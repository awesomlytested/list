{"repo":"GoogleChrome/workbox","url":"https://github.com/GoogleChrome/workbox","branch":"v6","configs":[{"package":"workbox","lang":"js","dir":"test","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should have top a level module for every export in index.mjs (and vise-versa)","suites":["[all] Window and SW packages"],"updatePoint":{"line":32,"column":83},"line":32,"code":"  it(`should have top a level module for every export in index.mjs (and vise-versa)`, async function () {\n    for (const pkg of windowAndSWPackages) {\n      const packagePath = path.join(__dirname, '..', '..', '..', 'packages', pkg.name); // TODO(philipwalton): remove this once all packages are converted to\n      // typescript or typescript adds `.mjs` support.\n\n      const ext = 'types' in pkg ? 'js' : 'mjs';\n      const indexFile = path.join(packagePath, `index.${ext}`);\n      const indexContents = await fs.readFile(indexFile, 'utf-8'); // Use the acorn parser to generate a list of named exports.\n\n      const namedExports = [];\n      const indexAST = acorn.parse(indexContents, {\n        ecmaVersion: 6,\n        sourceType: 'module'\n      });\n\n      for (const node of indexAST.body) {\n        if (node.type === 'ExportDefaultDeclaration') {\n          throw new Error(`'index.${ext}' files cannot contain default exports`);\n        }\n\n        if (node.type === 'ExportNamedDeclaration') {\n          for (const specifier of node.specifiers) {\n            namedExports.push(specifier.exported.name);\n          }\n        }\n      } // Inspect the package directory to get a list of top-level, public\n      // module basenames.\n\n\n      const topLevelFiles = glob.sync(`*.${ext}`, {\n        ignore: ['index', 'types', '_types', '_version'].map(file => `${file}.${ext}`),\n        cwd: packagePath\n      }).map(file => path.basename(file, `.${ext}`)); // Assert there's a 1-to-1 mapping between exports and top-level files.\n\n      expect(namedExports.sort()).to.deep.equal(topLevelFiles.sort());\n    }\n  });","file":"all/node/test-exports.js","skipped":false,"dir":"test"},{"name":"should have top a level module for every export in _private.mjs (and vise-versa)","suites":["[all] Window and SW packages"],"updatePoint":{"line":69,"column":86},"line":69,"code":"  it(`should have top a level module for every export in _private.mjs (and vise-versa)`, async function () {\n    for (const pkg of windowAndSWPackages) {\n      // TODO(philipwalton): remove this once all packages are converted to\n      // typescript or typescript adds `.mjs` support.\n      const ext = 'types' in pkg ? 'js' : 'mjs';\n      const packagePath = path.join(__dirname, '..', '..', '..', 'packages', pkg.name);\n      const privateFile = path.join(packagePath, `_private.${ext}`); // Only some packages have a `_private.mjs` module.\n\n      if (!fs.existsSync(privateFile)) {\n        continue;\n      }\n\n      const privateContents = await fs.readFile(privateFile, 'utf-8'); // Use the acorn parser to generate a list of named exports.\n\n      const namedExports = [];\n      const indexAST = acorn.parse(privateContents, {\n        ecmaVersion: 6,\n        sourceType: 'module'\n      });\n\n      for (const node of indexAST.body) {\n        if (node.type === 'ExportDefaultDeclaration') {\n          throw new Error(`'_private.${ext}' files cannot contain default exports`);\n        }\n\n        if (node.type === 'ExportNamedDeclaration') {\n          if (node.specifiers.length === 0) {\n            throw new Error(`'_private.${ext}' files may only contain a single, named-export block`);\n          }\n\n          for (const specifier of node.specifiers) {\n            namedExports.push(specifier.exported.name);\n          }\n        }\n      } // Inspect the package directory to get a list of top-level, public\n      // module basenames.\n\n\n      const privateDirectoryPath = path.join(packagePath, '_private');\n      const topLevelFiles = glob.sync(`*.${ext}`, {\n        cwd: privateDirectoryPath\n      }).map(file => path.basename(file, `.${ext}`)); // Assert there's a 1-to-1 mapping between exports and top-level files.\n\n      expect(namedExports.sort()).to.deep.equal(topLevelFiles.sort());\n    }\n  });","file":"all/node/test-exports.js","skipped":false,"dir":"test"},{"name":"should run JSDocs and have no unexpected results","suites":["[all] JSDocs"],"updatePoint":{"line":23,"column":54},"line":23,"code":"  it('should run JSDocs and have no unexpected results', async function () {\n    // Windows is super unhappy with the JSDocs build pipeline.\n    // With gulp.cmd in spawn, the query string used by the baseline template\n    // causes issues.\n    if (process.platform === 'win32') {\n      this.skip();\n      return;\n    }\n\n    this.timeout(60 * 1000);\n    const projectRoot = upath.join(__dirname, '..', '..', '..');\n    const docsPath = upath.join(projectRoot, 'docs');\n    await docs_build();\n    const docs = glob.sync('*.html', {\n      cwd: docsPath\n    }); // global.html is only added when the docs have stray global values.\n\n    expect(docs.includes('global.html'), `'global.html' should not be present in ${docsPath}`).to.be.false; // On some occasions, module.exports can leak into JSDocs, and breaks\n    // into the final template.\n\n    const indexAllHTML = await fse.readFile(upath.join(docsPath, 'index-all.html'), 'utf8');\n    expect(indexAllHTML.includes('<a href=\"module.html#.exports\">module.exports</a>'), `'module.exports' was found in index-all.html`).to.be.false; // We document this private method because we expect developers to\n    // override it in their extending classes.\n\n    const privateMethodAllowlist = ['_handle']; // string.matchAll() isn't supported before node v12...\n\n    const regexp = /<a href=\"([^\"]+)\">/g;\n    let match;\n\n    while ((match = regexp.exec(indexAllHTML)) !== null) {\n      const href = match[1];\n\n      if (href.includes('#_') && !privateMethodAllowlist.some(allow => href.endsWith(allow))) {\n        throw new Error(`Private method found in JSDocs: ${href}`);\n      }\n    }\n  });","file":"all/node/test-jsdocs.js","skipped":false,"dir":"test"},{"name":"should expose correct main, browser and module fields","suites":["[all] Test package.json"],"updatePoint":{"line":31,"column":59},"line":31,"code":"  it(`should expose correct main, browser and module fields`, function () {\n    const packageFiles = glob.sync('packages/**/package.json', {\n      ignore: ['packages/*/node_modules/**/*'],\n      cwd: upath.join(__dirname, '..', '..', '..'),\n      absolute: true\n    });\n    packageFiles.forEach(packagePath => {\n      const pkg = require(packagePath);\n\n      switch (pkg.workbox.packageType) {\n        case 'sw':\n          {\n            const propertiesToCheck = ['main', 'module'];\n            propertiesToCheck.forEach(propertyName => {\n              if (!pkg[propertyName]) {\n                throw new Error(`The package.json at '${upath.relative(process.cwd(), packagePath)}' isn't exposing a '${propertyName}' property`);\n              }\n\n              const fullPath = upath.join(upath.dirname(packagePath), pkg[propertyName]);\n\n              if (!fs.existsSync(fullPath)) {\n                throw new Error(`${upath.relative(process.cwd(), packagePath)} has an invalid '${propertyName}' property: '${pkg[propertyName]}'`);\n              }\n            });\n            break;\n          }\n\n        case 'window':\n          {\n            break;\n          }\n\n        case 'node':\n          {\n            break;\n          }\n\n        case 'node_ts':\n          {\n            break;\n          }\n\n        default:\n          throw new Error(`Unknown package.json workbox.packageType: '${pkg.workbox.packageType}' in ${upath.relative(process.cwd(), packagePath)}`);\n      }\n    });\n  });","file":"all/node/test-package.js","skipped":false,"dir":"test"},{"name":"should import _version.mjs in each .mjs file","suites":["[all] Test package.json"],"updatePoint":{"line":78,"column":50},"line":78,"code":"  it(`should import _version.mjs in each .mjs file`, function () {\n    // Find directories with package.json file\n    const packageFiles = glob.sync('packages/*/package.json', {\n      ignore: ['packages/*/node_modules/**/*'],\n      cwd: upath.join(__dirname, '..', '..', '..'),\n      absolute: true\n    });\n    packageFiles.forEach(packagePath => {\n      // skip non-sw modules\n      const pkg = require(packagePath);\n\n      if (pkg.workbox.packageType !== 'sw') {\n        return;\n      } // TODO(philipwalton): remove this once all packages are converted to\n      // typescript or typescript adds `.mjs` support.\n\n\n      const ext = 'types' in pkg ? 'js' : 'mjs'; // Glob for all js and mjs files in the package\n\n      const packageName = pkgPathToName(upath.dirname(packagePath));\n      const packageFiles = glob.sync(`packages/${packageName}/**/*.${ext}`, {\n        ignore: ['packages/*/node_modules/**/*', `packages/*/_version.${ext}`, `packages/*/${constants.PACKAGE_BUILD_DIRNAME}/**/*`],\n        cwd: upath.join(__dirname, '..', '..', '..'),\n        absolute: true\n      });\n      const importRegex = new RegExp(`import\\\\s+'[./]+_version\\\\.${ext}';`); // Find the version in each file.\n\n      packageFiles.forEach(filePath => {\n        const fileContents = fs.readFileSync(filePath).toString();\n        const results = importRegex.exec(fileContents);\n\n        if (!results) {\n          throw new Error(`Unable to find the workbox version in '${upath.relative(process.cwd(), filePath)}'`);\n        }\n      });\n    });\n  });","file":"all/node/test-package.js","skipped":false,"dir":"test"},{"name":"should contain the file version","suites":["[all] Test package.json"],"updatePoint":{"line":115,"column":37},"line":115,"code":"  it(`should contain the file version`, function () {\n    const versionRegex = /['|\"]workbox:((?:[^:'\"]*|:)*)['|\"]/; // Find directories with package.json file\n\n    const packageFiles = glob.sync('packages/*/package.json', {\n      ignore: ['packages/*/node_modules/**/*'],\n      cwd: upath.join(__dirname, '..', '..', '..'),\n      absolute: true\n    });\n    packageFiles.forEach(packagePath => {\n      // skip non-browser modules\n      const pkg = require(packagePath);\n\n      if (pkg.workbox.packageType !== 'sw') {\n        return;\n      } // Glob for all js and mjs files in the package\n\n\n      const packageName = pkgPathToName(upath.dirname(packagePath));\n      const packageFiles = glob.sync(`packages/${packageName}/${constants.PACKAGE_BUILD_DIRNAME}/**/*.{js,mjs}`, {\n        ignore: ['packages/*/node_modules/**/*'],\n        cwd: upath.join(__dirname, '..', '..', '..'),\n        absolute: true\n      }); // Find the version in each file.\n\n      packageFiles.forEach(filePath => {\n        const fileContents = fs.readFileSync(filePath).toString();\n        const results = versionRegex.exec(fileContents);\n\n        if (!results) {\n          throw new Error(`Unable to find the workbox version in '${upath.relative(process.cwd(), filePath)}'`);\n        }\n\n        const metadata = results[1].split(':');\n\n        try {\n          expect(metadata[0]).to.equal(pkg.name.replace('workbox-', ''));\n          expect(metadata[1]).to.equal(pkg.version);\n        } catch (err) {\n          throw new Error(`Invalid file version ${filePath}: ${metadata}`);\n        }\n      });\n    });\n  });","file":"all/node/test-package.js","skipped":false,"dir":"test"},{"name":"should have correct details in _version.mjs","suites":["[all] Test package.json"],"updatePoint":{"line":158,"column":49},"line":158,"code":"  it(`should have correct details in _version.mjs`, function () {\n    const versionRegex = /['|\"]workbox:((?:[^:'\"]*|:)*)['|\"]/; // Find directories with package.json file\n\n    const packageFiles = glob.sync('packages/*/package.json', {\n      ignore: ['packages/*/node_modules/**/*'],\n      cwd: upath.join(__dirname, '..', '..', '..'),\n      absolute: true\n    });\n    packageFiles.forEach(packagePath => {\n      // skip non-browser modules\n      const pkg = require(packagePath);\n\n      if (pkg.workbox.packageType !== 'sw') {\n        return;\n      } // TODO(philipwalton): remove this once all packages are converted to\n      // typescript or typescript adds `.mjs` support.\n\n\n      const ext = 'types' in pkg ? 'js' : 'mjs';\n      const packageName = pkgPathToName(upath.dirname(packagePath));\n      const versionFiles = glob.sync(`packages/${packageName}/_version.${ext}`, {\n        ignore: ['packages/*/node_modules/**/*'],\n        cwd: upath.join(__dirname, '..', '..', '..'),\n        absolute: true\n      }); // Find the version in each file.\n\n      versionFiles.forEach(filePath => {\n        const fileContents = fs.readFileSync(filePath).toString();\n        const results = versionRegex.exec(fileContents);\n\n        if (!results) {\n          throw new Error(`Unable to find the workbox version in '${upath.relative(process.cwd(), filePath)}'`);\n        }\n\n        const metadata = results[1].split(':');\n\n        try {\n          expect(metadata[0]).to.equal(pkg.name.replace('workbox-', ''));\n          expect(metadata[1]).to.equal(pkg.version);\n        } catch (err) {\n          throw new Error(`Invalid file version ${filePath}: ${metadata}`);\n        }\n      });\n    });\n  });","file":"all/node/test-package.js","skipped":false,"dir":"test"},{"name":"should only use a namespace that matches its package name","suites":["[all] Test package.json"],"updatePoint":{"line":203,"column":63},"line":203,"code":"  it(`should only use a namespace that matches its package name`, function () {\n    const pkgs = getPackages({\n      type: 'sw'\n    });\n\n    for (const pkg of pkgs) {\n      // These rules don't apply to workbox-sw\n      if (pkg.name === 'workbox-sw') continue; // Remove the `workbox-` prefix.\n\n      const pkgNameSuffix = pkg.name.replace(/^workbox-/, ''); // Remvoe the `workbox.` prefix.\n\n      const pkgNamespaceSuffix = pkg.workbox.browserNamespace.replace(/^workbox\\./, '');\n\n      if (camelCase(pkgNameSuffix) !== pkgNamespaceSuffix) {\n        throw new Error(ol`Invalid browser namespace:\n            ${pkg.workbox.browserNamespace}. The browser namespace must include\n            the package name camelCased (${camelCase(pkgNameSuffix)}).`);\n      }\n    }\n  });","file":"all/node/test-package.js","skipped":false,"dir":"test"},{"name":"should not have files with \"console\" or \"%cworwbox\"","suites":["[all] prod builds"],"updatePoint":{"line":28,"column":57},"line":28,"code":"  it(`should not have files with \"console\" or \"%cworwbox\"`, function () {\n    const invalidFiles = [];\n    buildFiles.forEach(filePath => {\n      const fileContents = fse.readFileSync(filePath).toString();\n\n      if (fileContents.indexOf(`console`) > -1 && // See https://github.com/GoogleChrome/workbox/issues/2259\n      !filePath.includes('workbox-precaching') || fileContents.indexOf(`%cworkbox`) > -1) {\n        invalidFiles.push(filePath);\n      }\n    });\n\n    if (invalidFiles.length > 0) {\n      logHelper.error(`Files with 'console' in them\\n`, JSON.stringify(invalidFiles, null, 2));\n      throw new Error(oneLine`\n        Found ${invalidFiles.length} files with \"console\" or \"%cworkbox\" in\n        the final build. Please ensure all 'logger' calls are wrapped in a\n        \"if (process.env.NODE_ENV !== 'production') {...}\" conditional.\n      `);\n    }\n  });","file":"all/node/test-prod-builds.js","skipped":false,"dir":"test"},{"name":"should not have files with hasOwnProperty","suites":["[all] prod builds"],"updatePoint":{"line":48,"column":47},"line":48,"code":"  it(`should not have files with hasOwnProperty`, function () {\n    const invalidFiles = [];\n    buildFiles.forEach(filePath => {\n      const fileContents = fse.readFileSync(filePath).toString();\n\n      if (fileContents.indexOf(`.hasOwnProperty('default')`) !== -1) {\n        invalidFiles.push(filePath);\n      }\n    });\n\n    if (invalidFiles.length > 0) {\n      logHelper.error(`Files with 'hasOwnProperty('default')' in them\\n`, JSON.stringify(invalidFiles, null, 2));\n      throw new Error(oneLine`\n        Found ${invalidFiles.length} files with \"hasOwnProperty('default')\"\n        in the final build. Please convert these to named exports to be friendly\n        to Rollup.\n      `);\n    }\n  });","file":"all/node/test-prod-builds.js","skipped":false,"dir":"test"},{"name":"should install  using yarn","suites":["[all] Yarn Installation"],"updatePoint":{"line":22,"column":53},"line":22,"code":"    it(`should install ${packageToInstall} using yarn`, async function () {\n      this.timeout(5 * 60 * 1000);\n\n      try {\n        const packagePath = upath.resolve('packages', packageToInstall);\n        await execa('yarn', ['add', packagePath], {\n          cwd: temporaryDirectory\n        });\n      } catch (error) {\n        if (error.code === 'ENOENT') {\n          // Skip the test if yarn isn't installed.\n          // (It will always be installed on GitHub Actions.)\n          this.skip();\n        } else {\n          throw error;\n        }\n      }\n    });","file":"all/node/test-yarn-installation.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-background-sync]"],"updatePoint":{"line":24,"column":30},"line":24,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-background-sync/sw/');\n  });","file":"workbox-background-sync/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page with service worker","suites":["[workbox-background-sync] Load and use Background Sync"],"updatePoint":{"line":39,"column":44},"line":39,"code":"  it(`should load a page with service worker`, async function () {\n    // Load the page and wait for the first service worker to register and activate.\n    await webdriver.get(testingURL);\n    await activateAndControlSW(swURL);\n    const url = `/test/workbox-background-sync/static/basic-example/example.txt`;\n    const err = await webdriver.executeAsyncScript((url, cb) => {\n      return fetch(url).then(() => cb()).catch(err => cb(err.message));\n    }, url);\n    expect(err).to.not.exist;\n    await waitUntil(() => {\n      const count = requestCounter.getURLCount(url);\n      return count > 0;\n    }, 20, 500);\n  });","file":"workbox-background-sync/integration/test-all.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-broadcast-update]"],"updatePoint":{"line":30,"column":30},"line":30,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-broadcast-update/sw/');\n  });","file":"workbox-broadcast-update/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should broadcast a message when there's a cache update to a regular request","suites":["[workbox-broadcast-update] Plugin"],"updatePoint":{"line":44,"column":81},"line":44,"code":"  it(`should broadcast a message when there's a cache update to a regular request`, async function () {\n    // Fetch `apiURL`, which should put it in the cache (but not trigger an update)\n    const err1 = await webdriver.executeAsyncScript((apiURL, cb) => {\n      fetch(apiURL).then(() => cb()).catch(err => cb(err.message));\n    }, apiURL);\n    expect(err1).to.not.exist; // Fetch `apiURL` again, which should trigger an update message.\n\n    const err2 = await webdriver.executeAsyncScript((apiURL, cb) => {\n      fetch(apiURL).then(() => cb()).catch(err => cb(err.message));\n    }, apiURL);\n    expect(err2).to.not.exist;\n    await webdriver.wait(() => {\n      return webdriver.executeScript(() => {\n        return window.__messages.length > 0;\n      });\n    });\n    const messages = await webdriver.executeScript(() => {\n      return window.__messages;\n    });\n    expect(messages.length).to.equal(1);\n    expect(messages[0]).to.deep.equal({\n      type: 'CACHE_UPDATED',\n      meta: 'workbox-broadcast-update',\n      payload: {\n        cacheName: 'bcu-integration-test',\n        updatedURL: apiURL\n      }\n    });\n  });","file":"workbox-broadcast-update/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should broadcast a message when there's a cache update to a navigation request","suites":["[workbox-broadcast-update] Plugin"],"updatePoint":{"line":73,"column":84},"line":73,"code":"  it(`should broadcast a message when there's a cache update to a navigation request`, async function () {\n    templateData.assign({\n      title: 'Broadcast Cache Update Test',\n      body: 'Second test, initial body.',\n      script: `\n        window.__messages = [];\n        navigator.serviceWorker.addEventListener('message', (event) => {\n          window.__messages.push(event.data);\n        });\n      `\n    });\n    const dynamicPageURL = testingURL + 'integration.html.njk?second'; // Navigate to a dynamic page whose content can be updated from with this\n    // test, and wait until the cache is populated.\n\n    await webdriver.get(dynamicPageURL);\n    await webdriver.wait(async () => {\n      return webdriver.executeAsyncScript(async (url, cb) => {\n        cb(await caches.match(url));\n      }, dynamicPageURL);\n    }); // Update the template data with new content,\n    // then refresh and wait until the update message is received.\n\n    templateData.assign({\n      body: 'Second test, with and updated body.'\n    });\n    await webdriver.get(webdriver.getCurrentUrl());\n    await webdriver.wait(() => {\n      return webdriver.executeScript(() => {\n        return window.__messages.length > 0;\n      });\n    });\n    const messages = await webdriver.executeScript(() => {\n      return window.__messages;\n    });\n    expect(messages.length).to.equal(1);\n    expect(messages[0]).to.deep.equal({\n      type: 'CACHE_UPDATED',\n      meta: 'workbox-broadcast-update',\n      payload: {\n        cacheName: 'bcu-integration-test',\n        updatedURL: dynamicPageURL\n      }\n    });\n  });","file":"workbox-broadcast-update/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should broadcast a message to all open window clients by default","suites":["[workbox-broadcast-update] Plugin"],"updatePoint":{"line":117,"column":70},"line":117,"code":"  it(`should broadcast a message to all open window clients by default`, async function () {\n    const iframeManager = new IframeManager(webdriver);\n    templateData.assign({\n      title: 'Broadcast Cache Update Test',\n      body: 'Third test, initial body.',\n      script: `\n        window.__messages = [];\n        navigator.serviceWorker.addEventListener('message', (event) => {\n          window.__messages.push(event.data);\n        });\n      `\n    });\n    const dynamicPageURL = testingURL + 'integration.html.njk?third'; // Navigate to a dynamic page whose content can be updated from with this\n    // test, and wait until the cache is populated.\n\n    await webdriver.get(dynamicPageURL);\n    await webdriver.wait(async () => {\n      return webdriver.executeAsyncScript(async (url, cb) => {\n        cb(await caches.match(url));\n      }, dynamicPageURL);\n    }); // Update the template data and open an iframe to trigger the cache update.\n\n    templateData.assign({\n      body: 'Third test, with an updated body.'\n    });\n    await iframeManager.createIframeClient(dynamicPageURL);\n    await webdriver.wait(() => {\n      return webdriver.executeScript(() => {\n        return window.__messages.length > 0;\n      });\n    });\n    const tab1Messages = await webdriver.executeScript(() => {\n      return window.__messages;\n    });\n    expect(tab1Messages).to.eql([{\n      type: 'CACHE_UPDATED',\n      meta: 'workbox-broadcast-update',\n      payload: {\n        cacheName: 'bcu-integration-test',\n        updatedURL: dynamicPageURL\n      }\n    }]);\n  });","file":"workbox-broadcast-update/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should only broadcast a message to the client that made the request when notifyAllClients is false","suites":["[workbox-broadcast-update] Plugin"],"updatePoint":{"line":160,"column":104},"line":160,"code":"  it(`should only broadcast a message to the client that made the request when notifyAllClients is false`, async function () {\n    const url = `${apiURL}?notifyAllClientsTest`;\n    const iframeManager = new IframeManager(webdriver);\n    await webdriver.get(testingURL);\n    await webdriver.executeAsyncScript((url, cb) => {\n      fetch(url).then(() => cb()).catch(err => cb(err.message));\n    }, url);\n    const iframeClient = await iframeManager.createIframeClient(testingURL);\n    await iframeClient.executeAsyncScript(`fetch(${JSON.stringify(url)})`);\n    await iframeClient.wait('window.__messages.length > 0');\n    const populatedMessages = await iframeClient.executeAsyncScript('window.__messages');\n    expect(populatedMessages).to.eql([{\n      type: 'CACHE_UPDATED',\n      meta: 'workbox-broadcast-update',\n      payload: {\n        cacheName: 'bcu-integration-test',\n        updatedURL: url\n      }\n    }]);\n    const unpopulatedMessages = await webdriver.executeScript(() => {\n      return window.__messages;\n    });\n    expect(unpopulatedMessages).to.be.empty;\n  });","file":"workbox-broadcast-update/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should have required dependencies","suites":["[workbox-build] Test Dependencies"],"updatePoint":{"line":13,"column":39},"line":13,"code":"  it(`should have required dependencies`, function () {\n    return new Promise((resolve, reject) => {\n      depcheck(upath.join(__dirname, '..', '..', '..', 'packages', 'workbox-build'), {\n        ignoreDirs: ['test', 'build', 'demo'],\n        ignoreMatches: ['@babel/preset-env', '@babel/runtime', 'type-fest', 'workbox-background-sync', 'workbox-broadcast-update', 'workbox-cacheable-response', 'workbox-core', 'workbox-expiration', 'workbox-google-analytics', 'workbox-navigation-preload', 'workbox-precaching', 'workbox-range-requests', 'workbox-recipes', 'workbox-routing', 'workbox-strategies', 'workbox-streams', 'workbox-sw', 'workbox-window']\n      }, unusedDeps => {\n        if (unusedDeps.dependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.dependencies)}`));\n        }\n\n        if (unusedDeps.devDependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.devDependencies)}`));\n        }\n\n        if (Object.keys(unusedDeps.missing).length > 0) {\n          return reject(new Error(`Dependencies missing from package.json: ${JSON.stringify(unusedDeps.missing)}`));\n        }\n\n        resolve();\n      });\n    });\n  });","file":"workbox-build/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should have no devDependencies","suites":["[workbox-build] Test Dependencies"],"updatePoint":{"line":35,"column":36},"line":35,"code":"  it(`should have no devDependencies`, function () {\n    // This test exists because there have been a number of situations where\n    // dependencies have been used from the top level project and NOT from\n    // this module itself. So dependencies are checked above and devDependencies\n    // can be put in top level.\n    const pkg = require('../../../packages/workbox-build/package.json');\n\n    if (pkg.devDependencies && Object.keys(pkg.devDependencies) > 0) {\n      throw new Error('No devDependencies in this module.');\n    }\n  });","file":"workbox-build/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should fail validation when '' is missing","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] required parameters"],"updatePoint":{"line":53,"column":67},"line":53,"code":"      it(`should fail validation when '${requiredParam}' is missing`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        delete options[requiredParam];\n        await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, requiredParam);\n      });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should fail validation when '' is present","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] unsupported parameters"],"updatePoint":{"line":62,"column":70},"line":62,"code":"      it(`should fail validation when '${unsupportedParam}' is present`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        options[unsupportedParam] = unsupportedParam;\n        await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, unsupportedParam);\n      });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should fail validation when '' is an unexpected value","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] invalid parameter values"],"updatePoint":{"line":71,"column":71},"line":71,"code":"      it(`should fail validation when '${param}' is an unexpected value`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n\n        options[param] = () => {};\n\n        await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, param);\n      });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when there are no manifest entries or runtimeCaching","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] invalid parameter values"],"updatePoint":{"line":80,"column":74},"line":80,"code":"    it(`should reject when there are no manifest entries or runtimeCaching`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS); // This temporary directory will be empty.\n\n      options.globDirectory = tempy.directory();\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(errors['no-manifest-entries-or-runtime-caching']);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":88,"column":72},"line":88,"code":"    it(`should use defaults when all the required parameters are present`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          __WB_DISABLE_DEV_LOGS: undefined,\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should include the versioning strings in the generated bundle","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":132,"column":69},"line":132,"code":"    it(`should include the versioning strings in the generated bundle`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        inlineWorkboxRuntime: true\n      });\n      const {\n        count,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6);\n      const contents = await fse.readFile(swDest, 'utf8'); // This isn't the exact string, but it's close enough.\n\n      expect(contents).to.include(`workbox:core:`);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should disable logging when disableDevLogs is set to true","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":149,"column":65},"line":149,"code":"    it(`should disable logging when disableDevLogs is set to true`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        disableDevLogs: true,\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          __WB_DISABLE_DEV_LOGS: true,\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with additional importScripts","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":194,"column":103},"line":194,"code":"    it(`should use defaults when all the required parameters are present, with additional importScripts`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const importScripts = ['manifest.js'];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        importScripts,\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/], [...importScripts]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with additional configuration","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":239,"column":103},"line":239,"code":"    it(`should use defaults when all the required parameters are present, with additional configuration`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const directoryIndex = 'test.html';\n      const ignoreURLParametersMatching = [/test1/, /test2/];\n      const cacheId = 'test';\n      const additionalOptions = {\n        cacheId,\n        directoryIndex,\n        ignoreURLParametersMatching,\n        clientsClaim: true,\n        skipWaiting: true\n      };\n      const options = Object.assign({}, BASE_OPTIONS, additionalOptions, {\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          clientsClaim: [[]],\n          skipWaiting: [[]],\n          setCacheNameDetails: [[{\n            prefix: cacheId\n          }]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {\n            directoryIndex,\n            ignoreURLParametersMatching\n          }]]\n        },\n        addEventListenerValidation: addEventListenerStub => {\n          // When skipWaiting is true, the 'message' addEventListener shouldn't be called.\n          expect(addEventListenerStub.called).to.be.false;\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with additionalManifestEntries","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":304,"column":104},"line":304,"code":"    it(`should use defaults when all the required parameters are present, with additionalManifestEntries`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        additionalManifestEntries: ['/one', {\n          url: '/two',\n          revision: null\n        }, {\n          url: '/three',\n          revision: '333'\n        }, // See https://github.com/GoogleChrome/workbox/issues/2558\n        {\n          url: '/four',\n          revision: '123',\n          integrity: '456'\n        }],\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options); // The string additionalManifestEntries entry should lead to one warning.\n\n      expect(warnings).to.have.length(1);\n      expect(count).to.eql(10); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            revision: null,\n            url: '/one'\n          }, {\n            revision: null,\n            url: '/two'\n          }, {\n            revision: '333',\n            url: '/three'\n          }, {\n            url: '/four',\n            revision: '123',\n            integrity: '456'\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should add a 'message' event listener when 'skipWaiting: false'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":373,"column":71},"line":373,"code":"    it(`should add a 'message' event listener when 'skipWaiting: false'`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const additionalOptions = {\n        skipWaiting: false\n      };\n      const options = Object.assign({}, BASE_OPTIONS, additionalOptions, {\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        },\n        addEventListenerValidation: addEventListenerStub => {\n          expect(addEventListenerStub.calledOnce).to.be.true;\n          expect(addEventListenerStub.firstCall.args[0]).to.eql('message'); // This isn't the *cleanest* possible way of testing the message event\n          // handler, but given the constraints of this node-based environment,\n          // it seems the most effective way to ensure the right code gets run.\n\n          expect(addEventListenerStub.firstCall.args[1].toString()).to.eql(`event => {\\n    if (event.data && event.data.type === 'SKIP_WAITING') {\\n      self.skipWaiting();\\n    }\\n  }`);\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with 'navigateFallback'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":427,"column":97},"line":427,"code":"    it(`should use defaults when all the required parameters are present, with 'navigateFallback'`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const navigateFallback = 'test.html';\n      const navigateFallbackDenylist = [/test1/, /test2/];\n      const navigateFallbackAllowlist = [/test3/, /test4/];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        navigateFallback,\n        navigateFallbackDenylist,\n        navigateFallbackAllowlist,\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          createHandlerBoundToURL: [[navigateFallback]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          registerRoute: [[{\n            name: 'NavigationRoute'\n          }]],\n          NavigationRoute: [['/urlWithCacheKey', {\n            denylist: navigateFallbackDenylist,\n            allowlist: navigateFallbackAllowlist\n          }]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with symlinks","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":484,"column":87},"line":484,"code":"    it(`should use defaults when all the required parameters are present, with symlinks`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const globDirectory = tempy.directory();\n      await fse.ensureSymlink(GLOB_DIR, upath.join(globDirectory, 'link'));\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globDirectory,\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'link/index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with 'globFollow' and  symlinks","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":530,"column":105},"line":530,"code":"    it(`should use defaults when all the required parameters are present, with 'globFollow' and  symlinks`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const globDirectory = tempy.directory();\n      await fse.ensureSymlink(GLOB_DIR, upath.join(globDirectory, 'link'));\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globDirectory,\n        globFollow: false,\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(4); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2707, 2629]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'link/index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'link/webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with 'offlineGoogleAnalytics' set to true","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":571,"column":115},"line":571,"code":"    it(`should use defaults when all the required parameters are present, with 'offlineGoogleAnalytics' set to true`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        offlineGoogleAnalytics: true\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          initialize: [[{}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with 'offlineGoogleAnalytics' set to a config","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":616,"column":119},"line":616,"code":"    it(`should use defaults when all the required parameters are present, with 'offlineGoogleAnalytics' set to a config`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        offlineGoogleAnalytics: {\n          parameterOverrides: {\n            cd1: 'offline'\n          }\n        }\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          initialize: [[{\n            parameterOverrides: {\n              cd1: 'offline'\n            }\n          }]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support using a swDest that includes a subdirectory","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":669,"column":66},"line":669,"code":"    it(`should support using a swDest that includes a subdirectory`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sub', 'directory', 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should inline the Workbox runtime when 'inlineWorkboxRuntime' is true","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":687,"column":77},"line":687,"code":"    it(`should inline the Workbox runtime when 'inlineWorkboxRuntime' is true`, async function () {\n      const outputDir = tempy.directory();\n      const swDest = upath.join(outputDir, 'sw.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        inlineWorkboxRuntime: true\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await confirmDirectoryContains(outputDir, filePaths); // We can't validate the generated sw.js file, unfortunately.\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'urlPattern' is missing from 'runtimeCaching'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":715,"column":72},"line":715,"code":"    it(`should reject when 'urlPattern' is missing from 'runtimeCaching'`, async function () {\n      const handler = STRING_HANDLER;\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching: [{\n          handler\n        }]\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, 'urlPattern');\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'handler' is missing from 'runtimeCaching'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":724,"column":69},"line":724,"code":"    it(`should reject when 'handler' is missing from 'runtimeCaching'`, async function () {\n      const urlPattern = REGEXP_URL_PATTERN;\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching: [{\n          urlPattern\n        }]\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, 'handler');\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'handler' is not a valid strategy name","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":733,"column":65},"line":733,"code":"    it(`should reject when 'handler' is not a valid strategy name`, async function () {\n      const urlPattern = REGEXP_URL_PATTERN;\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching: [{\n          urlPattern,\n          handler: 'invalid'\n        }]\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, 'handler');\n    }); // See https://github.com/GoogleChrome/workbox/issues/2078","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should not require using precaching","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":744,"column":43},"line":744,"code":"    it(`should not require using precaching`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const runtimeCaching = [{\n        urlPattern: STRING_URL_PATTERN,\n        handler: STRING_HANDLER\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      delete options.globDirectory;\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(0);\n      expect(size).to.eql(0);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [STRING_HANDLER]: [[]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          registerRoute: [[STRING_URL_PATTERN, {\n            name: STRING_HANDLER\n          }, DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support a single string 'urlPattern' and a string 'handler'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":776,"column":74},"line":776,"code":"    it(`should support a single string 'urlPattern' and a string 'handler'`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const runtimeCaching = [{\n        urlPattern: STRING_URL_PATTERN,\n        handler: STRING_HANDLER\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [STRING_HANDLER]: [[]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          registerRoute: [[STRING_URL_PATTERN, {\n            name: STRING_HANDLER\n          }, DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support a single function 'urlPattern' and a string 'handler'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":827,"column":76},"line":827,"code":"    it(`should support a single function 'urlPattern' and a string 'handler'`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const runtimeCaching = [{\n        urlPattern: FUNCTION_URL_PATTERN,\n        handler: STRING_HANDLER\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [STRING_HANDLER]: [[]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          // See https://github.com/chaijs/chai/issues/697\n          registerRoute: [['params => true', {\n            name: STRING_HANDLER\n          }, DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support setting individual 'options' each, for multiple 'runtimeCaching' entries","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":879,"column":95},"line":879,"code":"    it(`should support setting individual 'options' each, for multiple 'runtimeCaching' entries`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const firstRuntimeCachingOptions = {\n        cacheName: 'first-cache-name',\n        expiration: {\n          maxEntries: 1,\n          maxAgeSeconds: 1,\n          purgeOnQuotaError: false\n        }\n      };\n      const secondRuntimeCachingOptions = {\n        cacheName: 'second-cache-name',\n        cacheableResponse: {\n          headers: {\n            'X-Test': 'test'\n          },\n          statuses: [0, 200]\n        },\n        precacheFallback: {\n          fallbackURL: '/test'\n        }\n      };\n      const runtimeCaching = [{\n        urlPattern: REGEXP_URL_PATTERN,\n        handler: STRING_HANDLER,\n        options: firstRuntimeCachingOptions\n      }, {\n        urlPattern: REGEXP_URL_PATTERN,\n        handler: STRING_HANDLER,\n        options: secondRuntimeCachingOptions\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [STRING_HANDLER]: [[{\n            cacheName: firstRuntimeCachingOptions.cacheName,\n            plugins: [{}]\n          }], [{\n            cacheName: secondRuntimeCachingOptions.cacheName,\n            plugins: [{}, {}]\n          }]],\n          ExpirationPlugin: [[firstRuntimeCachingOptions.expiration]],\n          CacheableResponsePlugin: [[secondRuntimeCachingOptions.cacheableResponse]],\n          PrecacheFallbackPlugin: [[secondRuntimeCachingOptions.precacheFallback]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          registerRoute: [[REGEXP_URL_PATTERN, {\n            name: STRING_HANDLER\n          }, DEFAULT_METHOD], [REGEXP_URL_PATTERN, {\n            name: STRING_HANDLER\n          }, DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject with a ValidationError when 'networkTimeoutSeconds' is used and handler is not 'NetworkFirst'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":966,"column":115},"line":966,"code":"    it(`should reject with a ValidationError when 'networkTimeoutSeconds' is used and handler is not 'NetworkFirst'`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const runtimeCachingOptions = {\n        networkTimeoutSeconds: 1\n      };\n      const runtimeCaching = [{\n        urlPattern: REGEXP_URL_PATTERN,\n        handler: 'NetworkOnly',\n        options: runtimeCachingOptions\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(errors['invalid-network-timeout-seconds']);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support passing in a function when allowed","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":984,"column":57},"line":984,"code":"    it(`should support passing in a function when allowed`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n\n      const handler = () => {};\n\n      const urlPattern = () => {};\n\n      const runtimeCachingOptions = {\n        backgroundSync: {\n          name: 'test',\n          options: {\n            onSync: () => {}\n          }\n        },\n        plugins: [{\n          cachedResponseWillBeUsed: () => {}\n        }]\n      };\n      const runtimeCaching = [{\n        handler,\n        urlPattern,\n        options: runtimeCachingOptions\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [handler]: [[runtimeCachingOptions]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          registerRoute: [[urlPattern.toString(), handler.toString(), DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support 'networkTimeoutSeconds' when handler is 'NetworkFirst'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":1050,"column":77},"line":1050,"code":"    it(`should support 'networkTimeoutSeconds' when handler is 'NetworkFirst'`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const networkTimeoutSeconds = 1;\n      const handler = 'NetworkFirst';\n      const runtimeCachingOptions = {\n        networkTimeoutSeconds,\n        plugins: []\n      };\n      const runtimeCaching = [{\n        urlPattern: REGEXP_URL_PATTERN,\n        handler,\n        options: runtimeCachingOptions\n      }];\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [handler]: [[runtimeCachingOptions]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          registerRoute: [[REGEXP_URL_PATTERN, {\n            name: handler\n          }, DEFAULT_METHOD]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'options.expiration' is used without 'options.cacheName'","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":1108,"column":83},"line":1108,"code":"    it(`should reject when 'options.expiration' is used without 'options.cacheName'`, async function () {\n      const urlPattern = REGEXP_URL_PATTERN;\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching: [{\n          urlPattern,\n          handler: 'NetworkFirst',\n          options: {\n            expiration: {\n              maxEntries: 5\n            }\n          }\n        }]\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, errors['cache-name-required']);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should ignore swDest and workbox-*.js when generating manifest entries","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'runtimeCaching'"],"updatePoint":{"line":1123,"column":78},"line":1123,"code":"    it(`should ignore swDest and workbox-*.js when generating manifest entries`, async function () {\n      const tempDirectory = tempy.directory();\n      await fse.copy(BASE_OPTIONS.globDirectory, tempDirectory);\n      const swDest = upath.join(tempDirectory, 'service-worker.js');\n      await fse.createFile(swDest); // See https://rollupjs.org/guide/en/#outputchunkfilenames\n\n      await fse.createFile(upath.join(tempDirectory, 'workbox-abcd1234.js'));\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globDirectory: tempDirectory,\n        swDest\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'navigationPreload' is true and 'runtimeCaching' is undefined","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'navigationPreload'"],"updatePoint":{"line":1171,"column":88},"line":1171,"code":"    it(`should reject when 'navigationPreload' is true and 'runtimeCaching' is undefined`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        navigationPreload: true\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, errors['nav-preload-runtime-caching']);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should reject when 'navigationPreload' is true and 'runtimeCaching' is undefined","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'navigationPreload'"],"updatePoint":{"line":1177,"column":88},"line":1177,"code":"    it(`should reject when 'navigationPreload' is true and 'runtimeCaching' is undefined`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        runtimeCaching: undefined,\n        navigationPreload: true\n      });\n      await expect(generateSW(options)).to.eventually.be.rejectedWith(WorkboxConfigError, errors['nav-preload-runtime-caching']);\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should generate when 'navigationPreload' is true and 'runtimeCaching' is valid","suites":["[workbox-build] generate-sw.js (End to End)","[workbox-build] behavior with 'navigationPreload'"],"updatePoint":{"line":1184,"column":86},"line":1184,"code":"    it(`should generate when 'navigationPreload' is true and 'runtimeCaching' is valid`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const urlPattern = /test/;\n      const handler = 'CacheFirst';\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        runtimeCaching: [{\n          urlPattern,\n          handler\n        }],\n        navigationPreload: true\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await generateSW(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        swFile: swDest,\n        expectedMethodCalls: {\n          [handler]: [[]],\n          importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {}]],\n          enable: [[]],\n          registerRoute: [[urlPattern, {\n            name: handler\n          }, 'GET']]\n        }\n      });\n    });","file":"workbox-build/node/generate-sw.js","skipped":false,"dir":"test"},{"name":"should fail validation when '' is present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] unsupported parameters"],"updatePoint":{"line":43,"column":70},"line":43,"code":"      it(`should fail validation when '${unsupportedParam}' is present`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        options[unsupportedParam] = unsupportedParam;\n        await expect(getManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, unsupportedParam);\n      });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should fail validation when '' is an unexpected value","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] invalid parameter values"],"updatePoint":{"line":52,"column":71},"line":52,"code":"      it(`should fail validation when '${param}' is an unexpected value`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n\n        options[param] = () => {};\n\n        await expect(getManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, param);\n      });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":62,"column":72},"line":62,"code":"    it(`should use defaults when all the required parameters are present`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS);\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'index.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-1.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-2.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'styles/stylesheet-1.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'styles/stylesheet-2.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'webpackEntry.js',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, and 'globPatterns' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":94,"column":92},"line":94,"code":"    it(`should use defaults when all the required parameters, and 'globPatterns' are present`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globPatterns: ['**/*.html', '**/*.js']\n      });\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'index.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-1.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-2.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'webpackEntry.js',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(4); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2707, 2629]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, and 'globIgnores' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":122,"column":91},"line":122,"code":"    it(`should use defaults when all the required parameters, and 'globIgnores' are present`, async function () {\n      const options = Object.assign({\n        globIgnores: ['**/*.html', '**/*.js']\n      }, BASE_OPTIONS);\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'styles/stylesheet-1.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'styles/stylesheet-2.css',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(2); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([69, 75]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, 'globIgnores', and 'globPatterns' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":144,"column":107},"line":144,"code":"    it(`should use defaults when all the required parameters, 'globIgnores', and 'globPatterns' are present`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globPatterns: ['**/*.css', '**/*.js'],\n        globIgnores: ['node_modules/**/*', '**/*2*']\n      });\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'styles/stylesheet-1.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'webpackEntry.js',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(2); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([216, 219]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, and 'maximumFileSizeToCacheInBytes' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":167,"column":109},"line":167,"code":"    it(`should use defaults when all the required parameters, and 'maximumFileSizeToCacheInBytes' are present`, async function () {\n      const options = Object.assign({\n        maximumFileSizeToCacheInBytes: 50\n      }, BASE_OPTIONS);\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.have.lengthOf(2);\n      expect(manifestEntries).to.matchPattern([{\n        revision: /^[0-9a-f]{32}$/,\n        url: 'page-1.html'\n      }, {\n        revision: /^[0-9a-f]{32}$/,\n        url: 'page-2.html'\n      }, {\n        revision: /^[0-9a-f]{32}$/,\n        url: 'styles/stylesheet-1.css'\n      }, {\n        revision: /^[0-9a-f]{32}$/,\n        url: 'styles/stylesheet-2.css'\n      }]);\n      expect(count).to.eql(4); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([101, 109]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, and 'templatedURLs' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":195,"column":93},"line":195,"code":"    it(`should use defaults when all the required parameters, and 'templatedURLs' are present`, async function () {\n      const url1 = 'url1';\n      const url2 = 'url2';\n      const options = Object.assign({\n        templatedURLs: {\n          [url1]: ['**/*.html'],\n          [url2]: 'string dependency'\n        }\n      }, BASE_OPTIONS);\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'index.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-1.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'page-2.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'styles/stylesheet-1.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'styles/stylesheet-2.css',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'webpackEntry.js',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'url1',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'url2',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(8); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([5162, 5324]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters, and 'manifestTransforms' are present","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":240,"column":98},"line":240,"code":"    it(`should use defaults when all the required parameters, and 'manifestTransforms' are present`, async function () {\n      // This filters out all entries unless the url property includes the string '1'.\n      const transform1 = entries => {\n        const manifest = entries.filter(entry => {\n          return entry.url.includes('1');\n        });\n        return {\n          manifest\n        };\n      }; // This modifies all entries to prefix the url property with the string '/prefix/'.\n\n\n      const transform2 = entries => {\n        const manifest = entries.filter(entry => {\n          entry.url = `/prefix/${entry.url}`;\n          return entry;\n        });\n        return {\n          manifest\n        };\n      };\n\n      const options = Object.assign({\n        manifestTransforms: [transform1, transform2]\n      }, BASE_OPTIONS);\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: '/prefix/page-1.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: '/prefix/styles/stylesheet-1.css',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(2); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([50, 54]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, with 'globFollow' and symlinks","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] should generate a valid manifest when properly configured"],"updatePoint":{"line":283,"column":104},"line":283,"code":"    it(`should use defaults when all the required parameters are present, with 'globFollow' and symlinks`, async function () {\n      const globDirectory = tempy.directory();\n      await fse.ensureSymlink(SRC_DIR, upath.join(globDirectory, 'link'));\n      const options = Object.assign({}, BASE_OPTIONS, {\n        globDirectory,\n        globFollow: false\n      });\n      const {\n        count,\n        size,\n        manifestEntries,\n        warnings\n      } = await getManifest(options);\n      expect(warnings).to.be.empty;\n      expect(manifestEntries).to.matchPattern([{\n        url: 'link/index.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'link/page-1.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'link/page-2.html',\n        revision: /^[0-9a-f]{32}$/\n      }, {\n        url: 'link/webpackEntry.js',\n        revision: /^[0-9a-f]{32}$/\n      }]);\n      expect(count).to.eql(4); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2707, 2629]);\n    });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should fail validation when  is used","suites":["[workbox-build] get-manifest.js (End to End)","[workbox-build] removed options"],"updatePoint":{"line":327,"column":55},"line":327,"code":"      it(`should fail validation when ${option} is used`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS, {\n          [option]: value\n        });\n        await expect(getManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, option);\n      });","file":"workbox-build/node/get-manifest.js","skipped":false,"dir":"test"},{"name":"should reject when '' is missing","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] required parameters"],"updatePoint":{"line":51,"column":58},"line":51,"code":"      it(`should reject when '${requiredParam}' is missing`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        delete options[requiredParam];\n        await expect(injectManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, requiredParam);\n      });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should reject when '' is present","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] unsupported parameters"],"updatePoint":{"line":60,"column":61},"line":60,"code":"      it(`should reject when '${unsupportedParam}' is present`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        options[unsupportedParam] = unsupportedParam;\n        await expect(injectManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, unsupportedParam);\n      });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should reject when '' is null","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] invalid parameter values"],"updatePoint":{"line":69,"column":47},"line":69,"code":"      it(`should reject when '${param}' is null`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS);\n        options[param] = null;\n        await expect(injectManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, param);\n      });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should throw the expected error when 'swSrc' is invalid","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] runtime errors"],"updatePoint":{"line":77,"column":63},"line":77,"code":"    it(`should throw the expected error when 'swSrc' is invalid`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swSrc: 'DOES_NOT_EXIST'\n      });\n      await expect(injectManifest(options)).to.eventually.be.rejectedWith(errors['invalid-sw-src']);\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should throw the expected error when there is no match for 'injectionPoint'","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] runtime errors"],"updatePoint":{"line":83,"column":83},"line":83,"code":"    it(`should throw the expected error when there is no match for 'injectionPoint'`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swSrc: upath.join(SW_SRC_DIR, 'bad-no-injection.js')\n      });\n      await expect(injectManifest(options)).to.eventually.be.rejectedWith(errors['injection-point-not-found']);\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should throw the expected error when there is no match for 'injectionPoint' and 'swSrc' and 'swDest' are the same","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] runtime errors"],"updatePoint":{"line":89,"column":121},"line":89,"code":"    it(`should throw the expected error when there is no match for 'injectionPoint' and 'swSrc' and 'swDest' are the same`, async function () {\n      const swFile = upath.join(SW_SRC_DIR, 'bad-no-injection.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swSrc: swFile,\n        swDest: swFile\n      });\n      await expect(injectManifest(options)).to.eventually.be.rejectedWith(errors['same-src-and-dest']);\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should throw the expected error when there are multiple matches for 'injectionPoint'","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] runtime errors"],"updatePoint":{"line":97,"column":92},"line":97,"code":"    it(`should throw the expected error when there are multiple matches for 'injectionPoint'`, async function () {\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swSrc: upath.join(SW_SRC_DIR, 'bad-multiple-injection.js')\n      });\n      await expect(injectManifest(options)).to.eventually.be.rejectedWith(errors['multiple-injection-points']);\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":105,"column":72},"line":105,"code":"    it(`should use defaults when all the required parameters are present`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      expect(filePaths).to.have.members([upath.resolve(swDest)]);\n      await validateServiceWorkerRuntime({\n        entryPoint: 'injectManifest',\n        swFile: swDest,\n        expectedMethodCalls: {\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }]]]\n        }\n      });\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use absolute paths in the filePaths return value","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":149,"column":63},"line":149,"code":"    it(`should use absolute paths in the filePaths return value`, async function () {\n      // Deliberately use a relative path for swDest.\n      const swDest = upath.relative('.', tempy.file({\n        extension: 'js'\n      }));\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest\n      });\n      const {\n        filePaths,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty; // Use upath.resolve() to confirm that we get back an absolute path.\n\n      expect(filePaths).to.have.members([upath.resolve(swDest)]);\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, when workboxSW.precache() is called twice","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":165,"column":115},"line":165,"code":"    it(`should use defaults when all the required parameters are present, when workboxSW.precache() is called twice`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        swSrc: upath.join(SW_SRC_DIR, 'multiple-calls.js')\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      expect(filePaths).to.have.members([upath.resolve(swDest)]);\n      await validateServiceWorkerRuntime({\n        entryPoint: 'injectManifest',\n        swFile: swDest,\n        expectedMethodCalls: {\n          importScripts: [['./sample-import.js']],\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }]], [['/extra-assets/example.1234.css', '/extra-assets/example-2.1234.js']]]\n        }\n      });\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use defaults when all the required parameters are present, when a custom 'injectionPoint' is used","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":211,"column":112},"line":211,"code":"    it(`should use defaults when all the required parameters are present, when a custom 'injectionPoint' is used`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        injectionPoint: 'self.__custom_injection_point',\n        swSrc: upath.join(SW_SRC_DIR, 'custom-injection-point.js')\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      expect(filePaths).to.have.members([upath.resolve(swDest)]);\n      await validateServiceWorkerRuntime({\n        entryPoint: 'injectManifest',\n        swFile: swDest,\n        expectedMethodCalls: {\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }]]]\n        }\n      });\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support using the default 'injectionPoint' when precacheAndRoute() is called with options","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":257,"column":104},"line":257,"code":"    it(`should support using the default 'injectionPoint' when precacheAndRoute() is called with options`, async function () {\n      const swDest = tempy.file({\n        extension: 'js'\n      });\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        swSrc: upath.join(SW_SRC_DIR, 'precache-and-route-options.js')\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      expect(filePaths).to.have.members([upath.resolve(swDest)]);\n      await validateServiceWorkerRuntime({\n        entryPoint: 'injectManifest',\n        swFile: swDest,\n        expectedMethodCalls: {\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }], {\n            cleanURLs: true\n          }]]\n        }\n      });\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should ignore swSrc and swDest when generating manifest entries","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] writing a service worker file"],"updatePoint":{"line":304,"column":71},"line":304,"code":"    it(`should ignore swSrc and swDest when generating manifest entries`, async function () {\n      const tempDirectory = tempy.directory();\n      await fse.copy(BASE_OPTIONS.globDirectory, tempDirectory);\n      const swSrc = upath.join(tempDirectory, 'sw-src-service-worker.js');\n      await fse.copyFile(upath.join(SW_SRC_DIR, 'basic.js'), swSrc);\n      const swDest = upath.join(tempDirectory, 'sw-dest-service-worker.js');\n      await fse.createFile(swDest);\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swSrc,\n        swDest,\n        globDirectory: tempDirectory\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      await validateServiceWorkerRuntime({\n        entryPoint: 'injectManifest',\n        swFile: swDest,\n        expectedMethodCalls: {\n          precacheAndRoute: [[[{\n            url: 'index.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-1.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'page-2.html',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-1.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'styles/stylesheet-2.css',\n            revision: /^[0-9a-f]{32}$/\n          }, {\n            url: 'webpackEntry.js',\n            revision: /^[0-9a-f]{32}$/\n          }]]]\n        }\n      });\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should update the sourcemap to account for manifest injection","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":353,"column":69},"line":353,"code":"    it(`should update the sourcemap to account for manifest injection`, async function () {\n      const outputDir = tempy.directory();\n      const swSrc = upath.join(SW_SRC_DIR, 'basic-with-sourcemap.js.nolint');\n      const swDest = upath.join(outputDir, 'basic-with-sourcemap.js');\n      const sourcemapDest = upath.join(outputDir, 'basic-with-sourcemap.js.map');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        swSrc\n      });\n      const {\n        count,\n        filePaths,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]);\n      expect(filePaths).to.have.members([upath.resolve(swDest), sourcemapDest]);\n      const actualSourcemap = await fse.readJSON(sourcemapDest);\n      const expectedSourcemap = await fse.readJSON(upath.join(SW_SRC_DIR, '..', 'expected-source-map.js.map'));\n      expect(actualSourcemap).to.eql(expectedSourcemap); // We can't validate the SW file contents.\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not update the sourcemap if it uses a data: URL","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":377,"column":62},"line":377,"code":"    it(`should not update the sourcemap if it uses a data: URL`, async function () {\n      const outputDir = tempy.directory();\n      const swSrc = upath.join(SW_SRC_DIR, 'basic-with-sourcemap-data-url.js.nolint');\n      const swDest = upath.join(outputDir, 'basic-with-sourcemap.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        swSrc\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings).to.be.empty;\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]); // We can't validate the SW file contents.\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should perform injection, but report a warning if the sourcemap file can't be found","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":395,"column":91},"line":395,"code":"    it(`should perform injection, but report a warning if the sourcemap file can't be found`, async function () {\n      const outputDir = tempy.directory();\n      const swSrc = upath.join(SW_SRC_DIR, 'basic-with-invalid-sourcemap.js.nolint');\n      const swDest = upath.join(outputDir, 'basic-with-sourcemap.js');\n      const options = Object.assign({}, BASE_OPTIONS, {\n        swDest,\n        swSrc\n      });\n      const {\n        count,\n        size,\n        warnings\n      } = await injectManifest(options);\n      expect(warnings.length).to.eql(1);\n      expect(warnings[0]).to.include(errors['cant-find-sourcemap']);\n      expect(count).to.eql(6); // Line ending differences lead to different sizes on Windows.\n\n      expect(size).to.be.oneOf([2782, 2698]); // We can't validate the SW file contents.\n    });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should fail validation when  is used","suites":["[workbox-build] inject-manifest.js (End to End)","[workbox-build] removed options"],"updatePoint":{"line":427,"column":55},"line":427,"code":"      it(`should fail validation when ${option} is used`, async function () {\n        const options = Object.assign({}, BASE_OPTIONS, {\n          [option]: value\n        });\n        await expect(injectManifest(options)).to.eventually.be.rejectedWith(WorkboxConfigError, option);\n      });","file":"workbox-build/node/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not make any changes when additionalManifestEntries is empty","suites":["[workbox-build] lib/additional-manifest-entries-transform"],"updatePoint":{"line":26,"column":73},"line":26,"code":"  it(`should not make any changes when additionalManifestEntries is empty`, function () {\n    const transform = additionalManifestEntriesTransform([]);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/first',\n        revision: null\n      }],\n      warnings: []\n    });\n  });","file":"workbox-build/node/lib/additional-manifest-entries-transform.js","skipped":false,"dir":"test"},{"name":"should add the additionalManifestEntries to the end of the existing manifest","suites":["[workbox-build] lib/additional-manifest-entries-transform"],"updatePoint":{"line":36,"column":82},"line":36,"code":"  it(`should add the additionalManifestEntries to the end of the existing manifest`, function () {\n    const transform = additionalManifestEntriesTransform([{\n      url: '/second',\n      revision: null\n    }, {\n      url: '/third',\n      revision: null\n    }]);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/first',\n        revision: null\n      }, {\n        url: '/second',\n        size: 0,\n        revision: null\n      }, {\n        url: '/third',\n        size: 0,\n        revision: null\n      }],\n      warnings: []\n    });\n  });","file":"workbox-build/node/lib/additional-manifest-entries-transform.js","skipped":false,"dir":"test"},{"name":"should return a warning, along with the modified manifest, when additionalManifestEntries contains a string or an entry without revision","suites":["[workbox-build] lib/additional-manifest-entries-transform"],"updatePoint":{"line":60,"column":142},"line":60,"code":"  it(`should return a warning, along with the modified manifest, when additionalManifestEntries contains a string or an entry without revision`, function () {\n    const transform = additionalManifestEntriesTransform(['/second', {\n      url: '/third'\n    }]);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/first',\n        revision: null\n      }, {\n        url: '/second',\n        size: 0,\n        revision: null\n      }, {\n        url: '/third',\n        size: 0\n      }],\n      warnings: [errors['string-entry-warning'] + '\\n  - /second\\n  - /third\\n']\n    });\n  });","file":"workbox-build/node/lib/additional-manifest-entries-transform.js","skipped":false,"dir":"test"},{"name":"should pass 'babelPresetEnvTargets' to @babel/preset-env","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":68,"column":62},"line":68,"code":"  it(`should pass 'babelPresetEnvTargets' to @babel/preset-env`, async function () {\n    const babelPresetEnvTargets = ['target1', 'target2'];\n    await bundle({\n      babelPresetEnvTargets\n    }); // This is ugly, but necessary due to the way babel() is configured.\n\n    const babelParams = stubs['@rollup/plugin-babel'].babel.args[0][0];\n    expect(babelParams.presets[0][1].targets.browsers).to.eql(babelPresetEnvTargets);\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should use loadz0r and configure manualChunks when 'inlineWorkboxRuntime' is false","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":77,"column":88},"line":77,"code":"  it(`should use loadz0r and configure manualChunks when 'inlineWorkboxRuntime' is false`, async function () {\n    await bundle({\n      inlineWorkboxRuntime: false\n    });\n    expect(stubs.rollup.rollup.args[0][0].manualChunks).to.be.a('function');\n    expect(stubs['@surma/rollup-plugin-off-main-thread'].calledOnce).to.be.true;\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should not use loadz0r or configure manualChunks when 'inlineWorkboxRuntime' is true","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":84,"column":90},"line":84,"code":"  it(`should not use loadz0r or configure manualChunks when 'inlineWorkboxRuntime' is true`, async function () {\n    await bundle({\n      inlineWorkboxRuntime: true\n    });\n    expect(stubs.rollup.rollup.args[0][0].manualChunks).not.to.exist;\n    expect(stubs['@surma/rollup-plugin-off-main-thread'].notCalled).to.be.true;\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should replace NODE_ENV with the 'mode' value","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":91,"column":51},"line":91,"code":"  it(`should replace NODE_ENV with the 'mode' value`, async function () {\n    const mode = 'mode-value';\n    await bundle({\n      mode\n    });\n    expect(stubs['@rollup/plugin-replace'].args).to.eql([[{\n      'preventAssignment': true,\n      'process.env.NODE_ENV': `\"${mode}\"`\n    }]]);\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should use terser when 'mode' is 'production'","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":101,"column":51},"line":101,"code":"  it(`should use terser when 'mode' is 'production'`, async function () {\n    const mode = 'production';\n    await bundle({\n      mode\n    });\n    expect(stubs['rollup-plugin-terser'].terser.calledOnce).to.be.true;\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should not use terser when 'mode' is not 'production'","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":108,"column":59},"line":108,"code":"  it(`should not use terser when 'mode' is not 'production'`, async function () {\n    const mode = 'something-else';\n    await bundle({\n      mode\n    });\n    expect(stubs['rollup-plugin-terser'].terser.notCalled).to.be.true;\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should pass the 'sourcemap' parameter value through to Rollup","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":115,"column":67},"line":115,"code":"  it(`should pass the 'sourcemap' parameter value through to Rollup`, async function () {\n    const sourcemap = true;\n    await bundle({\n      sourcemap\n    });\n    expect(stubs.rollupStub.generate.args[0][0].sourcemap).to.eql(sourcemap);\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"should process the generated Rollup bundle into the expected return value","suites":["[workbox-build] lib/bundle"],"updatePoint":{"line":122,"column":79},"line":122,"code":"  it(`should process the generated Rollup bundle into the expected return value`, async function () {\n    const files = await bundle({});\n    expect(files).to.eql([{\n      contents: 'asset-source',\n      name: 'asset-filename'\n    }, {\n      contents: 'chunk1-code',\n      name: 'chunk1-filename'\n    }, {\n      contents: 'sourcemap-contents',\n      name: 'chunk2-filename.map'\n    }, {\n      contents: 'chunk2-code//# sourceMappingURL=chunk2-filename.map\\n',\n      name: 'chunk2-filename'\n    }]);\n  });","file":"workbox-build/node/lib/bundle.js","skipped":false,"dir":"test"},{"name":"getModuleURL() should throw when moduleName is undefined","suites":["[workbox-build] lib/cdn-utils.js"],"updatePoint":{"line":18,"column":62},"line":18,"code":"  it(`getModuleURL() should throw when moduleName is undefined`, function () {\n    expect(() => cdnUtils.getModuleURL()).to.throw(errors['no-module-name']);\n  });","file":"workbox-build/node/lib/cdn-utils.js","skipped":false,"dir":"test"},{"name":"getModuleURL('workbox-sw', 'dev') should throw","suites":["[workbox-build] lib/cdn-utils.js"],"updatePoint":{"line":21,"column":52},"line":21,"code":"  it(`getModuleURL('workbox-sw', 'dev') should throw`, function () {\n    expect(() => cdnUtils.getModuleURL('workbox-sw', 'dev')).to.throw('workbox-sw');\n  });","file":"workbox-build/node/lib/cdn-utils.js","skipped":false,"dir":"test"},{"name":"getModuleURL(moduleName) should return the expected URL","suites":["[workbox-build] lib/cdn-utils.js"],"updatePoint":{"line":24,"column":61},"line":24,"code":"  it(`getModuleURL(moduleName) should return the expected URL`, function () {\n    const moduleName = 'workbox-sw';\n    const url = cdnUtils.getModuleURL(moduleName);\n    expect(url.startsWith(CDN_ORIGIN)).to.be.true;\n    expect(url.includes(moduleName)).to.be.true;\n  });","file":"workbox-build/node/lib/cdn-utils.js","skipped":false,"dir":"test"},{"name":"getModuleURL('workbox-routing', buildType) should return the expected URL","suites":["[workbox-build] lib/cdn-utils.js"],"updatePoint":{"line":30,"column":79},"line":30,"code":"  it(`getModuleURL('workbox-routing', buildType) should return the expected URL`, function () {\n    const moduleName = 'workbox-routing';\n    const buildType = 'prod';\n    const url = cdnUtils.getModuleURL(moduleName, buildType);\n    expect(url.startsWith(CDN_ORIGIN)).to.be.true;\n    expect(url.includes(moduleName)).to.be.true;\n    expect(url.includes(buildType)).to.be.true;\n  });","file":"workbox-build/node/lib/cdn-utils.js","skipped":false,"dir":"test"},{"name":"should reject with an error when the copy fails","suites":["[workbox-build] lib/copy-workbox-libraries.js"],"updatePoint":{"line":24,"column":53},"line":24,"code":"  it(`should reject with an error when the copy fails`, async function () {\n    const {\n      copyWorkboxLibraries\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        ensureDir: sinon.stub().resolves(),\n        copy: sinon.stub().rejects('INJECTED_ERROR')\n      }\n    });\n\n    try {\n      await copyWorkboxLibraries(ABSOLUTE_DEST_DIRECTORY);\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['unable-to-copy-workbox-libraries']);\n    }\n  });","file":"workbox-build/node/lib/copy-workbox-libraries.js","skipped":false,"dir":"test"},{"name":"should resolve with the new directory name, using a destDir of ","suites":["[workbox-build] lib/copy-workbox-libraries.js"],"updatePoint":{"line":43,"column":81},"line":43,"code":"    it(`should resolve with the new directory name, using a destDir of ${destDir}`, async function () {\n      const copyStub = sinon.stub().resolves();\n      const ensureDirStub = sinon.stub().resolves();\n      const {\n        copyWorkboxLibraries\n      } = proxyquire(MODULE_PATH, {\n        'fs-extra': {\n          copy: copyStub,\n          ensureDir: ensureDirStub\n        }\n      });\n      const workboxDirectory = await copyWorkboxLibraries(destDir); // The workboxDirectory value is a relative path from destDir to the\n      // new directory. We check if ensureDir was called with the combined upath.\n\n      const expectedPath = upath.join(destDir, workboxDirectory);\n      expect(expectedPath).to.eql(ensureDirStub.args[0][0]); // The total number of package build directories that were copied:\n\n      expect(copyStub.callCount).to.eql(15);\n    });","file":"workbox-build/node/lib/copy-workbox-libraries.js","skipped":false,"dir":"test"},{"name":"should perform the expected escaping:  => ","suites":["[workbox-build] lib/copy-workbox-libraries.js"],"updatePoint":{"line":18,"column":71},"line":18,"code":"    it(`should perform the expected escaping: ${original} => ${escaped}`, async function () {\n      expect(escapeRegExp(original)).to.eql(escaped);\n    });","file":"workbox-build/node/lib/escape-regexp.js","skipped":false,"dir":"test"},{"name":"should return the expected composite details for a single file","suites":["[workbox-build] lib/get-composite-details.js"],"updatePoint":{"line":26,"column":68},"line":26,"code":"  it(`should return the expected composite details for a single file`, function () {\n    const details = getCompositeDetails(URL, [ENTRY1]);\n    expect(details).to.eql({\n      file: URL,\n      hash: '00c6ee2e21a7548de6260cf72c4f4b5b',\n      size: ENTRY1.size\n    });\n  });","file":"workbox-build/node/lib/get-composite-details.js","skipped":false,"dir":"test"},{"name":"should return the expected composite details for multiple files","suites":["[workbox-build] lib/get-composite-details.js"],"updatePoint":{"line":34,"column":69},"line":34,"code":"  it(`should return the expected composite details for multiple files`, function () {\n    const details = getCompositeDetails(URL, [ENTRY1, ENTRY2]);\n    expect(details).to.eql({\n      file: URL,\n      hash: '3dcd1f089c4a94cbbedb7a00d7ec9829',\n      size: ENTRY1.size + ENTRY2.size\n    });\n  });","file":"workbox-build/node/lib/get-composite-details.js","skipped":false,"dir":"test"},{"name":"should throw when there's a glob.sync() error","suites":["[workbox-build] lib/get-file-details.js"],"updatePoint":{"line":27,"column":51},"line":27,"code":"  it(`should throw when there's a glob.sync() error`, function () {\n    const {\n      getFileDetails\n    } = proxyquire(MODULE_PATH, {\n      glob: {\n        sync: () => {\n          throw new Error();\n        }\n      }\n    });\n\n    try {\n      getFileDetails({\n        globDirectory: GLOB_DIRECTORY,\n        globPattern: GLOB_PATTERN\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['unable-to-glob-files']);\n    }\n  });","file":"workbox-build/node/lib/get-file-details.js","skipped":false,"dir":"test"},{"name":"should return a warning when the pattern doesn't match anything","suites":["[workbox-build] lib/get-file-details.js"],"updatePoint":{"line":48,"column":69},"line":48,"code":"  it(`should return a warning when the pattern doesn't match anything`, function () {\n    const {\n      getFileDetails\n    } = proxyquire(MODULE_PATH, {\n      glob: {\n        sync: () => []\n      }\n    });\n    const {\n      globbedFileDetails,\n      warning\n    } = getFileDetails({\n      globDirectory: GLOB_DIRECTORY,\n      globPattern: GLOB_PATTERN\n    });\n    expect(globbedFileDetails).to.be.empty;\n    expect(warning).to.have.string(errors['useless-glob-pattern']);\n  });","file":"workbox-build/node/lib/get-file-details.js","skipped":false,"dir":"test"},{"name":"should return array of file details, without null values","suites":["[workbox-build] lib/get-file-details.js"],"updatePoint":{"line":66,"column":62},"line":66,"code":"  it(`should return array of file details, without null values`, function () {\n    const {\n      getFileDetails\n    } = proxyquire(MODULE_PATH, {\n      'glob': {\n        sync: () => {\n          return [FILE1, FILE2, DIRECTORY];\n        }\n      },\n      './get-file-size': {\n        getFileSize: value => {\n          if (upath.normalize(value) === upath.normalize(DIRECTORY)) {\n            return null;\n          }\n\n          return SIZE;\n        }\n      },\n      './get-file-hash': {\n        getFileHash: value => {\n          if (upath.normalize(value) === upath.normalize(DIRECTORY)) {\n            throw new Error(`getFileHash(${DIRECTORY}) shouldn't have been called.`);\n          }\n\n          return HASH;\n        }\n      }\n    });\n    const {\n      globbedFileDetails,\n      warning\n    } = getFileDetails({\n      globDirectory: GLOB_DIRECTORY,\n      globPattern: GLOB_PATTERN\n    });\n    expect(warning).to.eql('');\n    expect(globbedFileDetails).to.deep.equal([{\n      file: FILE1,\n      hash: HASH,\n      size: SIZE\n    }, {\n      file: FILE2,\n      hash: HASH,\n      size: SIZE\n    }]);\n  });","file":"workbox-build/node/lib/get-file-details.js","skipped":false,"dir":"test"},{"name":"should throw when there's a fs.readFileSync() error","suites":["[workbox-build] lib/get-file-hash.js"],"updatePoint":{"line":19,"column":57},"line":19,"code":"  it(`should throw when there's a fs.readFileSync() error`, function () {\n    const {\n      getFileHash\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        readFileSync: () => {\n          throw new Error();\n        }\n      }\n    });\n\n    try {\n      getFileHash(FILE);\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['unable-to-get-file-hash']);\n    }\n  });","file":"workbox-build/node/lib/get-file-hash.js","skipped":false,"dir":"test"},{"name":"should return the hash corresponding to a file's contents","suites":["[workbox-build] lib/get-file-hash.js"],"updatePoint":{"line":37,"column":63},"line":37,"code":"  it(`should return the hash corresponding to a file's contents`, function () {\n    const buffer = Buffer.alloc(10);\n    const hashForBuffer = 'a63c90cc3684ad8b0a2176a6a8fe9005';\n    const {\n      getFileHash\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        readFileSync: file => {\n          if (file !== FILE) {\n            throw new Error(`Unexpected file name: ${file}`);\n          }\n\n          return buffer;\n        }\n      }\n    });\n    const hash = getFileHash(FILE);\n    expect(hash).to.eql(hashForBuffer);\n  });","file":"workbox-build/node/lib/get-file-hash.js","skipped":false,"dir":"test"},{"name":"should return empty info when neither globDirectory nor templatedURLs are provided","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":25,"column":88},"line":25,"code":"  it(`should return empty info when neither globDirectory nor templatedURLs are provided`, async function () {\n    const {\n      getFileManifestEntries\n    } = require(MODULE_PATH);\n\n    const {\n      count,\n      size,\n      manifestEntries\n    } = await getFileManifestEntries({});\n    expect(count).to.eql(0);\n    expect(size).to.eql(0);\n    expect(manifestEntries).to.have.lengthOf(0);\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should not return the same file twice","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":39,"column":43},"line":39,"code":"  it(`should not return the same file twice`, async function () {\n    const {\n      getFileManifestEntries\n    } = proxyquire(MODULE_PATH, {\n      './get-file-details': {\n        getFileDetails: () => {\n          return {\n            globbedFileDetails: [FILE, FILE],\n            warning: undefined\n          };\n        }\n      }\n    });\n    const {\n      count,\n      size,\n      manifestEntries\n    } = await getFileManifestEntries({\n      globDirectory: GLOB_DIRECTORY,\n      globPatterns: GLOB_PATTERNS\n    });\n    expect(count).to.eql(1);\n    expect(size).to.eql(FILE.size);\n    expect(manifestEntries).to.deep.equal([{\n      url: FILE.file,\n      revision: FILE.hash\n    }]);\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should throw when a templatedURL matches a globbed file","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":67,"column":61},"line":67,"code":"  it(`should throw when a templatedURL matches a globbed file`, async function () {\n    const {\n      getFileManifestEntries\n    } = proxyquire(MODULE_PATH, {\n      './get-file-details': {\n        getFileDetails: () => {\n          return {\n            globbedFileDetails: [FILE],\n            warning: undefined\n          };\n        }\n      }\n    });\n\n    try {\n      await getFileManifestEntries({\n        globDirectory: GLOB_DIRECTORY,\n        globPatterns: GLOB_PATTERNS,\n        templatedURLs: {\n          [FILE.file]: ''\n        }\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['templated-url-matches-glob']);\n    }\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should treat an exception thrown by getFileDetails() as a warning message","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":94,"column":79},"line":94,"code":"  it(`should treat an exception thrown by getFileDetails() as a warning message`, async function () {\n    const warningMessage = 'test warning';\n    const {\n      getFileManifestEntries\n    } = proxyquire(MODULE_PATH, {\n      './get-file-details': {\n        getFileDetails: () => {\n          throw new Error(warningMessage);\n        }\n      }\n    });\n    const {\n      warnings\n    } = await getFileManifestEntries({\n      globDirectory: GLOB_DIRECTORY,\n      globPatterns: GLOB_PATTERNS,\n      templatedURLs: {\n        [FILE.file]: ''\n      }\n    });\n    expect(warnings).to.eql([warningMessage]);\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should throw when a templatedURL contains a pattern that doesn't match anything","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":116,"column":85},"line":116,"code":"  it(`should throw when a templatedURL contains a pattern that doesn't match anything`, async function () {\n    const {\n      getFileManifestEntries\n    } = require(MODULE_PATH);\n\n    try {\n      await getFileManifestEntries({\n        globDirectory: GLOB_DIRECTORY,\n        templatedURLs: {\n          [FILE.file]: GLOB_PATTERNS\n        }\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['bad-template-urls-asset']);\n    }\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should return results that take both glob patterns and templatedURLs into account","suites":["[workbox-build] Test getFileManifestEntries"],"updatePoint":{"line":133,"column":87},"line":133,"code":"  it(`should return results that take both glob patterns and templatedURLs into account`, async function () {\n    const url1 = '/path/to/url1';\n    const url2 = '/path/to/url2';\n    const stringValue = 'string';\n    const {\n      getFileManifestEntries\n    } = proxyquire(MODULE_PATH, {\n      './get-file-details': {\n        getFileDetails: () => {\n          return {\n            globbedFileDetails: [FILE],\n            warning: undefined\n          };\n        }\n      }\n    });\n    const {\n      count,\n      size,\n      manifestEntries\n    } = await getFileManifestEntries({\n      globDirectory: GLOB_DIRECTORY,\n      globPatterns: GLOB_PATTERNS,\n      templatedURLs: {\n        [url1]: GLOB_PATTERNS,\n        [url2]: stringValue\n      }\n    });\n    expect(count).to.eql(3);\n    expect(size).to.eql(FILE.size + FILE.size + stringValue.length);\n    expect(manifestEntries).to.deep.equal([{\n      url: FILE.file,\n      revision: FILE.hash\n    }, {\n      url: url1,\n      // This is the hash of FILE.hash.\n      revision: '00c6ee2e21a7548de6260cf72c4f4b5b'\n    }, {\n      url: url2,\n      // THis is the hash of stringValue.\n      revision: 'b45cffe084dd3d20d928bee85e7b0f21'\n    }]);\n  });","file":"workbox-build/node/lib/get-file-manifest-entries.js","skipped":false,"dir":"test"},{"name":"should throw when fs.statSync() fails","suites":["[workbox-build] lib/get-file-size.js"],"updatePoint":{"line":19,"column":43},"line":19,"code":"  it(`should throw when fs.statSync() fails`, function () {\n    const {\n      getFileSize\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        statSync: () => {\n          throw new Error();\n        }\n      }\n    });\n\n    try {\n      getFileSize(FILE);\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['unable-to-get-file-size']);\n    }\n  });","file":"workbox-build/node/lib/get-file-size.js","skipped":false,"dir":"test"},{"name":"should return null for non-files","suites":["[workbox-build] lib/get-file-size.js"],"updatePoint":{"line":37,"column":38},"line":37,"code":"  it(`should return null for non-files`, function () {\n    const {\n      getFileSize\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        statSync: () => {\n          return {\n            isFile: () => false\n          };\n        }\n      }\n    });\n    const size = getFileSize(FILE);\n    expect(size).not.to.exist;\n  });","file":"workbox-build/node/lib/get-file-size.js","skipped":false,"dir":"test"},{"name":"should return the expected file size","suites":["[workbox-build] lib/get-file-size.js"],"updatePoint":{"line":52,"column":42},"line":52,"code":"  it(`should return the expected file size`, function () {\n    const expectedSize = 1234;\n    const {\n      getFileSize\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        statSync: () => {\n          return {\n            isFile: () => true,\n            size: expectedSize\n          };\n        }\n      }\n    });\n    const size = getFileSize(FILE);\n    expect(size).to.eql(expectedSize);\n  });","file":"workbox-build/node/lib/get-file-size.js","skipped":false,"dir":"test"},{"name":"should return the expected details","suites":["[workbox-build] lib/get-string-details.js"],"updatePoint":{"line":15,"column":40},"line":15,"code":"  it(`should return the expected details`, function () {\n    const inputToExpectedDetails = new Map([[['/url-one', 'first-one'], {\n      file: '/url-one',\n      hash: 'e725107146e32e2e7e75feaa303b7fbc',\n      size: 9\n    }], [['/url-two', 'another-string'], {\n      file: '/url-two',\n      hash: '7fb80c5fad3565fd6ce3d9f61a53c659',\n      size: 14\n    }]]);\n\n    for (const [[url, string], expectedDetails] of inputToExpectedDetails) {\n      const details = getStringDetails(url, string);\n      expect(details).to.eql(expectedDetails);\n    }\n  });","file":"workbox-build/node/lib/get-string-details.js","skipped":false,"dir":"test"},{"name":"should return the expected hashes","suites":["[workbox-build] lib/get-string-hash.js"],"updatePoint":{"line":15,"column":39},"line":15,"code":"  it(`should return the expected hashes`, function () {\n    const stringsToHashes = new Map([['abc', '900150983cd24fb0d6963f7d28e17f72'], ['xyz', 'd16fb36f0911f878998c136191af705e']]);\n\n    for (const [string, hash] of stringsToHashes) {\n      expect(getStringHash(string)).to.eql(hash);\n    }\n  });","file":"workbox-build/node/lib/get-string-hash.js","skipped":false,"dir":"test"},{"name":"should handle bad URLs in the manifest","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":27,"column":44},"line":27,"code":"  it(`should handle bad URLs in the manifest`, function () {\n    const badInputs = [null, undefined, true, false, {}, []];\n    const modifications = {\n      '/example-1': '/example-1-altered',\n      '/example-2/multi-section/1234': '/example-2-altered/5678'\n    };\n    const transform = modifyURLPrefixTransform(modifications);\n\n    for (const badInput of badInputs) {\n      expect(() => transform([{\n        url: badInput\n      }])).to.throw(errors['manifest-entry-bad-url']);\n    }\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should handle bad modifyURLPrefixTransform input","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":41,"column":54},"line":41,"code":"  it(`should handle bad modifyURLPrefixTransform input`, function () {\n    const badInputs = [null, undefined, true, false, [], '', {\n      Hi: []\n    }];\n\n    for (const badInput of badInputs) {\n      expect(() => modifyURLPrefixTransform(badInput)).to.throw(errors['modify-url-prefix-bad-prefixes']);\n    }\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should strip prefixes","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":50,"column":27},"line":50,"code":"  it(`should strip prefixes`, function () {\n    const modifications = {\n      '/first-match': ''\n    };\n    const transform = modifyURLPrefixTransform(modifications);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/12345/hello'\n      }, {\n        url: '/second-match/12345/hello'\n      }]\n    });\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should prepend prefixes","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":63,"column":29},"line":63,"code":"  it(`should prepend prefixes`, function () {\n    const modifications = {\n      '': '/public'\n    };\n    const transform = modifyURLPrefixTransform(modifications);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/public/first-match/12345/hello'\n      }, {\n        url: '/public/second-match/12345/hello'\n      }]\n    });\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should only replace the initial match","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":76,"column":43},"line":76,"code":"  it(`should only replace the initial match`, function () {\n    const modifications = {\n      '/first-match': '/second-match',\n      '/second-match': '/third-match'\n    };\n    const transform = modifyURLPrefixTransform(modifications);\n    expect(transform(getManifest())).to.eql({\n      manifest: [{\n        url: '/second-match/12345/hello'\n      }, {\n        url: '/third-match/12345/hello'\n      }]\n    });\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should not replace when the match is not at the start of the URL","suites":["[workbox-build] lib/modify-url-prefix-transform.js"],"updatePoint":{"line":90,"column":70},"line":90,"code":"  it(`should not replace when the match is not at the start of the URL`, function () {\n    const modifications = {\n      '/hello': '/altered'\n    };\n    const transform = modifyURLPrefixTransform(modifications);\n    expect(transform(getManifest())).to.eql({\n      manifest: getManifest()\n    });\n  });","file":"workbox-build/node/lib/modify-url-prefix-transform.js","skipped":false,"dir":"test"},{"name":"should return [] when nothing is used","suites":["[workbox-build] lib/module-registry.js","getImportStatements()"],"updatePoint":{"line":25,"column":45},"line":25,"code":"    it(`should return [] when nothing is used`, function () {\n      expect(moduleRegistry.getImportStatements()).to.be.empty;\n    });","file":"workbox-build/node/lib/module-registry.js","skipped":false,"dir":"test"},{"name":"return the expected output given multiple calls to use()","suites":["[workbox-build] lib/module-registry.js","getImportStatements()"],"updatePoint":{"line":28,"column":64},"line":28,"code":"    it(`return the expected output given multiple calls to use()`, function () {\n      const module1Name = moduleRegistry.use('workbox-core', 'index'); // Multiple use()s should result in only one entry.\n\n      moduleRegistry.use('workbox-core', 'index');\n      const module2Name = moduleRegistry.use('workbox-routing', 'index');\n      const importStatements = moduleRegistry.getImportStatements();\n      expect(importStatements).to.have.members([`import {index as workbox_core_index} from '${basePath}/packages/workbox-core/index.mjs';`, `import {index as workbox_routing_index} from '${basePath}/packages/workbox-routing/index.mjs';`]);\n      expect(importStatements[0]).to.contain(module1Name);\n      expect(importStatements[1]).to.contain(module2Name);\n    });","file":"workbox-build/node/lib/module-registry.js","skipped":false,"dir":"test"},{"name":"should return the expected name","suites":["[workbox-build] lib/module-registry.js","getLocalName()"],"updatePoint":{"line":40,"column":39},"line":40,"code":"    it(`should return the expected name`, function () {\n      expect(moduleRegistry.getLocalName('a-b-c', 'd')).to.eql('a_b_c_d');\n    });","file":"workbox-build/node/lib/module-registry.js","skipped":false,"dir":"test"},{"name":"should return the expected name when called via use()","suites":["[workbox-build] lib/module-registry.js","getLocalName()"],"updatePoint":{"line":43,"column":61},"line":43,"code":"    it(`should return the expected name when called via use()`, function () {\n      expect(moduleRegistry.use('a-b-c', 'd')).to.eql('a_b_c_d');\n    });","file":"workbox-build/node/lib/module-registry.js","skipped":false,"dir":"test"},{"name":"should handle bad URLs in the manifest","suites":["[workbox-build] lib/no-revision-for-urls-matching-transform.js"],"updatePoint":{"line":28,"column":44},"line":28,"code":"  it(`should handle bad URLs in the manifest`, function () {\n    const badInputs = [null, undefined, true, false, {}, []];\n    const transform = noRevisionForURLsMatchingTransform(/ignored/);\n\n    for (const badInput of badInputs) {\n      expect(() => transform([{\n        url: badInput\n      }])).to.throw(errors['manifest-entry-bad-url']);\n    }\n  });","file":"workbox-build/node/lib/no-revision-for-urls-matching-transform.js","skipped":false,"dir":"test"},{"name":"should handle bad dontCacheBustURLsMatching input","suites":["[workbox-build] lib/no-revision-for-urls-matching-transform.js"],"updatePoint":{"line":38,"column":55},"line":38,"code":"  it(`should handle bad dontCacheBustURLsMatching input`, function () {\n    const badInputs = [null, undefined, true, false, [], '', {\n      Hi: []\n    }];\n\n    for (const badInput of badInputs) {\n      expect(() => noRevisionForURLsMatchingTransform(badInput)).to.throw(errors['invalid-dont-cache-bust']);\n    }\n  });","file":"workbox-build/node/lib/no-revision-for-urls-matching-transform.js","skipped":false,"dir":"test"},{"name":"should set revision info to null in a single matching entry","suites":["[workbox-build] lib/no-revision-for-urls-matching-transform.js"],"updatePoint":{"line":47,"column":65},"line":47,"code":"  it(`should set revision info to null in a single matching entry`, function () {\n    const transform = noRevisionForURLsMatchingTransform(/first-match/);\n    expect(transform(MANIFEST)).to.eql({\n      manifest: [{\n        url: '/first-match/12345/hello',\n        revision: null\n      }, {\n        url: '/second-match/12345/hello',\n        revision: '1234abcd'\n      }, {\n        url: '/third-match/12345/hello'\n      }]\n    });\n  });","file":"workbox-build/node/lib/no-revision-for-urls-matching-transform.js","skipped":false,"dir":"test"},{"name":"should set revision info to null in multiple matching entries","suites":["[workbox-build] lib/no-revision-for-urls-matching-transform.js"],"updatePoint":{"line":61,"column":67},"line":61,"code":"  it(`should set revision info to null in multiple matching entries`, function () {\n    const transform = noRevisionForURLsMatchingTransform(/12345/);\n    expect(transform(MANIFEST)).to.eql({\n      manifest: [{\n        url: '/first-match/12345/hello',\n        revision: null\n      }, {\n        url: '/second-match/12345/hello',\n        revision: null\n      }, {\n        url: '/third-match/12345/hello',\n        revision: null\n      }]\n    });\n  });","file":"workbox-build/node/lib/no-revision-for-urls-matching-transform.js","skipped":false,"dir":"test"},{"name":"should do nothing when there's a match for an entry without a revision","suites":["[workbox-build] lib/no-revision-for-urls-matching-transform.js"],"updatePoint":{"line":76,"column":76},"line":76,"code":"  it(`should do nothing when there's a match for an entry without a revision`, function () {\n    const transform = noRevisionForURLsMatchingTransform(/third-match/);\n    expect(transform(MANIFEST)).to.eql({\n      manifest: MANIFEST\n    });\n  });","file":"workbox-build/node/lib/no-revision-for-urls-matching-transform.js","skipped":false,"dir":"test"},{"name":"should throw an error if templating fails","suites":["[workbox-build] lib/populate-sw-template.js"],"updatePoint":{"line":20,"column":47},"line":20,"code":"  it(`should throw an error if templating fails`, function () {\n    const manifestEntries = ['ignored'];\n    const {\n      populateSWTemplate\n    } = proxyquire(MODULE_PATH, {\n      'lodash/template': () => {\n        throw new Error();\n      }\n    });\n\n    try {\n      populateSWTemplate({\n        manifestEntries\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['populating-sw-tmpl-failed']);\n    }\n  });","file":"workbox-build/node/lib/populate-sw-template.js","skipped":false,"dir":"test"},{"name":"should throw an error if both manifestEntries and runtimeCaching are empty","suites":["[workbox-build] lib/populate-sw-template.js"],"updatePoint":{"line":39,"column":80},"line":39,"code":"  it(`should throw an error if both manifestEntries and runtimeCaching are empty`, function () {\n    const {\n      populateSWTemplate\n    } = proxyquire(MODULE_PATH, {\n      'lodash/template': () => {}\n    });\n\n    try {\n      populateSWTemplate({\n        manifestEntries: [],\n        runtimeCaching: []\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['no-manifest-entries-or-runtime-caching']);\n    }\n  });","file":"workbox-build/node/lib/populate-sw-template.js","skipped":false,"dir":"test"},{"name":"should pass the expected options to the template using mostly defaults","suites":["[workbox-build] lib/populate-sw-template.js"],"updatePoint":{"line":56,"column":76},"line":56,"code":"  it(`should pass the expected options to the template using mostly defaults`, function () {\n    const runtimeCachingPlaceholder = 'runtime-caching-placeholder';\n    const swTemplate = 'template';\n    const precacheOptionsString = '{}';\n    const manifestEntries = ['ignored'];\n    const innerStub = sinon.stub().returns('');\n    const outerStub = sinon.stub().returns(innerStub);\n    const {\n      populateSWTemplate\n    } = proxyquire(MODULE_PATH, {\n      'lodash/template': outerStub,\n      './runtime-caching-converter': {\n        runtimeCachingConverter: () => runtimeCachingPlaceholder\n      },\n      '../templates/sw-template': {\n        swTemplate\n      }\n    });\n    populateSWTemplate({\n      manifestEntries\n    });\n    expect(outerStub.alwaysCalledWith(swTemplate)).to.be.true; // Doing a strict comparison with functions isn't easy.\n\n    expect(innerStub.args[0][0].use).to.be.a('function');\n    delete innerStub.args[0][0].use;\n    expect(innerStub.args[0]).to.eql([{\n      manifestEntries,\n      cacheId: undefined,\n      cleanupOutdatedCaches: undefined,\n      clientsClaim: undefined,\n      disableDevLogs: undefined,\n      importScripts: undefined,\n      navigateFallback: undefined,\n      navigateFallbackDenylist: undefined,\n      navigateFallbackAllowlist: undefined,\n      navigationPreload: undefined,\n      offlineAnalyticsConfigString: undefined,\n      precacheOptionsString,\n      runtimeCaching: runtimeCachingPlaceholder,\n      skipWaiting: undefined\n    }]);\n  });","file":"workbox-build/node/lib/populate-sw-template.js","skipped":false,"dir":"test"},{"name":"should pass the expected options to the template","suites":["[workbox-build] lib/populate-sw-template.js"],"updatePoint":{"line":98,"column":54},"line":98,"code":"  it(`should pass the expected options to the template`, function () {\n    const cacheId = 'test-cache-id';\n    const cleanupOutdatedCaches = true;\n    const clientsClaim = true;\n    const directoryIndex = 'index.html';\n    const disableDevLogs = true;\n    const handleFetch = true;\n    const ignoreURLParametersMatching = [/a/, /b/];\n    const importScripts = ['test.js'];\n    const manifestEntries = [{\n      url: '/path/to/index.html',\n      revision: '1234'\n    }];\n    const navigateFallback = '/shell.html';\n    const navigateFallbackDenylist = [/another-test/];\n    const navigateFallbackAllowlist = [/test/];\n    const navigationPreload = true;\n    const offlineGoogleAnalytics = true;\n    const offlineAnalyticsConfigString = '{}';\n    const runtimeCaching = [];\n    const runtimeCachingPlaceholder = 'runtime-caching-placeholder';\n    const skipWaiting = true;\n    const swTemplate = 'template';\n    const precacheOptionsString = '{\\n  \"directoryIndex\": \"index.html\",\\n  \"ignoreURLParametersMatching\": [/a/, /b/]\\n}'; // There are two stages in templating: creating the active template function\n    // from an initial string, and passing variables to that template function\n    // to get back a final, populated template string.\n    // We need to stub out both of those steps to test the full flow.\n\n    const templatePopulationStub = sinon.stub().returns('');\n    const templateCreationStub = sinon.stub().returns(templatePopulationStub);\n    const {\n      populateSWTemplate\n    } = proxyquire(MODULE_PATH, {\n      'lodash/template': templateCreationStub,\n      './runtime-caching-converter': {\n        runtimeCachingConverter: () => runtimeCachingPlaceholder\n      },\n      '../templates/sw-template': {\n        swTemplate\n      }\n    });\n    populateSWTemplate({\n      cacheId,\n      cleanupOutdatedCaches,\n      clientsClaim,\n      directoryIndex,\n      disableDevLogs,\n      handleFetch,\n      ignoreURLParametersMatching,\n      importScripts,\n      manifestEntries,\n      navigateFallback,\n      navigateFallbackDenylist,\n      navigateFallbackAllowlist,\n      navigationPreload,\n      offlineGoogleAnalytics,\n      runtimeCaching,\n      skipWaiting\n    });\n    expect(templateCreationStub.alwaysCalledWith(swTemplate)).to.be.true; // Doing a strict comparison with functions isn't easy.\n\n    expect(templatePopulationStub.args[0][0].use).to.be.a('function');\n    delete templatePopulationStub.args[0][0].use;\n    expect(templatePopulationStub.args[0]).to.eql([{\n      cacheId,\n      cleanupOutdatedCaches,\n      clientsClaim,\n      disableDevLogs,\n      importScripts,\n      manifestEntries,\n      navigateFallback,\n      navigateFallbackDenylist,\n      navigateFallbackAllowlist,\n      navigationPreload,\n      offlineAnalyticsConfigString,\n      runtimeCaching: runtimeCachingPlaceholder,\n      precacheOptionsString,\n      skipWaiting\n    }]);\n  });","file":"workbox-build/node/lib/populate-sw-template.js","skipped":false,"dir":"test"},{"name":"should handle a complex offlineGoogleAnalytics value when populating the template","suites":["[workbox-build] lib/populate-sw-template.js"],"updatePoint":{"line":178,"column":87},"line":178,"code":"  it(`should handle a complex offlineGoogleAnalytics value when populating the template`, function () {\n    const runtimeCachingPlaceholder = 'runtime-caching-placeholder';\n    const swTemplate = 'template';\n    const precacheOptionsString = '{}';\n    const offlineGoogleAnalytics = {\n      parameterOverrides: {\n        cd1: 'offline'\n      },\n      hitFilter: params => {\n        // Comments are stripped.\n        params.set('cm1', params.get('qt'));\n      }\n    };\n    const offlineAnalyticsConfigString = `{\\n\\tparameterOverrides: {\\n\\t\\tcd1: 'offline'\\n\\t},\\n\\thitFilter: (params) => {\\n        \\n        params.set('cm1', params.get('qt'));\\n      }\\n}`;\n    const manifestEntries = ['ignored'];\n    const innerStub = sinon.stub().returns('');\n    const outerStub = sinon.stub().returns(innerStub);\n    const {\n      populateSWTemplate\n    } = proxyquire(MODULE_PATH, {\n      'lodash/template': outerStub,\n      './runtime-caching-converter': {\n        runtimeCachingConverter: () => runtimeCachingPlaceholder\n      },\n      '../templates/sw-template': {\n        swTemplate\n      }\n    });\n    populateSWTemplate({\n      manifestEntries,\n      offlineGoogleAnalytics\n    });\n    expect(outerStub.alwaysCalledWith(swTemplate)).to.be.true; // Doing a strict comparison with functions isn't easy.\n\n    expect(innerStub.args[0][0].use).to.be.a('function');\n    delete innerStub.args[0][0].use;\n    expect(innerStub.args[0]).to.eql([{\n      manifestEntries,\n      cacheId: undefined,\n      cleanupOutdatedCaches: undefined,\n      clientsClaim: undefined,\n      disableDevLogs: undefined,\n      importScripts: undefined,\n      navigateFallback: undefined,\n      navigateFallbackDenylist: undefined,\n      navigateFallbackAllowlist: undefined,\n      navigationPreload: undefined,\n      offlineAnalyticsConfigString,\n      precacheOptionsString,\n      runtimeCaching: runtimeCachingPlaceholder,\n      skipWaiting: undefined\n    }]);\n  });","file":"workbox-build/node/lib/populate-sw-template.js","skipped":false,"dir":"test"},{"name":"should be a no-op if there's no match","suites":["[workbox-build] lib/replace-and-update-source-map"],"updatePoint":{"line":27,"column":43},"line":27,"code":"  it(`should be a no-op if there's no match`, async function () {\n    const {\n      map,\n      source\n    } = await replaceAndUpdateSourceMap({\n      jsFilename: JS_FILENAME,\n      originalSource: SOURCE,\n      originalMap: SOURCE_MAP,\n      searchString: 'is-not-found',\n      replaceString: 'ignored'\n    });\n    expect(JSON.parse(map)).to.eql(SOURCE_MAP);\n    expect(source).to.eql(SOURCE);\n  });","file":"workbox-build/node/lib/replace-and-update-source-map.js","skipped":false,"dir":"test"},{"name":"should be perform the replacement and update the sourcemap when there is a match","suites":["[workbox-build] lib/replace-and-update-source-map"],"updatePoint":{"line":41,"column":86},"line":41,"code":"  it(`should be perform the replacement and update the sourcemap when there is a match`, async function () {\n    const searchString = 'bc';\n    const replaceString = 'wxyz';\n    const {\n      map,\n      source\n    } = await replaceAndUpdateSourceMap({\n      searchString,\n      replaceString,\n      jsFilename: JS_FILENAME,\n      originalSource: SOURCE,\n      originalMap: SOURCE_MAP\n    });\n    const expectedSourceMap = Object.assign({}, SOURCE_MAP, {\n      mappings: 'AAAA,KAAG,GAAG,AAAG,CAAC'\n    });\n    expect(JSON.parse(map)).to.eql(expectedSourceMap);\n    expect(source).to.eql('awxyzdefkl');\n  });","file":"workbox-build/node/lib/replace-and-update-source-map.js","skipped":false,"dir":"test"},{"name":"should throw when urlPattern isn't set","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":141,"column":44},"line":141,"code":"  it(`should throw when urlPattern isn't set`, function () {\n    const runtimeCachingOptions = [{\n      handler: 'CacheFirst'\n    }];\n    expect(() => {\n      runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    }).to.throw(errors['urlPattern-is-required']);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should throw when handler isn't set","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":149,"column":41},"line":149,"code":"  it(`should throw when handler isn't set`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /xyz/\n    }];\n    expect(() => {\n      runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    }).to.throw(errors['handler-string-is-required']);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support an empty array of runtimeCaching options","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":157,"column":61},"line":157,"code":"  it(`should support an empty array of runtimeCaching options`, function () {\n    const runtimeCachingOptions = [];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support a single option with a RegExp urlPattern, using mostly defaults","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":162,"column":84},"line":162,"code":"  it(`should support a single option with a RegExp urlPattern, using mostly defaults`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /xyz/,\n      handler: 'CacheFirst'\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  }); // See https://github.com/GoogleChrome/workbox/issues/574#issue-230170963","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support multiple options, each setting multiple properties","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":171,"column":71},"line":171,"code":"  it(`should support multiple options, each setting multiple properties`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: 'NetworkFirst',\n      options: {\n        networkTimeoutSeconds: 20,\n        cacheName: 'abc-cache',\n        expiration: {\n          maxEntries: 5,\n          maxAgeSeconds: 50\n        },\n        broadcastUpdate: {\n          channelName: 'test'\n        },\n        backgroundSync: {\n          name: 'test'\n        },\n        precacheFallback: {\n          fallbackURL: '/test1'\n        },\n        rangeRequests: false,\n        fetchOptions: {\n          headers: {\n            Custom: 'Header'\n          }\n        }\n      }\n    }, {\n      urlPattern: '/test',\n      handler: 'StaleWhileRevalidate',\n      options: {\n        expiration: {\n          maxEntries: 10\n        },\n        cacheableResponse: {\n          statuses: [0, 200]\n        },\n        broadcastUpdate: {\n          channelName: 'test',\n          options: {\n            source: 'test-source'\n          }\n        },\n        backgroundSync: {\n          name: 'test',\n          options: {\n            maxRetentionTime: 123\n          }\n        },\n        rangeRequests: true,\n        precacheFallback: {\n          fallbackURL: '/test2'\n        },\n        matchOptions: {\n          ignoreSearch: true\n        }\n      }\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support a string urlPattern, using mostly defaults","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":232,"column":63},"line":232,"code":"  it(`should support a string urlPattern, using mostly defaults`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: '/path/to/file',\n      handler: 'CacheFirst'\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support handler being a function","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":240,"column":45},"line":240,"code":"  it(`should support handler being a function`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: () => {}\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support registering non-GET methods","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":248,"column":48},"line":248,"code":"  it(`should support registering non-GET methods`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: 'CacheFirst',\n      method: 'POST'\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    validate(runtimeCachingOptions, convertedOptions);\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should support custom plugins","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":257,"column":35},"line":257,"code":"  it(`should support custom plugins`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: 'CacheFirst',\n      options: {\n        plugins: [{\n          cacheWillUpdate: async ({\n            request,\n            response\n          }) => {\n            return response;\n          },\n          cacheDidUpdate: async ({\n            cacheName,\n            request,\n            oldResponse,\n            newResponse\n          }) => {},\n          cachedResponseWillBeUsed: async ({\n            cacheName,\n            request,\n            matchOptions,\n            cachedResponse\n          }) => {\n            return cachedResponse;\n          },\n          requestWillFetch: async ({\n            request\n          }) => {\n            return request;\n          },\n          fetchDidFail: async ({\n            originalRequest,\n            request,\n            error\n          }) => {}\n        }]\n      }\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    expect(convertedOptions[0].includes('cacheWillUpdate: async')).to.true;\n    expect(convertedOptions[0].includes('cacheDidUpdate: async')).to.true;\n    expect(convertedOptions[0].includes('cachedResponseWillBeUsed: async')).to.true;\n    expect(convertedOptions[0].includes('requestWillFetch: async')).to.true;\n    expect(convertedOptions[0].includes('fetchDidFail: async')).to.true;\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should strip comments on custom plugins","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":303,"column":45},"line":303,"code":"  it(`should strip comments on custom plugins`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: 'CacheFirst',\n      options: {\n        plugins: [{\n          cacheWillUpdate: async ({\n            request,\n            response\n          }) => {\n            // Commenting\n            return response;\n          },\n          cachedResponseWillBeUsed: async ({\n            cacheName,\n            request,\n            matchOptions,\n            cachedResponse\n          }) => {\n            /* Commenting */\n            return cachedResponse;\n          }\n        }]\n      }\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    expect(convertedOptions[0].includes('// Commenting')).to.false;\n    expect(convertedOptions[0].includes('/* Commenting */')).to.false;\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should keep contents with // that are not comments","suites":["[workbox-build] src/lib/utils/runtime-caching-converter.js"],"updatePoint":{"line":332,"column":56},"line":332,"code":"  it(`should keep contents with // that are not comments`, function () {\n    const runtimeCachingOptions = [{\n      urlPattern: /abc/,\n      handler: 'CacheFirst',\n      options: {\n        plugins: [{\n          cacheWillUpdate: async ({\n            request,\n            response\n          }) => {\n            // Commenting\n            if (request.url === 'https://test.com') {\n              return null;\n            }\n\n            return response;\n          }\n        }]\n      }\n    }];\n    const convertedOptions = runtimeCachingConverter(moduleRegistry, runtimeCachingOptions);\n    expect(convertedOptions[0].includes('// Commenting')).to.false;\n    expect(convertedOptions[0].includes('https://test.com')).to.true;\n  });","file":"workbox-build/node/lib/runtime-caching-converter.js","skipped":false,"dir":"test"},{"name":"should filter out files above maximumFileSizeToCacheInBytes","suites":["[workbox-build] lib/transform-manifest.js"],"updatePoint":{"line":32,"column":65},"line":32,"code":"  it(`should filter out files above maximumFileSizeToCacheInBytes`, async function () {\n    const {\n      size,\n      count,\n      manifestEntries\n    } = await transformManifest({\n      maximumFileSizeToCacheInBytes: MAXIMUM_FILE_SIZE,\n      fileDetails: FILE_DETAILS\n    });\n    expect(size).to.eql(ENTRY1.size + ENTRY2.size);\n    expect(count).to.eql(2);\n    expect(manifestEntries).to.deep.equal([{\n      url: ENTRY1.file,\n      revision: ENTRY1.hash\n    }, {\n      url: ENTRY2.file,\n      revision: ENTRY2.hash\n    }]);\n  });","file":"workbox-build/node/lib/transform-manifest.js","skipped":false,"dir":"test"},{"name":"should remove revision info based on dontCacheBustURLsMatching","suites":["[workbox-build] lib/transform-manifest.js"],"updatePoint":{"line":51,"column":68},"line":51,"code":"  it(`should remove revision info based on dontCacheBustURLsMatching`, async function () {\n    const {\n      size,\n      count,\n      manifestEntries\n    } = await transformManifest({\n      dontCacheBustURLsMatching: new RegExp(ENTRY1.file),\n      fileDetails: FILE_DETAILS\n    });\n    expect(size).to.eql(ENTRY1.size + ENTRY2.size + ENTRY3.size);\n    expect(count).to.eql(3);\n    expect(manifestEntries).to.deep.equal([{\n      url: ENTRY1.file,\n      revision: null\n    }, {\n      url: ENTRY2.file,\n      revision: ENTRY2.hash\n    }, {\n      url: ENTRY3.file,\n      revision: ENTRY3.hash\n    }]);\n  });","file":"workbox-build/node/lib/transform-manifest.js","skipped":false,"dir":"test"},{"name":"should modify the URLs based on modifyURLPrefix","suites":["[workbox-build] lib/transform-manifest.js"],"updatePoint":{"line":73,"column":53},"line":73,"code":"  it(`should modify the URLs based on modifyURLPrefix`, async function () {\n    const prefix = 'prefix/';\n    const {\n      size,\n      count,\n      manifestEntries\n    } = await transformManifest({\n      modifyURLPrefix: {\n        '': prefix\n      },\n      fileDetails: FILE_DETAILS\n    });\n    expect(size).to.eql(ENTRY1.size + ENTRY2.size + ENTRY3.size);\n    expect(count).to.eql(3);\n    expect(manifestEntries).to.deep.equal([{\n      url: prefix + ENTRY1.file,\n      revision: ENTRY1.hash\n    }, {\n      url: prefix + ENTRY2.file,\n      revision: ENTRY2.hash\n    }, {\n      url: prefix + ENTRY3.file,\n      revision: ENTRY3.hash\n    }]);\n  });","file":"workbox-build/node/lib/transform-manifest.js","skipped":false,"dir":"test"},{"name":"should use custom manifestTransforms","suites":["[workbox-build] lib/transform-manifest.js"],"updatePoint":{"line":98,"column":42},"line":98,"code":"  it(`should use custom manifestTransforms`, async function () {\n    const prefix1 = 'prefix1/';\n    const prefix2 = 'prefix2/';\n    const warning1 = 'test warning 1';\n    const warning2 = 'test warning 1';\n    const transformParam = 'test param';\n\n    const transform1 = (files, param) => {\n      expect(param).to.eql(transformParam);\n      const manifest = files.map(file => {\n        file.url = prefix1 + file.url;\n        return file;\n      });\n      return {\n        manifest,\n        warnings: [warning1]\n      };\n    };\n\n    const transform2 = (files, param) => {\n      expect(param).to.eql(transformParam);\n      const manifest = files.map(file => {\n        file.url = prefix2 + file.url;\n        return file;\n      });\n      return {\n        manifest,\n        warnings: [warning2]\n      };\n    };\n\n    const {\n      size,\n      count,\n      manifestEntries,\n      warnings\n    } = await transformManifest({\n      fileDetails: FILE_DETAILS,\n      manifestTransforms: [transform1, transform2],\n      transformParam\n    });\n    expect(warnings).to.eql([warning1, warning2]);\n    expect(size).to.eql(ENTRY1.size + ENTRY2.size + ENTRY3.size);\n    expect(count).to.eql(3);\n    expect(manifestEntries).to.deep.equal([{\n      url: prefix2 + prefix1 + ENTRY1.file,\n      revision: ENTRY1.hash\n    }, {\n      url: prefix2 + prefix1 + ENTRY2.file,\n      revision: ENTRY2.hash\n    }, {\n      url: prefix2 + prefix1 + ENTRY3.file,\n      revision: ENTRY3.hash\n    }]);\n  });","file":"workbox-build/node/lib/transform-manifest.js","skipped":false,"dir":"test"},{"name":"should support an async manifestTransform","suites":["[workbox-build] lib/transform-manifest.js"],"updatePoint":{"line":153,"column":47},"line":153,"code":"  it(`should support an async manifestTransform`, async function () {\n    const asyncTransform = async manifest => {\n      await Promise.resolve();\n      return {\n        manifest,\n        warnings: []\n      };\n    };\n\n    const {\n      size,\n      count,\n      manifestEntries,\n      warnings\n    } = await transformManifest({\n      fileDetails: FILE_DETAILS,\n      manifestTransforms: [asyncTransform]\n    });\n    expect(warnings).to.be.empty;\n    expect(size).to.eql(ENTRY1.size + ENTRY2.size + ENTRY3.size);\n    expect(count).to.eql(3);\n    expect(manifestEntries).to.deep.equal([{\n      url: ENTRY1.file,\n      revision: ENTRY1.hash\n    }, {\n      url: ENTRY2.file,\n      revision: ENTRY2.hash\n    }, {\n      url: ENTRY3.file,\n      revision: ENTRY3.hash\n    }]);\n  });","file":"workbox-build/node/lib/transform-manifest.js","skipped":false,"dir":"test"},{"name":"should return undefined paths when url is undefined","suites":["[workbox-build] lib/translate-url-to-sourcemap-paths.ts"],"updatePoint":{"line":21,"column":57},"line":21,"code":"  it(`should return undefined paths when url is undefined`, function () {\n    const {\n      translateURLToSourcemapPaths\n    } = require(MODULE_PATH);\n\n    const {\n      destPath,\n      srcPath,\n      warning\n    } = translateURLToSourcemapPaths(undefined, SWSRC, SWDEST);\n    expect(destPath).to.be.undefined;\n    expect(srcPath).to.be.undefined;\n    expect(warning).to.be.undefined;\n  });","file":"workbox-build/node/lib/translate-url-to-sourcemap-paths.js","skipped":false,"dir":"test"},{"name":"should return undefined paths when url starts with data:","suites":["[workbox-build] lib/translate-url-to-sourcemap-paths.ts"],"updatePoint":{"line":35,"column":62},"line":35,"code":"  it(`should return undefined paths when url starts with data:`, function () {\n    const {\n      translateURLToSourcemapPaths\n    } = require(MODULE_PATH);\n\n    const {\n      destPath,\n      srcPath,\n      warning\n    } = translateURLToSourcemapPaths(`data:${URL}`, SWSRC, SWDEST);\n    expect(destPath).to.be.undefined;\n    expect(srcPath).to.be.undefined;\n    expect(warning).to.be.undefined;\n  });","file":"workbox-build/node/lib/translate-url-to-sourcemap-paths.js","skipped":false,"dir":"test"},{"name":"should return undefined paths and a warning when the resolved URL path doesn't exist","suites":["[workbox-build] lib/translate-url-to-sourcemap-paths.ts"],"updatePoint":{"line":49,"column":90},"line":49,"code":"  it(`should return undefined paths and a warning when the resolved URL path doesn't exist`, function () {\n    const {\n      translateURLToSourcemapPaths\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        existsSync: () => false\n      }\n    });\n    const {\n      destPath,\n      srcPath,\n      warning\n    } = translateURLToSourcemapPaths(URL, SWSRC, SWDEST);\n    expect(destPath).to.be.undefined;\n    expect(srcPath).to.be.undefined;\n    expect(warning).to.include(errors['cant-find-sourcemap']);\n  });","file":"workbox-build/node/lib/translate-url-to-sourcemap-paths.js","skipped":false,"dir":"test"},{"name":"should return valid paths and no warning when the resolved URL path exists","suites":["[workbox-build] lib/translate-url-to-sourcemap-paths.ts"],"updatePoint":{"line":66,"column":80},"line":66,"code":"  it(`should return valid paths and no warning when the resolved URL path exists`, function () {\n    const {\n      translateURLToSourcemapPaths\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        existsSync: () => true\n      },\n      'upath': {\n        resolve: (...args) => args.join('/')\n      }\n    });\n    const {\n      destPath,\n      srcPath,\n      warning\n    } = translateURLToSourcemapPaths(URL, SWSRC, SWDEST);\n    expect(destPath).to.eql('dist/sw.js.map');\n    expect(srcPath).to.eq('src/sw.js.map');\n    expect(warning).to.be.undefined;\n  });","file":"workbox-build/node/lib/translate-url-to-sourcemap-paths.js","skipped":false,"dir":"test"},{"name":"() should throw when validation fails","suites":["[workbox-build] entry-points/options/validate-options.js"],"updatePoint":{"line":42,"column":52},"line":42,"code":"    it(`${func}() should throw when validation fails`, function () {\n      const validateOptions = proxyquire(MODULE_PATH, {\n        'ajv': {\n          default: AJVFailsValidation\n        },\n        '@apideck/better-ajv-errors': {\n          betterAjvErrors: sinon.stub().returns([{\n            message: 'message1',\n            path: 'path1',\n            suggestion: 'suggestion1'\n          }, {\n            message: 'message2',\n            path: 'path2',\n            suggestion: 'suggestion2'\n          }])\n        }\n      });\n      expect(() => validateOptions[func]()).to.throw(validateOptions.WorkboxConfigError, `[path1] message1. suggestion1\\n\\n[path2] message2. suggestion2`);\n    });","file":"workbox-build/node/lib/validate-options.js","skipped":false,"dir":"test"},{"name":"() should not throw when validation passes","suites":["[workbox-build] entry-points/options/validate-options.js"],"updatePoint":{"line":61,"column":57},"line":61,"code":"    it(`${func}() should not throw when validation passes`, function () {\n      const validateOptions = proxyquire(MODULE_PATH, {\n        ajv: {\n          default: AJVPassesValidation\n        }\n      });\n      const defaultOptions = validateOptions[func]({\n        globDirectory: '.'\n      });\n      expect(defaultOptions).to.be.an('object');\n    });","file":"workbox-build/node/lib/validate-options.js","skipped":false,"dir":"test"},{"name":"should reject with an error when fs-extra.mkdirp() fails","suites":["[workbox-build] lib/write-sw-using-default-template.js"],"updatePoint":{"line":22,"column":62},"line":22,"code":"  it(`should reject with an error when fs-extra.mkdirp() fails`, async function () {\n    const {\n      writeSWUsingDefaultTemplate\n    } = proxyquire(MODULE_PATH, {\n      'upath': {\n        dirname: () => 'ignored'\n      },\n      'fs-extra': {\n        mkdirp: () => Promise.reject(new Error())\n      }\n    });\n\n    try {\n      await writeSWUsingDefaultTemplate({});\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['unable-to-make-sw-directory']);\n    }\n  });","file":"workbox-build/node/lib/write-sw-using-default-template.js","skipped":false,"dir":"test"},{"name":"should reject with an error when fs-extra.writeFile() fails","suites":["[workbox-build] lib/write-sw-using-default-template.js"],"updatePoint":{"line":41,"column":65},"line":41,"code":"  it(`should reject with an error when fs-extra.writeFile() fails`, async function () {\n    const {\n      writeSWUsingDefaultTemplate\n    } = proxyquire(MODULE_PATH, {\n      'upath': {\n        dirname: () => 'ignored'\n      },\n      'fs-extra': {\n        mkdirp: () => Promise.resolve(),\n        writeFile: () => Promise.reject(new Error())\n      }\n    });\n\n    try {\n      await writeSWUsingDefaultTemplate({\n        manifestEntries: ['ignored']\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['sw-write-failure']);\n    }\n  });","file":"workbox-build/node/lib/write-sw-using-default-template.js","skipped":false,"dir":"test"},{"name":"should reject with a specific error when fs-extra.writeFile() fails due to EISDIR","suites":["[workbox-build] lib/write-sw-using-default-template.js"],"updatePoint":{"line":63,"column":87},"line":63,"code":"  it(`should reject with a specific error when fs-extra.writeFile() fails due to EISDIR`, async function () {\n    const eisdirError = new Error();\n    eisdirError.code = 'EISDIR';\n    const {\n      writeSWUsingDefaultTemplate\n    } = proxyquire(MODULE_PATH, {\n      'upath': {\n        dirname: () => 'ignored'\n      },\n      'fs-extra': {\n        mkdirp: () => Promise.resolve(),\n        readFile: () => Promise.resolve(),\n        writeFile: () => Promise.reject(eisdirError)\n      },\n      './bundle': {\n        bundle: async () => [{\n          name: 'ignored',\n          contents: 'ignored'\n        }]\n      }\n    });\n\n    try {\n      await writeSWUsingDefaultTemplate({\n        manifestEntries: ['ignored']\n      });\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.have.string(errors['sw-write-failure-directory']);\n    }\n  });","file":"workbox-build/node/lib/write-sw-using-default-template.js","skipped":false,"dir":"test"},{"name":"should call fs-extra.writeFile() with the expected parameters when everything succeeds","suites":["[workbox-build] lib/write-sw-using-default-template.js"],"updatePoint":{"line":94,"column":92},"line":94,"code":"  it(`should call fs-extra.writeFile() with the expected parameters when everything succeeds`, async function () {\n    const expectedPath = upath.join('expected', 'path');\n    const swDest = upath.join(expectedPath, 'sw.js');\n    const file1 = 'file1.js';\n    const file2 = 'file2.js';\n    const contents1 = 'contents1';\n    const contents2 = 'contents2';\n    const writeFileStub = sinon.stub().returns(Promise.resolve());\n    const {\n      writeSWUsingDefaultTemplate\n    } = proxyquire(MODULE_PATH, {\n      'fs-extra': {\n        mkdirp: path => {\n          expect(path).to.eql(expectedPath);\n        },\n        readFile: () => Promise.resolve(),\n        writeFile: writeFileStub\n      },\n      './bundle': {\n        bundle: async () => [{\n          name: upath.join(expectedPath, file1),\n          contents: contents1\n        }, {\n          name: upath.join(expectedPath, file2),\n          contents: contents2\n        }]\n      },\n      './populate-sw-template': {\n        populateSWTemplate: () => ''\n      }\n    });\n    await writeSWUsingDefaultTemplate({\n      swDest\n    }); // There should be exactly two calls to fs-extra.writeFile().\n\n    expect(writeFileStub.args).to.eql([[upath.resolve(expectedPath, file1), contents1], [upath.resolve(expectedPath, file2), contents2]]);\n  });","file":"workbox-build/node/lib/write-sw-using-default-template.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-cacheable-response]"],"updatePoint":{"line":28,"column":30},"line":28,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-cacheable-response/sw/');\n  });","file":"workbox-cacheable-response/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page and cache entries","suites":["[workbox-cacheable-response] Plugin"],"updatePoint":{"line":38,"column":42},"line":38,"code":"  it(`should load a page and cache entries`, async function () {\n    const swURL = `${baseURL}sw.js`; // Wait for the service worker to register and activate.\n\n    await activateAndControlSW(swURL);\n    const error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-1.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n\n    if (error) {\n      throw new Error(error);\n    } // Caching is done async from returning a response, so we may need\n    // to wait before the cache has some content.\n\n\n    await waitUntil(async () => {\n      const keys = await runInSW('cachesKeys');\n      return keys.length > 0;\n    });\n    const keys = await runInSW('cachesKeys');\n    expect(keys).to.deep.equal(['cacheable-response-cache']);\n    const cachedRequests = await runInSW('cacheURLs', keys[0]);\n    expect(cachedRequests).to.eql([`${baseURL}example-1.txt`]);\n  });","file":"workbox-cacheable-response/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should reject when both parameters are missing","suites":["[workbox-cli] app.js","failures due to bad parameters"],"updatePoint":{"line":63,"column":54},"line":63,"code":"    it(`should reject when both parameters are missing`, async function () {\n      await expect(app()).to.eventually.be.rejectedWith(errors['missing-input']);\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should reject when the command is unknown and options is present","suites":["[workbox-cli] app.js","failures due to bad parameters"],"updatePoint":{"line":66,"column":72},"line":66,"code":"    it(`should reject when the command is unknown and options is present`, async function () {\n      await expect(app({\n        input: [UNKNOWN_COMMAND, PROXIED_CONFIG_FILE]\n      })).to.eventually.be.rejectedWith(errors['unknown-command']);\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should reject when the command parameter is copyLibraries and options is missing","suites":["[workbox-cli] app.js","failures due to bad parameters"],"updatePoint":{"line":71,"column":88},"line":71,"code":"    it(`should reject when the command parameter is copyLibraries and options is missing`, async function () {\n      await expect(app({\n        input: ['copyLibraries']\n      })).to.eventually.be.rejectedWith(errors['missing-dest-dir-param']);\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should reject when the command parameter is  and options does not exist","suites":["[workbox-cli] app.js","failures due to bad parameters"],"updatePoint":{"line":78,"column":91},"line":78,"code":"      it(`should reject when the command parameter is ${command} and options does not exist`, async function () {\n        const loggerErrorStub = sinon.stub();\n        const {\n          app\n        } = proxyquire(MODULE_PATH, {\n          './lib/logger.js': {\n            logger: {\n              error: loggerErrorStub\n            }\n          }\n        });\n\n        try {\n          await app({\n            input: [command, INVALID_CONFIG_FILE]\n          });\n          throw new Error('Unexpected success.');\n        } catch (error) {\n          expect(loggerErrorStub.calledOnce).to.be.true;\n          expect(loggerErrorStub.alwaysCalledWithExactly(errors['invalid-common-js-module'])).to.be.true;\n          expect(error.message).to.have.string(INVALID_CONFIG_FILE);\n        }\n      });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should reject with a WorkboxConfigError when workbox-build.() is called","suites":["[workbox-cli] app.js","failures due to workbox-build runtime errors"],"updatePoint":{"line":116,"column":118},"line":116,"code":"        it(`should reject with a WorkboxConfigError when workbox-build.${command}(${JSON.stringify(config)}) is called`, async function () {\n          const {\n            app\n          } = proxyquire(MODULE_PATH, {\n            './lib/logger': {\n              logger: {\n                error: sinon.stub(),\n                log: sinon.stub()\n              }\n            },\n            './lib/read-config': {\n              readConfig: options => {\n                expect(options).to.eql(PROXIED_CONFIG_FILE);\n                return config;\n              }\n            }\n          });\n          await expect(app({\n            input: [command, PROXIED_CONFIG_FILE]\n          })).to.eventually.be.rejectedWith(WorkboxConfigError);\n        });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should reject with a generic runtime error when the workbox-build.() rejects for any other reason","suites":["[workbox-cli] app.js","failures due to workbox-build runtime errors"],"updatePoint":{"line":139,"column":117},"line":139,"code":"      it(`should reject with a generic runtime error when the workbox-build.${command}() rejects for any other reason`, async function () {\n        const {\n          app\n        } = proxyquire(MODULE_PATH, {\n          './lib/logger': {\n            logger: {\n              log: sinon.stub()\n            }\n          },\n          './lib/read-config': {\n            readConfig: options => {\n              expect(options).to.eql(PROXIED_CONFIG_FILE);\n              return PROXIED_CONFIG;\n            }\n          },\n          'workbox-build': {\n            [command]: config => {\n              expect(config).to.eql(PROXIED_CONFIG);\n              throw PROXIED_ERROR;\n            }\n          }\n        });\n        await expect(app({\n          input: [command, PROXIED_CONFIG_FILE]\n        })).to.eventually.be.rejectedWith(PROXIED_ERROR);\n      });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call logger.log() upon successfully running workbox-build.()","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":169,"column":87},"line":169,"code":"      it(`should call logger.log() upon successfully running workbox-build.${command}()`, async function () {\n        const loggerLogStub = sinon.stub();\n        const {\n          app\n        } = proxyquire(MODULE_PATH, {\n          './lib/read-config': {\n            readConfig: options => {\n              expect(options).to.eql(PROXIED_CONFIG_FILE);\n              return PROXIED_CONFIG;\n            }\n          },\n          './lib/logger': {\n            logger: {\n              log: loggerLogStub\n            }\n          },\n          'workbox-build': {\n            [command]: () => {\n              return WORKBOX_BUILD_NO_WARNINGS_RETURN_VALUE;\n            }\n          }\n        });\n        await app({\n          input: [command, PROXIED_CONFIG_FILE]\n        });\n        expect(loggerLogStub.callCount).to.eql(3);\n      });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call logger.warn() to report warnings, and then logger.log() upon successfully running workbox-build.()","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":196,"column":130},"line":196,"code":"      it(`should call logger.warn() to report warnings, and then logger.log() upon successfully running workbox-build.${command}()`, async function () {\n        const loggerLogStub = sinon.stub();\n        const loggerWarningStub = sinon.stub();\n        const {\n          app\n        } = proxyquire(MODULE_PATH, {\n          './lib/read-config': {\n            readConfig: options => {\n              expect(options).to.eql(PROXIED_CONFIG_FILE);\n              return PROXIED_CONFIG;\n            }\n          },\n          './lib/logger': {\n            logger: {\n              log: loggerLogStub,\n              warn: loggerWarningStub\n            }\n          },\n          'workbox-build': {\n            [command]: () => {\n              return WORKBOX_BUILD_WITH_WARNINGS_RETURN_VALUE;\n            }\n          }\n        });\n        await app({\n          input: [command, PROXIED_CONFIG_FILE]\n        });\n        expect(loggerWarningStub.calledOnce).to.be.true;\n        expect(loggerLogStub.callCount).to.eql(3);\n      });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call logger.log() upon successfully running workbox-build.() using the default config file location","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":226,"column":126},"line":226,"code":"      it(`should call logger.log() upon successfully running workbox-build.${command}() using the default config file location`, async function () {\n        const loggerLogStub = sinon.stub();\n        const {\n          app\n        } = proxyquire(MODULE_PATH, {\n          './lib/read-config': {\n            readConfig: options => {\n              const defaultConfigPath = upath.join(process.cwd(), constants.defaultConfigFile);\n              expect(options).to.eql(defaultConfigPath);\n              return PROXIED_CONFIG;\n            }\n          },\n          './lib/logger': {\n            logger: {\n              log: loggerLogStub,\n              error: loggerLogStub\n            }\n          },\n          'workbox-build': {\n            [command]: () => {\n              return WORKBOX_BUILD_NO_WARNINGS_RETURN_VALUE;\n            }\n          }\n        });\n        await app({\n          input: [command]\n        });\n        expect(loggerLogStub.callCount).to.eql(3);\n      });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call logger.log() upon successfully running workbox-build.copyWorkboxLibraries()","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":257,"column":95},"line":257,"code":"    it(`should call logger.log() upon successfully running workbox-build.copyWorkboxLibraries()`, async function () {\n      const loggerLogStub = sinon.stub();\n      const {\n        app\n      } = proxyquire(MODULE_PATH, {\n        './lib/logger': {\n          logger: {\n            log: loggerLogStub\n          }\n        },\n        'workbox-build': {\n          copyWorkboxLibraries: destDir => {\n            expect(destDir).to.eql(PROXIED_DEST_DIR);\n            return upath.join(destDir, 'workbox');\n          }\n        }\n      });\n      await app({\n        input: ['copyLibraries', PROXIED_DEST_DIR]\n      });\n      expect(loggerLogStub.callCount).to.eql(3);\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call params.showHelp() when passed 'help'","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":279,"column":56},"line":279,"code":"    it(`should call params.showHelp() when passed 'help'`, async function () {\n      const {\n        app\n      } = require(MODULE_PATH);\n\n      const params = {\n        input: ['help'],\n        showHelp: sinon.stub()\n      };\n      await app(params);\n      expect(params.showHelp.calledOnce).to.be.true;\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should call params.showHelp() when not passed any command","suites":["[workbox-cli] app.js","successful calls"],"updatePoint":{"line":291,"column":65},"line":291,"code":"    it(`should call params.showHelp() when not passed any command`, async function () {\n      const {\n        app\n      } = require(MODULE_PATH);\n\n      const params = {\n        input: [],\n        showHelp: sinon.stub()\n      };\n      await app(params);\n      expect(params.showHelp.calledOnce).to.be.true;\n    });","file":"workbox-cli/node/app.js","skipped":false,"dir":"test"},{"name":"should have required dependencies","suites":["[workbox-cli] package.json"],"updatePoint":{"line":13,"column":39},"line":13,"code":"  it(`should have required dependencies`, function () {\n    return new Promise((resolve, reject) => {\n      depcheck(upath.join(__dirname, '..', '..', '..', 'packages', 'workbox-cli'), {\n        ignoreDirs: ['build'],\n        ignoreMatches: ['@babel/runtime']\n      }, unusedDeps => {\n        if (unusedDeps.dependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.dependencies)}`));\n        }\n\n        if (unusedDeps.devDependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.devDependencies)}`));\n        }\n\n        if (Object.keys(unusedDeps.missing).length > 0) {\n          return reject(new Error(`Dependencies missing from package.json: ${JSON.stringify(unusedDeps.missing)}`));\n        }\n\n        resolve();\n      });\n    });\n  });","file":"workbox-cli/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should have no devDependencies","suites":["[workbox-cli] package.json"],"updatePoint":{"line":35,"column":36},"line":35,"code":"  it(`should have no devDependencies`, function () {\n    const pkg = require('../../../packages/workbox-cli/package.json');\n\n    if (pkg.devDependencies && Object.keys(pkg.devDependencies) > 0) {\n      throw new Error('There should not be devDependencies in this module.');\n    }\n  });","file":"workbox-cli/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should return an empty string when passed an error with no stack","suites":["[workbox-cli] lib/cleanup-stack-trace.js"],"updatePoint":{"line":18,"column":70},"line":18,"code":"  it(`should return an empty string when passed an error with no stack`, function () {\n    const error = new Error();\n    error.stack = '';\n    expect(cleanupStackTrace(error, CURRENT_MODULE_NAME)).to.eql('');\n  });","file":"workbox-cli/node/lib/cleanup-stack-trace.js","skipped":false,"dir":"test"},{"name":"should exclude every stack frame prior to the first frame of ","suites":["[workbox-cli] lib/cleanup-stack-trace.js"],"updatePoint":{"line":23,"column":89},"line":23,"code":"  it(`should exclude every stack frame prior to the first frame of ${CURRENT_MODULE_NAME}`, function () {\n    const error = new Error();\n    const cleanStackTrace = cleanupStackTrace(error, CURRENT_MODULE_NAME);\n    const frameCount = cleanStackTrace.split(`\\n`).length;\n    expect(frameCount).to.eql(1);\n  });","file":"workbox-cli/node/lib/cleanup-stack-trace.js","skipped":false,"dir":"test"},{"name":"should exclude every stack frame prior to the first frame of , when the error is nested","suites":["[workbox-cli] lib/cleanup-stack-trace.js"],"updatePoint":{"line":29,"column":115},"line":29,"code":"  it(`should exclude every stack frame prior to the first frame of ${CURRENT_MODULE_NAME}, when the error is nested`, function () {\n    let error;\n\n    (() => {\n      error = new Error();\n    })();\n\n    const cleanStackTrace = cleanupStackTrace(error, CURRENT_MODULE_NAME);\n    const frameCount = cleanStackTrace.split(`\\n`).length;\n    expect(frameCount).to.eql(2);\n  });","file":"workbox-cli/node/lib/cleanup-stack-trace.js","skipped":false,"dir":"test"},{"name":"should exclude error.message, and just return the stack frames","suites":["[workbox-cli] lib/cleanup-stack-trace.js"],"updatePoint":{"line":40,"column":68},"line":40,"code":"  it(`should exclude error.message, and just return the stack frames`, function () {\n    const error = new Error(`line 1\\nline 2\\nline 3`);\n    const cleanStackTrace = cleanupStackTrace(error, CURRENT_MODULE_NAME);\n    const frameCount = cleanStackTrace.split(`\\n`).length;\n    expect(frameCount).to.eql(1);\n  });","file":"workbox-cli/node/lib/cleanup-stack-trace.js","skipped":false,"dir":"test"},{"name":"should be a string","suites":["[workbox-cli] lib/help-text.js"],"updatePoint":{"line":11,"column":24},"line":11,"code":"  it(`should be a string`, function () {\n    const {\n      helpText\n    } = require('../../../../packages/workbox-cli/build/lib/help-text');\n\n    expect(helpText).to.be.a('string');\n  });","file":"workbox-cli/node/lib/help-text.js","skipped":false,"dir":"test"},{"name":"should call console.log() when logger.debug() is used","suites":["[workbox-cli] lib/logger.js"],"updatePoint":{"line":24,"column":59},"line":24,"code":"  it(`should call console.log() when logger.debug() is used`, function () {\n    const stub = sandbox.stub(console, 'log');\n    logger.debug('Test');\n    sandbox.restore();\n    expect(stub.calledOnce).to.be.true;\n  });","file":"workbox-cli/node/lib/logger.js","skipped":false,"dir":"test"},{"name":"should call console.log() when logger.log() is used","suites":["[workbox-cli] lib/logger.js"],"updatePoint":{"line":30,"column":57},"line":30,"code":"  it(`should call console.log() when logger.log() is used`, function () {\n    const stub = sandbox.stub(console, 'log');\n    logger.log('Test');\n    sandbox.restore();\n    expect(stub.calledOnce).to.be.true;\n  });","file":"workbox-cli/node/lib/logger.js","skipped":false,"dir":"test"},{"name":"should call console.warn() when logger.warn() is used","suites":["[workbox-cli] lib/logger.js"],"updatePoint":{"line":36,"column":59},"line":36,"code":"  it(`should call console.warn() when logger.warn() is used`, function () {\n    const stub = sandbox.stub(console, 'warn');\n    logger.warn('Test');\n    sandbox.restore();\n    expect(stub.calledOnce).to.be.true;\n  });","file":"workbox-cli/node/lib/logger.js","skipped":false,"dir":"test"},{"name":"should call console.error() when logger.error() is used","suites":["[workbox-cli] lib/logger.js"],"updatePoint":{"line":42,"column":61},"line":42,"code":"  it(`should call console.error() when logger.error() is used`, function () {\n    const stub = sandbox.stub(console, 'error');\n    logger.error('Test');\n    sandbox.restore();\n    expect(stub.calledOnce).to.be.true;\n  });","file":"workbox-cli/node/lib/logger.js","skipped":false,"dir":"test"},{"name":"should reject with a 'invalid-config-location' error when the answer is an empty string","suites":["[workbox-cli] lib/questions/ask-config-location.js"],"updatePoint":{"line":21,"column":93},"line":21,"code":"  it(`should reject with a 'invalid-config-location' error when the answer is an empty string`, async function () {\n    const {\n      askConfigLocation\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: ''\n        })\n      }\n    });\n\n    try {\n      await askConfigLocation();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['invalid-config-location']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-config-location.js","skipped":false,"dir":"test"},{"name":"should resolve with the valid answer to the question","suites":["[workbox-cli] lib/questions/ask-config-location.js"],"updatePoint":{"line":39,"column":58},"line":39,"code":"  it(`should resolve with the valid answer to the question`, async function () {\n    const expectedAnswer = 'expected answer';\n    const {\n      askConfigLocation\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: expectedAnswer\n        })\n      }\n    });\n    const answer = await askConfigLocation();\n    expect(answer).to.eql(expectedAnswer);\n  });","file":"workbox-cli/node/lib/questions/ask-config-location.js","skipped":false,"dir":"test"},{"name":"should reject with a 'no-file-extensions-found' error when the globDirectory doesn't contain any matching files","suites":["[workbox-cli] lib/questions/ask-extensions-to-cache.js"],"updatePoint":{"line":24,"column":117},"line":24,"code":"  it(`should reject with a 'no-file-extensions-found' error when the globDirectory doesn't contain any matching files`, async function () {\n    const {\n      askExtensionsToCache\n    } = proxyquire(MODULE_PATH, {\n      glob: (pattern, config, callback) => {\n        callback(null, []);\n      },\n      ora: () => {\n        return {\n          start: () => {\n            return {\n              stop: () => {}\n            };\n          }\n        };\n      }\n    });\n\n    try {\n      await askExtensionsToCache(GLOB_DIRECTORY);\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['no-file-extensions-found']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-extensions-to-cache.js","skipped":false,"dir":"test"},{"name":"should reject with a 'no-file-extensions-selected' error when the answer is an empty array","suites":["[workbox-cli] lib/questions/ask-extensions-to-cache.js"],"updatePoint":{"line":49,"column":96},"line":49,"code":"  it(`should reject with a 'no-file-extensions-selected' error when the answer is an empty array`, async function () {\n    const {\n      askExtensionsToCache\n    } = proxyquire(MODULE_PATH, {\n      glob: (pattern, config, callback) => {\n        callback(null, [`file.${SINGLE_EXTENSION}`]);\n      },\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: []\n        })\n      },\n      ora: () => {\n        return {\n          start: () => {\n            return {\n              stop: () => {}\n            };\n          }\n        };\n      }\n    });\n\n    try {\n      await askExtensionsToCache(GLOB_DIRECTORY);\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['no-file-extensions-selected']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-extensions-to-cache.js","skipped":false,"dir":"test"},{"name":"should resolve with the expected value when the answer is a single extension","suites":["[workbox-cli] lib/questions/ask-extensions-to-cache.js"],"updatePoint":{"line":79,"column":82},"line":79,"code":"  it(`should resolve with the expected value when the answer is a single extension`, async function () {\n    const {\n      askExtensionsToCache\n    } = proxyquire(MODULE_PATH, {\n      glob: (pattern, config, callback) => {\n        callback(null, [`file.${SINGLE_EXTENSION}`]);\n      },\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: [SINGLE_EXTENSION]\n        })\n      },\n      ora: () => {\n        return {\n          start: () => {\n            return {\n              stop: () => {}\n            };\n          }\n        };\n      }\n    });\n    const answer = await askExtensionsToCache(GLOB_DIRECTORY);\n    expect(answer).to.eql([`**/*.${SINGLE_EXTENSION}`]);\n  });","file":"workbox-cli/node/lib/questions/ask-extensions-to-cache.js","skipped":false,"dir":"test"},{"name":"should resolve with the expected value when the answer is multiple extensions","suites":["[workbox-cli] lib/questions/ask-extensions-to-cache.js"],"updatePoint":{"line":104,"column":83},"line":104,"code":"  it(`should resolve with the expected value when the answer is multiple extensions`, async function () {\n    const {\n      askExtensionsToCache\n    } = proxyquire(MODULE_PATH, {\n      glob: (pattern, config, callback) => {\n        callback(null, MULTIPLE_EXTENSIONS.map(extension => `file.${extension}`));\n      },\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: MULTIPLE_EXTENSIONS\n        })\n      },\n      ora: () => {\n        return {\n          start: () => {\n            return {\n              stop: () => {}\n            };\n          }\n        };\n      }\n    });\n    const answer = await askExtensionsToCache(GLOB_DIRECTORY);\n    expect(answer).to.eql([`**/*.{${MULTIPLE_EXTENSIONS.join(',')}}`]);\n  });","file":"workbox-cli/node/lib/questions/ask-extensions-to-cache.js","skipped":false,"dir":"test"},{"name":"should ignore the expected directories and extensions","suites":["[workbox-cli] lib/questions/ask-extensions-to-cache.js"],"updatePoint":{"line":129,"column":59},"line":129,"code":"  it(`should ignore the expected directories and extensions`, async function () {\n    const {\n      askExtensionsToCache\n    } = proxyquire(MODULE_PATH, {\n      glob: (pattern, config, callback) => {\n        expect(config.ignore).to.eql(['**/node_modules/**', '**/*.map']);\n        callback(null, MULTIPLE_EXTENSIONS.map(extension => `file.${extension}`));\n      },\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: MULTIPLE_EXTENSIONS\n        })\n      },\n      ora: () => {\n        return {\n          start: () => {\n            return {\n              stop: () => {}\n            };\n          }\n        };\n      }\n    });\n    await askExtensionsToCache(GLOB_DIRECTORY);\n  });","file":"workbox-cli/node/lib/questions/ask-extensions-to-cache.js","skipped":false,"dir":"test"},{"name":"should ask all the expected questions in the correct order, and return the expected result in generateSW mode","suites":["[workbox-cli] lib/questions/ask-questions.js"],"updatePoint":{"line":16,"column":115},"line":16,"code":"  it(`should ask all the expected questions in the correct order, and return the expected result in generateSW mode`, async function () {\n    // Using a stub that returns an increasing value for each call makes it\n    // easy to verify that all the stubs are called in the expected order,\n    // and to verify that the stub's responses are used to create the overall\n    // response in the expected fashion.\n    let count = 0;\n    const stub = sinon.stub();\n    const {\n      askQuestions\n    } = proxyquire(MODULE_PATH, {\n      './ask-root-of-web-app': {\n        askRootOfWebApp: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-extensions-to-cache': {\n        askExtensionsToCache: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-sw-dest': {\n        askSWDest: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-config-location': {\n        askConfigLocation: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-start_url-query-params': {\n        askQueryParametersInStartUrl: stub.callsFake(() => Promise.resolve(count++))\n      }\n    });\n    const answer = await askQuestions();\n    expect(answer).to.eql({\n      config: {\n        globDirectory: 0,\n        globPatterns: 1,\n        swDest: 2,\n        ignoreURLParametersMatching: 4\n      },\n      configLocation: 3\n    });\n    expect(stub.callCount).to.eql(5);\n  });","file":"workbox-cli/node/lib/questions/ask-questions.js","skipped":false,"dir":"test"},{"name":"should ask all the expected questions in the correct order, and return the expected result in injectManifest mode","suites":["[workbox-cli] lib/questions/ask-questions.js"],"updatePoint":{"line":54,"column":119},"line":54,"code":"  it(`should ask all the expected questions in the correct order, and return the expected result in injectManifest mode`, async function () {\n    // Using a stub that returns an increasing value for each call makes it\n    // easy to verify that all the stubs are called in the expected order,\n    // and to verify that the stub's responses are used to create the overall\n    // response in the expected fashion.\n    let count = 0;\n    const stub = sinon.stub();\n    const {\n      askQuestions\n    } = proxyquire(MODULE_PATH, {\n      './ask-root-of-web-app': {\n        askRootOfWebApp: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-extensions-to-cache': {\n        askExtensionsToCache: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-sw-src': {\n        askSWSrc: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-sw-dest': {\n        askSWDest: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-config-location': {\n        askConfigLocation: stub.callsFake(() => Promise.resolve(count++))\n      },\n      './ask-start_url-query-params': {\n        askQueryParametersInStartUrl: stub.callsFake(() => Promise.resolve(count++))\n      }\n    });\n    const answer = await askQuestions({\n      injectManifest: true\n    });\n    expect(answer).to.eql({\n      config: {\n        globDirectory: 0,\n        globPatterns: 1,\n        swSrc: 2,\n        swDest: 3\n      },\n      configLocation: 4\n    });\n    expect(stub.callCount).to.eql(5);\n  });","file":"workbox-cli/node/lib/questions/ask-questions.js","skipped":false,"dir":"test"},{"name":"should reject with a 'glob-directory-invalid' error when the answer isn't a valid directory","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":26,"column":97},"line":26,"code":"  it(`should reject with a 'glob-directory-invalid' error when the answer isn't a valid directory`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              // This will return false when our injected DIRECTORY value is\n              // passed in.\n              return path !== DIRECTORY;\n            }\n          };\n        }\n      }\n    });\n\n    try {\n      await askRootOfWebApp();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['glob-directory-invalid']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should reject with a 'glob-directory-invalid' error when the manual input is provided (directory does not exist)","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":58,"column":118},"line":58,"code":"  it(`should reject with a 'glob-directory-invalid' error when the manual input is provided (directory does not exist)`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY,\n          [questionManualInput]: CHILD_DIRECTORY\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              return path !== CHILD_DIRECTORY;\n            }\n          };\n        }\n      }\n    });\n\n    try {\n      await askRootOfWebApp();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['glob-directory-invalid']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should resolve with a valid answer to the question when no child directories are present (default: use current directory)","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":89,"column":127},"line":89,"code":"  it(`should resolve with a valid answer to the question when no child directories are present (default: use current directory)`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              // This will return true when our injected DIRECTORY value is\n              // passed in.\n              return path === DIRECTORY;\n            }\n          };\n        }\n      }\n    });\n    const answer = await askRootOfWebApp();\n    expect(answer).to.eql(DIRECTORY);\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should resolve with a valid answer to the question when manual input is provided (directory exists)","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":116,"column":105},"line":116,"code":"  it(`should resolve with a valid answer to the question when manual input is provided (directory exists)`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY,\n          [questionManualInput]: CHILD_DIRECTORY\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              return path === CHILD_DIRECTORY;\n            }\n          };\n        }\n      }\n    });\n    const answer = await askRootOfWebApp();\n    expect(answer).to.eql(CHILD_DIRECTORY);\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should resolve with a valid answer to the question when manual input is provided (directory exists and name contains white space)","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":142,"column":135},"line":142,"code":"  it(`should resolve with a valid answer to the question when manual input is provided (directory exists and name contains white space)`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY,\n          [questionManualInput]: CHILD_DIRECTORY_WHITE_SPACE\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              return path === CHILD_DIRECTORY_WHITE_SPACE;\n            }\n          };\n        }\n      }\n    });\n    const answer = await askRootOfWebApp();\n    expect(answer).to.eql(CHILD_DIRECTORY_WHITE_SPACE);\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should resolve with a valid answer to the question when manual input is provided (directory exists and name is composed of only white space)","suites":["[workbox-cli] lib/questions/ask-root-of-web-app.js"],"updatePoint":{"line":168,"column":146},"line":168,"code":"  it(`should resolve with a valid answer to the question when manual input is provided (directory exists and name is composed of only white space)`, async function () {\n    const {\n      askRootOfWebApp\n    } = proxyquire(MODULE_PATH, {\n      'glob': (pattern, config, callback) => {\n        callback(null, []);\n      },\n      'inquirer': {\n        prompt: () => Promise.resolve({\n          [questionRootDirectory]: DIRECTORY,\n          [questionManualInput]: CHILD_DIRECTORY_BLANK\n        })\n      },\n      'fs-extra': {\n        stat: path => {\n          return {\n            isDirectory: () => {\n              return path === CHILD_DIRECTORY_BLANK;\n            }\n          };\n        }\n      }\n    });\n    const answer = await askRootOfWebApp();\n    expect(answer).to.eql(CHILD_DIRECTORY_BLANK);\n  });","file":"workbox-cli/node/lib/questions/ask-root-of-web-app.js","skipped":false,"dir":"test"},{"name":"should resolve with a default search parameters if answered no to the question","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":30,"column":84},"line":30,"code":"  it(`should resolve with a default search parameters if answered no to the question`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = false;\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching\n        })\n      }\n    });\n    const answer = await askQueryParametersInStartUrl();\n    expect(answer).to.eql(DEFAULT_IGNORED_URL_PARAMETERS);\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should throw 'no-search-parameters-supplied' if answered yes and no url search parameters are passed","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":44,"column":106},"line":44,"code":"  it(`should throw 'no-search-parameters-supplied' if answered yes and no url search parameters are passed`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = true;\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching\n        })\n      }\n    });\n\n    try {\n      await askQueryParametersInStartUrl();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['no-search-parameters-supplied']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should throw 'invalid-search-parameters-supplied' if url search parameter passed is prefixed with '?' or '/'","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":63,"column":114},"line":63,"code":"  it(`should throw 'invalid-search-parameters-supplied' if url search parameter passed is prefixed with '?' or '/'`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = true;\n    const ignoreURLParametersMatching = '?source';\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching,\n          [question_ignoreURLParametersMatching]: ignoreURLParametersMatching\n        })\n      }\n    });\n\n    try {\n      await askQueryParametersInStartUrl();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['invalid-search-parameters-supplied']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should throw 'invalid-search-parameters-supplied' if one of the provided url search parameters is prefixed with '?' or '/'","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":84,"column":128},"line":84,"code":"  it(`should throw 'invalid-search-parameters-supplied' if one of the provided url search parameters is prefixed with '?' or '/'`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = true;\n    const ignoreURLParametersMatching = 'search,version,?language';\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching,\n          [question_ignoreURLParametersMatching]: ignoreURLParametersMatching\n        })\n      }\n    });\n\n    try {\n      await askQueryParametersInStartUrl();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['invalid-search-parameters-supplied']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should resolve with a list of search parameters when a valid url search parameter is passed","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":105,"column":97},"line":105,"code":"  it(`should resolve with a list of search parameters when a valid url search parameter is passed`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = true;\n    const ignoreURLParametersMatching = 'search';\n    const expectedAnswer = DEFAULT_IGNORED_URL_PARAMETERS.concat(toRegex(ignoreURLParametersMatching));\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching,\n          [question_ignoreURLParametersMatching]: ignoreURLParametersMatching\n        })\n      }\n    });\n    const answer = await askQueryParametersInStartUrl();\n    expect(answer).to.eql(expectedAnswer);\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should resolve with a list of search parameters when a valid list of url search parameters is passed","suites":["[workbox-cli] lib/questions/ask-start_url-query-params.js"],"updatePoint":{"line":122,"column":106},"line":122,"code":"  it(`should resolve with a list of search parameters when a valid list of url search parameters is passed`, async function () {\n    const shouldAskForIgnoreURLParametersMatching = true;\n    const ignoreURLParametersMatching = 'search,version,language';\n    const expectedAnswer = DEFAULT_IGNORED_URL_PARAMETERS.concat(ignoreURLParametersMatching.split(',').map(toRegex));\n    const {\n      askQueryParametersInStartUrl\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [question_shouldAskForIgnoreURLParametersMatching]: shouldAskForIgnoreURLParametersMatching,\n          [question_ignoreURLParametersMatching]: ignoreURLParametersMatching\n        })\n      }\n    });\n    const answer = await askQueryParametersInStartUrl();\n    expect(answer).to.eql(expectedAnswer);\n  });","file":"workbox-cli/node/lib/questions/ask-start_url-query-params.js","skipped":false,"dir":"test"},{"name":"should reject with a 'invalid-sw-dest' error when the answer is empty","suites":["[workbox-cli] lib/questions/ask-sw-dest.js"],"updatePoint":{"line":21,"column":75},"line":21,"code":"  it(`should reject with a 'invalid-sw-dest' error when the answer is empty`, async function () {\n    const {\n      askSWDest\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: ''\n        })\n      }\n    });\n\n    try {\n      await askSWDest();\n      throw new Error('Unexpected success.');\n    } catch (error) {\n      expect(error.message).to.eql(errors['invalid-sw-dest']);\n    }\n  });","file":"workbox-cli/node/lib/questions/ask-sw-dest.js","skipped":false,"dir":"test"},{"name":"should reject with a valid answer to the question","suites":["[workbox-cli] lib/questions/ask-sw-dest.js"],"updatePoint":{"line":39,"column":55},"line":39,"code":"  it(`should reject with a valid answer to the question`, async function () {\n    const expectedAnswer = 'expected answer';\n    const {\n      askSWDest\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: expectedAnswer\n        })\n      }\n    });\n    const answer = await askSWDest();\n    expect(answer).to.eql(expectedAnswer);\n  });","file":"workbox-cli/node/lib/questions/ask-sw-dest.js","skipped":false,"dir":"test"},{"name":"should resolve with a valid answer to the question","suites":["[workbox-cli] lib/questions/ask-sw-src.js"],"updatePoint":{"line":17,"column":56},"line":17,"code":"  it(`should resolve with a valid answer to the question`, async function () {\n    const expectedAnswer = 'expected answer';\n    const {\n      askSWSrc\n    } = proxyquire(MODULE_PATH, {\n      inquirer: {\n        prompt: () => Promise.resolve({\n          [QUESTION_NAME]: expectedAnswer\n        })\n      }\n    });\n    const answer = await askSWSrc();\n    expect(answer).to.eql(expectedAnswer);\n  });","file":"workbox-cli/node/lib/questions/ask-sw-src.js","skipped":false,"dir":"test"},{"name":"should write the configuration to the expected location based on the answers provided","suites":["[workbox-cli] lib/run-wizard.js"],"updatePoint":{"line":18,"column":91},"line":18,"code":"  it(`should write the configuration to the expected location based on the answers provided`, async function () {\n    const configLocation = upath.join('path', 'to', 'config.js');\n    const config = {\n      dummy: 123,\n      regExp: [/1/, /2/]\n    };\n    const fseWriteFileStub = sinon.stub().resolves();\n    const loggerStub = sinon.stub();\n    const {\n      runWizard\n    } = proxyquire(MODULE_PATH, {\n      './logger': {\n        logger: {\n          log: loggerStub\n        }\n      },\n      './questions/ask-questions': {\n        askQuestions: () => {\n          return {\n            config,\n            configLocation\n          };\n        }\n      },\n      'fs-extra': {\n        writeFile: fseWriteFileStub\n      }\n    });\n    await runWizard();\n    const fseArgs = fseWriteFileStub.firstCall.args;\n    expect(fseArgs[0]).to.eql(configLocation); // See https://github.com/GoogleChrome/workbox/issues/2796\n\n    expect(fseArgs[1]).to.eql(`module.exports = {\n\\tdummy: 123,\n\\tregExp: [\n\\t\\t/1/,\n\\t\\t/2/\n\\t]\n};`);\n    expect(loggerStub.calledTwice).to.be.true;\n  });","file":"workbox-cli/node/lib/run-wizard.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-core]"],"updatePoint":{"line":20,"column":30},"line":20,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-core/sw/');\n  });","file":"workbox-core/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load workbox-core in a service worker.","suites":["[workbox-core] Load core in the browser"],"updatePoint":{"line":28,"column":51},"line":28,"code":"  it(`should load workbox-core in a service worker.`, async function () {\n    await webdriver.get(testingURL);\n    await activateAndControlSW(swURL); // If the service worker activated, it meant the assertions in sw.js were\n    // met and workbox-core exposes the expected API and defaults that were\n    // expected\n  });","file":"workbox-core/integration/test-all.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-expiration]"],"updatePoint":{"line":28,"column":30},"line":28,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-expiration/sw/');\n  });","file":"workbox-expiration/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page with entries managed by maxEntries","suites":["[workbox-expiration] Plugin"],"updatePoint":{"line":38,"column":59},"line":38,"code":"  it(`should load a page with entries managed by maxEntries`, async function () {\n    const swURL = `${baseURL}sw-max-entries.js`; // Wait for the service worker to register and activate.\n\n    await activateAndControlSW(swURL);\n    let error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-1.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n\n    if (error) {\n      throw new Error(error);\n    } // Caching is done async from returning a response, so we may need\n    // to wait before the cache has some content.\n\n\n    await waitUntil(async () => {\n      const keys = await runInSW('cachesKeys');\n      return keys.length > 0;\n    });\n    const keys = await runInSW('cachesKeys');\n    expect(keys).to.deep.equal(['expiration-plugin-max-entries']);\n    let cachedRequests = await runInSW('cacheURLs', keys[0]);\n    expect(cachedRequests).to.eql([`${baseURL}example-1.txt`]);\n    error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-2.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n\n    if (error) {\n      throw new Error(error);\n    } // Caching is done async from returning a response, so we may need\n    // to wait before the cache has be cleaned up.\n\n\n    await waitUntil(async () => {\n      cachedRequests = await runInSW('cacheURLs', keys[0]);\n      return cachedRequests.length === 1 && cachedRequests[0] === `${baseURL}example-2.txt`;\n    });\n  });","file":"workbox-expiration/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page with entries managed by maxAgeSeconds","suites":["[workbox-expiration] Plugin"],"updatePoint":{"line":75,"column":62},"line":75,"code":"  it(`should load a page with entries managed by maxAgeSeconds`, async function () {\n    const swURL = `${baseURL}sw-max-age-seconds.js`; // Wait for the service worker to register and activate.\n\n    await activateAndControlSW(swURL);\n    let error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-1.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n\n    if (error) {\n      throw new Error(error);\n    } // Caching is done async from returning a response, so we may need\n    // to wait before the cache has some content.\n\n\n    await waitUntil(async () => {\n      const keys = await runInSW('cachesKeys');\n      return keys.length > 0;\n    });\n    const keys = await runInSW('cachesKeys');\n    expect(keys).to.deep.equal(['expiration-plugin-max-age-seconds']);\n    let cachedRequests = await runInSW('cacheURLs', keys[0]);\n    expect(cachedRequests).to.eql([`${baseURL}example-1.txt`]); // Wait 2 seconds to expire entry.\n\n    await new Promise(resolve => {\n      setTimeout(resolve, 2000);\n    });\n    error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-2.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n\n    if (error) {\n      throw new Error(error);\n    } // Caching is done async from returning a response, so we may need\n    // to wait before the cache has be cleaned up.\n\n\n    await waitUntil(async () => {\n      cachedRequests = await runInSW('cacheURLs', keys[0]);\n      return cachedRequests.length === 1 && cachedRequests[0] === `${baseURL}example-2.txt`;\n    });\n  });","file":"workbox-expiration/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should clean up when deleteCacheAndMetadata() is called","suites":["[workbox-expiration] Plugin"],"updatePoint":{"line":116,"column":61},"line":116,"code":"  it(`should clean up when deleteCacheAndMetadata() is called`, async function () {\n    const swURL = `${baseURL}sw-deletion.js`; // Wait for the service worker to register and activate.\n\n    await activateAndControlSW(swURL);\n    let error = await webdriver.executeAsyncScript(cb => {\n      fetch(`example-1.txt`).then(() => cb()).catch(err => cb(err.message));\n    });\n\n    if (error) {\n      throw new Error(error);\n    } // Caching is done async from returning a response, so we may need\n    // to wait before the cache has some content.\n\n\n    await waitUntil(async () => {\n      const keys = await runInSW('cachesKeys');\n      return keys.length > 0;\n    });\n    let keys = await runInSW('cachesKeys');\n    expect(keys).to.deep.equal(['expiration-plugin-deletion']);\n    const existence = await runInSW('doesDbExist', 'workbox-expiration');\n    expect(existence).to.be.true;\n    error = await webdriver.executeAsyncScript(cb => {\n      navigator.serviceWorker.addEventListener('message', event => {\n        cb(event.data);\n      }, {\n        once: true\n      });\n      navigator.serviceWorker.controller.postMessage('delete');\n    });\n\n    if (error) {\n      throw new Error(error);\n    } // After cleanup, there shouldn't be any cache keys or IndexedDB entries\n    // with the cacheName 'expiration-plugin-deletion'.\n\n\n    keys = await runInSW('cachesKeys');\n    expect(keys).to.deep.equal([]);\n    const entries = (await runInSW('getObjectStoreEntries', 'workbox-expiration', 'cache-entries')).filter(entry => {\n      return entry.cacheName === 'expiration-plugin-deletion';\n    });\n    expect(entries).to.deep.equal([]);\n  });","file":"workbox-expiration/integration/test-all.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-google-analytics]"],"updatePoint":{"line":26,"column":30},"line":26,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-google-analytics/sw/');\n  });","file":"workbox-google-analytics/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page with service worker","suites":["[workbox-google-analytics] initialize"],"updatePoint":{"line":63,"column":44},"line":63,"code":"  it(`should load a page with service worker`, async function () {\n    const err = await webdriver.executeAsyncScript(done => {\n      fetch('https://www.google-analytics.com/analytics.js', {\n        mode: 'no-cors'\n      }).then(() => done(), err => done(err.message));\n    });\n    expect(err).to.not.exist;\n  });","file":"workbox-google-analytics/integration/test-all.js","skipped":false,"dir":"test"},{"name":"replay failed Google Analytics hits","suites":["[workbox-google-analytics] initialize"],"updatePoint":{"line":71,"column":41},"line":71,"code":"  it(`replay failed Google Analytics hits`, async function () {\n    // Skip this test in browsers that don't support background sync.\n    // TODO(philipwalton): figure out a way to work around this.\n    const browserSupportsSync = await webdriver.executeScript(() => {\n      return 'SyncManager' in window;\n    });\n    if (!browserSupportsSync) this.skip(); // Send a hit while online to ensure regular requests work.\n\n    await webdriver.executeAsyncScript(done => {\n      window.gtag('event', 'beacon', {\n        transport_type: 'beacon',\n        event_callback: () => done()\n      });\n    });\n    let requests = await webdriver.executeAsyncScript(messageSW, {\n      action: 'get-spied-requests'\n    });\n    expect(requests).to.have.lengthOf(1); // Reset the spied requests array.\n\n    await webdriver.executeAsyncScript(messageSW, {\n      action: 'clear-spied-requests'\n    }); // Switch the service worker into \"offline\" mode.\n\n    await webdriver.executeAsyncScript(messageSW, {\n      action: 'simulate-offline',\n      value: true\n    });\n    await webdriver.executeAsyncScript(done => {\n      window.gtag('event', 'beacon', {\n        transport_type: 'beacon',\n        event_label: Date.now(),\n        event_callback: () => {\n          // See https://github.com/GoogleChrome/workbox/issues/2168\n          setTimeout(done, 50);\n        }\n      });\n    });\n    await webdriver.executeAsyncScript(done => {\n      window.gtag('event', 'pixel', {\n        transport_type: 'image',\n        event_label: Date.now(),\n        event_callback: () => {\n          // See https://github.com/GoogleChrome/workbox/issues/2168\n          setTimeout(done, 50);\n        }\n      });\n    }); // This request should not match GA routes, so it shouldn't be replayed.\n\n    await webdriver.executeAsyncScript(done => {\n      fetch('https://httpbin.org/get').then(() => done());\n    }); // Get all spied requests and ensure there haven't been any (since we're\n    // offline).\n\n    requests = await webdriver.executeAsyncScript(messageSW, {\n      action: 'get-spied-requests'\n    });\n    expect(requests).to.have.lengthOf(0); // Switch the service worker into \"online\" mode.\n\n    await webdriver.executeAsyncScript(messageSW, {\n      action: 'simulate-offline',\n      value: false\n    }); // Dispatch a sync event.\n\n    await webdriver.executeAsyncScript(messageSW, {\n      action: 'dispatch-sync-event'\n    }); // Wait until all expected requests have replayed.\n\n    await waitUntil(async () => {\n      requests = await webdriver.executeAsyncScript(messageSW, {\n        action: 'get-spied-requests'\n      });\n      return requests.length === 2;\n    }, 25, 200); // Parse the request bodies to set the params as an object and convert the\n    // qt param to a number.\n\n    for (const request of requests) {\n      request.params = qs.parse(request.body);\n      request.params.qt = Number(request.params.qt);\n      request.originalTime = request.timestamp - request.params.qt;\n    }\n\n    expect(requests[0].params.ea).to.equal('beacon');\n    expect(requests[1].params.ea).to.equal('pixel'); // Ensure the hit's qt params were present and greater than 0,\n    // and ensure those values reflect the original order of the hits.\n\n    expect(requests[0].params.qt > 0).to.be.true;\n    expect(requests[1].params.qt > 0).to.be.true;\n    expect(requests[0].originalTime < requests[1].originalTime).to.be.true;\n  });","file":"workbox-google-analytics/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should support disabling previously enabled navigation preload","suites":["navigationPreload.disable"],"updatePoint":{"line":30,"column":68},"line":30,"code":"  it(`should support disabling previously enabled navigation preload`, async function () {\n    await activateAndControlSW(`${baseURL}sw-default-header.js`);\n    const isEnabled = await runInSW('isNavigationPreloadSupported');\n\n    if (!isEnabled) {\n      // Just bail early if navigation preload isn't supported, since testing\n      // the disable flow isn't meaningful.\n      return this.skip();\n    }\n\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(0);\n    await global.__workbox.webdriver.get(integrationURL);\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(1); // Active the new service worker that has navigation preload disabled.\n\n    await activateAndControlSW(`${baseURL}sw-disable.js`);\n    await global.__workbox.webdriver.get(integrationURL); // With navigation preload now disabled, the synthetic response from the\n    // service worker should fulfill the navigation request, and the server\n    // won't get another HTTP request.\n\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(1);\n  });","file":"workbox-navigation-preload/integration/test-disable.js","skipped":false,"dir":"test"},{"name":"should make a network request if navigation preload is supported","suites":["navigationPreload.enable"],"updatePoint":{"line":30,"column":70},"line":30,"code":"  it(`should make a network request if navigation preload is supported`, async function () {\n    await activateAndControlSW(`${baseURL}sw-default-header.js`);\n    const isEnabled = await runInSW('isNavigationPreloadSupported');\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(0);\n    await global.__workbox.webdriver.get(integrationURL); // If navigation preload is enabled, there should be 1 request. Otherwise,\n    // no requests.\n\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(isEnabled ? 1 : 0); // Check to make sure that the correct header value was sent if navigation\n    // preload is enabled.\n\n    expect(requestCounter.getHeaderCount('true')).to.eql(isEnabled ? 1 : 0);\n  });","file":"workbox-navigation-preload/integration/test-enable.js","skipped":false,"dir":"test"},{"name":"should make a network request if navigation preload is supported, with a custom header value","suites":["navigationPreload.enable"],"updatePoint":{"line":42,"column":98},"line":42,"code":"  it(`should make a network request if navigation preload is supported, with a custom header value`, async function () {\n    await activateAndControlSW(`${baseURL}sw-custom-header.js`);\n    const isEnabled = await runInSW('isNavigationPreloadSupported');\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(0);\n    await global.__workbox.webdriver.get(integrationURL); // If navigation preload is enabled, there should be 1 request. Otherwise,\n    // no requests.\n\n    expect(requestCounter.getURLCount(integrationURLPath)).to.eql(isEnabled ? 1 : 0); // Check to make sure that the correct header value was sent if navigation\n    // preload is enabled.\n\n    expect(requestCounter.getHeaderCount('custom-value')).to.eql(isEnabled ? 1 : 0); // There shouldn't be any requests with the default header value, 'true'.\n\n    expect(requestCounter.getHeaderCount('true')).to.eql(0);\n  });","file":"workbox-navigation-preload/integration/test-enable.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-navigation-preload]"],"updatePoint":{"line":13,"column":30},"line":13,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-navigation-preload/sw/');\n  });","file":"workbox-navigation-preload/integration/test-sw.js","skipped":false,"dir":"test"},{"name":"should clean up outdated precached after activation","suites":["[workbox-precaching] cleanupOutdatedCaches()"],"updatePoint":{"line":22,"column":57},"line":22,"code":"  it(`should clean up outdated precached after activation`, async function () {\n    // Add an item to an outdated cache.\n    const preActivateKeys = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      // Opening a cache with a given name will cause it to \"exist\", even if it's empty.\n      caches.open('workbox-precache-http://localhost:3004/test/workbox-precaching/static/cleanup-outdated-caches/').then(() => caches.keys()).then(keys => cb(keys)).catch(err => cb(err.message));\n    });\n    expect(preActivateKeys).to.include('workbox-precache-http://localhost:3004/test/workbox-precaching/static/cleanup-outdated-caches/');\n    expect(preActivateKeys).to.not.include('workbox-precache-v2-http://localhost:3004/test/workbox-precaching/static/cleanup-outdated-caches/'); // Register the first service worker.\n\n    await activateAndControlSW(`${baseURL}sw.js`);\n    const postActivateKeys = await runInSW('cachesKeys');\n    expect(postActivateKeys).to.not.include('workbox-precache-http://localhost:3004/test/workbox-precaching/static/cleanup-outdated-caches/');\n    expect(postActivateKeys).to.include('workbox-precache-v2-http://localhost:3004/test/workbox-precaching/static/cleanup-outdated-caches/');\n  });","file":"workbox-precaching/integration/test-cleanup-outdated-caches.js","skipped":false,"dir":"test"},{"name":"should load a page with service worker ","suites":["[workbox-precaching] Precache and Update"],"updatePoint":{"line":22,"column":45},"line":22,"code":"  it(`should load a page with service worker `, async function () {\n    const SW_1_URL = `${baseURL}sw-1.js`;\n    const SW_2_URL = `${baseURL}sw-2.js`;\n    const cacheName = 'workbox-precache-v2-http://localhost:3004/test/workbox-precaching/static/precache-and-update/';\n\n    let requestCounter = global.__workbox.server.startCountingRequests(); // Register the first service worker.\n\n\n    await activateAndControlSW(SW_1_URL); // Check that only the precache cache was created.\n\n    const keys = await runInSW('cachesKeys');\n    expect(keys).to.eql([cacheName]); // Check that the cached requests are what we expect for sw-1.js\n\n    let cachedRequests = await runInSW('cacheURLs', cacheName);\n    expect(cachedRequests).to.have.members(['http://localhost:3004/test/workbox-precaching/static/precache-and-update/index.html?__WB_REVISION__=1', 'http://localhost:3004/test/workbox-precaching/static/precache-and-update/styles/index.css?__WB_REVISION__=1']);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/styles/index.css')).to.equal(1);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/index.html')).to.equal(1); // Unregister the old counter, and start a new count.\n\n    global.__workbox.server.stopCountingRequests(requestCounter);\n\n    requestCounter = global.__workbox.server.startCountingRequests(); // Request the page and check that the precached assets weren't requested from the network.\n    // Include the default ignoreURLParametersMatching query parameters.\n\n    await global.__workbox.webdriver.get(`${baseURL}index.html`);\n    await global.__workbox.webdriver.get(`${baseURL}index.html?utm_source=test`);\n    await global.__workbox.webdriver.get(`${baseURL}index.html?fbclid=test`);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/')).to.eql(0);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/index.html')).to.eql(0);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/index.html?utm_source=test')).to.eql(0);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/index.html?fbclid=test')).to.eql(0);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/styles/index.css')).to.eql(0); // Unregister the old counter, and start a new count.\n\n    global.__workbox.server.stopCountingRequests(requestCounter);\n\n    requestCounter = global.__workbox.server.startCountingRequests(); // Activate the second service worker\n\n    await activateAndControlSW(SW_2_URL); // Add a slight delay for the caching operation to complete.\n\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/index.html')).to.equal(1);\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/hashed-file.abcd1234.txt')).to.equal(1); // Check that the cached entries were deleted / added as expected when\n    // updating from sw-1.js to sw-2.js\n\n    cachedRequests = await runInSW('cacheURLs', cacheName);\n    expect(cachedRequests).to.have.members(['http://localhost:3004/test/workbox-precaching/static/precache-and-update/index.html?__WB_REVISION__=2', 'http://localhost:3004/test/workbox-precaching/static/precache-and-update/hashed-file.abcd1234.txt']); // Unregister the old counter, and start a new count.\n\n    global.__workbox.server.stopCountingRequests(requestCounter);\n\n    requestCounter = global.__workbox.server.startCountingRequests();\n    await global.__workbox.webdriver.get(baseURL); // Ensure the HTML page is returned from cache and not network.\n\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/')).to.eql(0); // Ensure the now deleted index.css file is returned from network and not cache.\n\n    expect(requestCounter.getURLCount('/test/workbox-precaching/static/precache-and-update/styles/index.css')).to.equal(1);\n\n    global.__workbox.server.stopCountingRequests(requestCounter);\n  });","file":"workbox-precaching/integration/test-precache-and-update.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-precaching]"],"updatePoint":{"line":13,"column":30},"line":13,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-precaching/sw/');\n  });","file":"workbox-precaching/integration/test-sw.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-range-requests]"],"updatePoint":{"line":24,"column":30},"line":24,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-range-requests/sw/');\n  });","file":"workbox-range-requests/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should return a partial response that satisfies the request's Range: header, and an error response when it can't be satisfied","suites":["[workbox-range-requests] Plugin"],"updatePoint":{"line":35,"column":131},"line":35,"code":"  it(`should return a partial response that satisfies the request's Range: header, and an error response when it can't be satisfied`, async function () {\n    const swURL = `${testingURL}sw.js`;\n    await activateAndControlSW(swURL);\n    const dummyURL = `this-file-doesnt-exist.txt`;\n    const partialResponseBody = await webdriver.executeAsyncScript((dummyURL, cb) => {\n      // Prime the cache, and then make the Range: request.\n      fetch(new Request(dummyURL, {\n        headers: {\n          Range: `bytes=5-6`\n        }\n      })).then(response => response.text()).then(text => cb(text)).catch(error => cb(error.message));\n    }, dummyURL); // The values used for the byte range are inclusive, so we'll end up with\n    // 11 characters returned in the partial response.\n\n    expect(partialResponseBody).to.eql('56');\n    const errorResponseStatus = await webdriver.executeAsyncScript((dummyURL, cb) => {\n      // These are arbitrary large values that extend past the end of the file.\n      fetch(new Request(dummyURL, {\n        headers: {\n          Range: `bytes=100-101`\n        }\n      })).then(response => cb(response.status));\n    }, dummyURL); // The expected error status is 416 (Range Not Satisfiable)\n\n    expect(errorResponseStatus).to.eql(416);\n  });","file":"workbox-range-requests/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should load a page and route requests","suites":["[workbox-routing] Route via NavigationRoute"],"updatePoint":{"line":17,"column":43},"line":17,"code":"  it(`should load a page and route requests`, async function () {\n    // Load the page and wait for the first service worker to register and activate.\n    await global.__workbox.webdriver.get(testingURL);\n    await activateAndControlSW(swURL);\n    const nestedURL = `${testingURL}TestNavigationURL`;\n    await global.__workbox.webdriver.get(nestedURL);\n    const bodyText = await global.__workbox.webdriver.executeScript(() => {\n      return document.body.textContent;\n    });\n    expect(bodyText).to.equal(`NavigationRoute.${nestedURL}`);\n  });","file":"workbox-routing/integration/test-navigation-route.js","skipped":false,"dir":"test"},{"name":"should honor a route created by a Route object","suites":["[workbox-routing] Basic Route"],"updatePoint":{"line":21,"column":52},"line":21,"code":"  it(`should honor a route created by a Route object`, async function () {\n    const testURL = `${testServerAddress}/routeObject`;\n    const responseBody = await global.__workbox.webdriver.executeAsyncScript((testURL, cb) => {\n      fetch(testURL).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testURL);\n    expect(responseBody).to.eql(testURL);\n  });","file":"workbox-routing/integration/test-routing-basic.js","skipped":false,"dir":"test"},{"name":"should honor a same-origin route created by a string","suites":["[workbox-routing] Basic Route"],"updatePoint":{"line":28,"column":58},"line":28,"code":"  it(`should honor a same-origin route created by a string`, async function () {\n    const testURL = `${testServerAddress}/sameOrigin`;\n    const responseBody = await global.__workbox.webdriver.executeAsyncScript((testURL, cb) => {\n      fetch(testURL).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testURL);\n    expect(responseBody).to.eql(testURL);\n  });","file":"workbox-routing/integration/test-routing-basic.js","skipped":false,"dir":"test"},{"name":"should honor a cross-origin route created by a string","suites":["[workbox-routing] Basic Route"],"updatePoint":{"line":35,"column":59},"line":35,"code":"  it(`should honor a cross-origin route created by a string`, async function () {\n    const testURL = 'https://example.com/crossOrigin';\n    const responseBody = await global.__workbox.webdriver.executeAsyncScript((testURL, cb) => {\n      fetch(testURL).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testURL);\n    expect(responseBody).to.eql(testURL);\n  });","file":"workbox-routing/integration/test-routing-basic.js","skipped":false,"dir":"test"},{"name":"should return a 404 when passed a URL that isn't routed and doesn't exist","suites":["[workbox-routing] Basic Route"],"updatePoint":{"line":42,"column":79},"line":42,"code":"  it(`should return a 404 when passed a URL that isn't routed and doesn't exist`, async function () {\n    const testURL = `${testServerAddress}/doesNotMatch`;\n    const responseStatus = await global.__workbox.webdriver.executeAsyncScript((testURL, cb) => {\n      fetch(testURL).then(response => cb(response.status)).catch(err => cb(err.message));\n    }, testURL);\n    expect(responseStatus).to.eql(404);\n  });","file":"workbox-routing/integration/test-routing-basic.js","skipped":false,"dir":"test"},{"name":"should load a page and route requests","suites":["[workbox-routing] Route via RegExp"],"updatePoint":{"line":17,"column":43},"line":17,"code":"  it(`should load a page and route requests`, async function () {\n    // Load the page and wait for the first service worker to register and activate.\n    await global.__workbox.webdriver.get(testingURL);\n    await activateAndControlSW(swURL);\n    let testCounter = 0;\n    let response = await global.__workbox.webdriver.executeAsyncScript((testCounter, cb) => {\n      fetch(new URL(`/RegExp/${testCounter}/`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testCounter);\n    expect(response).to.equal(`RegExp.${testServerAddress}/RegExp/${testCounter}/`);\n    testCounter += 1;\n    response = await global.__workbox.webdriver.executeAsyncScript((testCounter, cb) => {\n      fetch(new URL(`/regular-expression/${testCounter}/`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testCounter);\n    expect(response).to.equal(`regular-expression.${testServerAddress}/regular-expression/${testCounter}/`);\n    testCounter += 1;\n    response = await global.__workbox.webdriver.executeAsyncScript((testCounter, cb) => {\n      fetch(new URL(`/RegExpRoute/RegExp/${testCounter}/`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testCounter);\n    expect(response).to.equal(`RegExpRoute.RegExp.${testServerAddress}/RegExpRoute/RegExp/${testCounter}/`);\n    testCounter += 1;\n    response = await global.__workbox.webdriver.executeAsyncScript((testCounter, cb) => {\n      fetch(new URL(`/RegExpRoute/regular-expression/${testCounter}/`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    }, testCounter);\n    expect(response).to.equal(`RegExpRoute.regular-expression.${testServerAddress}/RegExpRoute/regular-expression/${testCounter}/`);\n  });","file":"workbox-routing/integration/test-routing-regex.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-routing]"],"updatePoint":{"line":13,"column":30},"line":13,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-routing/sw/');\n  });","file":"workbox-routing/integration/test-sw.js","skipped":false,"dir":"test"},{"name":"should respond with a cached response","suites":["[workbox-strategies] CacheFirst Requests"],"updatePoint":{"line":25,"column":43},"line":25,"code":"  it(`should respond with a cached response`, async function () {\n    const swURL = `${baseURL}sw.js`; // Wait for the service worker to register and activate.\n\n    await activateAndControlSW(swURL);\n    let response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(new URL(`/test/workbox-strategies/static/cache-first/example.txt`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    expect(response.trim()).to.equal('hello');\n    expect(requestCounter.getURLCount('/test/workbox-strategies/static/cache-first/example.txt')).to.eql(1); // This request should come from cache and not the server\n\n    response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(new URL(`/test/workbox-strategies/static/cache-first/example.txt`, location).href).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    expect(response.trim()).to.equal('hello');\n    expect(requestCounter.getURLCount('/test/workbox-strategies/static/cache-first/example.txt')).to.eql(1);\n  });","file":"workbox-strategies/integration/test-cacheFirst.js","skipped":false,"dir":"test"},{"name":"should respond with a cached response","suites":["[workbox-strategies] CacheOnly"],"updatePoint":{"line":20,"column":43},"line":20,"code":"  it(`should respond with a cached response`, async function () {\n    const swURL = `${baseURL}sw.js`; // Wait for the service worker to register and activate.\n\n    await activateAndControlSW(swURL);\n    let response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/CacheOnly/InCache/`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    expect(response).to.eql('Cached');\n    response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/CacheOnly/NotInCache/`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    expect(response).to.not.eql('Cached');\n  });","file":"workbox-strategies/integration/test-cacheOnly.js","skipped":false,"dir":"test"},{"name":"should respond with a non-cached entry but stash request in a cache","suites":["[workbox-strategies] NetworkFirst Requests"],"updatePoint":{"line":24,"column":73},"line":24,"code":"  it(`should respond with a non-cached entry but stash request in a cache`, async function () {\n    const swURL = `${baseURL}sw.js`; // Wait for the service worker to register and activate.\n\n    await activateAndControlSW(swURL);\n    const cacheName = 'network-first';\n    let response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const firstResponse = response.trim();\n    expect(firstResponse).to.not.equal('Cached'); // Writing to the cache is asynchronous, so this might not happen right away.\n\n    await waitUntil(async () => {\n      const responseText = await runInSW('getCachedResponseText', cacheName, '/__WORKBOX/uniqueValue');\n      return responseText === firstResponse;\n    });\n    response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const secondResponse = response.trim();\n    expect(secondResponse).to.not.equal(firstResponse); // Writing to the cache is asynchronous, so this might not happen right away.\n\n    await waitUntil(async () => {\n      const responseText = await runInSW('getCachedResponseText', cacheName, '/__WORKBOX/uniqueValue');\n      return responseText === secondResponse;\n    });\n  });","file":"workbox-strategies/integration/test-networkFirst.js","skipped":false,"dir":"test"},{"name":"should respond with a non-cached entry","suites":["[workbox-strategies] NetworkOnly Requests"],"updatePoint":{"line":22,"column":44},"line":22,"code":"  it(`should respond with a non-cached entry`, async function () {\n    const swURL = `${baseURL}sw.js`; // Wait for the service worker to register and activate.\n\n    await activateAndControlSW(swURL);\n    let response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const firstResponse = response.trim();\n    expect(firstResponse).to.not.eql('Cached');\n    await runInSW('clearAllCaches');\n    response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const secondResponse = response.trim();\n    expect(secondResponse).to.not.eql(firstResponse);\n    const keys = await runInSW('cachesKeys');\n    expect(keys).to.eql([]);\n  });","file":"workbox-strategies/integration/test-networkOnly.js","skipped":false,"dir":"test"},{"name":"should respond with cached entry and update it","suites":["[workbox-strategies] StaleWhileRevalidate Requests"],"updatePoint":{"line":24,"column":52},"line":24,"code":"  it(`should respond with cached entry and update it`, async function () {\n    const swURL = `${baseURL}sw.js`; // Wait for the service worker to register and activate.\n\n    await activateAndControlSW(swURL);\n    const cacheName = 'stale-while-revalidate';\n    let response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const firstResponse = response.trim(); // Writing to the cache is asynchronous, so this might not happen right away.\n\n    await waitUntil(async () => {\n      const responseText = await runInSW('getCachedResponseText', cacheName, '/__WORKBOX/uniqueValue');\n      return responseText === firstResponse;\n    }); // This response should come from cache and not the server\n\n    response = await global.__workbox.webdriver.executeAsyncScript(cb => {\n      fetch(`/__WORKBOX/uniqueValue`).then(response => response.text()).then(responseBody => cb(responseBody)).catch(err => cb(err.message));\n    });\n    const secondResponse = response.trim();\n    expect(secondResponse).to.eql(firstResponse); // Writing to the cache is asynchronous, so this might not happen right away.\n    // We expect a new value, updated from the network, different than secondResponse.\n\n    await waitUntil(async () => {\n      const responseText = await runInSW('getCachedResponseText', cacheName, '/__WORKBOX/uniqueValue');\n      return responseText !== secondResponse;\n    });\n  });","file":"workbox-strategies/integration/test-staleWhileRevalidate.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-strategies]"],"updatePoint":{"line":13,"column":30},"line":13,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-strategies/sw/');\n  });","file":"workbox-strategies/integration/test-sw.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-streams]"],"updatePoint":{"line":28,"column":30},"line":28,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-streams/sw/');\n  });","file":"workbox-streams/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should return the expected response for the '' approach","suites":["[workbox-streams] Integration Tests"],"updatePoint":{"line":48,"column":74},"line":48,"code":"    it(`should return the expected response for the '${testCase}' approach`, async function () {\n      const {\n        text,\n        headers\n      } = await webdriver.executeAsyncScript(async (testCase, cb) => {\n        try {\n          const response = await fetch(new URL(testCase, location));\n          const headers = [...response.headers].sort((a, b) => {\n            return a[0] > b[0];\n          });\n          const text = await response.text();\n          cb({\n            headers,\n            text\n          });\n        } catch (error) {\n          cb({\n            text: error.message\n          });\n        }\n      }, testCase);\n\n      if (text === 'No streams support') {\n        this.skip();\n      } else {\n        expect(text).to.eql('01234\\n');\n        expect(headers).to.eql([['content-type', 'text/plain'], ['x-test-case', testCase]]);\n      }\n    });","file":"workbox-streams/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should error when a stream source results in an opaque response","suites":["[workbox-streams] Integration Tests"],"updatePoint":{"line":79,"column":69},"line":79,"code":"  it(`should error when a stream source results in an opaque response`, async function () {\n    const {\n      text\n    } = await webdriver.executeAsyncScript(async (crossOriginURL, cb) => {\n      try {\n        const url = new URL('/crossOriginURL', location);\n        url.searchParams.set('cross-origin-url', crossOriginURL);\n        const response = await fetch(url);\n        const text = await response.text();\n        cb({\n          text\n        });\n      } catch (error) {\n        cb({\n          text: error.name\n        });\n      }\n    }, crossOriginURL);\n\n    if (text === 'No streams support') {\n      this.skip();\n    } else {\n      // The exception name varies from browser to browser.\n      expect(text).to.be.oneOf(['TypeError', 'AbortError']);\n    }\n  });","file":"workbox-streams/integration/test-all.js","skipped":false,"dir":"test"},{"name":"passes all SW unit tests","suites":["[workbox-sw]"],"updatePoint":{"line":20,"column":30},"line":20,"code":"  it(`passes all SW unit tests`, async function () {\n    await runUnitTests('/test/workbox-sw/sw/');\n  });","file":"workbox-sw/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should fail to activate an invalid SW which loads non-existent modules","suites":["WorkboxSW interface"],"updatePoint":{"line":37,"column":76},"line":37,"code":"  it(`should fail to activate an invalid SW which loads non-existent modules`, async function () {\n    const invalidSW = 'invalid-sw.js';\n    const outcome = await wasRegistrationSuccessful(invalidSW);\n    expect(outcome).to.be.false;\n  });","file":"workbox-sw/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should be able to activate a SW which loads all valid modules","suites":["WorkboxSW interface"],"updatePoint":{"line":42,"column":67},"line":42,"code":"  it(`should be able to activate a SW which loads all valid modules`, async function () {\n    const validSW = 'valid-sw.js';\n    const outcome = await wasRegistrationSuccessful(validSW);\n    expect(outcome).to.be.true;\n  });","file":"workbox-sw/integration/test-all.js","skipped":false,"dir":"test"},{"name":"should have required dependencies","suites":["[workbox-webpack-plugin] Test Dependencies"],"updatePoint":{"line":13,"column":39},"line":13,"code":"  it(`should have required dependencies`, function () {\n    return new Promise((resolve, reject) => {\n      depcheck(upath.join(__dirname, '..', '..', '..', 'packages', 'workbox-webpack-plugin'), {\n        ignoreDirs: ['test', 'build', 'demo'],\n        ignoreMatches: ['@babel/runtime']\n      }, unusedDeps => {\n        if (unusedDeps.dependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.dependencies)}`));\n        }\n\n        if (unusedDeps.devDependencies.length > 0) {\n          return reject(new Error(`Unused dependencies defined in package.json: ${JSON.stringify(unusedDeps.devDependencies)}`));\n        }\n\n        if (Object.keys(unusedDeps.missing).length > 0) {\n          return reject(new Error(`Dependencies missing from package.json: ${JSON.stringify(unusedDeps.missing)}`));\n        }\n\n        resolve();\n      });\n    });\n  });","file":"workbox-webpack-plugin/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should have no devDependencies","suites":["[workbox-webpack-plugin] Test Dependencies"],"updatePoint":{"line":35,"column":36},"line":35,"code":"  it(`should have no devDependencies`, function () {\n    // This test exists because there have been a number of situations where\n    // dependencies have been used from the top level project and NOT from\n    // this module itself. So dependencies are checked above and devDependencies\n    // can be put in top level.\n    const pkg = require('../../../packages/workbox-build/package.json');\n\n    if (pkg.devDependencies && Object.keys(pkg.devDependencies) > 0) {\n      throw new Error('No devDependencies in this module.');\n    }\n  });","file":"workbox-webpack-plugin/node/dependency-check.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when passed invalid config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":55,"column":77},"line":55,"code":"    it(`should lead to a webpack compilation error when passed invalid config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          invalid: 'invalid'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors).to.have.members([`Please check your GenerateSW plugin configuration:\\n[WebpackGenerateSW] 'invalid' property is not expected to be here. Did you mean property 'include'?`]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":85,"column":54},"line":85,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called with importScriptsViaChunks","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":128,"column":59},"line":128,"code":"    it(`should work when called with importScriptsViaChunks`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        devtool: 'source-map',\n        entry: {\n          main: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          imported: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          importScriptsViaChunks: ['imported', 'INVALID_CHUNK_NAME']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(webpackError).not.to.exist;\n          expect(statsJson.errors, JSON.stringify(statsJson.errors)).to.be.empty; // There should be a warning logged, due to INVALID_CHUNK_NAME.\n\n          expect(statsJson.warnings).to.have.length(1);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(8);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              // imported-[chunkhash].js.map should *not* be included.\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/], [/^imported-[0-9a-f]{20}\\.js$/]],\n              // imported-[chunkhash].js should *not* be included.\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called with additionalManifestEntries","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":177,"column":62},"line":177,"code":"    it(`should work when called with additionalManifestEntries`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          additionalManifestEntries: [{\n            url: 'one',\n            revision: null\n          }, {\n            url: 'two',\n            revision: null\n          }, {\n            url: 'three',\n            revision: '333'\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          const statsJson = stats.toJson();\n          expect(webpackError).not.to.exist;\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.length(0);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: 'one'\n              }, {\n                revision: '333',\n                url: 'three'\n              }, {\n                revision: null,\n                url: 'two'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":243,"column":50},"line":243,"code":"    it(`should honor the 'chunks' allowlist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'entry2']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":289,"column":100},"line":289,"code":"    it(`should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          main: upath.join(SRC_DIR, 'splitChunksEntry.js')\n        },\n        output: {\n          chunkFilename: '[name].js',\n          filename: 'main.js',\n          path: outputDir\n        },\n        optimization: {\n          splitChunks: {\n            chunks: 'all'\n          }\n        },\n        plugins: [new GenerateSW({\n          chunks: ['main']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'main.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'vendors~main.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'excludeChunks' denylist config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":339,"column":56},"line":339,"code":"    it(`should honor the 'excludeChunks' denylist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          excludeChunks: ['entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":385,"column":103},"line":385,"code":"    it(`should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'entry2'],\n          excludeChunks: ['entry2', 'entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] html-webpack-plugin and a single chunk"],"updatePoint":{"line":431,"column":54},"line":431,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new HtmlWebpackPlugin(), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] copy-webpack-plugin and a single chunk"],"updatePoint":{"line":479,"column":54},"line":479,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/example-jpeg.jpg'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should exclude .map and manifest.js files by default","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":547,"column":60},"line":547,"code":"    it(`should exclude .map and manifest.js files by default`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new CreateWebpackAssetPlugin('manifest.js'), new CreateWebpackAssetPlugin('manifest.json'), new CreateWebpackAssetPlugin('not-ignored.js'), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(9);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest.json'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'not-ignored.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to override the default exclude filter","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":591,"column":70},"line":591,"code":"    it(`should allow developers to override the default exclude filter`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new GenerateSW({\n          exclude: []\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(6);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js.map'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to allowlist via include","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":634,"column":56},"line":634,"code":"    it(`should allow developers to allowlist via include`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          include: [/.html$/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to combine the include and exclude filters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":684,"column":74},"line":684,"code":"    it(`should allow developers to combine the include and exclude filters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          include: [/.html$/],\n          exclude: [/index/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when swDest is an absolute path","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] swDest variations"],"updatePoint":{"line":734,"column":51},"line":734,"code":"    it(`should work when swDest is an absolute path`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          // upath.resolve() will always return an absolute upath.\n          swDest: upath.resolve(upath.join(outputDir, 'service-worker.js'))\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should warn when when passed a non-existent chunk","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":776,"column":57},"line":776,"code":"    it(`should warn when when passed a non-existent chunk`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'doesNotExist']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.members([`The chunk 'doesNotExist' was provided in your Workbox chunks config, but was not found in the compilation.`]);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should add maximumFileSizeToCacheInBytes warnings to compilation.warnings","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":820,"column":81},"line":820,"code":"    it(`should add maximumFileSizeToCacheInBytes warnings to compilation.warnings`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          // Make this large enough to cache some, but not all, files.\n          maximumFileSizeToCacheInBytes: 14 * 1024\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        if (webpackError) {\n          return done(webpackError);\n        }\n\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(statsJson.warnings).to.have.members([`images/example-jpeg.jpg is 15.3 kB, and won't be precached. Configure maximumFileSizeToCacheInBytes to change this limit.`]);\n          const swFile = upath.join(outputDir, 'service-worker.js');\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(12);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor publicPath","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Customizing output paths and names"],"updatePoint":{"line":897,"column":31},"line":897,"code":"    it(`should honor publicPath`, function (done) {\n      const outputDir = tempy.directory();\n      const publicPath = '/testing/';\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          publicPath,\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^\\/testing\\/entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support projects that bundle WASM code","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] WASM Code"],"updatePoint":{"line":941,"column":53},"line":941,"code":"    it(`should support projects that bundle WASM code`, function (done) {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'wasm-project');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'index.js')\n        },\n        output: {\n          filename: '[name].js',\n          globalObject: 'self',\n          path: outputDir\n        },\n        plugins: [new WorkerPlugin(), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats); // Bundling WASM into a Worker seems to lead to different hashes in\n          // different environments. Instead of hardcoding hash checks, just\n          // confirm that we output the expected number of files, which will\n          // only be true if the build was successful.\n\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(6);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support using MemoryFS as the outputFileSystem","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Filesystem options"],"updatePoint":{"line":976,"column":61},"line":976,"code":"    it(`should support using MemoryFS as the outputFileSystem`, function (done) {\n      const memoryFS = new MemoryFS();\n      const outputDir = '/output/dir';\n      memoryFS.mkdirpSync(outputDir);\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.outputFileSystem = memoryFS;\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = memoryFS.readdirSync(outputDir);\n          expect(files).to.have.length(3);\n          const swString = memoryFS.readFileSync(`${outputDir}/service-worker.js`, 'utf-8');\n          await validateServiceWorkerRuntime({\n            swString,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support multiple compilations using the same plugin instance","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1018,"column":75},"line":1018,"code":"    it(`should support multiple compilations using the same plugin instance`, async function () {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'example-project-1');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'webpackEntry.js')\n        },\n        output: {\n          filename: '[name].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0); // There should be a warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790\n\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(3);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should not list the swDest from one plugin in the other's manifest","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1064,"column":74},"line":1064,"code":"    it(`should not list the swDest from one plugin in the other's manifest`, function (done) {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'example-project-1');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'webpackEntry.js')\n        },\n        output: {\n          filename: '[name].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          swDest: 'sw1.js'\n        }), new GenerateSW({\n          swDest: 'sw2.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const sw1File = upath.join(outputDir, 'sw1.js');\n        const sw2File = upath.join(outputDir, 'sw2.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile: sw1File,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.js'\n              }], {}]]\n            }\n          });\n          await validateServiceWorkerRuntime({\n            swFile: sw2File,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support inlining the Workbox runtime","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1121,"column":51},"line":1121,"code":"    it(`should support inlining the Workbox runtime`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:6].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          inlineWorkboxRuntime: true\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats); // We can't really mock evaluation of the service worker script when\n          // the Workbox runtime is inlined, so just check to make sure the\n          // correct files are output.\n\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support inlining the Workbox runtime and generating sourcemaps","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1152,"column":77},"line":1152,"code":"    it(`should support inlining the Workbox runtime and generating sourcemaps`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:6].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          inlineWorkboxRuntime: true,\n          sourcemap: true\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats); // We can't really mock evaluation of the service worker script when\n          // the Workbox runtime is inlined, so just check to make sure the\n          // correct files are output.\n\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support using a swDest that includes a subdirectory","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1184,"column":66},"line":1184,"code":"    it(`should support using a swDest that includes a subdirectory`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          swDest: upath.join('sub', 'directory', 'service-worker.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats); // Make sure that the expected generated service worker files are\n          // output into the subdirectory.\n\n          const files = await globby('**/*', {\n            cwd: upath.join(outputDir, 'sub', 'directory')\n          });\n          expect(files).to.have.length(2);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use dontCacheBustURLsMatching","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1214,"column":44},"line":1214,"code":"    it(`should use dontCacheBustURLsMatching`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          dontCacheBustURLsMatching: /\\.[0-9a-f]{20}\\./\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                url: /^main\\.[0-9a-f]{20}\\.js$/,\n                revision: null\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use modifyURLPrefix","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1253,"column":34},"line":1253,"code":"    it(`should use modifyURLPrefix`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          modifyURLPrefix: {\n            '/public/': 'https://example.org/'\n          }\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^https:\\/\\/example\\.org\\/main\\.[0-9a-f]{20}\\.js/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use manifestTransforms","suites":["[workbox-webpack-plugin] GenerateSW with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1295,"column":37},"line":1295,"code":"    it(`should use manifestTransforms`, function (done) {\n      const outputDir = tempy.directory();\n      const warningMessage = 'test warning';\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          manifestTransforms: [(manifest, compilation) => {\n            expect(manifest).to.have.lengthOf(1);\n            expect(manifest[0].size).to.eql(959);\n            expect(manifest[0].url.startsWith('main.')).to.be.true;\n            expect(manifest[0].revision).to.be.null;\n            expect(compilation).to.exist;\n            manifest = manifest.map(entry => {\n              entry.url += '-suffix';\n              entry.revision = null;\n              return entry;\n            });\n            return {\n              manifest,\n              warnings: [warningMessage]\n            };\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors, JSON.stringify(statsJson.errors)).to.be.empty;\n          expect(statsJson.warnings).to.have.members([warningMessage]);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js-suffix$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/generate-sw.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when passed invalid config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":62,"column":77},"line":62,"code":"    it(`should lead to a webpack compilation error when passed invalid config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          invalid: 'invalid'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors).to.have.members([`Please check your InjectManifest plugin configuration:\\n[WebpackInjectManifest] 'invalid' property is not expected to be here. Did you mean property 'include'?`]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when the swSrc contains multiple injection points","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":91,"column":100},"line":91,"code":"    it(`should lead to a webpack compilation error when the swSrc contains multiple injection points`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'bad-multiple-injection.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors).to.have.members([`Multiple instances of self.__WB_MANIFEST were found in your SW source. Include it only once. For more info, see https://github.com/GoogleChrome/workbox/issues/2681`]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":121,"column":54},"line":121,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":167,"column":50},"line":167,"code":"    it(`should honor the 'chunks' allowlist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'entry2']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":215,"column":100},"line":215,"code":"    it(`should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          main: upath.join(SRC_DIR, 'splitChunksEntry.js')\n        },\n        output: {\n          chunkFilename: '[name].js',\n          filename: 'main.js',\n          path: outputDir\n        },\n        optimization: {\n          splitChunks: {\n            chunks: 'all'\n          }\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['main']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'main.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'vendors~main.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'excludeChunks' denylist config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":267,"column":56},"line":267,"code":"    it(`should honor the 'excludeChunks' denylist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          excludeChunks: ['entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":315,"column":103},"line":315,"code":"    it(`should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'entry2'],\n          excludeChunks: ['entry2', 'entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] html-webpack-plugin and a single chunk"],"updatePoint":{"line":363,"column":54},"line":363,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new HtmlWebpackPlugin(), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] copy-webpack-plugin and a single chunk"],"updatePoint":{"line":414,"column":54},"line":414,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/example-jpeg.jpg'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should update the sourcemap to account for manifest injection","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":485,"column":69},"line":485,"code":"    it(`should update the sourcemap to account for manifest injection`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          const expectedSourcemap = await fse.readJSON(upath.join(__dirname, '..', '..', 'static', 'expected-service-worker.js.map'));\n          const actualSourcemap = await fse.readJSON(upath.join(outputDir, 'service-worker.js.map')); // The mappings will vary depending on the webpack version.\n\n          delete expectedSourcemap.mappings;\n          delete actualSourcemap.mappings;\n          expect(actualSourcemap).to.eql(expectedSourcemap);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should handle a custom output.sourceMapFilename","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":532,"column":55},"line":532,"code":"    it(`should handle a custom output.sourceMapFilename`, function (done) {\n      const outputDir = tempy.directory();\n      const sourceMapFilename = upath.join('subdir', '[file].map');\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          sourceMapFilename,\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          const expectedSourcemap = await fse.readJSON(upath.join(__dirname, '..', '..', 'static', 'expected-service-worker.js.map'));\n          const actualSourcemap = await fse.readJSON(upath.join(outputDir, 'subdir', 'service-worker.js.map')); // The mappings will vary depending on the webpack version.\n\n          delete expectedSourcemap.mappings;\n          delete actualSourcemap.mappings;\n          expect(actualSourcemap).to.eql(expectedSourcemap);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not fail if the sourcemap is missing from the assets","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":581,"column":67},"line":581,"code":"    it(`should not fail if the sourcemap is missing from the assets`, function (done) {\n      const outputDir = tempy.directory();\n      const swSrc = upath.join(__dirname, '..', '..', 'static', 'sw-src-missing-sourcemap.js');\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: false,\n        plugins: [new InjectManifest({\n          swSrc,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    }); // See https://github.com/GoogleChrome/workbox/issues/2729","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid JavaScript when eval-cheap-source-map and minimization are used","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":624,"column":92},"line":624,"code":"    it(`should produce valid JavaScript when eval-cheap-source-map and minimization are used`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'eval-cheap-source-map',\n        optimization: {\n          minimize: true\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'module-import-sw.js'),\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest' // We can't verify expectedMethodCalls here, since we're using\n            // a compiled ES module import, not the workbox-sw interfaces.\n            // This test just confirms that the compilation produces valid JS.\n\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    }); // See https://github.com/GoogleChrome/workbox/issues/2729","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid JavaScript when eval-cheap-source-map is used without minimization","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":666,"column":95},"line":666,"code":"    it(`should produce valid JavaScript when eval-cheap-source-map is used without minimization`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'eval-cheap-source-map',\n        optimization: {\n          minimize: false\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'module-import-sw.js'),\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest' // We can't verify expectedMethodCalls here, since we're using\n            // a compiled ES module import, not the workbox-sw interfaces.\n            // This test just confirms that the compilation produces valid JS.\n\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should exclude .map and manifest.js files by default","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":709,"column":60},"line":709,"code":"    it(`should exclude .map and manifest.js files by default`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new CreateWebpackAssetPlugin('manifest.js'), new CreateWebpackAssetPlugin('manifest.json'), new CreateWebpackAssetPlugin('not-ignored.js'), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(7);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest.json'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'not-ignored.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to override the default exclude filter","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":756,"column":70},"line":756,"code":"    it(`should allow developers to override the default exclude filter`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          exclude: []\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js.map'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to allowlist via include","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":801,"column":56},"line":801,"code":"    it(`should allow developers to allowlist via include`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          include: [/.html$/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to combine the include and exclude filters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":853,"column":74},"line":853,"code":"    it(`should allow developers to combine the include and exclude filters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          include: [/.html$/],\n          exclude: [/index/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when swDest is an absolute path","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] swDest variations"],"updatePoint":{"line":905,"column":51},"line":905,"code":"    it(`should work when swDest is an absolute path`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: upath.resolve(upath.join(outputDir, 'service-worker.js'))\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should warn when when passed a non-existent chunk","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":947,"column":57},"line":947,"code":"    it(`should warn when when passed a non-existent chunk`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'doesNotExist']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.members([`The chunk 'doesNotExist' was provided in your Workbox chunks config, but was not found in the compilation.`]);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should add maximumFileSizeToCacheInBytes warnings to compilation.warnings","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":993,"column":81},"line":993,"code":"    it(`should add maximumFileSizeToCacheInBytes warnings to compilation.warnings`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          // Make this large enough to cache some, but not all, files.\n          maximumFileSizeToCacheInBytes: 14 * 1024\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        if (webpackError) {\n          return done(webpackError);\n        }\n\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(statsJson.warnings).to.have.members([`images/example-jpeg.jpg is 15.3 kB, and won't be precached. Configure maximumFileSizeToCacheInBytes to change this limit.`]);\n          const swFile = upath.join(outputDir, 'service-worker.js');\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor publicPath","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Customizing output paths and names"],"updatePoint":{"line":1072,"column":31},"line":1072,"code":"    it(`should honor publicPath`, function (done) {\n      const outputDir = tempy.directory();\n      const publicPath = '/testing/';\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          publicPath,\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^\\/testing\\/entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support projects that bundle WASM code","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] WASM Code"],"updatePoint":{"line":1119,"column":53},"line":1119,"code":"    it(`should support projects that bundle WASM code`, function (done) {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'wasm-project');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'index.js')\n        },\n        output: {\n          filename: '[name].js',\n          globalObject: 'self',\n          path: outputDir\n        },\n        plugins: [new WorkerPlugin(), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats); // Bundling WASM into a Worker seems to lead to different hashes in\n          // different environments. Instead of hardcoding hash checks, just\n          // confirm that we output the expected number of files, which will\n          // only be true if the build was successful.\n\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use dontCacheBustURLsMatching","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1157,"column":44},"line":1157,"code":"    it(`should use dontCacheBustURLsMatching`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          dontCacheBustURLsMatching: /\\.[0-9a-f]{20}\\./\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                url: /^main\\.[0-9a-f]{20}\\.js$/,\n                revision: null\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use modifyURLPrefix","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1198,"column":34},"line":1198,"code":"    it(`should use modifyURLPrefix`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          modifyURLPrefix: {\n            '/public/': 'https://example.org/'\n          }\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^https:\\/\\/example\\.org\\/main\\.[0-9a-f]{20}\\.js/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use webpackCompilationPlugins with DefinePlugin","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1242,"column":62},"line":1242,"code":"    it(`should use webpackCompilationPlugins with DefinePlugin`, function (done) {\n      const prefix = 'replaced-by-define-plugin';\n      const swSrc = upath.join(__dirname, '..', '..', 'static', 'sw-src-define-plugin.js');\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc,\n          swDest: 'service-worker.js',\n          webpackCompilationPlugins: [new webpack.DefinePlugin({\n            __PREFIX__: JSON.stringify(prefix)\n          })]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              setCacheNameDetails: [[{\n                prefix\n              }]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use manifestTransforms","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1290,"column":37},"line":1290,"code":"    it(`should use manifestTransforms`, function (done) {\n      const outputDir = tempy.directory();\n      const warningMessage = 'test warning';\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          manifestTransforms: [(manifest, compilation) => {\n            expect(manifest).to.have.lengthOf(1);\n            expect(manifest[0].size).to.eql(959);\n            expect(manifest[0].url.startsWith('main.')).to.be.true;\n            expect(manifest[0].revision).to.be.null;\n            expect(compilation).to.exist;\n            manifest = manifest.map(entry => {\n              entry.url += '-suffix';\n              entry.revision = null;\n              return entry;\n            });\n            return {\n              manifest,\n              warnings: [warningMessage]\n            };\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.members([warningMessage]);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main.[0-9a-f]{20}\\.js-suffix$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should rename a swSrc with a .ts extension to .js","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] TypeScript compilation"],"updatePoint":{"line":1352,"column":57},"line":1352,"code":"    it(`should rename a swSrc with a .ts extension to .js`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('*', {\n            cwd: outputDir\n          });\n          expect(files).to.contain('sw.js');\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support multiple compilations using the same plugin instance","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1382,"column":75},"line":1382,"code":"    it(`should support multiple compilations using the same plugin instance`, async function () {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0); // There should be a warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790\n\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(2);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should only log once per invocation when using multiple plugin instances","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1428,"column":80},"line":1428,"code":"    it(`should only log once per invocation when using multiple plugin instances`, async function () {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker1.js'\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker2.js'\n        })]\n      };\n      const compiler = webpack(config);\n\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0); // There should be a single warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790#issuecomment-640132556\n\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(3);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not list the swDest from one plugin in the other's manifest","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Multiple plugin instances"],"updatePoint":{"line":1480,"column":74},"line":1480,"code":"    it(`should not list the swDest from one plugin in the other's manifest`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts'),\n          swDest: 'sw1.js'\n        }), new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts'),\n          swDest: 'sw2.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const sw1File = upath.join(outputDir, 'sw1.js');\n        const sw2File = upath.join(outputDir, 'sw2.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile: sw1File,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          await validateServiceWorkerRuntime({\n            swFile: sw2File,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid, parsable JavaScript","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Manifest injection in development mode"],"updatePoint":{"line":1538,"column":49},"line":1538,"code":"    it(`should produce valid, parsable JavaScript`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swDest: 'sw.js',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw-src.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'sw.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile: swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should warn when compileSrc is false and webpackCompilationPlugins is used","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1581,"column":82},"line":1581,"code":"    it(`should warn when compileSrc is false and webpackCompilationPlugins is used`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.json',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.json'),\n          webpackCompilationPlugins: [{}]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.members(['compileSrc is false, so the webpackCompilationPlugins option will be ignored.']);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support injecting a manifest into a JSON file","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1610,"column":60},"line":1610,"code":"    it(`should support injecting a manifest into a JSON file`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.json',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.json')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          const manifest = await fse.readJSON(upath.join(outputDir, 'injected-manifest.json'));\n          expect(manifest).to.matchPattern([{\n            revision: null,\n            url: /^main\\.[0-9a-f]{20}\\.js$/\n          }]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support injecting a manifest into a CJS module","suites":["[workbox-webpack-plugin] InjectManifest with webpack v4","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1644,"column":61},"line":1644,"code":"    it(`should support injecting a manifest into a CJS module`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[hash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.js',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n\n          const manifest = require(upath.join(outputDir, 'injected-manifest.js'));\n\n          expect(manifest).to.matchPattern([{\n            revision: null,\n            url: /^main\\.[0-9a-f]{20}\\.js$/\n          }]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v4/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when passed invalid config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":53,"column":77},"line":53,"code":"    it(`should lead to a webpack compilation error when passed invalid config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          invalid: 'invalid'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors).to.have.length(1);\n          expect(statsJson.errors[0].message).to.eql(`Please check your GenerateSW plugin configuration:\\n[WebpackGenerateSW] 'invalid' property is not expected to be here. Did you mean property 'include'?`);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":84,"column":54},"line":84,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called with importScriptsViaChunks","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":127,"column":59},"line":127,"code":"    it(`should work when called with importScriptsViaChunks`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        devtool: 'source-map',\n        entry: {\n          main: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          imported: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          importScriptsViaChunks: ['imported', 'INVALID_CHUNK_NAME']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(webpackError).not.to.exist;\n          expect(statsJson.errors).to.be.empty; // There should be a warning logged, due to INVALID_CHUNK_NAME.\n\n          expect(statsJson.warnings).to.have.length(1);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(8);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              // imported-[chunkhash].js.map should *not* be included.\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/], [/^imported-[0-9a-f]{20}\\.js$/]],\n              // imported-[chunkhash].js should *not* be included.\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called with additionalManifestEntries","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":176,"column":62},"line":176,"code":"    it(`should work when called with additionalManifestEntries`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          additionalManifestEntries: [{\n            url: 'one',\n            revision: null\n          }, {\n            url: 'two',\n            revision: null\n          }, {\n            url: 'three',\n            revision: '333'\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          const statsJson = stats.toJson();\n          expect(webpackError).not.to.exist;\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings).to.have.length(0);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: 'one'\n              }, {\n                revision: '333',\n                url: 'three'\n              }, {\n                revision: null,\n                url: 'two'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":242,"column":50},"line":242,"code":"    it(`should honor the 'chunks' allowlist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'entry2']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":288,"column":100},"line":288,"code":"    it(`should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          main: upath.join(SRC_DIR, 'splitChunksEntry.js')\n        },\n        output: {\n          filename: '[chunkhash].js',\n          path: outputDir\n        },\n        optimization: {\n          minimize: false,\n          splitChunks: {\n            chunks: 'all'\n          }\n        },\n        performance: {\n          hints: false\n        },\n        plugins: [new GenerateSW({\n          chunks: ['main']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor the 'excludeChunks' denylist config","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":341,"column":56},"line":341,"code":"    it(`should honor the 'excludeChunks' denylist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          excludeChunks: ['entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":387,"column":103},"line":387,"code":"    it(`should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'entry2'],\n          excludeChunks: ['entry2', 'entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] html-webpack-plugin and a single chunk"],"updatePoint":{"line":433,"column":54},"line":433,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new HtmlWebpackPlugin(), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(5);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] copy-webpack-plugin and a single chunk"],"updatePoint":{"line":481,"column":54},"line":481,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/example-jpeg.jpg'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should exclude .map and manifest.js files by default","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":549,"column":60},"line":549,"code":"    it(`should exclude .map and manifest.js files by default`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new CreateWebpackAssetPlugin('manifest.js'), new CreateWebpackAssetPlugin('manifest.json'), new CreateWebpackAssetPlugin('not-ignored.js'), new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(9);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest.json'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'not-ignored.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to override the default exclude filter","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":593,"column":70},"line":593,"code":"    it(`should allow developers to override the default exclude filter`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: 'manifest-normally-ignored.js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          exclude: []\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest-normally-ignored.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to allowlist via include","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":632,"column":56},"line":632,"code":"    it(`should allow developers to allowlist via include`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          include: [/.html$/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should allow developers to combine the include and exclude filters","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":682,"column":74},"line":682,"code":"    it(`should allow developers to combine the include and exclude filters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          include: [/.html$/],\n          exclude: [/index/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should work when swDest is an absolute path","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] swDest variations"],"updatePoint":{"line":732,"column":51},"line":732,"code":"    it(`should work when swDest is an absolute path`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          // upath.resolve() will always return an absolute upath.\n          swDest: upath.resolve(upath.join(outputDir, 'service-worker.js'))\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should warn when when passed a non-existent chunk","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":774,"column":57},"line":774,"code":"    it(`should warn when when passed a non-existent chunk`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          chunks: ['entry1', 'doesNotExist']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings[0].message).to.eql(`The chunk 'doesNotExist' was provided in your Workbox chunks config, but was not found in the compilation.`);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should add maximumFileSizeToCacheInBytes warnings to compilation.warnings","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":818,"column":81},"line":818,"code":"    it(`should add maximumFileSizeToCacheInBytes warnings to compilation.warnings`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new GenerateSW({\n          // Make this large enough to cache some, but not all, files.\n          maximumFileSizeToCacheInBytes: 14 * 1024\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        if (webpackError) {\n          return done(webpackError);\n        }\n\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(statsJson.warnings[0].message).to.eql(`images/example-jpeg.jpg is 15.3 kB, and won't be precached. Configure maximumFileSizeToCacheInBytes to change this limit.`);\n          const swFile = upath.join(outputDir, 'service-worker.js');\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(12);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should honor publicPath","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Customizing output paths and names"],"updatePoint":{"line":895,"column":31},"line":895,"code":"    it(`should honor publicPath`, function (done) {\n      const outputDir = tempy.directory();\n      const publicPath = '/testing/';\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          publicPath,\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^\\/testing\\/entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support using MemoryFS as the outputFileSystem","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Filesystem options"],"updatePoint":{"line":938,"column":61},"line":938,"code":"    it(`should support using MemoryFS as the outputFileSystem`, function (done) {\n      const memoryFS = new MemoryFS();\n      const outputDir = '/output/dir';\n      memoryFS.mkdirpSync(outputDir);\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n      compiler.outputFileSystem = memoryFS;\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = memoryFS.readdirSync(outputDir);\n          expect(files).to.have.length(3);\n          const swString = memoryFS.readFileSync(`${outputDir}/service-worker.js`, 'utf-8');\n          await validateServiceWorkerRuntime({\n            swString,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support multiple compilations using the same plugin instance","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":980,"column":75},"line":980,"code":"    it(`should support multiple compilations using the same plugin instance`, async function () {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'example-project-1');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'webpackEntry.js')\n        },\n        output: {\n          filename: '[name].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW()]\n      };\n      const compiler = webpack(config);\n\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0); // There should be a warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790\n\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(3);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should not list the swDest from one plugin in the other's manifest","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1026,"column":74},"line":1026,"code":"    it(`should not list the swDest from one plugin in the other's manifest`, function (done) {\n      const outputDir = tempy.directory();\n      const srcDir = upath.join(__dirname, '..', '..', 'static', 'example-project-1');\n      const config = {\n        mode: 'production',\n        entry: {\n          index: upath.join(srcDir, 'webpackEntry.js')\n        },\n        output: {\n          filename: '[name].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          swDest: 'sw1.js'\n        }), new GenerateSW({\n          swDest: 'sw2.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const sw1File = upath.join(outputDir, 'sw1.js');\n        const sw2File = upath.join(outputDir, 'sw2.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile: sw1File,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.js'\n              }], {}]]\n            }\n          });\n          await validateServiceWorkerRuntime({\n            swFile: sw2File,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support inlining the Workbox runtime","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1083,"column":51},"line":1083,"code":"    it(`should support inlining the Workbox runtime`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:6].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          inlineWorkboxRuntime: true\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats); // We can't really mock evaluation of the service worker script when\n          // the Workbox runtime is inlined, so just check to make sure the\n          // correct files are output.\n\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support inlining the Workbox runtime and generating sourcemaps","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1114,"column":77},"line":1114,"code":"    it(`should support inlining the Workbox runtime and generating sourcemaps`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:6].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          inlineWorkboxRuntime: true,\n          sourcemap: true\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats); // We can't really mock evaluation of the service worker script when\n          // the Workbox runtime is inlined, so just check to make sure the\n          // correct files are output.\n\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should support using a swDest that includes a subdirectory","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Rollup plugin configuration options"],"updatePoint":{"line":1146,"column":66},"line":1146,"code":"    it(`should support using a swDest that includes a subdirectory`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          swDest: upath.join('sub', 'directory', 'service-worker.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats); // Make sure that the expected generated service worker files are\n          // output into the subdirectory.\n\n          const files = await globby('**/*', {\n            cwd: upath.join(outputDir, 'sub', 'directory')\n          });\n          expect(files).to.have.length(2);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use dontCacheBustURLsMatching","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1176,"column":44},"line":1176,"code":"    it(`should use dontCacheBustURLsMatching`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          dontCacheBustURLsMatching: /\\.[0-9a-f]{20}\\./\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                url: /^main\\.[0-9a-f]{20}\\.js$/,\n                revision: null\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use modifyURLPrefix","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1215,"column":34},"line":1215,"code":"    it(`should use modifyURLPrefix`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new GenerateSW({\n          modifyURLPrefix: {\n            '/public/': 'https://example.org/'\n          }\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^https:\\/\\/example\\.org\\/main\\.[0-9a-f]{20}\\.js/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should use manifestTransforms","suites":["[workbox-webpack-plugin] GenerateSW with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1257,"column":37},"line":1257,"code":"    it(`should use manifestTransforms`, function (done) {\n      const outputDir = tempy.directory();\n      const warningMessage = 'test warning';\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new GenerateSW({\n          manifestTransforms: [(manifest, compilation) => {\n            expect(manifest).to.have.lengthOf(1);\n            expect(manifest[0].size).to.eql(30);\n            expect(manifest[0].url.startsWith('main.')).to.be.true;\n            expect(manifest[0].revision).to.be.null;\n            expect(compilation).to.exist;\n            manifest = manifest.map(entry => {\n              entry.url += '-suffix';\n              entry.revision = null;\n              return entry;\n            });\n            return {\n              manifest,\n              warnings: [warningMessage]\n            };\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors, JSON.stringify(statsJson.errors)).to.be.empty;\n          expect(statsJson.warnings[0].message).to.eql(warningMessage);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            expectedMethodCalls: {\n              importScripts: [[/^\\.\\/workbox-[0-9a-f]{8}$/]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js-suffix$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/generate-sw.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when passed invalid config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":60,"column":77},"line":60,"code":"    it(`should lead to a webpack compilation error when passed invalid config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          invalid: 'invalid'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors[0].message).to.eql(`Please check your InjectManifest plugin configuration:\\n[WebpackInjectManifest] 'invalid' property is not expected to be here. Did you mean property 'include'?`);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should lead to a webpack compilation error when the swSrc contains multiple injection points","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Runtime errors"],"updatePoint":{"line":89,"column":100},"line":89,"code":"    it(`should lead to a webpack compilation error when the swSrc contains multiple injection points`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'bad-multiple-injection.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.warnings).to.be.empty;\n          expect(statsJson.errors[0].message).to.eql(`Multiple instances of self.__WB_MANIFEST were found in your SW source. Include it only once. For more info, see https://github.com/GoogleChrome/workbox/issues/2681`);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":119,"column":54},"line":119,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":165,"column":50},"line":165,"code":"    it(`should honor the 'chunks' allowlist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'entry2']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":213,"column":100},"line":213,"code":"    it(`should honor the 'chunks' allowlist config, including children created via SplitChunksPlugin`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          main: upath.join(SRC_DIR, 'splitChunksEntry.js')\n        },\n        output: {\n          filename: '[chunkhash].js',\n          path: outputDir\n        },\n        optimization: {\n          minimize: false,\n          splitChunks: {\n            chunks: 'all'\n          }\n        },\n        performance: {\n          hints: false\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['main']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor the 'excludeChunks' denylist config","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":268,"column":56},"line":268,"code":"    it(`should honor the 'excludeChunks' denylist config`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          excludeChunks: ['entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple chunks"],"updatePoint":{"line":316,"column":103},"line":316,"code":"    it(`should honor setting both the 'chunks' and 'excludeChunks', with the denylist taking precedence`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry3: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'entry2'],\n          excludeChunks: ['entry2', 'entry3']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] html-webpack-plugin and a single chunk"],"updatePoint":{"line":364,"column":54},"line":364,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n          entry2: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new HtmlWebpackPlugin(), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: null,\n                url: /^entry2-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when called without any parameters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] copy-webpack-plugin and a single chunk"],"updatePoint":{"line":415,"column":54},"line":415,"code":"    it(`should work when called without any parameters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/example-jpeg.jpg'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should update the sourcemap to account for manifest injection","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":486,"column":69},"line":486,"code":"    it(`should update the sourcemap to account for manifest injection`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          const expectedSourcemap = await fse.readJSON(upath.join(__dirname, 'static', 'expected-service-worker.js.map'));\n          const actualSourcemap = await fse.readJSON(upath.join(outputDir, 'service-worker.js.map')); // The mappings will vary depending on the webpack version.\n\n          delete expectedSourcemap.mappings;\n          delete actualSourcemap.mappings;\n          expect(actualSourcemap).to.eql(expectedSourcemap);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should handle a custom output.sourceMapFilename","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":533,"column":55},"line":533,"code":"    it(`should handle a custom output.sourceMapFilename`, function (done) {\n      const outputDir = tempy.directory();\n      const sourceMapFilename = upath.join('subdir', '[file].map');\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          sourceMapFilename,\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          const expectedSourcemap = await fse.readJSON(upath.join(__dirname, 'static', 'expected-service-worker.js.map'));\n          const actualSourcemap = await fse.readJSON(upath.join(outputDir, 'subdir', 'service-worker.js.map')); // The mappings will vary depending on the webpack version.\n\n          delete expectedSourcemap.mappings;\n          delete actualSourcemap.mappings;\n          expect(actualSourcemap).to.eql(expectedSourcemap);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not fail if the sourcemap is missing from the assets","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":582,"column":67},"line":582,"code":"    it(`should not fail if the sourcemap is missing from the assets`, function (done) {\n      const outputDir = tempy.directory();\n      const swSrc = upath.join(__dirname, '..', '..', 'static', 'sw-src-missing-sourcemap.js');\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: false,\n        plugins: [new InjectManifest({\n          swSrc,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    }); // See https://github.com/GoogleChrome/workbox/issues/2729","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid JavaScript when eval-cheap-source-map and minimization are used","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":625,"column":92},"line":625,"code":"    it(`should produce valid JavaScript when eval-cheap-source-map and minimization are used`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'eval-cheap-source-map',\n        optimization: {\n          minimize: true\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'module-import-sw.js'),\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(4);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest' // We can't verify expectedMethodCalls here, since we're using\n            // a compiled ES module import, not the workbox-sw interfaces.\n            // This test just confirms that the compilation produces valid JS.\n\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    }); // See https://github.com/GoogleChrome/workbox/issues/2729","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid JavaScript when eval-cheap-source-map is used without minimization","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Sourcemap manipulation"],"updatePoint":{"line":667,"column":95},"line":667,"code":"    it(`should produce valid JavaScript when eval-cheap-source-map is used without minimization`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'eval-cheap-source-map',\n        optimization: {\n          minimize: false\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'module-import-sw.js'),\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest' // We can't verify expectedMethodCalls here, since we're using\n            // a compiled ES module import, not the workbox-sw interfaces.\n            // This test just confirms that the compilation produces valid JS.\n\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should exclude .map and manifest.js files by default","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":710,"column":60},"line":710,"code":"    it(`should exclude .map and manifest.js files by default`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        devtool: 'source-map',\n        plugins: [new CreateWebpackAssetPlugin('manifest.js'), new CreateWebpackAssetPlugin('manifest.json'), new CreateWebpackAssetPlugin('not-ignored.js'), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(7);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest.json'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'not-ignored.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to override the default exclude filter","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":757,"column":70},"line":757,"code":"    it(`should allow developers to override the default exclude filter`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: 'manifest-normally-ignored.js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          exclude: []\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'manifest-normally-ignored.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to allowlist via include","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":798,"column":56},"line":798,"code":"    it(`should allow developers to allowlist via include`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          include: [/.html$/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should allow developers to combine the include and exclude filters","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Filtering via include/exclude"],"updatePoint":{"line":850,"column":74},"line":850,"code":"    it(`should allow developers to combine the include and exclude filters`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          include: [/.html$/],\n          exclude: [/index/]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(10);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should work when swDest is an absolute path","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] swDest variations"],"updatePoint":{"line":902,"column":51},"line":902,"code":"    it(`should work when swDest is an absolute path`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: WEBPACK_ENTRY_FILENAME,\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: upath.resolve(upath.join(outputDir, 'service-worker.js'))\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should warn when when passed a non-existent chunk","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":944,"column":57},"line":944,"code":"    it(`should warn when when passed a non-existent chunk`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          chunks: ['entry1', 'doesNotExist']\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings[0].message).to.eql(`The chunk 'doesNotExist' was provided in your Workbox chunks config, but was not found in the compilation.`);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should add maximumFileSizeToCacheInBytes warnings to compilation.warnings","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Reporting webpack warnings"],"updatePoint":{"line":990,"column":81},"line":990,"code":"    it(`should add maximumFileSizeToCacheInBytes warnings to compilation.warnings`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new CopyWebpackPlugin({\n          patterns: [{\n            from: SRC_DIR,\n            to: outputDir\n          }]\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          // Make this large enough to cache some, but not all, files.\n          maximumFileSizeToCacheInBytes: 14 * 1024\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        if (webpackError) {\n          return done(webpackError);\n        }\n\n        try {\n          const statsJson = stats.toJson('verbose');\n          expect(statsJson.warnings[0].message).to.eql(`images/example-jpeg.jpg is 15.3 kB, and won't be precached. Configure maximumFileSizeToCacheInBytes to change this limit.`);\n          const swFile = upath.join(outputDir, 'service-worker.js');\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(11);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^entry1-[0-9a-f]{20}\\.js$/\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'images/web-fundamentals-icon192x192.png'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'index.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-1.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'page-2.html'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'splitChunksEntry.js'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-1.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'styles/stylesheet-2.css'\n              }, {\n                revision: /^[0-9a-f]{32}$/,\n                url: 'webpackEntry.js'\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should honor publicPath","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Customizing output paths and names"],"updatePoint":{"line":1069,"column":31},"line":1069,"code":"    it(`should honor publicPath`, function (done) {\n      const outputDir = tempy.directory();\n      const publicPath = '/testing/';\n      const config = {\n        mode: 'production',\n        entry: {\n          entry1: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME)\n        },\n        output: {\n          publicPath,\n          filename: '[name]-[chunkhash].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^\\/testing\\/entry1-[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use dontCacheBustURLsMatching","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1115,"column":44},"line":1115,"code":"    it(`should use dontCacheBustURLsMatching`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          dontCacheBustURLsMatching: /\\.[0-9a-f]{20}\\./\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                url: /^main\\.[0-9a-f]{20}\\.js$/,\n                revision: null\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use modifyURLPrefix","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1156,"column":34},"line":1156,"code":"    it(`should use modifyURLPrefix`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir,\n          publicPath: '/public/'\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          modifyURLPrefix: {\n            '/public/': 'https://example.org/'\n          }\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^https:\\/\\/example\\.org\\/main\\.[0-9a-f]{20}\\.js/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use webpackCompilationPlugins with DefinePlugin","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1200,"column":62},"line":1200,"code":"    it(`should use webpackCompilationPlugins with DefinePlugin`, function (done) {\n      const prefix = 'replaced-by-define-plugin';\n      const swSrc = upath.join(__dirname, '..', '..', 'static', 'sw-src-define-plugin.js');\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc,\n          swDest: 'service-worker.js',\n          webpackCompilationPlugins: [new webpack.DefinePlugin({\n            __PREFIX__: JSON.stringify(prefix)\n          })]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              setCacheNameDetails: [[{\n                prefix\n              }]],\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should use manifestTransforms","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Manifest transformations"],"updatePoint":{"line":1248,"column":37},"line":1248,"code":"    it(`should use manifestTransforms`, function (done) {\n      const outputDir = tempy.directory();\n      const warningMessage = 'test warning';\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js',\n          manifestTransforms: [(manifest, compilation) => {\n            expect(manifest).to.have.lengthOf(1);\n            expect(manifest[0].size).to.eql(30);\n            expect(manifest[0].url.startsWith('main.')).to.be.true;\n            expect(manifest[0].revision).to.be.null;\n            expect(compilation).to.exist;\n            manifest = manifest.map(entry => {\n              entry.url += '-suffix';\n              entry.revision = null;\n              return entry;\n            });\n            return {\n              manifest,\n              warnings: [warningMessage]\n            };\n          }]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'service-worker.js');\n\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings[0].message).to.eql(warningMessage);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main.[0-9a-f]{20}\\.js-suffix$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should rename a swSrc with a .ts extension to .js","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] TypeScript compilation"],"updatePoint":{"line":1310,"column":57},"line":1310,"code":"    it(`should rename a swSrc with a .ts extension to .js`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('*', {\n            cwd: outputDir\n          });\n          expect(files).to.contain('sw.js');\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support multiple compilations using the same plugin instance","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1340,"column":75},"line":1340,"code":"    it(`should support multiple compilations using the same plugin instance`, async function () {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker.js'\n        })]\n      };\n      const compiler = webpack(config);\n\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0); // There should be a warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790\n\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(2);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should only log once per invocation when using multiple plugin instances","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple invocation scenarios"],"updatePoint":{"line":1386,"column":80},"line":1386,"code":"    it(`should only log once per invocation when using multiple plugin instances`, async function () {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:6].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker1.js'\n        }), new InjectManifest({\n          swSrc: SW_SRC,\n          swDest: 'service-worker2.js'\n        })]\n      };\n      const compiler = webpack(config);\n\n      for (const i of [1, 2, 3]) {\n        await new Promise((resolve, reject) => {\n          compiler.run(async (webpackError, stats) => {\n            try {\n              if (webpackError) {\n                throw new Error(webpackError.message);\n              }\n\n              const statsJson = stats.toJson('verbose');\n              expect(statsJson.errors).to.have.length(0); // There should be a single warning logged after the first compilation.\n              // See https://github.com/GoogleChrome/workbox/issues/1790#issuecomment-640132556\n\n              if (i > 1) {\n                expect(statsJson.warnings).to.have.length(1);\n              } else {\n                expect(statsJson.warnings).to.have.length(0);\n              }\n\n              const files = await globby('**', {\n                cwd: outputDir\n              });\n              expect(files).to.have.length(3);\n              resolve();\n            } catch (error) {\n              reject(new Error(`Failure during compilation ${i}: ${error}`));\n            }\n          });\n        });\n      }\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should not list the swDest from one plugin in the other's manifest","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Multiple plugin instances"],"updatePoint":{"line":1438,"column":74},"line":1438,"code":"    it(`should not list the swDest from one plugin in the other's manifest`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts'),\n          swDest: 'sw1.js'\n        }), new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw.ts'),\n          swDest: 'sw2.js'\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const sw1File = upath.join(outputDir, 'sw1.js');\n        const sw2File = upath.join(outputDir, 'sw2.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(3);\n          await validateServiceWorkerRuntime({\n            swFile: sw1File,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          await validateServiceWorkerRuntime({\n            swFile: sw2File,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should produce valid, parsable JavaScript","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Manifest injection in development mode"],"updatePoint":{"line":1496,"column":49},"line":1496,"code":"    it(`should produce valid, parsable JavaScript`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'development',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          exclude: [/sw\\d.js/],\n          swDest: 'sw.js',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'sw-src.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        const swFile = upath.join(outputDir, 'sw.js');\n\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          await validateServiceWorkerRuntime({\n            swFile: swFile,\n            entryPoint: 'injectManifest',\n            expectedMethodCalls: {\n              precacheAndRoute: [[[{\n                revision: null,\n                url: /^main\\.[0-9a-f]{20}\\.js$/\n              }], {}]]\n            }\n          });\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should error when compileSrc is false and webpackCompilationPlugins is used","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1539,"column":83},"line":1539,"code":"    it(`should error when compileSrc is false and webpackCompilationPlugins is used`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.json',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.json'),\n          webpackCompilationPlugins: [{}]\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run((webpackError, stats) => {\n        try {\n          expect(webpackError).not.to.exist;\n          const statsJson = stats.toJson();\n          expect(statsJson.errors).to.be.empty;\n          expect(statsJson.warnings[0].message).to.eql('compileSrc is false, so the webpackCompilationPlugins option will be ignored.');\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support injecting a manifest into a JSON file","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1568,"column":60},"line":1568,"code":"    it(`should support injecting a manifest into a JSON file`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.json',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.json')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n          const manifest = await fse.readJSON(upath.join(outputDir, 'injected-manifest.json'));\n          expect(manifest).to.matchPattern([{\n            revision: null,\n            url: /^main\\.[0-9a-f]{20}\\.js$/\n          }]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"should support injecting a manifest into a CJS module","suites":["[workbox-webpack-plugin] InjectManifest with webpack v5","[workbox-webpack-plugin] Non-compilation scenarios"],"updatePoint":{"line":1602,"column":61},"line":1602,"code":"    it(`should support injecting a manifest into a CJS module`, function (done) {\n      const outputDir = tempy.directory();\n      const config = {\n        mode: 'production',\n        entry: upath.join(SRC_DIR, WEBPACK_ENTRY_FILENAME),\n        output: {\n          filename: '[name].[contenthash:20].js',\n          path: outputDir\n        },\n        plugins: [new InjectManifest({\n          compileSrc: false,\n          swDest: 'injected-manifest.js',\n          swSrc: upath.join(__dirname, '..', '..', 'static', 'injected-manifest.js')\n        })]\n      };\n      const compiler = webpack(config);\n      compiler.run(async (webpackError, stats) => {\n        try {\n          webpackBuildCheck(webpackError, stats);\n          const files = await globby('**', {\n            cwd: outputDir\n          });\n          expect(files).to.have.length(2);\n\n          const manifest = require(upath.join(outputDir, 'injected-manifest.js'));\n\n          expect(manifest).to.matchPattern([{\n            revision: null,\n            url: /^main\\.[0-9a-f]{20}\\.js$/\n          }]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      });\n    });","file":"workbox-webpack-plugin/node/v5/inject-manifest.js","skipped":false,"dir":"test"},{"name":"passes all window unit tests","suites":["[workbox-window]"],"updatePoint":{"line":42,"column":34},"line":42,"code":"  it(`passes all window unit tests`, async function () {\n    await runUnitTests('/test/workbox-window/window/');\n  });","file":"workbox-window/integration/test-all.js","skipped":false,"dir":"test"},{"name":"registers a new service worker","suites":["[workbox-window] Workbox","register"],"updatePoint":{"line":61,"column":38},"line":61,"code":"    it(`registers a new service worker`, async function () {\n      const result = await executeAsyncAndCatch(async cb => {\n        try {\n          const wb = new Workbox('sw-clients-claim.js.njk');\n          await wb.register();\n          const reg = await navigator.serviceWorker.getRegistration();\n          const sw = reg.installing || reg.waiting || reg.active;\n          cb({\n            scriptURL: sw.scriptURL\n          });\n        } catch (error) {\n          cb({\n            error: error.stack\n          });\n        }\n      });\n      expect(result.scriptURL).to.equal(`${testPath}sw-clients-claim.js.njk`);\n    });","file":"workbox-window/integration/test-all.js","skipped":false,"dir":"test"},{"name":"reports all events for a new SW registration","suites":["[workbox-window] Workbox","register"],"updatePoint":{"line":79,"column":52},"line":79,"code":"    it(`reports all events for a new SW registration`, async function () {\n      const result = await executeAsyncAndCatch(async cb => {\n        try {\n          const wb = new Workbox('sw-clients-claim.js.njk');\n          const installedSpy = sinon.spy();\n          const waitingSpy = sinon.spy();\n          const activatedSpy = sinon.spy();\n          const controllingSpy = sinon.spy();\n          wb.addEventListener('installed', installedSpy);\n          wb.addEventListener('waiting', waitingSpy);\n          wb.addEventListener('activated', activatedSpy);\n          wb.addEventListener('controlling', controllingSpy);\n          await wb.register();\n          await window.activatedAndControlling(wb);\n          cb({\n            isUpdate: installedSpy.args[0][0].isUpdate,\n            installedSpyCallCount: installedSpy.callCount,\n            waitingSpyCallCount: waitingSpy.callCount,\n            controllingSpyCallCount: controllingSpy.callCount,\n            controllingIsExternal: controllingSpy.args[0][0].isExternal,\n            activatedSpyCallCount: activatedSpy.callCount\n          });\n        } catch (error) {\n          cb({\n            error: error.stack\n          });\n        }\n      }); // Test for truthiness because some browsers structure clone\n      // `undefined` to `null`.\n\n      expect(result.isUpdate).to.not.be.ok;\n      expect(result.controllingIsExternal).to.not.be.ok;\n      expect(result.installedSpyCallCount).to.equal(1);\n      expect(result.activatedSpyCallCount).to.equal(1);\n      expect(result.controllingSpyCallCount).to.equal(1); //  A new installation shouldn't enter the waiting phase.\n\n      expect(result.waitingSpyCallCount).to.equal(0);\n    });","file":"workbox-window/integration/test-all.js","skipped":false,"dir":"test"},{"name":"reports all events for an updated SW registration","suites":["[workbox-window] Workbox","register"],"updatePoint":{"line":117,"column":57},"line":117,"code":"    it(`reports all events for an updated SW registration`, async function () {\n      const result = await executeAsyncAndCatch(async cb => {\n        try {\n          const wb1 = new Workbox('sw-clients-claim.js.njk?v=1');\n          const redundantSpy = sinon.spy();\n          const wb1ControllingSpy = sinon.spy();\n          wb1.addEventListener('redundant', redundantSpy);\n          wb1.addEventListener('controlling', wb1ControllingSpy);\n          await wb1.register();\n          await window.activatedAndControlling(wb1);\n          const wb2 = new Workbox('sw-clients-claim.js.njk?v=2');\n          const installedSpy = sinon.spy();\n          const waitingSpy = sinon.spy();\n          const activatedSpy = sinon.spy();\n          const wb2ControllingSpy = sinon.spy();\n          wb2.addEventListener('installed', installedSpy);\n          wb2.addEventListener('waiting', waitingSpy);\n          wb2.addEventListener('activated', activatedSpy);\n          wb2.addEventListener('controlling', wb2ControllingSpy);\n          await wb2.register(); // Once the newly updated SW is in control, report back.\n\n          await window.activatedAndControlling(wb2);\n          cb({\n            wb1IsUpdate: redundantSpy.args[0][0].isUpdate,\n            wb2IsUpdate: installedSpy.args[0][0].isUpdate,\n            wb1ControllingIsExternal: wb1ControllingSpy.args[0][0].isExternal,\n            wb2ControllingIsExternal: wb2ControllingSpy.args[0][0].isExternal,\n            installedSpyCallCount: installedSpy.callCount,\n            waitingSpyCallCount: waitingSpy.callCount,\n            controllingSpyCallCount: wb2ControllingSpy.callCount,\n            activatedSpyCallCount: activatedSpy.callCount\n          });\n        } catch (error) {\n          cb({\n            error: error.stack\n          });\n        }\n      }); // Test for truthiness because some browsers structure clone\n      // `undefined` to `null`.\n\n      expect(result.wb1IsUpdate).to.not.be.ok;\n      expect(result.wb2IsUpdate).to.equal(true);\n      expect(result.wb1ControllingIsExternal).to.not.be.ok;\n      expect(result.wb2ControllingIsExternal).to.not.be.ok;\n      expect(result.installedSpyCallCount).to.equal(1);\n      expect(result.waitingSpyCallCount).to.equal(0);\n      expect(result.activatedSpyCallCount).to.equal(1);\n      expect(result.controllingSpyCallCount).to.equal(1);\n    });","file":"workbox-window/integration/test-all.js","skipped":false,"dir":"test"},{"name":"reports all events for an external SW registration","suites":["[workbox-window] Workbox","register"],"updatePoint":{"line":166,"column":58},"line":166,"code":"    it(`reports all events for an external SW registration`, async function () {\n      const iframeManager = new IframeManager(webdriver);\n      await executeAsyncAndCatch(async cb => {\n        try {\n          const wb = new Workbox('sw-clients-claim.js.njk'); // Use a global variable so these are accessible to future\n          // `executeAsyncAndCatch()` calls.\n\n          self.__spies = {\n            installedSpy: sinon.spy(),\n            waitingSpy: sinon.spy(),\n            activatedSpy: sinon.spy(),\n            controllingSpy: sinon.spy()\n          };\n          wb.addEventListener('installed', self.__spies.installedSpy);\n          wb.addEventListener('waiting', self.__spies.waitingSpy);\n          wb.addEventListener('activated', self.__spies.activatedSpy);\n          wb.addEventListener('controlling', self.__spies.controllingSpy);\n          await wb.register(); // Resolve this execution block once the SW is in control.\n\n          await window.activatedAndControlling(wb);\n          cb();\n        } catch (error) {\n          cb({\n            error: error.stack\n          });\n        }\n      }); // Update the version in sw.js to trigger a new installation.\n\n      templateData.assign({\n        version: '2'\n      });\n      const secondPath = `${testPath}?second`;\n      const iframeClient = await iframeManager.createIframeClient(secondPath);\n      const location = await iframeClient.executeAsyncScript(`\n        const wb = new Workbox('sw-clients-claim.js.njk');\n        wb.register()\n          .then(() => window.activatedAndControlling(wb))\n          .then(() => location.href);\n      `); // Just confirm we're operating on the page we expect.\n\n      expect(location).to.eql(secondPath);\n      const result = await executeAsyncAndCatch(async cb => {\n        cb({\n          location: location.href,\n          installedSpyArgs: JSON.stringify(self.__spies.installedSpy.args),\n          waitingSpyArgs: JSON.stringify(self.__spies.waitingSpy.args),\n          activatedSpyArgs: JSON.stringify(self.__spies.activatedSpy.args),\n          controllingSpyArgs: JSON.stringify(self.__spies.controllingSpy.args)\n        });\n      });\n      const installedSpyArgs = JSON.parse(result.installedSpyArgs);\n      const waitingSpyArgs = JSON.parse(result.waitingSpyArgs);\n      const activatedSpyArgs = JSON.parse(result.activatedSpyArgs);\n      const controllingSpyArgs = JSON.parse(result.controllingSpyArgs); // Just confirm we're operating on the page we expect.\n\n      expect(result.location).to.eql(testPath);\n      expect(installedSpyArgs.length, 'installedSpy').to.eql(2);\n      expect(waitingSpyArgs.length, 'waitingSpy').to.eql(0);\n      expect(activatedSpyArgs.length, 'activatedSpy').to.eql(2);\n      expect(controllingSpyArgs.length, 'controllingSpy').to.eql(2);\n      expect(installedSpyArgs[0][0].isExternal).to.eql(false);\n      expect(activatedSpyArgs[0][0].isExternal).to.eql(false);\n      expect(controllingSpyArgs[0][0].isExternal).to.eql(false);\n      expect(installedSpyArgs[1][0].isExternal).to.eql(true);\n      expect(activatedSpyArgs[1][0].isExternal).to.eql(true);\n      expect(controllingSpyArgs[1][0].isExternal).to.eql(true);\n    });","file":"workbox-window/integration/test-all.js","skipped":false,"dir":"test"}]}