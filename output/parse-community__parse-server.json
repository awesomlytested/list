{"repo":"parse-community/parse-server","url":"https://github.com/parse-community/parse-server","branch":"alpha","configs":[{"package":"parse-server","lang":"js","dir":"spec","framework":"jasmine","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"account should not be locked even after failed login attempts if account lockout policy is not set","suites":["Account Lockout Policy: "],"line":31,"updatePoint":{"line":31,"column":104,"index":1176},"code":"  it('account should not be locked even after failed login attempts if account lockout policy is not set', done => {\n    reconfigureServer({\n      appName: 'unlimited',\n      publicServerURL: 'http://localhost:1337/1'\n    }).then(() => {\n      const user = new Parse.User();\n      user.setUsername('username1');\n      user.setPassword('password');\n      return user.signUp(null);\n    }).then(() => {\n      return loginWithWrongCredentialsShouldFail('username1', 'incorrect password 1');\n    }).then(() => {\n      return loginWithWrongCredentialsShouldFail('username1', 'incorrect password 2');\n    }).then(() => {\n      return loginWithWrongCredentialsShouldFail('username1', 'incorrect password 3');\n    }).then(() => done()).catch(err => {\n      fail('allow unlimited failed login attempts failed: ' + JSON.stringify(err));\n      done();\n    });\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"throw error if duration is set to an invalid number","suites":["Account Lockout Policy: "],"line":51,"updatePoint":{"line":51,"column":57,"index":1983},"code":"  it('throw error if duration is set to an invalid number', done => {\n    reconfigureServer({\n      appName: 'duration',\n      accountLockout: {\n        duration: 'invalid value',\n        threshold: 5\n      },\n      publicServerURL: 'https://my.public.server.com/1'\n    }).then(() => {\n      Config.get('test');\n      fail('set duration to an invalid number test failed');\n      done();\n    }).catch(err => {\n      if (err && err === 'Account lockout duration should be greater than 0 and less than 100000') {\n        done();\n      } else {\n        fail('set duration to an invalid number test failed: ' + JSON.stringify(err));\n        done();\n      }\n    });\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"throw error if threshold is set to an invalid number","suites":["Account Lockout Policy: "],"line":72,"updatePoint":{"line":72,"column":58,"index":2650},"code":"  it('throw error if threshold is set to an invalid number', done => {\n    reconfigureServer({\n      appName: 'threshold',\n      accountLockout: {\n        duration: 5,\n        threshold: 'invalid number'\n      },\n      publicServerURL: 'https://my.public.server.com/1'\n    }).then(() => {\n      Config.get('test');\n      fail('set threshold to an invalid number test failed');\n      done();\n    }).catch(err => {\n      if (err && err === 'Account lockout threshold should be an integer greater than 0 and less than 1000') {\n        done();\n      } else {\n        fail('set threshold to an invalid number test failed: ' + JSON.stringify(err));\n        done();\n      }\n    });\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"throw error if threshold is < 1","suites":["Account Lockout Policy: "],"line":93,"updatePoint":{"line":93,"column":37,"index":3310},"code":"  it('throw error if threshold is < 1', done => {\n    reconfigureServer({\n      appName: 'threshold',\n      accountLockout: {\n        duration: 5,\n        threshold: 0\n      },\n      publicServerURL: 'https://my.public.server.com/1'\n    }).then(() => {\n      Config.get('test');\n      fail('threshold value < 1 is invalid test failed');\n      done();\n    }).catch(err => {\n      if (err && err === 'Account lockout threshold should be an integer greater than 0 and less than 1000') {\n        done();\n      } else {\n        fail('threshold value < 1 is invalid test failed: ' + JSON.stringify(err));\n        done();\n      }\n    });\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"throw error if threshold is > 999","suites":["Account Lockout Policy: "],"line":114,"updatePoint":{"line":114,"column":39,"index":3949},"code":"  it('throw error if threshold is > 999', done => {\n    reconfigureServer({\n      appName: 'threshold',\n      accountLockout: {\n        duration: 5,\n        threshold: 1000\n      },\n      publicServerURL: 'https://my.public.server.com/1'\n    }).then(() => {\n      Config.get('test');\n      fail('threshold value > 999 is invalid test failed');\n      done();\n    }).catch(err => {\n      if (err && err === 'Account lockout threshold should be an integer greater than 0 and less than 1000') {\n        done();\n      } else {\n        fail('threshold value > 999 is invalid test failed: ' + JSON.stringify(err));\n        done();\n      }\n    });\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"throw error if duration is <= 0","suites":["Account Lockout Policy: "],"line":135,"updatePoint":{"line":135,"column":37,"index":4593},"code":"  it('throw error if duration is <= 0', done => {\n    reconfigureServer({\n      appName: 'duration',\n      accountLockout: {\n        duration: 0,\n        threshold: 5\n      },\n      publicServerURL: 'https://my.public.server.com/1'\n    }).then(() => {\n      Config.get('test');\n      fail('duration value < 1 is invalid test failed');\n      done();\n    }).catch(err => {\n      if (err && err === 'Account lockout duration should be greater than 0 and less than 100000') {\n        done();\n      } else {\n        fail('duration value < 1 is invalid test failed: ' + JSON.stringify(err));\n        done();\n      }\n    });\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"throw error if duration is > 99999","suites":["Account Lockout Policy: "],"line":156,"updatePoint":{"line":156,"column":40,"index":5220},"code":"  it('throw error if duration is > 99999', done => {\n    reconfigureServer({\n      appName: 'duration',\n      accountLockout: {\n        duration: 100000,\n        threshold: 5\n      },\n      publicServerURL: 'https://my.public.server.com/1'\n    }).then(() => {\n      Config.get('test');\n      fail('duration value > 99999 is invalid test failed');\n      done();\n    }).catch(err => {\n      if (err && err === 'Account lockout duration should be greater than 0 and less than 100000') {\n        done();\n      } else {\n        fail('duration value > 99999 is invalid test failed: ' + JSON.stringify(err));\n        done();\n      }\n    });\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"lock account if failed login attempts are above threshold","suites":["Account Lockout Policy: "],"line":177,"updatePoint":{"line":177,"column":63,"index":5883},"code":"  it('lock account if failed login attempts are above threshold', done => {\n    reconfigureServer({\n      appName: 'lockout threshold',\n      accountLockout: {\n        duration: 1,\n        threshold: 2\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      const user = new Parse.User();\n      user.setUsername('username2');\n      user.setPassword('failedLoginAttemptsThreshold');\n      return user.signUp();\n    }).then(() => {\n      return loginWithWrongCredentialsShouldFail('username2', 'wrong password');\n    }).then(() => {\n      return loginWithWrongCredentialsShouldFail('username2', 'wrong password');\n    }).then(() => {\n      return isAccountLockoutError('username2', 'wrong password', 1, 1);\n    }).then(() => {\n      done();\n    }).catch(err => {\n      fail('lock account after failed login attempts test failed: ' + JSON.stringify(err));\n      done();\n    });\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"lock account for accountPolicy.duration minutes if failed login attempts are above threshold","suites":["Account Lockout Policy: "],"line":203,"updatePoint":{"line":203,"column":98,"index":6827},"code":"  it('lock account for accountPolicy.duration minutes if failed login attempts are above threshold', done => {\n    reconfigureServer({\n      appName: 'lockout threshold',\n      accountLockout: {\n        duration: 0.05,\n        // 0.05*60 = 3 secs\n        threshold: 2\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      const user = new Parse.User();\n      user.setUsername('username3');\n      user.setPassword('failedLoginAttemptsThreshold');\n      return user.signUp();\n    }).then(() => {\n      return loginWithWrongCredentialsShouldFail('username3', 'wrong password');\n    }).then(() => {\n      return loginWithWrongCredentialsShouldFail('username3', 'wrong password');\n    }).then(() => {\n      return isAccountLockoutError('username3', 'wrong password', 0.05, 1);\n    }).then(() => {\n      // account should still be locked even after 2 seconds.\n      return isAccountLockoutError('username3', 'wrong password', 0.05, 2000);\n    }).then(() => {\n      done();\n    }).catch(err => {\n      fail('account should be locked for duration mins test failed: ' + JSON.stringify(err));\n      done();\n    });\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"allow login for locked account after accountPolicy.duration minutes","suites":["Account Lockout Policy: "],"line":233,"updatePoint":{"line":233,"column":73,"index":7943},"code":"  it('allow login for locked account after accountPolicy.duration minutes', done => {\n    reconfigureServer({\n      appName: 'lockout threshold',\n      accountLockout: {\n        duration: 0.05,\n        // 0.05*60 = 3 secs\n        threshold: 2\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      const user = new Parse.User();\n      user.setUsername('username4');\n      user.setPassword('correct password');\n      return user.signUp();\n    }).then(() => {\n      return loginWithWrongCredentialsShouldFail('username4', 'wrong password');\n    }).then(() => {\n      return loginWithWrongCredentialsShouldFail('username4', 'wrong password');\n    }).then(() => {\n      // allow locked user to login after 3 seconds with a valid userid and password\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          Parse.User.logIn('username4', 'correct password').then(() => resolve()).catch(err => reject(err));\n        }, 3001);\n      });\n    }).then(() => {\n      done();\n    }).catch(err => {\n      fail('allow login for locked account after accountPolicy.duration minutes test failed: ' + JSON.stringify(err));\n      done();\n    });\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"accepts valid unlockOnPasswordReset option","suites":["lockout with password reset option"],"line":286,"updatePoint":{"line":286,"column":48,"index":9794},"code":"  it('accepts valid unlockOnPasswordReset option', async () => {\n    const values = [true, false];\n    for (const value of values) {\n      await expectAsync(setup({\n        unlockOnPasswordReset: value\n      })).toBeResolved();\n    }\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"rejects invalid unlockOnPasswordReset option","suites":["lockout with password reset option"],"line":294,"updatePoint":{"line":294,"column":50,"index":10036},"code":"  it('rejects invalid unlockOnPasswordReset option', async () => {\n    const values = ['a', 0, {}, [], null];\n    for (const value of values) {\n      await expectAsync(setup({\n        unlockOnPasswordReset: value\n      })).toBeRejected();\n    }\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"uses default value if unlockOnPasswordReset is not set","suites":["lockout with password reset option"],"line":302,"updatePoint":{"line":302,"column":60,"index":10297},"code":"  it('uses default value if unlockOnPasswordReset is not set', async () => {\n    await expectAsync(setup({\n      unlockOnPasswordReset: undefined\n    })).toBeResolved();\n    const parseConfig = Config.get(Parse.applicationId);\n    expect(parseConfig.accountLockout.unlockOnPasswordReset).toBe(Definitions.AccountLockoutOptions.unlockOnPasswordReset.default);\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"allow login for locked account after password reset","suites":["lockout with password reset option"],"line":309,"updatePoint":{"line":309,"column":57,"index":10659},"code":"  it('allow login for locked account after password reset', async () => {\n    await setup({\n      unlockOnPasswordReset: true\n    });\n    const config = Config.get(Parse.applicationId);\n    const user = new Parse.User();\n    const username = 'exampleUsername';\n    const password = 'examplePassword';\n    user.setUsername(username);\n    user.setPassword(password);\n    user.setEmail('mail@example.com');\n    await user.signUp();\n    await expectAsync(Parse.User.logIn(username, 'incorrectPassword')).toBeRejected();\n    await expectAsync(Parse.User.logIn(username, password)).toBeRejected();\n    await Parse.User.requestPasswordReset(user.getEmail());\n    await expectAsync(Parse.User.logIn(username, password)).toBeRejected();\n    const link = sendPasswordResetEmail.calls.all()[0].args[0].link;\n    const linkUrl = new URL(link);\n    const token = linkUrl.searchParams.get('token');\n    const newPassword = 'newPassword';\n    await request({\n      method: 'POST',\n      url: `${config.publicServerURL}/apps/test/request_password_reset`,\n      body: `new_password=${newPassword}&token=${token}&username=${username}`,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      followRedirects: false\n    });\n    await expectAsync(Parse.User.logIn(username, newPassword)).toBeResolved();\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"reject login for locked account after password reset (default)","suites":["lockout with password reset option"],"line":340,"updatePoint":{"line":340,"column":68,"index":11996},"code":"  it('reject login for locked account after password reset (default)', async () => {\n    await setup();\n    const config = Config.get(Parse.applicationId);\n    const user = new Parse.User();\n    const username = 'exampleUsername';\n    const password = 'examplePassword';\n    user.setUsername(username);\n    user.setPassword(password);\n    user.setEmail('mail@example.com');\n    await user.signUp();\n    await expectAsync(Parse.User.logIn(username, 'incorrectPassword')).toBeRejected();\n    await expectAsync(Parse.User.logIn(username, password)).toBeRejected();\n    await Parse.User.requestPasswordReset(user.getEmail());\n    await expectAsync(Parse.User.logIn(username, password)).toBeRejected();\n    const link = sendPasswordResetEmail.calls.all()[0].args[0].link;\n    const linkUrl = new URL(link);\n    const token = linkUrl.searchParams.get('token');\n    const newPassword = 'newPassword';\n    await request({\n      method: 'POST',\n      url: `${config.publicServerURL}/apps/test/request_password_reset`,\n      body: `new_password=${newPassword}&token=${token}&username=${username}`,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      followRedirects: false\n    });\n    await expectAsync(Parse.User.logIn(username, newPassword)).toBeRejected();\n  });","file":"AccountLockoutPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should use the provided adapter","suites":["AdaptableController"],"line":10,"updatePoint":{"line":10,"column":37,"index":563},"code":"  it('should use the provided adapter', done => {\n    const adapter = new FilesAdapter();\n    const controller = new FilesController(adapter);\n    expect(controller.adapter).toBe(adapter);\n    // make sure _adapter is private\n    expect(controller._adapter).toBe(undefined);\n    // Override _adapter is not doing anything\n    controller._adapter = 'Hello';\n    expect(controller.adapter).toBe(adapter);\n    done();\n  });","file":"AdaptableController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when creating a new mock controller","suites":["AdaptableController"],"line":21,"updatePoint":{"line":21,"column":54,"index":1001},"code":"  it('should throw when creating a new mock controller', done => {\n    const adapter = new FilesAdapter();\n    expect(() => {\n      new MockController(adapter);\n    }).toThrow();\n    done();\n  });","file":"AdaptableController.spec.js","skipped":false,"dir":"spec"},{"name":"should fail setting the wrong adapter to the controller","suites":["AdaptableController"],"line":28,"updatePoint":{"line":28,"column":61,"index":1205},"code":"  it('should fail setting the wrong adapter to the controller', done => {\n    function WrongAdapter() {}\n    const adapter = new FilesAdapter();\n    const controller = new FilesController(adapter);\n    const otherAdapter = new WrongAdapter();\n    expect(() => {\n      controller.adapter = otherAdapter;\n    }).toThrow();\n    done();\n  });","file":"AdaptableController.spec.js","skipped":false,"dir":"spec"},{"name":"should fail to instantiate a controller with wrong adapter","suites":["AdaptableController"],"line":38,"updatePoint":{"line":38,"column":64,"index":1547},"code":"  it('should fail to instantiate a controller with wrong adapter', done => {\n    function WrongAdapter() {}\n    const adapter = new WrongAdapter();\n    expect(() => {\n      new FilesController(adapter);\n    }).toThrow();\n    done();\n  });","file":"AdaptableController.spec.js","skipped":false,"dir":"spec"},{"name":"should fail to instantiate a controller without an adapter","suites":["AdaptableController"],"line":46,"updatePoint":{"line":46,"column":64,"index":1786},"code":"  it('should fail to instantiate a controller without an adapter', done => {\n    expect(() => {\n      new FilesController();\n    }).toThrow();\n    done();\n  });","file":"AdaptableController.spec.js","skipped":false,"dir":"spec"},{"name":"should accept an object adapter","suites":["AdaptableController"],"line":52,"updatePoint":{"line":52,"column":37,"index":1920},"code":"  it('should accept an object adapter', done => {\n    const adapter = {\n      createFile: function () {},\n      deleteFile: function () {},\n      getFileData: function () {},\n      getFileLocation: function () {},\n      validateFilename: function () {}\n    };\n    expect(() => {\n      new FilesController(adapter);\n    }).not.toThrow();\n    done();\n  });","file":"AdaptableController.spec.js","skipped":false,"dir":"spec"},{"name":"should accept an prototype based object adapter","suites":["AdaptableController"],"line":65,"updatePoint":{"line":65,"column":53,"index":2291},"code":"  it('should accept an prototype based object adapter', done => {\n    function AGoodAdapter() {}\n    AGoodAdapter.prototype.createFile = function () {};\n    AGoodAdapter.prototype.deleteFile = function () {};\n    AGoodAdapter.prototype.getFileData = function () {};\n    AGoodAdapter.prototype.getFileLocation = function () {};\n    AGoodAdapter.prototype.validateFilename = function () {};\n    const adapter = new AGoodAdapter();\n    expect(() => {\n      new FilesController(adapter);\n    }).not.toThrow();\n    done();\n  });","file":"AdaptableController.spec.js","skipped":false,"dir":"spec"},{"name":"should instantiate an adapter from string in object","suites":["AdapterLoader"],"line":7,"updatePoint":{"line":7,"column":57,"index":393},"code":"  it('should instantiate an adapter from string in object', done => {\n    const adapterPath = require('path').resolve('./spec/support/MockAdapter');\n    const adapter = loadAdapter({\n      adapter: adapterPath,\n      options: {\n        key: 'value',\n        foo: 'bar'\n      }\n    });\n    expect(adapter instanceof Object).toBe(true);\n    expect(adapter.options.key).toBe('value');\n    expect(adapter.options.foo).toBe('bar');\n    done();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"should instantiate an adapter from string","suites":["AdapterLoader"],"line":21,"updatePoint":{"line":21,"column":47,"index":828},"code":"  it('should instantiate an adapter from string', done => {\n    const adapterPath = require('path').resolve('./spec/support/MockAdapter');\n    const adapter = loadAdapter(adapterPath);\n    expect(adapter instanceof Object).toBe(true);\n    done();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"should instantiate an adapter from string that is module","suites":["AdapterLoader"],"line":27,"updatePoint":{"line":27,"column":62,"index":1096},"code":"  it('should instantiate an adapter from string that is module', done => {\n    const adapterPath = require('path').resolve('./lib/Adapters/Files/FilesAdapter');\n    const adapter = loadAdapter({\n      adapter: adapterPath\n    });\n    expect(typeof adapter).toBe('object');\n    expect(typeof adapter.createFile).toBe('function');\n    expect(typeof adapter.deleteFile).toBe('function');\n    expect(typeof adapter.getFileData).toBe('function');\n    expect(typeof adapter.getFileLocation).toBe('function');\n    done();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"should instantiate an adapter from npm module","suites":["AdapterLoader"],"line":39,"updatePoint":{"line":39,"column":51,"index":1606},"code":"  it('should instantiate an adapter from npm module', done => {\n    const adapter = loadAdapter({\n      module: '@parse/fs-files-adapter'\n    });\n    expect(typeof adapter).toBe('object');\n    expect(typeof adapter.createFile).toBe('function');\n    expect(typeof adapter.deleteFile).toBe('function');\n    expect(typeof adapter.getFileData).toBe('function');\n    expect(typeof adapter.getFileLocation).toBe('function');\n    done();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"should instantiate an adapter from function/Class","suites":["AdapterLoader"],"line":50,"updatePoint":{"line":50,"column":55,"index":2047},"code":"  it('should instantiate an adapter from function/Class', done => {\n    const adapter = loadAdapter({\n      adapter: FilesAdapter\n    });\n    expect(adapter instanceof FilesAdapter).toBe(true);\n    done();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"should instantiate the default adapter from Class","suites":["AdapterLoader"],"line":57,"updatePoint":{"line":57,"column":55,"index":2259},"code":"  it('should instantiate the default adapter from Class', done => {\n    const adapter = loadAdapter(null, FilesAdapter);\n    expect(adapter instanceof FilesAdapter).toBe(true);\n    done();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"should use the default adapter","suites":["AdapterLoader"],"line":62,"updatePoint":{"line":62,"column":36,"index":2435},"code":"  it('should use the default adapter', done => {\n    const defaultAdapter = new FilesAdapter();\n    const adapter = loadAdapter(null, defaultAdapter);\n    expect(adapter instanceof FilesAdapter).toBe(true);\n    done();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"should use the provided adapter","suites":["AdapterLoader"],"line":68,"updatePoint":{"line":68,"column":37,"index":2661},"code":"  it('should use the provided adapter', done => {\n    const originalAdapter = new FilesAdapter();\n    const adapter = loadAdapter(originalAdapter);\n    expect(adapter).toBe(originalAdapter);\n    done();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"should fail loading an improperly configured adapter","suites":["AdapterLoader"],"line":74,"updatePoint":{"line":74,"column":58,"index":2891},"code":"  it('should fail loading an improperly configured adapter', done => {\n    const Adapter = function (options) {\n      if (!options.foo) {\n        throw 'foo is required for that adapter';\n      }\n    };\n    const adapterOptions = {\n      param: 'key',\n      doSomething: function () {}\n    };\n    expect(() => {\n      const adapter = loadAdapter(adapterOptions, Adapter);\n      expect(adapter).toEqual(adapterOptions);\n    }).not.toThrow('foo is required for that adapter');\n    done();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"should load push adapter from options","suites":["AdapterLoader"],"line":90,"updatePoint":{"line":90,"column":43,"index":3369},"code":"  it('should load push adapter from options', done => {\n    const options = {\n      android: {\n        senderId: 'yolo',\n        apiKey: 'yolo'\n      }\n    };\n    expect(() => {\n      const adapter = loadAdapter(undefined, ParsePushAdapter, options);\n      expect(adapter.constructor).toBe(ParsePushAdapter);\n      expect(adapter).not.toBe(undefined);\n    }).not.toThrow();\n    done();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"should load custom push adapter from string (#3544)","suites":["AdapterLoader"],"line":104,"updatePoint":{"line":104,"column":57,"index":3775},"code":"  it('should load custom push adapter from string (#3544)', done => {\n    const adapterPath = require('path').resolve('./spec/support/MockPushAdapter');\n    const options = {\n      ios: {\n        bundleId: 'bundle.id'\n      }\n    };\n    const pushAdapterOptions = {\n      adapter: adapterPath,\n      options\n    };\n    expect(() => {\n      reconfigureServer({\n        push: pushAdapterOptions\n      }).then(() => {\n        const config = Config.get(Parse.applicationId);\n        const pushAdapter = config.pushWorker.adapter;\n        expect(pushAdapter.getValidPushTypes()).toEqual(['ios']);\n        expect(pushAdapter.options).toEqual(pushAdapterOptions);\n        done();\n      });\n    }).not.toThrow();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"should load file adapter from direct passing","suites":["AdapterLoader"],"line":127,"updatePoint":{"line":127,"column":50,"index":4479},"code":"  it('should load file adapter from direct passing', done => {\n    spyOn(console, 'warn').and.callFake(() => {});\n    const mockFilesAdapter = new MockFilesAdapter('key', 'secret', 'bucket');\n    expect(() => {\n      const adapter = loadAdapter(mockFilesAdapter, FilesAdapter);\n      expect(adapter).toBe(mockFilesAdapter);\n    }).not.toThrow();\n    done();\n  });","file":"AdapterLoader.spec.js","skipped":false,"dir":"spec"},{"name":"get pipeline from Array","suites":["AggregateRouter"],"line":4,"updatePoint":{"line":4,"column":29,"index":220},"code":"  it('get pipeline from Array', () => {\n    const body = [{\n      group: {\n        objectId: {}\n      }\n    }];\n    const expected = [{\n      $group: {\n        _id: {}\n      }\n    }];\n    const result = AggregateRouter.getPipeline(body);\n    expect(result).toEqual(expected);\n  });","file":"AggregateRouter.spec.js","skipped":false,"dir":"spec"},{"name":"get pipeline from Object","suites":["AggregateRouter"],"line":20,"updatePoint":{"line":20,"column":30,"index":575},"code":"  it('get pipeline from Object', () => {\n    const body = {\n      group: {\n        objectId: {}\n      }\n    };\n    const expected = [{\n      $group: {\n        _id: {}\n      }\n    }];\n    const result = AggregateRouter.getPipeline(body);\n    expect(result).toEqual(expected);\n  });","file":"AggregateRouter.spec.js","skipped":false,"dir":"spec"},{"name":"get pipeline from Pipeline Operator (Array)","suites":["AggregateRouter"],"line":36,"updatePoint":{"line":36,"column":49,"index":947},"code":"  it('get pipeline from Pipeline Operator (Array)', () => {\n    const body = {\n      pipeline: [{\n        group: {\n          objectId: {}\n        }\n      }]\n    };\n    const expected = [{\n      $group: {\n        _id: {}\n      }\n    }];\n    const result = AggregateRouter.getPipeline(body);\n    expect(result).toEqual(expected);\n  });","file":"AggregateRouter.spec.js","skipped":false,"dir":"spec"},{"name":"get pipeline from Pipeline Operator (Object)","suites":["AggregateRouter"],"line":54,"updatePoint":{"line":54,"column":50,"index":1354},"code":"  it('get pipeline from Pipeline Operator (Object)', () => {\n    const body = {\n      pipeline: {\n        group: {\n          objectId: {}\n        }\n      }\n    };\n    const expected = [{\n      $group: {\n        _id: {}\n      }\n    }];\n    const result = AggregateRouter.getPipeline(body);\n    expect(result).toEqual(expected);\n  });","file":"AggregateRouter.spec.js","skipped":false,"dir":"spec"},{"name":"get pipeline fails multiple keys in Array stage ","suites":["AggregateRouter"],"line":72,"updatePoint":{"line":72,"column":54,"index":1763},"code":"  it('get pipeline fails multiple keys in Array stage ', () => {\n    const body = [{\n      group: {\n        objectId: {}\n      },\n      match: {\n        name: 'Test'\n      }\n    }];\n    try {\n      AggregateRouter.getPipeline(body);\n    } catch (e) {\n      expect(e.message).toBe('Pipeline stages should only have one key found group, match');\n    }\n  });","file":"AggregateRouter.spec.js","skipped":false,"dir":"spec"},{"name":"get pipeline fails multiple keys in Pipeline Operator Array stage ","suites":["AggregateRouter"],"line":89,"updatePoint":{"line":89,"column":72,"index":2209},"code":"  it('get pipeline fails multiple keys in Pipeline Operator Array stage ', () => {\n    const body = {\n      pipeline: [{\n        group: {\n          objectId: {}\n        },\n        match: {\n          name: 'Test'\n        }\n      }]\n    };\n    try {\n      AggregateRouter.getPipeline(body);\n    } catch (e) {\n      expect(e.message).toBe('Pipeline stages should only have one key found group, match');\n    }\n  });","file":"AggregateRouter.spec.js","skipped":false,"dir":"spec"},{"name":"get search pipeline from Pipeline Operator (Array)","suites":["AggregateRouter"],"line":108,"updatePoint":{"line":108,"column":56,"index":2677},"code":"  it('get search pipeline from Pipeline Operator (Array)', () => {\n    const body = {\n      pipeline: {\n        search: {}\n      }\n    };\n    const expected = [{\n      $search: {}\n    }];\n    const result = AggregateRouter.getPipeline(body);\n    expect(result).toEqual(expected);\n  });","file":"AggregateRouter.spec.js","skipped":false,"dir":"spec"},{"name":"support stage name starting with `$`","suites":["AggregateRouter"],"line":120,"updatePoint":{"line":120,"column":42,"index":2949},"code":"  it('support stage name starting with `$`', () => {\n    const body = {\n      $match: {\n        someKey: 'whatever'\n      }\n    };\n    const expected = [{\n      $match: {\n        someKey: 'whatever'\n      }\n    }];\n    const result = AggregateRouter.getPipeline(body);\n    expect(result).toEqual(expected);\n  });","file":"AggregateRouter.spec.js","skipped":false,"dir":"spec"},{"name":"support nested stage names starting with `$`","suites":["AggregateRouter"],"line":134,"updatePoint":{"line":134,"column":50,"index":3270},"code":"  it('support nested stage names starting with `$`', () => {\n    const body = [{\n      lookup: {\n        from: 'ACollection',\n        let: {\n          id: '_id'\n        },\n        as: 'results',\n        pipeline: [{\n          $match: {\n            $expr: {\n              $eq: ['$_id', '$$id']\n            }\n          }\n        }]\n      }\n    }];\n    const expected = [{\n      $lookup: {\n        from: 'ACollection',\n        let: {\n          id: '_id'\n        },\n        as: 'results',\n        pipeline: [{\n          $match: {\n            $expr: {\n              $eq: ['$_id', '$$id']\n            }\n          }\n        }]\n      }\n    }];\n    const result = AggregateRouter.getPipeline(body);\n    expect(result).toEqual(expected);\n  });","file":"AggregateRouter.spec.js","skipped":false,"dir":"spec"},{"name":"support the use of `_id` in stages","suites":["AggregateRouter"],"line":170,"updatePoint":{"line":170,"column":40,"index":3994},"code":"  it('support the use of `_id` in stages', () => {\n    const body = [{\n      match: {\n        _id: 'randomId'\n      }\n    }, {\n      sort: {\n        _id: -1\n      }\n    }, {\n      addFields: {\n        _id: 1\n      }\n    }, {\n      group: {\n        _id: {}\n      }\n    }, {\n      project: {\n        _id: 0\n      }\n    }];\n    const expected = [{\n      $match: {\n        _id: 'randomId'\n      }\n    }, {\n      $sort: {\n        _id: -1\n      }\n    }, {\n      $addFields: {\n        _id: 1\n      }\n    }, {\n      $group: {\n        _id: {}\n      }\n    }, {\n      $project: {\n        _id: 0\n      }\n    }];\n    const result = AggregateRouter.getPipeline(body);\n    expect(result).toEqual(expected);\n  });","file":"AggregateRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should track a simple event","suites":["AnalyticsController"],"line":6,"updatePoint":{"line":6,"column":33,"index":162},"code":"  it('should track a simple event', done => {\n    spyOn(analyticsAdapter, 'trackEvent').and.callThrough();\n    reconfigureServer({\n      analyticsAdapter\n    }).then(() => {\n      return Parse.Analytics.track('MyEvent', {\n        key: 'value',\n        count: '0'\n      });\n    }).then(() => {\n      expect(analyticsAdapter.trackEvent).toHaveBeenCalled();\n      const lastCall = analyticsAdapter.trackEvent.calls.first();\n      const args = lastCall.args;\n      expect(args[0]).toEqual('MyEvent');\n      expect(args[1]).toEqual({\n        dimensions: {\n          key: 'value',\n          count: '0'\n        }\n      });\n      done();\n    }, err => {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"Analytics.spec.js","skipped":false,"dir":"spec"},{"name":"should track a app opened event","suites":["AnalyticsController"],"line":32,"updatePoint":{"line":32,"column":37,"index":873},"code":"  it('should track a app opened event', done => {\n    spyOn(analyticsAdapter, 'appOpened').and.callThrough();\n    reconfigureServer({\n      analyticsAdapter\n    }).then(() => {\n      return Parse.Analytics.track('AppOpened', {\n        key: 'value',\n        count: '0'\n      });\n    }).then(() => {\n      expect(analyticsAdapter.appOpened).toHaveBeenCalled();\n      const lastCall = analyticsAdapter.appOpened.calls.first();\n      const args = lastCall.args;\n      expect(args[0]).toEqual({\n        dimensions: {\n          key: 'value',\n          count: '0'\n        }\n      });\n      done();\n    }, err => {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"Analytics.spec.js","skipped":false,"dir":"spec"},{"name":"uses find condition from request.body","suites":["AudiencesRouter"],"line":7,"updatePoint":{"line":7,"column":43,"index":321},"code":"  it('uses find condition from request.body', done => {\n    const config = Config.get('test');\n    const androidAudienceRequest = {\n      name: 'Android Users',\n      query: '{ \"test\": \"android\" }'\n    };\n    const iosAudienceRequest = {\n      name: 'Iphone Users',\n      query: '{ \"test\": \"ios\" }'\n    };\n    const request = {\n      config: config,\n      auth: auth.master(config),\n      body: {\n        where: {\n          query: '{ \"test\": \"android\" }'\n        }\n      },\n      query: {},\n      info: {}\n    };\n    const router = new AudiencesRouter();\n    rest.create(config, auth.nobody(config), '_Audience', androidAudienceRequest).then(() => {\n      return rest.create(config, auth.nobody(config), '_Audience', iosAudienceRequest);\n    }).then(() => {\n      return router.handleFind(request);\n    }).then(res => {\n      const results = res.response.results;\n      expect(results.length).toEqual(1);\n      done();\n    }).catch(err => {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"AudienceRouter.spec.js","skipped":false,"dir":"spec"},{"name":"uses find condition from request.query","suites":["AudiencesRouter"],"line":42,"updatePoint":{"line":42,"column":44,"index":1324},"code":"  it('uses find condition from request.query', done => {\n    const config = Config.get('test');\n    const androidAudienceRequest = {\n      name: 'Android Users',\n      query: '{ \"test\": \"android\" }'\n    };\n    const iosAudienceRequest = {\n      name: 'Iphone Users',\n      query: '{ \"test\": \"ios\" }'\n    };\n    const request = {\n      config: config,\n      auth: auth.master(config),\n      body: {},\n      query: {\n        where: {\n          query: '{ \"test\": \"android\" }'\n        }\n      },\n      info: {}\n    };\n    const router = new AudiencesRouter();\n    rest.create(config, auth.nobody(config), '_Audience', androidAudienceRequest).then(() => {\n      return rest.create(config, auth.nobody(config), '_Audience', iosAudienceRequest);\n    }).then(() => {\n      return router.handleFind(request);\n    }).then(res => {\n      const results = res.response.results;\n      expect(results.length).toEqual(1);\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"AudienceRouter.spec.js","skipped":false,"dir":"spec"},{"name":"query installations with limit = 0","suites":["AudiencesRouter"],"line":77,"updatePoint":{"line":77,"column":40,"index":2307},"code":"  it('query installations with limit = 0', done => {\n    const config = Config.get('test');\n    const androidAudienceRequest = {\n      name: 'Android Users',\n      query: '{ \"test\": \"android\" }'\n    };\n    const iosAudienceRequest = {\n      name: 'Iphone Users',\n      query: '{ \"test\": \"ios\" }'\n    };\n    const request = {\n      config: config,\n      auth: auth.master(config),\n      body: {},\n      query: {\n        limit: 0\n      },\n      info: {}\n    };\n    Config.get('test');\n    const router = new AudiencesRouter();\n    rest.create(config, auth.nobody(config), '_Audience', androidAudienceRequest).then(() => {\n      return rest.create(config, auth.nobody(config), '_Audience', iosAudienceRequest);\n    }).then(() => {\n      return router.handleFind(request);\n    }).then(res => {\n      const response = res.response;\n      expect(response.results.length).toEqual(0);\n      done();\n    }).catch(err => {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"AudienceRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should create, read, update and delete audiences throw api","suites":["AudiencesRouter"],"line":176,"updatePoint":{"line":176,"column":64,"index":5331},"code":"  it('should create, read, update and delete audiences throw api', done => {\n    Parse._request('POST', 'push_audiences', {\n      name: 'My Audience',\n      query: JSON.stringify({\n        deviceType: 'ios'\n      })\n    }, {\n      useMasterKey: true\n    }).then(() => {\n      Parse._request('GET', 'push_audiences', {}, {\n        useMasterKey: true\n      }).then(results => {\n        expect(results.results.length).toEqual(1);\n        expect(results.results[0].name).toEqual('My Audience');\n        expect(results.results[0].query.deviceType).toEqual('ios');\n        Parse._request('GET', `push_audiences/${results.results[0].objectId}`, {}, {\n          useMasterKey: true\n        }).then(results => {\n          expect(results.name).toEqual('My Audience');\n          expect(results.query.deviceType).toEqual('ios');\n          Parse._request('PUT', `push_audiences/${results.objectId}`, {\n            name: 'My Audience 2'\n          }, {\n            useMasterKey: true\n          }).then(() => {\n            Parse._request('GET', `push_audiences/${results.objectId}`, {}, {\n              useMasterKey: true\n            }).then(results => {\n              expect(results.name).toEqual('My Audience 2');\n              expect(results.query.deviceType).toEqual('ios');\n              Parse._request('DELETE', `push_audiences/${results.objectId}`, {}, {\n                useMasterKey: true\n              }).then(() => {\n                Parse._request('GET', 'push_audiences', {}, {\n                  useMasterKey: true\n                }).then(results => {\n                  expect(results.results.length).toEqual(0);\n                  done();\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });","file":"AudienceRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should only create with master key","suites":["AudiencesRouter"],"line":222,"updatePoint":{"line":222,"column":40,"index":7044},"code":"  it('should only create with master key', done => {\n    Parse._request('POST', 'push_audiences', {\n      name: 'My Audience',\n      query: JSON.stringify({\n        deviceType: 'ios'\n      })\n    }).then(() => {}, error => {\n      expect(error.message).toEqual('unauthorized: master key is required');\n      done();\n    });\n  });","file":"AudienceRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should only find with master key","suites":["AudiencesRouter"],"line":233,"updatePoint":{"line":233,"column":38,"index":7372},"code":"  it('should only find with master key', done => {\n    Parse._request('GET', 'push_audiences', {}).then(() => {}, error => {\n      expect(error.message).toEqual('unauthorized: master key is required');\n      done();\n    });\n  });","file":"AudienceRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should only get with master key","suites":["AudiencesRouter"],"line":239,"updatePoint":{"line":239,"column":37,"index":7601},"code":"  it('should only get with master key', done => {\n    Parse._request('GET', `push_audiences/someId`, {}).then(() => {}, error => {\n      expect(error.message).toEqual('unauthorized: master key is required');\n      done();\n    });\n  });","file":"AudienceRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should only update with master key","suites":["AudiencesRouter"],"line":245,"updatePoint":{"line":245,"column":40,"index":7840},"code":"  it('should only update with master key', done => {\n    Parse._request('PUT', `push_audiences/someId`, {\n      name: 'My Audience 2'\n    }).then(() => {}, error => {\n      expect(error.message).toEqual('unauthorized: master key is required');\n      done();\n    });\n  });","file":"AudienceRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should only delete with master key","suites":["AudiencesRouter"],"line":253,"updatePoint":{"line":253,"column":40,"index":8112},"code":"  it('should only delete with master key', done => {\n    Parse._request('DELETE', `push_audiences/someId`, {}).then(() => {}, error => {\n      expect(error.message).toEqual('unauthorized: master key is required');\n      done();\n    });\n  });","file":"AudienceRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to search on audiences","suites":["AudiencesRouter"],"line":300,"updatePoint":{"line":300,"column":43,"index":9775},"code":"  it('should be able to search on audiences', done => {\n    Parse._request('POST', 'push_audiences', {\n      name: 'neverUsed',\n      query: JSON.stringify({\n        deviceType: 'ios'\n      })\n    }, {\n      useMasterKey: true\n    }).then(() => {\n      const query = {\n        timesUsed: {\n          $exists: false\n        },\n        lastUsed: {\n          $exists: false\n        }\n      };\n      Parse._request('GET', 'push_audiences?order=-createdAt&limit=1', {\n        where: query\n      }, {\n        useMasterKey: true\n      }).then(results => {\n        expect(results.results.length).toEqual(1);\n        const audience = results.results[0];\n        expect(audience.name).toEqual('neverUsed');\n        done();\n      }).catch(error => {\n        done.fail(error);\n      });\n    });\n  });","file":"AudienceRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should handle _Audience invalid fields via rest","suites":["AudiencesRouter"],"line":331,"updatePoint":{"line":331,"column":53,"index":10574},"code":"  it('should handle _Audience invalid fields via rest', async () => {\n    await reconfigureServer({\n      appId: 'test',\n      restAPIKey: 'test',\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    try {\n      await request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/_Audience',\n        body: {\n          lorem: 'ipsum',\n          _method: 'POST'\n        },\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'test',\n          'Content-Type': 'application/json'\n        }\n      });\n      expect(true).toBeFalsy();\n    } catch (e) {\n      expect(e.data.code).toBe(107);\n      expect(e.data.error).toBe('Could not add field lorem');\n    }\n  });","file":"AudienceRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should get user roles from the cache","suites":["Auth","getUserRoles"],"line":34,"updatePoint":{"line":34,"column":44,"index":842},"code":"    it('should get user roles from the cache', done => {\n      auth.getUserRoles().then(roles => {\n        const firstSet = config.cacheController.role.set.calls.first();\n        expect(firstSet).toEqual(undefined);\n        const firstGet = config.cacheController.role.get.calls.first();\n        expect(firstGet.args[0]).toEqual(currentUserId);\n        expect(roles).toEqual(currentRoles);\n        done();\n      });\n    });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should only query the roles once","suites":["Auth","getUserRoles"],"line":44,"updatePoint":{"line":44,"column":40,"index":1262},"code":"    it('should only query the roles once', done => {\n      const loadRolesSpy = spyOn(auth, '_loadRoles').and.callThrough();\n      auth.getUserRoles().then(roles => {\n        expect(roles).toEqual(currentRoles);\n        return auth.getUserRoles();\n      }).then(() => auth.getUserRoles()).then(() => auth.getUserRoles()).then(roles => {\n        // Should only call the cache adapter once.\n        expect(config.cacheController.role.get.calls.count()).toEqual(1);\n        expect(loadRolesSpy.calls.count()).toEqual(1);\n        const firstGet = config.cacheController.role.get.calls.first();\n        expect(firstGet.args[0]).toEqual(currentUserId);\n        expect(roles).toEqual(currentRoles);\n        done();\n      });\n    });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should not have any roles with no user","suites":["Auth","getUserRoles"],"line":59,"updatePoint":{"line":59,"column":46,"index":1994},"code":"    it('should not have any roles with no user', done => {\n      auth.user = null;\n      auth.getUserRoles().then(roles => expect(roles).toEqual([])).then(() => done());\n    });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should not have any user roles with master","suites":["Auth","getUserRoles"],"line":63,"updatePoint":{"line":63,"column":50,"index":2176},"code":"    it('should not have any user roles with master', done => {\n      auth.isMaster = true;\n      auth.getUserRoles().then(roles => expect(roles).toEqual([])).then(() => done());\n    });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should properly handle bcrypt upgrade","suites":["Auth","getUserRoles"],"line":67,"updatePoint":{"line":67,"column":45,"index":2357},"code":"    it('should properly handle bcrypt upgrade', done => {\n      const bcryptOriginal = require('bcrypt-nodejs');\n      const bcryptNew = require('bcryptjs');\n      bcryptOriginal.hash('my1Long:password', null, null, function (err, res) {\n        bcryptNew.compare('my1Long:password', res, function (err, res) {\n          expect(res).toBeTruthy();\n          done();\n        });\n      });\n    });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should load auth without a config","suites":["Auth","getUserRoles"],"line":78,"updatePoint":{"line":78,"column":39,"index":2752},"code":"  it('should load auth without a config', async () => {\n    const user = new Parse.User();\n    await user.signUp({\n      username: 'hello',\n      password: 'password'\n    });\n    expect(user.getSessionToken()).not.toBeUndefined();\n    const userAuth = await getAuthForSessionToken({\n      sessionToken: user.getSessionToken()\n    });\n    expect(userAuth.user instanceof Parse.User).toBe(true);\n    expect(userAuth.user.id).toBe(user.id);\n  });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should load auth with a config","suites":["Auth","getUserRoles"],"line":91,"updatePoint":{"line":91,"column":36,"index":3193},"code":"  it('should load auth with a config', async () => {\n    const user = new Parse.User();\n    await user.signUp({\n      username: 'hello',\n      password: 'password'\n    });\n    expect(user.getSessionToken()).not.toBeUndefined();\n    const userAuth = await getAuthForSessionToken({\n      sessionToken: user.getSessionToken(),\n      config: Config.get('test')\n    });\n    expect(userAuth.user instanceof Parse.User).toBe(true);\n    expect(userAuth.user.id).toBe(user.id);\n  });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should load auth without a config","suites":["Auth","getUserRoles"],"line":105,"updatePoint":{"line":105,"column":39,"index":3671},"code":"  it('should load auth without a config', async () => {\n    const user = new Parse.User();\n    await user.signUp({\n      username: 'hello',\n      password: 'password'\n    });\n    expect(user.getSessionToken()).not.toBeUndefined();\n    const userAuth = await getAuthForSessionToken({\n      sessionToken: user.getSessionToken()\n    });\n    expect(userAuth.user instanceof Parse.User).toBe(true);\n    expect(userAuth.user.id).toBe(user.id);\n  });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should load auth with a config","suites":["Auth","getUserRoles"],"line":118,"updatePoint":{"line":118,"column":36,"index":4112},"code":"  it('should load auth with a config', async () => {\n    const user = new Parse.User();\n    await user.signUp({\n      username: 'hello',\n      password: 'password'\n    });\n    expect(user.getSessionToken()).not.toBeUndefined();\n    const userAuth = await getAuthForSessionToken({\n      sessionToken: user.getSessionToken(),\n      config: Config.get('test')\n    });\n    expect(userAuth.user instanceof Parse.User).toBe(true);\n    expect(userAuth.user.id).toBe(user.id);\n  });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should load all roles without config","suites":["Auth","getRolesForUser"],"line":134,"updatePoint":{"line":134,"column":44,"index":4662},"code":"    it('should load all roles without config', async () => {\n      const user = new Parse.User();\n      await user.signUp({\n        username: 'hello',\n        password: 'password'\n      });\n      expect(user.getSessionToken()).not.toBeUndefined();\n      const userAuth = await getAuthForSessionToken({\n        sessionToken: user.getSessionToken()\n      });\n      const roles = [];\n      for (let i = 0; i < rolesNumber; i++) {\n        const acl = new Parse.ACL();\n        const role = new Parse.Role('roleloadtest' + i, acl);\n        role.getUsers().add([user]);\n        roles.push(role);\n      }\n      const savedRoles = await Parse.Object.saveAll(roles);\n      expect(savedRoles.length).toBe(rolesNumber);\n      const cloudRoles = await userAuth.getRolesForUser();\n      expect(cloudRoles.length).toBe(rolesNumber);\n    });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should load all roles with config","suites":["Auth","getRolesForUser"],"line":156,"updatePoint":{"line":156,"column":41,"index":5485},"code":"    it('should load all roles with config', async () => {\n      const user = new Parse.User();\n      await user.signUp({\n        username: 'hello',\n        password: 'password'\n      });\n      expect(user.getSessionToken()).not.toBeUndefined();\n      const userAuth = await getAuthForSessionToken({\n        sessionToken: user.getSessionToken(),\n        config: Config.get('test')\n      });\n      const roles = [];\n      for (let i = 0; i < rolesNumber; i++) {\n        const acl = new Parse.ACL();\n        const role = new Parse.Role('roleloadtest' + i, acl);\n        role.getUsers().add([user]);\n        roles.push(role);\n      }\n      const savedRoles = await Parse.Object.saveAll(roles);\n      expect(savedRoles.length).toBe(rolesNumber);\n      const cloudRoles = await userAuth.getRolesForUser();\n      expect(cloudRoles.length).toBe(rolesNumber);\n    });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should load all roles for different users with config","suites":["Auth","getRolesForUser"],"line":179,"updatePoint":{"line":179,"column":61,"index":6364},"code":"    it('should load all roles for different users with config', async () => {\n      const user = new Parse.User();\n      await user.signUp({\n        username: 'hello',\n        password: 'password'\n      });\n      const user2 = new Parse.User();\n      await user2.signUp({\n        username: 'world',\n        password: '1234'\n      });\n      expect(user.getSessionToken()).not.toBeUndefined();\n      const userAuth = await getAuthForSessionToken({\n        sessionToken: user.getSessionToken(),\n        config: Config.get('test')\n      });\n      const user2Auth = await getAuthForSessionToken({\n        sessionToken: user2.getSessionToken(),\n        config: Config.get('test')\n      });\n      const roles = [];\n      for (let i = 0; i < rolesNumber; i += 1) {\n        const acl = new Parse.ACL();\n        const acl2 = new Parse.ACL();\n        const role = new Parse.Role('roleloadtest' + i, acl);\n        const role2 = new Parse.Role('role2loadtest' + i, acl2);\n        role.getUsers().add([user]);\n        role2.getUsers().add([user2]);\n        roles.push(role);\n        roles.push(role2);\n      }\n      const savedRoles = await Parse.Object.saveAll(roles);\n      expect(savedRoles.length).toBe(rolesNumber * 2);\n      const cloudRoles = await userAuth.getRolesForUser();\n      const cloudRoles2 = await user2Auth.getRolesForUser();\n      expect(cloudRoles.length).toBe(rolesNumber);\n      expect(cloudRoles2.length).toBe(rolesNumber);\n    });","file":"Auth.spec.js","skipped":false,"dir":"spec"},{"name":"should provide the right responses for adapter ","suites":["AuthenticationProviders"],"line":64,"updatePoint":{"line":64,"column":70,"index":1991},"code":"    it(`should provide the right responses for adapter ${providerName}`, async () => {\n      const noResponse = ['twitter', 'apple', 'gcenter', 'google', 'keycloak'];\n      if (noResponse.includes(providerName)) {\n        return;\n      }\n      spyOn(require('../lib/Adapters/Auth/httpsRequest'), 'get').and.callFake(options => {\n        if (options === 'https://oauth.vk.com/access_token?client_id=appId&client_secret=appSecret&v=5.123&grant_type=client_credentials' || options === 'https://oauth.vk.com/access_token?client_id=appId&client_secret=appSecret&v=5.124&grant_type=client_credentials') {\n          return {\n            access_token: 'access_token'\n          };\n        }\n        return Promise.resolve(responses[providerName] || {\n          id: 'userId'\n        });\n      });\n      spyOn(require('../lib/Adapters/Auth/httpsRequest'), 'request').and.callFake(() => {\n        return Promise.resolve(responses[providerName] || {\n          id: 'userId'\n        });\n      });\n      const provider = require('../lib/Adapters/Auth/' + providerName);\n      let params = {};\n      if (providerName === 'vkontakte') {\n        params = {\n          appIds: 'appId',\n          appSecret: 'appSecret'\n        };\n        await provider.validateAuthData({\n          id: 'userId'\n        }, params);\n        params.appVersion = '5.123';\n      }\n      await provider.validateAuthData({\n        id: 'userId'\n      }, params);\n    });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should create user with REST API","suites":["AuthenticationProviders"],"line":184,"updatePoint":{"line":184,"column":38,"index":5693},"code":"  it('should create user with REST API', done => {\n    createOAuthUser((error, response, body) => {\n      expect(error).toBe(null);\n      const b = body;\n      ok(b.sessionToken);\n      expect(b.objectId).not.toBeNull();\n      expect(b.objectId).not.toBeUndefined();\n      const sessionToken = b.sessionToken;\n      const q = new Parse.Query('_Session');\n      q.equalTo('sessionToken', sessionToken);\n      q.first({\n        useMasterKey: true\n      }).then(res => {\n        if (!res) {\n          fail('should not fail fetching the session');\n          done();\n          return;\n        }\n        expect(res.get('installationId')).toEqual('yolo');\n        done();\n      }).catch(() => {\n        fail('should not fail fetching the session');\n        done();\n      });\n    });\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should only create a single user with REST API","suites":["AuthenticationProviders"],"line":210,"updatePoint":{"line":210,"column":52,"index":6489},"code":"  it('should only create a single user with REST API', done => {\n    let objectId;\n    createOAuthUser((error, response, body) => {\n      expect(error).toBe(null);\n      const b = body;\n      expect(b.objectId).not.toBeNull();\n      expect(b.objectId).not.toBeUndefined();\n      objectId = b.objectId;\n      createOAuthUser((error, response, body) => {\n        expect(error).toBe(null);\n        const b = body;\n        expect(b.objectId).not.toBeNull();\n        expect(b.objectId).not.toBeUndefined();\n        expect(b.objectId).toBe(objectId);\n        done();\n      });\n    });\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should fail to link if session token don't match user","suites":["AuthenticationProviders"],"line":228,"updatePoint":{"line":228,"column":59,"index":7081},"code":"  it(\"should fail to link if session token don't match user\", done => {\n    Parse.User.signUp('myUser', 'password').then(user => {\n      return createOAuthUserWithSessionToken(user.getSessionToken());\n    }).then(() => {\n      return Parse.User.logOut();\n    }).then(() => {\n      return Parse.User.signUp('myUser2', 'password');\n    }).then(user => {\n      return createOAuthUserWithSessionToken(user.getSessionToken());\n    }).then(fail, ({\n      data\n    }) => {\n      expect(data.code).toBe(208);\n      expect(data.error).toBe('this auth is already used');\n      done();\n    }).catch(done.fail);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"unlink and link with custom provider","suites":["AuthenticationProviders"],"line":245,"updatePoint":{"line":245,"column":42,"index":7670},"code":"  it('unlink and link with custom provider', async () => {\n    const provider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('myoauth');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n    await model._unlinkFrom('myoauth');\n    ok(!model._isLinked('myoauth'), 'User should not be linked to myoauth');\n    ok(!provider.synchronizedUserId, 'User id should be cleared');\n    ok(!provider.synchronizedAuthToken, 'Auth token should be cleared');\n    ok(!provider.synchronizedExpiration, 'Expiration should be cleared');\n    // make sure the auth data is properly deleted\n    const config = Config.get(Parse.applicationId);\n    const res = await config.database.adapter.find('_User', {\n      fields: Object.assign({}, defaultColumns._Default, defaultColumns._Installation)\n    }, {\n      objectId: model.id\n    }, {});\n    expect(res.length).toBe(1);\n    expect(res[0]._auth_data_myoauth).toBeUndefined();\n    expect(res[0]._auth_data_myoauth).not.toBeNull();\n    await model._linkWith('myoauth');\n    ok(provider.synchronizedUserId, 'User id should have a value');\n    ok(provider.synchronizedAuthToken, 'Auth token should have a value');\n    ok(provider.synchronizedExpiration, 'Expiration should have a value');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"properly loads custom adapter","suites":["AuthenticationProviders"],"line":293,"updatePoint":{"line":293,"column":35,"index":10131},"code":"  it('properly loads custom adapter', done => {\n    const validAuthData = {\n      id: 'hello',\n      token: 'world'\n    };\n    const adapter = {\n      validateAppId: function () {\n        return Promise.resolve();\n      },\n      validateAuthData: function (authData) {\n        if (authData.id == validAuthData.id && authData.token == validAuthData.token) {\n          return Promise.resolve();\n        }\n        return Promise.reject();\n      }\n    };\n    const authDataSpy = spyOn(adapter, 'validateAuthData').and.callThrough();\n    const appIdSpy = spyOn(adapter, 'validateAppId').and.callThrough();\n    const authenticationHandler = authenticationLoader({\n      customAuthentication: adapter\n    });\n    validateAuthenticationHandler(authenticationHandler);\n    const validator = authenticationHandler.getValidatorForProvider('customAuthentication');\n    validateValidator(validator);\n    validator(validAuthData).then(() => {\n      expect(authDataSpy).toHaveBeenCalled();\n      // AppIds are not provided in the adapter, should not be called\n      expect(appIdSpy).not.toHaveBeenCalled();\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"properly loads custom adapter module object","suites":["AuthenticationProviders"],"line":327,"updatePoint":{"line":327,"column":49,"index":11313},"code":"  it('properly loads custom adapter module object', done => {\n    const authenticationHandler = authenticationLoader({\n      customAuthentication: path.resolve('./spec/support/CustomAuth.js')\n    });\n    validateAuthenticationHandler(authenticationHandler);\n    const validator = authenticationHandler.getValidatorForProvider('customAuthentication');\n    validateValidator(validator);\n    validator({\n      token: 'my-token'\n    }).then(() => {\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"properly loads custom adapter module object (again)","suites":["AuthenticationProviders"],"line":343,"updatePoint":{"line":343,"column":57,"index":11842},"code":"  it('properly loads custom adapter module object (again)', done => {\n    const authenticationHandler = authenticationLoader({\n      customAuthentication: {\n        module: path.resolve('./spec/support/CustomAuthFunction.js'),\n        options: {\n          token: 'valid-token'\n        }\n      }\n    });\n    validateAuthenticationHandler(authenticationHandler);\n    const validator = authenticationHandler.getValidatorForProvider('customAuthentication');\n    validateValidator(validator);\n    validator({\n      token: 'valid-token'\n    }).then(() => {\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"properly loads a default adapter with options","suites":["AuthenticationProviders"],"line":364,"updatePoint":{"line":364,"column":51,"index":12463},"code":"  it('properly loads a default adapter with options', () => {\n    const options = {\n      facebook: {\n        appIds: ['a', 'b'],\n        appSecret: 'secret'\n      }\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('facebook', options);\n    validateAuthenticationAdapter(adapter);\n    expect(appIds).toEqual(['a', 'b']);\n    expect(providerOptions).toEqual(options.facebook);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error when Facebook request appId is wrong data type","suites":["AuthenticationProviders"],"line":380,"updatePoint":{"line":380,"column":71,"index":12931},"code":"  it('should throw error when Facebook request appId is wrong data type', async () => {\n    const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        id: 'a'\n      });\n    });\n    const options = {\n      facebook: {\n        appIds: 'abcd',\n        appSecret: 'secret_sauce'\n      }\n    };\n    const authData = {\n      access_token: 'badtoken'\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('facebook', options);\n    await expectAsync(adapter.validateAppId(appIds, authData, providerOptions)).toBeRejectedWith(new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'appIds must be an array.'));\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should handle Facebook appSecret for validating appIds","suites":["AuthenticationProviders"],"line":403,"updatePoint":{"line":403,"column":60,"index":13679},"code":"  it('should handle Facebook appSecret for validating appIds', async () => {\n    const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        id: 'a'\n      });\n    });\n    const options = {\n      facebook: {\n        appIds: ['a', 'b'],\n        appSecret: 'secret_sauce'\n      }\n    };\n    const authData = {\n      access_token: 'badtoken'\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('facebook', options);\n    await adapter.validateAppId(appIds, authData, providerOptions);\n    expect(httpsRequest.get.calls.first().args[0].includes('appsecret_proof')).toBe(true);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should handle Facebook appSecret for validating auth data","suites":["AuthenticationProviders"],"line":427,"updatePoint":{"line":427,"column":63,"index":14420},"code":"  it('should handle Facebook appSecret for validating auth data', async () => {\n    const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve();\n    });\n    const options = {\n      facebook: {\n        appIds: ['a', 'b'],\n        appSecret: 'secret_sauce'\n      }\n    };\n    const authData = {\n      id: 'test',\n      access_token: 'test'\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('facebook', options);\n    await adapter.validateAuthData(authData, providerOptions);\n    expect(httpsRequest.get.calls.first().args[0].includes('appsecret_proof')).toBe(true);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"properly loads a custom adapter with options","suites":["AuthenticationProviders"],"line":449,"updatePoint":{"line":449,"column":50,"index":15118},"code":"  it('properly loads a custom adapter with options', () => {\n    const options = {\n      custom: {\n        validateAppId: () => {},\n        validateAuthData: () => {},\n        appIds: ['a', 'b']\n      }\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('custom', options);\n    validateAuthenticationAdapter(adapter);\n    expect(appIds).toEqual(['a', 'b']);\n    expect(providerOptions).toEqual(options.custom);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"can disable provider","suites":["AuthenticationProviders"],"line":466,"updatePoint":{"line":466,"column":26,"index":15575},"code":"  it('can disable provider', async () => {\n    await reconfigureServer({\n      auth: {\n        myoauth: {\n          enabled: false,\n          module: path.resolve(__dirname, 'support/myoauth') // relative path as it's run from src\n        }\n      }\n    });\n\n    const provider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await expectAsync(Parse.User._logInWith('myoauth')).toBeRejectedWith(new Parse.Error(Parse.Error.UNSUPPORTED_SERVICE, 'This authentication method is unsupported.'));\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"can depreciate","suites":["AuthenticationProviders"],"line":480,"updatePoint":{"line":480,"column":20,"index":16108},"code":"  it('can depreciate', async () => {\n    const Deprecator = require('../lib/Deprecator/Deprecator');\n    const spy = spyOn(Deprecator, 'logRuntimeDeprecation').and.callFake(() => {});\n    const provider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('myoauth');\n    expect(spy).toHaveBeenCalledWith({\n      usage: 'auth.myoauth',\n      solution: 'auth.myoauth.enabled: true'\n    });\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should use default api","suites":["instagram auth adapter"],"line":495,"updatePoint":{"line":495,"column":28,"index":16755},"code":"  it('should use default api', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        data: {\n          id: 'userId'\n        }\n      });\n    });\n    await instagram.validateAuthData({\n      id: 'userId',\n      access_token: 'the_token'\n    }, {});\n    expect(httpsRequest.get).toHaveBeenCalledWith('https://graph.instagram.com/me?fields=id&access_token=the_token');\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"response object without data child","suites":["instagram auth adapter"],"line":509,"updatePoint":{"line":509,"column":40,"index":17189},"code":"  it('response object without data child', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        id: 'userId'\n      });\n    });\n    await instagram.validateAuthData({\n      id: 'userId',\n      access_token: 'the_token'\n    }, {});\n    expect(httpsRequest.get).toHaveBeenCalledWith('https://graph.instagram.com/me?fields=id&access_token=the_token');\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should pass in api url","suites":["instagram auth adapter"],"line":521,"updatePoint":{"line":521,"column":28,"index":17583},"code":"  it('should pass in api url', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        data: {\n          id: 'userId'\n        }\n      });\n    });\n    await instagram.validateAuthData({\n      id: 'userId',\n      access_token: 'the_token',\n      apiURL: 'https://new-api.instagram.com/v1/'\n    }, {});\n    expect(httpsRequest.get).toHaveBeenCalledWith('https://new-api.instagram.com/v1/me?fields=id&access_token=the_token');\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error with missing id_token","suites":["google auth adapter"],"line":540,"updatePoint":{"line":540,"column":46,"index":18219},"code":"  it('should throw error with missing id_token', async () => {\n    try {\n      await google.validateAuthData({}, {});\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token is invalid for this user.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should not decode invalid id_token","suites":["google auth adapter"],"line":548,"updatePoint":{"line":548,"column":40,"index":18443},"code":"  it('should not decode invalid id_token', async () => {\n    try {\n      await google.validateAuthData({\n        id: 'the_user_id',\n        id_token: 'the_token'\n      }, {});\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as string) should verify id_token","suites":["google auth adapter"],"line":574,"updatePoint":{"line":574,"column":56,"index":19279},"code":"  it('(using client id as string) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://accounts.google.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const result = await google.validateAuthData({\n      id: 'the_user_id',\n      id_token: 'the_token'\n    }, {\n      clientId: 'secret'\n    });\n    expect(result).toEqual(fakeClaim);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as string) should throw error with with invalid jwt issuer","suites":["google auth adapter"],"line":597,"updatePoint":{"line":597,"column":81,"index":19932},"code":"  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.google.com',\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    try {\n      await google.validateAuthData({\n        id: 'the_user_id',\n        id_token: 'the_token'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token not issued by correct provider - expected: accounts.google.com or https://accounts.google.com | from: https://not.google.com');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as string) should throw error with invalid jwt client_id","suites":["google auth adapter"],"line":622,"updatePoint":{"line":622,"column":80,"index":20708},"skipped":true,"code":"  xit('(using client id as string) should throw error with invalid jwt client_id', async () => {\n    const fakeClaim = {\n      iss: 'https://accounts.google.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    try {\n      await google.validateAuthData({\n        id: 'INSERT ID HERE',\n        token: 'INSERT APPLE TOKEN HERE'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"should throw error with invalid user id","suites":["google auth adapter"],"line":649,"updatePoint":{"line":649,"column":46,"index":21418},"skipped":true,"code":"  xit('should throw error with invalid user id', async () => {\n    const fakeClaim = {\n      iss: 'https://accounts.google.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    try {\n      await google.validateAuthData({\n        id: 'invalid user',\n        token: 'INSERT APPLE TOKEN HERE'\n      }, {\n        clientId: 'INSERT CLIENT ID HERE'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"validateAuthData should pass validation","suites":["google play games service auth"],"line":680,"updatePoint":{"line":680,"column":45,"index":22320},"code":"  it('validateAuthData should pass validation', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        playerId: 'userId'\n      });\n    });\n    await gpgames.validateAuthData({\n      id: 'userId',\n      access_token: 'access_token'\n    });\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should throw error","suites":["google play games service auth"],"line":691,"updatePoint":{"line":691,"column":41,"index":22612},"code":"  it('validateAuthData should throw error', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        playerId: 'invalid'\n      });\n    });\n    try {\n      await gpgames.validateAuthData({\n        id: 'userId',\n        access_token: 'access_token'\n      });\n    } catch (e) {\n      expect(e.message).toBe('Google Play Games Services - authData is invalid for this user.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should fail without access token","suites":["keycloak auth adapter"],"line":710,"updatePoint":{"line":710,"column":55,"index":23234},"code":"  it('validateAuthData should fail without access token', async () => {\n    const authData = {\n      id: 'fakeid'\n    };\n    try {\n      await keycloak.validateAuthData(authData);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Missing access token and/or User id');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should fail without user id","suites":["keycloak auth adapter"],"line":721,"updatePoint":{"line":721,"column":50,"index":23522},"code":"  it('validateAuthData should fail without user id', async () => {\n    const authData = {\n      access_token: 'sometoken'\n    };\n    try {\n      await keycloak.validateAuthData(authData);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Missing access token and/or User id');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should fail without config","suites":["keycloak auth adapter"],"line":732,"updatePoint":{"line":732,"column":49,"index":23822},"code":"  it('validateAuthData should fail without config', async () => {\n    const options = {\n      keycloak: {\n        config: null\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Missing keycloak configuration');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should fail connect error","suites":["keycloak auth adapter"],"line":753,"updatePoint":{"line":753,"column":48,"index":24344},"code":"  it('validateAuthData should fail connect error', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.reject({\n        text: JSON.stringify({\n          error: 'hosting_error'\n        })\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new'\n        }\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Could not connect to the authentication server');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should fail with error description","suites":["keycloak auth adapter"],"line":784,"updatePoint":{"line":784,"column":57,"index":25147},"code":"  it('validateAuthData should fail with error description', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.reject({\n        text: JSON.stringify({\n          error_description: 'custom error message'\n        })\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new'\n        }\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('custom error message');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should fail with invalid auth","suites":["keycloak auth adapter"],"line":815,"updatePoint":{"line":815,"column":52,"index":25938},"code":"  it('validateAuthData should fail with invalid auth', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({});\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new'\n        }\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Invalid authentication');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should fail with invalid groups","suites":["keycloak auth adapter"],"line":842,"updatePoint":{"line":842,"column":54,"index":26633},"code":"  it('validateAuthData should fail with invalid groups', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        data: {\n          sub: 'fakeid',\n          roles: ['role1'],\n          groups: ['unknown']\n        }\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new'\n        }\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n      roles: ['role1'],\n      groups: ['group1']\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Invalid authentication');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should fail with invalid roles","suites":["keycloak auth adapter"],"line":877,"updatePoint":{"line":877,"column":53,"index":27493},"code":"  it('validateAuthData should fail with invalid roles', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        data: {\n          sub: 'fakeid',\n          roles: 'unknown',\n          groups: ['group1']\n        }\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new'\n        }\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n      roles: ['role1'],\n      groups: ['group1']\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Invalid authentication');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should handle authentication","suites":["keycloak auth adapter"],"line":912,"updatePoint":{"line":912,"column":51,"index":28350},"code":"  it('validateAuthData should handle authentication', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        data: {\n          sub: 'fakeid',\n          roles: ['role1'],\n          groups: ['group1']\n        }\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new'\n        }\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n      roles: ['role1'],\n      groups: ['group1']\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    await adapter.validateAuthData(authData, providerOptions);\n    expect(httpsRequest.get).toHaveBeenCalledWith({\n      host: 'http://example.com',\n      path: '/realms/new/protocol/openid-connect/userinfo',\n      headers: {\n        Authorization: 'Bearer sometoken'\n      }\n    });\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"properly loads OAuth2 adapter via the \"oauth2\" option","suites":["oauth2 auth adapter"],"line":953,"updatePoint":{"line":953,"column":59,"index":29500},"code":"  it('properly loads OAuth2 adapter via the \"oauth2\" option', () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true\n      }\n    };\n    const loadedAuthAdapter = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    expect(loadedAuthAdapter.adapter).toEqual(oauth2);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"properly loads OAuth2 adapter with options","suites":["oauth2 auth adapter"],"line":962,"updatePoint":{"line":962,"column":48,"index":29809},"code":"  it('properly loads OAuth2 adapter with options', () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        useridField: 'sub',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n        authorizationHeader: 'Basic dXNlcm5hbWU6cGFzc3dvcmQ=',\n        debug: true\n      }\n    };\n    const loadedAuthAdapter = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    const appIds = loadedAuthAdapter.appIds;\n    const providerOptions = loadedAuthAdapter.providerOptions;\n    expect(providerOptions.tokenIntrospectionEndpointUrl).toEqual('https://example.com/introspect');\n    expect(providerOptions.useridField).toEqual('sub');\n    expect(providerOptions.appidField).toEqual('appId');\n    expect(appIds).toEqual(['a', 'b']);\n    expect(providerOptions.authorizationHeader).toEqual('Basic dXNlcm5hbWU6cGFzc3dvcmQ=');\n    expect(providerOptions.debug).toEqual(true);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAppId should fail if OAuth2 tokenIntrospectionEndpointUrl is not configured properly","suites":["oauth2 auth adapter"],"line":984,"updatePoint":{"line":984,"column":98,"index":30857},"code":"  it('validateAppId should fail if OAuth2 tokenIntrospectionEndpointUrl is not configured properly', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        appIds: ['a', 'b'],\n        appidField: 'appId'\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe('OAuth2 token introspection endpoint URL is missing from configuration!');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAppId appidField optional","suites":["oauth2 auth adapter"],"line":1007,"updatePoint":{"line":1007,"column":39,"index":31496},"code":"  it('validateAppId appidField optional', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect'\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      // Should not reach here\n      fail(e);\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAppId should fail without appIds","suites":["oauth2 auth adapter"],"line":1030,"updatePoint":{"line":1030,"column":46,"index":32100},"code":"  it('validateAppId should fail without appIds', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId'\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe('OAuth2 configuration is missing the client app IDs (\"appIds\" config parameter).');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAppId should fail empty appIds","suites":["oauth2 auth adapter"],"line":1053,"updatePoint":{"line":1053,"column":44,"index":32798},"code":"  it('validateAppId should fail empty appIds', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: []\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe('OAuth2 configuration is missing the client app IDs (\"appIds\" config parameter).');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAppId invalid accessToken","suites":["oauth2 auth adapter"],"line":1077,"updatePoint":{"line":1077,"column":39,"index":33511},"code":"  it('validateAppId invalid accessToken', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b']\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({});\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe('OAuth2 access token is invalid for this user.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAppId invalid accessToken appId","suites":["oauth2 auth adapter"],"line":1104,"updatePoint":{"line":1104,"column":45,"index":34302},"code":"  it('validateAppId invalid accessToken appId', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b']\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true\n      });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\"OAuth2: the access_token's appID is empty or is not in the list of permitted appIDs in the auth configuration.\");\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAppId valid accessToken appId","suites":["oauth2 auth adapter"],"line":1133,"updatePoint":{"line":1133,"column":43,"index":35184},"code":"  it('validateAppId valid accessToken appId', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b']\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        appId: 'a'\n      });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAppId valid accessToken appId array","suites":["oauth2 auth adapter"],"line":1164,"updatePoint":{"line":1164,"column":49,"index":35994},"code":"  it('validateAppId valid accessToken appId array', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b']\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        appId: ['a']\n      });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAppId valid accessToken invalid appId","suites":["oauth2 auth adapter"],"line":1195,"updatePoint":{"line":1195,"column":51,"index":36808},"code":"  it('validateAppId valid accessToken invalid appId', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b']\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        appId: 'unknown'\n      });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\"OAuth2: the access_token's appID is empty or is not in the list of permitted appIDs in the auth configuration.\");\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should fail if OAuth2 tokenIntrospectionEndpointUrl is not configured properly","suites":["oauth2 auth adapter"],"line":1225,"updatePoint":{"line":1225,"column":101,"index":37774},"code":"  it('validateAuthData should fail if OAuth2 tokenIntrospectionEndpointUrl is not configured properly', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe('OAuth2 token introspection endpoint URL is missing from configuration!');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData invalid accessToken","suites":["oauth2 auth adapter"],"line":1245,"updatePoint":{"line":1245,"column":42,"index":38340},"code":"  it('validateAuthData invalid accessToken', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        useridField: 'sub',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n        authorizationHeader: 'Basic dXNlcm5hbWU6cGFzc3dvcmQ='\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({});\n    });\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe('OAuth2 access token is invalid for this user.');\n    }\n    expect(httpsRequest.request).toHaveBeenCalledWith({\n      hostname: 'example.com',\n      path: '/introspect',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': 15,\n        Authorization: 'Basic dXNlcm5hbWU6cGFzc3dvcmQ='\n      }\n    }, 'token=sometoken');\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData valid accessToken","suites":["oauth2 auth adapter"],"line":1283,"updatePoint":{"line":1283,"column":40,"index":39533},"code":"  it('validateAuthData valid accessToken', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        useridField: 'sub',\n        appidField: 'appId',\n        appIds: ['a', 'b']\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        sub: 'fakeid'\n      });\n    });\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n    expect(httpsRequest.request).toHaveBeenCalledWith({\n      hostname: 'example.com',\n      path: '/introspect',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': 15\n      }\n    }, 'token=sometoken');\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData valid accessToken without useridField","suites":["oauth2 auth adapter"],"line":1323,"updatePoint":{"line":1323,"column":60,"index":40644},"code":"  it('validateAuthData valid accessToken without useridField', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b']\n      }\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        sub: 'fakeid'\n      });\n    });\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as string) should throw error with missing id_token","suites":["apple signin auth adapter"],"line":1358,"updatePoint":{"line":1358,"column":74,"index":41639},"code":"  it('(using client id as string) should throw error with missing id_token', async () => {\n    try {\n      await apple.validateAuthData({}, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token is invalid for this user.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as array) should throw error with missing id_token","suites":["apple signin auth adapter"],"line":1368,"updatePoint":{"line":1368,"column":73,"index":41929},"code":"  it('(using client id as array) should throw error with missing id_token', async () => {\n    try {\n      await apple.validateAuthData({}, {\n        clientId: ['secret']\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token is invalid for this user.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should not decode invalid id_token","suites":["apple signin auth adapter"],"line":1378,"updatePoint":{"line":1378,"column":40,"index":42188},"code":"  it('should not decode invalid id_token', async () => {\n    try {\n      await apple.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error if public key used to encode token is not available","suites":["apple signin auth adapter"],"line":1391,"updatePoint":{"line":1391,"column":76,"index":42545},"code":"  it('should throw error if public key used to encode token is not available', async () => {\n    const fakeDecodedToken = {\n      header: {\n        kid: '789',\n        alg: 'RS256'\n      }\n    };\n    try {\n      spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n      await apple.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(`Unable to find matching key for Key ID: ${fakeDecodedToken.header.kid}`);\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should use algorithm from key header to verify id_token","suites":["apple signin auth adapter"],"line":1411,"updatePoint":{"line":1411,"column":61,"index":43088},"code":"  it('should use algorithm from key header to verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    const result = await apple.validateAuthData({\n      id: 'the_user_id',\n      token: 'the_token'\n    }, {\n      clientId: 'secret'\n    });\n    expect(result).toEqual(fakeClaim);\n    expect(jwt.verify.calls.first().args[2].algorithms).toEqual(fakeDecodedToken.header.alg);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should not verify invalid id_token","suites":["apple signin auth adapter"],"line":1442,"updatePoint":{"line":1442,"column":40,"index":44014},"code":"  it('should not verify invalid id_token', async () => {\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    try {\n      await apple.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt malformed');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as array) should not verify invalid id_token","suites":["apple signin auth adapter"],"line":1469,"updatePoint":{"line":1469,"column":67,"index":44730},"code":"  it('(using client id as array) should not verify invalid id_token', async () => {\n    try {\n      await apple.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: ['secret']\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as string) should verify id_token","suites":["apple signin auth adapter"],"line":1482,"updatePoint":{"line":1482,"column":56,"index":45069},"code":"  it('(using client id as string) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const result = await apple.validateAuthData({\n      id: 'the_user_id',\n      token: 'the_token'\n    }, {\n      clientId: 'secret'\n    });\n    expect(result).toEqual(fakeClaim);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as array) should verify id_token","suites":["apple signin auth adapter"],"line":1512,"updatePoint":{"line":1512,"column":55,"index":45916},"code":"  it('(using client id as array) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const result = await apple.validateAuthData({\n      id: 'the_user_id',\n      token: 'the_token'\n    }, {\n      clientId: ['secret']\n    });\n    expect(result).toEqual(fakeClaim);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as array with multiple items) should verify id_token","suites":["apple signin auth adapter"],"line":1542,"updatePoint":{"line":1542,"column":75,"index":46785},"code":"  it('(using client id as array with multiple items) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const result = await apple.validateAuthData({\n      id: 'the_user_id',\n      token: 'the_token'\n    }, {\n      clientId: ['secret', 'secret 123']\n    });\n    expect(result).toEqual(fakeClaim);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as string) should throw error with with invalid jwt issuer","suites":["apple signin auth adapter"],"line":1572,"updatePoint":{"line":1572,"column":81,"index":47674},"code":"  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.apple.com',\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    try {\n      await apple.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token not issued by correct OpenID provider - expected: https://appleid.apple.com | from: https://not.apple.com');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as array) should throw error with with invalid jwt issuer","suites":["apple signin auth adapter"],"line":1607,"updatePoint":{"line":1607,"column":81,"index":48781},"skipped":true,"code":"  xit('(using client id as array) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.apple.com',\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    try {\n      await apple.validateAuthData({\n        id: 'INSERT ID HERE',\n        token: 'INSERT APPLE TOKEN HERE WITH INVALID JWT ISSUER'\n      }, {\n        clientId: ['INSERT CLIENT ID HERE']\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token not issued by correct OpenID provider - expected: https://appleid.apple.com | from: https://not.apple.com');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"(using client id as string) should throw error with with invalid jwt issuer","suites":["apple signin auth adapter"],"line":1639,"updatePoint":{"line":1639,"column":81,"index":49818},"code":"  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.apple.com',\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    try {\n      await apple.validateAuthData({\n        id: 'INSERT ID HERE',\n        token: 'INSERT APPLE TOKEN HERE WITH INVALID JWT ISSUER'\n      }, {\n        clientId: 'INSERT CLIENT ID HERE'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token not issued by correct OpenID provider - expected: https://appleid.apple.com | from: https://not.apple.com');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as string) should throw error with invalid jwt clientId","suites":["apple signin auth adapter"],"line":1674,"updatePoint":{"line":1674,"column":79,"index":50979},"skipped":true,"code":"  xit('(using client id as string) should throw error with invalid jwt clientId', async () => {\n    try {\n      await apple.validateAuthData({\n        id: 'INSERT ID HERE',\n        token: 'INSERT APPLE TOKEN HERE'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"(using client id as array) should throw error with invalid jwt clientId","suites":["apple signin auth adapter"],"line":1690,"updatePoint":{"line":1690,"column":78,"index":51484},"skipped":true,"code":"  xit('(using client id as array) should throw error with invalid jwt clientId', async () => {\n    try {\n      await apple.validateAuthData({\n        id: 'INSERT ID HERE',\n        token: 'INSERT APPLE TOKEN HERE'\n      }, {\n        clientId: ['secret']\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"should throw error with invalid user id","suites":["apple signin auth adapter"],"line":1706,"updatePoint":{"line":1706,"column":46,"index":51959},"skipped":true,"code":"  xit('should throw error with invalid user id', async () => {\n    try {\n      await apple.validateAuthData({\n        id: 'invalid user',\n        token: 'INSERT APPLE TOKEN HERE'\n      }, {\n        clientId: 'INSERT CLIENT ID HERE'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"should throw error with with invalid user id","suites":["apple signin auth adapter"],"line":1719,"updatePoint":{"line":1719,"column":50,"index":52318},"code":"  it('should throw error with with invalid user id', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'invalid_client_id',\n      sub: 'a_different_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    try {\n      await apple.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"can load adapter","suites":["Apple Game Center Auth adapter"],"line":1758,"updatePoint":{"line":1758,"column":22,"index":53508},"code":"  it('can load adapter', async () => {\n    const options = {\n      gcenter: {\n        rootCertificateUrl: 'https://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt.pem'\n      }\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('gcenter', options);\n    await adapter.validateAppId(appIds, {\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer'\n    }, providerOptions);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should validate","suites":["Apple Game Center Auth adapter"],"line":1773,"updatePoint":{"line":1773,"column":38,"index":54010},"code":"  it('validateAuthData should validate', async () => {\n    const options = {\n      gcenter: {\n        rootCertificateUrl: 'https://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt.pem'\n      }\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('gcenter', options);\n    await adapter.validateAppId(appIds, {\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer'\n    }, providerOptions);\n    // real token is used\n    const authData = {\n      id: 'G:1965586982',\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer',\n      timestamp: 1565257031287,\n      signature: 'uqLBTr9Uex8zCpc1UQ1MIDMitb+HUat2Mah4Kw6AVLSGe0gGNJXlih2i5X+0ZwVY0S9zY2NHWi2gFjmhjt/4kxWGMkupqXX5H/qhE2m7hzox6lZJpH98ZEUbouWRfZX2ZhUlCkAX09oRNi7fI7mWL1/o88MaI/y6k6tLr14JTzmlxgdyhw+QRLxRPA6NuvUlRSJpyJ4aGtNH5/wHdKQWL8nUnFYiYmaY8R7IjzNxPfy8UJTUWmeZvMSgND4u8EjADPsz7ZtZyWAPi8kYcAb6M8k0jwLD3vrYCB8XXyO2RQb/FY2TM4zJuI7PzLlvvgOJXbbfVtHx7Evnm5NYoyzgzw==',\n      salt: 'DzqqrQ==',\n      bundleId: 'cloud.xtralife.gamecenterauth'\n    };\n    gcenter.cache['https://static.gc.apple.com/public-key/gc-prod-4.cer'] = testCert;\n    await gcenter.validateAuthData(authData);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData invalid signature id","suites":["Apple Game Center Auth adapter"],"line":1799,"updatePoint":{"line":1799,"column":43,"index":55276},"code":"  it('validateAuthData invalid signature id', async () => {\n    gcenter.cache['https://static.gc.apple.com/public-key/gc-prod-4.cer'] = testCert;\n    gcenter.cache['https://static.gc.apple.com/public-key/gc-prod-6.cer'] = testCert2;\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('gcenter', {});\n    await adapter.validateAppId(appIds, {\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer'\n    }, providerOptions);\n    const authData = {\n      id: 'G:1965586982',\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-6.cer',\n      timestamp: 1565257031287,\n      signature: '1234',\n      salt: 'DzqqrQ==',\n      bundleId: 'com.example.com'\n    };\n    await expectAsync(gcenter.validateAuthData(authData)).toBeRejectedWith(new Parse.Error(Parse.Error.SCRIPT_FAILED, 'Apple Game Center - invalid signature'));\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData invalid public key http url","suites":["Apple Game Center Auth adapter"],"line":1820,"updatePoint":{"line":1820,"column":50,"index":56196},"code":"  it('validateAuthData invalid public key http url', async () => {\n    const options = {\n      gcenter: {\n        rootCertificateUrl: 'https://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt.pem'\n      }\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('gcenter', options);\n    await adapter.validateAppId(appIds, {\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer'\n    }, providerOptions);\n    const publicKeyUrls = ['example.com', 'http://static.gc.apple.com/public-key/gc-prod-4.cer', 'https://developer.apple.com/assets/elements/badges/download-on-the-app-store.svg', 'https://example.com/ \\\\.apple.com/public_key.cer', 'https://example.com/ &.apple.com/public_key.cer'];\n    await Promise.all(publicKeyUrls.map(publicKeyUrl => expectAsync(gcenter.validateAuthData({\n      id: 'G:1965586982',\n      timestamp: 1565257031287,\n      publicKeyUrl,\n      signature: '1234',\n      salt: 'DzqqrQ==',\n      bundleId: 'com.example.com'\n    })).toBeRejectedWith(new Parse.Error(Parse.Error.SCRIPT_FAILED, `Apple Game Center - invalid publicKeyUrl: ${publicKeyUrl}`))));\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should not validate Symantec Cert","suites":["Apple Game Center Auth adapter"],"line":1844,"updatePoint":{"line":1844,"column":39,"index":57373},"code":"  it('should not validate Symantec Cert', async () => {\n    const options = {\n      gcenter: {\n        rootCertificateUrl: 'https://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt.pem'\n      }\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('gcenter', options);\n    await adapter.validateAppId(appIds, {\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer'\n    }, providerOptions);\n    expect(() => gcenter.verifyPublicKeyIssuer(testCert, 'https://static.gc.apple.com/public-key/gc-prod-4.cer'));\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"adapter should load default cert","suites":["Apple Game Center Auth adapter"],"line":1860,"updatePoint":{"line":1860,"column":38,"index":57990},"code":"  it('adapter should load default cert', async () => {\n    const options = {\n      gcenter: {}\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('gcenter', options);\n    await adapter.validateAppId(appIds, {\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer'\n    }, providerOptions);\n    const previous = new Date();\n    await adapter.validateAppId(appIds, {\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer'\n    }, providerOptions);\n    const duration = new Date().getTime() - previous.getTime();\n    expect(duration <= 1).toBe(true);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"adapter should throw","suites":["Apple Game Center Auth adapter"],"line":1879,"updatePoint":{"line":1879,"column":26,"index":58634},"code":"  it('adapter should throw', async () => {\n    const options = {\n      gcenter: {\n        rootCertificateUrl: 'https://example.com'\n      }\n    };\n    const {\n      adapter,\n      appIds,\n      providerOptions\n    } = authenticationLoader.loadAuthAdapter('gcenter', options);\n    await expectAsync(adapter.validateAppId(appIds, {\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer'\n    }, providerOptions)).toBeRejectedWith(new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Apple Game Center auth adapter parameter `rootCertificateURL` is invalid.'));\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"validateAuthData should throw for invalid auth","suites":["phant auth adapter"],"line":1897,"updatePoint":{"line":1897,"column":52,"index":59350},"code":"  it('validateAuthData should throw for invalid auth', async () => {\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken'\n    };\n    const {\n      adapter\n    } = authenticationLoader.loadAuthAdapter('phantauth', {});\n    spyOn(httpsRequest, 'get').and.callFake(() => Promise.resolve({\n      sub: 'invalidID'\n    }));\n    try {\n      await adapter.validateAuthData(authData);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('PhantAuth auth is invalid for this user.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should use access_token for validation is passed and responds with id and mail","suites":["microsoft graph auth adapter"],"line":1919,"updatePoint":{"line":1919,"column":84,"index":60083},"code":"  it('should use access_token for validation is passed and responds with id and mail', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        id: 'userId',\n        mail: 'userMail'\n      });\n    });\n    await microsoft.validateAuthData({\n      id: 'userId',\n      access_token: 'the_token'\n    });\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should fail to validate Microsoft Graph auth with bad token","suites":["microsoft graph auth adapter"],"line":1931,"updatePoint":{"line":1931,"column":65,"index":60418},"code":"  it('should fail to validate Microsoft Graph auth with bad token', done => {\n    const authData = {\n      id: 'fake-id',\n      mail: 'fake@mail.com',\n      access_token: 'very.long.bad.token'\n    };\n    microsoft.validateAuthData(authData).then(done.fail, err => {\n      expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      expect(err.message).toBe('Microsoft Graph auth is invalid for this user.');\n      done();\n    });\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as string) should throw error with missing id_token","suites":["facebook limited auth adapter"],"line":1950,"updatePoint":{"line":1950,"column":75,"index":61128},"skipped":true,"code":"  xit('(using client id as string) should throw error with missing id_token', async () => {\n    try {\n      await facebook.validateAuthData({}, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Facebook auth is not configured.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"(using client id as array) should throw error with missing id_token","suites":["facebook limited auth adapter"],"line":1962,"updatePoint":{"line":1962,"column":74,"index":61499},"skipped":true,"code":"  xit('(using client id as array) should throw error with missing id_token', async () => {\n    try {\n      await facebook.validateAuthData({}, {\n        clientId: ['secret']\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Facebook auth is not configured.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"should not decode invalid id_token","suites":["facebook limited auth adapter"],"line":1972,"updatePoint":{"line":1972,"column":40,"index":61759},"code":"  it('should not decode invalid id_token', async () => {\n    try {\n      await facebook.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error if public key used to encode token is not available","suites":["facebook limited auth adapter"],"line":1985,"updatePoint":{"line":1985,"column":76,"index":62119},"code":"  it('should throw error if public key used to encode token is not available', async () => {\n    const fakeDecodedToken = {\n      header: {\n        kid: '789',\n        alg: 'RS256'\n      }\n    };\n    try {\n      spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n      await facebook.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(`Unable to find matching key for Key ID: ${fakeDecodedToken.header.kid}`);\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should use algorithm from key header to verify id_token","suites":["facebook limited auth adapter"],"line":2005,"updatePoint":{"line":2005,"column":61,"index":62665},"code":"  it('should use algorithm from key header to verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    const result = await facebook.validateAuthData({\n      id: 'the_user_id',\n      token: 'the_token'\n    }, {\n      clientId: 'secret'\n    });\n    expect(result).toEqual(fakeClaim);\n    expect(jwt.verify.calls.first().args[2].algorithms).toEqual(fakeDecodedToken.header.alg);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should not verify invalid id_token","suites":["facebook limited auth adapter"],"line":2036,"updatePoint":{"line":2036,"column":40,"index":63589},"code":"  it('should not verify invalid id_token', async () => {\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    try {\n      await facebook.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt malformed');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as array) should not verify invalid id_token","suites":["facebook limited auth adapter"],"line":2063,"updatePoint":{"line":2063,"column":67,"index":64308},"code":"  it('(using client id as array) should not verify invalid id_token', async () => {\n    try {\n      await facebook.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: ['secret']\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as string) should verify id_token","suites":["facebook limited auth adapter"],"line":2076,"updatePoint":{"line":2076,"column":56,"index":64650},"code":"  it('(using client id as string) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const result = await facebook.validateAuthData({\n      id: 'the_user_id',\n      token: 'the_token'\n    }, {\n      clientId: 'secret'\n    });\n    expect(result).toEqual(fakeClaim);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as array) should verify id_token","suites":["facebook limited auth adapter"],"line":2106,"updatePoint":{"line":2106,"column":55,"index":65495},"code":"  it('(using client id as array) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const result = await facebook.validateAuthData({\n      id: 'the_user_id',\n      token: 'the_token'\n    }, {\n      clientId: ['secret']\n    });\n    expect(result).toEqual(fakeClaim);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as array with multiple items) should verify id_token","suites":["facebook limited auth adapter"],"line":2136,"updatePoint":{"line":2136,"column":75,"index":66362},"code":"  it('(using client id as array with multiple items) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const result = await facebook.validateAuthData({\n      id: 'the_user_id',\n      token: 'the_token'\n    }, {\n      clientId: ['secret', 'secret 123']\n    });\n    expect(result).toEqual(fakeClaim);\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as string) should throw error with with invalid jwt issuer","suites":["facebook limited auth adapter"],"line":2166,"updatePoint":{"line":2166,"column":81,"index":67249},"code":"  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.facebook.com',\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    try {\n      await facebook.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token not issued by correct OpenID provider - expected: https://facebook.com | from: https://not.facebook.com');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as array) should throw error with with invalid jwt issuer","suites":["facebook limited auth adapter"],"line":2201,"updatePoint":{"line":2201,"column":81,"index":68366},"skipped":true,"code":"  xit('(using client id as array) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.facebook.com',\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    try {\n      await facebook.validateAuthData({\n        id: 'INSERT ID HERE',\n        token: 'INSERT FACEBOOK TOKEN HERE WITH INVALID JWT ISSUER'\n      }, {\n        clientId: ['INSERT CLIENT ID HERE']\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token not issued by correct OpenID provider - expected: https://facebook.com | from: https://not.facebook.com');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"(using client id as string) should throw error with with invalid jwt issuer","suites":["facebook limited auth adapter"],"line":2233,"updatePoint":{"line":2233,"column":81,"index":69410},"code":"  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.facebook.com',\n      sub: 'the_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    try {\n      await facebook.validateAuthData({\n        id: 'INSERT ID HERE',\n        token: 'INSERT FACEBOOK TOKEN HERE WITH INVALID JWT ISSUER'\n      }, {\n        clientId: 'INSERT CLIENT ID HERE'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token not issued by correct OpenID provider - expected: https://facebook.com | from: https://not.facebook.com');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"(using client id as string) should throw error with invalid jwt clientId","suites":["facebook limited auth adapter"],"line":2268,"updatePoint":{"line":2268,"column":79,"index":70584},"skipped":true,"code":"  xit('(using client id as string) should throw error with invalid jwt clientId', async () => {\n    try {\n      await facebook.validateAuthData({\n        id: 'INSERT ID HERE',\n        token: 'INSERT FACEBOOK TOKEN HERE'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"(using client id as array) should throw error with invalid jwt clientId","suites":["facebook limited auth adapter"],"line":2284,"updatePoint":{"line":2284,"column":78,"index":71101},"skipped":true,"code":"  xit('(using client id as array) should throw error with invalid jwt clientId', async () => {\n    try {\n      await facebook.validateAuthData({\n        id: 'INSERT ID HERE',\n        token: 'INSERT FACEBOOK TOKEN HERE'\n      }, {\n        clientId: ['secret']\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"should throw error with invalid user id","suites":["facebook limited auth adapter"],"line":2300,"updatePoint":{"line":2300,"column":46,"index":71588},"skipped":true,"code":"  xit('should throw error with invalid user id', async () => {\n    try {\n      await facebook.validateAuthData({\n        id: 'invalid user',\n        token: 'INSERT FACEBOOK TOKEN HERE'\n      }, {\n        clientId: 'INSERT CLIENT ID HERE'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","dir":"spec"},{"name":"should throw error with with invalid user id","suites":["facebook limited auth adapter"],"line":2313,"updatePoint":{"line":2313,"column":50,"index":71953},"code":"  it('should throw error with with invalid user id', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'invalid_client_id',\n      sub: 'a_different_user_id'\n    };\n    const fakeDecodedToken = {\n      header: {\n        kid: '123',\n        alg: 'RS256'\n      }\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key'\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    try {\n      await facebook.validateAuthData({\n        id: 'the_user_id',\n        token: 'the_token'\n      }, {\n        clientId: 'secret'\n      });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });","file":"AuthenticationAdapters.spec.js","skipped":false,"dir":"spec"},{"name":"should return the proper url","suites":["batch"],"line":19,"updatePoint":{"line":19,"column":34,"index":743},"code":"  it('should return the proper url', () => {\n    const internalURL = batch.makeBatchRoutingPathFunction(originalURL)('/parse/classes/Object');\n    expect(internalURL).toEqual('/classes/Object');\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should return the proper url given a public url-only path","suites":["batch"],"line":23,"updatePoint":{"line":23,"column":63,"index":973},"code":"  it('should return the proper url given a public url-only path', () => {\n    const originalURL = '/something/really/long/batch';\n    const internalURL = batch.makeBatchRoutingPathFunction(originalURL, serverURL, publicServerURLLong)('/parse/classes/Object');\n    expect(internalURL).toEqual('/classes/Object');\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should return the proper url given a server url-only path","suites":["batch"],"line":28,"updatePoint":{"line":28,"column":63,"index":1291},"code":"  it('should return the proper url given a server url-only path', () => {\n    const originalURL = '/parse/batch';\n    const internalURL = batch.makeBatchRoutingPathFunction(originalURL, serverURL, publicServerURLLong)('/parse/classes/Object');\n    expect(internalURL).toEqual('/classes/Object');\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should return the proper url same public/local endpoint","suites":["batch"],"line":33,"updatePoint":{"line":33,"column":61,"index":1591},"code":"  it('should return the proper url same public/local endpoint', () => {\n    const originalURL = '/parse/batch';\n    const internalURL = batch.makeBatchRoutingPathFunction(originalURL, serverURL, publicServerURL)('/parse/classes/Object');\n    expect(internalURL).toEqual('/classes/Object');\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should return the proper url with different public/local mount","suites":["batch"],"line":38,"updatePoint":{"line":38,"column":68,"index":1894},"code":"  it('should return the proper url with different public/local mount', () => {\n    const originalURL = '/parse/batch';\n    const internalURL = batch.makeBatchRoutingPathFunction(originalURL, serverURL1, publicServerURL)('/parse/classes/Object');\n    expect(internalURL).toEqual('/classes/Object');\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should return the proper url with naked public","suites":["batch"],"line":43,"updatePoint":{"line":43,"column":52,"index":2182},"code":"  it('should return the proper url with naked public', () => {\n    const originalURL = '/batch';\n    const internalURL = batch.makeBatchRoutingPathFunction(originalURL, serverURL, publicServerURLNaked)('/classes/Object');\n    expect(internalURL).toEqual('/classes/Object');\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should return the proper url with naked local","suites":["batch"],"line":48,"updatePoint":{"line":48,"column":51,"index":2461},"code":"  it('should return the proper url with naked local', () => {\n    const originalURL = '/parse/batch';\n    const internalURL = batch.makeBatchRoutingPathFunction(originalURL, serverURLNaked, publicServerURL)('/parse/classes/Object');\n    expect(internalURL).toEqual('/classes/Object');\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should return the proper url with no url provided","suites":["batch"],"line":53,"updatePoint":{"line":53,"column":55,"index":2756},"code":"  it('should return the proper url with no url provided', () => {\n    const originalURL = '/parse/batch';\n    const internalURL = batch.makeBatchRoutingPathFunction(originalURL, undefined, publicServerURL)('/parse/classes/Object');\n    expect(internalURL).toEqual('/classes/Object');\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should return the proper url with no public url provided","suites":["batch"],"line":58,"updatePoint":{"line":58,"column":62,"index":3053},"code":"  it('should return the proper url with no public url provided', () => {\n    const originalURL = '/parse/batch';\n    const internalURL = batch.makeBatchRoutingPathFunction(originalURL, serverURLNaked, undefined)('/parse/classes/Object');\n    expect(internalURL).toEqual('/classes/Object');\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should return the proper url with bad url provided","suites":["batch"],"line":63,"updatePoint":{"line":63,"column":56,"index":3343},"code":"  it('should return the proper url with bad url provided', () => {\n    const originalURL = '/parse/batch';\n    const internalURL = batch.makeBatchRoutingPathFunction(originalURL, 'badurl.com', publicServerURL)('/parse/classes/Object');\n    expect(internalURL).toEqual('/classes/Object');\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should return the proper url with bad public url provided","suites":["batch"],"line":68,"updatePoint":{"line":68,"column":63,"index":3644},"code":"  it('should return the proper url with bad public url provided', () => {\n    const originalURL = '/parse/batch';\n    const internalURL = batch.makeBatchRoutingPathFunction(originalURL, serverURLNaked, 'badurl.com')('/parse/classes/Object');\n    expect(internalURL).toEqual('/classes/Object');\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should handle a batch request without transaction","suites":["batch"],"line":73,"updatePoint":{"line":73,"column":55,"index":3936},"code":"  it('should handle a batch request without transaction', async () => {\n    spyOn(databaseAdapter, 'createObject').and.callThrough();\n    const response = await request({\n      method: 'POST',\n      headers: headers,\n      url: 'http://localhost:8378/1/batch',\n      body: JSON.stringify({\n        requests: [{\n          method: 'POST',\n          path: '/1/classes/MyObject',\n          body: {\n            key: 'value1'\n          }\n        }, {\n          method: 'POST',\n          path: '/1/classes/MyObject',\n          body: {\n            key: 'value2'\n          }\n        }]\n      })\n    });\n    expect(response.data.length).toEqual(2);\n    expect(response.data[0].success.objectId).toBeDefined();\n    expect(response.data[0].success.createdAt).toBeDefined();\n    expect(response.data[1].success.objectId).toBeDefined();\n    expect(response.data[1].success.createdAt).toBeDefined();\n    const query = new Parse.Query('MyObject');\n    const results = await query.find();\n    expect(databaseAdapter.createObject.calls.count()).toBe(2);\n    expect(databaseAdapter.createObject.calls.argsFor(0)[3]).toEqual(null);\n    expect(databaseAdapter.createObject.calls.argsFor(1)[3]).toEqual(null);\n    expect(results.map(result => result.get('key')).sort()).toEqual(['value1', 'value2']);\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should handle a batch request with transaction = false","suites":["batch"],"line":107,"updatePoint":{"line":107,"column":60,"index":5226},"code":"  it('should handle a batch request with transaction = false', async () => {\n    spyOn(databaseAdapter, 'createObject').and.callThrough();\n    const response = await request({\n      method: 'POST',\n      headers: headers,\n      url: 'http://localhost:8378/1/batch',\n      body: JSON.stringify({\n        requests: [{\n          method: 'POST',\n          path: '/1/classes/MyObject',\n          body: {\n            key: 'value1'\n          }\n        }, {\n          method: 'POST',\n          path: '/1/classes/MyObject',\n          body: {\n            key: 'value2'\n          }\n        }],\n        transaction: false\n      })\n    });\n    expect(response.data.length).toEqual(2);\n    expect(response.data[0].success.objectId).toBeDefined();\n    expect(response.data[0].success.createdAt).toBeDefined();\n    expect(response.data[1].success.objectId).toBeDefined();\n    expect(response.data[1].success.createdAt).toBeDefined();\n    const query = new Parse.Query('MyObject');\n    const results = await query.find();\n    expect(databaseAdapter.createObject.calls.count()).toBe(2);\n    expect(databaseAdapter.createObject.calls.argsFor(0)[3]).toEqual(null);\n    expect(databaseAdapter.createObject.calls.argsFor(1)[3]).toEqual(null);\n    expect(results.map(result => result.get('key')).sort()).toEqual(['value1', 'value2']);\n  });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should handle a batch request with transaction = true","suites":["batch","transactions"],"line":155,"updatePoint":{"line":155,"column":63,"index":7344},"code":"      it('should handle a batch request with transaction = true', async () => {\n        const myObject = new Parse.Object('MyObject'); // This is important because transaction only works on pre-existing collections\n        await myObject.save();\n        await myObject.destroy();\n        spyOn(databaseAdapter, 'createObject').and.callThrough();\n        const response = await request({\n          method: 'POST',\n          headers: headers,\n          url: 'http://localhost:8378/1/batch',\n          body: JSON.stringify({\n            requests: [{\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value2'\n              }\n            }],\n            transaction: true\n          })\n        });\n        expect(response.data.length).toEqual(2);\n        expect(response.data[0].success.objectId).toBeDefined();\n        expect(response.data[0].success.createdAt).toBeDefined();\n        expect(response.data[1].success.objectId).toBeDefined();\n        expect(response.data[1].success.createdAt).toBeDefined();\n        const query = new Parse.Query('MyObject');\n        const results = await query.find();\n        expect(databaseAdapter.createObject.calls.count() % 2).toBe(0);\n        for (let i = 0; i + 1 < databaseAdapter.createObject.calls.length; i = i + 2) {\n          expect(databaseAdapter.createObject.calls.argsFor(i)[3]).toBe(databaseAdapter.createObject.calls.argsFor(i + 1)[3]);\n        }\n        expect(results.map(result => result.get('key')).sort()).toEqual(['value1', 'value2']);\n      });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should not save anything when one operation fails in a transaction","suites":["batch","transactions"],"line":194,"updatePoint":{"line":194,"column":76,"index":9082},"code":"      it('should not save anything when one operation fails in a transaction', async () => {\n        const myObject = new Parse.Object('MyObject'); // This is important because transaction only works on pre-existing collections\n        await myObject.save();\n        await myObject.destroy();\n        try {\n          await request({\n            method: 'POST',\n            headers: headers,\n            url: 'http://localhost:8378/1/batch',\n            body: JSON.stringify({\n              requests: [{\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 'value1'\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 10\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 'value1'\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 10\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 'value1'\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 10\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 'value1'\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 10\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 'value1'\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 10\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 'value1'\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 10\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 'value1'\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 10\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 'value1'\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 10\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 'value1'\n                }\n              }, {\n                method: 'POST',\n                path: '/1/classes/MyObject',\n                body: {\n                  key: 10\n                }\n              }],\n              transaction: true\n            })\n          });\n          fail();\n        } catch (error) {\n          expect(error).toBeDefined();\n          const query = new Parse.Query('MyObject');\n          const results = await query.find();\n          expect(results.length).toBe(0);\n        }\n      });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should generate separate session for each call","suites":["batch","transactions"],"line":324,"updatePoint":{"line":324,"column":56,"index":12875},"code":"      it('should generate separate session for each call', async () => {\n        await reconfigureServer();\n        const myObject = new Parse.Object('MyObject'); // This is important because transaction only works on pre-existing collections\n        await myObject.save();\n        await myObject.destroy();\n        const myObject2 = new Parse.Object('MyObject2'); // This is important because transaction only works on pre-existing collections\n        await myObject2.save();\n        await myObject2.destroy();\n        spyOn(databaseAdapter, 'createObject').and.callThrough();\n        let myObjectCalls = 0;\n        Parse.Cloud.beforeSave('MyObject', async () => {\n          myObjectCalls++;\n          if (myObjectCalls === 2) {\n            try {\n              await request({\n                method: 'POST',\n                headers: headers,\n                url: 'http://localhost:8378/1/batch',\n                body: JSON.stringify({\n                  requests: [{\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 'value1'\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 10\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 'value1'\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 10\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 'value1'\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 10\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 'value1'\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 10\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 'value1'\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 10\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 'value1'\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 10\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 'value1'\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 10\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 'value1'\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 10\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 'value1'\n                    }\n                  }, {\n                    method: 'POST',\n                    path: '/1/classes/MyObject2',\n                    body: {\n                      key: 10\n                    }\n                  }],\n                  transaction: true\n                })\n              });\n              fail('should fail');\n            } catch (e) {\n              expect(e).toBeDefined();\n            }\n          }\n        });\n        const response = await request({\n          method: 'POST',\n          headers: headers,\n          url: 'http://localhost:8378/1/batch',\n          body: JSON.stringify({\n            requests: [{\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value2'\n              }\n            }],\n            transaction: true\n          })\n        });\n        expect(response.data.length).toEqual(2);\n        expect(response.data[0].success.objectId).toBeDefined();\n        expect(response.data[0].success.createdAt).toBeDefined();\n        expect(response.data[1].success.objectId).toBeDefined();\n        expect(response.data[1].success.createdAt).toBeDefined();\n        await request({\n          method: 'POST',\n          headers: headers,\n          url: 'http://localhost:8378/1/batch',\n          body: JSON.stringify({\n            requests: [{\n              method: 'POST',\n              path: '/1/classes/MyObject3',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject3',\n              body: {\n                key: 'value2'\n              }\n            }]\n          })\n        });\n        const query = new Parse.Query('MyObject');\n        const results = await query.find();\n        expect(results.map(result => result.get('key')).sort()).toEqual(['value1', 'value2']);\n        const query2 = new Parse.Query('MyObject2');\n        const results2 = await query2.find();\n        expect(results2.length).toEqual(0);\n        const query3 = new Parse.Query('MyObject3');\n        const results3 = await query3.find();\n        expect(results3.map(result => result.get('key')).sort()).toEqual(['value1', 'value2']);\n        expect(databaseAdapter.createObject.calls.count() >= 13).toEqual(true);\n        let transactionalSession;\n        let transactionalSession2;\n        let myObjectDBCalls = 0;\n        let myObject2DBCalls = 0;\n        let myObject3DBCalls = 0;\n        for (let i = 0; i < databaseAdapter.createObject.calls.count(); i++) {\n          const args = databaseAdapter.createObject.calls.argsFor(i);\n          switch (args[0]) {\n            case 'MyObject':\n              myObjectDBCalls++;\n              if (!transactionalSession || (myObjectDBCalls - 1) % 2 === 0) {\n                transactionalSession = args[3];\n              } else {\n                expect(transactionalSession).toBe(args[3]);\n              }\n              if (transactionalSession2) {\n                expect(transactionalSession2).not.toBe(args[3]);\n              }\n              break;\n            case 'MyObject2':\n              myObject2DBCalls++;\n              if (!transactionalSession2 || (myObject2DBCalls - 1) % 9 === 0) {\n                transactionalSession2 = args[3];\n              } else {\n                expect(transactionalSession2).toBe(args[3]);\n              }\n              if (transactionalSession) {\n                expect(transactionalSession).not.toBe(args[3]);\n              }\n              break;\n            case 'MyObject3':\n              myObject3DBCalls++;\n              expect(args[3]).toEqual(null);\n              break;\n          }\n        }\n        expect(myObjectDBCalls % 2).toEqual(0);\n        expect(myObjectDBCalls > 0).toEqual(true);\n        expect(myObject2DBCalls % 9).toEqual(0);\n        expect(myObject2DBCalls > 0).toEqual(true);\n        expect(myObject3DBCalls % 2).toEqual(0);\n        expect(myObject3DBCalls > 0).toEqual(true);\n      });","file":"batch.spec.js","skipped":false,"dir":"spec"},{"name":"should expose role and user caches","suites":["CacheController"],"line":15,"updatePoint":{"line":15,"column":40,"index":506},"code":"  it('should expose role and user caches', done => {\n    const cache = new CacheController(FakeCacheAdapter, FakeAppID);\n    expect(cache.role).not.toEqual(null);\n    expect(cache.role.get).not.toEqual(null);\n    expect(cache.user).not.toEqual(null);\n    expect(cache.user.get).not.toEqual(null);\n    done();\n  });","file":"CacheController.spec.js","skipped":false,"dir":"spec"},{"name":"should clear the entire cache","suites":["CacheController"],"line":37,"updatePoint":{"line":37,"column":35,"index":1498},"code":"  it('should clear the entire cache', () => {\n    const cache = new CacheController(FakeCacheAdapter, FakeAppID);\n    cache.clear();\n    expect(FakeCacheAdapter.clear.calls.count()).toEqual(1);\n    cache.user.clear();\n    expect(FakeCacheAdapter.clear.calls.count()).toEqual(2);\n    cache.role.clear();\n    expect(FakeCacheAdapter.clear.calls.count()).toEqual(3);\n  });","file":"CacheController.spec.js","skipped":false,"dir":"spec"},{"name":"should handle cache rejections","suites":["CacheController"],"line":46,"updatePoint":{"line":46,"column":36,"index":1869},"code":"  it('should handle cache rejections', done => {\n    FakeCacheAdapter.get = () => Promise.reject();\n    const cache = new CacheController(FakeCacheAdapter, FakeAppID);\n    cache.get('foo').then(done, () => {\n      fail('Promise should not be rejected.');\n    });\n  });","file":"CacheController.spec.js","skipped":false,"dir":"spec"},{"name":"should load properly definitions from args","suites":["commander additions"],"line":41,"updatePoint":{"line":41,"column":48,"index":1008},"code":"  it('should load properly definitions from args', done => {\n    commander.loadDefinitions(testDefinitions);\n    commander.parse(['node', './CLI.spec.js', '--arg0', 'arg0Value', '--arg1', 'arg1Value', '--arg2', '2', '--arg3', 'some']);\n    expect(commander.arg0).toEqual('arg0Value');\n    expect(commander.arg1).toEqual('arg1Value');\n    expect(commander.arg2).toEqual(2);\n    expect(commander.arg3).toEqual('some');\n    expect(commander.arg4).toEqual('arg4Value');\n    done();\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"should load properly definitions from env","suites":["commander additions"],"line":51,"updatePoint":{"line":51,"column":47,"index":1491},"code":"  it('should load properly definitions from env', done => {\n    commander.loadDefinitions(testDefinitions);\n    commander.parse([], {\n      PROGRAM_ARG_0: 'arg0ENVValue',\n      PROGRAM_ARG_1: 'arg1ENVValue',\n      PROGRAM_ARG_2: '3'\n    });\n    expect(commander.arg0).toEqual('arg0ENVValue');\n    expect(commander.arg1).toEqual('arg1ENVValue');\n    expect(commander.arg2).toEqual(3);\n    expect(commander.arg4).toEqual('arg4Value');\n    done();\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"should load properly use args over env","suites":["commander additions"],"line":64,"updatePoint":{"line":64,"column":44,"index":1939},"code":"  it('should load properly use args over env', done => {\n    commander.loadDefinitions(testDefinitions);\n    commander.parse(['node', './CLI.spec.js', '--arg0', 'arg0Value', '--arg4', ''], {\n      PROGRAM_ARG_0: 'arg0ENVValue',\n      PROGRAM_ARG_1: 'arg1ENVValue',\n      PROGRAM_ARG_2: '4',\n      PROGRAM_ARG_4: 'arg4ENVValue'\n    });\n    expect(commander.arg0).toEqual('arg0Value');\n    expect(commander.arg1).toEqual('arg1ENVValue');\n    expect(commander.arg2).toEqual(4);\n    expect(commander.arg4).toEqual('');\n    done();\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"should fail in action as port is invalid","suites":["commander additions"],"line":78,"updatePoint":{"line":78,"column":46,"index":2474},"code":"  it('should fail in action as port is invalid', done => {\n    commander.loadDefinitions(testDefinitions);\n    expect(() => {\n      commander.parse(['node', './CLI.spec.js', '--arg0', 'arg0Value'], {\n        PROGRAM_ARG_0: 'arg0ENVValue',\n        PROGRAM_ARG_1: 'arg1ENVValue',\n        PROGRAM_ARG_2: 'hello'\n      });\n    }).toThrow('arg2 is invalid');\n    done();\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"should not override config.json","suites":["commander additions"],"line":89,"updatePoint":{"line":89,"column":37,"index":2837},"code":"  it('should not override config.json', done => {\n    spyOn(console, 'log').and.callFake(() => {});\n    commander.loadDefinitions(testDefinitions);\n    commander.parse(['node', './CLI.spec.js', '--arg0', 'arg0Value', './spec/configs/CLIConfig.json'], {\n      PROGRAM_ARG_0: 'arg0ENVValue',\n      PROGRAM_ARG_1: 'arg1ENVValue'\n    });\n    const options = commander.getOptions();\n    expect(options.arg2).toBe(8888);\n    expect(options.arg3).toBe('hello'); //config value\n    expect(options.arg4).toBe('/1');\n    done();\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"should fail with invalid values in JSON","suites":["commander additions"],"line":102,"updatePoint":{"line":102,"column":45,"index":3370},"code":"  it('should fail with invalid values in JSON', done => {\n    commander.loadDefinitions(testDefinitions);\n    expect(() => {\n      commander.parse(['node', './CLI.spec.js', '--arg0', 'arg0Value', './spec/configs/CLIConfigFail.json'], {\n        PROGRAM_ARG_0: 'arg0ENVValue',\n        PROGRAM_ARG_1: 'arg1ENVValue'\n      });\n    }).toThrow('arg2 is invalid');\n    done();\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"should fail when too many apps are set","suites":["commander additions"],"line":112,"updatePoint":{"line":112,"column":44,"index":3745},"code":"  it('should fail when too many apps are set', done => {\n    commander.loadDefinitions(testDefinitions);\n    expect(() => {\n      commander.parse(['node', './CLI.spec.js', './spec/configs/CLIConfigFailTooManyApps.json']);\n    }).toThrow('Multiple apps are not supported');\n    done();\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"should load config from apps","suites":["commander additions"],"line":119,"updatePoint":{"line":119,"column":34,"index":4026},"code":"  it('should load config from apps', done => {\n    spyOn(console, 'log').and.callFake(() => {});\n    commander.loadDefinitions(testDefinitions);\n    commander.parse(['node', './CLI.spec.js', './spec/configs/CLIConfigApps.json']);\n    const options = commander.getOptions();\n    expect(options.arg1).toBe('my_app');\n    expect(options.arg2).toBe(8888);\n    expect(options.arg3).toBe('hello'); //config value\n    expect(options.arg4).toBe('/1');\n    done();\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"should fail when passing an invalid arguement","suites":["commander additions"],"line":130,"updatePoint":{"line":130,"column":51,"index":4505},"code":"  it('should fail when passing an invalid arguement', done => {\n    commander.loadDefinitions(testDefinitions);\n    expect(() => {\n      commander.parse(['node', './CLI.spec.js', './spec/configs/CLIConfigUnknownArg.json']);\n    }).toThrow('error: unknown option myArg');\n    done();\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"should have valid types","suites":["definitions"],"line":139,"updatePoint":{"line":139,"column":29,"index":4808},"code":"  it('should have valid types', () => {\n    for (const key in definitions) {\n      const definition = definitions[key];\n      expect(typeof definition).toBe('object');\n      if (typeof definition.env !== 'undefined') {\n        expect(typeof definition.env).toBe('string');\n      }\n      expect(typeof definition.help).toBe('string');\n      if (typeof definition.required !== 'undefined') {\n        expect(typeof definition.required).toBe('boolean');\n      }\n      if (typeof definition.action !== 'undefined') {\n        expect(typeof definition.action).toBe('function');\n      }\n    }\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when using deprecated facebookAppIds","suites":["definitions"],"line":155,"updatePoint":{"line":155,"column":55,"index":5425},"code":"  it('should throw when using deprecated facebookAppIds', () => {\n    expect(() => {\n      definitions.facebookAppIds.action();\n    }).toThrow();\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"should have valid types","suites":["LiveQuery definitions"],"line":162,"updatePoint":{"line":162,"column":29,"index":5597},"code":"  it('should have valid types', () => {\n    for (const key in liveQueryDefinitions) {\n      const definition = liveQueryDefinitions[key];\n      expect(typeof definition).toBe('object');\n      if (typeof definition.env !== 'undefined') {\n        expect(typeof definition.env).toBe('string');\n      }\n      expect(typeof definition.help).toBe('string', `help for ${key} should be a string`);\n      if (typeof definition.required !== 'undefined') {\n        expect(typeof definition.required).toBe('boolean');\n      }\n      if (typeof definition.action !== 'undefined') {\n        expect(typeof definition.action).toBe('function');\n      }\n    }\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"shoud start Parse Server","suites":["execution"],"line":191,"updatePoint":{"line":191,"column":30,"index":6549},"code":"  it('shoud start Parse Server', done => {\n    childProcess = spawn(binPath, ['--appId', 'test', '--masterKey', 'test', '--databaseURI', 'mongodb://localhost/test', '--port', '1339']);\n    childProcess.stdout.on('data', data => {\n      data = data.toString();\n      if (data.includes('parse-server running on')) {\n        done();\n      }\n    });\n    childProcess.stderr.on('data', data => {\n      done.fail(data.toString());\n    });\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"shoud start Parse Server with GraphQL","suites":["execution"],"line":203,"updatePoint":{"line":203,"column":43,"index":7001},"code":"  it('shoud start Parse Server with GraphQL', done => {\n    childProcess = spawn(binPath, ['--appId', 'test', '--masterKey', 'test', '--databaseURI', 'mongodb://localhost/test', '--port', '1340', '--mountGraphQL']);\n    let output = '';\n    childProcess.stdout.on('data', data => {\n      data = data.toString();\n      output += data;\n      if (data.includes('GraphQL running on')) {\n        expect(output).toMatch('parse-server running on');\n        done();\n      }\n    });\n    childProcess.stderr.on('data', data => {\n      done.fail(data.toString());\n    });\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"shoud start Parse Server with GraphQL and Playground","suites":["execution"],"line":218,"updatePoint":{"line":218,"column":58,"index":7583},"code":"  it('shoud start Parse Server with GraphQL and Playground', done => {\n    childProcess = spawn(binPath, ['--appId', 'test', '--masterKey', 'test', '--databaseURI', 'mongodb://localhost/test', '--port', '1341', '--mountGraphQL', '--mountPlayground']);\n    let output = '';\n    childProcess.stdout.on('data', data => {\n      data = data.toString();\n      output += data;\n      if (data.includes('Playground running on')) {\n        expect(output).toMatch('GraphQL running on');\n        expect(output).toMatch('parse-server running on');\n        done();\n      }\n    });\n    childProcess.stderr.on('data', data => {\n      done.fail(data.toString());\n    });\n  });","file":"CLI.spec.js","skipped":false,"dir":"spec"},{"name":"can be initialized","suites":["Client"],"line":4,"updatePoint":{"line":4,"column":24,"index":204},"code":"  it('can be initialized', function () {\n    const parseWebSocket = new ParseWebSocket({});\n    const client = new Client(1, parseWebSocket);\n    expect(client.id).toBe(1);\n    expect(client.parseWebSocket).toBe(parseWebSocket);\n    expect(client.subscriptionInfos.size).toBe(0);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can push response","suites":["Client"],"line":11,"updatePoint":{"line":11,"column":23,"index":489},"code":"  it('can push response', function () {\n    const parseWebSocket = {\n      send: jasmine.createSpy('send')\n    };\n    Client.pushResponse(parseWebSocket, 'message');\n    expect(parseWebSocket.send).toHaveBeenCalledWith('message');\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can push error","suites":["Client"],"line":18,"updatePoint":{"line":18,"column":20,"index":723},"code":"  it('can push error', function () {\n    const parseWebSocket = {\n      send: jasmine.createSpy('send')\n    };\n    Client.pushError(parseWebSocket, 1, 'error', true);\n    const lastCall = parseWebSocket.send.calls.first();\n    const messageJSON = JSON.parse(lastCall.args[0]);\n    expect(messageJSON.op).toBe('error');\n    expect(messageJSON.error).toBe('error');\n    expect(messageJSON.code).toBe(1);\n    expect(messageJSON.reconnect).toBe(true);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can add subscription information","suites":["Client"],"line":30,"updatePoint":{"line":30,"column":38,"index":1195},"code":"  it('can add subscription information', function () {\n    const subscription = {};\n    const fields = ['test'];\n    const subscriptionInfo = {\n      subscription: subscription,\n      fields: fields\n    };\n    const client = new Client(1, {});\n    client.addSubscriptionInfo(1, subscriptionInfo);\n    expect(client.subscriptionInfos.size).toBe(1);\n    expect(client.subscriptionInfos.get(1)).toBe(subscriptionInfo);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can get subscription information","suites":["Client"],"line":42,"updatePoint":{"line":42,"column":38,"index":1617},"code":"  it('can get subscription information', function () {\n    const subscription = {};\n    const fields = ['test'];\n    const subscriptionInfo = {\n      subscription: subscription,\n      fields: fields\n    };\n    const client = new Client(1, {});\n    client.addSubscriptionInfo(1, subscriptionInfo);\n    const subscriptionInfoAgain = client.getSubscriptionInfo(1);\n    expect(subscriptionInfoAgain).toBe(subscriptionInfo);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can delete subscription information","suites":["Client"],"line":54,"updatePoint":{"line":54,"column":41,"index":2046},"code":"  it('can delete subscription information', function () {\n    const subscription = {};\n    const fields = ['test'];\n    const subscriptionInfo = {\n      subscription: subscription,\n      fields: fields\n    };\n    const client = new Client(1, {});\n    client.addSubscriptionInfo(1, subscriptionInfo);\n    client.deleteSubscriptionInfo(1);\n    expect(client.subscriptionInfos.size).toBe(0);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can generate ParseObject JSON with null selected field","suites":["Client"],"line":66,"updatePoint":{"line":66,"column":60,"index":2460},"code":"  it('can generate ParseObject JSON with null selected field', function () {\n    const parseObjectJSON = {\n      key: 'value',\n      className: 'test',\n      objectId: 'test',\n      updatedAt: '2015-12-07T21:27:13.746Z',\n      createdAt: '2015-12-07T21:27:13.746Z',\n      ACL: 'test'\n    };\n    const client = new Client(1, {});\n    expect(client._toJSONWithFields(parseObjectJSON, null)).toBe(parseObjectJSON);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can generate ParseObject JSON with undefined selected field","suites":["Client"],"line":78,"updatePoint":{"line":78,"column":65,"index":2883},"code":"  it('can generate ParseObject JSON with undefined selected field', function () {\n    const parseObjectJSON = {\n      key: 'value',\n      className: 'test',\n      objectId: 'test',\n      updatedAt: '2015-12-07T21:27:13.746Z',\n      createdAt: '2015-12-07T21:27:13.746Z',\n      ACL: 'test'\n    };\n    const client = new Client(1, {});\n    expect(client._toJSONWithFields(parseObjectJSON, undefined)).toBe(parseObjectJSON);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can generate ParseObject JSON with selected fields","suites":["Client"],"line":90,"updatePoint":{"line":90,"column":56,"index":3302},"code":"  it('can generate ParseObject JSON with selected fields', function () {\n    const parseObjectJSON = {\n      key: 'value',\n      className: 'test',\n      objectId: 'test',\n      updatedAt: '2015-12-07T21:27:13.746Z',\n      createdAt: '2015-12-07T21:27:13.746Z',\n      ACL: 'test',\n      test: 'test'\n    };\n    const client = new Client(1, {});\n    expect(client._toJSONWithFields(parseObjectJSON, ['test'])).toEqual({\n      className: 'test',\n      objectId: 'test',\n      updatedAt: '2015-12-07T21:27:13.746Z',\n      createdAt: '2015-12-07T21:27:13.746Z',\n      ACL: 'test',\n      test: 'test'\n    });\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can generate ParseObject JSON with nonexistent selected fields","suites":["Client"],"line":110,"updatePoint":{"line":110,"column":68,"index":3924},"code":"  it('can generate ParseObject JSON with nonexistent selected fields', function () {\n    const parseObjectJSON = {\n      key: 'value',\n      className: 'test',\n      objectId: 'test',\n      updatedAt: '2015-12-07T21:27:13.746Z',\n      createdAt: '2015-12-07T21:27:13.746Z',\n      ACL: 'test',\n      test: 'test'\n    };\n    const client = new Client(1, {});\n    const limitedParseObject = client._toJSONWithFields(parseObjectJSON, ['name']);\n    expect(limitedParseObject).toEqual({\n      className: 'test',\n      objectId: 'test',\n      updatedAt: '2015-12-07T21:27:13.746Z',\n      createdAt: '2015-12-07T21:27:13.746Z',\n      ACL: 'test'\n    });\n    expect('name' in limitedParseObject).toBe(false);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can push connect response","suites":["Client"],"line":131,"updatePoint":{"line":131,"column":31,"index":4594},"code":"  it('can push connect response', function () {\n    const parseWebSocket = {\n      send: jasmine.createSpy('send')\n    };\n    const client = new Client(1, parseWebSocket);\n    client.pushConnect();\n    const lastCall = parseWebSocket.send.calls.first();\n    const messageJSON = JSON.parse(lastCall.args[0]);\n    expect(messageJSON.op).toBe('connected');\n    expect(messageJSON.clientId).toBe(1);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can push subscribe response","suites":["Client"],"line":142,"updatePoint":{"line":142,"column":33,"index":4998},"code":"  it('can push subscribe response', function () {\n    const parseWebSocket = {\n      send: jasmine.createSpy('send')\n    };\n    const client = new Client(1, parseWebSocket);\n    client.pushSubscribe(2);\n    const lastCall = parseWebSocket.send.calls.first();\n    const messageJSON = JSON.parse(lastCall.args[0]);\n    expect(messageJSON.op).toBe('subscribed');\n    expect(messageJSON.clientId).toBe(1);\n    expect(messageJSON.requestId).toBe(2);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can push unsubscribe response","suites":["Client"],"line":154,"updatePoint":{"line":154,"column":35,"index":5451},"code":"  it('can push unsubscribe response', function () {\n    const parseWebSocket = {\n      send: jasmine.createSpy('send')\n    };\n    const client = new Client(1, parseWebSocket);\n    client.pushUnsubscribe(2);\n    const lastCall = parseWebSocket.send.calls.first();\n    const messageJSON = JSON.parse(lastCall.args[0]);\n    expect(messageJSON.op).toBe('unsubscribed');\n    expect(messageJSON.clientId).toBe(1);\n    expect(messageJSON.requestId).toBe(2);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can push create response","suites":["Client"],"line":166,"updatePoint":{"line":166,"column":30,"index":5903},"code":"  it('can push create response', function () {\n    const parseObjectJSON = {\n      key: 'value',\n      className: 'test',\n      objectId: 'test',\n      updatedAt: '2015-12-07T21:27:13.746Z',\n      createdAt: '2015-12-07T21:27:13.746Z',\n      ACL: 'test',\n      test: 'test'\n    };\n    const parseWebSocket = {\n      send: jasmine.createSpy('send')\n    };\n    const client = new Client(1, parseWebSocket);\n    client.pushCreate(2, parseObjectJSON);\n    const lastCall = parseWebSocket.send.calls.first();\n    const messageJSON = JSON.parse(lastCall.args[0]);\n    expect(messageJSON.op).toBe('create');\n    expect(messageJSON.clientId).toBe(1);\n    expect(messageJSON.requestId).toBe(2);\n    expect(messageJSON.object).toEqual(parseObjectJSON);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can push enter response","suites":["Client"],"line":188,"updatePoint":{"line":188,"column":29,"index":6651},"code":"  it('can push enter response', function () {\n    const parseObjectJSON = {\n      key: 'value',\n      className: 'test',\n      objectId: 'test',\n      updatedAt: '2015-12-07T21:27:13.746Z',\n      createdAt: '2015-12-07T21:27:13.746Z',\n      ACL: 'test',\n      test: 'test'\n    };\n    const parseWebSocket = {\n      send: jasmine.createSpy('send')\n    };\n    const client = new Client(1, parseWebSocket);\n    client.pushEnter(2, parseObjectJSON);\n    const lastCall = parseWebSocket.send.calls.first();\n    const messageJSON = JSON.parse(lastCall.args[0]);\n    expect(messageJSON.op).toBe('enter');\n    expect(messageJSON.clientId).toBe(1);\n    expect(messageJSON.requestId).toBe(2);\n    expect(messageJSON.object).toEqual(parseObjectJSON);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can push update response","suites":["Client"],"line":210,"updatePoint":{"line":210,"column":30,"index":7398},"code":"  it('can push update response', function () {\n    const parseObjectJSON = {\n      key: 'value',\n      className: 'test',\n      objectId: 'test',\n      updatedAt: '2015-12-07T21:27:13.746Z',\n      createdAt: '2015-12-07T21:27:13.746Z',\n      ACL: 'test',\n      test: 'test'\n    };\n    const parseWebSocket = {\n      send: jasmine.createSpy('send')\n    };\n    const client = new Client(1, parseWebSocket);\n    client.pushUpdate(2, parseObjectJSON);\n    const lastCall = parseWebSocket.send.calls.first();\n    const messageJSON = JSON.parse(lastCall.args[0]);\n    expect(messageJSON.op).toBe('update');\n    expect(messageJSON.clientId).toBe(1);\n    expect(messageJSON.requestId).toBe(2);\n    expect(messageJSON.object).toEqual(parseObjectJSON);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"can push leave response","suites":["Client"],"line":232,"updatePoint":{"line":232,"column":29,"index":8146},"code":"  it('can push leave response', function () {\n    const parseObjectJSON = {\n      key: 'value',\n      className: 'test',\n      objectId: 'test',\n      updatedAt: '2015-12-07T21:27:13.746Z',\n      createdAt: '2015-12-07T21:27:13.746Z',\n      ACL: 'test',\n      test: 'test'\n    };\n    const parseWebSocket = {\n      send: jasmine.createSpy('send')\n    };\n    const client = new Client(1, parseWebSocket);\n    client.pushLeave(2, parseObjectJSON);\n    const lastCall = parseWebSocket.send.calls.first();\n    const messageJSON = JSON.parse(lastCall.args[0]);\n    expect(messageJSON.op).toBe('leave');\n    expect(messageJSON.clientId).toBe(1);\n    expect(messageJSON.requestId).toBe(2);\n    expect(messageJSON.object).toEqual(parseObjectJSON);\n  });","file":"Client.spec.js","skipped":false,"dir":"spec"},{"name":"should properly parse the SDK versions","suites":["ClientSDK"],"line":3,"updatePoint":{"line":3,"column":44,"index":122},"code":"  it('should properly parse the SDK versions', () => {\n    const clientSDKFromVersion = ClientSDK.fromString;\n    expect(clientSDKFromVersion('i1.1.1')).toEqual({\n      sdk: 'i',\n      version: '1.1.1'\n    });\n    expect(clientSDKFromVersion('i1')).toEqual({\n      sdk: 'i',\n      version: '1'\n    });\n    expect(clientSDKFromVersion('apple-tv1.13.0')).toEqual({\n      sdk: 'apple-tv',\n      version: '1.13.0'\n    });\n    expect(clientSDKFromVersion('js1.9.0')).toEqual({\n      sdk: 'js',\n      version: '1.9.0'\n    });\n  });","file":"ClientSDK.spec.js","skipped":false,"dir":"spec"},{"name":"should properly sastisfy","suites":["ClientSDK"],"line":22,"updatePoint":{"line":22,"column":30,"index":634},"code":"  it('should properly sastisfy', () => {\n    expect(ClientSDK.compatible({\n      js: '>=1.9.0'\n    })('js1.9.0')).toBe(true);\n    expect(ClientSDK.compatible({\n      js: '>=1.9.0'\n    })('js2.0.0')).toBe(true);\n    expect(ClientSDK.compatible({\n      js: '>=1.9.0'\n    })('js1.8.0')).toBe(false);\n    expect(ClientSDK.compatible({\n      js: '>=1.9.0'\n    })(undefined)).toBe(true);\n  });","file":"ClientSDK.spec.js","skipped":false,"dir":"spec"},{"name":"can load absolute cloud code file","suites":["Cloud Code"],"line":20,"updatePoint":{"line":20,"column":39,"index":630},"code":"  it('can load absolute cloud code file', done => {\n    reconfigureServer({\n      cloud: __dirname + '/cloud/cloudCodeRelativeFile.js'\n    }).then(() => {\n      Parse.Cloud.run('cloudCodeInFile', {}).then(result => {\n        expect(result).toEqual('It is possible to define cloud code in a file.');\n        done();\n      });\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"can load relative cloud code file","suites":["Cloud Code"],"line":30,"updatePoint":{"line":30,"column":39,"index":969},"code":"  it('can load relative cloud code file', done => {\n    reconfigureServer({\n      cloud: './spec/cloud/cloudCodeAbsoluteFile.js'\n    }).then(() => {\n      Parse.Cloud.run('cloudCodeInFile', {}).then(result => {\n        expect(result).toEqual('It is possible to define cloud code in a file.');\n        done();\n      });\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"can create functions","suites":["Cloud Code"],"line":40,"updatePoint":{"line":40,"column":26,"index":1289},"code":"  it('can create functions', done => {\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    });\n    Parse.Cloud.run('hello', {}).then(result => {\n      expect(result).toEqual('Hello world!');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"show warning on duplicate cloud functions","suites":["Cloud Code"],"line":49,"updatePoint":{"line":49,"column":47,"index":1550},"code":"  it('show warning on duplicate cloud functions', done => {\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'warn').and.callFake(() => {});\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    });\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    });\n    expect(logger.warn).toHaveBeenCalledWith('Warning: Duplicate cloud functions exist for hello. Only the last one will be used and the others will be ignored.');\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"is cleared cleared after the previous test","suites":["Cloud Code"],"line":61,"updatePoint":{"line":61,"column":48,"index":2049},"code":"  it('is cleared cleared after the previous test', done => {\n    Parse.Cloud.run('hello', {}).catch(error => {\n      expect(error.code).toEqual(Parse.Error.SCRIPT_FAILED);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave rejection","suites":["Cloud Code"],"line":67,"updatePoint":{"line":67,"column":32,"index":2233},"code":"  it('basic beforeSave rejection', function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveFail', function () {\n      throw new Error('You shall not pass!');\n    });\n    const obj = new Parse.Object('BeforeSaveFail');\n    obj.set('foo', 'bar');\n    obj.save().then(() => {\n      fail('Should not have been able to save BeforeSaveFailure class.');\n      done();\n    }, () => {\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"returns an error","suites":["Cloud Code"],"line":80,"updatePoint":{"line":80,"column":22,"index":2627},"code":"  it('returns an error', done => {\n    Parse.Cloud.define('cloudCodeWithError', () => {\n      /* eslint-disable no-undef */\n      foo.bar();\n      /* eslint-enable no-undef */\n      return 'I better throw an error.';\n    });\n    Parse.Cloud.run('cloudCodeWithError').then(() => done.fail('should not succeed'), e => {\n      expect(e).toEqual(new Parse.Error(Parse.Error.SCRIPT_FAILED, 'foo is not defined'));\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"returns an empty error","suites":["Cloud Code"],"line":92,"updatePoint":{"line":92,"column":28,"index":3070},"code":"  it('returns an empty error', done => {\n    Parse.Cloud.define('cloudCodeWithError', () => {\n      throw null;\n    });\n    Parse.Cloud.run('cloudCodeWithError').then(() => done.fail('should not succeed'), e => {\n      expect(e.code).toEqual(Parse.Error.SCRIPT_FAILED);\n      expect(e.message).toEqual('Script failed.');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeFind can throw string","suites":["Cloud Code"],"line":102,"updatePoint":{"line":102,"column":33,"index":3424},"code":"  it('beforeFind can throw string', async function (done) {\n    Parse.Cloud.beforeFind('beforeFind', () => {\n      throw 'throw beforeFind';\n    });\n    const obj = new Parse.Object('beforeFind');\n    obj.set('foo', 'bar');\n    await obj.save();\n    expect(obj.get('foo')).toBe('bar');\n    try {\n      const query = new Parse.Query('beforeFind');\n      await query.first();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SCRIPT_FAILED);\n      expect(e.message).toBe('throw beforeFind');\n      done();\n    }\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave rejection with custom error code","suites":["Cloud Code"],"line":119,"updatePoint":{"line":119,"column":49,"index":3962},"code":"  it('beforeSave rejection with custom error code', function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveFailWithErrorCode', function () {\n      throw new Parse.Error(999, 'Nope');\n    });\n    const obj = new Parse.Object('BeforeSaveFailWithErrorCode');\n    obj.set('foo', 'bar');\n    obj.save().then(function () {\n      fail('Should not have been able to save BeforeSaveFailWithErrorCode class.');\n      done();\n    }, function (error) {\n      expect(error.code).toEqual(999);\n      expect(error.message).toEqual('Nope');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave rejection via promise","suites":["Cloud Code"],"line":134,"updatePoint":{"line":134,"column":44,"index":4511},"code":"  it('basic beforeSave rejection via promise', function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveFailWithPromise', function () {\n      const query = new Parse.Query('Yolo');\n      return query.find().then(() => {\n        throw 'Nope';\n      }, () => {\n        return Promise.response();\n      });\n    });\n    const obj = new Parse.Object('BeforeSaveFailWithPromise');\n    obj.set('foo', 'bar');\n    obj.save().then(function () {\n      fail('Should not have been able to save BeforeSaveFailure class.');\n      done();\n    }, function (error) {\n      expect(error.code).toEqual(Parse.Error.SCRIPT_FAILED);\n      expect(error.message).toEqual('Nope');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeSave changed object success","suites":["Cloud Code"],"line":154,"updatePoint":{"line":154,"column":44,"index":5194},"code":"  it('test beforeSave changed object success', function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveChanged', function (req) {\n      req.object.set('foo', 'baz');\n    });\n    const obj = new Parse.Object('BeforeSaveChanged');\n    obj.set('foo', 'bar');\n    obj.save().then(function () {\n      const query = new Parse.Query('BeforeSaveChanged');\n      query.get(obj.id).then(function (objAgain) {\n        expect(objAgain.get('foo')).toEqual('baz');\n        done();\n      }, function (error) {\n        fail(error);\n        done();\n      });\n    }, function (error) {\n      fail(error);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeSave with invalid field","suites":["Cloud Code"],"line":174,"updatePoint":{"line":174,"column":40,"index":5805},"code":"  it('test beforeSave with invalid field', async () => {\n    Parse.Cloud.beforeSave('BeforeSaveChanged', function (req) {\n      req.object.set('length', 0);\n    });\n    const obj = new Parse.Object('BeforeSaveChanged');\n    obj.set('foo', 'bar');\n    try {\n      await obj.save();\n      fail('should not succeed');\n    } catch (e) {\n      expect(e.message).toBe('Invalid field name: length.');\n    }\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeSave changed object fail doesn't change object","suites":["Cloud Code"],"line":187,"updatePoint":{"line":187,"column":63,"index":6234},"code":"  it(\"test beforeSave changed object fail doesn't change object\", async function () {\n    Parse.Cloud.beforeSave('BeforeSaveChanged', function (req) {\n      if (req.object.has('fail')) {\n        return Promise.reject(new Error('something went wrong'));\n      }\n      return Promise.resolve();\n    });\n    const obj = new Parse.Object('BeforeSaveChanged');\n    obj.set('foo', 'bar');\n    await obj.save();\n    obj.set('foo', 'baz').set('fail', true);\n    try {\n      await obj.save();\n    } catch (e) {\n      await obj.fetch();\n      expect(obj.get('foo')).toBe('bar');\n    }\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeSave returns value on create and update","suites":["Cloud Code"],"line":205,"updatePoint":{"line":205,"column":56,"index":6808},"code":"  it('test beforeSave returns value on create and update', done => {\n    Parse.Cloud.beforeSave('BeforeSaveChanged', function (req) {\n      req.object.set('foo', 'baz');\n    });\n    const obj = new Parse.Object('BeforeSaveChanged');\n    obj.set('foo', 'bing');\n    obj.save().then(() => {\n      expect(obj.get('foo')).toEqual('baz');\n      obj.set('foo', 'bar');\n      return obj.save().then(() => {\n        expect(obj.get('foo')).toEqual('baz');\n        done();\n      });\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeSave applies changes when beforeSave returns true","suites":["Cloud Code"],"line":220,"updatePoint":{"line":220,"column":66,"index":7305},"code":"  it('test beforeSave applies changes when beforeSave returns true', done => {\n    Parse.Cloud.beforeSave('Insurance', function (req) {\n      req.object.set('rate', '$49.99/Month');\n      return true;\n    });\n    const insurance = new Parse.Object('Insurance');\n    insurance.set('rate', '$5.00/Month');\n    insurance.save().then(insurance => {\n      expect(insurance.get('rate')).toEqual('$49.99/Month');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeSave applies changes and resolves returned promise","suites":["Cloud Code"],"line":232,"updatePoint":{"line":232,"column":67,"index":7740},"code":"  it('test beforeSave applies changes and resolves returned promise', done => {\n    Parse.Cloud.beforeSave('Insurance', function (req) {\n      req.object.set('rate', '$49.99/Month');\n      return new Parse.Query('Pet').get(req.object.get('pet').id).then(pet => {\n        pet.set('healthy', true);\n        return pet.save();\n      });\n    });\n    const pet = new Parse.Object('Pet');\n    pet.set('healthy', false);\n    pet.save().then(pet => {\n      const insurance = new Parse.Object('Insurance');\n      insurance.set('pet', pet);\n      insurance.set('rate', '$5.00/Month');\n      insurance.save().then(insurance => {\n        expect(insurance.get('rate')).toEqual('$49.99/Month');\n        new Parse.Query('Pet').get(insurance.get('pet').id).then(pet => {\n          expect(pet.get('healthy')).toEqual(true);\n          done();\n        });\n      });\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave should be called only if user fulfills permissions","suites":["Cloud Code"],"line":255,"updatePoint":{"line":255,"column":67,"index":8601},"code":"  it('beforeSave should be called only if user fulfills permissions', async () => {\n    const triggeruser = new Parse.User();\n    triggeruser.setUsername('triggeruser');\n    triggeruser.setPassword('triggeruser');\n    await triggeruser.signUp();\n    const triggeruser2 = new Parse.User();\n    triggeruser2.setUsername('triggeruser2');\n    triggeruser2.setPassword('triggeruser2');\n    await triggeruser2.signUp();\n    const triggeruser3 = new Parse.User();\n    triggeruser3.setUsername('triggeruser3');\n    triggeruser3.setPassword('triggeruser3');\n    await triggeruser3.signUp();\n    const triggeruser4 = new Parse.User();\n    triggeruser4.setUsername('triggeruser4');\n    triggeruser4.setPassword('triggeruser4');\n    await triggeruser4.signUp();\n    const triggeruser5 = new Parse.User();\n    triggeruser5.setUsername('triggeruser5');\n    triggeruser5.setPassword('triggeruser5');\n    await triggeruser5.signUp();\n    const triggerroleacl = new Parse.ACL();\n    triggerroleacl.setPublicReadAccess(true);\n    const triggerrole = new Parse.Role();\n    triggerrole.setName('triggerrole');\n    triggerrole.setACL(triggerroleacl);\n    triggerrole.getUsers().add(triggeruser);\n    triggerrole.getUsers().add(triggeruser3);\n    await triggerrole.save();\n    const config = Config.get('test');\n    const schema = await config.database.loadSchema();\n    await schema.addClassIfNotExists('triggerclass', {\n      someField: {\n        type: 'String'\n      },\n      pointerToUser: {\n        type: 'Pointer',\n        targetClass: '_User'\n      }\n    }, {\n      find: {\n        'role:triggerrole': true,\n        [triggeruser.id]: true,\n        [triggeruser2.id]: true\n      },\n      create: {\n        'role:triggerrole': true,\n        [triggeruser.id]: true,\n        [triggeruser2.id]: true\n      },\n      get: {\n        'role:triggerrole': true,\n        [triggeruser.id]: true,\n        [triggeruser2.id]: true\n      },\n      update: {\n        'role:triggerrole': true,\n        [triggeruser.id]: true,\n        [triggeruser2.id]: true\n      },\n      addField: {\n        'role:triggerrole': true,\n        [triggeruser.id]: true,\n        [triggeruser2.id]: true\n      },\n      delete: {\n        'role:triggerrole': true,\n        [triggeruser.id]: true,\n        [triggeruser2.id]: true\n      },\n      readUserFields: ['pointerToUser'],\n      writeUserFields: ['pointerToUser']\n    }, {});\n    let called = 0;\n    Parse.Cloud.beforeSave('triggerclass', () => {\n      called++;\n    });\n    const triggerobject = new Parse.Object('triggerclass');\n    triggerobject.set('someField', 'someValue');\n    triggerobject.set('someField2', 'someValue');\n    const triggerobjectacl = new Parse.ACL();\n    triggerobjectacl.setPublicReadAccess(false);\n    triggerobjectacl.setPublicWriteAccess(false);\n    triggerobjectacl.setRoleReadAccess(triggerrole, true);\n    triggerobjectacl.setRoleWriteAccess(triggerrole, true);\n    triggerobjectacl.setReadAccess(triggeruser.id, true);\n    triggerobjectacl.setWriteAccess(triggeruser.id, true);\n    triggerobjectacl.setReadAccess(triggeruser2.id, true);\n    triggerobjectacl.setWriteAccess(triggeruser2.id, true);\n    triggerobject.setACL(triggerobjectacl);\n    await triggerobject.save(undefined, {\n      sessionToken: triggeruser.getSessionToken()\n    });\n    expect(called).toBe(1);\n    await triggerobject.save(undefined, {\n      sessionToken: triggeruser.getSessionToken()\n    });\n    expect(called).toBe(2);\n    await triggerobject.save(undefined, {\n      sessionToken: triggeruser2.getSessionToken()\n    });\n    expect(called).toBe(3);\n    await triggerobject.save(undefined, {\n      sessionToken: triggeruser3.getSessionToken()\n    });\n    expect(called).toBe(4);\n    const triggerobject2 = new Parse.Object('triggerclass');\n    triggerobject2.set('someField', 'someValue');\n    triggerobject2.set('someField22', 'someValue');\n    const triggerobjectacl2 = new Parse.ACL();\n    triggerobjectacl2.setPublicReadAccess(false);\n    triggerobjectacl2.setPublicWriteAccess(false);\n    triggerobjectacl2.setReadAccess(triggeruser.id, true);\n    triggerobjectacl2.setWriteAccess(triggeruser.id, true);\n    triggerobjectacl2.setReadAccess(triggeruser2.id, true);\n    triggerobjectacl2.setWriteAccess(triggeruser2.id, true);\n    triggerobjectacl2.setReadAccess(triggeruser5.id, true);\n    triggerobjectacl2.setWriteAccess(triggeruser5.id, true);\n    triggerobject2.setACL(triggerobjectacl2);\n    await triggerobject2.save(undefined, {\n      sessionToken: triggeruser2.getSessionToken()\n    });\n    expect(called).toBe(5);\n    await triggerobject2.save(undefined, {\n      sessionToken: triggeruser2.getSessionToken()\n    });\n    expect(called).toBe(6);\n    await triggerobject2.save(undefined, {\n      sessionToken: triggeruser.getSessionToken()\n    });\n    expect(called).toBe(7);\n    let catched = false;\n    try {\n      await triggerobject2.save(undefined, {\n        sessionToken: triggeruser3.getSessionToken()\n      });\n    } catch (e) {\n      catched = true;\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    expect(catched).toBe(true);\n    expect(called).toBe(7);\n    catched = false;\n    try {\n      await triggerobject2.save(undefined, {\n        sessionToken: triggeruser4.getSessionToken()\n      });\n    } catch (e) {\n      catched = true;\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    expect(catched).toBe(true);\n    expect(called).toBe(7);\n    catched = false;\n    try {\n      await triggerobject2.save(undefined, {\n        sessionToken: triggeruser5.getSessionToken()\n      });\n    } catch (e) {\n      catched = true;\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    expect(catched).toBe(true);\n    expect(called).toBe(7);\n    const triggerobject3 = new Parse.Object('triggerclass');\n    triggerobject3.set('someField', 'someValue');\n    triggerobject3.set('someField33', 'someValue');\n    catched = false;\n    try {\n      await triggerobject3.save(undefined, {\n        sessionToken: triggeruser4.getSessionToken()\n      });\n    } catch (e) {\n      catched = true;\n      expect(e.code).toBe(119);\n    }\n    expect(catched).toBe(true);\n    expect(called).toBe(7);\n    catched = false;\n    try {\n      await triggerobject3.save(undefined, {\n        sessionToken: triggeruser5.getSessionToken()\n      });\n    } catch (e) {\n      catched = true;\n      expect(e.code).toBe(119);\n    }\n    expect(catched).toBe(true);\n    expect(called).toBe(7);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test afterSave ran and created an object","suites":["Cloud Code"],"line":445,"updatePoint":{"line":445,"column":46,"index":15006},"code":"  it('test afterSave ran and created an object', function (done) {\n    Parse.Cloud.afterSave('AfterSaveTest', function (req) {\n      const obj = new Parse.Object('AfterSaveProof');\n      obj.set('proof', req.object.id);\n      obj.save().then(test);\n    });\n    const obj = new Parse.Object('AfterSaveTest');\n    obj.save();\n    function test() {\n      const query = new Parse.Query('AfterSaveProof');\n      query.equalTo('proof', obj.id);\n      query.find().then(function (results) {\n        expect(results.length).toEqual(1);\n        done();\n      }, function (error) {\n        fail(error);\n        done();\n      });\n    }\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test afterSave ran on created object and returned a promise","suites":["Cloud Code"],"line":465,"updatePoint":{"line":465,"column":65,"index":15655},"code":"  it('test afterSave ran on created object and returned a promise', function (done) {\n    Parse.Cloud.afterSave('AfterSaveTest2', function (req) {\n      const obj = req.object;\n      if (!obj.existed()) {\n        return new Promise(resolve => {\n          setTimeout(function () {\n            obj.set('proof', obj.id);\n            obj.save().then(function () {\n              resolve();\n            });\n          }, 1000);\n        });\n      }\n    });\n    const obj = new Parse.Object('AfterSaveTest2');\n    obj.save().then(function () {\n      const query = new Parse.Query('AfterSaveTest2');\n      query.equalTo('proof', obj.id);\n      query.find().then(function (results) {\n        expect(results.length).toEqual(1);\n        const savedObject = results[0];\n        expect(savedObject.get('proof')).toEqual(obj.id);\n        done();\n      }, function (error) {\n        fail(error);\n        done();\n      });\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test afterSave ignoring promise, object not found","suites":["Cloud Code"],"line":496,"updatePoint":{"line":496,"column":56,"index":16608},"skipped":true,"code":"  xit('test afterSave ignoring promise, object not found', function (done) {\n    Parse.Cloud.afterSave('AfterSaveTest2', function (req) {\n      const obj = req.object;\n      if (!obj.existed()) {\n        return new Promise(resolve => {\n          setTimeout(function () {\n            obj.set('proof', obj.id);\n            obj.save().then(function () {\n              resolve();\n            });\n          }, 1000);\n        });\n      }\n    });\n    const obj = new Parse.Object('AfterSaveTest2');\n    obj.save().then(function () {\n      done();\n    });\n    const query = new Parse.Query('AfterSaveTest2');\n    query.equalTo('proof', obj.id);\n    query.find().then(function (results) {\n      expect(results.length).toEqual(0);\n    }, function (error) {\n      fail(error);\n    });\n  });","file":"CloudCode.spec.js","dir":"spec"},{"name":"test afterSave rejecting promise","suites":["Cloud Code"],"line":522,"updatePoint":{"line":522,"column":38,"index":17370},"code":"  it('test afterSave rejecting promise', function (done) {\n    Parse.Cloud.afterSave('AfterSaveTest2', function () {\n      return new Promise((resolve, reject) => {\n        setTimeout(function () {\n          reject('THIS SHOULD BE IGNORED');\n        }, 1000);\n      });\n    });\n    const obj = new Parse.Object('AfterSaveTest2');\n    obj.save().then(function () {\n      done();\n    }, function (error) {\n      fail(error);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test afterDelete returning promise, object is deleted when destroy resolves","suites":["Cloud Code"],"line":538,"updatePoint":{"line":538,"column":81,"index":17864},"code":"  it('test afterDelete returning promise, object is deleted when destroy resolves', function (done) {\n    Parse.Cloud.afterDelete('AfterDeleteTest2', function (req) {\n      return new Promise(resolve => {\n        setTimeout(function () {\n          const obj = new Parse.Object('AfterDeleteTestProof');\n          obj.set('proof', req.object.id);\n          obj.save().then(function () {\n            resolve();\n          });\n        }, 1000);\n      });\n    });\n    const errorHandler = function (error) {\n      fail(error);\n      done();\n    };\n    const obj = new Parse.Object('AfterDeleteTest2');\n    obj.save().then(function () {\n      obj.destroy().then(function () {\n        const query = new Parse.Query('AfterDeleteTestProof');\n        query.equalTo('proof', obj.id);\n        query.find().then(function (results) {\n          expect(results.length).toEqual(1);\n          const deletedObject = results[0];\n          expect(deletedObject.get('proof')).toEqual(obj.id);\n          done();\n        }, errorHandler);\n      }, errorHandler);\n    }, errorHandler);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test afterDelete ignoring promise, object is not yet deleted","suites":["Cloud Code"],"line":568,"updatePoint":{"line":568,"column":66,"index":18915},"code":"  it('test afterDelete ignoring promise, object is not yet deleted', function (done) {\n    Parse.Cloud.afterDelete('AfterDeleteTest2', function (req) {\n      return new Promise(resolve => {\n        setTimeout(function () {\n          const obj = new Parse.Object('AfterDeleteTestProof');\n          obj.set('proof', req.object.id);\n          obj.save().then(function () {\n            resolve();\n          });\n        }, 1000);\n      });\n    });\n    const errorHandler = function (error) {\n      fail(error);\n      done();\n    };\n    const obj = new Parse.Object('AfterDeleteTest2');\n    obj.save().then(function () {\n      obj.destroy().then(function () {\n        done();\n      });\n      const query = new Parse.Query('AfterDeleteTestProof');\n      query.equalTo('proof', obj.id);\n      query.find().then(function (results) {\n        expect(results.length).toEqual(0);\n      }, errorHandler);\n    }, errorHandler);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeSave happens on update","suites":["Cloud Code"],"line":596,"updatePoint":{"line":596,"column":39,"index":19807},"code":"  it('test beforeSave happens on update', function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveChanged', function (req) {\n      req.object.set('foo', 'baz');\n    });\n    const obj = new Parse.Object('BeforeSaveChanged');\n    obj.set('foo', 'bar');\n    obj.save().then(function () {\n      obj.set('foo', 'bar');\n      return obj.save();\n    }).then(function () {\n      const query = new Parse.Query('BeforeSaveChanged');\n      return query.get(obj.id).then(function (objAgain) {\n        expect(objAgain.get('foo')).toEqual('baz');\n        done();\n      });\n    }, function (error) {\n      fail(error);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeDelete failure","suites":["Cloud Code"],"line":616,"updatePoint":{"line":616,"column":31,"index":20431},"code":"  it('test beforeDelete failure', function (done) {\n    Parse.Cloud.beforeDelete('BeforeDeleteFail', function () {\n      throw 'Nope';\n    });\n    const obj = new Parse.Object('BeforeDeleteFail');\n    let id;\n    obj.set('foo', 'bar');\n    obj.save().then(() => {\n      id = obj.id;\n      return obj.destroy();\n    }).then(() => {\n      fail('obj.destroy() should have failed, but it succeeded');\n      done();\n    }, error => {\n      expect(error.code).toEqual(Parse.Error.SCRIPT_FAILED);\n      expect(error.message).toEqual('Nope');\n      const objAgain = new Parse.Object('BeforeDeleteFail', {\n        objectId: id\n      });\n      return objAgain.fetch();\n    }).then(objAgain => {\n      if (objAgain) {\n        expect(objAgain.get('foo')).toEqual('bar');\n      } else {\n        fail('unable to fetch the object ', id);\n      }\n      done();\n    }, error => {\n      // We should have been able to fetch the object again\n      fail(error);\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeDelete rejection via promise","suites":["Cloud Code"],"line":648,"updatePoint":{"line":648,"column":46,"index":21402},"code":"  it('basic beforeDelete rejection via promise', function (done) {\n    Parse.Cloud.beforeSave('BeforeDeleteFailWithPromise', function () {\n      const query = new Parse.Query('Yolo');\n      return query.find().then(() => {\n        throw 'Nope';\n      });\n    });\n    const obj = new Parse.Object('BeforeDeleteFailWithPromise');\n    obj.set('foo', 'bar');\n    obj.save().then(function () {\n      fail('Should not have been able to save BeforeSaveFailure class.');\n      done();\n    }, function (error) {\n      expect(error.code).toEqual(Parse.Error.SCRIPT_FAILED);\n      expect(error.message).toEqual('Nope');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test afterDelete ran and created an object","suites":["Cloud Code"],"line":666,"updatePoint":{"line":666,"column":48,"index":22041},"code":"  it('test afterDelete ran and created an object', function (done) {\n    Parse.Cloud.afterDelete('AfterDeleteTest', function (req) {\n      const obj = new Parse.Object('AfterDeleteProof');\n      obj.set('proof', req.object.id);\n      obj.save().then(test);\n    });\n    const obj = new Parse.Object('AfterDeleteTest');\n    obj.save().then(function () {\n      obj.destroy();\n    });\n    function test() {\n      const query = new Parse.Query('AfterDeleteProof');\n      query.equalTo('proof', obj.id);\n      query.find().then(function (results) {\n        expect(results.length).toEqual(1);\n        done();\n      }, function (error) {\n        fail(error);\n        done();\n      });\n    }\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test cloud function return types","suites":["Cloud Code"],"line":688,"updatePoint":{"line":688,"column":38,"index":22720},"code":"  it('test cloud function return types', function (done) {\n    Parse.Cloud.define('foo', function () {\n      return {\n        object: {\n          __type: 'Object',\n          className: 'Foo',\n          objectId: '123',\n          x: 2,\n          relation: {\n            __type: 'Object',\n            className: 'Bar',\n            objectId: '234',\n            x: 3\n          }\n        },\n        array: [{\n          __type: 'Object',\n          className: 'Bar',\n          objectId: '345',\n          x: 2\n        }],\n        a: 2\n      };\n    });\n    Parse.Cloud.run('foo').then(result => {\n      expect(result.object instanceof Parse.Object).toBeTruthy();\n      if (!result.object) {\n        fail('Unable to run foo');\n        done();\n        return;\n      }\n      expect(result.object.className).toEqual('Foo');\n      expect(result.object.get('x')).toEqual(2);\n      const bar = result.object.get('relation');\n      expect(bar instanceof Parse.Object).toBeTruthy();\n      expect(bar.className).toEqual('Bar');\n      expect(bar.get('x')).toEqual(3);\n      expect(Array.isArray(result.array)).toEqual(true);\n      expect(result.array[0] instanceof Parse.Object).toBeTruthy();\n      expect(result.array[0].get('x')).toEqual(2);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test cloud function request params types","suites":["Cloud Code"],"line":731,"updatePoint":{"line":731,"column":46,"index":23980},"code":"  it('test cloud function request params types', function (done) {\n    Parse.Cloud.define('params', function (req) {\n      expect(req.params.date instanceof Date).toBe(true);\n      expect(req.params.date.getTime()).toBe(1463907600000);\n      expect(req.params.dateList[0] instanceof Date).toBe(true);\n      expect(req.params.dateList[0].getTime()).toBe(1463907600000);\n      expect(req.params.complexStructure.date[0] instanceof Date).toBe(true);\n      expect(req.params.complexStructure.date[0].getTime()).toBe(1463907600000);\n      expect(req.params.complexStructure.deepDate.date[0] instanceof Date).toBe(true);\n      expect(req.params.complexStructure.deepDate.date[0].getTime()).toBe(1463907600000);\n      expect(req.params.complexStructure.deepDate2[0].date instanceof Date).toBe(true);\n      expect(req.params.complexStructure.deepDate2[0].date.getTime()).toBe(1463907600000);\n      // Regression for #2294\n      expect(req.params.file instanceof Parse.File).toBe(true);\n      expect(req.params.file.url()).toEqual('https://some.url');\n      // Regression for #2204\n      expect(req.params.array).toEqual(['a', 'b', 'c']);\n      expect(Array.isArray(req.params.array)).toBe(true);\n      expect(req.params.arrayOfArray).toEqual([['a', 'b', 'c'], ['d', 'e', 'f']]);\n      expect(Array.isArray(req.params.arrayOfArray)).toBe(true);\n      expect(Array.isArray(req.params.arrayOfArray[0])).toBe(true);\n      expect(Array.isArray(req.params.arrayOfArray[1])).toBe(true);\n      return {};\n    });\n    const params = {\n      date: {\n        __type: 'Date',\n        iso: '2016-05-22T09:00:00.000Z'\n      },\n      dateList: [{\n        __type: 'Date',\n        iso: '2016-05-22T09:00:00.000Z'\n      }],\n      lol: 'hello',\n      complexStructure: {\n        date: [{\n          __type: 'Date',\n          iso: '2016-05-22T09:00:00.000Z'\n        }],\n        deepDate: {\n          date: [{\n            __type: 'Date',\n            iso: '2016-05-22T09:00:00.000Z'\n          }]\n        },\n        deepDate2: [{\n          date: {\n            __type: 'Date',\n            iso: '2016-05-22T09:00:00.000Z'\n          }\n        }]\n      },\n      file: Parse.File.fromJSON({\n        __type: 'File',\n        name: 'name',\n        url: 'https://some.url'\n      }),\n      array: ['a', 'b', 'c'],\n      arrayOfArray: [['a', 'b', 'c'], ['d', 'e', 'f']]\n    };\n    Parse.Cloud.run('params', params).then(() => {\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test cloud function should echo keys","suites":["Cloud Code"],"line":795,"updatePoint":{"line":795,"column":42,"index":26389},"code":"  it('test cloud function should echo keys', function (done) {\n    Parse.Cloud.define('echoKeys', function () {\n      return {\n        applicationId: Parse.applicationId,\n        masterKey: Parse.masterKey,\n        javascriptKey: Parse.javascriptKey\n      };\n    });\n    Parse.Cloud.run('echoKeys').then(result => {\n      expect(result.applicationId).toEqual(Parse.applicationId);\n      expect(result.masterKey).toEqual(Parse.masterKey);\n      expect(result.javascriptKey).toEqual(Parse.javascriptKey);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should properly create an object in before save","suites":["Cloud Code"],"line":810,"updatePoint":{"line":810,"column":53,"index":26931},"code":"  it('should properly create an object in before save', done => {\n    Parse.Cloud.beforeSave('BeforeSaveChanged', function (req) {\n      req.object.set('foo', 'baz');\n    });\n    Parse.Cloud.define('createBeforeSaveChangedObject', function () {\n      const obj = new Parse.Object('BeforeSaveChanged');\n      return obj.save().then(() => {\n        return obj;\n      });\n    });\n    Parse.Cloud.run('createBeforeSaveChangedObject').then(res => {\n      expect(res.get('foo')).toEqual('baz');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"dirtyKeys are set on update","suites":["Cloud Code"],"line":825,"updatePoint":{"line":825,"column":33,"index":27428},"code":"  it('dirtyKeys are set on update', done => {\n    let triggerTime = 0;\n    // Register a mock beforeSave hook\n    Parse.Cloud.beforeSave('GameScore', req => {\n      const object = req.object;\n      expect(object instanceof Parse.Object).toBeTruthy();\n      expect(object.get('fooAgain')).toEqual('barAgain');\n      if (triggerTime == 0) {\n        // Create\n        expect(object.get('foo')).toEqual('bar');\n      } else if (triggerTime == 1) {\n        // Update\n        expect(object.dirtyKeys()).toEqual(['foo']);\n        expect(object.dirty('foo')).toBeTruthy();\n        expect(object.get('foo')).toEqual('baz');\n      } else {\n        throw new Error();\n      }\n      triggerTime++;\n    });\n    const obj = new Parse.Object('GameScore');\n    obj.set('foo', 'bar');\n    obj.set('fooAgain', 'barAgain');\n    obj.save().then(() => {\n      // We only update foo\n      obj.set('foo', 'baz');\n      return obj.save();\n    }).then(() => {\n      // Make sure the checking has been triggered\n      expect(triggerTime).toBe(2);\n      done();\n    }, function (error) {\n      fail(error);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeSave unchanged success","suites":["Cloud Code"],"line":861,"updatePoint":{"line":861,"column":39,"index":28542},"code":"  it('test beforeSave unchanged success', function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveUnchanged', function () {\n      return;\n    });\n    const obj = new Parse.Object('BeforeSaveUnchanged');\n    obj.set('foo', 'bar');\n    obj.save().then(function () {\n      done();\n    }, function (error) {\n      fail(error);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeDelete success","suites":["Cloud Code"],"line":874,"updatePoint":{"line":874,"column":31,"index":28885},"code":"  it('test beforeDelete success', function (done) {\n    Parse.Cloud.beforeDelete('BeforeDeleteTest', function () {\n      return;\n    });\n    const obj = new Parse.Object('BeforeDeleteTest');\n    obj.set('foo', 'bar');\n    obj.save().then(function () {\n      return obj.destroy();\n    }).then(function () {\n      const objAgain = new Parse.Object('BeforeDeleteTest', obj.id);\n      return objAgain.fetch().then(fail, () => done());\n    }, function (error) {\n      fail(error);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test save triggers get user","suites":["Cloud Code"],"line":890,"updatePoint":{"line":890,"column":33,"index":29391},"code":"  it('test save triggers get user', async done => {\n    Parse.Cloud.beforeSave('SaveTriggerUser', function (req) {\n      if (req.user && req.user.id) {\n        return;\n      } else {\n        throw new Error('No user present on request object for beforeSave.');\n      }\n    });\n    Parse.Cloud.afterSave('SaveTriggerUser', function (req) {\n      if (!req.user || !req.user.id) {\n        console.log('No user present on request object for afterSave.');\n      }\n    });\n    const user = new Parse.User();\n    user.set('password', 'asdf');\n    user.set('email', 'asdf@example.com');\n    user.set('username', 'zxcv');\n    await user.signUp();\n    const obj = new Parse.Object('SaveTriggerUser');\n    obj.save().then(function () {\n      done();\n    }, function (error) {\n      fail(error);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave change propagates through the save response","suites":["Cloud Code"],"line":916,"updatePoint":{"line":916,"column":60,"index":30230},"code":"  it('beforeSave change propagates through the save response', done => {\n    Parse.Cloud.beforeSave('ChangingObject', function (request) {\n      request.object.set('foo', 'baz');\n    });\n    const obj = new Parse.Object('ChangingObject');\n    obj.save({\n      foo: 'bar'\n    }).then(objAgain => {\n      expect(objAgain.get('foo')).toEqual('baz');\n      done();\n    }, () => {\n      fail('Should not have failed to save.');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave change propagates through the afterSave #1931","suites":["Cloud Code"],"line":931,"updatePoint":{"line":931,"column":62,"index":30683},"code":"  it('beforeSave change propagates through the afterSave #1931', done => {\n    Parse.Cloud.beforeSave('ChangingObject', function (request) {\n      request.object.unset('file');\n      request.object.unset('date');\n    });\n    Parse.Cloud.afterSave('ChangingObject', function (request) {\n      expect(request.object.has('file')).toBe(false);\n      expect(request.object.has('date')).toBe(false);\n      expect(request.object.get('file')).toBeUndefined();\n      return Promise.resolve();\n    });\n    const file = new Parse.File('yolo.txt', [1, 2, 3], 'text/plain');\n    file.save().then(() => {\n      const obj = new Parse.Object('ChangingObject');\n      return obj.save({\n        file,\n        date: new Date()\n      });\n    }).then(() => {\n      done();\n    }, () => {\n      fail();\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"test cloud function parameter validation success","suites":["Cloud Code"],"line":956,"updatePoint":{"line":956,"column":54,"index":31484},"code":"  it('test cloud function parameter validation success', done => {\n    // Register a function with validation\n    Parse.Cloud.define('functionWithParameterValidation', () => {\n      return 'works';\n    }, request => {\n      return request.params.success === 100;\n    });\n    Parse.Cloud.run('functionWithParameterValidation', {\n      success: 100\n    }).then(() => {\n      done();\n    }, () => {\n      fail('Validation should not have failed.');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"doesnt receive stale user in cloud code functions after user has been updated with master key (regression test for #1836)","suites":["Cloud Code"],"line":972,"updatePoint":{"line":972,"column":127,"index":32031},"code":"  it('doesnt receive stale user in cloud code functions after user has been updated with master key (regression test for #1836)', done => {\n    Parse.Cloud.define('testQuery', function (request) {\n      return request.user.get('data');\n    });\n    Parse.User.signUp('user', 'pass').then(user => {\n      user.set('data', 'AAA');\n      return user.save();\n    }).then(() => Parse.Cloud.run('testQuery')).then(result => {\n      expect(result).toEqual('AAA');\n      Parse.User.current().set('data', 'BBB');\n      return Parse.User.current().save(null, {\n        useMasterKey: true\n      });\n    }).then(() => Parse.Cloud.run('testQuery')).then(result => {\n      expect(result).toEqual('BBB');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"clears out the user cache for all sessions when the user is changed","suites":["Cloud Code"],"line":990,"updatePoint":{"line":990,"column":73,"index":32694},"code":"  it('clears out the user cache for all sessions when the user is changed', done => {\n    let session1;\n    let session2;\n    let user;\n    const cacheAdapter = new InMemoryCacheAdapter({\n      ttl: 100000000\n    });\n    reconfigureServer({\n      cacheAdapter\n    }).then(() => {\n      Parse.Cloud.define('checkStaleUser', request => {\n        return request.user.get('data');\n      });\n      user = new Parse.User();\n      user.set('username', 'test');\n      user.set('password', 'moon-y');\n      user.set('data', 'first data');\n      return user.signUp();\n    }).then(user => {\n      session1 = user.getSessionToken();\n      return request({\n        url: 'http://localhost:8378/1/login?username=test&password=moon-y',\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest'\n        }\n      });\n    }).then(response => {\n      session2 = response.data.sessionToken;\n      //Ensure both session tokens are in the cache\n      return Parse.Cloud.run('checkStaleUser', {\n        sessionToken: session2\n      });\n    }).then(() => request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/functions/checkStaleUser',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Session-Token': session2\n      }\n    })).then(() => Promise.all([cacheAdapter.get('test:user:' + session1), cacheAdapter.get('test:user:' + session2)])).then(cachedVals => {\n      expect(cachedVals[0].objectId).toEqual(user.id);\n      expect(cachedVals[1].objectId).toEqual(user.id);\n\n      //Change with session 1 and then read with session 2.\n      user.set('data', 'second data');\n      return user.save();\n    }).then(() => request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/functions/checkStaleUser',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Session-Token': session2\n      }\n    })).then(response => {\n      expect(response.data.result).toEqual('second data');\n      done();\n    }).catch(done.fail);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"trivial beforeSave should not affect fetched pointers (regression test for #1238)","suites":["Cloud Code"],"line":1051,"updatePoint":{"line":1051,"column":87,"index":34797},"code":"  it('trivial beforeSave should not affect fetched pointers (regression test for #1238)', done => {\n    Parse.Cloud.beforeSave('BeforeSaveUnchanged', () => {});\n    const TestObject = Parse.Object.extend('TestObject');\n    const NoBeforeSaveObject = Parse.Object.extend('NoBeforeSave');\n    const BeforeSaveObject = Parse.Object.extend('BeforeSaveUnchanged');\n    const aTestObject = new TestObject();\n    aTestObject.set('foo', 'bar');\n    aTestObject.save().then(aTestObject => {\n      const aNoBeforeSaveObj = new NoBeforeSaveObject();\n      aNoBeforeSaveObj.set('aTestObject', aTestObject);\n      expect(aNoBeforeSaveObj.get('aTestObject').get('foo')).toEqual('bar');\n      return aNoBeforeSaveObj.save();\n    }).then(aNoBeforeSaveObj => {\n      expect(aNoBeforeSaveObj.get('aTestObject').get('foo')).toEqual('bar');\n      const aBeforeSaveObj = new BeforeSaveObject();\n      aBeforeSaveObj.set('aTestObject', aTestObject);\n      expect(aBeforeSaveObj.get('aTestObject').get('foo')).toEqual('bar');\n      return aBeforeSaveObj.save();\n    }).then(aBeforeSaveObj => {\n      expect(aBeforeSaveObj.get('aTestObject').get('foo')).toEqual('bar');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave should not affect fetched pointers","suites":["Cloud Code"],"line":1074,"updatePoint":{"line":1074,"column":51,"index":35935},"code":"  it('beforeSave should not affect fetched pointers', done => {\n    Parse.Cloud.beforeSave('BeforeSaveUnchanged', () => {});\n    Parse.Cloud.beforeSave('BeforeSaveChanged', function (req) {\n      req.object.set('foo', 'baz');\n    });\n    const TestObject = Parse.Object.extend('TestObject');\n    const BeforeSaveUnchangedObject = Parse.Object.extend('BeforeSaveUnchanged');\n    const BeforeSaveChangedObject = Parse.Object.extend('BeforeSaveChanged');\n    const aTestObject = new TestObject();\n    aTestObject.set('foo', 'bar');\n    aTestObject.save().then(aTestObject => {\n      const aBeforeSaveUnchangedObject = new BeforeSaveUnchangedObject();\n      aBeforeSaveUnchangedObject.set('aTestObject', aTestObject);\n      expect(aBeforeSaveUnchangedObject.get('aTestObject').get('foo')).toEqual('bar');\n      return aBeforeSaveUnchangedObject.save();\n    }).then(aBeforeSaveUnchangedObject => {\n      expect(aBeforeSaveUnchangedObject.get('aTestObject').get('foo')).toEqual('bar');\n      const aBeforeSaveChangedObject = new BeforeSaveChangedObject();\n      aBeforeSaveChangedObject.set('aTestObject', aTestObject);\n      expect(aBeforeSaveChangedObject.get('aTestObject').get('foo')).toEqual('bar');\n      return aBeforeSaveChangedObject.save();\n    }).then(aBeforeSaveChangedObject => {\n      expect(aBeforeSaveChangedObject.get('aTestObject').get('foo')).toEqual('bar');\n      expect(aBeforeSaveChangedObject.get('foo')).toEqual('baz');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should fully delete objects when using `unset` with beforeSave (regression test for #1840)","suites":["Cloud Code"],"line":1101,"updatePoint":{"line":1101,"column":96,"index":37446},"code":"  it('should fully delete objects when using `unset` with beforeSave (regression test for #1840)', done => {\n    const TestObject = Parse.Object.extend('TestObject');\n    const NoBeforeSaveObject = Parse.Object.extend('NoBeforeSave');\n    const BeforeSaveObject = Parse.Object.extend('BeforeSaveChanged');\n    Parse.Cloud.beforeSave('BeforeSaveChanged', req => {\n      const object = req.object;\n      object.set('before', 'save');\n    });\n    Parse.Cloud.define('removeme', () => {\n      const testObject = new TestObject();\n      return testObject.save().then(testObject => {\n        const object = new NoBeforeSaveObject({\n          remove: testObject\n        });\n        return object.save();\n      }).then(object => {\n        object.unset('remove');\n        return object.save();\n      });\n    });\n    Parse.Cloud.define('removeme2', () => {\n      const testObject = new TestObject();\n      return testObject.save().then(testObject => {\n        const object = new BeforeSaveObject({\n          remove: testObject\n        });\n        return object.save();\n      }).then(object => {\n        object.unset('remove');\n        return object.save();\n      });\n    });\n    Parse.Cloud.run('removeme').then(aNoBeforeSaveObj => {\n      expect(aNoBeforeSaveObj.get('remove')).toEqual(undefined);\n      return Parse.Cloud.run('removeme2');\n    }).then(aBeforeSaveObj => {\n      expect(aBeforeSaveObj.get('before')).toEqual('save');\n      expect(aBeforeSaveObj.get('remove')).toEqual(undefined);\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should not include relation op (regression test for #1606)","suites":["Cloud Code"],"line":1179,"updatePoint":{"line":1179,"column":64,"index":40046},"code":"  it('should not include relation op (regression test for #1606)', done => {\n    const TestObject = Parse.Object.extend('TestObject');\n    const BeforeSaveObject = Parse.Object.extend('BeforeSaveChanged');\n    let testObj;\n    Parse.Cloud.beforeSave('BeforeSaveChanged', req => {\n      const object = req.object;\n      object.set('before', 'save');\n      testObj = new TestObject();\n      return testObj.save().then(() => {\n        object.relation('testsRelation').add(testObj);\n      });\n    });\n    const object = new BeforeSaveObject();\n    object.save().then(objectAgain => {\n      // Originally it would throw as it would be a non-relation\n      expect(() => {\n        objectAgain.relation('testsRelation');\n      }).not.toThrow();\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"before save increment does not return undefined","suites":["Cloud Code"],"line":1208,"updatePoint":{"line":1208,"column":53,"index":41002},"code":"  it('before save increment does not return undefined', done => {\n    Parse.Cloud.define('cloudIncrementClassFunction', function (req) {\n      const CloudIncrementClass = Parse.Object.extend('CloudIncrementClass');\n      const obj = new CloudIncrementClass();\n      obj.id = req.params.objectId;\n      return obj.save();\n    });\n    Parse.Cloud.beforeSave('CloudIncrementClass', function (req) {\n      const obj = req.object;\n      if (!req.master) {\n        obj.increment('points', -10);\n        obj.increment('num', -9);\n      }\n    });\n    const CloudIncrementClass = Parse.Object.extend('CloudIncrementClass');\n    const obj = new CloudIncrementClass();\n    obj.set('points', 10);\n    obj.set('num', 10);\n    obj.save(null, {\n      useMasterKey: true\n    }).then(function () {\n      Parse.Cloud.run('cloudIncrementClassFunction', {\n        objectId: obj.id\n      }).then(function (savedObj) {\n        expect(savedObj.get('num')).toEqual(1);\n        expect(savedObj.get('points')).toEqual(0);\n        done();\n      });\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"before save can revert fields","suites":["Cloud Code"],"line":1238,"updatePoint":{"line":1238,"column":35,"index":42020},"code":"  it('before save can revert fields', async () => {\n    Parse.Cloud.beforeSave('TestObject', ({\n      object\n    }) => {\n      object.revert('foo');\n      return object;\n    });\n    Parse.Cloud.afterSave('TestObject', ({\n      object\n    }) => {\n      expect(object.get('foo')).toBeUndefined();\n      return object;\n    });\n    const obj = new TestObject();\n    obj.set('foo', 'bar');\n    await obj.save();\n    expect(obj.get('foo')).toBeUndefined();\n    await obj.fetch();\n    expect(obj.get('foo')).toBeUndefined();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"before save can revert fields with existing object","suites":["Cloud Code"],"line":1258,"updatePoint":{"line":1258,"column":56,"index":42565},"code":"  it('before save can revert fields with existing object', async () => {\n    Parse.Cloud.beforeSave('TestObject', ({\n      object\n    }) => {\n      object.revert('foo');\n      return object;\n    }, {\n      skipWithMasterKey: true\n    });\n    Parse.Cloud.afterSave('TestObject', ({\n      object\n    }) => {\n      expect(object.get('foo')).toBe('bar');\n      return object;\n    }, {\n      skipWithMasterKey: true\n    });\n    const obj = new TestObject();\n    obj.set('foo', 'bar');\n    await obj.save(null, {\n      useMasterKey: true\n    });\n    expect(obj.get('foo')).toBe('bar');\n    obj.set('foo', 'yolo');\n    await obj.save();\n    expect(obj.get('foo')).toBe('bar');\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"can unset in afterSave","suites":["Cloud Code"],"line":1285,"updatePoint":{"line":1285,"column":28,"index":43213},"code":"  it('can unset in afterSave', async () => {\n    Parse.Cloud.beforeSave('TestObject', ({\n      object\n    }) => {\n      if (!object.existed()) {\n        object.set('secret', true);\n        return object;\n      }\n      object.revert('secret');\n    });\n    Parse.Cloud.afterSave('TestObject', ({\n      object\n    }) => {\n      object.unset('secret');\n    });\n    Parse.Cloud.beforeFind('TestObject', ({\n      query\n    }) => {\n      query.exclude('secret');\n    }, {\n      skipWithMasterKey: true\n    });\n    const obj = new TestObject();\n    await obj.save();\n    expect(obj.get('secret')).toBeUndefined();\n    await obj.fetch();\n    expect(obj.get('secret')).toBeUndefined();\n    await obj.fetch({\n      useMasterKey: true\n    });\n    expect(obj.get('secret')).toBe(true);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should revert in beforeSave","suites":["Cloud Code"],"line":1317,"updatePoint":{"line":1317,"column":33,"index":43997},"code":"  it('should revert in beforeSave', async () => {\n    Parse.Cloud.beforeSave('MyObject', ({\n      object\n    }) => {\n      if (!object.existed()) {\n        object.set('count', 0);\n        return object;\n      }\n      object.revert('count');\n      return object;\n    });\n    const obj = await new Parse.Object('MyObject').save();\n    expect(obj.get('count')).toBe(0);\n    obj.set('count', 10);\n    await obj.save();\n    expect(obj.get('count')).toBe(0);\n    await obj.fetch();\n    expect(obj.get('count')).toBe(0);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"pointer should not be cleared by triggers","suites":["Cloud Code"],"line":1336,"updatePoint":{"line":1336,"column":47,"index":44531},"code":"  it('pointer should not be cleared by triggers', async () => {\n    Parse.Cloud.afterSave('MyObject', () => {});\n    const foo = await new Parse.Object('Test', {\n      foo: 'bar'\n    }).save();\n    const obj = await new Parse.Object('MyObject', {\n      foo\n    }).save();\n    const foo2 = obj.get('foo');\n    expect(foo2.get('foo')).toBe('bar');\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"can set a pointer in triggers","suites":["Cloud Code"],"line":1347,"updatePoint":{"line":1347,"column":35,"index":44871},"code":"  it('can set a pointer in triggers', async () => {\n    Parse.Cloud.beforeSave('MyObject', () => {});\n    Parse.Cloud.afterSave('MyObject', async ({\n      object\n    }) => {\n      const foo = await new Parse.Object('Test', {\n        foo: 'bar'\n      }).save();\n      object.set({\n        foo\n      });\n      await object.save(null, {\n        useMasterKey: true\n      });\n    }, {\n      skipWithMasterKey: true\n    });\n    const obj = await new Parse.Object('MyObject').save();\n    const foo2 = obj.get('foo');\n    expect(foo2.get('foo')).toBe('bar');\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave should not sanitize database","suites":["Cloud Code"],"line":1368,"updatePoint":{"line":1368,"column":45,"index":45438},"code":"  it('beforeSave should not sanitize database', async done => {\n    const {\n      adapter\n    } = Config.get(Parse.applicationId).database;\n    const spy = spyOn(adapter, 'findOneAndUpdate').and.callThrough();\n    spy.calls.saveArgumentsByValue();\n    let count = 0;\n    Parse.Cloud.beforeSave('CloudIncrementNested', req => {\n      count += 1;\n      req.object.set('foo', 'baz');\n      expect(typeof req.object.get('objectField').number).toBe('number');\n    });\n    Parse.Cloud.afterSave('CloudIncrementNested', req => {\n      expect(typeof req.object.get('objectField').number).toBe('number');\n    });\n    const obj = new Parse.Object('CloudIncrementNested');\n    obj.set('objectField', {\n      number: 5\n    });\n    obj.set('foo', 'bar');\n    await obj.save();\n    obj.increment('objectField.number', 10);\n    await obj.save();\n    const [,,, /* className */ /* schema */ /* query */update] = adapter.findOneAndUpdate.calls.first().args;\n    expect(update).toEqual({\n      'objectField.number': {\n        __op: 'Increment',\n        amount: 10\n      },\n      foo: 'baz',\n      updatedAt: obj.updatedAt.toISOString()\n    });\n    count === 2 ? done() : fail();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed on afterSave exception","suites":["Cloud Code"],"line":1407,"updatePoint":{"line":1407,"column":43,"index":46744},"code":"  it('should succeed on afterSave exception', done => {\n    Parse.Cloud.afterSave('AfterSaveTestClass', function () {\n      throw 'Exception';\n    });\n    const AfterSaveTestClass = Parse.Object.extend('AfterSaveTestClass');\n    const obj = new AfterSaveTestClass();\n    obj.save().then(done, done.fail);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"can deprecate Parse.Cloud.httpRequest","suites":["Cloud Code"],"line":1415,"updatePoint":{"line":1415,"column":43,"index":47055},"code":"  it('can deprecate Parse.Cloud.httpRequest', async () => {\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'warn').and.callFake(() => {});\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    });\n    await Parse.Cloud.httpRequest({\n      method: 'POST',\n      url: 'http://localhost:8378/1/functions/hello',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest'\n      }\n    });\n    expect(logger.warn).toHaveBeenCalledWith('DeprecationWarning: Parse.Cloud.httpRequest is deprecated and will be removed in a future version. Use a http request library instead.');\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should define a job","suites":["Cloud Code","cloud jobs"],"line":1432,"updatePoint":{"line":1432,"column":27,"index":47740},"code":"    it('should define a job', done => {\n      expect(() => {\n        Parse.Cloud.job('myJob', ({\n          message\n        }) => {\n          message('Hello, world!!!');\n        });\n      }).not.toThrow();\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/jobs/myJob',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Master-Key': Parse.masterKey\n        }\n      }).then(async response => {\n        const jobStatusId = response.headers['x-parse-job-status-id'];\n        const checkJobStatus = async () => {\n          const jobStatus = await getJobStatus(jobStatusId);\n          return jobStatus.get('finishedAt') && jobStatus.get('message') === 'Hello, world!!!';\n        };\n        while (!(await checkJobStatus())) {\n          await new Promise(resolve => setTimeout(resolve, 100));\n        }\n      }).then(done).catch(done.fail);\n    });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should not run without master key","suites":["Cloud Code","cloud jobs"],"line":1458,"updatePoint":{"line":1458,"column":41,"index":48668},"code":"    it('should not run without master key', done => {\n      expect(() => {\n        Parse.Cloud.job('myJob', () => {});\n      }).not.toThrow();\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/jobs/myJob',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        }\n      }).then(() => {\n        fail('Expected to be unauthorized');\n        done();\n      }, err => {\n        expect(err.status).toBe(403);\n        done();\n      });\n    });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should run with master key","suites":["Cloud Code","cloud jobs"],"line":1477,"updatePoint":{"line":1477,"column":34,"index":49195},"code":"    it('should run with master key', done => {\n      expect(() => {\n        Parse.Cloud.job('myJob', (req, res) => {\n          expect(req.functionName).toBeUndefined();\n          expect(req.jobName).toBe('myJob');\n          expect(typeof req.jobId).toBe('string');\n          expect(typeof req.message).toBe('function');\n          expect(typeof res).toBe('undefined');\n        });\n      }).not.toThrow();\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/jobs/myJob',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Master-Key': Parse.masterKey\n        }\n      }).then(async response => {\n        const jobStatusId = response.headers['x-parse-job-status-id'];\n        const checkJobStatus = async () => {\n          const jobStatus = await getJobStatus(jobStatusId);\n          return jobStatus.get('finishedAt');\n        };\n        while (!(await checkJobStatus())) {\n          await new Promise(resolve => setTimeout(resolve, 100));\n        }\n      }).then(done).catch(done.fail);\n    });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should run with master key basic auth","suites":["Cloud Code","cloud jobs"],"line":1505,"updatePoint":{"line":1505,"column":45,"index":50269},"code":"    it('should run with master key basic auth', done => {\n      expect(() => {\n        Parse.Cloud.job('myJob', (req, res) => {\n          expect(req.functionName).toBeUndefined();\n          expect(req.jobName).toBe('myJob');\n          expect(typeof req.jobId).toBe('string');\n          expect(typeof req.message).toBe('function');\n          expect(typeof res).toBe('undefined');\n        });\n      }).not.toThrow();\n      request({\n        method: 'POST',\n        url: `http://${Parse.applicationId}:${Parse.masterKey}@localhost:8378/1/jobs/myJob`\n      }).then(async response => {\n        const jobStatusId = response.headers['x-parse-job-status-id'];\n        const checkJobStatus = async () => {\n          const jobStatus = await getJobStatus(jobStatusId);\n          return jobStatus.get('finishedAt');\n        };\n        while (!(await checkJobStatus())) {\n          await new Promise(resolve => setTimeout(resolve, 100));\n        }\n      }).then(done).catch(done.fail);\n    });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should set the message / success on the job","suites":["Cloud Code","cloud jobs"],"line":1529,"updatePoint":{"line":1529,"column":51,"index":51256},"code":"    it('should set the message / success on the job', done => {\n      Parse.Cloud.job('myJob', req => {\n        return req.message('hello').then(() => {\n          return getJobStatus(req.jobId);\n        }).then(jobStatus => {\n          expect(jobStatus.get('message')).toEqual('hello');\n          expect(jobStatus.get('status')).toEqual('running');\n        });\n      });\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/jobs/myJob',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Master-Key': Parse.masterKey\n        }\n      }).then(async response => {\n        const jobStatusId = response.headers['x-parse-job-status-id'];\n        const checkJobStatus = async () => {\n          const jobStatus = await getJobStatus(jobStatusId);\n          return jobStatus.get('finishedAt') && jobStatus.get('message') === 'hello' && jobStatus.get('status') === 'succeeded';\n        };\n        while (!(await checkJobStatus())) {\n          await new Promise(resolve => setTimeout(resolve, 100));\n        }\n      }).then(done).catch(done.fail);\n    });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should set the failure on the job","suites":["Cloud Code","cloud jobs"],"line":1556,"updatePoint":{"line":1556,"column":41,"index":52359},"code":"    it('should set the failure on the job', done => {\n      Parse.Cloud.job('myJob', () => {\n        return Promise.reject('Something went wrong');\n      });\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/jobs/myJob',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Master-Key': Parse.masterKey\n        }\n      }).then(async response => {\n        const jobStatusId = response.headers['x-parse-job-status-id'];\n        const checkJobStatus = async () => {\n          const jobStatus = await getJobStatus(jobStatusId);\n          return jobStatus.get('finishedAt') && jobStatus.get('message') === 'Something went wrong' && jobStatus.get('status') === 'failed';\n        };\n        while (!(await checkJobStatus())) {\n          await new Promise(resolve => setTimeout(resolve, 100));\n        }\n      }).then(done).catch(done.fail);\n    });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should set the failure message on the job error","suites":["Cloud Code","cloud jobs"],"line":1578,"updatePoint":{"line":1578,"column":55,"index":53285},"code":"    it('should set the failure message on the job error', async () => {\n      Parse.Cloud.job('myJobError', () => {\n        throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Something went wrong');\n      });\n      const job = await Parse.Cloud.startJob('myJobError');\n      let jobStatus, status;\n      while (status !== 'failed') {\n        if (jobStatus) {\n          await new Promise(resolve => setTimeout(resolve, 10));\n        }\n        jobStatus = await Parse.Cloud.getJobStatus(job);\n        status = jobStatus.get('status');\n      }\n      expect(jobStatus.get('message')).toEqual('Something went wrong');\n    });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"Should have request ip","suites":["cloud functions"],"line":1602,"updatePoint":{"line":1602,"column":28,"index":54080},"code":"  it('Should have request ip', done => {\n    Parse.Cloud.define('myFunction', req => {\n      expect(req.ip).toBeDefined();\n      return 'success';\n    });\n    Parse.Cloud.run('myFunction', {}).then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request headers","suites":["beforeSave hooks"],"line":1611,"updatePoint":{"line":1611,"column":33,"index":54345},"code":"  it('should have request headers', done => {\n    Parse.Cloud.beforeSave('MyObject', req => {\n      expect(req.headers).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request ip","suites":["beforeSave hooks"],"line":1619,"updatePoint":{"line":1619,"column":28,"index":54620},"code":"  it('should have request ip', done => {\n    Parse.Cloud.beforeSave('MyObject', req => {\n      expect(req.ip).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should respect custom object ids (#6733)","suites":["beforeSave hooks"],"line":1627,"updatePoint":{"line":1627,"column":46,"index":54908},"code":"  it('should respect custom object ids (#6733)', async () => {\n    Parse.Cloud.beforeSave('TestObject', req => {\n      expect(req.object.id).toEqual('test_6733');\n    });\n    await reconfigureServer({\n      allowCustomObjectId: true\n    });\n    const req = request({\n      // Parse JS SDK does not currently support custom object ids (see #1097), so we do a REST request\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/TestObject',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      body: {\n        objectId: 'test_6733',\n        foo: 'bar'\n      }\n    });\n    {\n      const res = await req;\n      expect(res.data.objectId).toEqual('test_6733');\n    }\n    const query = new Parse.Query('TestObject');\n    query.equalTo('objectId', 'test_6733');\n    const res = await query.find();\n    expect(res.length).toEqual(1);\n    expect(res[0].get('foo')).toEqual('bar');\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request headers","suites":["afterSave hooks"],"line":1659,"updatePoint":{"line":1659,"column":33,"index":55883},"code":"  it('should have request headers', done => {\n    Parse.Cloud.afterSave('MyObject', req => {\n      expect(req.headers).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request ip","suites":["afterSave hooks"],"line":1667,"updatePoint":{"line":1667,"column":28,"index":56157},"code":"  it('should have request ip', done => {\n    Parse.Cloud.afterSave('MyObject', req => {\n      expect(req.ip).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should unset in afterSave","suites":["afterSave hooks"],"line":1675,"updatePoint":{"line":1675,"column":31,"index":56429},"code":"  it('should unset in afterSave', async () => {\n    Parse.Cloud.afterSave('MyObject', ({\n      object\n    }) => {\n      object.unset('secret');\n    }, {\n      skipWithMasterKey: true\n    });\n    const obj = new Parse.Object('MyObject');\n    obj.set('secret', 'bar');\n    await obj.save();\n    expect(obj.get('secret')).toBeUndefined();\n    await obj.fetch();\n    expect(obj.get('secret')).toBe('bar');\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should unset","suites":["afterSave hooks"],"line":1690,"updatePoint":{"line":1690,"column":18,"index":56824},"code":"  it('should unset', async () => {\n    Parse.Cloud.beforeSave('MyObject', ({\n      object\n    }) => {\n      object.set('secret', 'hidden');\n    });\n    Parse.Cloud.afterSave('MyObject', ({\n      object\n    }) => {\n      object.unset('secret');\n    });\n    const obj = await new Parse.Object('MyObject').save();\n    expect(obj.get('secret')).toBeUndefined();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request headers","suites":["beforeDelete hooks"],"line":1706,"updatePoint":{"line":1706,"column":33,"index":57246},"code":"  it('should have request headers', done => {\n    Parse.Cloud.beforeDelete('MyObject', req => {\n      expect(req.headers).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(myObj => myObj.destroy()).then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request ip","suites":["beforeDelete hooks"],"line":1714,"updatePoint":{"line":1714,"column":28,"index":57554},"code":"  it('should have request ip', done => {\n    Parse.Cloud.beforeDelete('MyObject', req => {\n      expect(req.ip).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(myObj => myObj.destroy()).then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request headers","suites":["afterDelete hooks"],"line":1724,"updatePoint":{"line":1724,"column":33,"index":57904},"code":"  it('should have request headers', done => {\n    Parse.Cloud.afterDelete('MyObject', req => {\n      expect(req.headers).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(myObj => myObj.destroy()).then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request ip","suites":["afterDelete hooks"],"line":1732,"updatePoint":{"line":1732,"column":28,"index":58211},"code":"  it('should have request ip', done => {\n    Parse.Cloud.afterDelete('MyObject', req => {\n      expect(req.ip).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(myObj => myObj.destroy()).then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should add beforeFind trigger","suites":["beforeFind hooks"],"line":1742,"updatePoint":{"line":1742,"column":35,"index":58561},"code":"  it('should add beforeFind trigger', done => {\n    Parse.Cloud.beforeFind('MyObject', req => {\n      const q = req.query;\n      expect(q instanceof Parse.Query).toBe(true);\n      const jsonQuery = q.toJSON();\n      expect(jsonQuery.where.key).toEqual('value');\n      expect(jsonQuery.where.some).toEqual({\n        $gt: 10\n      });\n      expect(jsonQuery.include).toEqual('otherKey,otherValue');\n      expect(jsonQuery.excludeKeys).toBe('exclude');\n      expect(jsonQuery.limit).toEqual(100);\n      expect(jsonQuery.skip).toBe(undefined);\n      expect(jsonQuery.order).toBe('key');\n      expect(jsonQuery.keys).toBe('select');\n      expect(jsonQuery.readPreference).toBe('PRIMARY');\n      expect(jsonQuery.includeReadPreference).toBe('SECONDARY');\n      expect(jsonQuery.subqueryReadPreference).toBe('SECONDARY_PREFERRED');\n      expect(req.isGet).toEqual(false);\n    });\n    const query = new Parse.Query('MyObject');\n    query.equalTo('key', 'value');\n    query.greaterThan('some', 10);\n    query.include('otherKey');\n    query.include('otherValue');\n    query.ascending('key');\n    query.select('select');\n    query.exclude('exclude');\n    query.readPreference('PRIMARY', 'SECONDARY', 'SECONDARY_PREFERRED');\n    query.find().then(() => {\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should use modify","suites":["beforeFind hooks"],"line":1775,"updatePoint":{"line":1775,"column":23,"index":59820},"code":"  it('should use modify', done => {\n    Parse.Cloud.beforeFind('MyObject', req => {\n      const q = req.query;\n      q.equalTo('forced', true);\n    });\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('forced', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('forced', true);\n    Parse.Object.saveAll([obj0, obj1]).then(() => {\n      const query = new Parse.Query('MyObject');\n      query.equalTo('forced', false);\n      query.find().then(results => {\n        expect(results.length).toBe(1);\n        const firstResult = results[0];\n        expect(firstResult.get('forced')).toBe(true);\n        done();\n      });\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should use the modified the query","suites":["beforeFind hooks"],"line":1795,"updatePoint":{"line":1795,"column":39,"index":60493},"code":"  it('should use the modified the query', done => {\n    Parse.Cloud.beforeFind('MyObject', req => {\n      const q = req.query;\n      const otherQuery = new Parse.Query('MyObject');\n      otherQuery.equalTo('forced', true);\n      return Parse.Query.or(q, otherQuery);\n    });\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('forced', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('forced', true);\n    Parse.Object.saveAll([obj0, obj1]).then(() => {\n      const query = new Parse.Query('MyObject');\n      query.equalTo('forced', false);\n      query.find().then(results => {\n        expect(results.length).toBe(2);\n        done();\n      });\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have object found with nested relational data query","suites":["beforeFind hooks"],"line":1815,"updatePoint":{"line":1815,"column":64,"index":61204},"code":"  it('should have object found with nested relational data query', async () => {\n    const obj1 = Parse.Object.extend('TestObject');\n    const obj2 = Parse.Object.extend('TestObject2');\n    let item2 = new obj2();\n    item2 = await item2.save();\n    let item1 = new obj1();\n    const relation = item1.relation('rel');\n    relation.add(item2);\n    item1 = await item1.save();\n    Parse.Cloud.beforeFind('TestObject', req => {\n      const additionalQ = new Parse.Query('TestObject');\n      additionalQ.equalTo('rel', item2);\n      return Parse.Query.and(req.query, additionalQ);\n    });\n    const q = new Parse.Query('TestObject');\n    const res = await q.first();\n    expect(res.id).toEqual(item1.id);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should use the modified exclude query","suites":["beforeFind hooks"],"line":1833,"updatePoint":{"line":1833,"column":43,"index":61890},"code":"  it('should use the modified exclude query', async () => {\n    Parse.Cloud.beforeFind('MyObject', req => {\n      const q = req.query;\n      q.exclude('number');\n    });\n    const obj = new Parse.Object('MyObject');\n    obj.set('number', 100);\n    obj.set('string', 'hello');\n    await obj.save();\n    const query = new Parse.Query('MyObject');\n    query.equalTo('objectId', obj.id);\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('number')).toBeUndefined();\n    expect(results[0].get('string')).toBe('hello');\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should reject queries","suites":["beforeFind hooks"],"line":1849,"updatePoint":{"line":1849,"column":27,"index":62446},"code":"  it('should reject queries', done => {\n    Parse.Cloud.beforeFind('MyObject', () => {\n      return Promise.reject('Do not run that query');\n    });\n    const query = new Parse.Query('MyObject');\n    query.find().then(() => {\n      fail('should not succeed');\n      done();\n    }, err => {\n      expect(err.code).toBe(Parse.Error.SCRIPT_FAILED);\n      expect(err.message).toEqual('Do not run that query');\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should handle empty where","suites":["beforeFind hooks"],"line":1863,"updatePoint":{"line":1863,"column":31,"index":62884},"code":"  it('should handle empty where', done => {\n    Parse.Cloud.beforeFind('MyObject', req => {\n      const otherQuery = new Parse.Query('MyObject');\n      otherQuery.equalTo('some', true);\n      return Parse.Query.or(req.query, otherQuery);\n    });\n    request({\n      url: 'http://localhost:8378/1/classes/MyObject',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest'\n      }\n    }).then(() => {\n      done();\n    }, err => {\n      fail(err);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should handle sorting where","suites":["beforeFind hooks"],"line":1882,"updatePoint":{"line":1882,"column":33,"index":63415},"code":"  it('should handle sorting where', done => {\n    Parse.Cloud.beforeFind('MyObject', req => {\n      const query = req.query;\n      query.ascending('score');\n      return query;\n    });\n    const count = 20;\n    const objects = [];\n    while (objects.length != count) {\n      const object = new Parse.Object('MyObject');\n      object.set('score', Math.floor(Math.random() * 100));\n      objects.push(object);\n    }\n    Parse.Object.saveAll(objects).then(() => {\n      const query = new Parse.Query('MyObject');\n      return query.find();\n    }).then(objects => {\n      let lastScore = -1;\n      objects.forEach(element => {\n        expect(element.get('score') >= lastScore).toBe(true);\n        lastScore = element.get('score');\n      });\n    }).then(done).catch(done.fail);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should add beforeFind trigger using get API","suites":["beforeFind hooks"],"line":1906,"updatePoint":{"line":1906,"column":49,"index":64210},"code":"  it('should add beforeFind trigger using get API', done => {\n    const hook = {\n      method: function (req) {\n        expect(req.isGet).toEqual(true);\n        return Promise.resolve();\n      }\n    };\n    spyOn(hook, 'method').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', hook.method);\n    const obj = new Parse.Object('MyObject');\n    obj.set('secretField', 'SSID');\n    obj.save().then(function () {\n      request({\n        method: 'GET',\n        url: 'http://localhost:8378/1/classes/MyObject/' + obj.id,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        json: true\n      }).then(response => {\n        const body = response.data;\n        expect(body.secretField).toEqual('SSID');\n        expect(hook.method).toHaveBeenCalled();\n        done();\n      });\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request headers","suites":["beforeFind hooks"],"line":1934,"updatePoint":{"line":1934,"column":33,"index":65052},"code":"  it('should have request headers', done => {\n    Parse.Cloud.beforeFind('MyObject', req => {\n      expect(req.headers).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(myObj => {\n      const query = new Parse.Query('MyObject');\n      query.equalTo('objectId', myObj.id);\n      return Promise.all([query.get(myObj.id), query.first(), query.find()]);\n    }).then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request ip","suites":["beforeFind hooks"],"line":1946,"updatePoint":{"line":1946,"column":28,"index":65520},"code":"  it('should have request ip', done => {\n    Parse.Cloud.beforeFind('MyObject', req => {\n      expect(req.ip).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(myObj => {\n      const query = new Parse.Query('MyObject');\n      query.equalTo('objectId', myObj.id);\n      return Promise.all([query.get(myObj.id), query.first(), query.find()]);\n    }).then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should add afterFind trigger","suites":["afterFind hooks"],"line":1960,"updatePoint":{"line":1960,"column":34,"index":66029},"code":"  it('should add afterFind trigger', done => {\n    Parse.Cloud.afterFind('MyObject', req => {\n      const q = req.query;\n      expect(q instanceof Parse.Query).toBe(true);\n      const jsonQuery = q.toJSON();\n      expect(jsonQuery.where.key).toEqual('value');\n      expect(jsonQuery.where.some).toEqual({\n        $gt: 10\n      });\n      expect(jsonQuery.include).toEqual('otherKey,otherValue');\n      expect(jsonQuery.excludeKeys).toBe('exclude');\n      expect(jsonQuery.limit).toEqual(100);\n      expect(jsonQuery.skip).toBe(undefined);\n      expect(jsonQuery.order).toBe('key');\n      expect(jsonQuery.keys).toBe('select');\n      expect(jsonQuery.readPreference).toBe('PRIMARY');\n      expect(jsonQuery.includeReadPreference).toBe('SECONDARY');\n      expect(jsonQuery.subqueryReadPreference).toBe('SECONDARY_PREFERRED');\n    });\n    const query = new Parse.Query('MyObject');\n    query.equalTo('key', 'value');\n    query.greaterThan('some', 10);\n    query.include('otherKey');\n    query.include('otherValue');\n    query.ascending('key');\n    query.select('select');\n    query.exclude('exclude');\n    query.readPreference('PRIMARY', 'SECONDARY', 'SECONDARY_PREFERRED');\n    query.find().then(() => {\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should add afterFind trigger using get","suites":["afterFind hooks"],"line":1992,"updatePoint":{"line":1992,"column":44,"index":67268},"code":"  it('should add afterFind trigger using get', done => {\n    Parse.Cloud.afterFind('MyObject', req => {\n      for (let i = 0; i < req.objects.length; i++) {\n        req.objects[i].set('secretField', '###');\n      }\n      return req.objects;\n    });\n    const obj = new Parse.Object('MyObject');\n    obj.set('secretField', 'SSID');\n    obj.save().then(function () {\n      const query = new Parse.Query('MyObject');\n      query.get(obj.id).then(function (result) {\n        expect(result.get('secretField')).toEqual('###');\n        done();\n      }, function (error) {\n        fail(error);\n        done();\n      });\n    }, function (error) {\n      fail(error);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should add afterFind trigger using find","suites":["afterFind hooks"],"line":2015,"updatePoint":{"line":2015,"column":45,"index":67954},"code":"  it('should add afterFind trigger using find', done => {\n    Parse.Cloud.afterFind('MyObject', req => {\n      for (let i = 0; i < req.objects.length; i++) {\n        req.objects[i].set('secretField', '###');\n      }\n      return req.objects;\n    });\n    const obj = new Parse.Object('MyObject');\n    obj.set('secretField', 'SSID');\n    obj.save().then(function () {\n      const query = new Parse.Query('MyObject');\n      query.equalTo('objectId', obj.id);\n      query.find().then(function (results) {\n        expect(results[0].get('secretField')).toEqual('###');\n        done();\n      }, function (error) {\n        fail(error);\n        done();\n      });\n    }, function (error) {\n      fail(error);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should filter out results","suites":["afterFind hooks"],"line":2039,"updatePoint":{"line":2039,"column":31,"index":68667},"code":"  it('should filter out results', done => {\n    Parse.Cloud.afterFind('MyObject', req => {\n      const filteredResults = [];\n      for (let i = 0; i < req.objects.length; i++) {\n        if (req.objects[i].get('secretField') === 'SSID1') {\n          filteredResults.push(req.objects[i]);\n        }\n      }\n      return filteredResults;\n    });\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('secretField', 'SSID1');\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('secretField', 'SSID2');\n    Parse.Object.saveAll([obj0, obj1]).then(function () {\n      const query = new Parse.Query('MyObject');\n      query.find().then(function (results) {\n        expect(results[0].get('secretField')).toEqual('SSID1');\n        expect(results.length).toEqual(1);\n        done();\n      }, function (error) {\n        fail(error);\n        done();\n      });\n    }, function (error) {\n      fail(error);\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should handle failures","suites":["afterFind hooks"],"line":2068,"updatePoint":{"line":2068,"column":28,"index":69600},"code":"  it('should handle failures', done => {\n    Parse.Cloud.afterFind('MyObject', () => {\n      throw new Parse.Error(Parse.Error.SCRIPT_FAILED, 'It should fail');\n    });\n    const obj = new Parse.Object('MyObject');\n    obj.set('secretField', 'SSID');\n    obj.save().then(function () {\n      const query = new Parse.Query('MyObject');\n      query.equalTo('objectId', obj.id);\n      query.find().then(function () {\n        fail('AfterFind should handle response failure correctly');\n        done();\n      }, function () {\n        done();\n      });\n    }, function () {\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should also work with promise","suites":["afterFind hooks"],"line":2087,"updatePoint":{"line":2087,"column":35,"index":70202},"code":"  it('should also work with promise', done => {\n    Parse.Cloud.afterFind('MyObject', req => {\n      return new Promise(resolve => {\n        setTimeout(function () {\n          for (let i = 0; i < req.objects.length; i++) {\n            req.objects[i].set('secretField', '###');\n          }\n          resolve(req.objects);\n        }, 1000);\n      });\n    });\n    const obj = new Parse.Object('MyObject');\n    obj.set('secretField', 'SSID');\n    obj.save().then(function () {\n      const query = new Parse.Query('MyObject');\n      query.equalTo('objectId', obj.id);\n      query.find().then(function (results) {\n        expect(results[0].get('secretField')).toEqual('###');\n        done();\n      }, function (error) {\n        fail(error);\n      });\n    }, function (error) {\n      fail(error);\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should alter select","suites":["afterFind hooks"],"line":2113,"updatePoint":{"line":2113,"column":25,"index":70996},"code":"  it('should alter select', done => {\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.query.select('white');\n      return req.query;\n    });\n    const obj0 = new Parse.Object('MyObject').set('white', true).set('black', true);\n    obj0.save().then(() => {\n      new Parse.Query('MyObject').first().then(result => {\n        expect(result.get('white')).toBe(true);\n        expect(result.get('black')).toBe(undefined);\n        done();\n      });\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should not alter select","suites":["afterFind hooks"],"line":2127,"updatePoint":{"line":2127,"column":29,"index":71465},"code":"  it('should not alter select', done => {\n    const obj0 = new Parse.Object('MyObject').set('white', true).set('black', true);\n    obj0.save().then(() => {\n      new Parse.Query('MyObject').first().then(result => {\n        expect(result.get('white')).toBe(true);\n        expect(result.get('black')).toBe(true);\n        done();\n      });\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should set count to true on beforeFind hooks if query is count","suites":["afterFind hooks"],"line":2137,"updatePoint":{"line":2137,"column":68,"index":71855},"code":"  it('should set count to true on beforeFind hooks if query is count', done => {\n    const hook = {\n      method: function (req) {\n        expect(req.count).toBe(true);\n        return Promise.resolve();\n      }\n    };\n    spyOn(hook, 'method').and.callThrough();\n    Parse.Cloud.beforeFind('Stuff', hook.method);\n    new Parse.Query('Stuff').count().then(count => {\n      expect(count).toBe(0);\n      expect(hook.method).toHaveBeenCalled();\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should set count to false on beforeFind hooks if query is not count","suites":["afterFind hooks"],"line":2152,"updatePoint":{"line":2152,"column":73,"index":72329},"code":"  it('should set count to false on beforeFind hooks if query is not count', done => {\n    const hook = {\n      method: function (req) {\n        expect(req.count).toBe(false);\n        return Promise.resolve();\n      }\n    };\n    spyOn(hook, 'method').and.callThrough();\n    Parse.Cloud.beforeFind('Stuff', hook.method);\n    new Parse.Query('Stuff').find().then(res => {\n      expect(res.length).toBe(0);\n      expect(hook.method).toHaveBeenCalled();\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"can set a pointer object in afterFind","suites":["afterFind hooks"],"line":2167,"updatePoint":{"line":2167,"column":43,"index":72776},"code":"  it('can set a pointer object in afterFind', async () => {\n    const obj = new Parse.Object('MyObject');\n    await obj.save();\n    Parse.Cloud.afterFind('MyObject', async ({\n      objects\n    }) => {\n      const otherObject = new Parse.Object('Test');\n      otherObject.set('foo', 'bar');\n      await otherObject.save();\n      objects[0].set('Pointer', otherObject);\n      objects[0].set('xyz', 'yolo');\n      expect(objects[0].get('Pointer').get('foo')).toBe('bar');\n    });\n    const query = new Parse.Query('MyObject');\n    query.equalTo('objectId', obj.id);\n    const obj2 = await query.first();\n    expect(obj2.get('xyz')).toBe('yolo');\n    const pointer = obj2.get('Pointer');\n    expect(pointer.get('foo')).toBe('bar');\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"can set invalid object in afterFind","suites":["afterFind hooks"],"line":2187,"updatePoint":{"line":2187,"column":41,"index":73508},"code":"  it('can set invalid object in afterFind', async () => {\n    const obj = new Parse.Object('MyObject');\n    await obj.save();\n    Parse.Cloud.afterFind('MyObject', () => [{}]);\n    const query = new Parse.Query('MyObject');\n    query.equalTo('objectId', obj.id);\n    const obj2 = await query.first();\n    expect(obj2).toBeDefined();\n    expect(obj2.toJSON()).toEqual({});\n    expect(obj2.id).toBeUndefined();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"can return a unsaved object in afterFind","suites":["afterFind hooks"],"line":2198,"updatePoint":{"line":2198,"column":46,"index":73928},"code":"  it('can return a unsaved object in afterFind', async () => {\n    const obj = new Parse.Object('MyObject');\n    await obj.save();\n    Parse.Cloud.afterFind('MyObject', async () => {\n      const otherObject = new Parse.Object('Test');\n      otherObject.set('foo', 'bar');\n      return [otherObject];\n    });\n    const query = new Parse.Query('MyObject');\n    const obj2 = await query.first();\n    expect(obj2.get('foo')).toEqual('bar');\n    expect(obj2.id).toBeUndefined();\n    await obj2.save();\n    expect(obj2.id).toBeDefined();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request headers","suites":["afterFind hooks"],"line":2213,"updatePoint":{"line":2213,"column":33,"index":74453},"code":"  it('should have request headers', done => {\n    Parse.Cloud.afterFind('MyObject', req => {\n      expect(req.headers).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(myObj => {\n      const query = new Parse.Query('MyObject');\n      query.equalTo('objectId', myObj.id);\n      return Promise.all([query.get(myObj.id), query.first(), query.find()]);\n    }).then(() => done());\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have request ip","suites":["afterFind hooks"],"line":2225,"updatePoint":{"line":2225,"column":28,"index":74920},"code":"  it('should have request ip', done => {\n    Parse.Cloud.afterFind('MyObject', req => {\n      expect(req.ip).toBeDefined();\n    });\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    myObject.save().then(myObj => {\n      const query = new Parse.Query('MyObject');\n      query.equalTo('objectId', myObj.id);\n      return Promise.all([query.get(myObj.id), query.first(), query.find()]);\n    }).then(() => done()).catch(done.fail);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should validate triggers correctly","suites":["afterFind hooks"],"line":2237,"updatePoint":{"line":2237,"column":40,"index":75411},"code":"  it('should validate triggers correctly', () => {\n    expect(() => {\n      Parse.Cloud.beforeSave('_Session', () => {});\n    }).toThrow('Only the afterLogout trigger is allowed for the _Session class.');\n    expect(() => {\n      Parse.Cloud.afterSave('_Session', () => {});\n    }).toThrow('Only the afterLogout trigger is allowed for the _Session class.');\n    expect(() => {\n      Parse.Cloud.beforeSave('_PushStatus', () => {});\n    }).toThrow('Only afterSave is allowed on _PushStatus');\n    expect(() => {\n      Parse.Cloud.afterSave('_PushStatus', () => {});\n    }).not.toThrow();\n    expect(() => {\n      Parse.Cloud.beforeLogin(() => {});\n    }).not.toThrow('Only the _User class is allowed for the beforeLogin and afterLogin triggers');\n    expect(() => {\n      Parse.Cloud.beforeLogin('_User', () => {});\n    }).not.toThrow('Only the _User class is allowed for the beforeLogin and afterLogin triggers');\n    expect(() => {\n      Parse.Cloud.beforeLogin(Parse.User, () => {});\n    }).not.toThrow('Only the _User class is allowed for the beforeLogin and afterLogin triggers');\n    expect(() => {\n      Parse.Cloud.beforeLogin('SomeClass', () => {});\n    }).toThrow('Only the _User class is allowed for the beforeLogin and afterLogin triggers');\n    expect(() => {\n      Parse.Cloud.afterLogin(() => {});\n    }).not.toThrow('Only the _User class is allowed for the beforeLogin and afterLogin triggers');\n    expect(() => {\n      Parse.Cloud.afterLogin('_User', () => {});\n    }).not.toThrow('Only the _User class is allowed for the beforeLogin and afterLogin triggers');\n    expect(() => {\n      Parse.Cloud.afterLogin(Parse.User, () => {});\n    }).not.toThrow('Only the _User class is allowed for the beforeLogin and afterLogin triggers');\n    expect(() => {\n      Parse.Cloud.afterLogin('SomeClass', () => {});\n    }).toThrow('Only the _User class is allowed for the beforeLogin and afterLogin triggers');\n    expect(() => {\n      Parse.Cloud.afterLogout(() => {});\n    }).not.toThrow();\n    expect(() => {\n      Parse.Cloud.afterLogout('_Session', () => {});\n    }).not.toThrow();\n    expect(() => {\n      Parse.Cloud.afterLogout('_User', () => {});\n    }).toThrow('Only the _Session class is allowed for the afterLogout trigger.');\n    expect(() => {\n      Parse.Cloud.afterLogout('SomeClass', () => {});\n    }).toThrow('Only the _Session class is allowed for the afterLogout trigger.');\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should skip afterFind hooks for aggregate","suites":["afterFind hooks"],"line":2287,"updatePoint":{"line":2287,"column":47,"index":77823},"code":"  it('should skip afterFind hooks for aggregate', done => {\n    const hook = {\n      method: function () {\n        return Promise.reject();\n      }\n    };\n    spyOn(hook, 'method').and.callThrough();\n    Parse.Cloud.afterFind('MyObject', hook.method);\n    const obj = new Parse.Object('MyObject');\n    const pipeline = [{\n      group: {\n        objectId: {}\n      }\n    }];\n    obj.save().then(() => {\n      const query = new Parse.Query('MyObject');\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results[0].objectId).toEqual(null);\n      expect(hook.method).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should skip afterFind hooks for distinct","suites":["afterFind hooks"],"line":2310,"updatePoint":{"line":2310,"column":46,"index":78465},"code":"  it('should skip afterFind hooks for distinct', done => {\n    const hook = {\n      method: function () {\n        return Promise.reject();\n      }\n    };\n    spyOn(hook, 'method').and.callThrough();\n    Parse.Cloud.afterFind('MyObject', hook.method);\n    const obj = new Parse.Object('MyObject');\n    obj.set('score', 10);\n    obj.save().then(() => {\n      const query = new Parse.Query('MyObject');\n      return query.distinct('score');\n    }).then(results => {\n      expect(results[0]).toEqual(10);\n      expect(hook.method).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error if context header is malformed","suites":["afterFind hooks"],"line":2329,"updatePoint":{"line":2329,"column":55,"index":79053},"code":"  it('should throw error if context header is malformed', async () => {\n    let calledBefore = false;\n    let calledAfter = false;\n    Parse.Cloud.beforeSave('TestObject', () => {\n      calledBefore = true;\n    });\n    Parse.Cloud.afterSave('TestObject', () => {\n      calledAfter = true;\n    });\n    const req = request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/TestObject',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Cloud-Context': 'key'\n      },\n      body: {\n        foo: 'bar'\n      }\n    });\n    try {\n      await req;\n      fail('Should have thrown error');\n    } catch (e) {\n      expect(e).toBeDefined();\n      expect(e.data.code).toEqual(Parse.Error.INVALID_JSON);\n    }\n    expect(calledBefore).toBe(false);\n    expect(calledAfter).toBe(false);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error if context header is string \"1\"","suites":["afterFind hooks"],"line":2360,"updatePoint":{"line":2360,"column":56,"index":79916},"code":"  it('should throw error if context header is string \"1\"', async () => {\n    let calledBefore = false;\n    let calledAfter = false;\n    Parse.Cloud.beforeSave('TestObject', () => {\n      calledBefore = true;\n    });\n    Parse.Cloud.afterSave('TestObject', () => {\n      calledAfter = true;\n    });\n    const req = request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/TestObject',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Cloud-Context': '1'\n      },\n      body: {\n        foo: 'bar'\n      }\n    });\n    try {\n      await req;\n      fail('Should have thrown error');\n    } catch (e) {\n      expect(e).toBeDefined();\n      expect(e.data.code).toEqual(Parse.Error.INVALID_JSON);\n    }\n    expect(calledBefore).toBe(false);\n    expect(calledAfter).toBe(false);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should expose context in beforeSave/afterSave via header","suites":["afterFind hooks"],"line":2391,"updatePoint":{"line":2391,"column":62,"index":80783},"code":"  it('should expose context in beforeSave/afterSave via header', async () => {\n    let calledBefore = false;\n    let calledAfter = false;\n    Parse.Cloud.beforeSave('TestObject', req => {\n      expect(req.object.get('foo')).toEqual('bar');\n      expect(req.context.otherKey).toBe(1);\n      expect(req.context.key).toBe('value');\n      calledBefore = true;\n    });\n    Parse.Cloud.afterSave('TestObject', req => {\n      expect(req.object.get('foo')).toEqual('bar');\n      expect(req.context.otherKey).toBe(1);\n      expect(req.context.key).toBe('value');\n      calledAfter = true;\n    });\n    const req = request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/TestObject',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Cloud-Context': '{\"key\":\"value\",\"otherKey\":1}'\n      },\n      body: {\n        foo: 'bar'\n      }\n    });\n    await req;\n    expect(calledBefore).toBe(true);\n    expect(calledAfter).toBe(true);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should override header context with body context in beforeSave/afterSave","suites":["afterFind hooks"],"line":2422,"updatePoint":{"line":2422,"column":78,"index":81807},"code":"  it('should override header context with body context in beforeSave/afterSave', async () => {\n    let calledBefore = false;\n    let calledAfter = false;\n    Parse.Cloud.beforeSave('TestObject', req => {\n      expect(req.object.get('foo')).toEqual('bar');\n      expect(req.context.otherKey).toBe(10);\n      expect(req.context.key).toBe('hello');\n      calledBefore = true;\n    });\n    Parse.Cloud.afterSave('TestObject', req => {\n      expect(req.object.get('foo')).toEqual('bar');\n      expect(req.context.otherKey).toBe(10);\n      expect(req.context.key).toBe('hello');\n      calledAfter = true;\n    });\n    const req = request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/TestObject',\n      headers: {\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Cloud-Context': '{\"key\":\"value\",\"otherKey\":1}'\n      },\n      body: {\n        foo: 'bar',\n        _ApplicationId: 'test',\n        _context: '{\"key\":\"hello\",\"otherKey\":10}'\n      }\n    });\n    await req;\n    expect(calledBefore).toBe(true);\n    expect(calledAfter).toBe(true);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error if context body is malformed","suites":["afterFind hooks"],"line":2454,"updatePoint":{"line":2454,"column":53,"index":82849},"code":"  it('should throw error if context body is malformed', async () => {\n    let calledBefore = false;\n    let calledAfter = false;\n    Parse.Cloud.beforeSave('TestObject', () => {\n      calledBefore = true;\n    });\n    Parse.Cloud.afterSave('TestObject', () => {\n      calledAfter = true;\n    });\n    const req = request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/TestObject',\n      headers: {\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Cloud-Context': '{\"key\":\"value\",\"otherKey\":1}'\n      },\n      body: {\n        foo: 'bar',\n        _ApplicationId: 'test',\n        _context: 'key'\n      }\n    });\n    try {\n      await req;\n      fail('Should have thrown error');\n    } catch (e) {\n      expect(e).toBeDefined();\n      expect(e.data.code).toEqual(Parse.Error.INVALID_JSON);\n    }\n    expect(calledBefore).toBe(false);\n    expect(calledAfter).toBe(false);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error if context body is string \"true\"","suites":["afterFind hooks"],"line":2486,"updatePoint":{"line":2486,"column":57,"index":83753},"code":"  it('should throw error if context body is string \"true\"', async () => {\n    let calledBefore = false;\n    let calledAfter = false;\n    Parse.Cloud.beforeSave('TestObject', () => {\n      calledBefore = true;\n    });\n    Parse.Cloud.afterSave('TestObject', () => {\n      calledAfter = true;\n    });\n    const req = request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/TestObject',\n      headers: {\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Cloud-Context': '{\"key\":\"value\",\"otherKey\":1}'\n      },\n      body: {\n        foo: 'bar',\n        _ApplicationId: 'test',\n        _context: 'true'\n      }\n    });\n    try {\n      await req;\n      fail('Should have thrown error');\n    } catch (e) {\n      expect(e).toBeDefined();\n      expect(e.data.code).toEqual(Parse.Error.INVALID_JSON);\n    }\n    expect(calledBefore).toBe(false);\n    expect(calledAfter).toBe(false);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should expose context in before and afterSave","suites":["afterFind hooks"],"line":2518,"updatePoint":{"line":2518,"column":51,"index":84652},"code":"  it('should expose context in before and afterSave', async () => {\n    let calledBefore = false;\n    let calledAfter = false;\n    Parse.Cloud.beforeSave('MyClass', req => {\n      req.context = {\n        key: 'value',\n        otherKey: 1\n      };\n      calledBefore = true;\n    });\n    Parse.Cloud.afterSave('MyClass', req => {\n      expect(req.context.otherKey).toBe(1);\n      expect(req.context.key).toBe('value');\n      calledAfter = true;\n    });\n    const object = new Parse.Object('MyClass');\n    await object.save();\n    expect(calledBefore).toBe(true);\n    expect(calledAfter).toBe(true);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should expose context in before and afterSave and let keys be set individually","suites":["afterFind hooks"],"line":2538,"updatePoint":{"line":2538,"column":84,"index":85288},"code":"  it('should expose context in before and afterSave and let keys be set individually', async () => {\n    let calledBefore = false;\n    let calledAfter = false;\n    Parse.Cloud.beforeSave('MyClass', req => {\n      req.context.some = 'value';\n      req.context.yolo = 1;\n      calledBefore = true;\n    });\n    Parse.Cloud.afterSave('MyClass', req => {\n      expect(req.context.yolo).toBe(1);\n      expect(req.context.some).toBe('value');\n      calledAfter = true;\n    });\n    const object = new Parse.Object('MyClass');\n    await object.save();\n    expect(calledBefore).toBe(true);\n    expect(calledAfter).toBe(true);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should run beforeLogin with correct credentials","suites":["beforeLogin hook"],"line":2558,"updatePoint":{"line":2558,"column":53,"index":85920},"code":"  it('should run beforeLogin with correct credentials', async done => {\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      expect(req.object.get('username')).toEqual('tupac');\n    });\n    await Parse.User.signUp('tupac', 'shakur');\n    const user = await Parse.User.logIn('tupac', 'shakur');\n    expect(hit).toBe(1);\n    expect(user).toBeDefined();\n    expect(user.getUsername()).toBe('tupac');\n    expect(user.getSessionToken()).toBeDefined();\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to block login if an error is thrown","suites":["beforeLogin hook"],"line":2572,"updatePoint":{"line":2572,"column":57,"index":86409},"code":"  it('should be able to block login if an error is thrown', async done => {\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      if (req.object.get('isBanned')) {\n        throw new Error('banned account');\n      }\n    });\n    const user = await Parse.User.signUp('tupac', 'shakur');\n    await user.save({\n      isBanned: true\n    });\n    try {\n      await Parse.User.logIn('tupac', 'shakur');\n      throw new Error('should not have been logged in.');\n    } catch (e) {\n      expect(e.message).toBe('banned account');\n    }\n    expect(hit).toBe(1);\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to block login if an error is thrown even if the user has a attached file","suites":["beforeLogin hook"],"line":2593,"updatePoint":{"line":2593,"column":94,"index":87032},"code":"  it('should be able to block login if an error is thrown even if the user has a attached file', async done => {\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      if (req.object.get('isBanned')) {\n        throw new Error('banned account');\n      }\n    });\n    const user = await Parse.User.signUp('tupac', 'shakur');\n    const base64 = 'V29ya2luZyBhdCBQYXJzZSBpcyBncmVhdCE=';\n    const file = new Parse.File('myfile.txt', {\n      base64\n    });\n    await file.save();\n    await user.save({\n      isBanned: true,\n      file\n    });\n    try {\n      await Parse.User.logIn('tupac', 'shakur');\n      throw new Error('should not have been logged in.');\n    } catch (e) {\n      expect(e.message).toBe('banned account');\n    }\n    expect(hit).toBe(1);\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should not run beforeLogin with incorrect credentials","suites":["beforeLogin hook"],"line":2620,"updatePoint":{"line":2620,"column":59,"index":87783},"code":"  it('should not run beforeLogin with incorrect credentials', async done => {\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      expect(req.object.get('username')).toEqual('tupac');\n    });\n    await Parse.User.signUp('tupac', 'shakur');\n    try {\n      await Parse.User.logIn('tony', 'shakur');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    expect(hit).toBe(0);\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should not run beforeLogin on sign up","suites":["beforeLogin hook"],"line":2635,"updatePoint":{"line":2635,"column":43,"index":88209},"code":"  it('should not run beforeLogin on sign up', async done => {\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      expect(req.object.get('username')).toEqual('tupac');\n    });\n    const user = await Parse.User.signUp('tupac', 'shakur');\n    expect(user).toBeDefined();\n    expect(hit).toBe(0);\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should trigger afterLogout hook on logout","suites":["beforeLogin hook"],"line":2646,"updatePoint":{"line":2646,"column":47,"index":88545},"code":"  it('should trigger afterLogout hook on logout', async done => {\n    let userId;\n    Parse.Cloud.afterLogout(req => {\n      expect(req.object.className).toEqual('_Session');\n      expect(req.object.id).toBeDefined();\n      const user = req.object.get('user');\n      expect(user).toBeDefined();\n      userId = user.id;\n    });\n    const user = await Parse.User.signUp('user', 'pass');\n    await Parse.User.logOut();\n    expect(user.id).toBe(userId);\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have expected data in request","suites":["beforeLogin hook"],"line":2660,"updatePoint":{"line":2660,"column":42,"index":89008},"code":"  it('should have expected data in request', async done => {\n    Parse.Cloud.beforeLogin(req => {\n      expect(req.object).toBeDefined();\n      expect(req.user).toBeUndefined();\n      expect(req.headers).toBeDefined();\n      expect(req.ip).toBeDefined();\n      expect(req.installationId).toBeDefined();\n      expect(req.context).toBeUndefined();\n    });\n    await Parse.User.signUp('tupac', 'shakur');\n    await Parse.User.logIn('tupac', 'shakur');\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"afterFind should not be triggered when saving an object","suites":["beforeLogin hook"],"line":2673,"updatePoint":{"line":2673,"column":61,"index":89494},"code":"  it('afterFind should not be triggered when saving an object', async () => {\n    let beforeSaves = 0;\n    Parse.Cloud.beforeSave('SavingTest', () => {\n      beforeSaves++;\n    });\n    let afterSaves = 0;\n    Parse.Cloud.afterSave('SavingTest', () => {\n      afterSaves++;\n    });\n    let beforeFinds = 0;\n    Parse.Cloud.beforeFind('SavingTest', () => {\n      beforeFinds++;\n    });\n    let afterFinds = 0;\n    Parse.Cloud.afterFind('SavingTest', () => {\n      afterFinds++;\n    });\n    const obj = new Parse.Object('SavingTest');\n    obj.set('someField', 'some value 1');\n    await obj.save();\n    expect(beforeSaves).toEqual(1);\n    expect(afterSaves).toEqual(1);\n    expect(beforeFinds).toEqual(0);\n    expect(afterFinds).toEqual(0);\n    obj.set('someField', 'some value 2');\n    await obj.save();\n    expect(beforeSaves).toEqual(2);\n    expect(afterSaves).toEqual(2);\n    expect(beforeFinds).toEqual(0);\n    expect(afterFinds).toEqual(0);\n    await obj.fetch();\n    expect(beforeSaves).toEqual(2);\n    expect(afterSaves).toEqual(2);\n    expect(beforeFinds).toEqual(1);\n    expect(afterFinds).toEqual(1);\n    obj.set('someField', 'some value 3');\n    await obj.save();\n    expect(beforeSaves).toEqual(3);\n    expect(afterSaves).toEqual(3);\n    expect(beforeFinds).toEqual(1);\n    expect(afterFinds).toEqual(1);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should run afterLogin after successful login","suites":["afterLogin hook"],"line":2717,"updatePoint":{"line":2717,"column":50,"index":90844},"code":"  it('should run afterLogin after successful login', async done => {\n    let hit = 0;\n    Parse.Cloud.afterLogin(req => {\n      hit++;\n      expect(req.object.get('username')).toEqual('testuser');\n    });\n    await Parse.User.signUp('testuser', 'p@ssword');\n    const user = await Parse.User.logIn('testuser', 'p@ssword');\n    expect(hit).toBe(1);\n    expect(user).toBeDefined();\n    expect(user.getUsername()).toBe('testuser');\n    expect(user.getSessionToken()).toBeDefined();\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should not run afterLogin after unsuccessful login","suites":["afterLogin hook"],"line":2731,"updatePoint":{"line":2731,"column":56,"index":91347},"code":"  it('should not run afterLogin after unsuccessful login', async done => {\n    let hit = 0;\n    Parse.Cloud.afterLogin(req => {\n      hit++;\n      expect(req.object.get('username')).toEqual('testuser');\n    });\n    await Parse.User.signUp('testuser', 'p@ssword');\n    try {\n      await Parse.User.logIn('testuser', 'badpassword');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    expect(hit).toBe(0);\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should not run afterLogin on sign up","suites":["afterLogin hook"],"line":2746,"updatePoint":{"line":2746,"column":42,"index":91788},"code":"  it('should not run afterLogin on sign up', async done => {\n    let hit = 0;\n    Parse.Cloud.afterLogin(req => {\n      hit++;\n      expect(req.object.get('username')).toEqual('testuser');\n    });\n    const user = await Parse.User.signUp('testuser', 'p@ssword');\n    expect(user).toBeDefined();\n    expect(hit).toBe(0);\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have expected data in request","suites":["afterLogin hook"],"line":2757,"updatePoint":{"line":2757,"column":42,"index":92126},"code":"  it('should have expected data in request', async done => {\n    Parse.Cloud.afterLogin(req => {\n      expect(req.object).toBeDefined();\n      expect(req.user).toBeDefined();\n      expect(req.headers).toBeDefined();\n      expect(req.ip).toBeDefined();\n      expect(req.installationId).toBeDefined();\n      expect(req.context).toBeUndefined();\n    });\n    await Parse.User.signUp('testuser', 'p@ssword');\n    await Parse.User.logIn('testuser', 'p@ssword');\n    done();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"context options should override _context object property when saving a new object","suites":["afterLogin hook"],"line":2770,"updatePoint":{"line":2770,"column":87,"index":92645},"code":"  it('context options should override _context object property when saving a new object', async () => {\n    Parse.Cloud.beforeSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n      expect(req.context.hello).not.toBeDefined();\n      expect(req._context).not.toBeDefined();\n      expect(req.object._context).not.toBeDefined();\n      expect(req.object.context).not.toBeDefined();\n    });\n    Parse.Cloud.afterSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n      expect(req.context.hello).not.toBeDefined();\n      expect(req._context).not.toBeDefined();\n      expect(req.object._context).not.toBeDefined();\n      expect(req.object.context).not.toBeDefined();\n    });\n    const obj = new TestObject();\n    obj.set('_context', {\n      hello: 'world'\n    });\n    await obj.save(null, {\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have access to context when saving a new object","suites":["afterLogin hook"],"line":2795,"updatePoint":{"line":2795,"column":60,"index":93495},"code":"  it('should have access to context when saving a new object', async () => {\n    Parse.Cloud.beforeSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    Parse.Cloud.afterSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    const obj = new TestObject();\n    await obj.save(null, {\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have access to context when saving an existing object","suites":["afterLogin hook"],"line":2809,"updatePoint":{"line":2809,"column":66,"index":93892},"code":"  it('should have access to context when saving an existing object', async () => {\n    const obj = new TestObject();\n    await obj.save(null);\n    Parse.Cloud.beforeSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    Parse.Cloud.afterSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    await obj.save(null, {\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have access to context when saving a new object in a trigger","suites":["afterLogin hook"],"line":2824,"updatePoint":{"line":2824,"column":73,"index":94322},"code":"  it('should have access to context when saving a new object in a trigger', async () => {\n    Parse.Cloud.beforeSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    Parse.Cloud.afterSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    Parse.Cloud.afterSave('TriggerObject', async () => {\n      const obj = new TestObject();\n      await obj.save(null, {\n        context: {\n          a: 'a'\n        }\n      });\n    });\n    const obj = new Parse.Object('TriggerObject');\n    await obj.save(null);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have access to context when cascade-saving objects","suites":["afterLogin hook"],"line":2842,"updatePoint":{"line":2842,"column":63,"index":94870},"code":"  it('should have access to context when cascade-saving objects', async () => {\n    Parse.Cloud.beforeSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    Parse.Cloud.afterSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    Parse.Cloud.beforeSave('TestObject2', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    Parse.Cloud.afterSave('TestObject2', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    const obj = new Parse.Object('TestObject');\n    const obj2 = new Parse.Object('TestObject2');\n    obj.set('obj2', obj2);\n    await obj.save(null, {\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have access to context as saveAll argument","suites":["afterLogin hook"],"line":2864,"updatePoint":{"line":2864,"column":55,"index":95548},"code":"  it('should have access to context as saveAll argument', async () => {\n    Parse.Cloud.beforeSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    Parse.Cloud.afterSave('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    const obj1 = new TestObject();\n    const obj2 = new TestObject();\n    await Parse.Object.saveAll([obj1, obj2], {\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have access to context as destroyAll argument","suites":["afterLogin hook"],"line":2879,"updatePoint":{"line":2879,"column":58,"index":95993},"code":"  it('should have access to context as destroyAll argument', async () => {\n    Parse.Cloud.beforeDelete('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    Parse.Cloud.afterDelete('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    const obj1 = new TestObject();\n    const obj2 = new TestObject();\n    await Parse.Object.saveAll([obj1, obj2]);\n    await Parse.Object.destroyAll([obj1, obj2], {\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have access to context as destroy a object","suites":["afterLogin hook"],"line":2895,"updatePoint":{"line":2895,"column":55,"index":96488},"code":"  it('should have access to context as destroy a object', async () => {\n    Parse.Cloud.beforeDelete('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    Parse.Cloud.afterDelete('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    const obj = new TestObject();\n    await obj.save();\n    await obj.destroy({\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have access to context in beforeFind hook","suites":["afterLogin hook"],"line":2910,"updatePoint":{"line":2910,"column":54,"index":96896},"code":"  it('should have access to context in beforeFind hook', async () => {\n    Parse.Cloud.beforeFind('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    const query = new Parse.Query('TestObject');\n    return query.find({\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"should have access to context when cloud function is called.","suites":["afterLogin hook"],"line":2921,"updatePoint":{"line":2921,"column":66,"index":97206},"code":"  it('should have access to context when cloud function is called.', async () => {\n    Parse.Cloud.define('contextTest', async req => {\n      expect(req.context.a).toEqual('a');\n      return {};\n    });\n    await Parse.Cloud.run('contextTest', {}, {\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"afterFind should have access to context","suites":["afterLogin hook"],"line":2932,"updatePoint":{"line":2932,"column":45,"index":97489},"code":"  it('afterFind should have access to context', async () => {\n    Parse.Cloud.afterFind('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    const obj = new TestObject();\n    await obj.save();\n    const query = new Parse.Query(TestObject);\n    await query.find({\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeFind and afterFind should have access to context while making fetch call","suites":["afterLogin hook"],"line":2945,"updatePoint":{"line":2945,"column":84,"index":97869},"code":"  it('beforeFind and afterFind should have access to context while making fetch call', async () => {\n    Parse.Cloud.beforeFind('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n      expect(req.context.b).toBeUndefined();\n      req.context.b = 'b';\n    });\n    Parse.Cloud.afterFind('TestObject', req => {\n      expect(req.context.a).toEqual('a');\n      expect(req.context.b).toEqual('b');\n    });\n    const obj = new TestObject();\n    await obj.save();\n    await obj.fetch({\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSaveFile should return file that is already saved and not save anything to files adapter","suites":["saveFile hooks"],"line":2965,"updatePoint":{"line":2965,"column":100,"index":98470},"code":"  it('beforeSaveFile should return file that is already saved and not save anything to files adapter', async () => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    const createFileSpy = spyOn(mockAdapter, 'createFile').and.callThrough();\n    Parse.Cloud.beforeSave(Parse.File, () => {\n      const newFile = new Parse.File('some-file.txt');\n      newFile._url = 'http://www.somewhere.com/parse/files/some-app-id/some-file.txt';\n      return newFile;\n    });\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    const result = await file.save({\n      useMasterKey: true\n    });\n    expect(result).toBe(file);\n    expect(result._name).toBe('some-file.txt');\n    expect(result._url).toBe('http://www.somewhere.com/parse/files/some-app-id/some-file.txt');\n    expect(createFileSpy).not.toHaveBeenCalled();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSaveFile should throw error","suites":["saveFile hooks"],"line":2984,"updatePoint":{"line":2984,"column":39,"index":99266},"code":"  it('beforeSaveFile should throw error', async () => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    Parse.Cloud.beforeSave(Parse.File, () => {\n      throw new Parse.Error(400, 'some-error-message');\n    });\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    try {\n      await file.save({\n        useMasterKey: true\n      });\n    } catch (error) {\n      expect(error.message).toBe('some-error-message');\n    }\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSaveFile should change values of uploaded file by editing fileObject directly","suites":["saveFile hooks"],"line":3000,"updatePoint":{"line":3000,"column":89,"index":99786},"code":"  it('beforeSaveFile should change values of uploaded file by editing fileObject directly', async () => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    const createFileSpy = spyOn(mockAdapter, 'createFile').and.callThrough();\n    Parse.Cloud.beforeSave(Parse.File, async req => {\n      expect(req.triggerName).toEqual('beforeSave');\n      expect(req.master).toBe(true);\n      req.file.addMetadata('foo', 'bar');\n      req.file.addTag('tagA', 'some-tag');\n    });\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    const result = await file.save({\n      useMasterKey: true\n    });\n    expect(result).toBe(file);\n    const newData = new Buffer([1, 2, 3]);\n    const newOptions = {\n      tags: {\n        tagA: 'some-tag'\n      },\n      metadata: {\n        foo: 'bar'\n      }\n    };\n    expect(createFileSpy).toHaveBeenCalledWith(jasmine.any(String), newData, 'text/plain', newOptions);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSaveFile should change values by returning new fileObject","suites":["saveFile hooks"],"line":3027,"updatePoint":{"line":3027,"column":69,"index":100708},"code":"  it('beforeSaveFile should change values by returning new fileObject', async () => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    const createFileSpy = spyOn(mockAdapter, 'createFile').and.callThrough();\n    Parse.Cloud.beforeSave(Parse.File, async req => {\n      expect(req.triggerName).toEqual('beforeSave');\n      expect(req.fileSize).toBe(3);\n      const newFile = new Parse.File('donald_duck.pdf', [4, 5, 6], 'application/pdf');\n      newFile.setMetadata({\n        foo: 'bar'\n      });\n      newFile.setTags({\n        tagA: 'some-tag'\n      });\n      return newFile;\n    });\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    const result = await file.save({\n      useMasterKey: true\n    });\n    expect(result).toBeInstanceOf(Parse.File);\n    const newData = new Buffer([4, 5, 6]);\n    const newContentType = 'application/pdf';\n    const newOptions = {\n      tags: {\n        tagA: 'some-tag'\n      },\n      metadata: {\n        foo: 'bar'\n      }\n    };\n    expect(createFileSpy).toHaveBeenCalledWith(jasmine.any(String), newData, newContentType, newOptions);\n    const expectedFileName = 'donald_duck.pdf';\n    expect(file._name.indexOf(expectedFileName)).toBe(file._name.length - expectedFileName.length);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSaveFile should contain metadata and tags saved from client","suites":["saveFile hooks"],"line":3063,"updatePoint":{"line":3063,"column":71,"index":101983},"code":"  it('beforeSaveFile should contain metadata and tags saved from client', async () => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    const createFileSpy = spyOn(mockAdapter, 'createFile').and.callThrough();\n    Parse.Cloud.beforeSave(Parse.File, async req => {\n      expect(req.triggerName).toEqual('beforeSave');\n      expect(req.fileSize).toBe(3);\n      expect(req.file).toBeInstanceOf(Parse.File);\n      expect(req.file.name()).toBe('popeye.txt');\n      expect(req.file.metadata()).toEqual({\n        foo: 'bar'\n      });\n      expect(req.file.tags()).toEqual({\n        bar: 'foo'\n      });\n    });\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    file.setMetadata({\n      foo: 'bar'\n    });\n    file.setTags({\n      bar: 'foo'\n    });\n    const result = await file.save({\n      useMasterKey: true\n    });\n    expect(result).toBeInstanceOf(Parse.File);\n    const options = {\n      metadata: {\n        foo: 'bar'\n      },\n      tags: {\n        bar: 'foo'\n      }\n    };\n    expect(createFileSpy).toHaveBeenCalledWith(jasmine.any(String), jasmine.any(Buffer), 'text/plain', options);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSaveFile should return same file data with new file name","suites":["saveFile hooks"],"line":3101,"updatePoint":{"line":3101,"column":68,"index":103126},"code":"  it('beforeSaveFile should return same file data with new file name', async () => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    const config = Config.get('test');\n    config.filesController.options.preserveFileName = true;\n    Parse.Cloud.beforeSave(Parse.File, async ({\n      file\n    }) => {\n      expect(file.name()).toBe('popeye.txt');\n      const fileData = await file.getData();\n      const newFile = new Parse.File('2020-04-01.txt', {\n        base64: fileData\n      });\n      return newFile;\n    });\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    const result = await file.save({\n      useMasterKey: true\n    });\n    expect(result.name()).toBe('2020-04-01.txt');\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"afterSaveFile should set fileSize to null if beforeSave returns an already saved file","suites":["saveFile hooks"],"line":3123,"updatePoint":{"line":3123,"column":91,"index":103885},"code":"  it('afterSaveFile should set fileSize to null if beforeSave returns an already saved file', async () => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    const createFileSpy = spyOn(mockAdapter, 'createFile').and.callThrough();\n    Parse.Cloud.beforeSave(Parse.File, req => {\n      expect(req.fileSize).toBe(3);\n      const newFile = new Parse.File('some-file.txt');\n      newFile._url = 'http://www.somewhere.com/parse/files/some-app-id/some-file.txt';\n      return newFile;\n    });\n    Parse.Cloud.afterSave(Parse.File, req => {\n      expect(req.fileSize).toBe(null);\n    });\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    const result = await file.save({\n      useMasterKey: true\n    });\n    expect(result).toBe(result);\n    expect(result._name).toBe('some-file.txt');\n    expect(result._url).toBe('http://www.somewhere.com/parse/files/some-app-id/some-file.txt');\n    expect(createFileSpy).not.toHaveBeenCalled();\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"afterSaveFile should throw error","suites":["saveFile hooks"],"line":3146,"updatePoint":{"line":3146,"column":38,"index":104813},"code":"  it('afterSaveFile should throw error', async () => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    Parse.Cloud.afterSave(Parse.File, async () => {\n      throw new Parse.Error(400, 'some-error-message');\n    });\n    const filename = 'donald_duck.pdf';\n    const file = new Parse.File(filename, [1, 2, 3], 'text/plain');\n    try {\n      await file.save({\n        useMasterKey: true\n      });\n    } catch (error) {\n      expect(error.message).toBe('some-error-message');\n    }\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"afterSaveFile should call with fileObject","suites":["saveFile hooks"],"line":3163,"updatePoint":{"line":3163,"column":47,"index":105332},"code":"  it('afterSaveFile should call with fileObject', async done => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    Parse.Cloud.beforeSave(Parse.File, async req => {\n      req.file.setTags({\n        tagA: 'some-tag'\n      });\n      req.file.setMetadata({\n        foo: 'bar'\n      });\n    });\n    Parse.Cloud.afterSave(Parse.File, async req => {\n      expect(req.master).toBe(true);\n      expect(req.file._tags).toEqual({\n        tagA: 'some-tag'\n      });\n      expect(req.file._metadata).toEqual({\n        foo: 'bar'\n      });\n      done();\n    });\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    await file.save({\n      useMasterKey: true\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"afterSaveFile should change fileSize when file data changes","suites":["saveFile hooks"],"line":3190,"updatePoint":{"line":3190,"column":65,"index":106057},"code":"  it('afterSaveFile should change fileSize when file data changes', async done => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    Parse.Cloud.beforeSave(Parse.File, async req => {\n      expect(req.fileSize).toBe(3);\n      expect(req.master).toBe(true);\n      const newFile = new Parse.File('donald_duck.pdf', [4, 5, 6, 7, 8, 9], 'application/pdf');\n      return newFile;\n    });\n    Parse.Cloud.afterSave(Parse.File, async req => {\n      expect(req.fileSize).toBe(6);\n      expect(req.master).toBe(true);\n      done();\n    });\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    await file.save({\n      useMasterKey: true\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeDeleteFile should call with fileObject","suites":["saveFile hooks"],"line":3210,"updatePoint":{"line":3210,"column":50,"index":106730},"code":"  it('beforeDeleteFile should call with fileObject', async () => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    Parse.Cloud.beforeDelete(Parse.File, req => {\n      expect(req.file).toBeInstanceOf(Parse.File);\n      expect(req.file._name).toEqual('popeye.txt');\n      expect(req.file._url).toEqual('http://www.somewhere.com/popeye.txt');\n      expect(req.fileSize).toBe(null);\n    });\n    const file = new Parse.File('popeye.txt');\n    await file.destroy({\n      useMasterKey: true\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeDeleteFile should throw error","suites":["saveFile hooks"],"line":3225,"updatePoint":{"line":3225,"column":41,"index":107245},"code":"  it('beforeDeleteFile should throw error', async done => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    Parse.Cloud.beforeDelete(Parse.File, () => {\n      throw new Error('some error message');\n    });\n    const file = new Parse.File('popeye.txt');\n    try {\n      await file.destroy({\n        useMasterKey: true\n      });\n    } catch (error) {\n      expect(error.message).toBe('some error message');\n      done();\n    }\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"afterDeleteFile should call with fileObject","suites":["saveFile hooks"],"line":3242,"updatePoint":{"line":3242,"column":49,"index":107710},"code":"  it('afterDeleteFile should call with fileObject', async done => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    Parse.Cloud.beforeDelete(Parse.File, req => {\n      expect(req.file).toBeInstanceOf(Parse.File);\n      expect(req.file._name).toEqual('popeye.txt');\n      expect(req.file._url).toEqual('http://www.somewhere.com/popeye.txt');\n    });\n    Parse.Cloud.afterDelete(Parse.File, req => {\n      expect(req.file).toBeInstanceOf(Parse.File);\n      expect(req.file._name).toEqual('popeye.txt');\n      expect(req.file._url).toEqual('http://www.somewhere.com/popeye.txt');\n      done();\n    });\n    const file = new Parse.File('popeye.txt');\n    await file.destroy({\n      useMasterKey: true\n    });\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSaveFile should not change file if nothing is returned","suites":["saveFile hooks"],"line":3262,"updatePoint":{"line":3262,"column":66,"index":108463},"code":"  it('beforeSaveFile should not change file if nothing is returned', async () => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    Parse.Cloud.beforeSave(Parse.File, () => {\n      return;\n    });\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    const result = await file.save({\n      useMasterKey: true\n    });\n    expect(result).toBe(file);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"throw custom error from beforeSaveFile","suites":["saveFile hooks"],"line":3275,"updatePoint":{"line":3275,"column":44,"index":108842},"code":"  it('throw custom error from beforeSaveFile', async done => {\n    Parse.Cloud.beforeSave(Parse.File, () => {\n      throw new Parse.Error(Parse.Error.SCRIPT_FAILED, 'It should fail');\n    });\n    try {\n      const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n      await file.save({\n        useMasterKey: true\n      });\n      fail('error should have thrown');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SCRIPT_FAILED);\n      done();\n    }\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"throw empty error from beforeSaveFile","suites":["saveFile hooks"],"line":3290,"updatePoint":{"line":3290,"column":43,"index":109316},"code":"  it('throw empty error from beforeSaveFile', async done => {\n    Parse.Cloud.beforeSave(Parse.File, () => {\n      throw null;\n    });\n    try {\n      const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n      await file.save({\n        useMasterKey: true\n      });\n      fail('error should have thrown');\n    } catch (e) {\n      expect(e.code).toBe(130);\n      done();\n    }\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"legacy hooks","suites":["saveFile hooks"],"line":3305,"updatePoint":{"line":3305,"column":18,"index":109687},"code":"  it('legacy hooks', async () => {\n    await reconfigureServer({\n      filesAdapter: mockAdapter\n    });\n    const logger = require('../lib/logger').logger;\n    const logSpy = spyOn(logger, 'warn').and.callFake(() => {});\n    const triggers = {\n      beforeSaveFile(req) {\n        req.file.setTags({\n          tagA: 'some-tag'\n        });\n        req.file.setMetadata({\n          foo: 'bar'\n        });\n        expect(req.triggerName).toEqual('beforeSave');\n        expect(req.master).toBe(true);\n      },\n      afterSaveFile(req) {\n        expect(req.master).toBe(true);\n        expect(req.file._tags).toEqual({\n          tagA: 'some-tag'\n        });\n        expect(req.file._metadata).toEqual({\n          foo: 'bar'\n        });\n      },\n      beforeDeleteFile(req) {\n        expect(req.file).toBeInstanceOf(Parse.File);\n        expect(req.file._name).toEqual('popeye.txt');\n        expect(req.file._url).toEqual('http://www.somewhere.com/popeye.txt');\n        expect(req.fileSize).toBe(null);\n      },\n      afterDeleteFile(req) {\n        expect(req.file).toBeInstanceOf(Parse.File);\n        expect(req.file._name).toEqual('popeye.txt');\n        expect(req.file._url).toEqual('http://www.somewhere.com/popeye.txt');\n      }\n    };\n    for (const key in triggers) {\n      spyOn(triggers, key).and.callThrough();\n      Parse.Cloud[key](triggers[key]);\n    }\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    await file.save({\n      useMasterKey: true\n    });\n    await new Parse.File('popeye.txt', [1, 2, 3], 'text/plain').destroy({\n      useMasterKey: true\n    });\n    await new Promise(resolve => setTimeout(resolve, 100));\n    for (const key in triggers) {\n      expect(triggers[key]).toHaveBeenCalled();\n      expect(logSpy).toHaveBeenCalledWith(`DeprecationWarning: Parse.Cloud.${key} is deprecated and will be removed in a future version. Use Parse.Cloud.${key.replace('File', '')}(Parse.File, (request) => {})`);\n    }\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"can send email via Parse.Cloud","suites":["sendEmail"],"line":3362,"updatePoint":{"line":3362,"column":36,"index":111697},"code":"  it('can send email via Parse.Cloud', async done => {\n    const emailAdapter = {\n      sendMail: mailData => {\n        expect(mailData).toBeDefined();\n        expect(mailData.to).toBe('test');\n        reconfigureServer().then(done, done);\n      }\n    };\n    await reconfigureServer({\n      emailAdapter: emailAdapter\n    });\n    const mailData = {\n      to: 'test'\n    };\n    await Parse.Cloud.sendEmail(mailData);\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"cannot send email without adapter","suites":["sendEmail"],"line":3378,"updatePoint":{"line":3378,"column":39,"index":112122},"code":"  it('cannot send email without adapter', async () => {\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'error').and.callFake(() => {});\n    await Parse.Cloud.sendEmail({});\n    expect(logger.error).toHaveBeenCalledWith('Failed to send email because no mail adapter is configured for Parse Server.');\n  });","file":"CloudCode.spec.js","skipped":false,"dir":"spec"},{"name":"complete validator","suites":["cloud validator"],"line":11,"updatePoint":{"line":11,"column":24,"index":231},"code":"  it('complete validator', async done => {\n    Parse.Cloud.define('myFunction', () => {\n      return 'myFunc';\n    }, () => {});\n    try {\n      const result = await Parse.Cloud.run('myFunction', {});\n      expect(result).toBe('myFunc');\n      done();\n    } catch (e) {\n      fail('should not have thrown error');\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"Throw from validator","suites":["cloud validator"],"line":23,"updatePoint":{"line":23,"column":26,"index":559},"code":"  it('Throw from validator', async done => {\n    Parse.Cloud.define('myFunction', () => {\n      return 'myFunc';\n    }, () => {\n      throw 'error';\n    });\n    try {\n      await Parse.Cloud.run('myFunction');\n      fail('cloud function should have failed.');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validator can throw parse error","suites":["cloud validator"],"line":37,"updatePoint":{"line":37,"column":37,"index":931},"code":"  it('validator can throw parse error', async done => {\n    Parse.Cloud.define('myFunction', () => {\n      return 'myFunc';\n    }, () => {\n      throw new Parse.Error(Parse.Error.SCRIPT_FAILED, 'It should fail');\n    });\n    try {\n      await Parse.Cloud.run('myFunction');\n      fail('should have validation error');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SCRIPT_FAILED);\n      expect(e.message).toBe('It should fail');\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validator can throw parse error with no message","suites":["cloud validator"],"line":52,"updatePoint":{"line":52,"column":53,"index":1411},"code":"  it('validator can throw parse error with no message', async done => {\n    Parse.Cloud.define('myFunction', () => {\n      return 'myFunc';\n    }, () => {\n      throw new Parse.Error(Parse.Error.SCRIPT_FAILED);\n    });\n    try {\n      await Parse.Cloud.run('myFunction');\n      fail('should have validation error');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SCRIPT_FAILED);\n      expect(e.message).toBeUndefined();\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"async validator","suites":["cloud validator"],"line":67,"updatePoint":{"line":67,"column":21,"index":1834},"code":"  it('async validator', async done => {\n    Parse.Cloud.define('myFunction', () => {\n      return 'myFunc';\n    }, async () => {\n      await new Promise(resolve => {\n        setTimeout(resolve, 1000);\n      });\n      throw 'async error';\n    });\n    try {\n      await Parse.Cloud.run('myFunction');\n      fail('should have validation error');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      expect(e.message).toBe('async error');\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"pass function to validator","suites":["cloud validator"],"line":85,"updatePoint":{"line":85,"column":32,"index":2334},"code":"  it('pass function to validator', async done => {\n    const validator = request => {\n      expect(request).toBeDefined();\n      expect(request.params).toBeDefined();\n      expect(request.master).toBe(false);\n      expect(request.user).toBeUndefined();\n      expect(request.installationId).toBeDefined();\n      expect(request.log).toBeDefined();\n      expect(request.headers).toBeDefined();\n      expect(request.functionName).toBeDefined();\n      expect(request.context).toBeDefined();\n      done();\n    };\n    Parse.Cloud.define('myFunction', () => {\n      return 'myFunc';\n    }, validator);\n    await Parse.Cloud.run('myFunction');\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"require user on cloud functions","suites":["cloud validator"],"line":103,"updatePoint":{"line":103,"column":37,"index":2980},"code":"  it('require user on cloud functions', async done => {\n    Parse.Cloud.define('hello1', () => {\n      return 'Hello world!';\n    }, {\n      requireUser: true\n    });\n    try {\n      await Parse.Cloud.run('hello1', {});\n      fail('function should have failed.');\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Please login to continue.');\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"require master on cloud functions","suites":["cloud validator"],"line":118,"updatePoint":{"line":118,"column":39,"index":3443},"code":"  it('require master on cloud functions', done => {\n    Parse.Cloud.define('hello2', () => {\n      return 'Hello world!';\n    }, {\n      requireMaster: true\n    });\n    Parse.Cloud.run('hello2', {}).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Master key is required to complete this request.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params on cloud functions","suites":["cloud validator"],"line":132,"updatePoint":{"line":132,"column":35,"index":3919},"code":"  it('set params on cloud functions', done => {\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    }, {\n      fields: ['a']\n    });\n    Parse.Cloud.run('hello', {}).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Please specify data for a.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params on cloud functions","suites":["cloud validator"],"line":146,"updatePoint":{"line":146,"column":35,"index":4365},"code":"  it('set params on cloud functions', done => {\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    }, {\n      fields: ['a']\n    });\n    Parse.Cloud.run('hello', {}).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Please specify data for a.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"allow params on cloud functions","suites":["cloud validator"],"line":160,"updatePoint":{"line":160,"column":37,"index":4813},"code":"  it('allow params on cloud functions', done => {\n    Parse.Cloud.define('hello', req => {\n      expect(req.params.a).toEqual('yolo');\n      return 'Hello world!';\n    }, {\n      fields: ['a']\n    });\n    Parse.Cloud.run('hello', {\n      a: 'yolo'\n    }).then(() => {\n      done();\n    }).catch(() => {\n      fail('Error should not have been called.');\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params type array","suites":["cloud validator"],"line":175,"updatePoint":{"line":175,"column":27,"index":5170},"code":"  it('set params type array', done => {\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: Array\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {\n      data: ''\n    }).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Invalid type for data. Expected: array');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params type allow array","suites":["cloud validator"],"line":195,"updatePoint":{"line":195,"column":33,"index":5698},"code":"  it('set params type allow array', async () => {\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: Array\n        }\n      }\n    });\n    const result = await Parse.Cloud.run('hello', {\n      data: [{\n        foo: 'bar'\n      }]\n    });\n    expect(result).toBe('Hello world!');\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params type","suites":["cloud validator"],"line":212,"updatePoint":{"line":212,"column":21,"index":6044},"code":"  it('set params type', done => {\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: String\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {\n      data: []\n    }).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Invalid type for data. Expected: string');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params default","suites":["cloud validator"],"line":232,"updatePoint":{"line":232,"column":24,"index":6565},"code":"  it('set params default', done => {\n    Parse.Cloud.define('hello', req => {\n      expect(req.params.data).toBe('yolo');\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: String,\n          default: 'yolo'\n        }\n      }\n    });\n    Parse.Cloud.run('hello').then(() => {\n      done();\n    }).catch(() => {\n      fail('function should not have failed.');\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params required","suites":["cloud validator"],"line":250,"updatePoint":{"line":250,"column":25,"index":6973},"code":"  it('set params required', done => {\n    Parse.Cloud.define('hello', req => {\n      expect(req.params.data).toBe('yolo');\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: String,\n          required: true\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {}).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Please specify data for data.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params not-required options data","suites":["cloud validator"],"line":270,"updatePoint":{"line":270,"column":42,"index":7553},"code":"  it('set params not-required options data', done => {\n    Parse.Cloud.define('hello', req => {\n      expect(req.params.data).toBe('abc');\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: String,\n          required: false,\n          options: s => {\n            return s.length >= 4 && s.length <= 50;\n          },\n          error: 'Validation failed. Expected length of data to be between 4 and 50.'\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {\n      data: 'abc'\n    }).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Expected length of data to be between 4 and 50.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params not-required type","suites":["cloud validator"],"line":296,"updatePoint":{"line":296,"column":34,"index":8344},"code":"  it('set params not-required type', done => {\n    Parse.Cloud.define('hello', req => {\n      expect(req.params.data).toBe(null);\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: String,\n          required: false\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {\n      data: null\n    }).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Invalid type for data. Expected: string');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params not-required options","suites":["cloud validator"],"line":318,"updatePoint":{"line":318,"column":37,"index":8950},"code":"  it('set params not-required options', done => {\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: String,\n          required: false,\n          options: s => {\n            return s.length >= 4 && s.length <= 50;\n          }\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {}).then(() => {\n      done();\n    }).catch(() => {\n      fail('function should not have failed.');\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params not-required no-options","suites":["cloud validator"],"line":338,"updatePoint":{"line":338,"column":40,"index":9423},"code":"  it('set params not-required no-options', done => {\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: String,\n          required: false\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {}).then(() => {\n      done();\n    }).catch(() => {\n      fail('function should not have failed.');\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params option","suites":["cloud validator"],"line":355,"updatePoint":{"line":355,"column":23,"index":9788},"code":"  it('set params option', done => {\n    Parse.Cloud.define('hello', req => {\n      expect(req.params.data).toBe('yolo');\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: String,\n          required: true,\n          options: 'a'\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {\n      data: 'f'\n    }).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Invalid option for data. Expected: a');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params options","suites":["cloud validator"],"line":378,"updatePoint":{"line":378,"column":24,"index":10402},"code":"  it('set params options', done => {\n    Parse.Cloud.define('hello', req => {\n      expect(req.params.data).toBe('yolo');\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: String,\n          required: true,\n          options: ['a', 'b']\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {\n      data: 'f'\n    }).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Invalid option for data. Expected: a, b');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params options function","suites":["cloud validator"],"line":401,"updatePoint":{"line":401,"column":33,"index":11035},"code":"  it('set params options function', done => {\n    Parse.Cloud.define('hello', () => {\n      fail('cloud function should not run.');\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: Number,\n          required: true,\n          options: val => {\n            return val > 1 && val < 5;\n          },\n          error: 'Validation failed. Expected data to be between 1 and 5.'\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {\n      data: 7\n    }).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Expected data to be between 1 and 5.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"can run params function on null","suites":["cloud validator"],"line":427,"updatePoint":{"line":427,"column":37,"index":11793},"code":"  it('can run params function on null', done => {\n    Parse.Cloud.define('hello', () => {\n      fail('cloud function should not run.');\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          options: val => {\n            return val.length > 5;\n          },\n          error: 'Validation failed. String should be at least 5 characters'\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {\n      data: null\n    }).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. String should be at least 5 characters');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"can throw from options validator","suites":["cloud validator"],"line":451,"updatePoint":{"line":451,"column":38,"index":12505},"code":"  it('can throw from options validator', done => {\n    Parse.Cloud.define('hello', () => {\n      fail('cloud function should not run.');\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          options: () => {\n            throw 'validation failed.';\n          }\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {\n      data: 'a'\n    }).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('validation failed.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"can throw null from options validator","suites":["cloud validator"],"line":474,"updatePoint":{"line":474,"column":43,"index":13108},"code":"  it('can throw null from options validator', done => {\n    Parse.Cloud.define('hello', () => {\n      fail('cloud function should not run.');\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          options: () => {\n            throw null;\n          }\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {\n      data: 'a'\n    }).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Invalid value for data.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"can create functions","suites":["cloud validator"],"line":497,"updatePoint":{"line":497,"column":26,"index":13702},"code":"  it('can create functions', done => {\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    }, {\n      requireUser: false,\n      requireMaster: false,\n      fields: {\n        data: {\n          type: String\n        },\n        data1: {\n          type: String,\n          default: 'default'\n        }\n      }\n    });\n    Parse.Cloud.run('hello', {\n      data: 'str'\n    }).then(result => {\n      expect(result).toEqual('Hello world!');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave requireUserKey","suites":["cloud validator"],"line":520,"updatePoint":{"line":520,"column":37,"index":14193},"code":"  it('basic beforeSave requireUserKey', async function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveFail', () => {}, {\n      requireUser: true,\n      requireUserKeys: ['name']\n    });\n    const user = await Parse.User.signUp('testuser', 'p@ssword');\n    user.set('name', 'foo');\n    await user.save(null, {\n      sessionToken: user.getSessionToken()\n    });\n    const obj = new Parse.Object('BeforeSaveFail');\n    obj.set('foo', 'bar');\n    await obj.save(null, {\n      sessionToken: user.getSessionToken()\n    });\n    expect(obj.get('foo')).toBe('bar');\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave skipWithMasterKey","suites":["cloud validator"],"line":538,"updatePoint":{"line":538,"column":40,"index":14771},"code":"  it('basic beforeSave skipWithMasterKey', async function (done) {\n    Parse.Cloud.beforeSave('BeforeSave', () => {\n      throw 'before save should have resolved using masterKey.';\n    }, {\n      skipWithMasterKey: true\n    });\n    const obj = new Parse.Object('BeforeSave');\n    obj.set('foo', 'bar');\n    await obj.save(null, {\n      useMasterKey: true\n    });\n    expect(obj.get('foo')).toBe('bar');\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeFind skipWithMasterKey","suites":["cloud validator"],"line":552,"updatePoint":{"line":552,"column":40,"index":15192},"code":"  it('basic beforeFind skipWithMasterKey', async function (done) {\n    Parse.Cloud.beforeFind('beforeFind', () => {\n      throw 'before find should have resolved using masterKey.';\n    }, {\n      skipWithMasterKey: true\n    });\n    const obj = new Parse.Object('beforeFind');\n    obj.set('foo', 'bar');\n    await obj.save();\n    expect(obj.get('foo')).toBe('bar');\n    const query = new Parse.Query('beforeFind');\n    const first = await query.first({\n      useMasterKey: true\n    });\n    expect(first).toBeDefined();\n    expect(first.id).toBe(obj.id);\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeDelete skipWithMasterKey","suites":["cloud validator"],"line":570,"updatePoint":{"line":570,"column":42,"index":15765},"code":"  it('basic beforeDelete skipWithMasterKey', async function (done) {\n    Parse.Cloud.beforeDelete('beforeFind', () => {\n      throw 'before find should have resolved using masterKey.';\n    }, {\n      skipWithMasterKey: true\n    });\n    const obj = new Parse.Object('beforeFind');\n    obj.set('foo', 'bar');\n    await obj.save();\n    expect(obj.get('foo')).toBe('bar');\n    await obj.destroy({\n      useMasterKey: true\n    });\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSaveFile skipWithMasterKey","suites":["cloud validator"],"line":585,"updatePoint":{"line":585,"column":44,"index":16211},"code":"  it('basic beforeSaveFile skipWithMasterKey', async done => {\n    Parse.Cloud.beforeSave(Parse.File, () => {\n      throw 'beforeSaveFile should have resolved using master key.';\n    }, {\n      skipWithMasterKey: true\n    });\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    const result = await file.save({\n      useMasterKey: true\n    });\n    expect(result).toBe(file);\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave validateMasterKey and skipWithMasterKey fail","suites":["cloud validator"],"line":598,"updatePoint":{"line":598,"column":61,"index":16645},"code":"  it('beforeSave validateMasterKey and skipWithMasterKey fail', async function (done) {\n    Parse.Cloud.beforeSave('BeforeSave', () => {\n      throw 'beforeSaveFile should have resolved using master key.';\n    }, {\n      fields: ['foo'],\n      validateMasterKey: true,\n      skipWithMasterKey: true\n    });\n    const obj = new Parse.Object('BeforeSave');\n    try {\n      await obj.save(null, {\n        useMasterKey: true\n      });\n      fail('function should have failed.');\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Please specify data for foo.');\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave validateMasterKey and skipWithMasterKey success","suites":["cloud validator"],"line":618,"updatePoint":{"line":618,"column":64,"index":17323},"code":"  it('beforeSave validateMasterKey and skipWithMasterKey success', async function (done) {\n    Parse.Cloud.beforeSave('BeforeSave', () => {\n      throw 'beforeSaveFile should have resolved using master key.';\n    }, {\n      fields: ['foo'],\n      validateMasterKey: true,\n      skipWithMasterKey: true\n    });\n    const obj = new Parse.Object('BeforeSave');\n    obj.set('foo', 'bar');\n    try {\n      await obj.save(null, {\n        useMasterKey: true\n      });\n      done();\n    } catch (error) {\n      fail('error should not have been called.');\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave requireUserKey on User Class","suites":["cloud validator"],"line":637,"updatePoint":{"line":637,"column":51,"index":17869},"code":"  it('basic beforeSave requireUserKey on User Class', async function (done) {\n    Parse.Cloud.beforeSave(Parse.User, () => {}, {\n      requireUser: true,\n      requireUserKeys: ['name']\n    });\n    const user = new Parse.User();\n    user.set('username', 'testuser');\n    user.set('password', 'p@ssword');\n    user.set('name', 'foo');\n    expect(user.get('name')).toBe('foo');\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave requireUserKey rejection","suites":["cloud validator"],"line":649,"updatePoint":{"line":649,"column":47,"index":18259},"code":"  it('basic beforeSave requireUserKey rejection', async function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveFail', () => {}, {\n      requireUser: true,\n      requireUserKeys: ['name']\n    });\n    const user = await Parse.User.signUp('testuser', 'p@ssword');\n    const obj = new Parse.Object('BeforeSaveFail');\n    obj.set('foo', 'bar');\n    try {\n      await obj.save(null, {\n        sessionToken: user.getSessionToken()\n      });\n      fail('should not have been able to save without userkey');\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Please set data for name on your account.');\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave requireUserKey without user","suites":["cloud validator"],"line":668,"updatePoint":{"line":668,"column":50,"index":18975},"code":"  it('basic beforeSave requireUserKey without user', async function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveFail', () => {}, {\n      requireUserKeys: ['name']\n    });\n    const obj = new Parse.Object('BeforeSaveFail');\n    obj.set('foo', 'bar');\n    try {\n      await obj.save();\n      fail('should not have been able to save without user');\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Please login to make this request.');\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave requireUserKey as admin","suites":["cloud validator"],"line":683,"updatePoint":{"line":683,"column":46,"index":19507},"code":"  it('basic beforeSave requireUserKey as admin', async function (done) {\n    Parse.Cloud.beforeSave(Parse.User, () => {}, {\n      fields: {\n        admin: {\n          default: false,\n          constant: true\n        }\n      }\n    });\n    Parse.Cloud.define('secureFunction', () => {\n      return \"Here's all the secure data!\";\n    }, {\n      requireUserKeys: {\n        admin: {\n          options: true,\n          error: 'Unauthorized.'\n        }\n      }\n    });\n    const user = new Parse.User();\n    user.set('username', 'testuser');\n    user.set('password', 'p@ssword');\n    user.set('admin', true);\n    await user.signUp();\n    expect(user.get('admin')).toBe(false);\n    try {\n      await Parse.Cloud.run('secureFunction');\n      fail('function should only be available to admin users');\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Unauthorized.');\n    }\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave requireUserKey as custom function","suites":["cloud validator"],"line":717,"updatePoint":{"line":717,"column":56,"index":20472},"code":"  it('basic beforeSave requireUserKey as custom function', async function (done) {\n    Parse.Cloud.beforeSave(Parse.User, () => {}, {\n      fields: {\n        accType: {\n          default: 'normal',\n          constant: true\n        }\n      }\n    });\n    Parse.Cloud.define('secureFunction', () => {\n      return \"Here's all the secure data!\";\n    }, {\n      requireUserKeys: {\n        accType: {\n          options: val => {\n            return ['admin', 'admin2'].includes(val);\n          },\n          error: 'Unauthorized.'\n        }\n      }\n    });\n    const user = new Parse.User();\n    user.set('username', 'testuser');\n    user.set('password', 'p@ssword');\n    user.set('accType', 'admin');\n    await user.signUp();\n    expect(user.get('accType')).toBe('normal');\n    try {\n      await Parse.Cloud.run('secureFunction');\n      fail('function should only be available to admin users');\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Unauthorized.');\n    }\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave allow requireUserKey as custom function","suites":["cloud validator"],"line":753,"updatePoint":{"line":753,"column":62,"index":21530},"code":"  it('basic beforeSave allow requireUserKey as custom function', async function (done) {\n    Parse.Cloud.beforeSave(Parse.User, () => {}, {\n      fields: {\n        accType: {\n          default: 'admin',\n          constant: true\n        }\n      }\n    });\n    Parse.Cloud.define('secureFunction', () => {\n      return \"Here's all the secure data!\";\n    }, {\n      requireUserKeys: {\n        accType: {\n          options: val => {\n            return ['admin', 'admin2'].includes(val);\n          },\n          error: 'Unauthorized.'\n        }\n      }\n    });\n    const user = new Parse.User();\n    user.set('username', 'testuser');\n    user.set('password', 'p@ssword');\n    await user.signUp();\n    expect(user.get('accType')).toBe('admin');\n    const result = await Parse.Cloud.run('secureFunction');\n    expect(result).toBe(\"Here's all the secure data!\");\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave requireUser","suites":["cloud validator"],"line":783,"updatePoint":{"line":783,"column":34,"index":22373},"code":"  it('basic beforeSave requireUser', function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveFail', () => {}, {\n      requireUser: true\n    });\n    const obj = new Parse.Object('BeforeSaveFail');\n    obj.set('foo', 'bar');\n    obj.save().then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Please login to continue.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic validator requireAnyUserRoles","suites":["cloud validator"],"line":797,"updatePoint":{"line":797,"column":41,"index":22876},"code":"  it('basic validator requireAnyUserRoles', async function (done) {\n    Parse.Cloud.define('cloudFunction', () => {\n      return true;\n    }, {\n      requireUser: true,\n      requireAnyUserRoles: ['Admin']\n    });\n    const user = await Parse.User.signUp('testuser', 'p@ssword');\n    try {\n      await Parse.Cloud.run('cloudFunction');\n      fail('cloud validator should have failed.');\n    } catch (e) {\n      expect(e.message).toBe('Validation failed. User does not match the required roles.');\n    }\n    const roleACL = new Parse.ACL();\n    roleACL.setPublicReadAccess(true);\n    const role = new Parse.Role('Admin', roleACL);\n    role.getUsers().add(user);\n    await role.save({\n      useMasterKey: true\n    });\n    await Parse.Cloud.run('cloudFunction');\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic validator requireAllUserRoles","suites":["cloud validator"],"line":821,"updatePoint":{"line":821,"column":41,"index":23654},"code":"  it('basic validator requireAllUserRoles', async function (done) {\n    Parse.Cloud.define('cloudFunction', () => {\n      return true;\n    }, {\n      requireUser: true,\n      requireAllUserRoles: ['Admin', 'Admin2']\n    });\n    const user = await Parse.User.signUp('testuser', 'p@ssword');\n    try {\n      await Parse.Cloud.run('cloudFunction');\n      fail('cloud validator should have failed.');\n    } catch (e) {\n      expect(e.message).toBe('Validation failed. User does not match all the required roles.');\n    }\n    const roleACL = new Parse.ACL();\n    roleACL.setPublicReadAccess(true);\n    const role = new Parse.Role('Admin', roleACL);\n    role.getUsers().add(user);\n    const role2 = new Parse.Role('Admin2', roleACL);\n    role2.getUsers().add(user);\n    await role.save({\n      useMasterKey: true\n    });\n    await role2.save({\n      useMasterKey: true\n    });\n    await Parse.Cloud.run('cloudFunction');\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"allow requireAnyUserRoles to be a function","suites":["cloud validator"],"line":850,"updatePoint":{"line":850,"column":48,"index":24594},"code":"  it('allow requireAnyUserRoles to be a function', async function (done) {\n    Parse.Cloud.define('cloudFunction', () => {\n      return true;\n    }, {\n      requireUser: true,\n      requireAnyUserRoles: () => {\n        return ['Admin Func'];\n      }\n    });\n    const user = await Parse.User.signUp('testuser', 'p@ssword');\n    try {\n      await Parse.Cloud.run('cloudFunction');\n      fail('cloud validator should have failed.');\n    } catch (e) {\n      expect(e.message).toBe('Validation failed. User does not match the required roles.');\n    }\n    const roleACL = new Parse.ACL();\n    roleACL.setPublicReadAccess(true);\n    const role = new Parse.Role('Admin Func', roleACL);\n    role.getUsers().add(user);\n    await role.save({\n      useMasterKey: true\n    });\n    await Parse.Cloud.run('cloudFunction');\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"allow requireAllUserRoles to be a function","suites":["cloud validator"],"line":876,"updatePoint":{"line":876,"column":48,"index":25421},"code":"  it('allow requireAllUserRoles to be a function', async function (done) {\n    Parse.Cloud.define('cloudFunction', () => {\n      return true;\n    }, {\n      requireUser: true,\n      requireAllUserRoles: () => {\n        return ['AdminA', 'AdminB'];\n      }\n    });\n    const user = await Parse.User.signUp('testuser', 'p@ssword');\n    try {\n      await Parse.Cloud.run('cloudFunction');\n      fail('cloud validator should have failed.');\n    } catch (e) {\n      expect(e.message).toBe('Validation failed. User does not match all the required roles.');\n    }\n    const roleACL = new Parse.ACL();\n    roleACL.setPublicReadAccess(true);\n    const role = new Parse.Role('AdminA', roleACL);\n    role.getUsers().add(user);\n    const role2 = new Parse.Role('AdminB', roleACL);\n    role2.getUsers().add(user);\n    await role.save({\n      useMasterKey: true\n    });\n    await role2.save({\n      useMasterKey: true\n    });\n    await Parse.Cloud.run('cloudFunction');\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic requireAllUserRoles but no user","suites":["cloud validator"],"line":907,"updatePoint":{"line":907,"column":43,"index":26390},"code":"  it('basic requireAllUserRoles but no user', async function (done) {\n    Parse.Cloud.define('cloudFunction', () => {\n      return true;\n    }, {\n      requireAllUserRoles: ['Admin']\n    });\n    try {\n      await Parse.Cloud.run('cloudFunction');\n      fail('cloud validator should have failed.');\n    } catch (e) {\n      expect(e.message).toBe('Validation failed. Please login to continue.');\n    }\n    const user = await Parse.User.signUp('testuser', 'p@ssword');\n    const roleACL = new Parse.ACL();\n    roleACL.setPublicReadAccess(true);\n    const role = new Parse.Role('Admin', roleACL);\n    role.getUsers().add(user);\n    await role.save({\n      useMasterKey: true\n    });\n    await Parse.Cloud.run('cloudFunction');\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave requireMaster","suites":["cloud validator"],"line":930,"updatePoint":{"line":930,"column":36,"index":27124},"code":"  it('basic beforeSave requireMaster', function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveFail', () => {}, {\n      requireMaster: true\n    });\n    const obj = new Parse.Object('BeforeSaveFail');\n    obj.set('foo', 'bar');\n    obj.save().then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Master key is required to complete this request.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave master","suites":["cloud validator"],"line":944,"updatePoint":{"line":944,"column":29,"index":27640},"code":"  it('basic beforeSave master', async function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveFail', () => {}, {\n      requireUser: true\n    });\n    const obj = new Parse.Object('BeforeSaveFail');\n    obj.set('foo', 'bar');\n    await obj.save(null, {\n      useMasterKey: true\n    });\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave validateMasterKey","suites":["cloud validator"],"line":955,"updatePoint":{"line":955,"column":40,"index":27953},"code":"  it('basic beforeSave validateMasterKey', function (done) {\n    Parse.Cloud.beforeSave('BeforeSaveFail', () => {}, {\n      requireUser: true,\n      validateMasterKey: true\n    });\n    const obj = new Parse.Object('BeforeSaveFail');\n    obj.set('foo', 'bar');\n    obj.save(null, {\n      useMasterKey: true\n    }).then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Please login to continue.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave requireKeys","suites":["cloud validator"],"line":972,"updatePoint":{"line":972,"column":34,"index":28518},"code":"  it('basic beforeSave requireKeys', function (done) {\n    Parse.Cloud.beforeSave('beforeSaveRequire', () => {}, {\n      fields: {\n        foo: {\n          required: true\n        },\n        bar: {\n          required: true\n        }\n      }\n    });\n    const obj = new Parse.Object('beforeSaveRequire');\n    obj.set('foo', 'bar');\n    obj.save().then(() => {\n      fail('function should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed. Please specify data for bar.');\n      done();\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave constantKeys","suites":["cloud validator"],"line":993,"updatePoint":{"line":993,"column":35,"index":29125},"code":"  it('basic beforeSave constantKeys', async function (done) {\n    Parse.Cloud.beforeSave('BeforeSave', () => {}, {\n      fields: {\n        foo: {\n          constant: true,\n          default: 'bar'\n        }\n      }\n    });\n    const obj = new Parse.Object('BeforeSave');\n    obj.set('foo', 'far');\n    await obj.save();\n    expect(obj.get('foo')).toBe('bar');\n    obj.set('foo', 'yolo');\n    await obj.save();\n    expect(obj.get('foo')).toBe('bar');\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave defaultKeys","suites":["cloud validator"],"line":1011,"updatePoint":{"line":1011,"column":34,"index":29592},"code":"  it('basic beforeSave defaultKeys', async function (done) {\n    Parse.Cloud.beforeSave('BeforeSave', () => {}, {\n      fields: {\n        foo: {\n          default: 'bar'\n        }\n      }\n    });\n    const obj = new Parse.Object('BeforeSave');\n    await obj.save();\n    expect(obj.get('foo')).toBe('bar');\n    obj.set('foo', 'yolo');\n    await obj.save();\n    expect(obj.get('foo')).toBe('yolo');\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate beforeSave","suites":["cloud validator"],"line":1027,"updatePoint":{"line":1027,"column":25,"index":29998},"code":"  it('validate beforeSave', async done => {\n    Parse.Cloud.beforeSave('MyObject', () => {}, validatorSuccess);\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    try {\n      await myObject.save();\n      done();\n    } catch (e) {\n      fail('before save should not have failed.');\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate beforeSave fail","suites":["cloud validator"],"line":1038,"updatePoint":{"line":1038,"column":30,"index":30340},"code":"  it('validate beforeSave fail', async done => {\n    Parse.Cloud.beforeSave('MyObject', () => {}, validatorFail);\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    try {\n      await myObject.save();\n      fail('cloud function should have failed.');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate afterSave","suites":["cloud validator"],"line":1050,"updatePoint":{"line":1050,"column":24,"index":30729},"code":"  it('validate afterSave', async done => {\n    Parse.Cloud.afterSave('MyObject', () => {\n      done();\n    }, validatorSuccess);\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    try {\n      await myObject.save();\n    } catch (e) {\n      fail('before save should not have failed.');\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate afterSave fail","suites":["cloud validator"],"line":1062,"updatePoint":{"line":1062,"column":29,"index":31074},"code":"  it('validate afterSave fail', async done => {\n    Parse.Cloud.afterSave('MyObject', () => {\n      fail('this should not be called.');\n    }, validatorFail);\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    await myObject.save();\n    setTimeout(() => {\n      done();\n    }, 1000);\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate beforeDelete","suites":["cloud validator"],"line":1073,"updatePoint":{"line":1073,"column":27,"index":31406},"code":"  it('validate beforeDelete', async done => {\n    Parse.Cloud.beforeDelete('MyObject', () => {}, validatorSuccess);\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    await myObject.save();\n    try {\n      await myObject.destroy();\n      done();\n    } catch (e) {\n      fail('before delete should not have failed.');\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate beforeDelete fail","suites":["cloud validator"],"line":1085,"updatePoint":{"line":1085,"column":32,"index":31784},"code":"  it('validate beforeDelete fail', async done => {\n    Parse.Cloud.beforeDelete('MyObject', () => {\n      fail('this should not be called.');\n    }, validatorFail);\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    await myObject.save();\n    try {\n      await myObject.destroy();\n      fail('cloud function should have failed.');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate afterDelete","suites":["cloud validator"],"line":1100,"updatePoint":{"line":1100,"column":26,"index":32254},"code":"  it('validate afterDelete', async done => {\n    Parse.Cloud.afterDelete('MyObject', () => {\n      done();\n    }, validatorSuccess);\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    await myObject.save();\n    try {\n      await myObject.destroy();\n    } catch (e) {\n      fail('after delete should not have failed.');\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate afterDelete fail","suites":["cloud validator"],"line":1113,"updatePoint":{"line":1113,"column":31,"index":32634},"code":"  it('validate afterDelete fail', async done => {\n    Parse.Cloud.afterDelete('MyObject', () => {\n      fail('this should not be called.');\n    }, validatorFail);\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    await myObject.save();\n    try {\n      await myObject.destroy();\n      fail('cloud function should have failed.');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate beforeFind","suites":["cloud validator"],"line":1128,"updatePoint":{"line":1128,"column":25,"index":33102},"code":"  it('validate beforeFind', async done => {\n    Parse.Cloud.beforeFind('MyObject', () => {}, validatorSuccess);\n    try {\n      const MyObject = Parse.Object.extend('MyObject');\n      const myObjectQuery = new Parse.Query(MyObject);\n      await myObjectQuery.find();\n      done();\n    } catch (e) {\n      fail('beforeFind should not have failed.');\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate beforeFind fail","suites":["cloud validator"],"line":1139,"updatePoint":{"line":1139,"column":30,"index":33468},"code":"  it('validate beforeFind fail', async done => {\n    Parse.Cloud.beforeFind('MyObject', () => {}, validatorFail);\n    try {\n      const MyObject = Parse.Object.extend('MyObject');\n      const myObjectQuery = new Parse.Query(MyObject);\n      await myObjectQuery.find();\n      fail('cloud function should have failed.');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate afterFind","suites":["cloud validator"],"line":1151,"updatePoint":{"line":1151,"column":24,"index":33882},"code":"  it('validate afterFind', async done => {\n    Parse.Cloud.afterFind('MyObject', () => {}, validatorSuccess);\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    await myObject.save();\n    try {\n      const myObjectQuery = new Parse.Query(MyObject);\n      await myObjectQuery.find();\n      done();\n    } catch (e) {\n      fail('beforeFind should not have failed.');\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate afterFind fail","suites":["cloud validator"],"line":1164,"updatePoint":{"line":1164,"column":29,"index":34308},"code":"  it('validate afterFind fail', async done => {\n    Parse.Cloud.afterFind('MyObject', () => {}, validatorFail);\n    const MyObject = Parse.Object.extend('MyObject');\n    const myObject = new MyObject();\n    await myObject.save();\n    try {\n      const myObjectQuery = new Parse.Query(MyObject);\n      await myObjectQuery.find();\n      fail('cloud function should have failed.');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate beforeSaveFile","suites":["cloud validator"],"line":1178,"updatePoint":{"line":1178,"column":29,"index":34788},"code":"  it('validate beforeSaveFile', async done => {\n    Parse.Cloud.beforeSave(Parse.File, () => {}, validatorSuccess);\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    const result = await file.save({\n      useMasterKey: true\n    });\n    expect(result).toBe(file);\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate beforeSaveFile fail","suites":["cloud validator"],"line":1187,"updatePoint":{"line":1187,"column":34,"index":35100},"code":"  it('validate beforeSaveFile fail', async done => {\n    Parse.Cloud.beforeSave(Parse.File, () => {}, validatorFail);\n    try {\n      const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n      await file.save({\n        useMasterKey: true\n      });\n      fail('cloud function should have failed.');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate afterSaveFile","suites":["cloud validator"],"line":1200,"updatePoint":{"line":1200,"column":28,"index":35508},"code":"  it('validate afterSaveFile', async done => {\n    Parse.Cloud.afterSave(Parse.File, () => {}, validatorSuccess);\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    const result = await file.save({\n      useMasterKey: true\n    });\n    expect(result).toBe(file);\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate afterSaveFile fail","suites":["cloud validator"],"line":1209,"updatePoint":{"line":1209,"column":33,"index":35818},"code":"  it('validate afterSaveFile fail', async done => {\n    Parse.Cloud.beforeSave(Parse.File, () => {}, validatorFail);\n    try {\n      const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n      await file.save({\n        useMasterKey: true\n      });\n      fail('cloud function should have failed.');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate beforeDeleteFile","suites":["cloud validator"],"line":1222,"updatePoint":{"line":1222,"column":31,"index":36229},"code":"  it('validate beforeDeleteFile', async done => {\n    Parse.Cloud.beforeDelete(Parse.File, () => {}, validatorSuccess);\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    await file.save();\n    await file.destroy();\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate beforeDeleteFile fail","suites":["cloud validator"],"line":1229,"updatePoint":{"line":1229,"column":36,"index":36493},"code":"  it('validate beforeDeleteFile fail', async done => {\n    Parse.Cloud.beforeDelete(Parse.File, () => {}, validatorFail);\n    try {\n      const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n      await file.save();\n      await file.destroy();\n      fail('cloud function should have failed.');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate afterDeleteFile","suites":["cloud validator"],"line":1241,"updatePoint":{"line":1241,"column":30,"index":36897},"code":"  it('validate afterDeleteFile', async done => {\n    Parse.Cloud.afterDelete(Parse.File, () => {}, validatorSuccess);\n    const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n    await file.save();\n    await file.destroy();\n    done();\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"validate afterDeleteFile fail","suites":["cloud validator"],"line":1248,"updatePoint":{"line":1248,"column":35,"index":37159},"code":"  it('validate afterDeleteFile fail', async done => {\n    Parse.Cloud.afterDelete(Parse.File, () => {}, validatorFail);\n    try {\n      const file = new Parse.File('popeye.txt', [1, 2, 3], 'text/plain');\n      await file.save();\n      await file.destroy();\n      fail('cloud function should have failed.');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"Should have validator","suites":["cloud validator"],"line":1260,"updatePoint":{"line":1260,"column":27,"index":37559},"code":"  it('Should have validator', async done => {\n    Parse.Cloud.define('myFunction', () => {}, () => {\n      throw 'error';\n    });\n    try {\n      await Parse.Cloud.run('myFunction');\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.VALIDATION_ERROR);\n      done();\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"does not log on valid config","suites":["cloud validator"],"line":1271,"updatePoint":{"line":1271,"column":34,"index":37850},"code":"  it('does not log on valid config', () => {\n    Parse.Cloud.define('myFunction', () => {}, {\n      requireUser: true,\n      requireMaster: true,\n      validateMasterKey: false,\n      skipWithMasterKey: true,\n      requireUserKeys: {\n        Acc: {\n          constant: true,\n          options: ['A', 'B'],\n          required: true,\n          default: 'f',\n          error: 'a',\n          type: String\n        }\n      },\n      fields: {\n        Acc: {\n          constant: true,\n          options: ['A', 'B'],\n          required: true,\n          default: 'f',\n          error: 'a',\n          type: String\n        }\n      }\n    });\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"Logs on invalid config","suites":["cloud validator"],"line":1299,"updatePoint":{"line":1299,"column":28,"index":38479},"code":"  it('Logs on invalid config', () => {\n    const fields = [{\n      field: 'requiredUser',\n      value: true,\n      error: 'requiredUser is not a supported parameter for Cloud Function validations.'\n    }, {\n      field: 'requireUser',\n      value: [],\n      error: 'Invalid type for Cloud Function validation key requireUser. Expected boolean, actual array'\n    }, {\n      field: 'requireMaster',\n      value: [],\n      error: 'Invalid type for Cloud Function validation key requireMaster. Expected boolean, actual array'\n    }, {\n      field: 'validateMasterKey',\n      value: [],\n      error: 'Invalid type for Cloud Function validation key validateMasterKey. Expected boolean, actual array'\n    }, {\n      field: 'skipWithMasterKey',\n      value: [],\n      error: 'Invalid type for Cloud Function validation key skipWithMasterKey. Expected boolean, actual array'\n    }, {\n      field: 'requireAllUserRoles',\n      value: true,\n      error: 'Invalid type for Cloud Function validation key requireAllUserRoles. Expected array|function, actual boolean'\n    }, {\n      field: 'requireAnyUserRoles',\n      value: true,\n      error: 'Invalid type for Cloud Function validation key requireAnyUserRoles. Expected array|function, actual boolean'\n    }, {\n      field: 'fields',\n      value: true,\n      error: 'Invalid type for Cloud Function validation key fields. Expected array|object, actual boolean'\n    }, {\n      field: 'requireUserKeys',\n      value: true,\n      error: 'Invalid type for Cloud Function validation key requireUserKeys. Expected array|object, actual boolean'\n    }];\n    for (const field of fields) {\n      try {\n        Parse.Cloud.define('myFunction', () => {}, {\n          [field.field]: field.value\n        });\n        fail(`Expected error registering invalid Cloud Function validation ${field.field}.`);\n      } catch (e) {\n        expect(e).toBe(field.error);\n      }\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"Logs on invalid config","suites":["cloud validator"],"line":1348,"updatePoint":{"line":1348,"column":28,"index":40382},"code":"  it('Logs on invalid config', () => {\n    const fields = [{\n      field: 'otherKey',\n      value: true,\n      error: 'otherKey is not a supported parameter for Cloud Function validations.'\n    }, {\n      field: 'constant',\n      value: [],\n      error: 'Invalid type for Cloud Function validation key constant. Expected boolean, actual array'\n    }, {\n      field: 'required',\n      value: [],\n      error: 'Invalid type for Cloud Function validation key required. Expected boolean, actual array'\n    }, {\n      field: 'error',\n      value: [],\n      error: 'Invalid type for Cloud Function validation key error. Expected string, actual array'\n    }];\n    for (const field of fields) {\n      try {\n        Parse.Cloud.define('myFunction', () => {}, {\n          fields: {\n            name: {\n              [field.field]: field.value\n            }\n          }\n        });\n        fail(`Expected error registering invalid Cloud Function validation ${field.field}.`);\n      } catch (e) {\n        expect(e).toBe(field.error);\n      }\n      try {\n        Parse.Cloud.define('myFunction', () => {}, {\n          requireUserKeys: {\n            name: {\n              [field.field]: field.value\n            }\n          }\n        });\n        fail(`Expected error registering invalid Cloud Function validation ${field.field}.`);\n      } catch (e) {\n        expect(e).toBe(field.error);\n      }\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"set params options function async","suites":["cloud validator"],"line":1393,"updatePoint":{"line":1393,"column":39,"index":41787},"code":"  it('set params options function async', async () => {\n    Parse.Cloud.define('hello', () => {\n      return 'Hello world!';\n    }, {\n      fields: {\n        data: {\n          type: String,\n          required: true,\n          options: async val => {\n            await new Promise(resolve => {\n              setTimeout(resolve, 500);\n            });\n            return val === 'f';\n          },\n          error: 'Validation failed.'\n        }\n      }\n    });\n    try {\n      await Parse.Cloud.run('hello', {\n        data: 'd'\n      });\n      fail('validation should have failed');\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Validation failed.');\n    }\n    const result = await Parse.Cloud.run('hello', {\n      data: 'f'\n    });\n    expect(result).toBe('Hello world!');\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSave requireUserKey as custom async function","suites":["cloud validator"],"line":1425,"updatePoint":{"line":1425,"column":62,"index":42664},"code":"  it('basic beforeSave requireUserKey as custom async function', async () => {\n    Parse.Cloud.beforeSave(Parse.User, () => {}, {\n      fields: {\n        accType: {\n          default: 'normal',\n          constant: true\n        }\n      }\n    });\n    Parse.Cloud.define('secureFunction', () => {\n      return \"Here's all the secure data!\";\n    }, {\n      requireUserKeys: {\n        accType: {\n          options: async val => {\n            await new Promise(resolve => {\n              setTimeout(resolve, 500);\n            });\n            return ['admin', 'admin2'].includes(val);\n          },\n          error: 'Unauthorized.'\n        }\n      }\n    });\n    const user = new Parse.User();\n    user.set('username', 'testuser');\n    user.set('password', 'p@ssword');\n    user.set('accType', 'admin');\n    await user.signUp();\n    expect(user.get('accType')).toBe('normal');\n    try {\n      await Parse.Cloud.run('secureFunction');\n      fail('function should only be available to admin users');\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n      expect(error.message).toEqual('Unauthorized.');\n    }\n  });","file":"CloudCode.Validator.spec.js","skipped":false,"dir":"spec"},{"name":"should expose log to functions","suites":["Cloud Code Logger"],"line":25,"updatePoint":{"line":25,"column":36,"index":997},"code":"  it('should expose log to functions', () => {\n    const spy = spyOn(Config.get('test').loggerController, 'log').and.callThrough();\n    Parse.Cloud.define('loggerTest', req => {\n      req.log.info('logTest', 'info log', {\n        info: 'some log'\n      });\n      req.log.error('logTest', 'error log', {\n        error: 'there was an error'\n      });\n      return {};\n    });\n    return Parse.Cloud.run('loggerTest').then(() => {\n      expect(spy).toHaveBeenCalledTimes(3);\n      const cloudFunctionMessage = spy.calls.all()[2];\n      const errorMessage = spy.calls.all()[1];\n      const infoMessage = spy.calls.all()[0];\n      expect(cloudFunctionMessage.args[0]).toBe('info');\n      expect(cloudFunctionMessage.args[1][1].params).toEqual({});\n      expect(cloudFunctionMessage.args[1][0]).toMatch(/Ran cloud function loggerTest for user [^ ]* with:\\n {2}Input: {}\\n {2}Result: {}/);\n      expect(cloudFunctionMessage.args[1][1].functionName).toEqual('loggerTest');\n      expect(errorMessage.args[0]).toBe('error');\n      expect(errorMessage.args[1][2].error).toBe('there was an error');\n      expect(errorMessage.args[1][0]).toBe('logTest');\n      expect(errorMessage.args[1][1]).toBe('error log');\n      expect(infoMessage.args[0]).toBe('info');\n      expect(infoMessage.args[1][2].info).toBe('some log');\n      expect(infoMessage.args[1][0]).toBe('logTest');\n      expect(infoMessage.args[1][1]).toBe('info log');\n    });\n  });","file":"CloudCodeLogger.spec.js","skipped":false,"dir":"spec"},{"name":"trigger should obfuscate password","suites":["Cloud Code Logger"],"line":55,"updatePoint":{"line":55,"column":39,"index":2430},"code":"  it('trigger should obfuscate password', done => {\n    Parse.Cloud.beforeSave(Parse.User, req => {\n      return req.object;\n    });\n    Parse.User.signUp('tester123', 'abc').then(() => {\n      const entry = spy.calls.mostRecent().args;\n      expect(entry[1]).not.toMatch(/password\":\"abc/);\n      expect(entry[1]).toMatch(/\\*\\*\\*\\*\\*\\*\\*\\*/);\n      done();\n    }).then(null, e => done.fail(e));\n  });","file":"CloudCodeLogger.spec.js","skipped":false,"dir":"spec"},{"name":"should expose log to trigger","suites":["Cloud Code Logger"],"line":66,"updatePoint":{"line":66,"column":34,"index":2826},"code":"  it('should expose log to trigger', done => {\n    Parse.Cloud.beforeSave('MyObject', req => {\n      req.log.info('beforeSave MyObject', 'info log', {\n        info: 'some log'\n      });\n      req.log.error('beforeSave MyObject', 'error log', {\n        error: 'there was an error'\n      });\n      return {};\n    });\n    const obj = new Parse.Object('MyObject');\n    obj.save().then(() => {\n      const lastCalls = spy.calls.all().reverse();\n      const cloudTriggerMessage = lastCalls[0].args;\n      const errorMessage = lastCalls[1].args;\n      const infoMessage = lastCalls[2].args;\n      expect(cloudTriggerMessage[0]).toBe('info');\n      expect(cloudTriggerMessage[2].triggerType).toEqual('beforeSave');\n      expect(cloudTriggerMessage[1]).toMatch(/beforeSave triggered for MyObject for user [^ ]*\\n {2}Input: {}\\n {2}Result: {\"object\":{}}/);\n      expect(cloudTriggerMessage[2].user).toBe(user.id);\n      expect(errorMessage[0]).toBe('error');\n      expect(errorMessage[3].error).toBe('there was an error');\n      expect(errorMessage[1] + ' ' + errorMessage[2]).toBe('beforeSave MyObject error log');\n      expect(infoMessage[0]).toBe('info');\n      expect(infoMessage[3].info).toBe('some log');\n      expect(infoMessage[1] + ' ' + infoMessage[2]).toBe('beforeSave MyObject info log');\n      done();\n    });\n  });","file":"CloudCodeLogger.spec.js","skipped":false,"dir":"spec"},{"name":"should truncate really long lines when asked to","suites":["Cloud Code Logger"],"line":95,"updatePoint":{"line":95,"column":53,"index":4164},"code":"  it('should truncate really long lines when asked to', () => {\n    const logController = new LoggerController(new WinstonLoggerAdapter());\n    const longString = fs.readFileSync(loremFile, 'utf8');\n    const truncatedString = logController.truncateLogMessage(longString);\n    expect(truncatedString.length).toBe(1015); // truncate length + the string '... (truncated)'\n  });","file":"CloudCodeLogger.spec.js","skipped":false,"dir":"spec"},{"name":"should truncate input and result of long lines","suites":["Cloud Code Logger"],"line":102,"updatePoint":{"line":102,"column":52,"index":4540},"code":"  it('should truncate input and result of long lines', done => {\n    const longString = fs.readFileSync(loremFile, 'utf8');\n    Parse.Cloud.define('aFunction', req => {\n      return req.params;\n    });\n    Parse.Cloud.run('aFunction', {\n      longString\n    }).then(() => {\n      const log = spy.calls.mostRecent().args;\n      expect(log[0]).toEqual('info');\n      expect(log[1]).toMatch(/Ran cloud function aFunction for user [^ ]* with:\\n {2}Input: {.*?\\(truncated\\)$/m);\n      done();\n    }).then(null, e => done.fail(e));\n  });","file":"CloudCodeLogger.spec.js","skipped":false,"dir":"spec"},{"name":"should log an afterSave","suites":["Cloud Code Logger"],"line":116,"updatePoint":{"line":116,"column":29,"index":5049},"code":"  it('should log an afterSave', done => {\n    Parse.Cloud.afterSave('MyObject', () => {});\n    new Parse.Object('MyObject').save().then(() => {\n      const log = spy.calls.mostRecent().args;\n      expect(log[2].triggerType).toEqual('afterSave');\n      done();\n    })\n    // catch errors - not that the error is actually useful :(\n    .then(null, e => done.fail(e));\n  });","file":"CloudCodeLogger.spec.js","skipped":false,"dir":"spec"},{"name":"should log a denied beforeSave","suites":["Cloud Code Logger"],"line":126,"updatePoint":{"line":126,"column":36,"index":5428},"code":"  it('should log a denied beforeSave', done => {\n    Parse.Cloud.beforeSave('MyObject', () => {\n      throw 'uh oh!';\n    });\n    new Parse.Object('MyObject').save().then(() => done.fail('this is not supposed to succeed'), () => new Promise(resolve => setTimeout(resolve, 100))).then(() => {\n      const logs = spy.calls.all().reverse();\n      const log = logs[1].args; // 0 is the 'uh oh!' from rejection...\n      expect(log[0]).toEqual('error');\n      const error = log[2].error;\n      expect(error instanceof Parse.Error).toBeTruthy();\n      expect(error.code).toBe(Parse.Error.SCRIPT_FAILED);\n      expect(error.message).toBe('uh oh!');\n      done();\n    });\n  });","file":"CloudCodeLogger.spec.js","skipped":false,"dir":"spec"},{"name":"should log cloud function success","suites":["Cloud Code Logger"],"line":141,"updatePoint":{"line":141,"column":39,"index":6100},"code":"  it('should log cloud function success', done => {\n    Parse.Cloud.define('aFunction', () => {\n      return 'it worked!';\n    });\n    Parse.Cloud.run('aFunction', {\n      foo: 'bar'\n    }).then(() => {\n      const log = spy.calls.mostRecent().args;\n      expect(log[0]).toEqual('info');\n      expect(log[1]).toMatch(/Ran cloud function aFunction for user [^ ]* with:\\n {2}Input: {\"foo\":\"bar\"}\\n {2}Result: \"it worked!/);\n      done();\n    });\n  });","file":"CloudCodeLogger.spec.js","skipped":false,"dir":"spec"},{"name":"should log cloud function failure","suites":["Cloud Code Logger"],"line":154,"updatePoint":{"line":154,"column":39,"index":6550},"code":"  it('should log cloud function failure', done => {\n    Parse.Cloud.define('aFunction', () => {\n      throw 'it failed!';\n    });\n    Parse.Cloud.run('aFunction', {\n      foo: 'bar'\n    }).catch(() => {}).then(() => {\n      const logs = spy.calls.all().reverse();\n      expect(logs[0].args[1]).toBe('Parse error: ');\n      expect(logs[0].args[2].message).toBe('it failed!');\n      const log = logs[1].args;\n      expect(log[0]).toEqual('error');\n      expect(log[1]).toMatch(/Failed running cloud function aFunction for user [^ ]* with:\\n {2}Input: {\"foo\":\"bar\"}\\n {2}Error:/);\n      const errorString = JSON.stringify(new Parse.Error(Parse.Error.SCRIPT_FAILED, 'it failed!'));\n      expect(log[1].indexOf(errorString)).toBeGreaterThan(0);\n      done();\n    }).catch(done.fail);\n  });","file":"CloudCodeLogger.spec.js","skipped":false,"dir":"spec"},{"name":"should log a changed beforeSave indicating a change","suites":["Cloud Code Logger"],"line":172,"updatePoint":{"line":172,"column":58,"index":7354},"skipped":true,"code":"  xit('should log a changed beforeSave indicating a change', done => {\n    const logController = new LoggerController(new WinstonLoggerAdapter());\n    Parse.Cloud.beforeSave('MyObject', req => {\n      const myObj = req.object;\n      myObj.set('aChange', true);\n      return myObj;\n    });\n    new Parse.Object('MyObject').save().then(() => logController.getLogs({\n      from: Date.now() - 500,\n      size: 1000\n    })).then(() => {\n      // expect the log to indicate that it has changed\n      /*\n                  Here's what it looks like on parse.com...\n                   Input: {\"original\":{\"clientVersion\":\"1\",\"createdAt\":\"2016-06-02T05:29:08.694Z\",\"image\":{\"__type\":\"File\",\"name\":\"tfss-xxxxxxxx.png\",\"url\":\"http://files.parsetfss.com/xxxxxxxx.png\"},\"lastScanDate\":{\"__type\":\"Date\",\"iso\":\"2016-06-02T05:28:58.135Z\"},\"localIdentifier\":\"XXXXX\",\"objectId\":\"OFHMX7ZUcI\",\"status\":... (truncated)\n                  Result: Update changed to {\"object\":{\"__type\":\"Pointer\",\"className\":\"Emoticode\",\"objectId\":\"ksrq7z3Ehc\"},\"imageThumb\":{\"__type\":\"File\",\"name\":\"tfss-xxxxxxx.png\",\"url\":\"http://files.parsetfss.com/xxxxx.png\"},\"status\":\"success\"}\n              */\n      done();\n    }).then(null, e => done.fail(JSON.stringify(e)));\n  }).pend('needs more work.....');","file":"CloudCodeLogger.spec.js","dir":"spec"},{"name":"cloud function should obfuscate password","suites":["Cloud Code Logger"],"line":192,"updatePoint":{"line":192,"column":46,"index":8604},"code":"  it('cloud function should obfuscate password', done => {\n    Parse.Cloud.define('testFunction', () => {\n      return 'verify code success';\n    });\n    Parse.Cloud.run('testFunction', {\n      username: 'hawk',\n      password: '123456'\n    }).then(() => {\n      const entry = spy.calls.mostRecent().args;\n      expect(entry[2].params.password).toMatch(/\\*\\*\\*\\*\\*\\*\\*\\*/);\n      done();\n    }).then(null, e => done.fail(e));\n  });","file":"CloudCodeLogger.spec.js","skipped":false,"dir":"spec"},{"name":"should only log once for object not found","suites":["Cloud Code Logger"],"line":205,"updatePoint":{"line":205,"column":47,"index":9037},"code":"  it('should only log once for object not found', async () => {\n    const config = Config.get('test');\n    const spy = spyOn(config.loggerController, 'error').and.callThrough();\n    try {\n      const object = new Parse.Object('Object');\n      object.id = 'invalid';\n      await object.fetch();\n    } catch (e) {\n      /**/\n    }\n    expect(spy).toHaveBeenCalled();\n    expect(spy.calls.count()).toBe(1);\n    const {\n      args\n    } = spy.calls.mostRecent();\n    expect(args[0]).toBe('Parse error: ');\n    expect(args[1].message).toBe('Object not found.');\n  });","file":"CloudCodeLogger.spec.js","skipped":false,"dir":"spec"},{"name":"returns a string","suites":["randomString"],"line":14,"updatePoint":{"line":14,"column":22,"index":328},"code":"  it('returns a string', () => {\n    expect(typeof cryptoUtils.randomString(10)).toBe('string');\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns result of the given length","suites":["randomString"],"line":17,"updatePoint":{"line":17,"column":40,"index":449},"code":"  it('returns result of the given length', () => {\n    expect(cryptoUtils.randomString(11).length).toBe(11);\n    expect(cryptoUtils.randomString(25).length).toBe(25);\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"throws if requested length is zero","suites":["randomString"],"line":21,"updatePoint":{"line":21,"column":40,"index":622},"code":"  it('throws if requested length is zero', () => {\n    expect(() => cryptoUtils.randomString(0)).toThrow();\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns unique results","suites":["randomString"],"line":24,"updatePoint":{"line":24,"column":28,"index":724},"code":"  it('returns unique results', () => {\n    expect(givesUniqueResults(() => cryptoUtils.randomString(10), 100)).toBe(true);\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns a string","suites":["randomHexString"],"line":29,"updatePoint":{"line":29,"column":22,"index":887},"code":"  it('returns a string', () => {\n    expect(typeof cryptoUtils.randomHexString(10)).toBe('string');\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns result of the given length","suites":["randomHexString"],"line":32,"updatePoint":{"line":32,"column":40,"index":1011},"code":"  it('returns result of the given length', () => {\n    expect(cryptoUtils.randomHexString(10).length).toBe(10);\n    expect(cryptoUtils.randomHexString(32).length).toBe(32);\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"throws if requested length is zero","suites":["randomHexString"],"line":36,"updatePoint":{"line":36,"column":40,"index":1190},"code":"  it('throws if requested length is zero', () => {\n    expect(() => cryptoUtils.randomHexString(0)).toThrow();\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"throws if requested length is not even","suites":["randomHexString"],"line":39,"updatePoint":{"line":39,"column":44,"index":1311},"code":"  it('throws if requested length is not even', () => {\n    expect(() => cryptoUtils.randomHexString(11)).toThrow();\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns unique results","suites":["randomHexString"],"line":42,"updatePoint":{"line":42,"column":28,"index":1417},"code":"  it('returns unique results', () => {\n    expect(givesUniqueResults(() => cryptoUtils.randomHexString(20), 100)).toBe(true);\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns a string","suites":["newObjectId"],"line":47,"updatePoint":{"line":47,"column":22,"index":1579},"code":"  it('returns a string', () => {\n    expect(typeof cryptoUtils.newObjectId()).toBe('string');\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns result with at least 10 characters","suites":["newObjectId"],"line":50,"updatePoint":{"line":50,"column":48,"index":1705},"code":"  it('returns result with at least 10 characters', () => {\n    expect(cryptoUtils.newObjectId().length).toBeGreaterThan(9);\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns result with required number of characters","suites":["newObjectId"],"line":53,"updatePoint":{"line":53,"column":55,"index":1842},"code":"  it('returns result with required number of characters', () => {\n    expect(cryptoUtils.newObjectId(42).length).toBe(42);\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns unique results","suites":["newObjectId"],"line":56,"updatePoint":{"line":56,"column":28,"index":1944},"code":"  it('returns unique results', () => {\n    expect(givesUniqueResults(() => cryptoUtils.newObjectId(), 100)).toBe(true);\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns a string","suites":["newToken"],"line":61,"updatePoint":{"line":61,"column":22,"index":2097},"code":"  it('returns a string', () => {\n    expect(typeof cryptoUtils.newToken()).toBe('string');\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns result with at least 32 characters","suites":["newToken"],"line":64,"updatePoint":{"line":64,"column":48,"index":2220},"code":"  it('returns result with at least 32 characters', () => {\n    expect(cryptoUtils.newToken().length).toBeGreaterThan(31);\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"returns unique results","suites":["newToken"],"line":67,"updatePoint":{"line":67,"column":28,"index":2328},"code":"  it('returns unique results', () => {\n    expect(givesUniqueResults(() => cryptoUtils.newToken(), 100)).toBe(true);\n  });","file":"cryptoUtils.spec.js","skipped":false,"dir":"spec"},{"name":"should not restructure simple cases of SERVER-13732","suites":["DatabaseController","validateQuery"],"line":5,"updatePoint":{"line":5,"column":59,"index":284},"code":"    it('should not restructure simple cases of SERVER-13732', done => {\n      const query = {\n        $or: [{\n          a: 1\n        }, {\n          a: 2\n        }],\n        _rperm: {\n          $in: ['a', 'b']\n        },\n        foo: 3\n      };\n      validateQuery(query);\n      expect(query).toEqual({\n        $or: [{\n          a: 1\n        }, {\n          a: 2\n        }],\n        _rperm: {\n          $in: ['a', 'b']\n        },\n        foo: 3\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should not restructure SERVER-13732 queries with $nears","suites":["DatabaseController","validateQuery"],"line":31,"updatePoint":{"line":31,"column":63,"index":763},"code":"    it('should not restructure SERVER-13732 queries with $nears', done => {\n      let query = {\n        $or: [{\n          a: 1\n        }, {\n          b: 1\n        }],\n        c: {\n          $nearSphere: {}\n        }\n      };\n      validateQuery(query);\n      expect(query).toEqual({\n        $or: [{\n          a: 1\n        }, {\n          b: 1\n        }],\n        c: {\n          $nearSphere: {}\n        }\n      });\n      query = {\n        $or: [{\n          a: 1\n        }, {\n          b: 1\n        }],\n        c: {\n          $near: {}\n        }\n      };\n      validateQuery(query);\n      expect(query).toEqual({\n        $or: [{\n          a: 1\n        }, {\n          b: 1\n        }],\n        c: {\n          $near: {}\n        }\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should not push refactored keys down a tree for SERVER-13732","suites":["DatabaseController","validateQuery"],"line":76,"updatePoint":{"line":76,"column":68,"index":1524},"code":"    it('should not push refactored keys down a tree for SERVER-13732', done => {\n      const query = {\n        a: 1,\n        $or: [{\n          $or: [{\n            b: 1\n          }, {\n            b: 2\n          }]\n        }, {\n          $or: [{\n            c: 1\n          }, {\n            c: 2\n          }]\n        }]\n      };\n      validateQuery(query);\n      expect(query).toEqual({\n        a: 1,\n        $or: [{\n          $or: [{\n            b: 1\n          }, {\n            b: 2\n          }]\n        }, {\n          $or: [{\n            c: 1\n          }, {\n            c: 2\n          }]\n        }]\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should reject invalid queries","suites":["DatabaseController","validateQuery"],"line":112,"updatePoint":{"line":112,"column":37,"index":2123},"code":"    it('should reject invalid queries', done => {\n      expect(() => validateQuery({\n        $or: {\n          a: 1\n        }\n      })).toThrow();\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should accept valid queries","suites":["DatabaseController","validateQuery"],"line":120,"updatePoint":{"line":120,"column":35,"index":2289},"code":"    it('should accept valid queries', done => {\n      expect(() => validateQuery({\n        $or: [{\n          a: 1\n        }, {\n          b: 2\n        }]\n      })).not.toThrow();\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should not decorate query if no pointer CLPs are present","suites":["DatabaseController","addPointerPermissions"],"line":138,"updatePoint":{"line":138,"column":64,"index":2905},"code":"    it('should not decorate query if no pointer CLPs are present', done => {\n      const clp = buildCLP();\n      const query = {\n        a: 'b'\n      };\n      schemaController.testPermissionsForClassName.withArgs(CLASS_NAME, ACL_GROUP, OPERATION).and.returnValue(true);\n      schemaController.getClassLevelPermissions.withArgs(CLASS_NAME).and.returnValue(clp);\n      const output = databaseController.addPointerPermissions(schemaController, CLASS_NAME, OPERATION, query, ACL_GROUP);\n      expect(output).toEqual({\n        ...query\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should decorate query if a pointer CLP entry is present","suites":["DatabaseController","addPointerPermissions"],"line":151,"updatePoint":{"line":151,"column":63,"index":3467},"code":"    it('should decorate query if a pointer CLP entry is present', done => {\n      const clp = buildCLP(['user']);\n      const query = {\n        a: 'b'\n      };\n      schemaController.testPermissionsForClassName.withArgs(CLASS_NAME, ACL_GROUP, OPERATION).and.returnValue(false);\n      schemaController.getClassLevelPermissions.withArgs(CLASS_NAME).and.returnValue(clp);\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'user').and.returnValue({\n        type: 'Pointer'\n      });\n      const output = databaseController.addPointerPermissions(schemaController, CLASS_NAME, OPERATION, query, ACL_GROUP);\n      expect(output).toEqual({\n        ...query,\n        user: createUserPointer(USER_ID)\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should decorate query if an array CLP entry is present","suites":["DatabaseController","addPointerPermissions"],"line":168,"updatePoint":{"line":168,"column":62,"index":4199},"code":"    it('should decorate query if an array CLP entry is present', done => {\n      const clp = buildCLP(['users']);\n      const query = {\n        a: 'b'\n      };\n      schemaController.testPermissionsForClassName.withArgs(CLASS_NAME, ACL_GROUP, OPERATION).and.returnValue(false);\n      schemaController.getClassLevelPermissions.withArgs(CLASS_NAME).and.returnValue(clp);\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'users').and.returnValue({\n        type: 'Array'\n      });\n      const output = databaseController.addPointerPermissions(schemaController, CLASS_NAME, OPERATION, query, ACL_GROUP);\n      expect(output).toEqual({\n        ...query,\n        users: {\n          $all: [createUserPointer(USER_ID)]\n        }\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should decorate query if an object CLP entry is present","suites":["DatabaseController","addPointerPermissions"],"line":187,"updatePoint":{"line":187,"column":63,"index":4963},"code":"    it('should decorate query if an object CLP entry is present', done => {\n      const clp = buildCLP(['user']);\n      const query = {\n        a: 'b'\n      };\n      schemaController.testPermissionsForClassName.withArgs(CLASS_NAME, ACL_GROUP, OPERATION).and.returnValue(false);\n      schemaController.getClassLevelPermissions.withArgs(CLASS_NAME).and.returnValue(clp);\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'user').and.returnValue({\n        type: 'Object'\n      });\n      const output = databaseController.addPointerPermissions(schemaController, CLASS_NAME, OPERATION, query, ACL_GROUP);\n      expect(output).toEqual({\n        ...query,\n        user: createUserPointer(USER_ID)\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should decorate query if a pointer CLP is present and the same field is part of the query","suites":["DatabaseController","addPointerPermissions"],"line":204,"updatePoint":{"line":204,"column":97,"index":5729},"code":"    it('should decorate query if a pointer CLP is present and the same field is part of the query', done => {\n      const clp = buildCLP(['user']);\n      const query = {\n        a: 'b',\n        user: 'a'\n      };\n      schemaController.testPermissionsForClassName.withArgs(CLASS_NAME, ACL_GROUP, OPERATION).and.returnValue(false);\n      schemaController.getClassLevelPermissions.withArgs(CLASS_NAME).and.returnValue(clp);\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'user').and.returnValue({\n        type: 'Pointer'\n      });\n      const output = databaseController.addPointerPermissions(schemaController, CLASS_NAME, OPERATION, query, ACL_GROUP);\n      expect(output).toEqual({\n        $and: [{\n          user: createUserPointer(USER_ID)\n        }, {\n          ...query\n        }]\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should transform the query to an $or query if multiple array/pointer CLPs are present","suites":["DatabaseController","addPointerPermissions"],"line":225,"updatePoint":{"line":225,"column":93,"index":6555},"code":"    it('should transform the query to an $or query if multiple array/pointer CLPs are present', done => {\n      const clp = buildCLP(['user', 'users', 'userObject']);\n      const query = {\n        a: 'b'\n      };\n      schemaController.testPermissionsForClassName.withArgs(CLASS_NAME, ACL_GROUP, OPERATION).and.returnValue(false);\n      schemaController.getClassLevelPermissions.withArgs(CLASS_NAME).and.returnValue(clp);\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'user').and.returnValue({\n        type: 'Pointer'\n      });\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'users').and.returnValue({\n        type: 'Array'\n      });\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'userObject').and.returnValue({\n        type: 'Object'\n      });\n      const output = databaseController.addPointerPermissions(schemaController, CLASS_NAME, OPERATION, query, ACL_GROUP);\n      expect(output).toEqual({\n        $or: [{\n          ...query,\n          user: createUserPointer(USER_ID)\n        }, {\n          ...query,\n          users: {\n            $all: [createUserPointer(USER_ID)]\n          }\n        }, {\n          ...query,\n          userObject: createUserPointer(USER_ID)\n        }]\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should not return a $or operation if the query involves one of the two fields also used as array/pointer permissions","suites":["DatabaseController","addPointerPermissions"],"line":258,"updatePoint":{"line":258,"column":124,"index":7840},"code":"    it('should not return a $or operation if the query involves one of the two fields also used as array/pointer permissions', done => {\n      const clp = buildCLP(['users', 'user']);\n      const query = {\n        a: 'b',\n        user: createUserPointer(USER_ID)\n      };\n      schemaController.testPermissionsForClassName.withArgs(CLASS_NAME, ACL_GROUP, OPERATION).and.returnValue(false);\n      schemaController.getClassLevelPermissions.withArgs(CLASS_NAME).and.returnValue(clp);\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'user').and.returnValue({\n        type: 'Pointer'\n      });\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'users').and.returnValue({\n        type: 'Array'\n      });\n      const output = databaseController.addPointerPermissions(schemaController, CLASS_NAME, OPERATION, query, ACL_GROUP);\n      expect(output).toEqual({\n        ...query,\n        user: createUserPointer(USER_ID)\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should not return a $or operation if the query involves one of the fields also used as array/pointer permissions","suites":["DatabaseController","addPointerPermissions"],"line":279,"updatePoint":{"line":279,"column":120,"index":8800},"code":"    it('should not return a $or operation if the query involves one of the fields also used as array/pointer permissions', done => {\n      const clp = buildCLP(['user', 'users', 'userObject']);\n      const query = {\n        a: 'b',\n        user: createUserPointer(USER_ID)\n      };\n      schemaController.testPermissionsForClassName.withArgs(CLASS_NAME, ACL_GROUP, OPERATION).and.returnValue(false);\n      schemaController.getClassLevelPermissions.withArgs(CLASS_NAME).and.returnValue(clp);\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'user').and.returnValue({\n        type: 'Pointer'\n      });\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'users').and.returnValue({\n        type: 'Array'\n      });\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'userObject').and.returnValue({\n        type: 'Object'\n      });\n      const output = databaseController.addPointerPermissions(schemaController, CLASS_NAME, OPERATION, query, ACL_GROUP);\n      expect(output).toEqual({\n        ...query,\n        user: createUserPointer(USER_ID)\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error if for some unexpected reason the property specified in the CLP is neither a pointer nor an array","suites":["DatabaseController","addPointerPermissions"],"line":303,"updatePoint":{"line":303,"column":127,"index":9906},"code":"    it('should throw an error if for some unexpected reason the property specified in the CLP is neither a pointer nor an array', done => {\n      const clp = buildCLP(['user']);\n      const query = {\n        a: 'b'\n      };\n      schemaController.testPermissionsForClassName.withArgs(CLASS_NAME, ACL_GROUP, OPERATION).and.returnValue(false);\n      schemaController.getClassLevelPermissions.withArgs(CLASS_NAME).and.returnValue(clp);\n      schemaController.getExpectedType.withArgs(CLASS_NAME, 'user').and.returnValue({\n        type: 'Number'\n      });\n      expect(() => {\n        databaseController.addPointerPermissions(schemaController, CLASS_NAME, OPERATION, query, ACL_GROUP);\n      }).toThrow(Error(`An unexpected condition occurred when resolving pointer permissions: ${CLASS_NAME} user`));\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"objectToEntriesStrings","suites":["DatabaseController","reduceOperations"],"line":321,"updatePoint":{"line":321,"column":30,"index":10737},"code":"    it('objectToEntriesStrings', done => {\n      const output = databaseController.objectToEntriesStrings({\n        a: 1,\n        b: 2,\n        c: 3\n      });\n      expect(output).toEqual(['\"a\":1', '\"b\":2', '\"c\":3']);\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"reduceOrOperation","suites":["DatabaseController","reduceOperations"],"line":330,"updatePoint":{"line":330,"column":25,"index":10972},"code":"    it('reduceOrOperation', done => {\n      expect(databaseController.reduceOrOperation({\n        a: 1\n      })).toEqual({\n        a: 1\n      });\n      expect(databaseController.reduceOrOperation({\n        $or: [{\n          a: 1\n        }, {\n          b: 2\n        }]\n      })).toEqual({\n        $or: [{\n          a: 1\n        }, {\n          b: 2\n        }]\n      });\n      expect(databaseController.reduceOrOperation({\n        $or: [{\n          a: 1\n        }, {\n          a: 2\n        }]\n      })).toEqual({\n        $or: [{\n          a: 1\n        }, {\n          a: 2\n        }]\n      });\n      expect(databaseController.reduceOrOperation({\n        $or: [{\n          a: 1\n        }, {\n          a: 1\n        }]\n      })).toEqual({\n        a: 1\n      });\n      expect(databaseController.reduceOrOperation({\n        $or: [{\n          a: 1,\n          b: 2,\n          c: 3\n        }, {\n          a: 1\n        }]\n      })).toEqual({\n        a: 1\n      });\n      expect(databaseController.reduceOrOperation({\n        $or: [{\n          b: 2\n        }, {\n          a: 1,\n          b: 2,\n          c: 3\n        }]\n      })).toEqual({\n        b: 2\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"reduceAndOperation","suites":["DatabaseController","reduceOperations"],"line":395,"updatePoint":{"line":395,"column":26,"index":12144},"code":"    it('reduceAndOperation', done => {\n      expect(databaseController.reduceAndOperation({\n        a: 1\n      })).toEqual({\n        a: 1\n      });\n      expect(databaseController.reduceAndOperation({\n        $and: [{\n          a: 1\n        }, {\n          b: 2\n        }]\n      })).toEqual({\n        $and: [{\n          a: 1\n        }, {\n          b: 2\n        }]\n      });\n      expect(databaseController.reduceAndOperation({\n        $and: [{\n          a: 1\n        }, {\n          a: 2\n        }]\n      })).toEqual({\n        $and: [{\n          a: 1\n        }, {\n          a: 2\n        }]\n      });\n      expect(databaseController.reduceAndOperation({\n        $and: [{\n          a: 1\n        }, {\n          a: 1\n        }]\n      })).toEqual({\n        a: 1\n      });\n      expect(databaseController.reduceAndOperation({\n        $and: [{\n          a: 1,\n          b: 2,\n          c: 3\n        }, {\n          b: 2\n        }]\n      })).toEqual({\n        a: 1,\n        b: 2,\n        c: 3\n      });\n      done();\n    });","file":"DatabaseController.spec.js","skipped":false,"dir":"spec"},{"name":"should be an error with specific message","suites":["defaultGraphQLTypes","TypeValidationError"],"line":36,"updatePoint":{"line":36,"column":48,"index":657},"code":"    it('should be an error with specific message', () => {\n      const typeValidationError = new TypeValidationError('somevalue', 'sometype');\n      expect(typeValidationError).toEqual(jasmine.any(Error));\n      expect(typeValidationError.message).toEqual('somevalue is not a valid sometype');\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should return itself if a string","suites":["defaultGraphQLTypes","parseStringValue"],"line":43,"updatePoint":{"line":43,"column":40,"index":996},"code":"    it('should return itself if a string', () => {\n      const myString = 'myString';\n      expect(parseStringValue(myString)).toBe(myString);\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not a string","suites":["defaultGraphQLTypes","parseStringValue"],"line":47,"updatePoint":{"line":47,"column":35,"index":1142},"code":"    it('should fail if not a string', () => {\n      expect(() => parseStringValue()).toThrow(jasmine.stringMatching('is not a valid String'));\n      expect(() => parseStringValue({})).toThrow(jasmine.stringMatching('is not a valid String'));\n      expect(() => parseStringValue([])).toThrow(jasmine.stringMatching('is not a valid String'));\n      expect(() => parseStringValue(123)).toThrow(jasmine.stringMatching('is not a valid String'));\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse to number if a string","suites":["defaultGraphQLTypes","parseIntValue"],"line":55,"updatePoint":{"line":55,"column":42,"index":1640},"code":"    it('should parse to number if a string', () => {\n      const myString = '123';\n      expect(parseIntValue(myString)).toBe(123);\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not a string","suites":["defaultGraphQLTypes","parseIntValue"],"line":59,"updatePoint":{"line":59,"column":35,"index":1773},"code":"    it('should fail if not a string', () => {\n      expect(() => parseIntValue()).toThrow(jasmine.stringMatching('is not a valid Int'));\n      expect(() => parseIntValue({})).toThrow(jasmine.stringMatching('is not a valid Int'));\n      expect(() => parseIntValue([])).toThrow(jasmine.stringMatching('is not a valid Int'));\n      expect(() => parseIntValue(123)).toThrow(jasmine.stringMatching('is not a valid Int'));\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not an integer string","suites":["defaultGraphQLTypes","parseIntValue"],"line":65,"updatePoint":{"line":65,"column":44,"index":2207},"code":"    it('should fail if not an integer string', () => {\n      expect(() => parseIntValue('a123')).toThrow(jasmine.stringMatching('is not a valid Int'));\n      expect(() => parseIntValue('123.4')).toThrow(jasmine.stringMatching('is not a valid Int'));\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse to number if a string","suites":["defaultGraphQLTypes","parseFloatValue"],"line":71,"updatePoint":{"line":71,"column":42,"index":2507},"code":"    it('should parse to number if a string', () => {\n      expect(parseFloatValue('123')).toBe(123);\n      expect(parseFloatValue('123.4')).toBe(123.4);\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not a string","suites":["defaultGraphQLTypes","parseFloatValue"],"line":75,"updatePoint":{"line":75,"column":35,"index":2661},"code":"    it('should fail if not a string', () => {\n      expect(() => parseFloatValue()).toThrow(jasmine.stringMatching('is not a valid Float'));\n      expect(() => parseFloatValue({})).toThrow(jasmine.stringMatching('is not a valid Float'));\n      expect(() => parseFloatValue([])).toThrow(jasmine.stringMatching('is not a valid Float'));\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not a float string","suites":["defaultGraphQLTypes","parseFloatValue"],"line":80,"updatePoint":{"line":80,"column":41,"index":3010},"code":"    it('should fail if not a float string', () => {\n      expect(() => parseIntValue('a123')).toThrow(jasmine.stringMatching('is not a valid Int'));\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should return itself if a boolean","suites":["defaultGraphQLTypes","parseBooleanValue"],"line":85,"updatePoint":{"line":85,"column":41,"index":3213},"code":"    it('should return itself if a boolean', () => {\n      let myBoolean = true;\n      expect(parseBooleanValue(myBoolean)).toBe(myBoolean);\n      myBoolean = false;\n      expect(parseBooleanValue(myBoolean)).toBe(myBoolean);\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not a boolean","suites":["defaultGraphQLTypes","parseBooleanValue"],"line":91,"updatePoint":{"line":91,"column":36,"index":3441},"code":"    it('should fail if not a boolean', () => {\n      expect(() => parseBooleanValue()).toThrow(jasmine.stringMatching('is not a valid Boolean'));\n      expect(() => parseBooleanValue({})).toThrow(jasmine.stringMatching('is not a valid Boolean'));\n      expect(() => parseBooleanValue([])).toThrow(jasmine.stringMatching('is not a valid Boolean'));\n      expect(() => parseBooleanValue(123)).toThrow(jasmine.stringMatching('is not a valid Boolean'));\n      expect(() => parseBooleanValue('true')).toThrow(jasmine.stringMatching('is not a valid Boolean'));\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse to date if a string","suites":["defaultGraphQLTypes","parseDateValue"],"line":100,"updatePoint":{"line":100,"column":40,"index":4051},"code":"    it('should parse to date if a string', () => {\n      const myDateString = '2019-05-09T23:12:00.000Z';\n      const myDate = new Date(Date.UTC(2019, 4, 9, 23, 12, 0, 0));\n      expect(parseDateIsoValue(myDateString)).toEqual(myDate);\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not a string","suites":["defaultGraphQLTypes","parseDateValue"],"line":105,"updatePoint":{"line":105,"column":35,"index":4290},"code":"    it('should fail if not a string', () => {\n      expect(() => parseDateIsoValue()).toThrow(jasmine.stringMatching('is not a valid Date'));\n      expect(() => parseDateIsoValue({})).toThrow(jasmine.stringMatching('is not a valid Date'));\n      expect(() => parseDateIsoValue([])).toThrow(jasmine.stringMatching('is not a valid Date'));\n      expect(() => parseDateIsoValue(123)).toThrow(jasmine.stringMatching('is not a valid Date'));\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not a date string","suites":["defaultGraphQLTypes","parseDateValue"],"line":111,"updatePoint":{"line":111,"column":40,"index":4740},"code":"    it('should fail if not a date string', () => {\n      expect(() => parseDateIsoValue('not a date')).toThrow(jasmine.stringMatching('is not a valid Date'));\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse string","suites":["defaultGraphQLTypes","parseValue"],"line":123,"updatePoint":{"line":123,"column":27,"index":6031},"code":"    it('should parse string', () => {\n      expect(parseValue(someString)).toEqual('somestring');\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse int","suites":["defaultGraphQLTypes","parseValue"],"line":126,"updatePoint":{"line":126,"column":24,"index":6134},"code":"    it('should parse int', () => {\n      expect(parseValue(someInt)).toEqual(123);\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse float","suites":["defaultGraphQLTypes","parseValue"],"line":129,"updatePoint":{"line":129,"column":26,"index":6227},"code":"    it('should parse float', () => {\n      expect(parseValue(someFloat)).toEqual(123.4);\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse boolean","suites":["defaultGraphQLTypes","parseValue"],"line":132,"updatePoint":{"line":132,"column":28,"index":6326},"code":"    it('should parse boolean', () => {\n      expect(parseValue(someBoolean)).toEqual(true);\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse list","suites":["defaultGraphQLTypes","parseValue"],"line":135,"updatePoint":{"line":135,"column":25,"index":6423},"code":"    it('should parse list', () => {\n      expect(parseValue(someList)).toEqual(['somestring', 123, 123.4, true, {\n        someString: 'somestring',\n        someInt: 123,\n        someFloat: 123.4,\n        someBoolean: true,\n        someOther: {},\n        someList: [{\n          someString: 'somestring'\n        }],\n        someObject: {\n          someString: 'somestring'\n        }\n      }, {}, ['somestring', 123, 123.4, true, {\n        someString: 'somestring',\n        someInt: 123,\n        someFloat: 123.4,\n        someBoolean: true,\n        someOther: {},\n        someList: [{\n          someString: 'somestring'\n        }],\n        someObject: {\n          someString: 'somestring'\n        }\n      }, {}]]);\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse object","suites":["defaultGraphQLTypes","parseValue"],"line":162,"updatePoint":{"line":162,"column":27,"index":7145},"code":"    it('should parse object', () => {\n      expect(parseValue(someObject)).toEqual({\n        someString: 'somestring',\n        someInt: 123,\n        someFloat: 123.4,\n        someBoolean: true,\n        someOther: {},\n        someList: [{\n          someString: 'somestring'\n        }],\n        someObject: {\n          someString: 'somestring'\n        }\n      });\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should return value otherwise","suites":["defaultGraphQLTypes","parseValue"],"line":177,"updatePoint":{"line":177,"column":37,"index":7525},"code":"    it('should return value otherwise', () => {\n      expect(parseValue(someOther)).toEqual(new Object());\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse to list if an array","suites":["defaultGraphQLTypes","parseListValues"],"line":182,"updatePoint":{"line":182,"column":40,"index":7687},"code":"    it('should parse to list if an array', () => {\n      expect(parseListValues([{\n        kind: Kind.STRING,\n        value: 'someString'\n      }, {\n        kind: Kind.INT,\n        value: '123'\n      }])).toEqual(['someString', 123]);\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not an array","suites":["defaultGraphQLTypes","parseListValues"],"line":191,"updatePoint":{"line":191,"column":35,"index":7925},"code":"    it('should fail if not an array', () => {\n      expect(() => parseListValues()).toThrow(jasmine.stringMatching('is not a valid List'));\n      expect(() => parseListValues({})).toThrow(jasmine.stringMatching('is not a valid List'));\n      expect(() => parseListValues('some string')).toThrow(jasmine.stringMatching('is not a valid List'));\n      expect(() => parseListValues(123)).toThrow(jasmine.stringMatching('is not a valid List'));\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse to list if an array","suites":["defaultGraphQLTypes","parseObjectFields"],"line":199,"updatePoint":{"line":199,"column":40,"index":8424},"code":"    it('should parse to list if an array', () => {\n      expect(parseObjectFields([{\n        name: {\n          value: 'someString'\n        },\n        value: {\n          kind: Kind.STRING,\n          value: 'someString'\n        }\n      }, {\n        name: {\n          value: 'someInt'\n        },\n        value: {\n          kind: Kind.INT,\n          value: '123'\n        }\n      }])).toEqual({\n        someString: 'someString',\n        someInt: 123\n      });\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not an array","suites":["defaultGraphQLTypes","parseObjectFields"],"line":221,"updatePoint":{"line":221,"column":35,"index":8882},"code":"    it('should fail if not an array', () => {\n      expect(() => parseObjectFields()).toThrow(jasmine.stringMatching('is not a valid Object'));\n      expect(() => parseObjectFields({})).toThrow(jasmine.stringMatching('is not a valid Object'));\n      expect(() => parseObjectFields('some string')).toThrow(jasmine.stringMatching('is not a valid Object'));\n      expect(() => parseObjectFields(123)).toThrow(jasmine.stringMatching('is not a valid Object'));\n    });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse to date if string","suites":["defaultGraphQLTypes","Date","parse literal"],"line":233,"updatePoint":{"line":233,"column":40,"index":9473},"code":"      it('should parse to date if string', () => {\n        const date = '2019-05-09T23:12:00.000Z';\n        expect(parseLiteral(createValue(Kind.STRING, date))).toEqual({\n          __type: 'Date',\n          iso: new Date(date)\n        });\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse to date if object","suites":["defaultGraphQLTypes","Date","parse literal"],"line":240,"updatePoint":{"line":240,"column":40,"index":9722},"code":"      it('should parse to date if object', () => {\n        const date = '2019-05-09T23:12:00.000Z';\n        expect(parseLiteral(createValue(Kind.OBJECT, undefined, undefined, [createObjectField('__type', {\n          value: 'Date'\n        }), createObjectField('iso', {\n          value: date,\n          kind: Kind.STRING\n        })]))).toEqual({\n          __type: 'Date',\n          iso: new Date(date)\n        });\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not an valid object or string","suites":["defaultGraphQLTypes","Date","parse literal"],"line":252,"updatePoint":{"line":252,"column":54,"index":10159},"code":"      it('should fail if not an valid object or string', () => {\n        expect(() => parseLiteral({})).toThrow(jasmine.stringMatching('is not a valid Date'));\n        expect(() => parseLiteral(createValue(Kind.OBJECT, undefined, undefined, [createObjectField('__type', {\n          value: 'Foo'\n        }), createObjectField('iso', {\n          value: '2019-05-09T23:12:00.000Z'\n        })]))).toThrow(jasmine.stringMatching('is not a valid Date'));\n        expect(() => parseLiteral([])).toThrow(jasmine.stringMatching('is not a valid Date'));\n        expect(() => parseLiteral(123)).toThrow(jasmine.stringMatching('is not a valid Date'));\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse string value","suites":["defaultGraphQLTypes","Date","parse value"],"line":267,"updatePoint":{"line":267,"column":35,"index":10883},"code":"      it('should parse string value', () => {\n        const date = '2019-05-09T23:12:00.000Z';\n        expect(parseValue(date)).toEqual({\n          __type: 'Date',\n          iso: new Date(date)\n        });\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse object value","suites":["defaultGraphQLTypes","Date","parse value"],"line":274,"updatePoint":{"line":274,"column":35,"index":11099},"code":"      it('should parse object value', () => {\n        const input = {\n          __type: 'Date',\n          iso: new Date('2019-05-09T23:12:00.000Z')\n        };\n        expect(parseValue(input)).toEqual(input);\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not an valid object or string","suites":["defaultGraphQLTypes","Date","parse value"],"line":281,"updatePoint":{"line":281,"column":54,"index":11337},"code":"      it('should fail if not an valid object or string', () => {\n        expect(() => parseValue({})).toThrow(jasmine.stringMatching('is not a valid Date'));\n        expect(() => parseValue({\n          __type: 'Foo',\n          iso: '2019-05-09T23:12:00.000Z'\n        })).toThrow(jasmine.stringMatching('is not a valid Date'));\n        expect(() => parseValue({\n          __type: 'Date',\n          iso: 'foo'\n        })).toThrow(jasmine.stringMatching('is not a valid Date'));\n        expect(() => parseValue([])).toThrow(jasmine.stringMatching('is not a valid Date'));\n        expect(() => parseValue(123)).toThrow(jasmine.stringMatching('is not a valid Date'));\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should do nothing if string","suites":["defaultGraphQLTypes","Date","serialize date type"],"line":299,"updatePoint":{"line":299,"column":37,"index":12093},"code":"      it('should do nothing if string', () => {\n        const str = '2019-05-09T23:12:00.000Z';\n        expect(serialize(str)).toBe(str);\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should serialize date","suites":["defaultGraphQLTypes","Date","serialize date type"],"line":303,"updatePoint":{"line":303,"column":31,"index":12235},"code":"      it('should serialize date', () => {\n        const date = new Date();\n        expect(serialize(date)).toBe(date.toISOString());\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should return iso value if object","suites":["defaultGraphQLTypes","Date","serialize date type"],"line":307,"updatePoint":{"line":307,"column":43,"index":12390},"code":"      it('should return iso value if object', () => {\n        const iso = '2019-05-09T23:12:00.000Z';\n        const date = {\n          __type: 'Date',\n          iso\n        };\n        expect(serialize(date)).toEqual(iso);\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not an valid object or string","suites":["defaultGraphQLTypes","Date","serialize date type"],"line":315,"updatePoint":{"line":315,"column":54,"index":12633},"code":"      it('should fail if not an valid object or string', () => {\n        expect(() => serialize({})).toThrow(jasmine.stringMatching('is not a valid Date'));\n        expect(() => serialize({\n          __type: 'Foo',\n          iso: '2019-05-09T23:12:00.000Z'\n        })).toThrow(jasmine.stringMatching('is not a valid Date'));\n        expect(() => serialize([])).toThrow(jasmine.stringMatching('is not a valid Date'));\n        expect(() => serialize(123)).toThrow(jasmine.stringMatching('is not a valid Date'));\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse to bytes if string","suites":["defaultGraphQLTypes","Bytes","parse literal"],"line":331,"updatePoint":{"line":331,"column":41,"index":13272},"code":"      it('should parse to bytes if string', () => {\n        expect(parseLiteral(createValue(Kind.STRING, 'bytesContent'))).toEqual({\n          __type: 'Bytes',\n          base64: 'bytesContent'\n        });\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse to bytes if object","suites":["defaultGraphQLTypes","Bytes","parse literal"],"line":337,"updatePoint":{"line":337,"column":41,"index":13487},"code":"      it('should parse to bytes if object', () => {\n        expect(parseLiteral(createValue(Kind.OBJECT, undefined, undefined, [createObjectField('__type', {\n          value: 'Bytes'\n        }), createObjectField('base64', {\n          value: 'bytesContent'\n        })]))).toEqual({\n          __type: 'Bytes',\n          base64: 'bytesContent'\n        });\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not an valid object or string","suites":["defaultGraphQLTypes","Bytes","parse literal"],"line":347,"updatePoint":{"line":347,"column":54,"index":13864},"code":"      it('should fail if not an valid object or string', () => {\n        expect(() => parseLiteral({})).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n        expect(() => parseLiteral(createValue(Kind.OBJECT, undefined, undefined, [createObjectField('__type', {\n          value: 'Foo'\n        }), createObjectField('base64', {\n          value: 'bytesContent'\n        })]))).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n        expect(() => parseLiteral([])).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n        expect(() => parseLiteral(123)).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse string value","suites":["defaultGraphQLTypes","Bytes","parse value"],"line":362,"updatePoint":{"line":362,"column":35,"index":14584},"code":"      it('should parse string value', () => {\n        expect(parseValue('bytesContent')).toEqual({\n          __type: 'Bytes',\n          base64: 'bytesContent'\n        });\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse object value","suites":["defaultGraphQLTypes","Bytes","parse value"],"line":368,"updatePoint":{"line":368,"column":35,"index":14765},"code":"      it('should parse object value', () => {\n        const input = {\n          __type: 'Bytes',\n          base64: 'bytesContent'\n        };\n        expect(parseValue(input)).toEqual(input);\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not an valid object or string","suites":["defaultGraphQLTypes","Bytes","parse value"],"line":375,"updatePoint":{"line":375,"column":54,"index":14985},"code":"      it('should fail if not an valid object or string', () => {\n        expect(() => parseValue({})).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n        expect(() => parseValue({\n          __type: 'Foo',\n          base64: 'bytesContent'\n        })).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n        expect(() => parseValue([])).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n        expect(() => parseValue(123)).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should do nothing if string","suites":["defaultGraphQLTypes","Bytes","serialize bytes type"],"line":389,"updatePoint":{"line":389,"column":37,"index":15589},"code":"      it('should do nothing if string', () => {\n        const str = 'foo';\n        expect(serialize(str)).toBe(str);\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should return base64 value if object","suites":["defaultGraphQLTypes","Bytes","serialize bytes type"],"line":393,"updatePoint":{"line":393,"column":46,"index":15725},"code":"      it('should return base64 value if object', () => {\n        const base64Content = 'bytesContent';\n        const bytes = {\n          __type: 'Bytes',\n          base64: base64Content\n        };\n        expect(serialize(bytes)).toEqual(base64Content);\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not an valid object or string","suites":["defaultGraphQLTypes","Bytes","serialize bytes type"],"line":401,"updatePoint":{"line":401,"column":54,"index":15997},"code":"      it('should fail if not an valid object or string', () => {\n        expect(() => serialize({})).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n        expect(() => serialize({\n          __type: 'Foo',\n          base64: 'bytesContent'\n        })).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n        expect(() => serialize([])).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n        expect(() => serialize(123)).toThrow(jasmine.stringMatching('is not a valid Bytes'));\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse to file if string","suites":["defaultGraphQLTypes","File","parse literal"],"line":417,"updatePoint":{"line":417,"column":40,"index":16628},"code":"      it('should parse to file if string', () => {\n        expect(parseLiteral(createValue(Kind.STRING, 'parsefile'))).toEqual({\n          __type: 'File',\n          name: 'parsefile'\n        });\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should parse to file if object","suites":["defaultGraphQLTypes","File","parse literal"],"line":423,"updatePoint":{"line":423,"column":40,"index":16833},"code":"      it('should parse to file if object', () => {\n        expect(parseLiteral(createValue(Kind.OBJECT, undefined, undefined, [createObjectField('__type', {\n          value: 'File'\n        }), createObjectField('name', {\n          value: 'parsefile'\n        }), createObjectField('url', {\n          value: 'myurl'\n        })]))).toEqual({\n          __type: 'File',\n          name: 'parsefile',\n          url: 'myurl'\n        });\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not an valid object or string","suites":["defaultGraphQLTypes","File","parse literal"],"line":436,"updatePoint":{"line":436,"column":54,"index":17286},"code":"      it('should fail if not an valid object or string', () => {\n        expect(() => parseLiteral({})).toThrow(jasmine.stringMatching('is not a valid File'));\n        expect(() => parseLiteral(createValue(Kind.OBJECT, undefined, undefined, [createObjectField('__type', {\n          value: 'Foo'\n        }), createObjectField('name', {\n          value: 'parsefile'\n        }), createObjectField('url', {\n          value: 'myurl'\n        })]))).toThrow(jasmine.stringMatching('is not a valid File'));\n        expect(() => parseLiteral([])).toThrow(jasmine.stringMatching('is not a valid File'));\n        expect(() => parseLiteral(123)).toThrow(jasmine.stringMatching('is not a valid File'));\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should do nothing if string","suites":["defaultGraphQLTypes","File","serialize file type"],"line":453,"updatePoint":{"line":453,"column":37,"index":18069},"code":"      it('should do nothing if string', () => {\n        const str = 'foo';\n        expect(serialize(str)).toBe(str);\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should return file name if object","suites":["defaultGraphQLTypes","File","serialize file type"],"line":457,"updatePoint":{"line":457,"column":43,"index":18202},"code":"      it('should return file name if object', () => {\n        const fileName = 'parsefile';\n        const file = {\n          __type: 'File',\n          name: fileName,\n          url: 'myurl'\n        };\n        expect(serialize(file)).toEqual(fileName);\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if not an valid object or string","suites":["defaultGraphQLTypes","File","serialize file type"],"line":466,"updatePoint":{"line":466,"column":54,"index":18475},"code":"      it('should fail if not an valid object or string', () => {\n        expect(() => serialize({})).toThrow(jasmine.stringMatching('is not a valid File'));\n        expect(() => serialize({\n          __type: 'Foo',\n          name: 'parsefile',\n          url: 'myurl'\n        })).toThrow(jasmine.stringMatching('is not a valid File'));\n        expect(() => serialize([])).toThrow(jasmine.stringMatching('is not a valid File'));\n        expect(() => serialize(123)).toThrow(jasmine.stringMatching('is not a valid File'));\n      });","file":"defaultGraphQLTypes.spec.js","skipped":false,"dir":"spec"},{"name":"should keep default fields if not provided","suites":["DefinedSchemas","Fields"],"line":22,"updatePoint":{"line":22,"column":50,"index":575},"code":"    it('should keep default fields if not provided', async () => {\n      const server = await reconfigureServer();\n      // Will perform create\n      await new DefinedSchemas({\n        definitions: [{\n          className: 'Test'\n        }]\n      }, server.config).execute();\n      let schema = await new Parse.Schema('Test').get();\n      const expectedFields = {\n        objectId: {\n          type: 'String'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        ACL: {\n          type: 'ACL'\n        }\n      };\n      expect(schema.fields).toEqual(expectedFields);\n      await server.config.schemaCache.clear();\n      // Will perform update\n      await new DefinedSchemas({\n        definitions: [{\n          className: 'Test'\n        }]\n      }, server.config).execute();\n      schema = await new Parse.Schema('Test').get();\n      expect(schema.fields).toEqual(expectedFields);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should protect default fields","suites":["DefinedSchemas","Fields"],"line":56,"updatePoint":{"line":56,"column":37,"index":1521},"code":"    it('should protect default fields', async () => {\n      const server = await reconfigureServer();\n      const schemas = {\n        definitions: [{\n          className: '_User',\n          fields: {\n            email: 'Object'\n          }\n        }, {\n          className: '_Role',\n          fields: {\n            users: 'Object'\n          }\n        }, {\n          className: '_Installation',\n          fields: {\n            installationId: 'Object'\n          }\n        }, {\n          className: 'Test',\n          fields: {\n            createdAt: {\n              type: 'Object'\n            },\n            objectId: {\n              type: 'Number'\n            },\n            updatedAt: {\n              type: 'String'\n            },\n            ACL: {\n              type: 'String'\n            }\n          }\n        }]\n      };\n      const expectedFields = {\n        objectId: {\n          type: 'String'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        ACL: {\n          type: 'ACL'\n        }\n      };\n      const expectedUserFields = {\n        objectId: {\n          type: 'String'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        ACL: {\n          type: 'ACL'\n        },\n        username: {\n          type: 'String'\n        },\n        password: {\n          type: 'String'\n        },\n        email: {\n          type: 'String'\n        },\n        emailVerified: {\n          type: 'Boolean'\n        },\n        authData: {\n          type: 'Object'\n        }\n      };\n      const expectedRoleFields = {\n        objectId: {\n          type: 'String'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        ACL: {\n          type: 'ACL'\n        },\n        name: {\n          type: 'String'\n        },\n        users: {\n          type: 'Relation',\n          targetClass: '_User'\n        },\n        roles: {\n          type: 'Relation',\n          targetClass: '_Role'\n        }\n      };\n      const expectedInstallationFields = {\n        objectId: {\n          type: 'String'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        ACL: {\n          type: 'ACL'\n        },\n        installationId: {\n          type: 'String'\n        },\n        deviceToken: {\n          type: 'String'\n        },\n        channels: {\n          type: 'Array'\n        },\n        deviceType: {\n          type: 'String'\n        },\n        pushType: {\n          type: 'String'\n        },\n        GCMSenderId: {\n          type: 'String'\n        },\n        timeZone: {\n          type: 'String'\n        },\n        localeIdentifier: {\n          type: 'String'\n        },\n        badge: {\n          type: 'Number'\n        },\n        appVersion: {\n          type: 'String'\n        },\n        appName: {\n          type: 'String'\n        },\n        appIdentifier: {\n          type: 'String'\n        },\n        parseVersion: {\n          type: 'String'\n        }\n      };\n\n      // Perform create\n      await new DefinedSchemas(schemas, server.config).execute();\n      let schema = await new Parse.Schema('Test').get();\n      expect(schema.fields).toEqual(expectedFields);\n      let userSchema = await new Parse.Schema('_User').get();\n      expect(userSchema.fields).toEqual(expectedUserFields);\n      let roleSchema = await new Parse.Schema('_Role').get();\n      expect(roleSchema.fields).toEqual(expectedRoleFields);\n      let installationSchema = await new Parse.Schema('_Installation').get();\n      expect(installationSchema.fields).toEqual(expectedInstallationFields);\n      await server.config.schemaCache.clear();\n      // Perform update\n      await new DefinedSchemas(schemas, server.config).execute();\n      schema = await new Parse.Schema('Test').get();\n      expect(schema.fields).toEqual(expectedFields);\n      userSchema = await new Parse.Schema('_User').get();\n      expect(userSchema.fields).toEqual(expectedUserFields);\n      roleSchema = await new Parse.Schema('_Role').get();\n      expect(roleSchema.fields).toEqual(expectedRoleFields);\n      installationSchema = await new Parse.Schema('_Installation').get();\n      expect(installationSchema.fields).toEqual(expectedInstallationFields);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should create new fields","suites":["DefinedSchemas","Fields"],"line":236,"updatePoint":{"line":236,"column":32,"index":5880},"code":"    it('should create new fields', async () => {\n      const server = await reconfigureServer();\n      const fields = {\n        objectId: {\n          type: 'String'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        ACL: {\n          type: 'ACL'\n        },\n        aString: {\n          type: 'String'\n        },\n        aStringWithDefault: {\n          type: 'String',\n          defaultValue: 'Test'\n        },\n        aStringWithRequired: {\n          type: 'String',\n          required: true\n        },\n        aStringWithRequiredAndDefault: {\n          type: 'String',\n          required: true,\n          defaultValue: 'Test'\n        },\n        aBoolean: {\n          type: 'Boolean'\n        },\n        aFile: {\n          type: 'File'\n        },\n        aNumber: {\n          type: 'Number'\n        },\n        aRelation: {\n          type: 'Relation',\n          targetClass: '_User'\n        },\n        aPointer: {\n          type: 'Pointer',\n          targetClass: '_Role'\n        },\n        aDate: {\n          type: 'Date'\n        },\n        aGeoPoint: {\n          type: 'GeoPoint'\n        },\n        aPolygon: {\n          type: 'Polygon'\n        },\n        aArray: {\n          type: 'Array'\n        },\n        aObject: {\n          type: 'Object'\n        }\n      };\n      const schemas = {\n        definitions: [{\n          className: 'Test',\n          fields\n        }]\n      };\n\n      // Create\n      await new DefinedSchemas(schemas, server.config).execute();\n      let schema = await new Parse.Schema('Test').get();\n      expect(schema.fields).toEqual(fields);\n      fields.anotherObject = {\n        type: 'Object'\n      };\n      // Update\n      await new DefinedSchemas(schemas, server.config).execute();\n      schema = await new Parse.Schema('Test').get();\n      expect(schema.fields).toEqual(fields);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should not delete removed fields when \"deleteExtraFields\" is false","suites":["DefinedSchemas","Fields"],"line":319,"updatePoint":{"line":319,"column":74,"index":7813},"code":"    it('should not delete removed fields when \"deleteExtraFields\" is false', async () => {\n      const server = await reconfigureServer();\n      await new DefinedSchemas({\n        definitions: [{\n          className: 'Test',\n          fields: {\n            aField: {\n              type: 'String'\n            }\n          }\n        }]\n      }, server.config).execute();\n      let schema = await new Parse.Schema('Test').get();\n      expect(schema.fields.aField).toBeDefined();\n      await new DefinedSchemas({\n        definitions: [{\n          className: 'Test'\n        }]\n      }, server.config).execute();\n      schema = await new Parse.Schema('Test').get();\n      expect(schema.fields).toEqual({\n        objectId: {\n          type: 'String'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        aField: {\n          type: 'String'\n        },\n        ACL: {\n          type: 'ACL'\n        }\n      });\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should delete removed fields when \"deleteExtraFields\" is true","suites":["DefinedSchemas","Fields"],"line":357,"updatePoint":{"line":357,"column":69,"index":8790},"code":"    it('should delete removed fields when \"deleteExtraFields\" is true', async () => {\n      const server = await reconfigureServer();\n      await new DefinedSchemas({\n        definitions: [{\n          className: 'Test',\n          fields: {\n            aField: {\n              type: 'String'\n            }\n          }\n        }]\n      }, server.config).execute();\n      let schema = await new Parse.Schema('Test').get();\n      expect(schema.fields.aField).toBeDefined();\n      await new DefinedSchemas({\n        deleteExtraFields: true,\n        definitions: [{\n          className: 'Test'\n        }]\n      }, server.config).execute();\n      schema = await new Parse.Schema('Test').get();\n      expect(schema.fields).toEqual({\n        objectId: {\n          type: 'String'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        ACL: {\n          type: 'ACL'\n        }\n      });\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should re create fields with changed type when \"recreateModifiedFields\" is true","suites":["DefinedSchemas","Fields"],"line":393,"updatePoint":{"line":393,"column":87,"index":9764},"code":"    it('should re create fields with changed type when \"recreateModifiedFields\" is true', async () => {\n      const server = await reconfigureServer();\n      await new DefinedSchemas({\n        definitions: [{\n          className: 'Test',\n          fields: {\n            aField: {\n              type: 'String'\n            }\n          }\n        }]\n      }, server.config).execute();\n      let schema = await new Parse.Schema('Test').get();\n      expect(schema.fields.aField).toEqual({\n        type: 'String'\n      });\n      const object = new Parse.Object('Test');\n      await object.save({\n        aField: 'Hello'\n      }, {\n        useMasterKey: true\n      });\n      await new DefinedSchemas({\n        recreateModifiedFields: true,\n        definitions: [{\n          className: 'Test',\n          fields: {\n            aField: {\n              type: 'Number'\n            }\n          }\n        }]\n      }, server.config).execute();\n      schema = await new Parse.Schema('Test').get();\n      expect(schema.fields.aField).toEqual({\n        type: 'Number'\n      });\n      await object.fetch({\n        useMasterKey: true\n      });\n      expect(object.get('aField')).toBeUndefined();\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should not re create fields with changed type when \"recreateModifiedFields\" is not true","suites":["DefinedSchemas","Fields"],"line":435,"updatePoint":{"line":435,"column":95,"index":10955},"code":"    it('should not re create fields with changed type when \"recreateModifiedFields\" is not true', async () => {\n      const server = await reconfigureServer();\n      await new DefinedSchemas({\n        definitions: [{\n          className: 'Test',\n          fields: {\n            aField: {\n              type: 'String'\n            }\n          }\n        }]\n      }, server.config).execute();\n      let schema = await new Parse.Schema('Test').get();\n      expect(schema.fields.aField).toEqual({\n        type: 'String'\n      });\n      const object = new Parse.Object('Test');\n      await object.save({\n        aField: 'Hello'\n      }, {\n        useMasterKey: true\n      });\n      await new DefinedSchemas({\n        definitions: [{\n          className: 'Test',\n          fields: {\n            aField: {\n              type: 'Number'\n            }\n          }\n        }]\n      }, server.config).execute();\n      schema = await new Parse.Schema('Test').get();\n      expect(schema.fields.aField).toEqual({\n        type: 'String'\n      });\n      await object.fetch({\n        useMasterKey: true\n      });\n      expect(object.get('aField')).toBeDefined();\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should just update classic fields with changed params","suites":["DefinedSchemas","Fields"],"line":476,"updatePoint":{"line":476,"column":61,"index":12072},"code":"    it('should just update classic fields with changed params', async () => {\n      const server = await reconfigureServer();\n      await new DefinedSchemas({\n        definitions: [{\n          className: 'Test',\n          fields: {\n            aField: {\n              type: 'String'\n            }\n          }\n        }]\n      }, server.config).execute();\n      let schema = await new Parse.Schema('Test').get();\n      expect(schema.fields.aField).toEqual({\n        type: 'String'\n      });\n      const object = new Parse.Object('Test');\n      await object.save({\n        aField: 'Hello'\n      }, {\n        useMasterKey: true\n      });\n      await new DefinedSchemas({\n        definitions: [{\n          className: 'Test',\n          fields: {\n            aField: {\n              type: 'String',\n              required: true\n            }\n          }\n        }]\n      }, server.config).execute();\n      schema = await new Parse.Schema('Test').get();\n      expect(schema.fields.aField).toEqual({\n        type: 'String',\n        required: true\n      });\n      await object.fetch({\n        useMasterKey: true\n      });\n      expect(object.get('aField')).toEqual('Hello');\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should create new indexes","suites":["DefinedSchemas","Indexes"],"line":521,"updatePoint":{"line":521,"column":33,"index":13254},"code":"    it('should create new indexes', async () => {\n      const server = await reconfigureServer();\n      const indexes = {\n        complex: {\n          createdAt: 1,\n          updatedAt: 1\n        }\n      };\n      const schemas = {\n        definitions: [{\n          className: 'Test',\n          fields: {\n            aField: {\n              type: 'String'\n            }\n          },\n          indexes\n        }]\n      };\n      await new DefinedSchemas(schemas, server.config).execute();\n      let schema = await new Parse.Schema('Test').get();\n      cleanUpIndexes(schema);\n      expect(schema.indexes).toEqual(indexes);\n      indexes.complex2 = {\n        createdAt: 1,\n        aField: 1\n      };\n      await new DefinedSchemas(schemas, server.config).execute();\n      schema = await new Parse.Schema('Test').get();\n      cleanUpIndexes(schema);\n      expect(schema.indexes).toEqual(indexes);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should re create changed indexes","suites":["DefinedSchemas","Indexes"],"line":553,"updatePoint":{"line":553,"column":40,"index":14161},"code":"    it('should re create changed indexes', async () => {\n      const server = await reconfigureServer();\n      let indexes = {\n        complex: {\n          createdAt: 1,\n          updatedAt: 1\n        }\n      };\n      let schemas = {\n        definitions: [{\n          className: 'Test',\n          indexes\n        }]\n      };\n      await new DefinedSchemas(schemas, server.config).execute();\n      indexes = {\n        complex: {\n          createdAt: 1\n        }\n      };\n      schemas = {\n        definitions: [{\n          className: 'Test',\n          indexes\n        }]\n      };\n\n      // Change indexes\n      await new DefinedSchemas(schemas, server.config).execute();\n      let schema = await new Parse.Schema('Test').get();\n      cleanUpIndexes(schema);\n      expect(schema.indexes).toEqual(indexes);\n\n      // Update\n      await new DefinedSchemas(schemas, server.config).execute();\n      schema = await new Parse.Schema('Test').get();\n      cleanUpIndexes(schema);\n      expect(schema.indexes).toEqual(indexes);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should delete removed indexes","suites":["DefinedSchemas","Indexes"],"line":592,"updatePoint":{"line":592,"column":37,"index":15183},"code":"    it('should delete removed indexes', async () => {\n      const server = await reconfigureServer();\n      let indexes = {\n        complex: {\n          createdAt: 1,\n          updatedAt: 1\n        }\n      };\n      let schemas = {\n        definitions: [{\n          className: 'Test',\n          indexes\n        }]\n      };\n      await new DefinedSchemas(schemas, server.config).execute();\n      indexes = {};\n      schemas = {\n        definitions: [{\n          className: 'Test',\n          indexes\n        }]\n      };\n      // Change indexes\n      await new DefinedSchemas(schemas, server.config).execute();\n      let schema = await new Parse.Schema('Test').get();\n      cleanUpIndexes(schema);\n      expect(schema.indexes).toBeUndefined();\n\n      // Update\n      await new DefinedSchemas(schemas, server.config).execute();\n      schema = await new Parse.Schema('Test').get();\n      cleanUpIndexes(schema);\n      expect(schema.indexes).toBeUndefined();\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should keep protected indexes","suites":["DefinedSchemas","Indexes"],"line":626,"updatePoint":{"line":626,"column":38,"index":16144},"skipped":true,"code":"    xit('should keep protected indexes', async () => {\n      const server = await reconfigureServer();\n      const expectedIndexes = {\n        username_1: {\n          username: 1\n        },\n        case_insensitive_username: {\n          username: 1\n        },\n        email_1: {\n          email: 1\n        },\n        case_insensitive_email: {\n          email: 1\n        }\n      };\n      const schemas = {\n        definitions: [{\n          className: '_User',\n          indexes: {\n            case_insensitive_username: {\n              password: true\n            },\n            case_insensitive_email: {\n              password: true\n            }\n          }\n        }, {\n          className: 'Test'\n        }]\n      };\n      //  Create\n      await new DefinedSchemas(schemas, server.config).execute();\n      let userSchema = await new Parse.Schema('_User').get();\n      let testSchema = await new Parse.Schema('Test').get();\n      cleanUpIndexes(userSchema);\n      cleanUpIndexes(testSchema);\n      expect(testSchema.indexes).toBeUndefined();\n      expect(userSchema.indexes).toEqual(expectedIndexes);\n\n      //   Update\n      await new DefinedSchemas(schemas, server.config).execute();\n      userSchema = await new Parse.Schema('_User').get();\n      testSchema = await new Parse.Schema('Test').get();\n      cleanUpIndexes(userSchema);\n      cleanUpIndexes(testSchema);\n      expect(testSchema.indexes).toBeUndefined();\n      expect(userSchema.indexes).toEqual(expectedIndexes);\n    });","file":"DefinedSchemas.spec.js","dir":"spec"},{"name":"should detect protected indexes for _User class","suites":["DefinedSchemas","Indexes"],"line":675,"updatePoint":{"line":675,"column":55,"index":17648},"code":"    it('should detect protected indexes for _User class', () => {\n      const definedSchema = new DefinedSchemas({}, {});\n      const protectedUserIndexes = ['_id_', 'case_insensitive_email', 'username_1', 'email_1'];\n      protectedUserIndexes.forEach(field => {\n        expect(definedSchema.isProtectedIndex('_User', field)).toEqual(true);\n      });\n      expect(definedSchema.isProtectedIndex('_User', 'test')).toEqual(false);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should detect protected indexes for _Role class","suites":["DefinedSchemas","Indexes"],"line":683,"updatePoint":{"line":683,"column":55,"index":18086},"code":"    it('should detect protected indexes for _Role class', () => {\n      const definedSchema = new DefinedSchemas({}, {});\n      expect(definedSchema.isProtectedIndex('_Role', 'name_1')).toEqual(true);\n      expect(definedSchema.isProtectedIndex('_Role', 'test')).toEqual(false);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should detect protected indexes for _Idempotency class","suites":["DefinedSchemas","Indexes"],"line":688,"updatePoint":{"line":688,"column":62,"index":18380},"code":"    it('should detect protected indexes for _Idempotency class', () => {\n      const definedSchema = new DefinedSchemas({}, {});\n      expect(definedSchema.isProtectedIndex('_Idempotency', 'reqId_1')).toEqual(true);\n      expect(definedSchema.isProtectedIndex('_Idempotency', 'test')).toEqual(false);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should not detect protected indexes on user defined class","suites":["DefinedSchemas","Indexes"],"line":693,"updatePoint":{"line":693,"column":65,"index":18692},"code":"    it('should not detect protected indexes on user defined class', () => {\n      const definedSchema = new DefinedSchemas({}, {});\n      const protectedIndexes = ['case_insensitive_email', 'username_1', 'email_1', 'reqId_1', 'name_1'];\n      protectedIndexes.forEach(field => {\n        expect(definedSchema.isProtectedIndex('ExampleClass', field)).toEqual(false);\n      });\n      expect(definedSchema.isProtectedIndex('ExampleClass', '_id_')).toEqual(true);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should use default CLP","suites":["DefinedSchemas","ClassLevelPermissions"],"line":703,"updatePoint":{"line":703,"column":30,"index":19174},"code":"    it('should use default CLP', async () => {\n      const server = await reconfigureServer();\n      const schemas = {\n        definitions: [{\n          className: 'Test'\n        }]\n      };\n      await new DefinedSchemas(schemas, server.config).execute();\n      const expectedTestCLP = {\n        find: {},\n        count: {},\n        get: {},\n        create: {},\n        update: {},\n        delete: {},\n        addField: {},\n        protectedFields: {}\n      };\n      let testSchema = await new Parse.Schema('Test').get();\n      expect(testSchema.classLevelPermissions).toEqual(expectedTestCLP);\n      await new DefinedSchemas(schemas, server.config).execute();\n      testSchema = await new Parse.Schema('Test').get();\n      expect(testSchema.classLevelPermissions).toEqual(expectedTestCLP);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should save CLP","suites":["DefinedSchemas","ClassLevelPermissions"],"line":727,"updatePoint":{"line":727,"column":23,"index":19967},"code":"    it('should save CLP', async () => {\n      const server = await reconfigureServer();\n      const expectedTestCLP = {\n        find: {},\n        count: {\n          requiresAuthentication: true\n        },\n        get: {\n          'role:Admin': true\n        },\n        create: {\n          'role:ARole': true,\n          requiresAuthentication: true\n        },\n        update: {\n          requiresAuthentication: true\n        },\n        delete: {\n          requiresAuthentication: true\n        },\n        addField: {},\n        protectedFields: {\n          '*': ['aField'],\n          'role:Admin': ['anotherField']\n        }\n      };\n      const schemas = {\n        definitions: [{\n          className: 'Test',\n          fields: {\n            aField: {\n              type: 'String'\n            },\n            anotherField: {\n              type: 'Object'\n            }\n          },\n          classLevelPermissions: expectedTestCLP\n        }]\n      };\n      await new DefinedSchemas(schemas, server.config).execute();\n      let testSchema = await new Parse.Schema('Test').get();\n      expect(testSchema.classLevelPermissions).toEqual(expectedTestCLP);\n      expectedTestCLP.update = {};\n      expectedTestCLP.create = {\n        requiresAuthentication: true\n      };\n      await new DefinedSchemas(schemas, server.config).execute();\n      testSchema = await new Parse.Schema('Test').get();\n      expect(testSchema.classLevelPermissions).toEqual(expectedTestCLP);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should force addField to empty","suites":["DefinedSchemas","ClassLevelPermissions"],"line":778,"updatePoint":{"line":778,"column":38,"index":21446},"code":"    it('should force addField to empty', async () => {\n      const server = await reconfigureServer();\n      const schemas = {\n        definitions: [{\n          className: 'Test',\n          classLevelPermissions: {\n            addField: {\n              '*': true\n            }\n          }\n        }]\n      };\n      await new DefinedSchemas(schemas, server.config).execute();\n      const expectedTestCLP = {\n        find: {},\n        count: {},\n        get: {},\n        create: {},\n        update: {},\n        delete: {},\n        addField: {},\n        protectedFields: {}\n      };\n      let testSchema = await new Parse.Schema('Test').get();\n      expect(testSchema.classLevelPermissions).toEqual(expectedTestCLP);\n      await new DefinedSchemas(schemas, server.config).execute();\n      testSchema = await new Parse.Schema('Test').get();\n      expect(testSchema.classLevelPermissions).toEqual(expectedTestCLP);\n    });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should not delete automatically classes","suites":["DefinedSchemas","ClassLevelPermissions"],"line":808,"updatePoint":{"line":808,"column":45,"index":22377},"code":"  it('should not delete automatically classes', async () => {\n    await reconfigureServer({\n      schema: {\n        definitions: [{\n          className: '_User'\n        }, {\n          className: 'Test'\n        }]\n      }\n    });\n    await reconfigureServer({\n      schema: {\n        definitions: [{\n          className: '_User'\n        }]\n      }\n    });\n    const schema = await new Parse.Schema('Test').get();\n    expect(schema.className).toEqual('Test');\n  });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should disable class PUT/POST endpoint when lockSchemas provided to avoid dual source of truth","suites":["DefinedSchemas","ClassLevelPermissions"],"line":828,"updatePoint":{"line":828,"column":100,"index":22896},"code":"  it('should disable class PUT/POST endpoint when lockSchemas provided to avoid dual source of truth', async () => {\n    await reconfigureServer({\n      schema: {\n        lockSchemas: true,\n        definitions: [{\n          className: '_User'\n        }, {\n          className: 'Test'\n        }]\n      }\n    });\n    const schema = await new Parse.Schema('Test').get();\n    expect(schema.className).toEqual('Test');\n    const schemas = await Parse.Schema.all();\n    // Role could be flaky since all system classes are not ensured\n    // at start up by the DefinedSchema system\n    expect(schemas.filter(({\n      className\n    }) => className !== '_Role').length).toEqual(3);\n    await expectAsync(new Parse.Schema('TheNewTest').save()).toBeRejectedWithError('Cannot perform this operation when schemas options is used.');\n    await expectAsync(new Parse.Schema('_User').update()).toBeRejectedWithError('Cannot perform this operation when schemas options is used.');\n  });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should only enable delete class endpoint since","suites":["DefinedSchemas","ClassLevelPermissions"],"line":850,"updatePoint":{"line":850,"column":52,"index":23818},"code":"  it('should only enable delete class endpoint since', async () => {\n    await reconfigureServer({\n      schema: {\n        definitions: [{\n          className: '_User'\n        }, {\n          className: 'Test'\n        }]\n      }\n    });\n    await reconfigureServer({\n      schema: {\n        definitions: [{\n          className: '_User'\n        }]\n      }\n    });\n    let schemas = await Parse.Schema.all();\n    expect(schemas.length).toEqual(4);\n    await new Parse.Schema('_User').delete();\n    schemas = await Parse.Schema.all();\n    expect(schemas.length).toEqual(3);\n  });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should run beforeMigration before execution of DefinedSchemas","suites":["DefinedSchemas","ClassLevelPermissions"],"line":873,"updatePoint":{"line":873,"column":67,"index":24409},"code":"  it('should run beforeMigration before execution of DefinedSchemas', async () => {\n    const config = {\n      schema: {\n        definitions: [{\n          className: '_User'\n        }, {\n          className: 'Test'\n        }],\n        beforeMigration: async () => {}\n      }\n    };\n    const spy = spyOn(config.schema, 'beforeMigration');\n    await reconfigureServer(config);\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should run afterMigration after execution of DefinedSchemas","suites":["DefinedSchemas","ClassLevelPermissions"],"line":888,"updatePoint":{"line":888,"column":65,"index":24831},"code":"  it('should run afterMigration after execution of DefinedSchemas', async () => {\n    const config = {\n      schema: {\n        definitions: [{\n          className: '_User'\n        }, {\n          className: 'Test'\n        }],\n        afterMigration: async () => {}\n      }\n    };\n    const spy = spyOn(config.schema, 'afterMigration');\n    await reconfigureServer(config);\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should use logger in case of error","suites":["DefinedSchemas","ClassLevelPermissions"],"line":903,"updatePoint":{"line":903,"column":40,"index":25226},"code":"  it('should use logger in case of error', async () => {\n    const server = await reconfigureServer({\n      schema: {\n        definitions: [{\n          className: '_User'\n        }]\n      }\n    });\n    const error = new Error('A test error');\n    const logger = require('../lib/logger').logger;\n    spyOn(DefinedSchemas.prototype, 'wait').and.resolveTo();\n    spyOn(logger, 'error').and.callThrough();\n    spyOn(Parse.Schema, 'all').and.callFake(() => {\n      throw error;\n    });\n    await new DefinedSchemas({\n      definitions: [{\n        className: 'Test',\n        fields: {\n          aField: {\n            type: 'String'\n          }\n        }\n      }]\n    }, server.config).execute();\n    expect(logger.error).toHaveBeenCalledWith(`Failed to run migrations: ${error.toString()}`);\n  });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"should perform migration in parallel without failing","suites":["DefinedSchemas","ClassLevelPermissions"],"line":930,"updatePoint":{"line":930,"column":58,"index":26036},"code":"  it('should perform migration in parallel without failing', async () => {\n    const server = await reconfigureServer();\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'error').and.callThrough();\n    const migrationOptions = {\n      definitions: [{\n        className: 'Test',\n        fields: {\n          aField: {\n            type: 'String'\n          }\n        },\n        indexes: {\n          aField: {\n            aField: 1\n          }\n        },\n        classLevelPermissions: {\n          create: {\n            requiresAuthentication: true\n          }\n        }\n      }]\n    };\n\n    // Simulate parallel deployment\n    await Promise.all([new DefinedSchemas(migrationOptions, server.config).execute(), new DefinedSchemas(migrationOptions, server.config).execute(), new DefinedSchemas(migrationOptions, server.config).execute(), new DefinedSchemas(migrationOptions, server.config).execute(), new DefinedSchemas(migrationOptions, server.config).execute()]);\n    const testSchema = (await Parse.Schema.all()).find(({\n      className\n    }) => className === migrationOptions.definitions[0].className);\n    expect(testSchema.indexes.aField).toEqual({\n      aField: 1\n    });\n    expect(testSchema.fields.aField).toEqual({\n      type: 'String'\n    });\n    expect(testSchema.classLevelPermissions.create).toEqual({\n      requiresAuthentication: true\n    });\n    expect(logger.error).toHaveBeenCalledTimes(0);\n  });","file":"DefinedSchemas.spec.js","skipped":false,"dir":"spec"},{"name":"deprecations are an array","suites":["Deprecator"],"line":12,"updatePoint":{"line":12,"column":31,"index":301},"code":"  it('deprecations are an array', async () => {\n    expect(Deprecator._getDeprecations()).toBeInstanceOf(Array);\n  });","file":"Deprecator.spec.js","skipped":false,"dir":"spec"},{"name":"logs deprecation for new default","suites":["Deprecator"],"line":15,"updatePoint":{"line":15,"column":38,"index":427},"code":"  it('logs deprecation for new default', async () => {\n    deprecations = [{\n      optionKey: 'exampleKey',\n      changeNewDefault: 'exampleNewDefault'\n    }];\n    spyOn(Deprecator, '_getDeprecations').and.callFake(() => deprecations);\n    const logger = require('../lib/logger').logger;\n    const logSpy = spyOn(logger, 'warn').and.callFake(() => {});\n    await reconfigureServer();\n    expect(logSpy.calls.all()[0].args[0]).toEqual(`DeprecationWarning: The Parse Server option '${deprecations[0].optionKey}' default will change to '${deprecations[0].changeNewDefault}' in a future version.`);\n  });","file":"Deprecator.spec.js","skipped":false,"dir":"spec"},{"name":"does not log deprecation for new default if option is set manually","suites":["Deprecator"],"line":26,"updatePoint":{"line":26,"column":72,"index":1062},"code":"  it('does not log deprecation for new default if option is set manually', async () => {\n    deprecations = [{\n      optionKey: 'exampleKey',\n      changeNewDefault: 'exampleNewDefault'\n    }];\n    spyOn(Deprecator, '_getDeprecations').and.callFake(() => deprecations);\n    const logSpy = spyOn(Deprecator, '_logOption').and.callFake(() => {});\n    await reconfigureServer({\n      [deprecations[0].optionKey]: 'manuallySet'\n    });\n    expect(logSpy).not.toHaveBeenCalled();\n  });","file":"Deprecator.spec.js","skipped":false,"dir":"spec"},{"name":"logs runtime deprecation","suites":["Deprecator"],"line":38,"updatePoint":{"line":38,"column":30,"index":1501},"code":"  it('logs runtime deprecation', async () => {\n    const logger = require('../lib/logger').logger;\n    const logSpy = spyOn(logger, 'warn').and.callFake(() => {});\n    const options = {\n      usage: 'Doing this',\n      solution: 'Do that instead.'\n    };\n    Deprecator.logRuntimeDeprecation(options);\n    expect(logSpy.calls.all()[0].args[0]).toEqual(`DeprecationWarning: ${options.usage} is deprecated and will be removed in a future version. ${options.solution}`);\n  });","file":"Deprecator.spec.js","skipped":false,"dir":"spec"},{"name":"show the invalid verification link page, if the user clicks on the verify email link after the email verify token expires","suites":["Email Verification Token Expiration: "],"line":6,"updatePoint":{"line":6,"column":127,"index":285},"code":"  it('show the invalid verification link page, if the user clicks on the verify email link after the email verify token expires', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 0.5,\n      // 0.5 second\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('testEmailVerifyTokenValidity');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      // wait for 1 second - simulate user behavior to some extent\n      setTimeout(() => {\n        expect(sendEmailOptions).not.toBeUndefined();\n        request({\n          url: sendEmailOptions.link,\n          followRedirects: false\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/invalid_verification_link.html?username=testEmailVerifyTokenValidity&appId=test');\n          done();\n        });\n      }, 1000);\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"emailVerified should set to false, if the user does not verify their email before the email verify token expires","suites":["Email Verification Token Expiration: "],"line":46,"updatePoint":{"line":46,"column":118,"index":1725},"code":"  it('emailVerified should set to false, if the user does not verify their email before the email verify token expires', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 0.5,\n      // 0.5 second\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('testEmailVerifyTokenValidity');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      // wait for 1 second - simulate user behavior to some extent\n      setTimeout(() => {\n        expect(sendEmailOptions).not.toBeUndefined();\n        request({\n          url: sendEmailOptions.link,\n          followRedirects: false\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          user.fetch().then(() => {\n            expect(user.get('emailVerified')).toEqual(false);\n            done();\n          }).catch(error => {\n            jfail(error);\n            done();\n          });\n        });\n      }, 1000);\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"if user clicks on the email verify link before email verification token expiration then show the verify email success page","suites":["Email Verification Token Expiration: "],"line":91,"updatePoint":{"line":91,"column":128,"index":3194},"code":"  it('if user clicks on the email verify link before email verification token expiration then show the verify email success page', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('testEmailVerifyTokenValidity');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      request({\n        url: sendEmailOptions.link,\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/verify_email_success.html?username=testEmailVerifyTokenValidity');\n        done();\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"if user clicks on the email verify link before email verification token expiration then emailVerified should be true","suites":["Email Verification Token Expiration: "],"line":127,"updatePoint":{"line":127,"column":122,"index":4445},"code":"  it('if user clicks on the email verify link before email verification token expiration then emailVerified should be true', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('testEmailVerifyTokenValidity');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      request({\n        url: sendEmailOptions.link,\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        user.fetch().then(() => {\n          expect(user.get('emailVerified')).toEqual(true);\n          done();\n        }).catch(error => {\n          jfail(error);\n          done();\n        });\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"if user clicks on the email verify link before email verification token expiration then user should be able to login","suites":["Email Verification Token Expiration: "],"line":168,"updatePoint":{"line":168,"column":122,"index":5716},"code":"  it('if user clicks on the email verify link before email verification token expiration then user should be able to login', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('testEmailVerifyTokenValidity');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      request({\n        url: sendEmailOptions.link,\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        Parse.User.logIn('testEmailVerifyTokenValidity', 'expiringToken').then(user => {\n          expect(typeof user).toBe('object');\n          expect(user.get('emailVerified')).toBe(true);\n          done();\n        }).catch(error => {\n          jfail(error);\n          done();\n        });\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"sets the _email_verify_token_expires_at and _email_verify_token fields after user SignUp","suites":["Email Verification Token Expiration: "],"line":210,"updatePoint":{"line":210,"column":94,"index":7057},"code":"  it('sets the _email_verify_token_expires_at and _email_verify_token fields after user SignUp', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('sets_email_verify_token_expires_at');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      const config = Config.get('test');\n      return config.database.find('_User', {\n        username: 'sets_email_verify_token_expires_at'\n      });\n    }).then(results => {\n      expect(results.length).toBe(1);\n      const user = results[0];\n      expect(typeof user).toBe('object');\n      expect(user.emailVerified).toEqual(false);\n      expect(typeof user._email_verify_token).toBe('string');\n      expect(typeof user._email_verify_token_expires_at).toBe('object');\n      expect(sendEmailOptions).toBeDefined();\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"unsets the _email_verify_token_expires_at and _email_verify_token fields in the User class if email verification is successful","suites":["Email Verification Token Expiration: "],"line":251,"updatePoint":{"line":251,"column":132,"index":8515},"code":"  it('unsets the _email_verify_token_expires_at and _email_verify_token fields in the User class if email verification is successful', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('unsets_email_verify_token_expires_at');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      request({\n        url: sendEmailOptions.link,\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        const config = Config.get('test');\n        return config.database.find('_User', {\n          username: 'unsets_email_verify_token_expires_at'\n        }).then(results => {\n          expect(results.length).toBe(1);\n          return results[0];\n        }).then(user => {\n          expect(typeof user).toBe('object');\n          expect(user.emailVerified).toEqual(true);\n          expect(typeof user._email_verify_token).toBe('undefined');\n          expect(typeof user._email_verify_token_expires_at).toBe('undefined');\n          done();\n        }).catch(error => {\n          jfail(error);\n          done();\n        });\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"clicking on the email verify link by an email VERIFIED user that was setup before enabling the expire email verify token should show email verify email success","suites":["Email Verification Token Expiration: "],"line":301,"updatePoint":{"line":301,"column":165,"index":10266},"code":"  it('clicking on the email verify link by an email VERIFIED user that was setup before enabling the expire email verify token should show email verify email success', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    const serverConfig = {\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    };\n\n    // setup server WITHOUT enabling the expire email verify token flag\n    reconfigureServer(serverConfig).then(() => {\n      user.setUsername('testEmailVerifyTokenValidity');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      return request({\n        url: sendEmailOptions.link,\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        return user.fetch();\n      });\n    }).then(() => {\n      expect(user.get('emailVerified')).toEqual(true);\n      // RECONFIGURE the server i.e., ENABLE the expire email verify token flag\n      serverConfig.emailVerifyTokenValidityDuration = 5; // 5 seconds\n      return reconfigureServer(serverConfig);\n    }).then(() => {\n      request({\n        url: sendEmailOptions.link,\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/verify_email_success.html?username=testEmailVerifyTokenValidity');\n        done();\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"clicking on the email verify link by an email UNVERIFIED user that was setup before enabling the expire email verify token should show invalid verficiation link page","suites":["Email Verification Token Expiration: "],"line":351,"updatePoint":{"line":351,"column":171,"index":12110},"code":"  it('clicking on the email verify link by an email UNVERIFIED user that was setup before enabling the expire email verify token should show invalid verficiation link page', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    const serverConfig = {\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    };\n\n    // setup server WITHOUT enabling the expire email verify token flag\n    reconfigureServer(serverConfig).then(() => {\n      user.setUsername('testEmailVerifyTokenValidity');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      // just get the user again - DO NOT email verify the user\n      return user.fetch();\n    }).then(() => {\n      expect(user.get('emailVerified')).toEqual(false);\n      // RECONFIGURE the server i.e., ENABLE the expire email verify token flag\n      serverConfig.emailVerifyTokenValidityDuration = 5; // 5 seconds\n      return reconfigureServer(serverConfig);\n    }).then(() => {\n      request({\n        url: sendEmailOptions.link,\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/invalid_verification_link.html?username=testEmailVerifyTokenValidity&appId=test');\n        done();\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"setting the email on the user should set a new email verification token and new expiration date for the token when expire email verify token flag is set","suites":["Email Verification Token Expiration: "],"line":396,"updatePoint":{"line":396,"column":158,"index":13846},"code":"  it('setting the email on the user should set a new email verification token and new expiration date for the token when expire email verify token flag is set', done => {\n    const user = new Parse.User();\n    let userBeforeEmailReset;\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    const serverConfig = {\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    };\n    reconfigureServer(serverConfig).then(() => {\n      user.setUsername('newEmailVerifyTokenOnEmailReset');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      const config = Config.get('test');\n      return config.database.find('_User', {\n        username: 'newEmailVerifyTokenOnEmailReset'\n      }).then(results => {\n        return results[0];\n      });\n    }).then(userFromDb => {\n      expect(typeof userFromDb).toBe('object');\n      userBeforeEmailReset = userFromDb;\n\n      // trigger another token generation by setting the email\n      user.set('email', 'user@parse.com');\n      return new Promise(resolve => {\n        // wait for half a sec to get a new expiration time\n        setTimeout(() => resolve(user.save()), 500);\n      });\n    }).then(() => {\n      const config = Config.get('test');\n      return config.database.find('_User', {\n        username: 'newEmailVerifyTokenOnEmailReset'\n      }).then(results => {\n        return results[0];\n      });\n    }).then(userAfterEmailReset => {\n      expect(typeof userAfterEmailReset).toBe('object');\n      expect(userBeforeEmailReset._email_verify_token).not.toEqual(userAfterEmailReset._email_verify_token);\n      expect(userBeforeEmailReset._email_verify_token_expires_at).not.toEqual(userAfterEmailReset._email_verify_token_expires_at);\n      expect(sendEmailOptions).toBeDefined();\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"should send a new verification email when a resend is requested and the user is UNVERIFIED","suites":["Email Verification Token Expiration: "],"line":455,"updatePoint":{"line":455,"column":96,"index":16006},"code":"  it('should send a new verification email when a resend is requested and the user is UNVERIFIED', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    let sendVerificationEmailCallCount = 0;\n    let userBeforeRequest;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n        sendVerificationEmailCallCount++;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('resends_verification_token');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      const config = Config.get('test');\n      return config.database.find('_User', {\n        username: 'resends_verification_token'\n      }).then(results => {\n        return results[0];\n      });\n    }).then(newUser => {\n      // store this user before we make our email request\n      userBeforeRequest = newUser;\n      expect(sendVerificationEmailCallCount).toBe(1);\n      return request({\n        url: 'http://localhost:8378/1/verificationEmailRequest',\n        method: 'POST',\n        body: {\n          email: 'user@parse.com'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(response => {\n      expect(response.status).toBe(200);\n      expect(sendVerificationEmailCallCount).toBe(2);\n      expect(sendEmailOptions).toBeDefined();\n\n      // query for this user again\n      const config = Config.get('test');\n      return config.database.find('_User', {\n        username: 'resends_verification_token'\n      }).then(results => {\n        return results[0];\n      });\n    }).then(userAfterRequest => {\n      // verify that our token & expiration has been changed for this new request\n      expect(typeof userAfterRequest).toBe('object');\n      expect(userBeforeRequest._email_verify_token).not.toEqual(userAfterRequest._email_verify_token);\n      expect(userBeforeRequest._email_verify_token_expires_at).not.toEqual(userAfterRequest._email_verify_token_expires_at);\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"should throw with invalid emailVerifyTokenReuseIfValid","suites":["Email Verification Token Expiration: "],"line":526,"updatePoint":{"line":526,"column":60,"index":18503},"code":"  it('should throw with invalid emailVerifyTokenReuseIfValid', async done => {\n    const sendEmailOptions = [];\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        sendEmailOptions.push(options);\n      },\n      sendMail: () => {}\n    };\n    try {\n      await reconfigureServer({\n        appName: 'passwordPolicy',\n        verifyUserEmails: true,\n        emailAdapter: emailAdapter,\n        emailVerifyTokenValidityDuration: 5 * 60,\n        // 5 minutes\n        emailVerifyTokenReuseIfValid: [],\n        publicServerURL: 'http://localhost:8378/1'\n      });\n      fail('should have thrown.');\n    } catch (e) {\n      expect(e).toBe('emailVerifyTokenReuseIfValid must be a boolean value');\n    }\n    try {\n      await reconfigureServer({\n        appName: 'passwordPolicy',\n        verifyUserEmails: true,\n        emailAdapter: emailAdapter,\n        emailVerifyTokenReuseIfValid: true,\n        publicServerURL: 'http://localhost:8378/1'\n      });\n      fail('should have thrown.');\n    } catch (e) {\n      expect(e).toBe('You cannot use emailVerifyTokenReuseIfValid without emailVerifyTokenValidityDuration');\n    }\n    done();\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"should match codes with emailVerifyTokenReuseIfValid","suites":["Email Verification Token Expiration: "],"line":563,"updatePoint":{"line":563,"column":58,"index":19711},"code":"  it('should match codes with emailVerifyTokenReuseIfValid', async done => {\n    let sendEmailOptions;\n    let sendVerificationEmailCallCount = 0;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n        sendVerificationEmailCallCount++;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    await reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5 * 60,\n      // 5 minutes\n      publicServerURL: 'http://localhost:8378/1',\n      emailVerifyTokenReuseIfValid: true\n    });\n    const user = new Parse.User();\n    user.setUsername('resends_verification_token');\n    user.setPassword('expiringToken');\n    user.set('email', 'user@example.com');\n    await user.signUp();\n    const config = Config.get('test');\n    const [userBeforeRequest] = await config.database.find('_User', {\n      username: 'resends_verification_token'\n    });\n    // store this user before we make our email request\n    expect(sendVerificationEmailCallCount).toBe(1);\n    await new Promise(resolve => {\n      setTimeout(() => {\n        resolve();\n      }, 1000);\n    });\n    const response = await request({\n      url: 'http://localhost:8378/1/verificationEmailRequest',\n      method: 'POST',\n      body: {\n        email: 'user@example.com'\n      },\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      }\n    });\n    expect(response.status).toBe(200);\n    expect(sendVerificationEmailCallCount).toBe(2);\n    expect(sendEmailOptions).toBeDefined();\n    const [userAfterRequest] = await config.database.find('_User', {\n      username: 'resends_verification_token'\n    });\n\n    // verify that our token & expiration has been changed for this new request\n    expect(typeof userAfterRequest).toBe('object');\n    expect(userBeforeRequest._email_verify_token).toEqual(userAfterRequest._email_verify_token);\n    expect(userBeforeRequest._email_verify_token_expires_at).toEqual(userAfterRequest._email_verify_token_expires_at);\n    done();\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"should not send a new verification email when a resend is requested and the user is VERIFIED","suites":["Email Verification Token Expiration: "],"line":624,"updatePoint":{"line":624,"column":98,"index":21977},"code":"  it('should not send a new verification email when a resend is requested and the user is VERIFIED', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    let sendVerificationEmailCallCount = 0;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n        sendVerificationEmailCallCount++;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('no_new_verification_token_once_verified');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      return request({\n        url: sendEmailOptions.link,\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n      });\n    }).then(() => {\n      expect(sendVerificationEmailCallCount).toBe(1);\n      return request({\n        url: 'http://localhost:8378/1/verificationEmailRequest',\n        method: 'POST',\n        body: {\n          email: 'user@parse.com'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json'\n        }\n      }).then(fail, res => res).then(response => {\n        expect(response.status).toBe(400);\n        expect(sendVerificationEmailCallCount).toBe(1);\n        done();\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"should not send a new verification email if this user does not exist","suites":["Email Verification Token Expiration: "],"line":678,"updatePoint":{"line":678,"column":74,"index":23707},"code":"  it('should not send a new verification email if this user does not exist', done => {\n    let sendEmailOptions;\n    let sendVerificationEmailCallCount = 0;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n        sendVerificationEmailCallCount++;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      return request({\n        url: 'http://localhost:8378/1/verificationEmailRequest',\n        method: 'POST',\n        body: {\n          email: 'user@parse.com'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json'\n        }\n      }).then(fail).catch(response => response).then(response => {\n        expect(response.status).toBe(400);\n        expect(sendVerificationEmailCallCount).toBe(0);\n        expect(sendEmailOptions).not.toBeDefined();\n        done();\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if no email is supplied","suites":["Email Verification Token Expiration: "],"line":719,"updatePoint":{"line":719,"column":41,"index":24990},"code":"  it('should fail if no email is supplied', done => {\n    let sendEmailOptions;\n    let sendVerificationEmailCallCount = 0;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n        sendVerificationEmailCallCount++;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/verificationEmailRequest',\n        method: 'POST',\n        body: {},\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json'\n        }\n      }).then(fail, response => response).then(response => {\n        expect(response.status).toBe(400);\n        expect(response.data.code).toBe(Parse.Error.EMAIL_MISSING);\n        expect(response.data.error).toBe('you must provide an email');\n        expect(sendVerificationEmailCallCount).toBe(0);\n        expect(sendEmailOptions).not.toBeDefined();\n        done();\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if email is not a string","suites":["Email Verification Token Expiration: "],"line":760,"updatePoint":{"line":760,"column":42,"index":26357},"code":"  it('should fail if email is not a string', done => {\n    let sendEmailOptions;\n    let sendVerificationEmailCallCount = 0;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n        sendVerificationEmailCallCount++;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/verificationEmailRequest',\n        method: 'POST',\n        body: {\n          email: 3\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json'\n        }\n      }).then(fail, res => res).then(response => {\n        expect(response.status).toBe(400);\n        expect(response.data.code).toBe(Parse.Error.INVALID_EMAIL_ADDRESS);\n        expect(response.data.error).toBe('you must provide a valid email string');\n        expect(sendVerificationEmailCallCount).toBe(0);\n        expect(sendEmailOptions).not.toBeDefined();\n        done();\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"client should not see the _email_verify_token_expires_at field","suites":["Email Verification Token Expiration: "],"line":803,"updatePoint":{"line":803,"column":68,"index":27788},"code":"  it('client should not see the _email_verify_token_expires_at field', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('testEmailVerifyTokenValidity');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      user.fetch().then(() => {\n        expect(user.get('emailVerified')).toEqual(false);\n        expect(typeof user.get('_email_verify_token_expires_at')).toBe('undefined');\n        expect(sendEmailOptions).toBeDefined();\n        done();\n      }).catch(error => {\n        jfail(error);\n        done();\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"emailVerified should be set to false after changing from an already verified email","suites":["Email Verification Token Expiration: "],"line":840,"updatePoint":{"line":840,"column":88,"index":28978},"code":"  it('emailVerified should be set to false after changing from an already verified email', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailVerifyToken',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 5,\n      // 5 seconds\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('testEmailVerifyTokenValidity');\n      user.setPassword('expiringToken');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      request({\n        url: sendEmailOptions.link,\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        Parse.User.logIn('testEmailVerifyTokenValidity', 'expiringToken').then(user => {\n          expect(typeof user).toBe('object');\n          expect(user.get('emailVerified')).toBe(true);\n          user.set('email', 'newEmail@parse.com');\n          return user.save();\n        }).then(() => user.fetch()).then(user => {\n          expect(typeof user).toBe('object');\n          expect(user.get('email')).toBe('newEmail@parse.com');\n          expect(user.get('emailVerified')).toBe(false);\n          request({\n            url: sendEmailOptions.link,\n            followRedirects: false\n          }).then(response => {\n            expect(response.status).toEqual(302);\n            done();\n          });\n        }).catch(error => {\n          jfail(error);\n          done();\n        });\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"EmailVerificationToken.spec.js","skipped":false,"dir":"spec"},{"name":"should call the default handler in case of error, like updating a non existing object","suites":["Enable express error handler"],"line":3,"updatePoint":{"line":3,"column":91,"index":184},"code":"  it('should call the default handler in case of error, like updating a non existing object', async done => {\n    spyOn(console, 'error');\n    const parseServer = await reconfigureServer(Object.assign({}, defaultConfiguration, {\n      enableExpressErrorHandler: true\n    }));\n    parseServer.app.use(function (err, req, res, next) {\n      expect(err.message).toBe('Object not found.');\n      next(err);\n    });\n    try {\n      await request({\n        method: 'PUT',\n        url: defaultConfiguration.serverURL + '/classes/AnyClass/nonExistingId',\n        headers: {\n          'X-Parse-Application-Id': defaultConfiguration.appId,\n          'X-Parse-Master-Key': defaultConfiguration.masterKey,\n          'Content-Type': 'application/json'\n        },\n        body: {\n          someField: 'blablabla'\n        }\n      });\n      fail('Should throw error');\n    } catch (response) {\n      expect(response).toBeDefined();\n      expect(response.status).toEqual(500);\n      parseServer.server.close(done);\n    }\n  });","file":"EnableExpressErrorHandler.spec.js","skipped":false,"dir":"spec"},{"name":"can publish and subscribe","suites":["EventEmitterPubSub"],"line":3,"updatePoint":{"line":3,"column":31,"index":177},"code":"  it('can publish and subscribe', function () {\n    const publisher = EventEmitterPubSub.createPublisher();\n    const subscriber = EventEmitterPubSub.createSubscriber();\n    subscriber.subscribe('testChannel');\n    // Register mock checked for subscriber\n    let isChecked = false;\n    subscriber.on('message', function (channel, message) {\n      isChecked = true;\n      expect(channel).toBe('testChannel');\n      expect(message).toBe('testMessage');\n    });\n    publisher.publish('testChannel', 'testMessage');\n    // Make sure the callback is checked\n    expect(isChecked).toBe(true);\n  });","file":"EventEmitterPubSub.spec.js","skipped":false,"dir":"spec"},{"name":"can unsubscribe","suites":["EventEmitterPubSub"],"line":18,"updatePoint":{"line":18,"column":21,"index":760},"code":"  it('can unsubscribe', function () {\n    const publisher = EventEmitterPubSub.createPublisher();\n    const subscriber = EventEmitterPubSub.createSubscriber();\n    subscriber.subscribe('testChannel');\n    subscriber.unsubscribe('testChannel');\n    // Register mock checked for subscriber\n    let isCalled = false;\n    subscriber.on('message', function () {\n      isCalled = true;\n    });\n    publisher.publish('testChannel', 'testMessage');\n    // Make sure the callback is not called\n    expect(isCalled).toBe(false);\n  });","file":"EventEmitterPubSub.spec.js","skipped":false,"dir":"spec"},{"name":"can unsubscribe not subscribing channel","suites":["EventEmitterPubSub"],"line":32,"updatePoint":{"line":32,"column":45,"index":1309},"code":"  it('can unsubscribe not subscribing channel', function () {\n    const subscriber = EventEmitterPubSub.createSubscriber();\n\n    // Make sure subscriber does not throw exception\n    subscriber.unsubscribe('testChannel');\n  });","file":"EventEmitterPubSub.spec.js","skipped":false,"dir":"spec"},{"name":"should return the serverInfo","suites":["features"],"line":5,"updatePoint":{"line":5,"column":34,"index":122},"code":"  it('should return the serverInfo', async () => {\n    const response = await request({\n      url: 'http://localhost:8378/1/serverInfo',\n      json: true,\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Master-Key': 'test'\n      }\n    });\n    const data = response.data;\n    expect(data).toBeDefined();\n    expect(data.features).toBeDefined();\n    expect(data.parseServerVersion).toBeDefined();\n  });","file":"features.spec.js","skipped":false,"dir":"spec"},{"name":"requires the master key to get features","suites":["features"],"line":20,"updatePoint":{"line":20,"column":45,"index":602},"code":"  it('requires the master key to get features', async done => {\n    try {\n      await request({\n        url: 'http://localhost:8378/1/serverInfo',\n        json: true,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest'\n        }\n      });\n      done.fail('The serverInfo request should be rejected without the master key');\n    } catch (error) {\n      expect(error.status).toEqual(403);\n      expect(error.data.error).toEqual('unauthorized: master key is required');\n      done();\n    }\n  });","file":"features.spec.js","skipped":false,"dir":"spec"},{"name":"should properly expand objects","suites":["FilesController"],"line":21,"updatePoint":{"line":21,"column":36,"index":843},"code":"  it('should properly expand objects', done => {\n    const config = Config.get(Parse.applicationId);\n    const gridFSAdapter = new GridFSBucketAdapter('mongodb://localhost:27017/parse');\n    const filesController = new FilesController(gridFSAdapter);\n    const result = filesController.expandFilesInObject(config, function () {});\n    expect(result).toBeUndefined();\n    const fullFile = {\n      type: '__type',\n      url: 'http://an.url'\n    };\n    const anObject = {\n      aFile: fullFile\n    };\n    filesController.expandFilesInObject(config, anObject);\n    expect(anObject.aFile.url).toEqual('http://an.url');\n    done();\n  });","file":"FilesController.spec.js","skipped":false,"dir":"spec"},{"name":"should create a server log on failure","suites":["FilesController"],"line":51,"updatePoint":{"line":51,"column":43,"index":1991},"code":"  it('should create a server log on failure', done => {\n    const logController = new LoggerController(new WinstonLoggerAdapter());\n    reconfigureServer({\n      filesAdapter: mockAdapter\n    }).then(() => new Parse.File('yolo.txt', [1, 2, 3], 'text/plain').save()).then(() => done.fail('should not succeed'), () => setImmediate(() => Promise.resolve('done'))).then(() => new Promise(resolve => setTimeout(resolve, 200))).then(() => logController.getLogs({\n      from: Date.now() - 1000,\n      size: 1000\n    })).then(logs => {\n      // we get two logs here: 1. the source of the failure to save the file\n      // and 2 the message that will be sent back to the client.\n\n      const log1 = logs.find(x => x.message === 'Error creating a file:  it failed with xyz');\n      expect(log1.level).toBe('error');\n      const log2 = logs.find(x => x.message === 'it failed with xyz');\n      expect(log2.level).toBe('error');\n      expect(log2.code).toBe(130);\n      done();\n    });\n  });","file":"FilesController.spec.js","skipped":false,"dir":"spec"},{"name":"should create a parse error when a string is returned","suites":["FilesController"],"line":70,"updatePoint":{"line":70,"column":59,"index":2987},"code":"  it('should create a parse error when a string is returned', done => {\n    const mock2 = mockAdapter;\n    mock2.validateFilename = () => {\n      return 'Bad file! No biscuit!';\n    };\n    const filesController = new FilesController(mockAdapter);\n    const error = filesController.validateFilename();\n    expect(typeof error).toBe('object');\n    expect(error.message.indexOf('biscuit')).toBe(13);\n    expect(error.code).toBe(Parse.Error.INVALID_FILE_NAME);\n    mockAdapter.validateFilename = () => {\n      return null;\n    };\n    done();\n  });","file":"FilesController.spec.js","skipped":false,"dir":"spec"},{"name":"should add a unique hash to the file name when the preserveFileName option is false","suites":["FilesController"],"line":85,"updatePoint":{"line":85,"column":89,"index":3561},"code":"  it('should add a unique hash to the file name when the preserveFileName option is false', done => {\n    const config = Config.get(Parse.applicationId);\n    const gridFSAdapter = new GridFSBucketAdapter('mongodb://localhost:27017/parse');\n    spyOn(gridFSAdapter, 'createFile');\n    gridFSAdapter.createFile.and.returnValue(Promise.resolve());\n    const fileName = 'randomFileName.pdf';\n    const regexEscapedFileName = fileName.replace(/\\./g, '\\\\$&');\n    const filesController = new FilesController(gridFSAdapter, null, {\n      preserveFileName: false\n    });\n    filesController.createFile(config, fileName);\n    expect(gridFSAdapter.createFile).toHaveBeenCalledTimes(1);\n    expect(gridFSAdapter.createFile.calls.mostRecent().args[0]).toMatch(`^.{32}_${regexEscapedFileName}$`);\n    done();\n  });","file":"FilesController.spec.js","skipped":false,"dir":"spec"},{"name":"should not add a unique hash to the file name when the preserveFileName option is true","suites":["FilesController"],"line":100,"updatePoint":{"line":100,"column":92,"index":4366},"code":"  it('should not add a unique hash to the file name when the preserveFileName option is true', done => {\n    const config = Config.get(Parse.applicationId);\n    const gridFSAdapter = new GridFSBucketAdapter('mongodb://localhost:27017/parse');\n    spyOn(gridFSAdapter, 'createFile');\n    gridFSAdapter.createFile.and.returnValue(Promise.resolve());\n    const fileName = 'randomFileName.pdf';\n    const filesController = new FilesController(gridFSAdapter, null, {\n      preserveFileName: true\n    });\n    filesController.createFile(config, fileName);\n    expect(gridFSAdapter.createFile).toHaveBeenCalledTimes(1);\n    expect(gridFSAdapter.createFile.calls.mostRecent().args[0]).toEqual(fileName);\n    done();\n  });","file":"FilesController.spec.js","skipped":false,"dir":"spec"},{"name":"should handle adapter without getMetadata","suites":["FilesController"],"line":114,"updatePoint":{"line":114,"column":47,"index":5034},"code":"  it('should handle adapter without getMetadata', async () => {\n    const gridFSAdapter = new GridFSBucketAdapter(databaseURI);\n    gridFSAdapter.getMetadata = null;\n    const filesController = new FilesController(gridFSAdapter);\n    const result = await filesController.getMetadata();\n    expect(result).toEqual({});\n  });","file":"FilesController.spec.js","skipped":false,"dir":"spec"},{"name":"should reject slashes in file names","suites":["FilesController"],"line":121,"updatePoint":{"line":121,"column":41,"index":5352},"code":"  it('should reject slashes in file names', done => {\n    const gridFSAdapter = new GridFSBucketAdapter('mongodb://localhost:27017/parse');\n    const fileName = 'foo/randomFileName.pdf';\n    expect(gridFSAdapter.validateFilename(fileName)).not.toBe(null);\n    done();\n  });","file":"FilesController.spec.js","skipped":false,"dir":"spec"},{"name":"should also reject slashes in file names","suites":["FilesController"],"line":127,"updatePoint":{"line":127,"column":46,"index":5631},"code":"  it('should also reject slashes in file names', done => {\n    const gridFSAdapter = new GridFSBucketAdapter('mongodb://localhost:27017/parse');\n    const fileName = 'foo/randomFileName.pdf';\n    expect(gridFSAdapter.validateFilename(fileName)).not.toBe(null);\n    done();\n  });","file":"FilesController.spec.js","skipped":false,"dir":"spec"},{"name":"should save an encrypted file that can only be decrypted by a GridFS adapter with the encryptionKey","suites":[],"line":21,"updatePoint":{"line":21,"column":105,"index":812},"code":"  it('should save an encrypted file that can only be decrypted by a GridFS adapter with the encryptionKey', async () => {\n    const unencryptedAdapter = new GridFSBucketAdapter(databaseURI);\n    const encryptedAdapter = new GridFSBucketAdapter(databaseURI, {}, '89E4AFF1-DFE4-4603-9574-BFA16BB446FD');\n    await expectMissingFile(encryptedAdapter, 'myFileName');\n    const originalString = 'abcdefghi';\n    await encryptedAdapter.createFile('myFileName', originalString);\n    const unencryptedResult = await unencryptedAdapter.getFileData('myFileName');\n    expect(unencryptedResult.toString('utf8')).not.toBe(originalString);\n    const encryptedResult = await encryptedAdapter.getFileData('myFileName');\n    expect(encryptedResult.toString('utf8')).toBe(originalString);\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should rotate key of all unencrypted GridFS files to encrypted files","suites":[],"line":32,"updatePoint":{"line":32,"column":74,"index":1559},"code":"  it('should rotate key of all unencrypted GridFS files to encrypted files', async () => {\n    const unencryptedAdapter = new GridFSBucketAdapter(databaseURI);\n    const encryptedAdapter = new GridFSBucketAdapter(databaseURI, {}, '89E4AFF1-DFE4-4603-9574-BFA16BB446FD');\n    const fileName1 = 'file1.txt';\n    const data1 = 'hello world';\n    const fileName2 = 'file2.txt';\n    const data2 = 'hello new world';\n    //Store unecrypted files\n    await unencryptedAdapter.createFile(fileName1, data1);\n    const unencryptedResult1 = await unencryptedAdapter.getFileData(fileName1);\n    expect(unencryptedResult1.toString('utf8')).toBe(data1);\n    await unencryptedAdapter.createFile(fileName2, data2);\n    const unencryptedResult2 = await unencryptedAdapter.getFileData(fileName2);\n    expect(unencryptedResult2.toString('utf8')).toBe(data2);\n    //Check if encrypted adapter can read data and make sure it's not the same as unEncrypted adapter\n    const {\n      rotated,\n      notRotated\n    } = await encryptedAdapter.rotateEncryptionKey();\n    expect(rotated.length).toEqual(2);\n    expect(rotated.filter(function (value) {\n      return value === fileName1;\n    }).length).toEqual(1);\n    expect(rotated.filter(function (value) {\n      return value === fileName2;\n    }).length).toEqual(1);\n    expect(notRotated.length).toEqual(0);\n    let result = await encryptedAdapter.getFileData(fileName1);\n    expect(result instanceof Buffer).toBe(true);\n    expect(result.toString('utf-8')).toEqual(data1);\n    const encryptedData1 = await unencryptedAdapter.getFileData(fileName1);\n    expect(encryptedData1.toString('utf-8')).not.toEqual(unencryptedResult1);\n    result = await encryptedAdapter.getFileData(fileName2);\n    expect(result instanceof Buffer).toBe(true);\n    expect(result.toString('utf-8')).toEqual(data2);\n    const encryptedData2 = await unencryptedAdapter.getFileData(fileName2);\n    expect(encryptedData2.toString('utf-8')).not.toEqual(unencryptedResult2);\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should rotate key of all old encrypted GridFS files to encrypted files","suites":[],"line":70,"updatePoint":{"line":70,"column":76,"index":3536},"code":"  it('should rotate key of all old encrypted GridFS files to encrypted files', async () => {\n    const oldEncryptionKey = 'oldKeyThatILoved';\n    const oldEncryptedAdapter = new GridFSBucketAdapter(databaseURI, {}, oldEncryptionKey);\n    const encryptedAdapter = new GridFSBucketAdapter(databaseURI, {}, 'newKeyThatILove');\n    const fileName1 = 'file1.txt';\n    const data1 = 'hello world';\n    const fileName2 = 'file2.txt';\n    const data2 = 'hello new world';\n    //Store unecrypted files\n    await oldEncryptedAdapter.createFile(fileName1, data1);\n    const oldEncryptedResult1 = await oldEncryptedAdapter.getFileData(fileName1);\n    expect(oldEncryptedResult1.toString('utf8')).toBe(data1);\n    await oldEncryptedAdapter.createFile(fileName2, data2);\n    const oldEncryptedResult2 = await oldEncryptedAdapter.getFileData(fileName2);\n    expect(oldEncryptedResult2.toString('utf8')).toBe(data2);\n    //Check if encrypted adapter can read data and make sure it's not the same as unEncrypted adapter\n    const {\n      rotated,\n      notRotated\n    } = await encryptedAdapter.rotateEncryptionKey({\n      oldKey: oldEncryptionKey\n    });\n    expect(rotated.length).toEqual(2);\n    expect(rotated.filter(function (value) {\n      return value === fileName1;\n    }).length).toEqual(1);\n    expect(rotated.filter(function (value) {\n      return value === fileName2;\n    }).length).toEqual(1);\n    expect(notRotated.length).toEqual(0);\n    let result = await encryptedAdapter.getFileData(fileName1);\n    expect(result instanceof Buffer).toBe(true);\n    expect(result.toString('utf-8')).toEqual(data1);\n    let decryptionError1;\n    let encryptedData1;\n    try {\n      encryptedData1 = await oldEncryptedAdapter.getFileData(fileName1);\n    } catch (err) {\n      decryptionError1 = err;\n    }\n    expect(decryptionError1).toMatch('Error');\n    expect(encryptedData1).toBeUndefined();\n    result = await encryptedAdapter.getFileData(fileName2);\n    expect(result instanceof Buffer).toBe(true);\n    expect(result.toString('utf-8')).toEqual(data2);\n    let decryptionError2;\n    let encryptedData2;\n    try {\n      encryptedData2 = await oldEncryptedAdapter.getFileData(fileName2);\n    } catch (err) {\n      decryptionError2 = err;\n    }\n    expect(decryptionError2).toMatch('Error');\n    expect(encryptedData2).toBeUndefined();\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should rotate key of all old encrypted GridFS files to unencrypted files","suites":[],"line":125,"updatePoint":{"line":125,"column":78,"index":5864},"code":"  it('should rotate key of all old encrypted GridFS files to unencrypted files', async () => {\n    const oldEncryptionKey = 'oldKeyThatILoved';\n    const oldEncryptedAdapter = new GridFSBucketAdapter(databaseURI, {}, oldEncryptionKey);\n    const unEncryptedAdapter = new GridFSBucketAdapter(databaseURI);\n    const fileName1 = 'file1.txt';\n    const data1 = 'hello world';\n    const fileName2 = 'file2.txt';\n    const data2 = 'hello new world';\n    //Store unecrypted files\n    await oldEncryptedAdapter.createFile(fileName1, data1);\n    const oldEncryptedResult1 = await oldEncryptedAdapter.getFileData(fileName1);\n    expect(oldEncryptedResult1.toString('utf8')).toBe(data1);\n    await oldEncryptedAdapter.createFile(fileName2, data2);\n    const oldEncryptedResult2 = await oldEncryptedAdapter.getFileData(fileName2);\n    expect(oldEncryptedResult2.toString('utf8')).toBe(data2);\n    //Check if unEncrypted adapter can read data and make sure it's not the same as oldEncrypted adapter\n    const {\n      rotated,\n      notRotated\n    } = await unEncryptedAdapter.rotateEncryptionKey({\n      oldKey: oldEncryptionKey\n    });\n    expect(rotated.length).toEqual(2);\n    expect(rotated.filter(function (value) {\n      return value === fileName1;\n    }).length).toEqual(1);\n    expect(rotated.filter(function (value) {\n      return value === fileName2;\n    }).length).toEqual(1);\n    expect(notRotated.length).toEqual(0);\n    let result = await unEncryptedAdapter.getFileData(fileName1);\n    expect(result instanceof Buffer).toBe(true);\n    expect(result.toString('utf-8')).toEqual(data1);\n    let decryptionError1;\n    let encryptedData1;\n    try {\n      encryptedData1 = await oldEncryptedAdapter.getFileData(fileName1);\n    } catch (err) {\n      decryptionError1 = err;\n    }\n    expect(decryptionError1).toMatch('Error');\n    expect(encryptedData1).toBeUndefined();\n    result = await unEncryptedAdapter.getFileData(fileName2);\n    expect(result instanceof Buffer).toBe(true);\n    expect(result.toString('utf-8')).toEqual(data2);\n    let decryptionError2;\n    let encryptedData2;\n    try {\n      encryptedData2 = await oldEncryptedAdapter.getFileData(fileName2);\n    } catch (err) {\n      decryptionError2 = err;\n    }\n    expect(decryptionError2).toMatch('Error');\n    expect(encryptedData2).toBeUndefined();\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should only encrypt specified fileNames","suites":[],"line":180,"updatePoint":{"line":180,"column":45,"index":8147},"code":"  it('should only encrypt specified fileNames', async () => {\n    const oldEncryptionKey = 'oldKeyThatILoved';\n    const oldEncryptedAdapter = new GridFSBucketAdapter(databaseURI, {}, oldEncryptionKey);\n    const encryptedAdapter = new GridFSBucketAdapter(databaseURI, {}, 'newKeyThatILove');\n    const unEncryptedAdapter = new GridFSBucketAdapter(databaseURI);\n    const fileName1 = 'file1.txt';\n    const data1 = 'hello world';\n    const fileName2 = 'file2.txt';\n    const data2 = 'hello new world';\n    //Store unecrypted files\n    await oldEncryptedAdapter.createFile(fileName1, data1);\n    const oldEncryptedResult1 = await oldEncryptedAdapter.getFileData(fileName1);\n    expect(oldEncryptedResult1.toString('utf8')).toBe(data1);\n    await oldEncryptedAdapter.createFile(fileName2, data2);\n    const oldEncryptedResult2 = await oldEncryptedAdapter.getFileData(fileName2);\n    expect(oldEncryptedResult2.toString('utf8')).toBe(data2);\n    //Inject unecrypted file to see if causes an issue\n    const fileName3 = 'file3.txt';\n    const data3 = 'hello past world';\n    await unEncryptedAdapter.createFile(fileName3, data3, 'text/utf8');\n    //Check if encrypted adapter can read data and make sure it's not the same as unEncrypted adapter\n    const {\n      rotated,\n      notRotated\n    } = await encryptedAdapter.rotateEncryptionKey({\n      oldKey: oldEncryptionKey,\n      fileNames: [fileName1, fileName2]\n    });\n    expect(rotated.length).toEqual(2);\n    expect(rotated.filter(function (value) {\n      return value === fileName1;\n    }).length).toEqual(1);\n    expect(rotated.filter(function (value) {\n      return value === fileName2;\n    }).length).toEqual(1);\n    expect(notRotated.length).toEqual(0);\n    expect(rotated.filter(function (value) {\n      return value === fileName3;\n    }).length).toEqual(0);\n    let result = await encryptedAdapter.getFileData(fileName1);\n    expect(result instanceof Buffer).toBe(true);\n    expect(result.toString('utf-8')).toEqual(data1);\n    let decryptionError1;\n    let encryptedData1;\n    try {\n      encryptedData1 = await oldEncryptedAdapter.getFileData(fileName1);\n    } catch (err) {\n      decryptionError1 = err;\n    }\n    expect(decryptionError1).toMatch('Error');\n    expect(encryptedData1).toBeUndefined();\n    result = await encryptedAdapter.getFileData(fileName2);\n    expect(result instanceof Buffer).toBe(true);\n    expect(result.toString('utf-8')).toEqual(data2);\n    let decryptionError2;\n    let encryptedData2;\n    try {\n      encryptedData2 = await oldEncryptedAdapter.getFileData(fileName2);\n    } catch (err) {\n      decryptionError2 = err;\n    }\n    expect(decryptionError2).toMatch('Error');\n    expect(encryptedData2).toBeUndefined();\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should return fileNames of those it can't encrypt with the new key","suites":[],"line":244,"updatePoint":{"line":244,"column":72,"index":10885},"code":"  it(\"should return fileNames of those it can't encrypt with the new key\", async () => {\n    const oldEncryptionKey = 'oldKeyThatILoved';\n    const oldEncryptedAdapter = new GridFSBucketAdapter(databaseURI, {}, oldEncryptionKey);\n    const encryptedAdapter = new GridFSBucketAdapter(databaseURI, {}, 'newKeyThatILove');\n    const unEncryptedAdapter = new GridFSBucketAdapter(databaseURI);\n    const fileName1 = 'file1.txt';\n    const data1 = 'hello world';\n    const fileName2 = 'file2.txt';\n    const data2 = 'hello new world';\n    //Store unecrypted files\n    await oldEncryptedAdapter.createFile(fileName1, data1);\n    const oldEncryptedResult1 = await oldEncryptedAdapter.getFileData(fileName1);\n    expect(oldEncryptedResult1.toString('utf8')).toBe(data1);\n    await oldEncryptedAdapter.createFile(fileName2, data2);\n    const oldEncryptedResult2 = await oldEncryptedAdapter.getFileData(fileName2);\n    expect(oldEncryptedResult2.toString('utf8')).toBe(data2);\n    //Inject unecrypted file to see if causes an issue\n    const fileName3 = 'file3.txt';\n    const data3 = 'hello past world';\n    await unEncryptedAdapter.createFile(fileName3, data3, 'text/utf8');\n    //Check if encrypted adapter can read data and make sure it's not the same as unEncrypted adapter\n    const {\n      rotated,\n      notRotated\n    } = await encryptedAdapter.rotateEncryptionKey({\n      oldKey: oldEncryptionKey\n    });\n    expect(rotated.length).toEqual(2);\n    expect(rotated.filter(function (value) {\n      return value === fileName1;\n    }).length).toEqual(1);\n    expect(rotated.filter(function (value) {\n      return value === fileName2;\n    }).length).toEqual(1);\n    expect(notRotated.length).toEqual(1);\n    expect(notRotated.filter(function (value) {\n      return value === fileName3;\n    }).length).toEqual(1);\n    let result = await encryptedAdapter.getFileData(fileName1);\n    expect(result instanceof Buffer).toBe(true);\n    expect(result.toString('utf-8')).toEqual(data1);\n    let decryptionError1;\n    let encryptedData1;\n    try {\n      encryptedData1 = await oldEncryptedAdapter.getFileData(fileName1);\n    } catch (err) {\n      decryptionError1 = err;\n    }\n    expect(decryptionError1).toMatch('Error');\n    expect(encryptedData1).toBeUndefined();\n    result = await encryptedAdapter.getFileData(fileName2);\n    expect(result instanceof Buffer).toBe(true);\n    expect(result.toString('utf-8')).toEqual(data2);\n    let decryptionError2;\n    let encryptedData2;\n    try {\n      encryptedData2 = await oldEncryptedAdapter.getFileData(fileName2);\n    } catch (err) {\n      decryptionError2 = err;\n    }\n    expect(decryptionError2).toMatch('Error');\n    expect(encryptedData2).toBeUndefined();\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should save metadata","suites":[],"line":307,"updatePoint":{"line":307,"column":26,"index":13539},"code":"  it('should save metadata', async () => {\n    const gfsAdapter = new GridFSBucketAdapter(databaseURI);\n    const originalString = 'abcdefghi';\n    const metadata = {\n      hello: 'world'\n    };\n    await gfsAdapter.createFile('myFileName', originalString, null, {\n      metadata\n    });\n    const gfsResult = await gfsAdapter.getFileData('myFileName');\n    expect(gfsResult.toString('utf8')).toBe(originalString);\n    let gfsMetadata = await gfsAdapter.getMetadata('myFileName');\n    expect(gfsMetadata.metadata).toEqual(metadata);\n\n    // Empty json for file not found\n    gfsMetadata = await gfsAdapter.getMetadata('myUnknownFile');\n    expect(gfsMetadata).toEqual({});\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should save metadata with file","suites":[],"line":325,"updatePoint":{"line":325,"column":36,"index":14228},"code":"  it('should save metadata with file', async () => {\n    const gfsAdapter = new GridFSBucketAdapter(databaseURI);\n    await reconfigureServer({\n      filesAdapter: gfsAdapter\n    });\n    const str = 'Hello World!';\n    const data = [];\n    for (let i = 0; i < str.length; i++) {\n      data.push(str.charCodeAt(i));\n    }\n    const metadata = {\n      foo: 'bar'\n    };\n    const file = new Parse.File('hello.txt', data, 'text/plain');\n    file.addMetadata('foo', 'bar');\n    await file.save();\n    let fileData = await gfsAdapter.getMetadata(file.name());\n    expect(fileData.metadata).toEqual(metadata);\n\n    // Can only add metadata on create\n    file.addMetadata('hello', 'world');\n    await file.save();\n    fileData = await gfsAdapter.getMetadata(file.name());\n    expect(fileData.metadata).toEqual(metadata);\n    const headers = {\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest'\n    };\n    const response = await request({\n      method: 'GET',\n      headers,\n      url: `http://localhost:8378/1/files/test/metadata/${file.name()}`\n    });\n    fileData = response.data;\n    expect(fileData.metadata).toEqual(metadata);\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should handle getMetadata error","suites":[],"line":361,"updatePoint":{"line":361,"column":37,"index":15387},"code":"  it('should handle getMetadata error', async () => {\n    const gfsAdapter = new GridFSBucketAdapter(databaseURI);\n    await reconfigureServer({\n      filesAdapter: gfsAdapter\n    });\n    gfsAdapter.getMetadata = () => Promise.reject();\n    const headers = {\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest'\n    };\n    const response = await request({\n      method: 'GET',\n      headers,\n      url: `http://localhost:8378/1/files/test/metadata/filename.txt`\n    });\n    expect(response.data).toEqual({});\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"properly fetches a large file from GridFS","suites":[],"line":378,"updatePoint":{"line":378,"column":47,"index":15936},"code":"  it('properly fetches a large file from GridFS', async () => {\n    const gfsAdapter = new GridFSBucketAdapter(databaseURI);\n    const twoMegabytesFile = randomString(2048 * 1024);\n    await gfsAdapter.createFile('myFileName', twoMegabytesFile);\n    const gfsResult = await gfsAdapter.getFileData('myFileName');\n    expect(gfsResult.toString('utf8')).toBe(twoMegabytesFile);\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"properly deletes a file from GridFS","suites":[],"line":385,"updatePoint":{"line":385,"column":41,"index":16311},"code":"  it('properly deletes a file from GridFS', async () => {\n    const gfsAdapter = new GridFSBucketAdapter(databaseURI);\n    await gfsAdapter.createFile('myFileName', 'a simple file');\n    await gfsAdapter.deleteFile('myFileName');\n    await expectMissingFile(gfsAdapter, 'myFileName');\n  }, 1000000);","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"properly overrides files","suites":[],"line":391,"updatePoint":{"line":391,"column":30,"index":16600},"code":"  it('properly overrides files', async () => {\n    const gfsAdapter = new GridFSBucketAdapter(databaseURI);\n    await gfsAdapter.createFile('myFileName', 'a simple file');\n    await gfsAdapter.createFile('myFileName', 'an overrided simple file');\n    const data = await gfsAdapter.getFileData('myFileName');\n    expect(data.toString('utf8')).toBe('an overrided simple file');\n    const bucket = await gfsAdapter._getBucket();\n    const documents = await bucket.find({\n      filename: 'myFileName'\n    }).toArray();\n    expect(documents.length).toBe(2);\n    await gfsAdapter.deleteFile('myFileName');\n    await expectMissingFile(gfsAdapter, 'myFileName');\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"handleShutdown, close connection","suites":[],"line":405,"updatePoint":{"line":405,"column":38,"index":17269},"code":"  it('handleShutdown, close connection', async () => {\n    const databaseURI = 'mongodb://localhost:27017/parse';\n    const gfsAdapter = new GridFSBucketAdapter(databaseURI);\n    const db = await gfsAdapter._connect();\n    const status = await db.admin().serverStatus();\n    expect(status.connections.current > 0).toEqual(true);\n    await gfsAdapter.handleShutdown();\n    try {\n      await db.admin().serverStatus();\n      expect(false).toBe(true);\n    } catch (e) {\n      expect(e.message).toEqual('Client must be connected before running operations');\n    }\n  });","file":"GridFSBucketStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should do /hello","suites":["httpRequest"],"line":48,"updatePoint":{"line":48,"column":22,"index":1109},"code":"  it('should do /hello', async () => {\n    const httpResponse = await httpRequest({\n      url: `${httpRequestServer}/hello`\n    });\n    expect(httpResponse.status).toBe(200);\n    expect(httpResponse.buffer).toEqual(Buffer.from('{\"response\":\"OK\"}'));\n    expect(httpResponse.text).toEqual('{\"response\":\"OK\"}');\n    expect(httpResponse.data.response).toEqual('OK');\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should do not follow redirects by default","suites":["httpRequest"],"line":57,"updatePoint":{"line":57,"column":47,"index":1504},"code":"  it('should do not follow redirects by default', async () => {\n    const httpResponse = await httpRequest({\n      url: `${httpRequestServer}/301`\n    });\n    expect(httpResponse.status).toBe(301);\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should follow redirects when set","suites":["httpRequest"],"line":63,"updatePoint":{"line":63,"column":38,"index":1699},"code":"  it('should follow redirects when set', async () => {\n    const httpResponse = await httpRequest({\n      url: `${httpRequestServer}/301`,\n      followRedirects: true\n    });\n    expect(httpResponse.status).toBe(200);\n    expect(httpResponse.buffer).toEqual(Buffer.from('{\"response\":\"OK\"}'));\n    expect(httpResponse.text).toEqual('{\"response\":\"OK\"}');\n    expect(httpResponse.data.response).toEqual('OK');\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should fail on 404","suites":["httpRequest"],"line":73,"updatePoint":{"line":73,"column":24,"index":2098},"code":"  it('should fail on 404', async () => {\n    await expectAsync(httpRequest({\n      url: `${httpRequestServer}/404`\n    })).toBeRejectedWith(jasmine.objectContaining({\n      status: 404,\n      buffer: Buffer.from('NO'),\n      text: 'NO',\n      data: undefined\n    }));\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should post on echo","suites":["httpRequest"],"line":83,"updatePoint":{"line":83,"column":25,"index":2373},"code":"  it('should post on echo', async () => {\n    const httpResponse = await httpRequest({\n      method: 'POST',\n      url: `${httpRequestServer}/echo`,\n      body: {\n        foo: 'bar'\n      },\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n    expect(httpResponse.status).toBe(200);\n    expect(httpResponse.data).toEqual({\n      foo: 'bar'\n    });\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should encode a query string body by default","suites":["httpRequest"],"line":99,"updatePoint":{"line":99,"column":50,"index":2779},"code":"  it('should encode a query string body by default', () => {\n    const options = {\n      body: {\n        foo: 'bar'\n      }\n    };\n    const result = httpRequest.encodeBody(options);\n    expect(result.body).toEqual('foo=bar');\n    expect(result.headers['Content-Type']).toEqual('application/x-www-form-urlencoded');\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should encode a JSON body","suites":["httpRequest"],"line":109,"updatePoint":{"line":109,"column":31,"index":3082},"code":"  it('should encode a JSON body', () => {\n    const options = {\n      body: {\n        foo: 'bar'\n      },\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    };\n    const result = httpRequest.encodeBody(options);\n    expect(result.body).toEqual('{\"foo\":\"bar\"}');\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should encode a www-form body","suites":["httpRequest"],"line":121,"updatePoint":{"line":121,"column":35,"index":3375},"code":"  it('should encode a www-form body', () => {\n    const options = {\n      body: {\n        foo: 'bar',\n        bar: 'baz'\n      },\n      headers: {\n        'cOntent-tYpe': 'application/x-www-form-urlencoded'\n      }\n    };\n    const result = httpRequest.encodeBody(options);\n    expect(result.body).toEqual('foo=bar&bar=baz');\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should not encode a wrong content type","suites":["httpRequest"],"line":134,"updatePoint":{"line":134,"column":44,"index":3716},"code":"  it('should not encode a wrong content type', () => {\n    const options = {\n      body: {\n        foo: 'bar',\n        bar: 'baz'\n      },\n      headers: {\n        'cOntent-tYpe': 'mime/jpeg'\n      }\n    };\n    const result = httpRequest.encodeBody(options);\n    expect(result.body).toEqual({\n      foo: 'bar',\n      bar: 'baz'\n    });\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should fail gracefully","suites":["httpRequest"],"line":150,"updatePoint":{"line":150,"column":28,"index":4042},"code":"  it('should fail gracefully', async () => {\n    await expectAsync(httpRequest({\n      url: 'http://not a good url'\n    })).toBeRejected();\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should params object to query string","suites":["httpRequest"],"line":155,"updatePoint":{"line":155,"column":42,"index":4202},"code":"  it('should params object to query string', async () => {\n    const httpResponse = await httpRequest({\n      url: `${httpRequestServer}/qs`,\n      params: {\n        foo: 'bar'\n      }\n    });\n    expect(httpResponse.status).toBe(200);\n    expect(httpResponse.data).toEqual({\n      foo: 'bar'\n    });\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should params string to query string","suites":["httpRequest"],"line":167,"updatePoint":{"line":167,"column":42,"index":4509},"code":"  it('should params string to query string', async () => {\n    const httpResponse = await httpRequest({\n      url: `${httpRequestServer}/qs`,\n      params: 'foo=bar&foo2=bar2'\n    });\n    expect(httpResponse.status).toBe(200);\n    expect(httpResponse.data).toEqual({\n      foo: 'bar',\n      foo2: 'bar2'\n    });\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should not crash with undefined body","suites":["httpRequest"],"line":178,"updatePoint":{"line":178,"column":42,"index":4827},"code":"  it('should not crash with undefined body', () => {\n    const httpResponse = new HTTPResponse({});\n    expect(httpResponse.body).toBeUndefined();\n    expect(httpResponse.data).toBeUndefined();\n    expect(httpResponse.text).toBeUndefined();\n    expect(httpResponse.buffer).toBeUndefined();\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"serialized httpResponse correctly with body string","suites":["httpRequest"],"line":185,"updatePoint":{"line":185,"column":56,"index":5137},"code":"  it('serialized httpResponse correctly with body string', () => {\n    const httpResponse = new HTTPResponse({}, 'hello');\n    expect(httpResponse.text).toBe('hello');\n    expect(httpResponse.data).toBe(undefined);\n    expect(httpResponse.body).toBe('hello');\n    const serialized = JSON.stringify(httpResponse);\n    const result = JSON.parse(serialized);\n    expect(result.text).toBe('hello');\n    expect(result.data).toBe(undefined);\n    expect(result.body).toBe(undefined);\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"serialized httpResponse correctly with body object","suites":["httpRequest"],"line":196,"updatePoint":{"line":196,"column":56,"index":5620},"code":"  it('serialized httpResponse correctly with body object', () => {\n    const httpResponse = new HTTPResponse({}, {\n      foo: 'bar'\n    });\n    Parse._encode(httpResponse);\n    const serialized = JSON.stringify(httpResponse);\n    const result = JSON.parse(serialized);\n    expect(httpResponse.text).toEqual('{\"foo\":\"bar\"}');\n    expect(httpResponse.data).toEqual({\n      foo: 'bar'\n    });\n    expect(httpResponse.body).toEqual({\n      foo: 'bar'\n    });\n    expect(result.text).toEqual('{\"foo\":\"bar\"}');\n    expect(result.data).toEqual({\n      foo: 'bar'\n    });\n    expect(result.body).toEqual(undefined);\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"serialized httpResponse correctly with body buffer string","suites":["httpRequest"],"line":216,"updatePoint":{"line":216,"column":63,"index":6241},"code":"  it('serialized httpResponse correctly with body buffer string', () => {\n    const httpResponse = new HTTPResponse({}, Buffer.from('hello'));\n    expect(httpResponse.text).toBe('hello');\n    expect(httpResponse.data).toBe(undefined);\n    const serialized = JSON.stringify(httpResponse);\n    const result = JSON.parse(serialized);\n    expect(result.text).toBe('hello');\n    expect(result.data).toBe(undefined);\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"serialized httpResponse correctly with body buffer JSON Object","suites":["httpRequest"],"line":225,"updatePoint":{"line":225,"column":68,"index":6663},"code":"  it('serialized httpResponse correctly with body buffer JSON Object', () => {\n    const json = '{\"foo\":\"bar\"}';\n    const httpResponse = new HTTPResponse({}, Buffer.from(json));\n    const serialized = JSON.stringify(httpResponse);\n    const result = JSON.parse(serialized);\n    expect(result.text).toEqual('{\"foo\":\"bar\"}');\n    expect(result.data).toEqual({\n      foo: 'bar'\n    });\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"serialized httpResponse with Parse._encode should be allright","suites":["httpRequest"],"line":235,"updatePoint":{"line":235,"column":67,"index":7052},"code":"  it('serialized httpResponse with Parse._encode should be allright', () => {\n    const json = '{\"foo\":\"bar\"}';\n    const httpResponse = new HTTPResponse({}, Buffer.from(json));\n    const encoded = Parse._encode(httpResponse);\n    let foundData,\n      foundText,\n      foundBody = false;\n    for (const key in encoded) {\n      if (key === 'data') {\n        foundData = true;\n      }\n      if (key === 'text') {\n        foundText = true;\n      }\n      if (key === 'body') {\n        foundBody = true;\n      }\n    }\n    expect(foundData).toBe(true);\n    expect(foundText).toBe(true);\n    expect(foundBody).toBe(false);\n  });","file":"HTTPRequest.spec.js","skipped":false,"dir":"spec"},{"name":"should enforce idempotency for cloud code function","suites":["Idempotency"],"line":50,"updatePoint":{"line":50,"column":56,"index":1569},"code":"  it('should enforce idempotency for cloud code function', async () => {\n    let counter = 0;\n    Parse.Cloud.define('myFunction', () => {\n      counter++;\n    });\n    const params = {\n      method: 'POST',\n      url: 'http://localhost:8378/1/functions/myFunction',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': Parse.masterKey,\n        'X-Parse-Request-Id': 'abc-123'\n      }\n    };\n    expect(Config.get(Parse.applicationId).idempotencyOptions.ttl).toBe(ttl);\n    await request(params);\n    await request(params).then(fail, e => {\n      expect(e.status).toEqual(400);\n      expect(e.data.error).toEqual('Duplicate request');\n    });\n    expect(counter).toBe(1);\n  });","file":"Idempotency.spec.js","skipped":false,"dir":"spec"},{"name":"should delete request entry after TTL","suites":["Idempotency"],"line":72,"updatePoint":{"line":72,"column":43,"index":2282},"code":"  it('should delete request entry after TTL', async () => {\n    let counter = 0;\n    Parse.Cloud.define('myFunction', () => {\n      counter++;\n    });\n    const params = {\n      method: 'POST',\n      url: 'http://localhost:8378/1/functions/myFunction',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': Parse.masterKey,\n        'X-Parse-Request-Id': 'abc-123'\n      }\n    };\n    await expectAsync(request(params)).toBeResolved();\n    if (SIMULATE_TTL) {\n      await deleteRequestEntry('abc-123');\n    } else {\n      await new Promise(resolve => setTimeout(resolve, maxTimeOut));\n    }\n    await expectAsync(request(params)).toBeResolved();\n    expect(counter).toBe(2);\n  });","file":"Idempotency.spec.js","skipped":false,"dir":"spec"},{"name":"should enforce idempotency for cloud code jobs","suites":["Idempotency"],"line":117,"updatePoint":{"line":117,"column":52,"index":3906},"code":"  it('should enforce idempotency for cloud code jobs', async () => {\n    let counter = 0;\n    Parse.Cloud.job('myJob', () => {\n      counter++;\n    });\n    const params = {\n      method: 'POST',\n      url: 'http://localhost:8378/1/jobs/myJob',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': Parse.masterKey,\n        'X-Parse-Request-Id': 'abc-123'\n      }\n    };\n    await expectAsync(request(params)).toBeResolved();\n    await request(params).then(fail, e => {\n      expect(e.status).toEqual(400);\n      expect(e.data.error).toEqual('Duplicate request');\n    });\n    expect(counter).toBe(1);\n  });","file":"Idempotency.spec.js","skipped":false,"dir":"spec"},{"name":"should enforce idempotency for class object creation","suites":["Idempotency"],"line":138,"updatePoint":{"line":138,"column":58,"index":4566},"code":"  it('should enforce idempotency for class object creation', async () => {\n    let counter = 0;\n    Parse.Cloud.afterSave('MyClass', () => {\n      counter++;\n    });\n    const params = {\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/MyClass',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': Parse.masterKey,\n        'X-Parse-Request-Id': 'abc-123'\n      }\n    };\n    await expectAsync(request(params)).toBeResolved();\n    await request(params).then(fail, e => {\n      expect(e.status).toEqual(400);\n      expect(e.data.error).toEqual('Duplicate request');\n    });\n    expect(counter).toBe(1);\n  });","file":"Idempotency.spec.js","skipped":false,"dir":"spec"},{"name":"should enforce idempotency for user object creation","suites":["Idempotency"],"line":159,"updatePoint":{"line":159,"column":57,"index":5238},"code":"  it('should enforce idempotency for user object creation', async () => {\n    let counter = 0;\n    Parse.Cloud.afterSave('_User', () => {\n      counter++;\n    });\n    const params = {\n      method: 'POST',\n      url: 'http://localhost:8378/1/users',\n      body: {\n        username: 'user',\n        password: 'pass'\n      },\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': Parse.masterKey,\n        'X-Parse-Request-Id': 'abc-123'\n      }\n    };\n    await expectAsync(request(params)).toBeResolved();\n    await request(params).then(fail, e => {\n      expect(e.status).toEqual(400);\n      expect(e.data.error).toEqual('Duplicate request');\n    });\n    expect(counter).toBe(1);\n  });","file":"Idempotency.spec.js","skipped":false,"dir":"spec"},{"name":"should enforce idempotency for installation object creation","suites":["Idempotency"],"line":184,"updatePoint":{"line":184,"column":65,"index":5980},"code":"  it('should enforce idempotency for installation object creation', async () => {\n    let counter = 0;\n    Parse.Cloud.afterSave('_Installation', () => {\n      counter++;\n    });\n    const params = {\n      method: 'POST',\n      url: 'http://localhost:8378/1/installations',\n      body: {\n        installationId: '1',\n        deviceType: 'ios'\n      },\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': Parse.masterKey,\n        'X-Parse-Request-Id': 'abc-123'\n      }\n    };\n    await expectAsync(request(params)).toBeResolved();\n    await request(params).then(fail, e => {\n      expect(e.status).toEqual(400);\n      expect(e.data.error).toEqual('Duplicate request');\n    });\n    expect(counter).toBe(1);\n  });","file":"Idempotency.spec.js","skipped":false,"dir":"spec"},{"name":"should not interfere with calls of different request ID","suites":["Idempotency"],"line":209,"updatePoint":{"line":209,"column":61,"index":6738},"code":"  it('should not interfere with calls of different request ID', async () => {\n    let counter = 0;\n    Parse.Cloud.afterSave('MyClass', () => {\n      counter++;\n    });\n    const promises = [...Array(100).keys()].map(() => {\n      const params = {\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/MyClass',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Master-Key': Parse.masterKey,\n          'X-Parse-Request-Id': uuid.v4()\n        }\n      };\n      return request(params);\n    });\n    await expectAsync(Promise.all(promises)).toBeResolved();\n    expect(counter).toBe(100);\n  });","file":"Idempotency.spec.js","skipped":false,"dir":"spec"},{"name":"should re-throw any other error unchanged when writing request entry fails for any other reason","suites":["Idempotency"],"line":229,"updatePoint":{"line":229,"column":101,"index":7428},"code":"  it('should re-throw any other error unchanged when writing request entry fails for any other reason', async () => {\n    spyOn(rest, 'create').and.rejectWith(new Parse.Error(0, 'some other error'));\n    Parse.Cloud.define('myFunction', () => {});\n    const params = {\n      method: 'POST',\n      url: 'http://localhost:8378/1/functions/myFunction',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': Parse.masterKey,\n        'X-Parse-Request-Id': 'abc-123'\n      }\n    };\n    await request(params).then(fail, e => {\n      expect(e.status).toEqual(400);\n      expect(e.data.error).toEqual('some other error');\n    });\n  });","file":"Idempotency.spec.js","skipped":false,"dir":"spec"},{"name":"should use default configuration when none is set","suites":["Idempotency"],"line":246,"updatePoint":{"line":246,"column":55,"index":8057},"code":"  it('should use default configuration when none is set', async () => {\n    await setup({});\n    expect(Config.get(Parse.applicationId).idempotencyOptions.ttl).toBe(Definitions.IdempotencyOptions.ttl.default);\n    expect(Config.get(Parse.applicationId).idempotencyOptions.paths).toBe(Definitions.IdempotencyOptions.paths.default);\n  });","file":"Idempotency.spec.js","skipped":false,"dir":"spec"},{"name":"should throw on invalid configuration","suites":["Idempotency"],"line":251,"updatePoint":{"line":251,"column":43,"index":8382},"code":"  it('should throw on invalid configuration', async () => {\n    await expectAsync(setup({\n      paths: 1\n    })).toBeRejected();\n    await expectAsync(setup({\n      ttl: 'a'\n    })).toBeRejected();\n    await expectAsync(setup({\n      ttl: 0\n    })).toBeRejected();\n    await expectAsync(setup({\n      ttl: -1\n    })).toBeRejected();\n  });","file":"Idempotency.spec.js","skipped":false,"dir":"spec"},{"name":"requires a master key and app id","suites":["server"],"line":11,"updatePoint":{"line":11,"column":38,"index":485},"code":"  it('requires a master key and app id', done => {\n    reconfigureServer({\n      appId: undefined\n    }).catch(error => {\n      expect(error).toEqual('You must provide an appId!');\n      return reconfigureServer({\n        masterKey: undefined\n      });\n    }).catch(error => {\n      expect(error).toEqual('You must provide a masterKey!');\n      return reconfigureServer({\n        serverURL: undefined\n      });\n    }).catch(error => {\n      expect(error).toEqual('You must provide a serverURL!');\n      done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"show warning if any reserved characters in appId","suites":["server"],"line":29,"updatePoint":{"line":29,"column":54,"index":1026},"code":"  it('show warning if any reserved characters in appId', done => {\n    spyOn(console, 'warn').and.callFake(() => {});\n    reconfigureServer({\n      appId: 'test!-^'\n    }).then(() => {\n      expect(console.warn).toHaveBeenCalled();\n      return done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"support http basic authentication with masterkey","suites":["server"],"line":38,"updatePoint":{"line":38,"column":54,"index":1293},"code":"  it('support http basic authentication with masterkey', done => {\n    reconfigureServer({\n      appId: 'test'\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/classes/TestObject',\n        headers: {\n          Authorization: 'Basic ' + Buffer.from('test:' + 'test').toString('base64')\n        }\n      }).then(response => {\n        expect(response.status).toEqual(200);\n        done();\n      });\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"support http basic authentication with javascriptKey","suites":["server"],"line":53,"updatePoint":{"line":53,"column":58,"index":1731},"code":"  it('support http basic authentication with javascriptKey', done => {\n    reconfigureServer({\n      appId: 'test'\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/classes/TestObject',\n        headers: {\n          Authorization: 'Basic ' + Buffer.from('test:javascript-key=' + 'test').toString('base64')\n        }\n      }).then(response => {\n        expect(response.status).toEqual(200);\n        done();\n      });\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"fails if database is unreachable","suites":["server"],"line":68,"updatePoint":{"line":68,"column":38,"index":2164},"code":"  it('fails if database is unreachable', done => {\n    reconfigureServer({\n      databaseAdapter: new MongoStorageAdapter({\n        uri: 'mongodb://fake:fake@localhost:43605/drew3',\n        mongoOptions: {\n          serverSelectionTimeoutMS: 2000\n        }\n      })\n    }).catch(() => {\n      const config = Config.get('test');\n      config.schemaCache.clear();\n      //Need to use rest api because saving via JS SDK results in fail() not getting called\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/NewClass',\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        body: {}\n      }).then(fail, response => {\n        expect(response.status).toEqual(500);\n        const body = response.data;\n        expect(body.code).toEqual(1);\n        expect(body.message).toEqual('Internal server error.');\n        reconfigureServer().then(done, done);\n      });\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can load email adapter via object","suites":["server","mail adapter"],"line":98,"updatePoint":{"line":98,"column":41,"index":3173},"code":"    it('can load email adapter via object', done => {\n      reconfigureServer({\n        appName: 'unused',\n        verifyUserEmails: true,\n        emailAdapter: MockEmailAdapterWithOptions({\n          fromAddress: 'parse@example.com',\n          apiKey: 'k',\n          domain: 'd'\n        }),\n        publicServerURL: 'http://localhost:8378/1'\n      }).then(done, fail);\n    });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can load email adapter via class","suites":["server","mail adapter"],"line":110,"updatePoint":{"line":110,"column":40,"index":3550},"code":"    it('can load email adapter via class', done => {\n      reconfigureServer({\n        appName: 'unused',\n        verifyUserEmails: true,\n        emailAdapter: {\n          class: MockEmailAdapterWithOptions,\n          options: {\n            fromAddress: 'parse@example.com',\n            apiKey: 'k',\n            domain: 'd'\n          }\n        },\n        publicServerURL: 'http://localhost:8378/1'\n      }).then(done, fail);\n    });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can load email adapter via module name","suites":["server","mail adapter"],"line":125,"updatePoint":{"line":125,"column":46,"index":3989},"code":"    it('can load email adapter via module name', async () => {\n      const options = {\n        appName: 'unused',\n        verifyUserEmails: true,\n        emailAdapter: {\n          module: 'mock-mail-adapter',\n          options: {}\n        },\n        publicServerURL: 'http://localhost:8378/1'\n      };\n      await reconfigureServer(options);\n      const config = Config.get('test');\n      const mailAdapter = config.userController.adapter;\n      expect(mailAdapter.sendMail).toBeDefined();\n    });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can load email adapter via only module name","suites":["server","mail adapter"],"line":140,"updatePoint":{"line":140,"column":51,"index":4492},"code":"    it('can load email adapter via only module name', async () => {\n      const options = {\n        appName: 'unused',\n        verifyUserEmails: true,\n        emailAdapter: 'mock-mail-adapter',\n        publicServerURL: 'http://localhost:8378/1'\n      };\n      await reconfigureServer(options);\n      const config = Config.get('test');\n      const mailAdapter = config.userController.adapter;\n      expect(mailAdapter.sendMail).toBeDefined();\n    });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"throws if you initialize email adapter incorrectly","suites":["server","mail adapter"],"line":152,"updatePoint":{"line":152,"column":58,"index":4949},"code":"    it('throws if you initialize email adapter incorrectly', async () => {\n      const options = {\n        appName: 'unused',\n        verifyUserEmails: true,\n        emailAdapter: {\n          module: 'mock-mail-adapter',\n          options: {\n            throw: true\n          }\n        },\n        publicServerURL: 'http://localhost:8378/1'\n      };\n      expectAsync(reconfigureServer(options)).toBeRejected('MockMailAdapterConstructor');\n    });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can report the server version","suites":["server","mail adapter"],"line":167,"updatePoint":{"line":167,"column":35,"index":5379},"code":"  it('can report the server version', async done => {\n    await reconfigureServer();\n    request({\n      url: 'http://localhost:8378/1/serverInfo',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Master-Key': 'test'\n      }\n    }).then(response => {\n      const body = response.data;\n      expect(body.parseServerVersion).toEqual(parseServerPackage.version);\n      done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can properly sets the push support","suites":["server","mail adapter"],"line":181,"updatePoint":{"line":181,"column":40,"index":5799},"code":"  it('can properly sets the push support', async done => {\n    await reconfigureServer();\n    // default config passes push options\n    const config = Config.get('test');\n    expect(config.hasPushSupport).toEqual(true);\n    expect(config.hasPushScheduledSupport).toEqual(false);\n    request({\n      url: 'http://localhost:8378/1/serverInfo',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Master-Key': 'test'\n      },\n      json: true\n    }).then(response => {\n      const body = response.data;\n      expect(body.features.push.immediatePush).toEqual(true);\n      expect(body.features.push.scheduledPush).toEqual(false);\n      done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can properly sets the push support when not configured","suites":["server","mail adapter"],"line":201,"updatePoint":{"line":201,"column":60,"index":6496},"code":"  it('can properly sets the push support when not configured', done => {\n    reconfigureServer({\n      push: undefined // force no config\n    }).then(() => {\n      const config = Config.get('test');\n      expect(config.hasPushSupport).toEqual(false);\n      expect(config.hasPushScheduledSupport).toEqual(false);\n      request({\n        url: 'http://localhost:8378/1/serverInfo',\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Master-Key': 'test'\n        },\n        json: true\n      }).then(response => {\n        const body = response.data;\n        expect(body.features.push.immediatePush).toEqual(false);\n        expect(body.features.push.scheduledPush).toEqual(false);\n        done();\n      });\n    }).catch(done.fail);\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can properly sets the push support ","suites":["server","mail adapter"],"line":223,"updatePoint":{"line":223,"column":41,"index":7239},"code":"  it('can properly sets the push support ', done => {\n    reconfigureServer({\n      push: {\n        adapter: {\n          send() {},\n          getValidPushTypes() {}\n        }\n      }\n    }).then(() => {\n      const config = Config.get('test');\n      expect(config.hasPushSupport).toEqual(true);\n      expect(config.hasPushScheduledSupport).toEqual(false);\n      request({\n        url: 'http://localhost:8378/1/serverInfo',\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Master-Key': 'test'\n        },\n        json: true\n      }).then(response => {\n        const body = response.data;\n        expect(body.features.push.immediatePush).toEqual(true);\n        expect(body.features.push.scheduledPush).toEqual(false);\n        done();\n      });\n    }).catch(done.fail);\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can properly sets the push schedule support","suites":["server","mail adapter"],"line":250,"updatePoint":{"line":250,"column":49,"index":8052},"code":"  it('can properly sets the push schedule support', done => {\n    reconfigureServer({\n      push: {\n        adapter: {\n          send() {},\n          getValidPushTypes() {}\n        }\n      },\n      scheduledPush: true\n    }).then(() => {\n      const config = Config.get('test');\n      expect(config.hasPushSupport).toEqual(true);\n      expect(config.hasPushScheduledSupport).toEqual(true);\n      request({\n        url: 'http://localhost:8378/1/serverInfo',\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Master-Key': 'test'\n        },\n        json: true\n      }).then(response => {\n        const body = response.data;\n        expect(body.features.push.immediatePush).toEqual(true);\n        expect(body.features.push.scheduledPush).toEqual(true);\n        done();\n      });\n    }).catch(done.fail);\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can respond 200 on path health","suites":["server","mail adapter"],"line":278,"updatePoint":{"line":278,"column":36,"index":8877},"code":"  it('can respond 200 on path health', done => {\n    request({\n      url: 'http://localhost:8378/1/health'\n    }).then(response => {\n      expect(response.status).toBe(200);\n      done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can create a parse-server v1","suites":["server","mail adapter"],"line":286,"updatePoint":{"line":286,"column":34,"index":9077},"code":"  it('can create a parse-server v1', done => {\n    const parseServer = new ParseServer.default(Object.assign({}, defaultConfiguration, {\n      appId: 'aTestApp',\n      masterKey: 'aTestMasterKey',\n      serverURL: 'http://localhost:12666/parse',\n      serverStartComplete: () => {\n        expect(Parse.applicationId).toEqual('aTestApp');\n        const app = express();\n        app.use('/parse', parseServer.app);\n        const server = app.listen(12666);\n        const obj = new Parse.Object('AnObject');\n        let objId;\n        obj.save().then(obj => {\n          objId = obj.id;\n          const q = new Parse.Query('AnObject');\n          return q.first();\n        }).then(obj => {\n          expect(obj.id).toEqual(objId);\n          server.close(async () => {\n            await reconfigureServer();\n            done();\n          });\n        }).catch(() => {\n          server.close(async () => {\n            await reconfigureServer();\n            done();\n          });\n        });\n      }\n    }));\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"can create a parse-server v2","suites":["server","mail adapter"],"line":317,"updatePoint":{"line":317,"column":34,"index":10083},"code":"  it('can create a parse-server v2', done => {\n    let objId;\n    let server;\n    const parseServer = ParseServer.ParseServer(Object.assign({}, defaultConfiguration, {\n      appId: 'anOtherTestApp',\n      masterKey: 'anOtherTestMasterKey',\n      serverURL: 'http://localhost:12667/parse',\n      serverStartComplete: error => {\n        const promise = error ? Promise.reject(error) : Promise.resolve();\n        promise.then(() => {\n          expect(Parse.applicationId).toEqual('anOtherTestApp');\n          const app = express();\n          app.use('/parse', parseServer);\n          server = app.listen(12667);\n          const obj = new Parse.Object('AnObject');\n          return obj.save();\n        }).then(obj => {\n          objId = obj.id;\n          const q = new Parse.Query('AnObject');\n          return q.first();\n        }).then(obj => {\n          expect(obj.id).toEqual(objId);\n          server.close(async () => {\n            await reconfigureServer();\n            done();\n          });\n        }).catch(error => {\n          fail(JSON.stringify(error));\n          if (server) {\n            server.close(async () => {\n              await reconfigureServer();\n              done();\n            });\n          } else {\n            done();\n          }\n        });\n      }\n    }));\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"has createLiveQueryServer","suites":["server","mail adapter"],"line":357,"updatePoint":{"line":357,"column":31,"index":11369},"code":"  it('has createLiveQueryServer', done => {\n    // original implementation through the factory\n    expect(typeof ParseServer.ParseServer.createLiveQueryServer).toEqual('function');\n    // For import calls\n    expect(typeof ParseServer.default.createLiveQueryServer).toEqual('function');\n    done();\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"exposes correct adapters","suites":["server","mail adapter"],"line":364,"updatePoint":{"line":364,"column":30,"index":11673},"code":"  it('exposes correct adapters', done => {\n    expect(ParseServer.S3Adapter).toThrow('S3Adapter is not provided by parse-server anymore; please install @parse/s3-files-adapter');\n    expect(ParseServer.GCSAdapter).toThrow('GCSAdapter is not provided by parse-server anymore; please install @parse/gcs-files-adapter');\n    expect(ParseServer.FileSystemAdapter).toThrow();\n    expect(ParseServer.InMemoryCacheAdapter).toThrow();\n    expect(ParseServer.NullCacheAdapter).toThrow();\n    done();\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"properly gives publicServerURL when set","suites":["server","mail adapter"],"line":372,"updatePoint":{"line":372,"column":45,"index":12185},"code":"  it('properly gives publicServerURL when set', done => {\n    reconfigureServer({\n      publicServerURL: 'https://myserver.com/1'\n    }).then(() => {\n      const config = Config.get('test', 'http://localhost:8378/1');\n      expect(config.mount).toEqual('https://myserver.com/1');\n      done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"properly removes trailing slash in mount","suites":["server","mail adapter"],"line":381,"updatePoint":{"line":381,"column":46,"index":12494},"code":"  it('properly removes trailing slash in mount', done => {\n    reconfigureServer({}).then(() => {\n      const config = Config.get('test', 'http://localhost:8378/1/');\n      expect(config.mount).toEqual('http://localhost:8378/1');\n      done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when getting invalid mount","suites":["server","mail adapter"],"line":388,"updatePoint":{"line":388,"column":45,"index":12751},"code":"  it('should throw when getting invalid mount', done => {\n    reconfigureServer({\n      publicServerURL: 'blabla:/some'\n    }).catch(error => {\n      expect(error).toEqual('publicServerURL should be a valid HTTPS URL starting with https://');\n      done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"fails if the session length is not a number","suites":["server","mail adapter"],"line":396,"updatePoint":{"line":396,"column":49,"index":13026},"code":"  it('fails if the session length is not a number', done => {\n    reconfigureServer({\n      sessionLength: 'test'\n    }).then(done.fail).catch(error => {\n      expect(error).toEqual('Session length must be a valid number.');\n      done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"fails if the session length is less than or equal to 0","suites":["server","mail adapter"],"line":404,"updatePoint":{"line":404,"column":60,"index":13290},"code":"  it('fails if the session length is less than or equal to 0', done => {\n    reconfigureServer({\n      sessionLength: '-33'\n    }).then(done.fail).catch(error => {\n      expect(error).toEqual('Session length must be a value greater than 0.');\n      return reconfigureServer({\n        sessionLength: '0'\n      });\n    }).catch(error => {\n      expect(error).toEqual('Session length must be a value greater than 0.');\n      done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"ignores the session length when expireInactiveSessions set to false","suites":["server","mail adapter"],"line":417,"updatePoint":{"line":417,"column":73,"index":13747},"code":"  it('ignores the session length when expireInactiveSessions set to false', done => {\n    reconfigureServer({\n      sessionLength: '-33',\n      expireInactiveSessions: false\n    }).then(() => reconfigureServer({\n      sessionLength: '0',\n      expireInactiveSessions: false\n    })).then(done);\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"fails if default limit is negative","suites":["server","mail adapter"],"line":426,"updatePoint":{"line":426,"column":40,"index":14014},"code":"  it('fails if default limit is negative', async () => {\n    await expectAsync(reconfigureServer({\n      defaultLimit: -1\n    })).toBeRejectedWith('Default limit must be a value greater than 0.');\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"fails if default limit is wrong type","suites":["server","mail adapter"],"line":431,"updatePoint":{"line":431,"column":42,"index":14219},"code":"  it('fails if default limit is wrong type', async () => {\n    for (const value of ['invalid', {}, [], true]) {\n      await expectAsync(reconfigureServer({\n        defaultLimit: value\n      })).toBeRejectedWith('Default limit must be a number.');\n    }\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"fails if default limit is zero","suites":["server","mail adapter"],"line":438,"updatePoint":{"line":438,"column":36,"index":14472},"code":"  it('fails if default limit is zero', async () => {\n    await expectAsync(reconfigureServer({\n      defaultLimit: 0\n    })).toBeRejectedWith('Default limit must be a value greater than 0.');\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"fails if maxLimit is negative","suites":["server","mail adapter"],"line":443,"updatePoint":{"line":443,"column":35,"index":14669},"code":"  it('fails if maxLimit is negative', done => {\n    reconfigureServer({\n      maxLimit: -100\n    }).catch(error => {\n      expect(error).toEqual('Max limit must be a value greater than 0.');\n      done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"fails if you try to set revokeSessionOnPasswordReset to non-boolean","suites":["server","mail adapter"],"line":451,"updatePoint":{"line":451,"column":73,"index":14926},"code":"  it('fails if you try to set revokeSessionOnPasswordReset to non-boolean', done => {\n    reconfigureServer({\n      revokeSessionOnPasswordReset: 'non-bool'\n    }).catch(done);\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"fails if you provides invalid ip in masterKeyIps","suites":["server","mail adapter"],"line":456,"updatePoint":{"line":456,"column":54,"index":15090},"code":"  it('fails if you provides invalid ip in masterKeyIps', done => {\n    reconfigureServer({\n      masterKeyIps: ['invalidIp', '1.2.3.4']\n    }).catch(error => {\n      expect(error).toEqual('Invalid ip in masterKeyIps: invalidIp');\n      done();\n    });\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed if you provide valid ip in masterKeyIps","suites":["server","mail adapter"],"line":464,"updatePoint":{"line":464,"column":60,"index":15354},"code":"  it('should succeed if you provide valid ip in masterKeyIps', done => {\n    reconfigureServer({\n      masterKeyIps: ['1.2.3.4', '2001:0db8:0000:0042:0000:8a2e:0370:7334']\n    }).then(done);\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"should load a middleware","suites":["server","mail adapter"],"line":469,"updatePoint":{"line":469,"column":30,"index":15521},"code":"  it('should load a middleware', done => {\n    const obj = {\n      middleware: function (req, res, next) {\n        next();\n      }\n    };\n    const spy = spyOn(obj, 'middleware').and.callThrough();\n    reconfigureServer({\n      middleware: obj.middleware\n    }).then(() => {\n      const query = new Parse.Query('AnObject');\n      return query.find();\n    }).then(() => {\n      expect(spy).toHaveBeenCalled();\n      done();\n    }).catch(done.fail);\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"should allow direct access","suites":["server","mail adapter"],"line":486,"updatePoint":{"line":486,"column":32,"index":15977},"code":"  it('should allow direct access', async () => {\n    const RESTController = Parse.CoreManager.getRESTController();\n    const spy = spyOn(Parse.CoreManager, 'setRESTController').and.callThrough();\n    await reconfigureServer({\n      directAccess: true\n    });\n    expect(spy).toHaveBeenCalledTimes(2);\n    Parse.CoreManager.setRESTController(RESTController);\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"should load a middleware from string","suites":["server","mail adapter"],"line":495,"updatePoint":{"line":495,"column":42,"index":16351},"code":"  it('should load a middleware from string', done => {\n    reconfigureServer({\n      middleware: 'spec/support/CustomMiddleware'\n    }).then(() => {\n      return request({\n        url: 'http://localhost:8378/1'\n      }).then(fail, res => {\n        // Just check that the middleware set the header\n        expect(res.headers['x-yolo']).toBe('1');\n        done();\n      });\n    }).catch(done.fail);\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"should not fail when Google signin is introduced without the optional clientId","suites":["server","mail adapter"],"line":508,"updatePoint":{"line":508,"column":84,"index":16796},"code":"  it('should not fail when Google signin is introduced without the optional clientId', done => {\n    const jwt = require('jsonwebtoken');\n    reconfigureServer({\n      auth: {\n        google: {}\n      }\n    }).then(() => {\n      const fakeClaim = {\n        iss: 'https://accounts.google.com',\n        aud: 'secret',\n        exp: Date.now(),\n        sub: 'the_user_id'\n      };\n      const fakeDecodedToken = {\n        header: {\n          kid: '123',\n          alg: 'RS256'\n        }\n      };\n      spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n      spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n      const user = new Parse.User();\n      user.linkWith('google', {\n        authData: {\n          id: 'the_user_id',\n          id_token: 'the_token'\n        }\n      }).then(done);\n    }).catch(done.fail);\n  });","file":"index.spec.js","skipped":false,"dir":"spec"},{"name":"should destroy a expire items in the cache","suites":["InMemoryCache"],"line":17,"updatePoint":{"line":17,"column":48,"index":441},"code":"  it('should destroy a expire items in the cache', done => {\n    const cache = new InMemoryCache(BASE_TTL);\n    cache.put(KEY, VALUE);\n    let value = cache.get(KEY);\n    expect(value).toEqual(VALUE);\n    wait(BASE_TTL.ttl * 10).then(() => {\n      value = cache.get(KEY);\n      expect(value).toEqual(null);\n      done();\n    });\n  });","file":"InMemoryCache.spec.js","skipped":false,"dir":"spec"},{"name":"should delete items","suites":["InMemoryCache"],"line":28,"updatePoint":{"line":28,"column":25,"index":753},"code":"  it('should delete items', done => {\n    const cache = new InMemoryCache(NO_EXPIRE_TTL);\n    cache.put(KEY, VALUE);\n    cache.put(KEY_2, VALUE);\n    expect(cache.get(KEY)).toEqual(VALUE);\n    expect(cache.get(KEY_2)).toEqual(VALUE);\n    cache.del(KEY);\n    expect(cache.get(KEY)).toEqual(null);\n    expect(cache.get(KEY_2)).toEqual(VALUE);\n    cache.del(KEY_2);\n    expect(cache.get(KEY)).toEqual(null);\n    expect(cache.get(KEY_2)).toEqual(null);\n    done();\n  });","file":"InMemoryCache.spec.js","skipped":false,"dir":"spec"},{"name":"should clear all items","suites":["InMemoryCache"],"line":42,"updatePoint":{"line":42,"column":28,"index":1223},"code":"  it('should clear all items', done => {\n    const cache = new InMemoryCache(NO_EXPIRE_TTL);\n    cache.put(KEY, VALUE);\n    cache.put(KEY_2, VALUE);\n    expect(cache.get(KEY)).toEqual(VALUE);\n    expect(cache.get(KEY_2)).toEqual(VALUE);\n    cache.clear();\n    expect(cache.get(KEY)).toEqual(null);\n    expect(cache.get(KEY_2)).toEqual(null);\n    done();\n  });","file":"InMemoryCache.spec.js","skipped":false,"dir":"spec"},{"name":"should deafult TTL to 5 seconds","suites":["InMemoryCache"],"line":53,"updatePoint":{"line":53,"column":37,"index":1592},"code":"  it('should deafult TTL to 5 seconds', () => {\n    const cache = new InMemoryCache({});\n    expect(cache.ttl).toEqual(5 * 1000);\n  });","file":"InMemoryCache.spec.js","skipped":false,"dir":"spec"},{"name":"should expose promisifyed methods","suites":["InMemoryCacheAdapter"],"line":10,"updatePoint":{"line":10,"column":39,"index":342},"code":"  it('should expose promisifyed methods', done => {\n    const cache = new InMemoryCacheAdapter({\n      ttl: NaN\n    });\n\n    // Verify all methods return promises.\n    Promise.all([cache.put(KEY, VALUE), cache.del(KEY), cache.get(KEY), cache.clear()]).then(() => {\n      done();\n    });\n  });","file":"InMemoryCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should get/set/clear","suites":["InMemoryCacheAdapter"],"line":20,"updatePoint":{"line":20,"column":26,"index":622},"code":"  it('should get/set/clear', done => {\n    const cache = new InMemoryCacheAdapter({\n      ttl: NaN\n    });\n    cache.put(KEY, VALUE).then(() => cache.get(KEY)).then(value => expect(value).toEqual(VALUE)).then(() => cache.clear()).then(() => cache.get(KEY)).then(value => expect(value).toEqual(null)).then(done);\n  });","file":"InMemoryCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should expire after ttl","suites":["InMemoryCacheAdapter"],"line":26,"updatePoint":{"line":26,"column":29,"index":943},"code":"  it('should expire after ttl', done => {\n    const cache = new InMemoryCacheAdapter({\n      ttl: 10\n    });\n    cache.put(KEY, VALUE).then(() => cache.get(KEY)).then(value => expect(value).toEqual(VALUE)).then(wait.bind(null, 50)).then(() => cache.get(KEY)).then(value => expect(value).toEqual(null)).then(done);\n  });","file":"InMemoryCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"uses find condition from request.body","suites":["InstallationsRouter"],"line":6,"updatePoint":{"line":6,"column":43,"index":294},"code":"  it('uses find condition from request.body', done => {\n    const config = Config.get('test');\n    const androidDeviceRequest = {\n      installationId: '12345678-abcd-abcd-abcd-123456789abc',\n      deviceType: 'android'\n    };\n    const iosDeviceRequest = {\n      installationId: '12345678-abcd-abcd-abcd-123456789abd',\n      deviceType: 'ios'\n    };\n    const request = {\n      config: config,\n      auth: auth.master(config),\n      body: {\n        where: {\n          deviceType: 'android'\n        }\n      },\n      query: {},\n      info: {}\n    };\n    const router = new InstallationsRouter();\n    rest.create(config, auth.nobody(config), '_Installation', androidDeviceRequest).then(() => {\n      return rest.create(config, auth.nobody(config), '_Installation', iosDeviceRequest);\n    }).then(() => {\n      return router.handleFind(request);\n    }).then(res => {\n      const results = res.response.results;\n      expect(results.length).toEqual(1);\n      done();\n    }).catch(err => {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"InstallationsRouter.spec.js","skipped":false,"dir":"spec"},{"name":"uses find condition from request.query","suites":["InstallationsRouter"],"line":41,"updatePoint":{"line":41,"column":44,"index":1341},"code":"  it('uses find condition from request.query', done => {\n    const config = Config.get('test');\n    const androidDeviceRequest = {\n      installationId: '12345678-abcd-abcd-abcd-123456789abc',\n      deviceType: 'android'\n    };\n    const iosDeviceRequest = {\n      installationId: '12345678-abcd-abcd-abcd-123456789abd',\n      deviceType: 'ios'\n    };\n    const request = {\n      config: config,\n      auth: auth.master(config),\n      body: {},\n      query: {\n        where: {\n          deviceType: 'android'\n        }\n      },\n      info: {}\n    };\n    const router = new InstallationsRouter();\n    rest.create(config, auth.nobody(config), '_Installation', androidDeviceRequest).then(() => {\n      return rest.create(config, auth.nobody(config), '_Installation', iosDeviceRequest);\n    }).then(() => {\n      return router.handleFind(request);\n    }).then(res => {\n      const results = res.response.results;\n      expect(results.length).toEqual(1);\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"InstallationsRouter.spec.js","skipped":false,"dir":"spec"},{"name":"query installations with limit = 0","suites":["InstallationsRouter"],"line":76,"updatePoint":{"line":76,"column":40,"index":2369},"code":"  it('query installations with limit = 0', done => {\n    const config = Config.get('test');\n    const androidDeviceRequest = {\n      installationId: '12345678-abcd-abcd-abcd-123456789abc',\n      deviceType: 'android'\n    };\n    const iosDeviceRequest = {\n      installationId: '12345678-abcd-abcd-abcd-123456789abd',\n      deviceType: 'ios'\n    };\n    const request = {\n      config: config,\n      auth: auth.master(config),\n      body: {},\n      query: {\n        limit: 0\n      },\n      info: {}\n    };\n    Config.get('test');\n    const router = new InstallationsRouter();\n    rest.create(config, auth.nobody(config), '_Installation', androidDeviceRequest).then(() => {\n      return rest.create(config, auth.nobody(config), '_Installation', iosDeviceRequest);\n    }).then(() => {\n      return router.handleFind(request);\n    }).then(res => {\n      const response = res.response;\n      expect(response.results.length).toEqual(0);\n      done();\n    }).catch(err => {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"InstallationsRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should create _JobSchedule with masterKey","suites":["JobSchedule"],"line":22,"updatePoint":{"line":22,"column":47,"index":567},"code":"  it('should create _JobSchedule with masterKey', done => {\n    const jobSchedule = new Parse.Object('_JobSchedule');\n    jobSchedule.set({\n      jobName: 'MY Cool Job'\n    });\n    jobSchedule.save(null, {\n      useMasterKey: true\n    }).then(() => {\n      done();\n    }).catch(done.fail);\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should fail creating _JobSchedule without masterKey","suites":["JobSchedule"],"line":33,"updatePoint":{"line":33,"column":57,"index":873},"code":"  it('should fail creating _JobSchedule without masterKey', done => {\n    const jobSchedule = new Parse.Object('_JobSchedule');\n    jobSchedule.set({\n      jobName: 'SomeJob'\n    });\n    jobSchedule.save(null).then(done.fail).catch(() => done());\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should reject access when not using masterKey (/jobs)","suites":["JobSchedule"],"line":40,"updatePoint":{"line":40,"column":59,"index":1128},"code":"  it('should reject access when not using masterKey (/jobs)', done => {\n    request(Object.assign({\n      url: Parse.serverURL + '/cloud_code/jobs'\n    }, defaultOptions)).then(done.fail, () => done());\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should reject access when not using masterKey (/jobs/data)","suites":["JobSchedule"],"line":45,"updatePoint":{"line":45,"column":64,"index":1342},"code":"  it('should reject access when not using masterKey (/jobs/data)', done => {\n    request(Object.assign({\n      url: Parse.serverURL + '/cloud_code/jobs/data'\n    }, defaultOptions)).then(done.fail, () => done());\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should reject access when not using masterKey (PUT /jobs/id)","suites":["JobSchedule"],"line":50,"updatePoint":{"line":50,"column":66,"index":1563},"code":"  it('should reject access when not using masterKey (PUT /jobs/id)', done => {\n    request(Object.assign({\n      method: 'PUT',\n      url: Parse.serverURL + '/cloud_code/jobs/jobId'\n    }, defaultOptions)).then(done.fail, () => done());\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should reject access when not using masterKey (DELETE /jobs/id)","suites":["JobSchedule"],"line":56,"updatePoint":{"line":56,"column":69,"index":1809},"code":"  it('should reject access when not using masterKey (DELETE /jobs/id)', done => {\n    request(Object.assign({\n      method: 'DELETE',\n      url: Parse.serverURL + '/cloud_code/jobs/jobId'\n    }, defaultOptions)).then(done.fail, () => done());\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should allow access when using masterKey (GET /jobs)","suites":["JobSchedule"],"line":62,"updatePoint":{"line":62,"column":58,"index":2047},"code":"  it('should allow access when using masterKey (GET /jobs)', done => {\n    request(Object.assign({\n      url: Parse.serverURL + '/cloud_code/jobs'\n    }, masterKeyOptions)).then(done, done.fail);\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should create a job schedule","suites":["JobSchedule"],"line":67,"updatePoint":{"line":67,"column":34,"index":2225},"code":"  it('should create a job schedule', done => {\n    Parse.Cloud.job('job', () => {});\n    const options = Object.assign({}, masterKeyOptions, {\n      method: 'POST',\n      url: Parse.serverURL + '/cloud_code/jobs',\n      body: {\n        job_schedule: {\n          jobName: 'job'\n        }\n      }\n    });\n    request(options).then(res => {\n      expect(res.data.objectId).not.toBeUndefined();\n    }).then(() => {\n      return request(Object.assign({\n        url: Parse.serverURL + '/cloud_code/jobs'\n      }, masterKeyOptions));\n    }).then(res => {\n      expect(res.data.length).toBe(1);\n    }).then(done).catch(done.fail);\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should fail creating a job with an invalid name","suites":["JobSchedule"],"line":88,"updatePoint":{"line":88,"column":53,"index":2873},"code":"  it('should fail creating a job with an invalid name', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      url: Parse.serverURL + '/cloud_code/jobs',\n      method: 'POST',\n      body: {\n        job_schedule: {\n          jobName: 'job'\n        }\n      }\n    });\n    request(options).then(done.fail).catch(() => done());\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should update a job","suites":["JobSchedule"],"line":100,"updatePoint":{"line":100,"column":25,"index":3193},"code":"  it('should update a job', done => {\n    Parse.Cloud.job('job1', () => {});\n    Parse.Cloud.job('job2', () => {});\n    const options = Object.assign({}, masterKeyOptions, {\n      method: 'POST',\n      url: Parse.serverURL + '/cloud_code/jobs',\n      body: {\n        job_schedule: {\n          jobName: 'job1'\n        }\n      }\n    });\n    request(options).then(res => {\n      expect(res.data.objectId).not.toBeUndefined();\n      return request(Object.assign(options, {\n        url: Parse.serverURL + '/cloud_code/jobs/' + res.data.objectId,\n        method: 'PUT',\n        body: {\n          job_schedule: {\n            jobName: 'job2'\n          }\n        }\n      }));\n    }).then(() => {\n      return request(Object.assign({}, masterKeyOptions, {\n        url: Parse.serverURL + '/cloud_code/jobs'\n      }));\n    }).then(res => {\n      expect(res.data.length).toBe(1);\n      expect(res.data[0].jobName).toBe('job2');\n    }).then(done).catch(done.fail);\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should fail updating a job with an invalid name","suites":["JobSchedule"],"line":132,"updatePoint":{"line":132,"column":53,"index":4178},"code":"  it('should fail updating a job with an invalid name', done => {\n    Parse.Cloud.job('job1', () => {});\n    const options = Object.assign({}, masterKeyOptions, {\n      method: 'POST',\n      url: Parse.serverURL + '/cloud_code/jobs',\n      body: {\n        job_schedule: {\n          jobName: 'job1'\n        }\n      }\n    });\n    request(options).then(res => {\n      expect(res.data.objectId).not.toBeUndefined();\n      return request(Object.assign(options, {\n        method: 'PUT',\n        url: Parse.serverURL + '/cloud_code/jobs/' + res.data.objectId,\n        body: {\n          job_schedule: {\n            jobName: 'job2'\n          }\n        }\n      }));\n    }).then(done.fail).catch(() => done());\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should destroy a job","suites":["JobSchedule"],"line":156,"updatePoint":{"line":156,"column":26,"index":4857},"code":"  it('should destroy a job', done => {\n    Parse.Cloud.job('job', () => {});\n    const options = Object.assign({}, masterKeyOptions, {\n      method: 'POST',\n      url: Parse.serverURL + '/cloud_code/jobs',\n      body: {\n        job_schedule: {\n          jobName: 'job'\n        }\n      }\n    });\n    request(options).then(res => {\n      expect(res.data.objectId).not.toBeUndefined();\n      return request(Object.assign({\n        method: 'DELETE',\n        url: Parse.serverURL + '/cloud_code/jobs/' + res.data.objectId\n      }, masterKeyOptions));\n    }).then(() => {\n      return request(Object.assign({\n        url: Parse.serverURL + '/cloud_code/jobs'\n      }, masterKeyOptions));\n    }).then(res => {\n      expect(res.data.length).toBe(0);\n    }).then(done).catch(done.fail);\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"should properly return job data","suites":["JobSchedule"],"line":181,"updatePoint":{"line":181,"column":37,"index":5652},"code":"  it('should properly return job data', done => {\n    Parse.Cloud.job('job1', () => {});\n    Parse.Cloud.job('job2', () => {});\n    const options = Object.assign({}, masterKeyOptions, {\n      method: 'POST',\n      url: Parse.serverURL + '/cloud_code/jobs',\n      body: {\n        job_schedule: {\n          jobName: 'job1'\n        }\n      }\n    });\n    request(options).then(response => {\n      const res = response.data;\n      expect(res.objectId).not.toBeUndefined();\n    }).then(() => {\n      return request(Object.assign({\n        url: Parse.serverURL + '/cloud_code/jobs/data'\n      }, masterKeyOptions));\n    }).then(response => {\n      const res = response.data;\n      expect(res.in_use).toEqual(['job1']);\n      expect(res.jobs).toContain('job1');\n      expect(res.jobs).toContain('job2');\n      expect(res.jobs.length).toBe(2);\n    }).then(done).catch(e => done.fail(e.data));\n  });","file":"JobSchedule.spec.js","skipped":false,"dir":"spec"},{"name":"Should fail with missing options","suites":["Ldap Auth"],"line":7,"updatePoint":{"line":7,"column":38,"index":249},"code":"  it('Should fail with missing options', done => {\n    ldap.validateAuthData({\n      id: 'testuser',\n      password: 'testpw'\n    }).then(done.fail).catch(err => {\n      jequal(err.message, 'LDAP auth configuration missing');\n      done();\n    });\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should return a resolved promise when validating the app id","suites":["Ldap Auth"],"line":16,"updatePoint":{"line":16,"column":65,"index":530},"code":"  it('Should return a resolved promise when validating the app id', done => {\n    ldap.validateAppId().then(done).catch(done.fail);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should succeed with right credentials","suites":["Ldap Auth"],"line":19,"updatePoint":{"line":19,"column":43,"index":646},"code":"  it('Should succeed with right credentials', async done => {\n    const server = await mockLdapServer(port, 'uid=testuser, o=example');\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example'\n    };\n    await ldap.validateAuthData({\n      id: 'testuser',\n      password: 'secret'\n    }, options);\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should succeed with right credentials when LDAPS is used and certifcate is not checked","suites":["Ldap Auth"],"line":32,"updatePoint":{"line":32,"column":92,"index":1088},"code":"  it('Should succeed with right credentials when LDAPS is used and certifcate is not checked', async done => {\n    const server = await mockLdapServer(sslport, 'uid=testuser, o=example', false, true);\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: {\n        rejectUnauthorized: false\n      }\n    };\n    await ldap.validateAuthData({\n      id: 'testuser',\n      password: 'secret'\n    }, options);\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should succeed when LDAPS is used and the presented certificate is the expected certificate","suites":["Ldap Auth"],"line":48,"updatePoint":{"line":48,"column":97,"index":1618},"code":"  it('Should succeed when LDAPS is used and the presented certificate is the expected certificate', async done => {\n    const server = await mockLdapServer(sslport, 'uid=testuser, o=example', false, true);\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: {\n        ca: fs.readFileSync(__dirname + '/support/cert/cert.pem'),\n        rejectUnauthorized: true\n      }\n    };\n    await ldap.validateAuthData({\n      id: 'testuser',\n      password: 'secret'\n    }, options);\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should fail when LDAPS is used and the presented certificate is not the expected certificate","suites":["Ldap Auth"],"line":65,"updatePoint":{"line":65,"column":98,"index":2215},"code":"  it('Should fail when LDAPS is used and the presented certificate is not the expected certificate', async done => {\n    const server = await mockLdapServer(sslport, 'uid=testuser, o=example', false, true);\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: {\n        ca: fs.readFileSync(__dirname + '/support/cert/anothercert.pem'),\n        rejectUnauthorized: true\n      }\n    };\n    try {\n      await ldap.validateAuthData({\n        id: 'testuser',\n        password: 'secret'\n      }, options);\n      fail();\n    } catch (err) {\n      expect(err.message).toBe('LDAPS: Certificate mismatch');\n    }\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should fail when LDAPS is used certifcate matches but credentials are wrong","suites":["Ldap Auth"],"line":87,"updatePoint":{"line":87,"column":81,"index":2923},"code":"  it('Should fail when LDAPS is used certifcate matches but credentials are wrong', async done => {\n    const server = await mockLdapServer(sslport, 'uid=testuser, o=example', false, true);\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: {\n        ca: fs.readFileSync(__dirname + '/support/cert/cert.pem'),\n        rejectUnauthorized: true\n      }\n    };\n    try {\n      await ldap.validateAuthData({\n        id: 'testuser',\n        password: 'wrong!'\n      }, options);\n      fail();\n    } catch (err) {\n      expect(err.message).toBe('LDAP: Wrong username or password');\n    }\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should fail with wrong credentials","suites":["Ldap Auth"],"line":109,"updatePoint":{"line":109,"column":40,"index":3588},"code":"  it('Should fail with wrong credentials', async done => {\n    const server = await mockLdapServer(port, 'uid=testuser, o=example');\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example'\n    };\n    try {\n      await ldap.validateAuthData({\n        id: 'testuser',\n        password: 'wrong!'\n      }, options);\n      fail();\n    } catch (err) {\n      expect(err.message).toBe('LDAP: Wrong username or password');\n    }\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should succeed if user is in given group","suites":["Ldap Auth"],"line":127,"updatePoint":{"line":127,"column":46,"index":4110},"code":"  it('Should succeed if user is in given group', async done => {\n    const server = await mockLdapServer(port, 'uid=testuser, o=example');\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'powerusers',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))'\n    };\n    await ldap.validateAuthData({\n      id: 'testuser',\n      password: 'secret'\n    }, options);\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should fail if user is not in given group","suites":["Ldap Auth"],"line":142,"updatePoint":{"line":142,"column":47,"index":4630},"code":"  it('Should fail if user is not in given group', async done => {\n    const server = await mockLdapServer(port, 'uid=testuser, o=example');\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'groupTheUserIsNotIn',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))'\n    };\n    try {\n      await ldap.validateAuthData({\n        id: 'testuser',\n        password: 'secret'\n      }, options);\n      fail();\n    } catch (err) {\n      expect(err.message).toBe('LDAP: User not in group');\n    }\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should fail if the LDAP server does not allow searching inside the provided suffix","suites":["Ldap Auth"],"line":162,"updatePoint":{"line":162,"column":88,"index":5317},"code":"  it('Should fail if the LDAP server does not allow searching inside the provided suffix', async done => {\n    const server = await mockLdapServer(port, 'uid=testuser, o=example');\n    const options = {\n      suffix: 'o=invalid',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'powerusers',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))'\n    };\n    try {\n      await ldap.validateAuthData({\n        id: 'testuser',\n        password: 'secret'\n      }, options);\n      fail();\n    } catch (err) {\n      expect(err.message).toBe('LDAP group search failed');\n    }\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should fail if the LDAP server encounters an error while searching","suites":["Ldap Auth"],"line":182,"updatePoint":{"line":182,"column":72,"index":5980},"code":"  it('Should fail if the LDAP server encounters an error while searching', async done => {\n    const server = await mockLdapServer(port, 'uid=testuser, o=example', true);\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'powerusers',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))'\n    };\n    try {\n      await ldap.validateAuthData({\n        id: 'testuser',\n        password: 'secret'\n      }, options);\n      fail();\n    } catch (err) {\n      expect(err.message).toBe('LDAP group search failed');\n    }\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should delete the password from authData after validation","suites":["Ldap Auth"],"line":202,"updatePoint":{"line":202,"column":63,"index":6640},"code":"  it('Should delete the password from authData after validation', async done => {\n    const server = await mockLdapServer(port, 'uid=testuser, o=example', true);\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example'\n    };\n    const authData = {\n      id: 'testuser',\n      password: 'secret'\n    };\n    await ldap.validateAuthData(authData, options);\n    expect(authData).toEqual({\n      id: 'testuser'\n    });\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should not save the password in the user record after authentication","suites":["Ldap Auth"],"line":219,"updatePoint":{"line":219,"column":74,"index":7161},"code":"  it('Should not save the password in the user record after authentication', async done => {\n    const server = await mockLdapServer(port, 'uid=testuser, o=example', true);\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example'\n    };\n    await reconfigureServer({\n      auth: {\n        ldap: options\n      }\n    });\n    const authData = {\n      authData: {\n        id: 'testuser',\n        password: 'secret'\n      }\n    };\n    const returnedUser = await Parse.User.logInWith('ldap', authData);\n    const query = new Parse.Query('User');\n    const user = await query.equalTo('objectId', returnedUser.id).first({\n      useMasterKey: true\n    });\n    expect(user.get('authData')).toEqual({\n      ldap: {\n        id: 'testuser'\n      }\n    });\n    expect(user.get('authData').ldap.password).toBeUndefined();\n    server.close(done);\n  });","file":"LdapAuth.spec.js","skipped":false,"dir":"spec"},{"name":"should add transport","suites":["WinstonLogger"],"line":9,"updatePoint":{"line":9,"column":26,"index":270},"code":"  it('should add transport', () => {\n    const testTransport = new TestTransport();\n    spyOn(testTransport, 'log');\n    logging.addTransport(testTransport);\n    expect(logging.logger.transports.length).toBe(4);\n    logging.logger.info('hi');\n    expect(testTransport.log).toHaveBeenCalled();\n    logging.logger.error('error');\n    expect(testTransport.log).toHaveBeenCalled();\n    logging.removeTransport(testTransport);\n    expect(logging.logger.transports.length).toBe(3);\n  });","file":"Logger.spec.js","skipped":false,"dir":"spec"},{"name":"should have files transports","suites":["WinstonLogger"],"line":21,"updatePoint":{"line":21,"column":34,"index":760},"code":"  it('should have files transports', done => {\n    reconfigureServer().then(() => {\n      const transports = logging.logger.transports;\n      expect(transports.length).toBe(3);\n      done();\n    });\n  });","file":"Logger.spec.js","skipped":false,"dir":"spec"},{"name":"should disable files logs","suites":["WinstonLogger"],"line":28,"updatePoint":{"line":28,"column":31,"index":962},"code":"  it('should disable files logs', done => {\n    reconfigureServer({\n      logsFolder: null\n    }).then(() => {\n      const transports = logging.logger.transports;\n      expect(transports.length).toBe(1);\n      return reconfigureServer();\n    }).then(done);\n  });","file":"Logger.spec.js","skipped":false,"dir":"spec"},{"name":"should have a timestamp","suites":["WinstonLogger"],"line":37,"updatePoint":{"line":37,"column":29,"index":1223},"code":"  it('should have a timestamp', done => {\n    logging.logger.info('hi');\n    logging.logger.query({\n      limit: 1\n    }, (err, results) => {\n      if (err) {\n        done.fail(err);\n      }\n      expect(results['parse-server'][0].timestamp).toBeDefined();\n      done();\n    });\n  });","file":"Logger.spec.js","skipped":false,"dir":"spec"},{"name":"console should not be json","suites":["WinstonLogger"],"line":49,"updatePoint":{"line":49,"column":32,"index":1511},"code":"  it('console should not be json', done => {\n    // Force console transport\n    reconfigureServer({\n      logsFolder: null,\n      silent: false\n    }).then(() => {\n      spyOn(process.stdout, 'write');\n      logging.logger.info('hi', {\n        key: 'value'\n      });\n      expect(process.stdout.write).toHaveBeenCalled();\n      const firstLog = process.stdout.write.calls.first().args[0];\n      expect(firstLog).toEqual('info: hi {\"key\":\"value\"}' + '\\n');\n      return reconfigureServer();\n    }).then(() => {\n      done();\n    });\n  });","file":"Logger.spec.js","skipped":false,"dir":"spec"},{"name":"should enable JSON logs","suites":["WinstonLogger"],"line":67,"updatePoint":{"line":67,"column":29,"index":2046},"code":"  it('should enable JSON logs', done => {\n    // Force console transport\n    reconfigureServer({\n      logsFolder: null,\n      jsonLogs: true,\n      silent: false\n    }).then(() => {\n      spyOn(process.stdout, 'write');\n      logging.logger.info('hi', {\n        key: 'value'\n      });\n      expect(process.stdout.write).toHaveBeenCalled();\n      const firstLog = process.stdout.write.calls.first().args[0];\n      expect(firstLog).toEqual(JSON.stringify({\n        key: 'value',\n        level: 'info',\n        message: 'hi'\n      }) + '\\n');\n      return reconfigureServer({\n        jsonLogs: false\n      });\n    }).then(() => {\n      done();\n    });\n  });","file":"Logger.spec.js","skipped":false,"dir":"spec"},{"name":"can process an empty query without throwing","suites":["LoggerController"],"line":4,"updatePoint":{"line":4,"column":49,"index":283},"code":"  it('can process an empty query without throwing', done => {\n    // Make mock request\n    const query = {};\n    const loggerController = new LoggerController(new WinstonLoggerAdapter());\n    expect(() => {\n      loggerController.getLogs(query).then(function (res) {\n        expect(res.length).not.toBe(0);\n        done();\n      }).catch(err => {\n        jfail(err);\n        done();\n      });\n    }).not.toThrow();\n  });","file":"LoggerController.spec.js","skipped":false,"dir":"spec"},{"name":"properly validates dateTimes","suites":["LoggerController"],"line":18,"updatePoint":{"line":18,"column":34,"index":689},"code":"  it('properly validates dateTimes', done => {\n    expect(LoggerController.validDateTime()).toBe(null);\n    expect(LoggerController.validDateTime('String')).toBe(null);\n    expect(LoggerController.validDateTime(123456).getTime()).toBe(123456);\n    expect(LoggerController.validDateTime('2016-01-01Z00:00:00').getTime()).toBe(1451606400000);\n    done();\n  });","file":"LoggerController.spec.js","skipped":false,"dir":"spec"},{"name":"can set the proper default values","suites":["LoggerController"],"line":25,"updatePoint":{"line":25,"column":39,"index":1053},"code":"  it('can set the proper default values', done => {\n    // Make mock request\n    const result = LoggerController.parseOptions();\n    expect(result.size).toEqual(10);\n    expect(result.order).toEqual('desc');\n    expect(result.level).toEqual('info');\n    done();\n  });","file":"LoggerController.spec.js","skipped":false,"dir":"spec"},{"name":"can parse an ascending query without throwing","suites":["LoggerController"],"line":33,"updatePoint":{"line":33,"column":51,"index":1333},"code":"  it('can parse an ascending query without throwing', done => {\n    // Make mock request\n    const query = {\n      from: '2016-01-01Z00:00:00',\n      until: '2016-01-01Z00:00:00',\n      size: 5,\n      order: 'asc',\n      level: 'error'\n    };\n    const result = LoggerController.parseOptions(query);\n    expect(result.from.getTime()).toEqual(1451606400000);\n    expect(result.until.getTime()).toEqual(1451606400000);\n    expect(result.size).toEqual(5);\n    expect(result.order).toEqual('asc');\n    expect(result.level).toEqual('error');\n    done();\n  });","file":"LoggerController.spec.js","skipped":false,"dir":"spec"},{"name":"can process an ascending query without throwing","suites":["LoggerController"],"line":50,"updatePoint":{"line":50,"column":53,"index":1890},"code":"  it('can process an ascending query without throwing', done => {\n    const query = {\n      size: 5,\n      order: 'asc',\n      level: 'error'\n    };\n    const loggerController = new LoggerController(new WinstonLoggerAdapter());\n    loggerController.error('can process an ascending query without throwing');\n    expect(() => {\n      loggerController.getLogs(query).then(function (res) {\n        expect(res.length).not.toBe(0);\n        done();\n      }).catch(err => {\n        jfail(err);\n        fail('should not fail');\n        done();\n      });\n    }).not.toThrow();\n  });","file":"LoggerController.spec.js","skipped":false,"dir":"spec"},{"name":"can parse a descending query without throwing","suites":["LoggerController"],"line":69,"updatePoint":{"line":69,"column":51,"index":2461},"code":"  it('can parse a descending query without throwing', done => {\n    // Make mock request\n    const query = {\n      from: '2016-01-01Z00:00:00',\n      until: '2016-01-01Z00:00:00',\n      size: 5,\n      order: 'desc',\n      level: 'error'\n    };\n    const result = LoggerController.parseOptions(query);\n    expect(result.from.getTime()).toEqual(1451606400000);\n    expect(result.until.getTime()).toEqual(1451606400000);\n    expect(result.size).toEqual(5);\n    expect(result.order).toEqual('desc');\n    expect(result.level).toEqual('error');\n    done();\n  });","file":"LoggerController.spec.js","skipped":false,"dir":"spec"},{"name":"can process a descending query without throwing","suites":["LoggerController"],"line":86,"updatePoint":{"line":86,"column":53,"index":3020},"code":"  it('can process a descending query without throwing', done => {\n    const query = {\n      size: 5,\n      order: 'desc',\n      level: 'error'\n    };\n    const loggerController = new LoggerController(new WinstonLoggerAdapter());\n    loggerController.error('can process a descending query without throwing');\n    expect(() => {\n      loggerController.getLogs(query).then(function (res) {\n        expect(res.length).not.toBe(0);\n        done();\n      }).catch(err => {\n        jfail(err);\n        fail('should not fail');\n        done();\n      });\n    }).not.toThrow();\n  });","file":"LoggerController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw without an adapter","suites":["LoggerController"],"line":105,"updatePoint":{"line":105,"column":37,"index":3578},"code":"  it('should throw without an adapter', done => {\n    expect(() => {\n      new LoggerController();\n    }).toThrow();\n    done();\n  });","file":"LoggerController.spec.js","skipped":false,"dir":"spec"},{"name":"should replace implementations with verbose","suites":["LoggerController"],"line":111,"updatePoint":{"line":111,"column":49,"index":3725},"code":"  it('should replace implementations with verbose', done => {\n    const adapter = new WinstonLoggerAdapter();\n    const logger = new LoggerController(adapter, null, {\n      verbose: true\n    });\n    spyOn(adapter, 'log');\n    logger.silly('yo!');\n    expect(adapter.log).not.toHaveBeenCalled();\n    done();\n  });","file":"LoggerController.spec.js","skipped":false,"dir":"spec"},{"name":"should replace implementations with logLevel","suites":["LoggerController"],"line":121,"updatePoint":{"line":121,"column":50,"index":4039},"code":"  it('should replace implementations with logLevel', done => {\n    const adapter = new WinstonLoggerAdapter();\n    const logger = new LoggerController(adapter, null, {\n      logLevel: 'error'\n    });\n    spyOn(adapter, 'log');\n    logger.warn('yo!');\n    logger.info('yo!');\n    logger.debug('yo!');\n    logger.verbose('yo!');\n    logger.silly('yo!');\n    expect(adapter.log).not.toHaveBeenCalled();\n    logger.error('error');\n    expect(adapter.log).toHaveBeenCalled();\n    done();\n  });","file":"LoggerController.spec.js","skipped":false,"dir":"spec"},{"name":"can check valid master key of request","suites":[],"line":11,"updatePoint":{"line":11,"column":43,"index":545},"code":"  it('can check valid master key of request', done => {\n    // Make mock request\n    const request = {\n      auth: {\n        isMaster: true\n      },\n      query: {},\n      config: {\n        loggerController: loggerController\n      }\n    };\n    const router = new LogsRouter();\n    expect(() => {\n      router.validateRequest(request);\n    }).not.toThrow();\n    done();\n  });","file":"LogsRouter.spec.js","skipped":false,"dir":"spec"},{"name":"can check invalid construction of controller","suites":[],"line":28,"updatePoint":{"line":28,"column":50,"index":927},"code":"  it('can check invalid construction of controller', done => {\n    // Make mock request\n    const request = {\n      auth: {\n        isMaster: true\n      },\n      query: {},\n      config: {\n        loggerController: undefined // missing controller\n      }\n    };\n\n    const router = new LogsRouter();\n    expect(() => {\n      router.validateRequest(request);\n    }).toThrow();\n    done();\n  });","file":"LogsRouter.spec.js","skipped":false,"dir":"spec"},{"name":"can check invalid master key of request","suites":[],"line":46,"updatePoint":{"line":46,"column":45,"index":1316},"code":"  it('can check invalid master key of request', done => {\n    request({\n      url: 'http://localhost:8378/1/scriptlog',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      }\n    }).then(fail, response => {\n      const body = response.data;\n      expect(response.status).toEqual(403);\n      expect(body.error).toEqual('unauthorized: master key is required');\n      done();\n    });\n  });","file":"LogsRouter.spec.js","skipped":false,"dir":"spec"},{"name":"does scrub simple passwords on GET login","suites":[],"line":69,"updatePoint":{"line":69,"column":46,"index":2011},"code":"  it('does scrub simple passwords on GET login', done => {\n    reconfigureServer({\n      verbose: true\n    }).then(function () {\n      request({\n        headers: headers,\n        url: 'http://localhost:8378/1/login?username=test&password=simplepass.com'\n      }).catch(() => {}).then(() => {\n        request({\n          url: 'http://localhost:8378/1/scriptlog?size=4&level=verbose',\n          headers: headers\n        }).then(response => {\n          const body = response.data;\n          expect(response.status).toEqual(200);\n          // 4th entry is our actual GET request\n          expect(body[2].url).toEqual('/1/login?username=test&password=********');\n          expect(body[2].message).toEqual('REQUEST for [GET] /1/login?username=test&password=********: {}');\n          done();\n        });\n      });\n    });\n  });","file":"LogsRouter.spec.js","skipped":false,"dir":"spec"},{"name":"does scrub complex passwords on GET login","suites":[],"line":95,"updatePoint":{"line":95,"column":47,"index":2958},"code":"  it('does scrub complex passwords on GET login', done => {\n    reconfigureServer({\n      verbose: true\n    }).then(function () {\n      return request({\n        headers: headers,\n        // using urlencoded password, 'simple @,/?:&=+$#pass.com'\n        url: 'http://localhost:8378/1/login?username=test&password=simple%20%40%2C%2F%3F%3A%26%3D%2B%24%23pass.com'\n      }).catch(() => {}).then(() => {\n        return request({\n          url: 'http://localhost:8378/1/scriptlog?size=4&level=verbose',\n          headers: headers\n        }).then(response => {\n          const body = response.data;\n          expect(response.status).toEqual(200);\n          // 4th entry is our actual GET request\n          expect(body[2].url).toEqual('/1/login?username=test&password=********');\n          expect(body[2].message).toEqual('REQUEST for [GET] /1/login?username=test&password=********: {}');\n          done();\n        });\n      });\n    }).catch(done.fail);\n  });","file":"LogsRouter.spec.js","skipped":false,"dir":"spec"},{"name":"does not have password field in POST login","suites":[],"line":122,"updatePoint":{"line":122,"column":48,"index":4003},"code":"  it('does not have password field in POST login', done => {\n    reconfigureServer({\n      verbose: true\n    }).then(function () {\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/login',\n        body: {\n          username: 'test',\n          password: 'simplepass.com'\n        }\n      }).catch(() => {}).then(() => {\n        request({\n          url: 'http://localhost:8378/1/scriptlog?size=4&level=verbose',\n          headers: headers\n        }).then(response => {\n          const body = response.data;\n          expect(response.status).toEqual(200);\n          // 4th entry is our actual GET request\n          expect(body[2].url).toEqual('/1/login');\n          expect(body[2].message).toEqual('REQUEST for [POST] /1/login: {\\n  \"username\": \"test\",\\n  \"password\": \"********\"\\n}');\n          done();\n        });\n      });\n    });\n  });","file":"LogsRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should use _ContentType if provided","suites":["middlewares"],"line":23,"updatePoint":{"line":23,"column":41,"index":679},"code":"  it('should use _ContentType if provided', done => {\n    expect(fakeReq.headers['content-type']).toEqual(undefined);\n    const contentType = 'image/jpeg';\n    fakeReq.body._ContentType = contentType;\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeReq.headers['content-type']).toEqual(contentType);\n      expect(fakeReq.body._ContentType).toEqual(undefined);\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should give invalid response when keys are configured but no key supplied","suites":["middlewares"],"line":33,"updatePoint":{"line":33,"column":79,"index":1135},"code":"  it('should give invalid response when keys are configured but no key supplied', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey'\n    });\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should give invalid response when keys are configured but supplied key is incorrect","suites":["middlewares"],"line":41,"updatePoint":{"line":41,"column":89,"index":1466},"code":"  it('should give invalid response when keys are configured but supplied key is incorrect', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey'\n    });\n    fakeReq.headers['x-parse-rest-api-key'] = 'wrongKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should give invalid response when keys are configured but different key is supplied","suites":["middlewares"],"line":50,"updatePoint":{"line":50,"column":89,"index":1855},"code":"  it('should give invalid response when keys are configured but different key is supplied', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey'\n    });\n    fakeReq.headers['x-parse-client-key'] = 'clientKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed when any one of the configured keys supplied","suites":["middlewares"],"line":59,"updatePoint":{"line":59,"column":65,"index":2219},"code":"  it('should succeed when any one of the configured keys supplied', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      clientKey: 'clientKey',\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey'\n    });\n    fakeReq.headers['x-parse-rest-api-key'] = 'restAPIKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed when client key supplied but empty","suites":["middlewares"],"line":71,"updatePoint":{"line":71,"column":55,"index":2636},"code":"  it('should succeed when client key supplied but empty', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      clientKey: '',\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey'\n    });\n    fakeReq.headers['x-parse-client-key'] = '';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed when no keys are configured and none supplied","suites":["middlewares"],"line":83,"updatePoint":{"line":83,"column":66,"index":3043},"code":"  it('should succeed when no keys are configured and none supplied', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey'\n    });\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"it should pull  into req.info","suites":["middlewares"],"line":105,"updatePoint":{"line":105,"column":47,"index":3853},"code":"    it(`it should pull ${bodyKey} into req.info`, done => {\n      fakeReq.body[bodyKey] = keyValue;\n      middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n        expect(fakeReq.body[bodyKey]).toEqual(undefined);\n        expect(fakeReq.info[infoKey]).toEqual(keyValue);\n        otherKeys.forEach(otherKey => {\n          expect(fakeReq.info[otherKey]).toEqual(undefined);\n        });\n        done();\n      });\n    });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should not succeed if the ip does not belong to masterKeyIps list","suites":["middlewares"],"line":117,"updatePoint":{"line":117,"column":71,"index":4308},"code":"  it('should not succeed if the ip does not belong to masterKeyIps list', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2']\n    });\n    fakeReq.ip = 'ip3';\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed if the ip does belong to masterKeyIps list","suites":["middlewares"],"line":127,"updatePoint":{"line":127,"column":63,"index":4698},"code":"  it('should succeed if the ip does belong to masterKeyIps list', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2']\n    });\n    fakeReq.ip = 'ip1';\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should not succeed if the connection.remoteAddress does not belong to masterKeyIps list","suites":["middlewares"],"line":139,"updatePoint":{"line":139,"column":93,"index":5148},"code":"  it('should not succeed if the connection.remoteAddress does not belong to masterKeyIps list', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2']\n    });\n    fakeReq.connection = {\n      remoteAddress: 'ip3'\n    };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed if the connection.remoteAddress does belong to masterKeyIps list","suites":["middlewares"],"line":151,"updatePoint":{"line":151,"column":85,"index":5597},"code":"  it('should succeed if the connection.remoteAddress does belong to masterKeyIps list', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2']\n    });\n    fakeReq.connection = {\n      remoteAddress: 'ip1'\n    };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should not succeed if the socket.remoteAddress does not belong to masterKeyIps list","suites":["middlewares"],"line":165,"updatePoint":{"line":165,"column":89,"index":6080},"code":"  it('should not succeed if the socket.remoteAddress does not belong to masterKeyIps list', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2']\n    });\n    fakeReq.socket = {\n      remoteAddress: 'ip3'\n    };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed if the socket.remoteAddress does belong to masterKeyIps list","suites":["middlewares"],"line":177,"updatePoint":{"line":177,"column":81,"index":6521},"code":"  it('should succeed if the socket.remoteAddress does belong to masterKeyIps list', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2']\n    });\n    fakeReq.socket = {\n      remoteAddress: 'ip1'\n    };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should not succeed if the connection.socket.remoteAddress does not belong to masterKeyIps list","suites":["middlewares"],"line":191,"updatePoint":{"line":191,"column":100,"index":7011},"code":"  it('should not succeed if the connection.socket.remoteAddress does not belong to masterKeyIps list', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2']\n    });\n    fakeReq.connection = {\n      socket: {\n        remoteAddress: 'ip3'\n      }\n    };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed if the connection.socket.remoteAddress does belong to masterKeyIps list","suites":["middlewares"],"line":205,"updatePoint":{"line":205,"column":92,"index":7493},"code":"  it('should succeed if the connection.socket.remoteAddress does belong to masterKeyIps list', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2']\n    });\n    fakeReq.connection = {\n      socket: {\n        remoteAddress: 'ip1'\n      }\n    };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should allow any ip to use masterKey if masterKeyIps is empty","suites":["middlewares"],"line":221,"updatePoint":{"line":221,"column":67,"index":7980},"code":"  it('should allow any ip to use masterKey if masterKeyIps is empty', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: []\n    });\n    fakeReq.ip = 'ip1';\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed if xff header does belong to masterKeyIps","suites":["middlewares"],"line":233,"updatePoint":{"line":233,"column":62,"index":8387},"code":"  it('should succeed if xff header does belong to masterKeyIps', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1']\n    });\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    fakeReq.headers['x-forwarded-for'] = 'ip1, ip2, ip3';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed if xff header with one ip does belong to masterKeyIps","suites":["middlewares"],"line":245,"updatePoint":{"line":245,"column":74,"index":8845},"code":"  it('should succeed if xff header with one ip does belong to masterKeyIps', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1']\n    });\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    fakeReq.headers['x-forwarded-for'] = 'ip1';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should not succeed if xff header does not belong to masterKeyIps","suites":["middlewares"],"line":257,"updatePoint":{"line":257,"column":70,"index":9289},"code":"  it('should not succeed if xff header does not belong to masterKeyIps', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip4']\n    });\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    fakeReq.headers['x-forwarded-for'] = 'ip1, ip2, ip3';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should not succeed if xff header is empty and masterKeyIps is set","suites":["middlewares"],"line":267,"updatePoint":{"line":267,"column":71,"index":9714},"code":"  it('should not succeed if xff header is empty and masterKeyIps is set', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1']\n    });\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    fakeReq.headers['x-forwarded-for'] = '';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should properly expose the headers","suites":["middlewares"],"line":277,"updatePoint":{"line":277,"column":40,"index":10095},"code":"  it('should properly expose the headers', () => {\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      }\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(Object.keys(headers).length).toBe(4);\n    expect(headers['Access-Control-Expose-Headers']).toBe('X-Parse-Job-Status-Id, X-Parse-Push-Status-Id');\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should set default Access-Control-Allow-Headers if allowHeaders are empty","suites":["middlewares"],"line":289,"updatePoint":{"line":289,"column":79,"index":10601},"code":"  it('should set default Access-Control-Allow-Headers if allowHeaders are empty', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowHeaders: undefined\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      }\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Headers']).toContain(middlewares.DEFAULT_ALLOWED_HEADERS);\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowHeaders: []\n    });\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Headers']).toContain(middlewares.DEFAULT_ALLOWED_HEADERS);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should append custom headers to Access-Control-Allow-Headers if allowHeaders provided","suites":["middlewares"],"line":308,"updatePoint":{"line":308,"column":91,"index":11373},"code":"  it('should append custom headers to Access-Control-Allow-Headers if allowHeaders provided', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowHeaders: ['Header-1', 'Header-2']\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      }\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Headers']).toContain('Header-1, Header-2');\n    expect(headers['Access-Control-Allow-Headers']).toContain(middlewares.DEFAULT_ALLOWED_HEADERS);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should set default Access-Control-Allow-Origin if allowOrigin is empty","suites":["middlewares"],"line":323,"updatePoint":{"line":323,"column":76,"index":12005},"code":"  it('should set default Access-Control-Allow-Origin if allowOrigin is empty', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowOrigin: undefined\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      }\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Origin']).toEqual('*');\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should set custom origin to Access-Control-Allow-Origin if allowOrigin is provided","suites":["middlewares"],"line":337,"updatePoint":{"line":337,"column":88,"index":12513},"code":"  it('should set custom origin to Access-Control-Allow-Origin if allowOrigin is provided', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowOrigin: 'https://parseplatform.org/'\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      }\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Origin']).toEqual('https://parseplatform.org/');\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should use user provided on field userFromJWT","suites":["middlewares"],"line":351,"updatePoint":{"line":351,"column":51,"index":13028},"code":"  it('should use user provided on field userFromJWT', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey'\n    });\n    fakeReq.userFromJWT = 'fake-user';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeReq.auth.user).toEqual('fake-user');\n      done();\n    });\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"should give invalid response when upload file without x-parse-application-id in header","suites":["middlewares"],"line":361,"updatePoint":{"line":361,"column":92,"index":13400},"code":"  it('should give invalid response when upload file without x-parse-application-id in header', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey'\n    });\n    fakeReq.body = Buffer.from('fake-file');\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });","file":"Middlewares.spec.js","skipped":false,"dir":"spec"},{"name":"can transform legacy _client_permissions keys to parse format","suites":["MongoSchemaCollection"],"line":5,"updatePoint":{"line":5,"column":67,"index":227},"code":"  it('can transform legacy _client_permissions keys to parse format', done => {\n    expect(MongoSchemaCollection._TESTmongoSchemaToParseSchema({\n      _id: '_Installation',\n      _client_permissions: {\n        get: true,\n        find: true,\n        count: true,\n        update: true,\n        create: true,\n        delete: true\n      },\n      _metadata: {\n        class_permissions: {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          count: {\n            '*': true\n          },\n          update: {\n            '*': true\n          },\n          create: {\n            '*': true\n          },\n          delete: {\n            '*': true\n          },\n          addField: {\n            '*': true\n          },\n          protectedFields: {\n            '*': []\n          }\n        },\n        indexes: {\n          name1: {\n            deviceToken: 1\n          }\n        }\n      },\n      installationId: 'string',\n      deviceToken: 'string',\n      deviceType: 'string',\n      channels: 'array',\n      user: '*_User',\n      pushType: 'string',\n      GCMSenderId: 'string',\n      timeZone: 'string',\n      localeIdentifier: 'string',\n      badge: 'number',\n      appVersion: 'string',\n      appName: 'string',\n      appIdentifier: 'string',\n      parseVersion: 'string'\n    })).toEqual({\n      className: '_Installation',\n      fields: {\n        installationId: {\n          type: 'String'\n        },\n        deviceToken: {\n          type: 'String'\n        },\n        deviceType: {\n          type: 'String'\n        },\n        channels: {\n          type: 'Array'\n        },\n        user: {\n          type: 'Pointer',\n          targetClass: '_User'\n        },\n        pushType: {\n          type: 'String'\n        },\n        GCMSenderId: {\n          type: 'String'\n        },\n        timeZone: {\n          type: 'String'\n        },\n        localeIdentifier: {\n          type: 'String'\n        },\n        badge: {\n          type: 'Number'\n        },\n        appVersion: {\n          type: 'String'\n        },\n        appName: {\n          type: 'String'\n        },\n        appIdentifier: {\n          type: 'String'\n        },\n        parseVersion: {\n          type: 'String'\n        },\n        ACL: {\n          type: 'ACL'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        objectId: {\n          type: 'String'\n        }\n      },\n      classLevelPermissions: {\n        find: {\n          '*': true\n        },\n        get: {\n          '*': true\n        },\n        count: {\n          '*': true\n        },\n        create: {\n          '*': true\n        },\n        update: {\n          '*': true\n        },\n        delete: {\n          '*': true\n        },\n        addField: {\n          '*': true\n        },\n        protectedFields: {\n          '*': []\n        }\n      },\n      indexes: {\n        name1: {\n          deviceToken: 1\n        }\n      }\n    });\n    done();\n  });","file":"MongoSchemaCollectionAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"auto-escapes symbols in auth information","suites":[],"line":31,"updatePoint":{"line":31,"column":46,"index":936},"code":"  it('auto-escapes symbols in auth information', () => {\n    spyOn(MongoClient, 'connect').and.returnValue(Promise.resolve(fakeClient));\n    new MongoStorageAdapter({\n      uri: 'mongodb://user!with@+ symbols:password!with@+ symbols@localhost:1234/parse'\n    }).connect();\n    expect(MongoClient.connect).toHaveBeenCalledWith('mongodb://user!with%40%2B%20symbols:password!with%40%2B%20symbols@localhost:1234/parse', jasmine.any(Object));\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"doesn't double escape already URI-encoded information","suites":[],"line":38,"updatePoint":{"line":38,"column":59,"index":1393},"code":"  it(\"doesn't double escape already URI-encoded information\", () => {\n    spyOn(MongoClient, 'connect').and.returnValue(Promise.resolve(fakeClient));\n    new MongoStorageAdapter({\n      uri: 'mongodb://user!with%40%2B%20symbols:password!with%40%2B%20symbols@localhost:1234/parse'\n    }).connect();\n    expect(MongoClient.connect).toHaveBeenCalledWith('mongodb://user!with%40%2B%20symbols:password!with%40%2B%20symbols@localhost:1234/parse', jasmine.any(Object));\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"preserves replica sets","suites":[],"line":47,"updatePoint":{"line":47,"column":28,"index":1917},"code":"  it('preserves replica sets', () => {\n    spyOn(MongoClient, 'connect').and.returnValue(Promise.resolve(fakeClient));\n    new MongoStorageAdapter({\n      uri: 'mongodb://test:testpass@ds056315-a0.mongolab.com:59325,ds059315-a1.mongolab.com:59315/testDBname?replicaSet=rs-ds059415'\n    }).connect();\n    expect(MongoClient.connect).toHaveBeenCalledWith('mongodb://test:testpass@ds056315-a0.mongolab.com:59325,ds059315-a1.mongolab.com:59315/testDBname?replicaSet=rs-ds059415', jasmine.any(Object));\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"stores objectId in _id","suites":[],"line":54,"updatePoint":{"line":54,"column":28,"index":2421},"code":"  it('stores objectId in _id', done => {\n    const adapter = new MongoStorageAdapter({\n      uri: databaseURI\n    });\n    adapter.createObject('Foo', {\n      fields: {}\n    }, {\n      objectId: 'abcde'\n    }).then(() => adapter._rawFind('Foo', {})).then(results => {\n      expect(results.length).toEqual(1);\n      const obj = results[0];\n      expect(obj._id).toEqual('abcde');\n      expect(obj.objectId).toBeUndefined();\n      done();\n    });\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"find succeeds when query is within maxTimeMS","suites":[],"line":70,"updatePoint":{"line":70,"column":50,"index":2893},"code":"  it('find succeeds when query is within maxTimeMS', done => {\n    const maxTimeMS = 250;\n    const adapter = new MongoStorageAdapter({\n      uri: databaseURI,\n      mongoOptions: {\n        maxTimeMS\n      }\n    });\n    adapter.createObject('Foo', {\n      fields: {}\n    }, {\n      objectId: 'abcde'\n    }).then(() => adapter._rawFind('Foo', {\n      $where: `sleep(${maxTimeMS / 2})`\n    })).then(() => done(), err => {\n      done.fail(`maxTimeMS should not affect fast queries ${err}`);\n    });\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"find fails when query exceeds maxTimeMS","suites":[],"line":88,"updatePoint":{"line":88,"column":45,"index":3390},"code":"  it('find fails when query exceeds maxTimeMS', done => {\n    const maxTimeMS = 250;\n    const adapter = new MongoStorageAdapter({\n      uri: databaseURI,\n      mongoOptions: {\n        maxTimeMS\n      }\n    });\n    adapter.createObject('Foo', {\n      fields: {}\n    }, {\n      objectId: 'abcde'\n    }).then(() => adapter._rawFind('Foo', {\n      $where: `sleep(${maxTimeMS * 2})`\n    })).then(() => {\n      done.fail('Find succeeded despite taking too long!');\n    }, err => {\n      expect(err.name).toEqual('MongoServerError');\n      expect(err.code).toEqual(50);\n      expect(err.message).toMatch('operation exceeded time limit');\n      done();\n    });\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"stores pointers with a _p_ prefix","suites":[],"line":111,"updatePoint":{"line":111,"column":39,"index":4044},"code":"  it('stores pointers with a _p_ prefix', done => {\n    const obj = {\n      objectId: 'bar',\n      aPointer: {\n        __type: 'Pointer',\n        className: 'JustThePointer',\n        objectId: 'qwerty'\n      }\n    };\n    const adapter = new MongoStorageAdapter({\n      uri: databaseURI\n    });\n    adapter.createObject('APointerDarkly', {\n      fields: {\n        objectId: {\n          type: 'String'\n        },\n        aPointer: {\n          type: 'Pointer',\n          targetClass: 'JustThePointer'\n        }\n      }\n    }, obj).then(() => adapter._rawFind('APointerDarkly', {})).then(results => {\n      expect(results.length).toEqual(1);\n      const output = results[0];\n      expect(typeof output._id).toEqual('string');\n      expect(typeof output._p_aPointer).toEqual('string');\n      expect(output._p_aPointer).toEqual('JustThePointer$qwerty');\n      expect(output.aPointer).toBeUndefined();\n      done();\n    });\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"handles object and subdocument","suites":[],"line":143,"updatePoint":{"line":143,"column":36,"index":4964},"code":"  it('handles object and subdocument', done => {\n    const adapter = new MongoStorageAdapter({\n      uri: databaseURI\n    });\n    const schema = {\n      fields: {\n        subdoc: {\n          type: 'Object'\n        }\n      }\n    };\n    const obj = {\n      subdoc: {\n        foo: 'bar',\n        wu: 'tan'\n      }\n    };\n    adapter.createObject('MyClass', schema, obj).then(() => adapter._rawFind('MyClass', {})).then(results => {\n      expect(results.length).toEqual(1);\n      const mob = results[0];\n      expect(typeof mob.subdoc).toBe('object');\n      expect(mob.subdoc.foo).toBe('bar');\n      expect(mob.subdoc.wu).toBe('tan');\n      const obj = {\n        'subdoc.wu': 'clan'\n      };\n      return adapter.findOneAndUpdate('MyClass', schema, {}, obj);\n    }).then(() => adapter._rawFind('MyClass', {})).then(results => {\n      expect(results.length).toEqual(1);\n      const mob = results[0];\n      expect(typeof mob.subdoc).toBe('object');\n      expect(mob.subdoc.foo).toBe('bar');\n      expect(mob.subdoc.wu).toBe('clan');\n      done();\n    });\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"handles creating an array, object, date","suites":[],"line":179,"updatePoint":{"line":179,"column":45,"index":6028},"code":"  it('handles creating an array, object, date', done => {\n    const adapter = new MongoStorageAdapter({\n      uri: databaseURI\n    });\n    const obj = {\n      array: [1, 2, 3],\n      object: {\n        foo: 'bar'\n      },\n      date: {\n        __type: 'Date',\n        iso: '2016-05-26T20:55:01.154Z'\n      }\n    };\n    const schema = {\n      fields: {\n        array: {\n          type: 'Array'\n        },\n        object: {\n          type: 'Object'\n        },\n        date: {\n          type: 'Date'\n        }\n      }\n    };\n    adapter.createObject('MyClass', schema, obj).then(() => adapter._rawFind('MyClass', {})).then(results => {\n      expect(results.length).toEqual(1);\n      const mob = results[0];\n      expect(mob.array instanceof Array).toBe(true);\n      expect(typeof mob.object).toBe('object');\n      expect(mob.date instanceof Date).toBe(true);\n      return adapter.find('MyClass', schema, {}, {});\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      const mob = results[0];\n      expect(mob.array instanceof Array).toBe(true);\n      expect(typeof mob.object).toBe('object');\n      expect(mob.date.__type).toBe('Date');\n      expect(mob.date.iso).toBe('2016-05-26T20:55:01.154Z');\n      done();\n    }).catch(error => {\n      console.log(error);\n      fail();\n      done();\n    });\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"handles updating a single object with array, object date","suites":[],"line":227,"updatePoint":{"line":227,"column":62,"index":7362},"code":"  it('handles updating a single object with array, object date', done => {\n    const adapter = new MongoStorageAdapter({\n      uri: databaseURI\n    });\n    const schema = {\n      fields: {\n        array: {\n          type: 'Array'\n        },\n        object: {\n          type: 'Object'\n        },\n        date: {\n          type: 'Date'\n        }\n      }\n    };\n    adapter.createObject('MyClass', schema, {}).then(() => adapter._rawFind('MyClass', {})).then(results => {\n      expect(results.length).toEqual(1);\n      const update = {\n        array: [1, 2, 3],\n        object: {\n          foo: 'bar'\n        },\n        date: {\n          __type: 'Date',\n          iso: '2016-05-26T20:55:01.154Z'\n        }\n      };\n      const query = {};\n      return adapter.findOneAndUpdate('MyClass', schema, query, update);\n    }).then(results => {\n      const mob = results;\n      expect(mob.array instanceof Array).toBe(true);\n      expect(typeof mob.object).toBe('object');\n      expect(mob.date.__type).toBe('Date');\n      expect(mob.date.iso).toBe('2016-05-26T20:55:01.154Z');\n      return adapter._rawFind('MyClass', {});\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      const mob = results[0];\n      expect(mob.array instanceof Array).toBe(true);\n      expect(typeof mob.object).toBe('object');\n      expect(mob.date instanceof Date).toBe(true);\n      done();\n    }).catch(error => {\n      console.log(error);\n      fail();\n      done();\n    });\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"handleShutdown, close connection","suites":[],"line":278,"updatePoint":{"line":278,"column":38,"index":8805},"code":"  it('handleShutdown, close connection', async () => {\n    const adapter = new MongoStorageAdapter({\n      uri: databaseURI\n    });\n    const schema = {\n      fields: {\n        array: {\n          type: 'Array'\n        },\n        object: {\n          type: 'Object'\n        },\n        date: {\n          type: 'Date'\n        }\n      }\n    };\n    await adapter.createObject('MyClass', schema, {});\n    const status = await adapter.database.admin().serverStatus();\n    expect(status.connections.current > 0).toEqual(true);\n    await adapter.handleShutdown();\n    try {\n      await adapter.database.admin().serverStatus();\n      expect(false).toBe(true);\n    } catch (e) {\n      expect(e.message).toEqual('Client must be connected before running operations');\n    }\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"getClass if exists","suites":[],"line":306,"updatePoint":{"line":306,"column":24,"index":9557},"code":"  it('getClass if exists', async () => {\n    const adapter = new MongoStorageAdapter({\n      uri: databaseURI\n    });\n    const schema = {\n      fields: {\n        array: {\n          type: 'Array'\n        },\n        object: {\n          type: 'Object'\n        },\n        date: {\n          type: 'Date'\n        }\n      }\n    };\n    await adapter.createClass('MyClass', schema);\n    const myClassSchema = await adapter.getClass('MyClass');\n    expect(myClassSchema).toBeDefined();\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"getClass if not exists","suites":[],"line":327,"updatePoint":{"line":327,"column":28,"index":10044},"code":"  it('getClass if not exists', async () => {\n    const adapter = new MongoStorageAdapter({\n      uri: databaseURI\n    });\n    await expectAsync(adapter.getClass('UnknownClass')).toBeRejectedWith(undefined);\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should delete field without index","suites":[],"line":381,"updatePoint":{"line":381,"column":39,"index":12196},"code":"  it('should delete field without index', async () => {\n    const database = Config.get(Parse.applicationId).database;\n    const obj = new Parse.Object('MyObject');\n    obj.set('test', 1);\n    await obj.save();\n    const schemaBeforeDeletion = await new Parse.Schema('MyObject').get();\n    await database.adapter.deleteFields('MyObject', schemaBeforeDeletion, ['test']);\n    const schemaAfterDeletion = await new Parse.Schema('MyObject').get();\n    expect(schemaBeforeDeletion.fields.test).toBeDefined();\n    expect(schemaAfterDeletion.fields.test).toBeUndefined();\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should delete field with index","suites":[],"line":392,"updatePoint":{"line":392,"column":36,"index":12765},"code":"  it('should delete field with index', async () => {\n    const database = Config.get(Parse.applicationId).database;\n    const obj = new Parse.Object('MyObject');\n    obj.set('test', 1);\n    await obj.save();\n    const schemaBeforeDeletion = await new Parse.Schema('MyObject').get();\n    await database.adapter.ensureIndex('MyObject', schemaBeforeDeletion, ['test']);\n    await database.adapter.deleteFields('MyObject', schemaBeforeDeletion, ['test']);\n    const schemaAfterDeletion = await new Parse.Schema('MyObject').get();\n    expect(schemaBeforeDeletion.fields.test).toBeDefined();\n    expect(schemaAfterDeletion.fields.test).toBeUndefined();\n  });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should use transaction in a batch with transaction = true","suites":["transactions"],"line":418,"updatePoint":{"line":418,"column":67,"index":14105},"code":"      it('should use transaction in a batch with transaction = true', async () => {\n        const myObject = new Parse.Object('MyObject');\n        await myObject.save();\n        spyOn(Collection.prototype, 'findOneAndUpdate').and.callThrough();\n        await request({\n          method: 'POST',\n          headers: headers,\n          url: 'http://localhost:8378/1/batch',\n          body: JSON.stringify({\n            requests: [{\n              method: 'PUT',\n              path: '/1/classes/MyObject/' + myObject.id,\n              body: {\n                myAttribute: 'myValue'\n              }\n            }],\n            transaction: true\n          })\n        });\n        let found = false;\n        Collection.prototype.findOneAndUpdate.calls.all().forEach(call => {\n          found = true;\n          expect(call.args[2].session.transaction.state).toBe('TRANSACTION_COMMITTED');\n        });\n        expect(found).toBe(true);\n      });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should not use transaction in a batch with transaction = false","suites":["transactions"],"line":444,"updatePoint":{"line":444,"column":72,"index":15045},"code":"      it('should not use transaction in a batch with transaction = false', async () => {\n        const myObject = new Parse.Object('MyObject');\n        await myObject.save();\n        spyOn(Collection.prototype, 'findOneAndUpdate').and.callThrough();\n        await request({\n          method: 'POST',\n          headers: headers,\n          url: 'http://localhost:8378/1/batch',\n          body: JSON.stringify({\n            requests: [{\n              method: 'PUT',\n              path: '/1/classes/MyObject/' + myObject.id,\n              body: {\n                myAttribute: 'myValue'\n              }\n            }],\n            transaction: false\n          })\n        });\n        let found = false;\n        Collection.prototype.findOneAndUpdate.calls.all().forEach(call => {\n          found = true;\n          expect(call.args[2].session).toBeFalsy();\n        });\n        expect(found).toBe(true);\n      });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should not use transaction in a batch with no transaction option sent","suites":["transactions"],"line":470,"updatePoint":{"line":470,"column":79,"index":15957},"code":"      it('should not use transaction in a batch with no transaction option sent', async () => {\n        const myObject = new Parse.Object('MyObject');\n        await myObject.save();\n        spyOn(Collection.prototype, 'findOneAndUpdate').and.callThrough();\n        await request({\n          method: 'POST',\n          headers: headers,\n          url: 'http://localhost:8378/1/batch',\n          body: JSON.stringify({\n            requests: [{\n              method: 'PUT',\n              path: '/1/classes/MyObject/' + myObject.id,\n              body: {\n                myAttribute: 'myValue'\n              }\n            }]\n          })\n        });\n        let found = false;\n        Collection.prototype.findOneAndUpdate.calls.all().forEach(call => {\n          found = true;\n          expect(call.args[2].session).toBeFalsy();\n        });\n        expect(found).toBe(true);\n      });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should not use transaction in a put request","suites":["transactions"],"line":495,"updatePoint":{"line":495,"column":53,"index":16811},"code":"      it('should not use transaction in a put request', async () => {\n        const myObject = new Parse.Object('MyObject');\n        await myObject.save();\n        spyOn(Collection.prototype, 'findOneAndUpdate').and.callThrough();\n        await request({\n          method: 'PUT',\n          headers: headers,\n          url: 'http://localhost:8378/1/classes/MyObject/' + myObject.id,\n          body: {\n            myAttribute: 'myValue'\n          }\n        });\n        let found = false;\n        Collection.prototype.findOneAndUpdate.calls.all().forEach(call => {\n          found = true;\n          expect(call.args[2].session).toBeFalsy();\n        });\n        expect(found).toBe(true);\n      });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should not use transactions when using SDK insert","suites":["transactions"],"line":514,"updatePoint":{"line":514,"column":59,"index":17511},"code":"      it('should not use transactions when using SDK insert', async () => {\n        spyOn(Collection.prototype, 'insertOne').and.callThrough();\n        const myObject = new Parse.Object('MyObject');\n        await myObject.save();\n        const calls = Collection.prototype.insertOne.calls.all();\n        expect(calls.length).toBeGreaterThan(0);\n        calls.forEach(call => {\n          expect(call.args[1].session).toBeFalsy();\n        });\n      });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should not use transactions when using SDK update","suites":["transactions"],"line":524,"updatePoint":{"line":524,"column":59,"index":17962},"code":"      it('should not use transactions when using SDK update', async () => {\n        spyOn(Collection.prototype, 'findOneAndUpdate').and.callThrough();\n        const myObject = new Parse.Object('MyObject');\n        await myObject.save();\n        myObject.set('myAttribute', 'myValue');\n        await myObject.save();\n        const calls = Collection.prototype.findOneAndUpdate.calls.all();\n        expect(calls.length).toBeGreaterThan(0);\n        calls.forEach(call => {\n          expect(call.args[2].session).toBeFalsy();\n        });\n      });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should not use transactions when using SDK delete","suites":["transactions"],"line":536,"updatePoint":{"line":536,"column":59,"index":18506},"code":"      it('should not use transactions when using SDK delete', async () => {\n        spyOn(Collection.prototype, 'deleteMany').and.callThrough();\n        const myObject = new Parse.Object('MyObject');\n        await myObject.save();\n        await myObject.destroy();\n        const calls = Collection.prototype.deleteMany.calls.all();\n        expect(calls.length).toBeGreaterThan(0);\n        calls.forEach(call => {\n          expect(call.args[1].session).toBeFalsy();\n        });\n      });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should change","suites":["watch _SCHEMA"],"line":549,"updatePoint":{"line":549,"column":23,"index":19003},"code":"      it('should change', async done => {\n        const adapter = new MongoStorageAdapter({\n          uri: databaseURI,\n          collectionPrefix: '',\n          mongoOptions: {\n            enableSchemaHooks: true\n          }\n        });\n        await reconfigureServer({\n          databaseAdapter: adapter\n        });\n        expect(adapter.enableSchemaHooks).toBe(true);\n        spyOn(adapter, '_onchange');\n        const schema = {\n          fields: {\n            array: {\n              type: 'Array'\n            },\n            object: {\n              type: 'Object'\n            },\n            date: {\n              type: 'Date'\n            }\n          }\n        };\n        await adapter.createClass('Stuff', schema);\n        const myClassSchema = await adapter.getClass('Stuff');\n        expect(myClassSchema).toBeDefined();\n        setTimeout(() => {\n          expect(adapter._onchange).toHaveBeenCalled();\n          done();\n        }, 5000);\n      });","file":"MongoStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"a basic number","suites":["parseObjectToMongoObjectForCreate"],"line":9,"updatePoint":{"line":9,"column":20,"index":339},"code":"  it('a basic number', done => {\n    const input = {\n      five: 5\n    };\n    const output = transform.parseObjectToMongoObjectForCreate(null, input, {\n      fields: {\n        five: {\n          type: 'Number'\n        }\n      }\n    });\n    jequal(input, output);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"an object with null values","suites":["parseObjectToMongoObjectForCreate"],"line":23,"updatePoint":{"line":23,"column":32,"index":631},"code":"  it('an object with null values', done => {\n    const input = {\n      objectWithNullValues: {\n        isNull: null,\n        notNull: 3\n      }\n    };\n    const output = transform.parseObjectToMongoObjectForCreate(null, input, {\n      fields: {\n        objectWithNullValues: {\n          type: 'object'\n        }\n      }\n    });\n    jequal(input, output);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"built-in timestamps with date","suites":["parseObjectToMongoObjectForCreate"],"line":40,"updatePoint":{"line":40,"column":35,"index":1007},"code":"  it('built-in timestamps with date', done => {\n    const input = {\n      createdAt: '2015-10-06T21:24:50.332Z',\n      updatedAt: '2015-10-06T21:24:50.332Z'\n    };\n    const output = transform.parseObjectToMongoObjectForCreate(null, input, {\n      fields: {}\n    });\n    expect(output._created_at instanceof Date).toBe(true);\n    expect(output._updated_at instanceof Date).toBe(true);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"array of pointers","suites":["parseObjectToMongoObjectForCreate"],"line":52,"updatePoint":{"line":52,"column":23,"index":1398},"code":"  it('array of pointers', done => {\n    const pointer = {\n      __type: 'Pointer',\n      objectId: 'myId',\n      className: 'Blah'\n    };\n    const out = transform.parseObjectToMongoObjectForCreate(null, {\n      pointers: [pointer]\n    }, {\n      fields: {\n        pointers: {\n          type: 'Array'\n        }\n      }\n    });\n    jequal([pointer], out.pointers);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"a delete op","suites":["parseObjectToMongoObjectForCreate"],"line":73,"updatePoint":{"line":73,"column":18,"index":1952},"skipped":true,"code":"  xit('a delete op', done => {\n    const input = {\n      deleteMe: {\n        __op: 'Delete'\n      }\n    };\n    const output = transform.parseObjectToMongoObjectForCreate(null, input, {\n      fields: {}\n    });\n    jequal(output, {});\n    done();\n  });","file":"MongoTransform.spec.js","dir":"spec"},{"name":"Doesnt allow ACL, as Parse Server should tranform ACL to _wperm + _rperm","suites":["parseObjectToMongoObjectForCreate"],"line":85,"updatePoint":{"line":85,"column":78,"index":2264},"code":"  it('Doesnt allow ACL, as Parse Server should tranform ACL to _wperm + _rperm', done => {\n    const input = {\n      ACL: {\n        '0123': {\n          read: true,\n          write: true\n        }\n      }\n    };\n    expect(() => transform.parseObjectToMongoObjectForCreate(null, input, {\n      fields: {}\n    })).toThrow();\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"parse geopoint to mongo","suites":["parseObjectToMongoObjectForCreate"],"line":99,"updatePoint":{"line":99,"column":29,"index":2556},"code":"  it('parse geopoint to mongo', done => {\n    const lat = -45;\n    const lng = 45;\n    const geoPoint = {\n      __type: 'GeoPoint',\n      latitude: lat,\n      longitude: lng\n    };\n    const out = transform.parseObjectToMongoObjectForCreate(null, {\n      location: geoPoint\n    }, {\n      fields: {\n        location: {\n          type: 'GeoPoint'\n        }\n      }\n    });\n    expect(out.location).toEqual([lng, lat]);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"parse polygon to mongo","suites":["parseObjectToMongoObjectForCreate"],"line":119,"updatePoint":{"line":119,"column":28,"index":2991},"code":"  it('parse polygon to mongo', done => {\n    const lat1 = -45;\n    const lng1 = 45;\n    const lat2 = -55;\n    const lng2 = 55;\n    const lat3 = -65;\n    const lng3 = 65;\n    const polygon = {\n      __type: 'Polygon',\n      coordinates: [[lat1, lng1], [lat2, lng2], [lat3, lng3]]\n    };\n    const out = transform.parseObjectToMongoObjectForCreate(null, {\n      location: polygon\n    }, {\n      fields: {\n        location: {\n          type: 'Polygon'\n        }\n      }\n    });\n    expect(out.location.coordinates).toEqual([[[lng1, lat1], [lng2, lat2], [lng3, lat3], [lng1, lat1]]]);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"in array","suites":["parseObjectToMongoObjectForCreate"],"line":142,"updatePoint":{"line":142,"column":14,"index":3576},"code":"  it('in array', done => {\n    const geoPoint = {\n      __type: 'GeoPoint',\n      longitude: 180,\n      latitude: -180\n    };\n    const out = transform.parseObjectToMongoObjectForCreate(null, {\n      locations: [geoPoint, geoPoint]\n    }, {\n      fields: {\n        locations: {\n          type: 'Array'\n        }\n      }\n    });\n    expect(out.locations).toEqual([geoPoint, geoPoint]);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"in sub-object","suites":["parseObjectToMongoObjectForCreate"],"line":160,"updatePoint":{"line":160,"column":19,"index":3984},"code":"  it('in sub-object', done => {\n    const geoPoint = {\n      __type: 'GeoPoint',\n      longitude: 180,\n      latitude: -180\n    };\n    const out = transform.parseObjectToMongoObjectForCreate(null, {\n      locations: {\n        start: geoPoint\n      }\n    }, {\n      fields: {\n        locations: {\n          type: 'Object'\n        }\n      }\n    });\n    expect(out).toEqual({\n      locations: {\n        start: geoPoint\n      }\n    });\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"objectId","suites":["parseObjectToMongoObjectForCreate"],"line":184,"updatePoint":{"line":184,"column":14,"index":4429},"code":"  it('objectId', done => {\n    const out = transform.transformWhere(null, {\n      objectId: 'foo'\n    });\n    expect(out._id).toEqual('foo');\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"objectId in a list","suites":["parseObjectToMongoObjectForCreate"],"line":191,"updatePoint":{"line":191,"column":24,"index":4599},"code":"  it('objectId in a list', done => {\n    const input = {\n      objectId: {\n        $in: ['one', 'two', 'three']\n      }\n    };\n    const output = transform.transformWhere(null, input);\n    jequal(input.objectId, output._id);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"built-in timestamps","suites":["parseObjectToMongoObjectForCreate"],"line":201,"updatePoint":{"line":201,"column":25,"index":4843},"code":"  it('built-in timestamps', done => {\n    const input = {\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {}\n    });\n    expect(typeof output.createdAt).toEqual('string');\n    expect(typeof output.updatedAt).toEqual('string');\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"pointer","suites":["parseObjectToMongoObjectForCreate"],"line":213,"updatePoint":{"line":213,"column":13,"index":5175},"code":"  it('pointer', done => {\n    const input = {\n      _p_userPointer: '_User$123'\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        userPointer: {\n          type: 'Pointer',\n          targetClass: '_User'\n        }\n      }\n    });\n    expect(typeof output.userPointer).toEqual('object');\n    expect(output.userPointer).toEqual({\n      __type: 'Pointer',\n      className: '_User',\n      objectId: '123'\n    });\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"null pointer","suites":["parseObjectToMongoObjectForCreate"],"line":233,"updatePoint":{"line":233,"column":18,"index":5656},"code":"  it('null pointer', done => {\n    const input = {\n      _p_userPointer: null\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        userPointer: {\n          type: 'Pointer',\n          targetClass: '_User'\n        }\n      }\n    });\n    expect(output.userPointer).toBeUndefined();\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"file","suites":["parseObjectToMongoObjectForCreate"],"line":248,"updatePoint":{"line":248,"column":10,"index":5991},"code":"  it('file', done => {\n    const input = {\n      picture: 'pic.jpg'\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        picture: {\n          type: 'File'\n        }\n      }\n    });\n    expect(typeof output.picture).toEqual('object');\n    expect(output.picture).toEqual({\n      __type: 'File',\n      name: 'pic.jpg'\n    });\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"mongo geopoint to parse","suites":["parseObjectToMongoObjectForCreate"],"line":266,"updatePoint":{"line":266,"column":29,"index":6398},"code":"  it('mongo geopoint to parse', done => {\n    const lat = -45;\n    const lng = 45;\n    const input = {\n      location: [lng, lat]\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        location: {\n          type: 'GeoPoint'\n        }\n      }\n    });\n    expect(typeof output.location).toEqual('object');\n    expect(output.location).toEqual({\n      __type: 'GeoPoint',\n      latitude: lat,\n      longitude: lng\n    });\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"mongo polygon to parse","suites":["parseObjectToMongoObjectForCreate"],"line":287,"updatePoint":{"line":287,"column":28,"index":6878},"code":"  it('mongo polygon to parse', done => {\n    const lat = -45;\n    const lng = 45;\n    // Mongo stores polygon in WGS84 lng/lat\n    const input = {\n      location: {\n        type: 'Polygon',\n        coordinates: [[[lat, lng], [lat, lng]]]\n      }\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        location: {\n          type: 'Polygon'\n        }\n      }\n    });\n    expect(typeof output.location).toEqual('object');\n    expect(output.location).toEqual({\n      __type: 'Polygon',\n      coordinates: [[lng, lat], [lng, lat]]\n    });\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"bytes","suites":["parseObjectToMongoObjectForCreate"],"line":311,"updatePoint":{"line":311,"column":11,"index":7458},"code":"  it('bytes', done => {\n    const input = {\n      binaryData: 'aGVsbG8gd29ybGQ='\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        binaryData: {\n          type: 'Bytes'\n        }\n      }\n    });\n    expect(typeof output.binaryData).toEqual('object');\n    expect(output.binaryData).toEqual({\n      __type: 'Bytes',\n      base64: 'aGVsbG8gd29ybGQ='\n    });\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"nested array","suites":["parseObjectToMongoObjectForCreate"],"line":329,"updatePoint":{"line":329,"column":18,"index":7888},"code":"  it('nested array', done => {\n    const input = {\n      arr: [{\n        _testKey: 'testValue'\n      }]\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        arr: {\n          type: 'Array'\n        }\n      }\n    });\n    expect(Array.isArray(output.arr)).toEqual(true);\n    expect(output.arr).toEqual([{\n      _testKey: 'testValue'\n    }]);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"untransforms objects containing nested special keys","suites":["parseObjectToMongoObjectForCreate"],"line":348,"updatePoint":{"line":348,"column":57,"index":8330},"code":"  it('untransforms objects containing nested special keys', done => {\n    const input = {\n      array: [{\n        _id: 'Test ID',\n        _hashed_password: \"I Don't know why you would name a key this, but if you do it should work\",\n        _tombstone: {\n          _updated_at: \"I'm sure people will nest keys like this\",\n          _acl: 7,\n          _id: {\n            someString: 'str',\n            someNumber: 7\n          },\n          regularKey: {\n            moreContents: [1, 2, 3]\n          }\n        },\n        regularKey: 'some data'\n      }]\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        array: {\n          type: 'Array'\n        }\n      }\n    });\n    expect(dd(output, input)).toEqual(undefined);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"changes new pointer key","suites":["parseObjectToMongoObjectForCreate"],"line":377,"updatePoint":{"line":377,"column":29,"index":9080},"code":"  it('changes new pointer key', done => {\n    const input = {\n      somePointer: {\n        __type: 'Pointer',\n        className: 'Micro',\n        objectId: 'oft'\n      }\n    };\n    const output = transform.parseObjectToMongoObjectForCreate(null, input, {\n      fields: {\n        somePointer: {\n          type: 'Pointer'\n        }\n      }\n    });\n    expect(typeof output._p_somePointer).toEqual('string');\n    expect(output._p_somePointer).toEqual('Micro$oft');\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"changes existing pointer keys","suites":["parseObjectToMongoObjectForCreate"],"line":396,"updatePoint":{"line":396,"column":35,"index":9566},"code":"  it('changes existing pointer keys', done => {\n    const input = {\n      userPointer: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: 'qwerty'\n      }\n    };\n    const output = transform.parseObjectToMongoObjectForCreate(null, input, {\n      fields: {\n        userPointer: {\n          type: 'Pointer'\n        }\n      }\n    });\n    expect(typeof output._p_userPointer).toEqual('string');\n    expect(output._p_userPointer).toEqual('_User$qwerty');\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"writes the old ACL format in addition to rperm and wperm on create","suites":["parseObjectToMongoObjectForCreate"],"line":415,"updatePoint":{"line":415,"column":72,"index":10095},"code":"  it('writes the old ACL format in addition to rperm and wperm on create', done => {\n    const input = {\n      _rperm: ['*'],\n      _wperm: ['Kevin']\n    };\n    const output = transform.parseObjectToMongoObjectForCreate(null, input, {\n      fields: {}\n    });\n    expect(typeof output._acl).toEqual('object');\n    expect(output._acl['Kevin'].w).toBeTruthy();\n    expect(output._acl['Kevin'].r).toBeUndefined();\n    expect(output._rperm).toEqual(input._rperm);\n    expect(output._wperm).toEqual(input._wperm);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"removes Relation types","suites":["parseObjectToMongoObjectForCreate"],"line":430,"updatePoint":{"line":430,"column":28,"index":10578},"code":"  it('removes Relation types', done => {\n    const input = {\n      aRelation: {\n        __type: 'Relation',\n        className: 'Stuff'\n      }\n    };\n    const output = transform.parseObjectToMongoObjectForCreate(null, input, {\n      fields: {\n        aRelation: {\n          __type: 'Relation',\n          className: 'Stuff'\n        }\n      }\n    });\n    expect(output).toEqual({});\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"writes the old ACL format in addition to rperm and wperm on update","suites":["parseObjectToMongoObjectForCreate"],"line":448,"updatePoint":{"line":448,"column":72,"index":11022},"code":"  it('writes the old ACL format in addition to rperm and wperm on update', done => {\n    const input = {\n      _rperm: ['*'],\n      _wperm: ['Kevin']\n    };\n    const output = transform.transformUpdate(null, input, {\n      fields: {}\n    });\n    const set = output.$set;\n    expect(typeof set).toEqual('object');\n    expect(typeof set._acl).toEqual('object');\n    expect(set._acl['Kevin'].w).toBeTruthy();\n    expect(set._acl['Kevin'].r).toBeUndefined();\n    expect(set._rperm).toEqual(input._rperm);\n    expect(set._wperm).toEqual(input._wperm);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"untransforms from _rperm and _wperm to ACL","suites":["parseObjectToMongoObjectForCreate"],"line":465,"updatePoint":{"line":465,"column":48,"index":11563},"code":"  it('untransforms from _rperm and _wperm to ACL', done => {\n    const input = {\n      _rperm: ['*'],\n      _wperm: ['Kevin']\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {}\n    });\n    expect(output._rperm).toEqual(['*']);\n    expect(output._wperm).toEqual(['Kevin']);\n    expect(output.ACL).toBeUndefined();\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"untransforms mongodb number types","suites":["parseObjectToMongoObjectForCreate"],"line":478,"updatePoint":{"line":478,"column":39,"index":11927},"code":"  it('untransforms mongodb number types', done => {\n    const input = {\n      long: mongodb.Long.fromNumber(Number.MAX_SAFE_INTEGER),\n      double: new mongodb.Double(Number.MAX_VALUE)\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        long: {\n          type: 'Number'\n        },\n        double: {\n          type: 'Number'\n        }\n      }\n    });\n    expect(output.long).toBe(Number.MAX_SAFE_INTEGER);\n    expect(output.double).toBe(Number.MAX_VALUE);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"Date object where iso attribute is of type Date","suites":["parseObjectToMongoObjectForCreate"],"line":497,"updatePoint":{"line":497,"column":53,"index":12462},"code":"  it('Date object where iso attribute is of type Date', done => {\n    const input = {\n      ts: {\n        __type: 'Date',\n        iso: new Date('2017-01-18T00:00:00.000Z')\n      }\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        ts: {\n          type: 'Date'\n        }\n      }\n    });\n    expect(output.ts.iso).toEqual('2017-01-18T00:00:00.000Z');\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"Date object where iso attribute is of type String","suites":["parseObjectToMongoObjectForCreate"],"line":514,"updatePoint":{"line":514,"column":55,"index":12880},"code":"  it('Date object where iso attribute is of type String', done => {\n    const input = {\n      ts: {\n        __type: 'Date',\n        iso: '2017-01-18T00:00:00.000Z'\n      }\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        ts: {\n          type: 'Date'\n        }\n      }\n    });\n    expect(output.ts.iso).toEqual('2017-01-18T00:00:00.000Z');\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"object with undefined nested values","suites":["parseObjectToMongoObjectForCreate"],"line":531,"updatePoint":{"line":531,"column":41,"index":13274},"code":"  it('object with undefined nested values', () => {\n    const input = {\n      _id: 'vQHyinCW1l',\n      urls: {\n        firstUrl: 'https://',\n        secondUrl: undefined\n      }\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        urls: {\n          type: 'Object'\n        }\n      }\n    });\n    expect(output.urls).toEqual({\n      firstUrl: 'https://',\n      secondUrl: undefined\n    });\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"undefined objects","suites":["parseObjectToMongoObjectForCreate"],"line":551,"updatePoint":{"line":551,"column":23,"index":13696},"code":"  it('undefined objects', () => {\n    const input = {\n      _id: 'vQHyinCW1l',\n      urls: undefined\n    };\n    const output = transform.mongoObjectToParseObject(null, input, {\n      fields: {\n        urls: {\n          type: 'Object'\n        }\n      }\n    });\n    expect(output.urls).toBeUndefined();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"$regex in $all list","suites":["parseObjectToMongoObjectForCreate"],"line":565,"updatePoint":{"line":565,"column":25,"index":14005},"code":"  it('$regex in $all list', done => {\n    const input = {\n      arrayField: {\n        $all: [{\n          $regex: '^\\\\Qone\\\\E'\n        }, {\n          $regex: '^\\\\Qtwo\\\\E'\n        }, {\n          $regex: '^\\\\Qthree\\\\E'\n        }]\n      }\n    };\n    const outputValue = {\n      arrayField: {\n        $all: [/^\\Qone\\E/, /^\\Qtwo\\E/, /^\\Qthree\\E/]\n      }\n    };\n    const output = transform.transformWhere(null, input);\n    jequal(outputValue.arrayField, output.arrayField);\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"$regex in $all list must be { $regex: \"string\" }","suites":["parseObjectToMongoObjectForCreate"],"line":586,"updatePoint":{"line":586,"column":54,"index":14521},"code":"  it('$regex in $all list must be { $regex: \"string\" }', done => {\n    const input = {\n      arrayField: {\n        $all: [{\n          $regex: 1\n        }]\n      }\n    };\n    expect(() => {\n      transform.transformWhere(null, input);\n    }).toThrow();\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"all values in $all must be $regex (start with string) or non $regex (start with string)","suites":["parseObjectToMongoObjectForCreate"],"line":599,"updatePoint":{"line":599,"column":93,"index":14830},"code":"  it('all values in $all must be $regex (start with string) or non $regex (start with string)', done => {\n    const input = {\n      arrayField: {\n        $all: [{\n          $regex: '^\\\\Qone\\\\E'\n        }, {\n          $unknown: '^\\\\Qtwo\\\\E'\n        }]\n      }\n    };\n    expect(() => {\n      transform.transformWhere(null, input);\n    }).toThrow();\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"ignores User authData field in DB so it can be synthesized in code","suites":["parseObjectToMongoObjectForCreate"],"line":614,"updatePoint":{"line":614,"column":72,"index":15175},"code":"  it('ignores User authData field in DB so it can be synthesized in code', done => {\n    const input = {\n      _id: '123',\n      _auth_data_acme: {\n        id: 'abc'\n      },\n      authData: null\n    };\n    const output = transform.mongoObjectToParseObject('_User', input, {\n      fields: {}\n    });\n    expect(output.authData.acme.id).toBe('abc');\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"can set authData when not User class","suites":["parseObjectToMongoObjectForCreate"],"line":628,"updatePoint":{"line":628,"column":42,"index":15512},"code":"  it('can set authData when not User class', done => {\n    const input = {\n      _id: '123',\n      authData: 'random'\n    };\n    const output = transform.mongoObjectToParseObject('TestObject', input, {\n      fields: {}\n    });\n    expect(output.authData).toBe('random');\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"cannot have a custom field name beginning with underscore","suites":["parseObjectToMongoObjectForCreate"],"line":640,"updatePoint":{"line":640,"column":61,"index":15824},"code":"it('cannot have a custom field name beginning with underscore', done => {\n  const input = {\n    _id: '123',\n    _thisFieldNameIs: 'invalid'\n  };\n  try {\n    transform.mongoObjectToParseObject('TestObject', input, {\n      fields: {}\n    });\n  } catch (e) {\n    expect(e).toBeDefined();\n  }\n  done();\n});","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"removes Relation types","suites":["transformUpdate"],"line":655,"updatePoint":{"line":655,"column":28,"index":16130},"code":"  it('removes Relation types', done => {\n    const input = {\n      aRelation: {\n        __type: 'Relation',\n        className: 'Stuff'\n      }\n    };\n    const output = transform.transformUpdate(null, input, {\n      fields: {\n        aRelation: {\n          __type: 'Relation',\n          className: 'Stuff'\n        }\n      }\n    });\n    expect(output).toEqual({});\n    done();\n  });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should error on $eq, $ne, and $exists","suites":["transformConstraint","$relativeTime"],"line":676,"updatePoint":{"line":676,"column":45,"index":16609},"code":"    it('should error on $eq, $ne, and $exists', () => {\n      expect(() => {\n        transform.transformConstraint({\n          $eq: {\n            ttl: {\n              $relativeTime: '12 days ago'\n            }\n          }\n        });\n      }).toThrow();\n      expect(() => {\n        transform.transformConstraint({\n          $ne: {\n            ttl: {\n              $relativeTime: '12 days ago'\n            }\n          }\n        });\n      }).toThrow();\n      expect(() => {\n        transform.transformConstraint({\n          $exists: {\n            $relativeTime: '12 days ago'\n          }\n        });\n      }).toThrow();\n    });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should parse valid natural time","suites":["relativeTimeToDate","In the future"],"line":708,"updatePoint":{"line":708,"column":39,"index":17367},"code":"    it('should parse valid natural time', () => {\n      const text = 'in 1 year 2 weeks 12 days 10 hours 24 minutes 30 seconds';\n      const {\n        result,\n        status,\n        info\n      } = Utils.relativeTimeToDate(text, now);\n      expect(result.toISOString()).toBe('2018-10-22T23:52:46.617Z');\n      expect(status).toBe('success');\n      expect(info).toBe('future');\n    });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should parse valid natural time","suites":["relativeTimeToDate","In the past"],"line":721,"updatePoint":{"line":721,"column":39,"index":17792},"code":"    it('should parse valid natural time', () => {\n      const text = '2 days 12 hours 1 minute 12 seconds ago';\n      const {\n        result,\n        status,\n        info\n      } = Utils.relativeTimeToDate(text, now);\n      expect(result.toISOString()).toBe('2017-09-24T01:27:04.617Z');\n      expect(status).toBe('success');\n      expect(info).toBe('past');\n    });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should equal current time","suites":["relativeTimeToDate","From now"],"line":734,"updatePoint":{"line":734,"column":33,"index":18189},"code":"    it('should equal current time', () => {\n      const text = 'now';\n      const {\n        result,\n        status,\n        info\n      } = Utils.relativeTimeToDate(text, now);\n      expect(result.toISOString()).toBe('2017-09-26T13:28:16.617Z');\n      expect(status).toBe('success');\n      expect(info).toBe('present');\n    });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should error if string is completely gibberish","suites":["relativeTimeToDate","Error cases"],"line":747,"updatePoint":{"line":747,"column":54,"index":18577},"code":"    it('should error if string is completely gibberish', () => {\n      expect(Utils.relativeTimeToDate('gibberishasdnklasdnjklasndkl123j123')).toEqual({\n        status: 'error',\n        info: \"Time should either start with 'in' or end with 'ago'\"\n      });\n    });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should error if string contains neither `ago` nor `in`","suites":["relativeTimeToDate","Error cases"],"line":753,"updatePoint":{"line":753,"column":62,"index":18850},"code":"    it('should error if string contains neither `ago` nor `in`', () => {\n      expect(Utils.relativeTimeToDate('12 hours 1 minute')).toEqual({\n        status: 'error',\n        info: \"Time should either start with 'in' or end with 'ago'\"\n      });\n    });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should error if there are missing units or numbers","suites":["relativeTimeToDate","Error cases"],"line":759,"updatePoint":{"line":759,"column":58,"index":19101},"code":"    it('should error if there are missing units or numbers', () => {\n      expect(Utils.relativeTimeToDate('in 12 hours 1')).toEqual({\n        status: 'error',\n        info: 'Invalid time string. Dangling unit or number.'\n      });\n      expect(Utils.relativeTimeToDate('12 hours minute ago')).toEqual({\n        status: 'error',\n        info: 'Invalid time string. Dangling unit or number.'\n      });\n    });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should error on floating point numbers","suites":["relativeTimeToDate","Error cases"],"line":769,"updatePoint":{"line":769,"column":46,"index":19498},"code":"    it('should error on floating point numbers', () => {\n      expect(Utils.relativeTimeToDate('in 12.3 hours')).toEqual({\n        status: 'error',\n        info: \"'12.3' is not an integer.\"\n      });\n    });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should error if numbers are invalid","suites":["relativeTimeToDate","Error cases"],"line":775,"updatePoint":{"line":775,"column":43,"index":19703},"code":"    it('should error if numbers are invalid', () => {\n      expect(Utils.relativeTimeToDate('12 hours 123a minute ago')).toEqual({\n        status: 'error',\n        info: \"'123a' is not an integer.\"\n      });\n    });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should error on invalid interval units","suites":["relativeTimeToDate","Error cases"],"line":781,"updatePoint":{"line":781,"column":46,"index":19922},"code":"    it('should error on invalid interval units', () => {\n      expect(Utils.relativeTimeToDate('4 score 7 years ago')).toEqual({\n        status: 'error',\n        info: \"Invalid interval: 'score'\"\n      });\n    });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should error when string contains 'ago' and 'in'","suites":["relativeTimeToDate","Error cases"],"line":787,"updatePoint":{"line":787,"column":56,"index":20146},"code":"    it(\"should error when string contains 'ago' and 'in'\", () => {\n      expect(Utils.relativeTimeToDate('in 1 day 2 minutes ago')).toEqual({\n        status: 'error',\n        info: \"Time cannot have both 'in' and 'ago'\"\n      });\n    });","file":"MongoTransform.spec.js","skipped":false,"dir":"spec"},{"name":"should expose promisifyed methods","suites":["NullCacheAdapter"],"line":5,"updatePoint":{"line":5,"column":39,"index":215},"code":"  it('should expose promisifyed methods', done => {\n    const cache = new NullCacheAdapter({\n      ttl: NaN\n    });\n\n    // Verify all methods return promises.\n    Promise.all([cache.put(KEY, VALUE), cache.del(KEY), cache.get(KEY), cache.clear()]).then(() => {\n      done();\n    });\n  });","file":"NullCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should get/set/clear","suites":["NullCacheAdapter"],"line":15,"updatePoint":{"line":15,"column":26,"index":491},"code":"  it('should get/set/clear', done => {\n    const cache = new NullCacheAdapter({\n      ttl: NaN\n    });\n    cache.put(KEY, VALUE).then(() => cache.get(KEY)).then(value => expect(value).toEqual(null)).then(() => cache.clear()).then(() => cache.get(KEY)).then(value => expect(value).toEqual(null)).then(done);\n  });","file":"NullCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"Nonce should have right length","suites":["OAuth"],"line":3,"updatePoint":{"line":3,"column":36,"index":129},"code":"  it('Nonce should have right length', done => {\n    jequal(OAuth.nonce().length, 30);\n    done();\n  });","file":"OAuth1.spec.js","skipped":false,"dir":"spec"},{"name":"Should properly build parameter string","suites":["OAuth"],"line":7,"updatePoint":{"line":7,"column":44,"index":242},"code":"  it('Should properly build parameter string', done => {\n    const string = OAuth.buildParameterString({\n      c: 1,\n      a: 2,\n      b: 3\n    });\n    jequal(string, 'a=2&b=3&c=1');\n    done();\n  });","file":"OAuth1.spec.js","skipped":false,"dir":"spec"},{"name":"Should properly build empty parameter string","suites":["OAuth"],"line":16,"updatePoint":{"line":16,"column":50,"index":449},"code":"  it('Should properly build empty parameter string', done => {\n    const string = OAuth.buildParameterString();\n    jequal(string, '');\n    done();\n  });","file":"OAuth1.spec.js","skipped":false,"dir":"spec"},{"name":"Should properly build signature string","suites":["OAuth"],"line":21,"updatePoint":{"line":21,"column":44,"index":597},"code":"  it('Should properly build signature string', done => {\n    const string = OAuth.buildSignatureString('get', 'http://dummy.com', '');\n    jequal(string, 'GET&http%3A%2F%2Fdummy.com&');\n    done();\n  });","file":"OAuth1.spec.js","skipped":false,"dir":"spec"},{"name":"Should properly generate request signature","suites":["OAuth"],"line":26,"updatePoint":{"line":26,"column":48,"index":805},"code":"  it('Should properly generate request signature', done => {\n    let request = {\n      host: 'dummy.com',\n      path: 'path'\n    };\n    const oauth_params = {\n      oauth_timestamp: 123450000,\n      oauth_nonce: 'AAAAAAAAAAAAAAAAA',\n      oauth_consumer_key: 'hello',\n      oauth_token: 'token'\n    };\n    const consumer_secret = 'world';\n    const auth_token_secret = 'secret';\n    request = OAuth.signRequest(request, oauth_params, consumer_secret, auth_token_secret);\n    jequal(request.headers['Authorization'], 'OAuth oauth_consumer_key=\"hello\", oauth_nonce=\"AAAAAAAAAAAAAAAAA\", oauth_signature=\"8K95bpQcDi9Nd2GkhumTVcw4%2BXw%3D\", oauth_signature_method=\"HMAC-SHA1\", oauth_timestamp=\"123450000\", oauth_token=\"token\", oauth_version=\"1.0\"');\n    done();\n  });","file":"OAuth1.spec.js","skipped":false,"dir":"spec"},{"name":"Should properly build request","suites":["OAuth"],"line":43,"updatePoint":{"line":43,"column":35,"index":1555},"code":"  it('Should properly build request', done => {\n    const options = {\n      host: 'dummy.com',\n      consumer_key: 'hello',\n      consumer_secret: 'world',\n      auth_token: 'token',\n      auth_token_secret: 'secret',\n      // Custom oauth params for tests\n      oauth_params: {\n        oauth_timestamp: 123450000,\n        oauth_nonce: 'AAAAAAAAAAAAAAAAA'\n      }\n    };\n    const path = 'path';\n    const method = 'get';\n    const oauthClient = new OAuth(options);\n    const req = oauthClient.buildRequest(method, path, {\n      query: 'param'\n    });\n    jequal(req.host, options.host);\n    jequal(req.path, '/' + path + '?query=param');\n    jequal(req.method, 'GET');\n    jequal(req.headers['Content-Type'], 'application/x-www-form-urlencoded');\n    jequal(req.headers['Authorization'], 'OAuth oauth_consumer_key=\"hello\", oauth_nonce=\"AAAAAAAAAAAAAAAAA\", oauth_signature=\"wNkyEkDE%2F0JZ2idmqyrgHdvC0rs%3D\", oauth_signature_method=\"HMAC-SHA1\", oauth_timestamp=\"123450000\", oauth_token=\"token\", oauth_version=\"1.0\"');\n    done();\n  });","file":"OAuth1.spec.js","skipped":false,"dir":"spec"},{"name":"GET request for a resource that requires OAuth should fail with invalid credentials","suites":["OAuth"],"line":78,"updatePoint":{"line":78,"column":89,"index":2932},"code":"  it('GET request for a resource that requires OAuth should fail with invalid credentials', done => {\n    /*\n      This endpoint has been chosen to make a request to an endpoint that requires OAuth which fails due to missing authentication.\n      Any other endpoint from the Twitter API that requires OAuth can be used instead in case the currently used endpoint deprecates.\n    */\n    const options = {\n      host: 'api.twitter.com',\n      consumer_key: 'invalid_consumer_key',\n      consumer_secret: 'invalid_consumer_secret'\n    };\n    const path = '/1.1/favorites/list.json';\n    const params = {\n      lang: 'en'\n    };\n    const oauthClient = new OAuth(options);\n    oauthClient.get(path, params).then(function (data) {\n      validateCannotAuthenticateError(data, done);\n    });\n  });","file":"OAuth1.spec.js","skipped":false,"dir":"spec"},{"name":"POST request for a resource that requires OAuth should fail with invalid credentials","suites":["OAuth"],"line":97,"updatePoint":{"line":97,"column":90,"index":3724},"code":"  it('POST request for a resource that requires OAuth should fail with invalid credentials', done => {\n    /*\n      This endpoint has been chosen to make a request to an endpoint that requires OAuth which fails due to missing authentication.\n      Any other endpoint from the Twitter API that requires OAuth can be used instead in case the currently used endpoint deprecates.\n    */\n    const options = {\n      host: 'api.twitter.com',\n      consumer_key: 'invalid_consumer_key',\n      consumer_secret: 'invalid_consumer_secret'\n    };\n    const body = {\n      lang: 'en'\n    };\n    const path = '/1.1/account/settings.json';\n    const oauthClient = new OAuth(options);\n    oauthClient.post(path, null, body).then(function (data) {\n      validateCannotAuthenticateError(data, done);\n    });\n  });","file":"OAuth1.spec.js","skipped":false,"dir":"spec"},{"name":"Should fail a request","suites":["OAuth"],"line":116,"updatePoint":{"line":116,"column":27,"index":4458},"code":"  it('Should fail a request', done => {\n    const options = {\n      host: 'localhost',\n      consumer_key: 'XXXXXXXXXXXXXXXXXXXXXXXXX',\n      consumer_secret: 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n    };\n    const body = {\n      lang: 'en'\n    };\n    const path = '/';\n    const oauthClient = new OAuth(options);\n    oauthClient.post(path, null, body).then(function () {\n      jequal(false, true);\n      done();\n    }).catch(function () {\n      jequal(true, true);\n      done();\n    });\n  });","file":"OAuth1.spec.js","skipped":false,"dir":"spec"},{"name":"Should fail with missing options","suites":["OAuth"],"line":135,"updatePoint":{"line":135,"column":38,"index":4977},"code":"  it('Should fail with missing options', done => {\n    const options = undefined;\n    try {\n      new OAuth(options);\n    } catch (error) {\n      jequal(error.message, 'No options passed to OAuth');\n      done();\n    }\n  });","file":"OAuth1.spec.js","skipped":false,"dir":"spec"},{"name":"responds with file content on direct page request","suites":["Pages Router","basic request"],"line":33,"updatePoint":{"line":33,"column":57,"index":921},"code":"    it('responds with file content on direct page request', async () => {\n      const urls = ['http://localhost:8378/1/apps/email_verification_link_invalid.html', 'http://localhost:8378/1/apps/choose_password?appId=test', 'http://localhost:8378/1/apps/email_verification_success.html', 'http://localhost:8378/1/apps/password_reset_success.html', 'http://localhost:8378/1/apps/custom_json.html'];\n      for (const url of urls) {\n        const response = await request({\n          url\n        }).catch(e => e);\n        expect(response.status).toBe(200);\n      }\n    });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"can load file from custom pages path","suites":["Pages Router","basic request"],"line":42,"updatePoint":{"line":42,"column":44,"index":1476},"code":"    it('can load file from custom pages path', async () => {\n      config.pages.pagesPath = './public';\n      await reconfigureServer(config);\n      const response = await request({\n        url: 'http://localhost:8378/1/apps/email_verification_link_invalid.html'\n      }).catch(e => e);\n      expect(response.status).toBe(200);\n    });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"can load file from custom pages endpoint","suites":["Pages Router","basic request"],"line":50,"updatePoint":{"line":50,"column":48,"index":1816},"code":"    it('can load file from custom pages endpoint', async () => {\n      config.pages.pagesEndpoint = 'pages';\n      await reconfigureServer(config);\n      const response = await request({\n        url: `http://localhost:8378/1/pages/email_verification_link_invalid.html`\n      }).catch(e => e);\n      expect(response.status).toBe(200);\n    });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"responds with 404 if publicServerURL is not configured","suites":["Pages Router","basic request"],"line":58,"updatePoint":{"line":58,"column":62,"index":2172},"code":"    it('responds with 404 if publicServerURL is not configured', async () => {\n      await reconfigureServer({\n        appName: 'unused',\n        pages: {\n          enableRouter: true\n        }\n      });\n      const urls = ['http://localhost:8378/1/apps/test/verify_email', 'http://localhost:8378/1/apps/choose_password?appId=test', 'http://localhost:8378/1/apps/test/request_password_reset'];\n      for (const url of urls) {\n        const response = await request({\n          url\n        }).catch(e => e);\n        expect(response.status).toBe(404);\n      }\n    });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"responds with 403 access denied with invalid appId","suites":["Pages Router","basic request"],"line":73,"updatePoint":{"line":73,"column":58,"index":2734},"code":"    it('responds with 403 access denied with invalid appId', async () => {\n      const reqs = [{\n        url: 'http://localhost:8378/1/apps/invalid/verify_email',\n        method: 'GET'\n      }, {\n        url: 'http://localhost:8378/1/apps/choose_password?id=invalid',\n        method: 'GET'\n      }, {\n        url: 'http://localhost:8378/1/apps/invalid/request_password_reset',\n        method: 'GET'\n      }, {\n        url: 'http://localhost:8378/1/apps/invalid/request_password_reset',\n        method: 'POST'\n      }, {\n        url: 'http://localhost:8378/1/apps/invalid/resend_verification_email',\n        method: 'POST'\n      }];\n      for (const req of reqs) {\n        const response = await request(req).catch(e => e);\n        expect(response.status).toBe(403);\n      }\n    });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"request_password_reset: responds with AJAX success","suites":["Pages Router","AJAX requests"],"line":106,"updatePoint":{"line":106,"column":58,"index":3780},"code":"    it('request_password_reset: responds with AJAX success', async () => {\n      spyOn(UserController.prototype, 'updatePassword').and.callFake(() => Promise.resolve());\n      const res = await request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/apps/test/request_password_reset',\n        body: `new_password=user1&token=43634643&username=username`,\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'X-Requested-With': 'XMLHttpRequest'\n        },\n        followRedirects: false\n      }).catch(e => e);\n      expect(res.status).toBe(200);\n      expect(res.text).toEqual('\"Password successfully reset\"');\n    });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"request_password_reset: responds with AJAX error on missing password","suites":["Pages Router","AJAX requests"],"line":121,"updatePoint":{"line":121,"column":76,"index":4472},"code":"    it('request_password_reset: responds with AJAX error on missing password', async () => {\n      try {\n        await request({\n          method: 'POST',\n          url: 'http://localhost:8378/1/apps/test/request_password_reset',\n          body: `new_password=&token=132414&username=Johnny`,\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'X-Requested-With': 'XMLHttpRequest'\n          },\n          followRedirects: false\n        });\n      } catch (error) {\n        expect(error.status).not.toBe(302);\n        expect(error.text).toEqual('{\"code\":201,\"error\":\"Missing password\"}');\n      }\n    });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"request_password_reset: responds with AJAX error on missing username","suites":["Pages Router","AJAX requests"],"line":138,"updatePoint":{"line":138,"column":76,"index":5120},"code":"    it('request_password_reset: responds with AJAX error on missing username', async () => {\n      try {\n        await request({\n          method: 'POST',\n          url: 'http://localhost:8378/1/apps/test/request_password_reset',\n          body: `new_password=user1&token=43634643&username=`,\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'X-Requested-With': 'XMLHttpRequest'\n          },\n          followRedirects: false\n        });\n      } catch (error) {\n        expect(error.status).not.toBe(302);\n        expect(error.text).toEqual('{\"code\":200,\"error\":\"Missing username\"}');\n      }\n    });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"request_password_reset: responds with AJAX error on missing token","suites":["Pages Router","AJAX requests"],"line":155,"updatePoint":{"line":155,"column":73,"index":5766},"code":"    it('request_password_reset: responds with AJAX error on missing token', async () => {\n      try {\n        await request({\n          method: 'POST',\n          url: 'http://localhost:8378/1/apps/test/request_password_reset',\n          body: `new_password=user1&token=&username=Johnny`,\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'X-Requested-With': 'XMLHttpRequest'\n          },\n          followRedirects: false\n        });\n      } catch (error) {\n        expect(error.status).not.toBe(302);\n        expect(error.text).toEqual('{\"code\":-1,\"error\":\"Missing token\"}');\n      }\n    });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"uses default configuration when none is set","suites":["Pages Router","pages","server options"],"line":219,"updatePoint":{"line":219,"column":53,"index":7867},"code":"      it('uses default configuration when none is set', async () => {\n        await reconfigureServerWithPagesConfig({});\n        expect(Config.get(Parse.applicationId).pages.enableRouter).toBe(Definitions.PagesOptions.enableRouter.default);\n        expect(Config.get(Parse.applicationId).pages.enableLocalization).toBe(Definitions.PagesOptions.enableLocalization.default);\n        expect(Config.get(Parse.applicationId).pages.localizationJsonPath).toBe(Definitions.PagesOptions.localizationJsonPath.default);\n        expect(Config.get(Parse.applicationId).pages.localizationFallbackLocale).toBe(Definitions.PagesOptions.localizationFallbackLocale.default);\n        expect(Config.get(Parse.applicationId).pages.placeholders).toBe(Definitions.PagesOptions.placeholders.default);\n        expect(Config.get(Parse.applicationId).pages.forceRedirect).toBe(Definitions.PagesOptions.forceRedirect.default);\n        expect(Config.get(Parse.applicationId).pages.pagesPath).toBe(Definitions.PagesOptions.pagesPath.default);\n        expect(Config.get(Parse.applicationId).pages.pagesEndpoint).toBe(Definitions.PagesOptions.pagesEndpoint.default);\n        expect(Config.get(Parse.applicationId).pages.customUrls).toBe(Definitions.PagesOptions.customUrls.default);\n        expect(Config.get(Parse.applicationId).pages.customRoutes).toBe(Definitions.PagesOptions.customRoutes.default);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"throws on invalid configuration","suites":["Pages Router","pages","server options"],"line":232,"updatePoint":{"line":232,"column":41,"index":9237},"code":"      it('throws on invalid configuration', async () => {\n        const options = [[], 'a', 0, true, {\n          enableRouter: 'a'\n        }, {\n          enableRouter: 0\n        }, {\n          enableRouter: {}\n        }, {\n          enableRouter: []\n        }, {\n          enableLocalization: 'a'\n        }, {\n          enableLocalization: 0\n        }, {\n          enableLocalization: {}\n        }, {\n          enableLocalization: []\n        }, {\n          forceRedirect: 'a'\n        }, {\n          forceRedirect: 0\n        }, {\n          forceRedirect: {}\n        }, {\n          forceRedirect: []\n        }, {\n          placeholders: true\n        }, {\n          placeholders: 'a'\n        }, {\n          placeholders: 0\n        }, {\n          placeholders: []\n        }, {\n          pagesPath: true\n        }, {\n          pagesPath: 0\n        }, {\n          pagesPath: {}\n        }, {\n          pagesPath: []\n        }, {\n          pagesEndpoint: true\n        }, {\n          pagesEndpoint: 0\n        }, {\n          pagesEndpoint: {}\n        }, {\n          pagesEndpoint: []\n        }, {\n          customUrls: true\n        }, {\n          customUrls: 0\n        }, {\n          customUrls: 'a'\n        }, {\n          customUrls: []\n        }, {\n          localizationJsonPath: true\n        }, {\n          localizationJsonPath: 0\n        }, {\n          localizationJsonPath: {}\n        }, {\n          localizationJsonPath: []\n        }, {\n          localizationFallbackLocale: true\n        }, {\n          localizationFallbackLocale: 0\n        }, {\n          localizationFallbackLocale: {}\n        }, {\n          localizationFallbackLocale: []\n        }, {\n          customRoutes: true\n        }, {\n          customRoutes: 0\n        }, {\n          customRoutes: 'a'\n        }, {\n          customRoutes: {}\n        }];\n        for (const option of options) {\n          await expectAsync(reconfigureServerWithPagesConfig(option)).toBeRejected();\n        }\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"replaces placeholder in response content","suites":["Pages Router","pages","placeholders"],"line":320,"updatePoint":{"line":320,"column":50,"index":11249},"code":"      it('replaces placeholder in response content', async () => {\n        await expectAsync(router.goToPage(req, pages.passwordResetLinkInvalid)).toBeResolved();\n        expect(readFile.calls.all()[0].returnValue).toBeDefined();\n        const originalContent = await readFile.calls.all()[0].returnValue;\n        expect(originalContent).toContain('{{appName}}');\n        expect(pageResponse.calls.all()[0].returnValue).toBeDefined();\n        const replacedContent = await pageResponse.calls.all()[0].returnValue;\n        expect(replacedContent.text).not.toContain('{{appName}}');\n        expect(replacedContent.text).toContain(req.config.appName);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"removes undefined placeholder in response content","suites":["Pages Router","pages","placeholders"],"line":330,"updatePoint":{"line":330,"column":59,"index":11916},"code":"      it('removes undefined placeholder in response content', async () => {\n        await expectAsync(router.goToPage(req, pages.passwordReset)).toBeResolved();\n        expect(readFile.calls.all()[0].returnValue).toBeDefined();\n        const originalContent = await readFile.calls.all()[0].returnValue;\n        expect(originalContent).toContain('{{error}}');\n\n        // There is no error placeholder value set by default, so the\n        // {{error}} placeholder should just be removed from content\n        expect(pageResponse.calls.all()[0].returnValue).toBeDefined();\n        const replacedContent = await pageResponse.calls.all()[0].returnValue;\n        expect(replacedContent.text).not.toContain('{{error}}');\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"fills placeholders from config object","suites":["Pages Router","pages","placeholders"],"line":342,"updatePoint":{"line":342,"column":47,"index":12628},"code":"      it('fills placeholders from config object', async () => {\n        config.pages.enableLocalization = false;\n        config.pages.placeholders = {\n          title: 'setViaConfig'\n        };\n        await reconfigureServer(config);\n        const response = await request({\n          url: 'http://localhost:8378/1/apps/custom_json.html',\n          followRedirects: false,\n          method: 'GET'\n        });\n        expect(response.status).toEqual(200);\n        expect(response.text).toContain(config.pages.placeholders.title);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"fills placeholders from config function","suites":["Pages Router","pages","placeholders"],"line":356,"updatePoint":{"line":356,"column":49,"index":13170},"code":"      it('fills placeholders from config function', async () => {\n        config.pages.enableLocalization = false;\n        config.pages.placeholders = () => {\n          return {\n            title: 'setViaConfig'\n          };\n        };\n        await reconfigureServer(config);\n        const response = await request({\n          url: 'http://localhost:8378/1/apps/custom_json.html',\n          followRedirects: false,\n          method: 'GET'\n        });\n        expect(response.status).toEqual(200);\n        expect(response.text).toContain(config.pages.placeholders().title);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"fills placeholders from config promise","suites":["Pages Router","pages","placeholders"],"line":372,"updatePoint":{"line":372,"column":48,"index":13753},"code":"      it('fills placeholders from config promise', async () => {\n        config.pages.enableLocalization = false;\n        config.pages.placeholders = async () => {\n          return {\n            title: 'setViaConfig'\n          };\n        };\n        await reconfigureServer(config);\n        const response = await request({\n          url: 'http://localhost:8378/1/apps/custom_json.html',\n          followRedirects: false,\n          method: 'GET'\n        });\n        expect(response.status).toEqual(200);\n        expect(response.text).toContain((await config.pages.placeholders()).title);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"returns default file if localization is disabled","suites":["Pages Router","pages","localization"],"line":390,"updatePoint":{"line":390,"column":58,"index":14405},"code":"      it('returns default file if localization is disabled', async () => {\n        delete req.config.pages.enableLocalization;\n        await expectAsync(router.goToPage(req, pages.passwordResetLinkInvalid)).toBeResolved();\n        expect(pageResponse.calls.all()[0].args[0]).toBeDefined();\n        expect(pageResponse.calls.all()[0].args[0]).not.toMatch(new RegExp(`\\/de(-AT)?\\/${pages.passwordResetLinkInvalid.defaultFile}`));\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"returns default file if no locale is specified","suites":["Pages Router","pages","localization"],"line":396,"updatePoint":{"line":396,"column":56,"index":14841},"code":"      it('returns default file if no locale is specified', async () => {\n        delete req.query.locale;\n        await expectAsync(router.goToPage(req, pages.passwordResetLinkInvalid)).toBeResolved();\n        expect(pageResponse.calls.all()[0].args[0]).toBeDefined();\n        expect(pageResponse.calls.all()[0].args[0]).not.toMatch(new RegExp(`\\/de(-AT)?\\/${pages.passwordResetLinkInvalid.defaultFile}`));\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"returns custom page regardless of localization enabled","suites":["Pages Router","pages","localization"],"line":402,"updatePoint":{"line":402,"column":64,"index":15266},"code":"      it('returns custom page regardless of localization enabled', async () => {\n        req.config.pages.customUrls = {\n          passwordResetLinkInvalid: 'http://invalid-link.example.com'\n        };\n        await expectAsync(router.goToPage(req, pages.passwordResetLinkInvalid)).toBeResolved();\n        expect(pageResponse).not.toHaveBeenCalled();\n        expect(redirectResponse.calls.all()[0].args[0]).toBe(req.config.pages.customUrls.passwordResetLinkInvalid);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"returns file for locale match","suites":["Pages Router","pages","localization"],"line":410,"updatePoint":{"line":410,"column":39,"index":15718},"code":"      it('returns file for locale match', async () => {\n        await expectAsync(router.goToPage(req, pages.passwordResetLinkInvalid)).toBeResolved();\n        expect(pageResponse.calls.all()[0].args[0]).toBeDefined();\n        expect(pageResponse.calls.all()[0].args[0]).toMatch(new RegExp(`\\/${req.query.locale}\\/${pages.passwordResetLinkInvalid.defaultFile}`));\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"returns file for language match","suites":["Pages Router","pages","localization"],"line":415,"updatePoint":{"line":415,"column":41,"index":16094},"code":"      it('returns file for language match', async () => {\n        // Pretend no locale matching file exists\n        spyOn(Utils, 'fileExists').and.callFake(async path => {\n          return !path.includes(`/${req.query.locale}/${pages.passwordResetLinkInvalid.defaultFile}`);\n        });\n        await expectAsync(router.goToPage(req, pages.passwordResetLinkInvalid)).toBeResolved();\n        expect(pageResponse.calls.all()[0].args[0]).toBeDefined();\n        expect(pageResponse.calls.all()[0].args[0]).toMatch(new RegExp(`\\/de\\/${pages.passwordResetLinkInvalid.defaultFile}`));\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"returns default file for neither locale nor language match","suites":["Pages Router","pages","localization"],"line":424,"updatePoint":{"line":424,"column":68,"index":16709},"code":"      it('returns default file for neither locale nor language match', async () => {\n        req.query.locale = 'yo-LO';\n        await expectAsync(router.goToPage(req, pages.passwordResetLinkInvalid)).toBeResolved();\n        expect(pageResponse.calls.all()[0].args[0]).toBeDefined();\n        expect(pageResponse.calls.all()[0].args[0]).not.toMatch(new RegExp(`\\/yo(-LO)?\\/${pages.passwordResetLinkInvalid.defaultFile}`));\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"does not localize with JSON resource if localization is disabled","suites":["Pages Router","pages","localization with JSON resource"],"line":444,"updatePoint":{"line":444,"column":74,"index":17727},"code":"      it('does not localize with JSON resource if localization is disabled', async () => {\n        config.pages.enableLocalization = false;\n        config.pages.localizationJsonPath = './public/custom_json.json';\n        config.pages.localizationFallbackLocale = 'en';\n        await reconfigureServer(config);\n        const response = await request({\n          url: jsonPageUrl.toString(),\n          followRedirects: false\n        }).catch(e => e);\n        expect(response.status).toBe(200);\n        expect(pageResponse.calls.all()[0].args[1]).toEqual({});\n        expect(pageResponse.calls.all()[0].args[2]).toEqual({});\n\n        // Ensure header contains no page params\n        const pageParamHeaders = Object.keys(response.headers).filter(header => header.startsWith(pageParamHeaderPrefix));\n        expect(pageParamHeaders.length).toBe(0);\n\n        // Ensure page response does not contain any translation\n        const flattenedJson = Utils.flattenObject(jsonResource);\n        for (const value of Object.values(flattenedJson)) {\n          const valueWithoutPlaceholder = fillPlaceholders(value, '');\n          expect(response.text).not.toContain(valueWithoutPlaceholder);\n        }\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"localizes static page with JSON resource and fallback locale","suites":["Pages Router","pages","localization with JSON resource"],"line":468,"updatePoint":{"line":468,"column":70,"index":18921},"code":"      it('localizes static page with JSON resource and fallback locale', async () => {\n        const response = await request({\n          url: jsonPageUrl.toString(),\n          followRedirects: false\n        }).catch(e => e);\n        expect(response.status).toBe(200);\n\n        // Ensure page response contains translation of fallback locale\n        const translation = jsonResource[config.pages.localizationFallbackLocale].translation;\n        for (const value of Object.values(translation)) {\n          const valueWithoutPlaceholder = fillPlaceholders(value, '');\n          expect(response.text).toContain(valueWithoutPlaceholder);\n        }\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"localizes static page with JSON resource and request locale","suites":["Pages Router","pages","localization with JSON resource"],"line":482,"updatePoint":{"line":482,"column":69,"index":19574},"code":"      it('localizes static page with JSON resource and request locale', async () => {\n        // Add locale to request URL\n        jsonPageUrl.searchParams.set('locale', exampleLocale);\n        const response = await request({\n          url: jsonPageUrl.toString(),\n          followRedirects: false\n        }).catch(e => e);\n        expect(response.status).toBe(200);\n\n        // Ensure page response contains translations of request locale\n        const translation = jsonResource[exampleLocale].translation;\n        for (const value of Object.values(translation)) {\n          const valueWithoutPlaceholder = fillPlaceholders(value, '');\n          expect(response.text).toContain(valueWithoutPlaceholder);\n        }\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"localizes static page with JSON resource and language matching request locale","suites":["Pages Router","pages","localization with JSON resource"],"line":498,"updatePoint":{"line":498,"column":87,"index":20319},"code":"      it('localizes static page with JSON resource and language matching request locale', async () => {\n        // Add locale to request URL that has no locale match but only a language\n        // match in the JSON resource\n        jsonPageUrl.searchParams.set('locale', 'de-CH');\n        const response = await request({\n          url: jsonPageUrl.toString(),\n          followRedirects: false\n        }).catch(e => e);\n        expect(response.status).toBe(200);\n\n        // Ensure page response contains translations of requst language\n        const translation = jsonResource['de'].translation;\n        for (const value of Object.values(translation)) {\n          const valueWithoutPlaceholder = fillPlaceholders(value, '');\n          expect(response.text).toContain(valueWithoutPlaceholder);\n        }\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"localizes static page with JSON resource and fills placeholders in JSON values","suites":["Pages Router","pages","localization with JSON resource"],"line":515,"updatePoint":{"line":515,"column":88,"index":21134},"code":"      it('localizes static page with JSON resource and fills placeholders in JSON values', async () => {\n        // Add app ID to request URL so that the request is assigned to a Parse Server app\n        // and placeholders within translations strings can be replaced with default page\n        // parameters such as `appId`\n        jsonPageUrl.searchParams.set('appId', config.appId);\n        jsonPageUrl.searchParams.set('locale', exampleLocale);\n        const response = await request({\n          url: jsonPageUrl.toString(),\n          followRedirects: false\n        }).catch(e => e);\n        expect(response.status).toBe(200);\n\n        // Fill placeholders in transation\n        let translation = jsonResource[exampleLocale].translation;\n        translation = JSON.stringify(translation);\n        translation = mustache.render(translation, {\n          appName: config.appName\n        });\n        translation = JSON.parse(translation);\n\n        // Ensure page response contains translation of request locale\n        for (const value of Object.values(translation)) {\n          expect(response.text).toContain(value);\n        }\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"localizes feature page with JSON resource and fills placeholders in JSON values","suites":["Pages Router","pages","localization with JSON resource"],"line":540,"updatePoint":{"line":540,"column":89,"index":22273},"code":"      it('localizes feature page with JSON resource and fills placeholders in JSON values', async () => {\n        // Fake any page to load the JSON page file\n        spyOnProperty(Page.prototype, 'defaultFile').and.returnValue(jsonPageFile);\n        const response = await request({\n          url: `http://localhost:8378/1/apps/test/request_password_reset?token=exampleToken&username=exampleUsername&locale=${exampleLocale}`,\n          followRedirects: false\n        }).catch(e => e);\n        expect(response.status).toEqual(200);\n\n        // Fill placeholders in transation\n        let translation = jsonResource[exampleLocale].translation;\n        translation = JSON.stringify(translation);\n        translation = mustache.render(translation, {\n          appName: config.appName\n        });\n        translation = JSON.parse(translation);\n\n        // Ensure page response contains translation of request locale\n        for (const value of Object.values(translation)) {\n          expect(response.text).toContain(value);\n        }\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"returns a file for GET request","suites":["Pages Router","pages","response type"],"line":564,"updatePoint":{"line":564,"column":40,"index":23309},"code":"      it('returns a file for GET request', async () => {\n        await expectAsync(router.goToPage(req, pages.passwordResetLinkInvalid)).toBeResolved();\n        expect(pageResponse).toHaveBeenCalled();\n        expect(redirectResponse).not.toHaveBeenCalled();\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"returns a redirect for POST request","suites":["Pages Router","pages","response type"],"line":569,"updatePoint":{"line":569,"column":45,"index":23583},"code":"      it('returns a redirect for POST request', async () => {\n        req.method = 'POST';\n        await expectAsync(router.goToPage(req, pages.passwordResetLinkInvalid)).toBeResolved();\n        expect(pageResponse).not.toHaveBeenCalled();\n        expect(redirectResponse).toHaveBeenCalled();\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"returns a redirect for custom pages for GET and POST request","suites":["Pages Router","pages","response type"],"line":575,"updatePoint":{"line":575,"column":70,"index":23911},"code":"      it('returns a redirect for custom pages for GET and POST request', async () => {\n        req.config.pages.customUrls = {\n          passwordResetLinkInvalid: 'http://invalid-link.example.com'\n        };\n        for (const method of ['GET', 'POST']) {\n          req.method = method;\n          await expectAsync(router.goToPage(req, pages.passwordResetLinkInvalid)).toBeResolved();\n          expect(pageResponse).not.toHaveBeenCalled();\n          expect(redirectResponse).toHaveBeenCalled();\n        }\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"responds to POST request with redirect response","suites":["Pages Router","pages","response type"],"line":586,"updatePoint":{"line":586,"column":57,"index":24413},"code":"      it('responds to POST request with redirect response', async () => {\n        await reconfigureServer(config);\n        const response = await request({\n          url: 'http://localhost:8378/1/apps/test/request_password_reset?token=exampleToken&username=exampleUsername&locale=de-AT',\n          followRedirects: false,\n          method: 'POST'\n        });\n        expect(response.status).toEqual(303);\n        expect(response.headers.location).toContain('http://localhost:8378/1/apps/de-AT/password_reset_link_invalid.html');\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"responds to GET request with content response","suites":["Pages Router","pages","response type"],"line":596,"updatePoint":{"line":596,"column":55,"index":24950},"code":"      it('responds to GET request with content response', async () => {\n        await reconfigureServer(config);\n        const response = await request({\n          url: 'http://localhost:8378/1/apps/test/request_password_reset?token=exampleToken&username=exampleUsername&locale=de-AT',\n          followRedirects: false,\n          method: 'GET'\n        });\n        expect(response.status).toEqual(200);\n        expect(response.text).toContain('<html>');\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"localizes end-to-end for password reset: success","suites":["Pages Router","pages","end-to-end tests"],"line":608,"updatePoint":{"line":608,"column":58,"index":25465},"code":"      it('localizes end-to-end for password reset: success', async () => {\n        await reconfigureServer(config);\n        const sendPasswordResetEmail = spyOn(config.emailAdapter, 'sendPasswordResetEmail').and.callThrough();\n        const user = new Parse.User();\n        user.setUsername('exampleUsername');\n        user.setPassword('examplePassword');\n        user.set('email', 'mail@example.com');\n        await user.signUp();\n        await Parse.User.requestPasswordReset(user.getEmail());\n        const link = sendPasswordResetEmail.calls.all()[0].args[0].link;\n        const linkWithLocale = new URL(link);\n        linkWithLocale.searchParams.append(pageParams.locale, exampleLocale);\n        const linkResponse = await request({\n          url: linkWithLocale.toString(),\n          followRedirects: false\n        });\n        expect(linkResponse.status).toBe(200);\n        const appId = linkResponse.headers['x-parse-page-param-appid'];\n        const token = linkResponse.headers['x-parse-page-param-token'];\n        const locale = linkResponse.headers['x-parse-page-param-locale'];\n        const username = linkResponse.headers['x-parse-page-param-username'];\n        const publicServerUrl = linkResponse.headers['x-parse-page-param-publicserverurl'];\n        const passwordResetPagePath = pageResponse.calls.all()[0].args[0];\n        expect(appId).toBeDefined();\n        expect(token).toBeDefined();\n        expect(locale).toBeDefined();\n        expect(username).toBeDefined();\n        expect(publicServerUrl).toBeDefined();\n        expect(passwordResetPagePath).toMatch(new RegExp(`\\/${exampleLocale}\\/${pages.passwordReset.defaultFile}`));\n        pageResponse.calls.reset();\n        const formUrl = `${publicServerUrl}/apps/${appId}/request_password_reset`;\n        const formResponse = await request({\n          url: formUrl,\n          method: 'POST',\n          body: {\n            token,\n            locale,\n            username,\n            new_password: 'newPassword'\n          },\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          },\n          followRedirects: false\n        });\n        expect(formResponse.status).toEqual(200);\n        expect(pageResponse.calls.all()[0].args[0]).toContain(`/${locale}/${pages.passwordResetSuccess.defaultFile}`);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"localizes end-to-end for password reset: invalid link","suites":["Pages Router","pages","end-to-end tests"],"line":656,"updatePoint":{"line":656,"column":63,"index":27789},"code":"      it('localizes end-to-end for password reset: invalid link', async () => {\n        await reconfigureServer(config);\n        const sendPasswordResetEmail = spyOn(config.emailAdapter, 'sendPasswordResetEmail').and.callThrough();\n        const user = new Parse.User();\n        user.setUsername('exampleUsername');\n        user.setPassword('examplePassword');\n        user.set('email', 'mail@example.com');\n        await user.signUp();\n        await Parse.User.requestPasswordReset(user.getEmail());\n        const link = sendPasswordResetEmail.calls.all()[0].args[0].link;\n        const linkWithLocale = new URL(link);\n        linkWithLocale.searchParams.append(pageParams.locale, exampleLocale);\n        linkWithLocale.searchParams.set(pageParams.token, 'invalidToken');\n        const linkResponse = await request({\n          url: linkWithLocale.toString(),\n          followRedirects: false\n        });\n        expect(linkResponse.status).toBe(200);\n        const pagePath = pageResponse.calls.all()[0].args[0];\n        expect(pagePath).toMatch(new RegExp(`\\/${exampleLocale}\\/${pages.passwordResetLinkInvalid.defaultFile}`));\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"localizes end-to-end for verify email: success","suites":["Pages Router","pages","end-to-end tests"],"line":677,"updatePoint":{"line":677,"column":56,"index":28921},"code":"      it('localizes end-to-end for verify email: success', async () => {\n        await reconfigureServer(config);\n        const sendVerificationEmail = spyOn(config.emailAdapter, 'sendVerificationEmail').and.callThrough();\n        const user = new Parse.User();\n        user.setUsername('exampleUsername');\n        user.setPassword('examplePassword');\n        user.set('email', 'mail@example.com');\n        await user.signUp();\n        const link = sendVerificationEmail.calls.all()[0].args[0].link;\n        const linkWithLocale = new URL(link);\n        linkWithLocale.searchParams.append(pageParams.locale, exampleLocale);\n        const linkResponse = await request({\n          url: linkWithLocale.toString(),\n          followRedirects: false\n        });\n        expect(linkResponse.status).toBe(200);\n        const pagePath = pageResponse.calls.all()[0].args[0];\n        expect(pagePath).toMatch(new RegExp(`\\/${exampleLocale}\\/${pages.emailVerificationSuccess.defaultFile}`));\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"localizes end-to-end for verify email: invalid verification link - link send success","suites":["Pages Router","pages","end-to-end tests"],"line":696,"updatePoint":{"line":696,"column":94,"index":29949},"code":"      it('localizes end-to-end for verify email: invalid verification link - link send success', async () => {\n        await reconfigureServer(config);\n        const sendVerificationEmail = spyOn(config.emailAdapter, 'sendVerificationEmail').and.callThrough();\n        const user = new Parse.User();\n        user.setUsername('exampleUsername');\n        user.setPassword('examplePassword');\n        user.set('email', 'mail@example.com');\n        await user.signUp();\n        const link = sendVerificationEmail.calls.all()[0].args[0].link;\n        const linkWithLocale = new URL(link);\n        linkWithLocale.searchParams.append(pageParams.locale, exampleLocale);\n        linkWithLocale.searchParams.set(pageParams.token, 'invalidToken');\n        const linkResponse = await request({\n          url: linkWithLocale.toString(),\n          followRedirects: false\n        });\n        expect(linkResponse.status).toBe(200);\n        const appId = linkResponse.headers['x-parse-page-param-appid'];\n        const locale = linkResponse.headers['x-parse-page-param-locale'];\n        const username = linkResponse.headers['x-parse-page-param-username'];\n        const publicServerUrl = linkResponse.headers['x-parse-page-param-publicserverurl'];\n        const invalidVerificationPagePath = pageResponse.calls.all()[0].args[0];\n        expect(appId).toBeDefined();\n        expect(locale).toBe(exampleLocale);\n        expect(username).toBeDefined();\n        expect(publicServerUrl).toBeDefined();\n        expect(invalidVerificationPagePath).toMatch(new RegExp(`\\/${exampleLocale}\\/${pages.emailVerificationLinkExpired.defaultFile}`));\n        const formUrl = `${publicServerUrl}/apps/${appId}/resend_verification_email`;\n        const formResponse = await request({\n          url: formUrl,\n          method: 'POST',\n          body: {\n            locale,\n            username\n          },\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          },\n          followRedirects: false\n        });\n        expect(formResponse.status).toEqual(303);\n        expect(formResponse.text).toContain(`/${locale}/${pages.emailVerificationSendSuccess.defaultFile}`);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"localizes end-to-end for verify email: invalid verification link - link send fail","suites":["Pages Router","pages","end-to-end tests"],"line":739,"updatePoint":{"line":739,"column":91,"index":32130},"code":"      it('localizes end-to-end for verify email: invalid verification link - link send fail', async () => {\n        await reconfigureServer(config);\n        const sendVerificationEmail = spyOn(config.emailAdapter, 'sendVerificationEmail').and.callThrough();\n        const user = new Parse.User();\n        user.setUsername('exampleUsername');\n        user.setPassword('examplePassword');\n        user.set('email', 'mail@example.com');\n        await user.signUp();\n        const link = sendVerificationEmail.calls.all()[0].args[0].link;\n        const linkWithLocale = new URL(link);\n        linkWithLocale.searchParams.append(pageParams.locale, exampleLocale);\n        linkWithLocale.searchParams.set(pageParams.token, 'invalidToken');\n        const linkResponse = await request({\n          url: linkWithLocale.toString(),\n          followRedirects: false\n        });\n        expect(linkResponse.status).toBe(200);\n        const appId = linkResponse.headers['x-parse-page-param-appid'];\n        const locale = linkResponse.headers['x-parse-page-param-locale'];\n        const username = linkResponse.headers['x-parse-page-param-username'];\n        const publicServerUrl = linkResponse.headers['x-parse-page-param-publicserverurl'];\n        const invalidVerificationPagePath = pageResponse.calls.all()[0].args[0];\n        expect(appId).toBeDefined();\n        expect(locale).toBe(exampleLocale);\n        expect(username).toBeDefined();\n        expect(publicServerUrl).toBeDefined();\n        expect(invalidVerificationPagePath).toMatch(new RegExp(`\\/${exampleLocale}\\/${pages.emailVerificationLinkExpired.defaultFile}`));\n        spyOn(UserController.prototype, 'resendVerificationEmail').and.callFake(() => Promise.reject('failed to resend verification email'));\n        const formUrl = `${publicServerUrl}/apps/${appId}/resend_verification_email`;\n        const formResponse = await request({\n          url: formUrl,\n          method: 'POST',\n          body: {\n            locale,\n            username\n          },\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          },\n          followRedirects: false\n        });\n        expect(formResponse.status).toEqual(303);\n        expect(formResponse.text).toContain(`/${locale}/${pages.emailVerificationSendFail.defaultFile}`);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"localizes end-to-end for resend verification email: invalid link","suites":["Pages Router","pages","end-to-end tests"],"line":783,"updatePoint":{"line":783,"column":74,"index":34433},"code":"      it('localizes end-to-end for resend verification email: invalid link', async () => {\n        await reconfigureServer(config);\n        const formUrl = `${config.publicServerURL}/apps/${config.appId}/resend_verification_email`;\n        const formResponse = await request({\n          url: formUrl,\n          method: 'POST',\n          body: {\n            locale: exampleLocale\n          },\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          },\n          followRedirects: false\n        });\n        expect(formResponse.status).toEqual(303);\n        expect(formResponse.text).toContain(`/${exampleLocale}/${pages.emailVerificationLinkInvalid.defaultFile}`);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"verifyEmail: throws on missing server configuration","suites":["Pages Router","pages","failing with missing parameters"],"line":802,"updatePoint":{"line":802,"column":61,"index":35195},"code":"      it('verifyEmail: throws on missing server configuration', async () => {\n        delete req.config;\n        const verifyEmail = req => (() => new PagesRouter().verifyEmail(req)).bind(null);\n        expect(verifyEmail(req)).toThrow();\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"resendVerificationEmail: throws on missing server configuration","suites":["Pages Router","pages","failing with missing parameters"],"line":807,"updatePoint":{"line":807,"column":73,"index":35456},"code":"      it('resendVerificationEmail: throws on missing server configuration', async () => {\n        delete req.config;\n        const resendVerificationEmail = req => (() => new PagesRouter().resendVerificationEmail(req)).bind(null);\n        expect(resendVerificationEmail(req)).toThrow();\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"requestResetPassword: throws on missing server configuration","suites":["Pages Router","pages","failing with missing parameters"],"line":812,"updatePoint":{"line":812,"column":70,"index":35750},"code":"      it('requestResetPassword: throws on missing server configuration', async () => {\n        delete req.config;\n        const requestResetPassword = req => (() => new PagesRouter().requestResetPassword(req)).bind(null);\n        expect(requestResetPassword(req)).toThrow();\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"resetPassword: throws on missing server configuration","suites":["Pages Router","pages","failing with missing parameters"],"line":817,"updatePoint":{"line":817,"column":63,"index":36028},"code":"      it('resetPassword: throws on missing server configuration', async () => {\n        delete req.config;\n        const resetPassword = req => (() => new PagesRouter().resetPassword(req)).bind(null);\n        expect(resetPassword(req)).toThrow();\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"verifyEmail: responds with invalid link on missing username","suites":["Pages Router","pages","failing with missing parameters"],"line":822,"updatePoint":{"line":822,"column":69,"index":36291},"code":"      it('verifyEmail: responds with invalid link on missing username', async () => {\n        req.query.token = 'exampleToken';\n        req.params = {};\n        req.config.userController = {\n          verifyEmail: () => Promise.reject()\n        };\n        const verifyEmail = req => new PagesRouter().verifyEmail(req);\n        await verifyEmail(req);\n        expect(goToPage.calls.all()[0].args[1]).toBe(pages.emailVerificationLinkInvalid);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"resetPassword: responds with page choose password with error message on failed password update","suites":["Pages Router","pages","failing with missing parameters"],"line":832,"updatePoint":{"line":832,"column":104,"index":36777},"code":"      it('resetPassword: responds with page choose password with error message on failed password update', async () => {\n        req.body = {\n          token: 'exampleToken',\n          username: 'exampleUsername',\n          new_password: 'examplePassword'\n        };\n        const error = 'exampleError';\n        req.config.userController = {\n          updatePassword: () => Promise.reject(error)\n        };\n        const resetPassword = req => new PagesRouter().resetPassword(req);\n        await resetPassword(req);\n        expect(goToPage.calls.all()[0].args[1]).toBe(pages.passwordReset);\n        expect(goToPage.calls.all()[0].args[2].error).toBe(error);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"resetPassword: responds with AJAX error with error message on failed password update","suites":["Pages Router","pages","failing with missing parameters"],"line":847,"updatePoint":{"line":847,"column":94,"index":37436},"code":"      it('resetPassword: responds with AJAX error with error message on failed password update', async () => {\n        req.xhr = true;\n        req.body = {\n          token: 'exampleToken',\n          username: 'exampleUsername',\n          new_password: 'examplePassword'\n        };\n        const error = 'exampleError';\n        req.config.userController = {\n          updatePassword: () => Promise.reject(error)\n        };\n        const resetPassword = req => new PagesRouter().resetPassword(req).catch(e => e);\n        const response = await resetPassword(req);\n        expect(response.code).toBe(Parse.Error.OTHER_CAUSE);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"rejects requesting file outside of pages scope with UNIX path patterns","suites":["Pages Router","pages","exploits"],"line":864,"updatePoint":{"line":864,"column":80,"index":38096},"code":"      it('rejects requesting file outside of pages scope with UNIX path patterns', async () => {\n        await reconfigureServer(config);\n\n        // Do not compose this URL with `new URL(...)` because that would normalize\n        // the URL and remove path patterns; the path patterns must reach the router\n        const url = `${config.publicServerURL}/apps/../.gitignore`;\n        const response = await request({\n          url: url,\n          followRedirects: false\n        }).catch(e => e);\n        expect(response.status).toBe(404);\n        expect(response.text).toBe('Not found.');\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"handles custom route with GET","suites":["Pages Router","pages","custom route"],"line":879,"updatePoint":{"line":879,"column":39,"index":38699},"code":"      it('handles custom route with GET', async () => {\n        config.pages.customRoutes = [{\n          method: 'GET',\n          path: 'custom_page',\n          handler: async req => {\n            expect(req).toBeDefined();\n            expect(req.method).toBe('GET');\n            return {\n              file: 'custom_page.html'\n            };\n          }\n        }];\n        await reconfigureServer(config);\n        const handlerSpy = spyOn(config.pages.customRoutes[0], 'handler').and.callThrough();\n        const url = `${config.publicServerURL}/apps/${config.appId}/custom_page`;\n        const response = await request({\n          url: url,\n          followRedirects: false\n        }).catch(e => e);\n        expect(response.status).toBe(200);\n        expect(response.text).toMatch(config.appName);\n        expect(handlerSpy).toHaveBeenCalled();\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"handles custom route with POST","suites":["Pages Router","pages","custom route"],"line":902,"updatePoint":{"line":902,"column":40,"index":39558},"code":"      it('handles custom route with POST', async () => {\n        config.pages.customRoutes = [{\n          method: 'POST',\n          path: 'custom_page',\n          handler: async req => {\n            expect(req).toBeDefined();\n            expect(req.method).toBe('POST');\n            return {\n              file: 'custom_page.html'\n            };\n          }\n        }];\n        const handlerSpy = spyOn(config.pages.customRoutes[0], 'handler').and.callThrough();\n        await reconfigureServer(config);\n        const url = `${config.publicServerURL}/apps/${config.appId}/custom_page`;\n        const response = await request({\n          url: url,\n          followRedirects: false,\n          method: 'POST'\n        }).catch(e => e);\n        expect(response.status).toBe(200);\n        expect(response.text).toMatch(config.appName);\n        expect(handlerSpy).toHaveBeenCalled();\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"handles multiple custom routes","suites":["Pages Router","pages","custom route"],"line":926,"updatePoint":{"line":926,"column":40,"index":40445},"code":"      it('handles multiple custom routes', async () => {\n        config.pages.customRoutes = [{\n          method: 'GET',\n          path: 'custom_page',\n          handler: async req => {\n            expect(req).toBeDefined();\n            expect(req.method).toBe('GET');\n            return {\n              file: 'custom_page.html'\n            };\n          }\n        }, {\n          method: 'POST',\n          path: 'custom_page',\n          handler: async req => {\n            expect(req).toBeDefined();\n            expect(req.method).toBe('POST');\n            return {\n              file: 'custom_page.html'\n            };\n          }\n        }];\n        const getHandlerSpy = spyOn(config.pages.customRoutes[0], 'handler').and.callThrough();\n        const postHandlerSpy = spyOn(config.pages.customRoutes[1], 'handler').and.callThrough();\n        await reconfigureServer(config);\n        const url = `${config.publicServerURL}/apps/${config.appId}/custom_page`;\n        const getResponse = await request({\n          url: url,\n          followRedirects: false,\n          method: 'GET'\n        }).catch(e => e);\n        expect(getResponse.status).toBe(200);\n        expect(getResponse.text).toMatch(config.appName);\n        expect(getHandlerSpy).toHaveBeenCalled();\n        const postResponse = await request({\n          url: url,\n          followRedirects: false,\n          method: 'POST'\n        }).catch(e => e);\n        expect(postResponse.status).toBe(200);\n        expect(postResponse.text).toMatch(config.appName);\n        expect(postHandlerSpy).toHaveBeenCalled();\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"handles custom route with async handler","suites":["Pages Router","pages","custom route"],"line":969,"updatePoint":{"line":969,"column":49,"index":42032},"code":"      it('handles custom route with async handler', async () => {\n        config.pages.customRoutes = [{\n          method: 'GET',\n          path: 'custom_page',\n          handler: async req => {\n            expect(req).toBeDefined();\n            expect(req.method).toBe('GET');\n            const file = await new Promise(resolve => setTimeout(resolve('custom_page.html'), 1000));\n            return {\n              file\n            };\n          }\n        }];\n        await reconfigureServer(config);\n        const handlerSpy = spyOn(config.pages.customRoutes[0], 'handler').and.callThrough();\n        const url = `${config.publicServerURL}/apps/${config.appId}/custom_page`;\n        const response = await request({\n          url: url,\n          followRedirects: false\n        }).catch(e => e);\n        expect(response.status).toBe(200);\n        expect(response.text).toMatch(config.appName);\n        expect(handlerSpy).toHaveBeenCalled();\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"returns 404 if custom route does not return page","suites":["Pages Router","pages","custom route"],"line":993,"updatePoint":{"line":993,"column":58,"index":42991},"code":"      it('returns 404 if custom route does not return page', async () => {\n        config.pages.customRoutes = [{\n          method: 'GET',\n          path: 'custom_page',\n          handler: async () => {}\n        }];\n        await reconfigureServer(config);\n        const handlerSpy = spyOn(config.pages.customRoutes[0], 'handler').and.callThrough();\n        const url = `${config.publicServerURL}/apps/${config.appId}/custom_page`;\n        const response = await request({\n          url: url,\n          followRedirects: false\n        }).catch(e => e);\n        expect(response.status).toBe(404);\n        expect(response.text).toMatch('Not found');\n        expect(handlerSpy).toHaveBeenCalled();\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"password reset works with custom endpoint","suites":["Pages Router","pages","custom endpoint"],"line":1012,"updatePoint":{"line":1012,"column":51,"index":43736},"code":"      it('password reset works with custom endpoint', async () => {\n        config.pages.pagesEndpoint = 'customEndpoint';\n        await reconfigureServer(config);\n        const sendPasswordResetEmail = spyOn(config.emailAdapter, 'sendPasswordResetEmail').and.callThrough();\n        const user = new Parse.User();\n        user.setUsername('exampleUsername');\n        user.setPassword('examplePassword');\n        user.set('email', 'mail@example.com');\n        await user.signUp();\n        await Parse.User.requestPasswordReset(user.getEmail());\n        const link = sendPasswordResetEmail.calls.all()[0].args[0].link;\n        const linkResponse = await request({\n          url: link,\n          followRedirects: false\n        });\n        expect(linkResponse.status).toBe(200);\n        const appId = linkResponse.headers['x-parse-page-param-appid'];\n        const token = linkResponse.headers['x-parse-page-param-token'];\n        const username = linkResponse.headers['x-parse-page-param-username'];\n        const publicServerUrl = linkResponse.headers['x-parse-page-param-publicserverurl'];\n        const passwordResetPagePath = pageResponse.calls.all()[0].args[0];\n        expect(appId).toBeDefined();\n        expect(token).toBeDefined();\n        expect(username).toBeDefined();\n        expect(publicServerUrl).toBeDefined();\n        expect(passwordResetPagePath).toMatch(new RegExp(`\\/${pages.passwordReset.defaultFile}`));\n        pageResponse.calls.reset();\n        const formUrl = `${publicServerUrl}/${config.pages.pagesEndpoint}/${appId}/request_password_reset`;\n        const formResponse = await request({\n          url: formUrl,\n          method: 'POST',\n          body: {\n            token,\n            username,\n            new_password: 'newPassword'\n          },\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          },\n          followRedirects: false\n        });\n        expect(formResponse.status).toEqual(200);\n        expect(pageResponse.calls.all()[0].args[0]).toContain(`/${pages.passwordResetSuccess.defaultFile}`);\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"email verification works with custom endpoint","suites":["Pages Router","pages","custom endpoint"],"line":1056,"updatePoint":{"line":1056,"column":55,"index":45827},"code":"      it('email verification works with custom endpoint', async () => {\n        config.pages.pagesEndpoint = 'customEndpoint';\n        await reconfigureServer(config);\n        const sendVerificationEmail = spyOn(config.emailAdapter, 'sendVerificationEmail').and.callThrough();\n        const user = new Parse.User();\n        user.setUsername('exampleUsername');\n        user.setPassword('examplePassword');\n        user.set('email', 'mail@example.com');\n        await user.signUp();\n        const link = sendVerificationEmail.calls.all()[0].args[0].link;\n        const linkResponse = await request({\n          url: link,\n          followRedirects: false\n        });\n        expect(linkResponse.status).toBe(200);\n        const pagePath = pageResponse.calls.all()[0].args[0];\n        expect(pagePath).toMatch(new RegExp(`\\/${pages.emailVerificationSuccess.defaultFile}`));\n      });","file":"PagesRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should properly send push","suites":["Parse.Push"],"line":104,"updatePoint":{"line":104,"column":31,"index":3226},"code":"  it('should properly send push', async () => {\n    const {\n      sendToInstallationSpy\n    } = await setup();\n    const pushStatusId = await Parse.Push.send({\n      where: {\n        deviceType: 'ios'\n      },\n      data: {\n        badge: 'Increment',\n        alert: 'Hello world!'\n      }\n    });\n    await pushCompleted(pushStatusId);\n    expect(sendToInstallationSpy.calls.count()).toEqual(10);\n  });","file":"Parse.Push.spec.js","skipped":false,"dir":"spec"},{"name":"should properly send push with lowercaseIncrement","suites":["Parse.Push"],"line":120,"updatePoint":{"line":120,"column":55,"index":3654},"code":"  it('should properly send push with lowercaseIncrement', async () => {\n    await setup();\n    const pushStatusId = await Parse.Push.send({\n      where: {\n        deviceType: 'ios'\n      },\n      data: {\n        badge: 'increment',\n        alert: 'Hello world!'\n      }\n    });\n    await pushCompleted(pushStatusId);\n  });","file":"Parse.Push.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow clients to query _PushStatus","suites":["Parse.Push"],"line":133,"updatePoint":{"line":133,"column":51,"index":3973},"code":"  it('should not allow clients to query _PushStatus', async () => {\n    await setup();\n    const pushStatusId = await Parse.Push.send({\n      where: {\n        deviceType: 'ios'\n      },\n      data: {\n        badge: 'increment',\n        alert: 'Hello world!'\n      }\n    });\n    await pushCompleted(pushStatusId);\n    try {\n      await request({\n        url: 'http://localhost:8378/1/classes/_PushStatus',\n        json: true,\n        headers: {\n          'X-Parse-Application-Id': 'test'\n        }\n      });\n      fail();\n    } catch (response) {\n      expect(response.data.error).toEqual('unauthorized');\n    }\n  });","file":"Parse.Push.spec.js","skipped":false,"dir":"spec"},{"name":"should allow master key to query _PushStatus","suites":["Parse.Push"],"line":158,"updatePoint":{"line":158,"column":50,"index":4589},"code":"  it('should allow master key to query _PushStatus', async () => {\n    await setup();\n    const pushStatusId = await Parse.Push.send({\n      where: {\n        deviceType: 'ios'\n      },\n      data: {\n        badge: 'increment',\n        alert: 'Hello world!'\n      }\n    });\n    await pushCompleted(pushStatusId);\n    const response = await request({\n      url: 'http://localhost:8378/1/classes/_PushStatus',\n      json: true,\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Master-Key': 'test'\n      }\n    });\n    const body = response.data;\n    expect(body.results.length).toEqual(1);\n    expect(body.results[0].query).toEqual('{\"deviceType\":\"ios\"}');\n    expect(body.results[0].payload).toEqual('{\"badge\":\"increment\",\"alert\":\"Hello world!\"}');\n  });","file":"Parse.Push.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error if missing push configuration","suites":["Parse.Push"],"line":183,"updatePoint":{"line":183,"column":54,"index":5372},"code":"  it('should throw error if missing push configuration', async () => {\n    await reconfigureServer({\n      push: null\n    });\n    try {\n      await Parse.Push.send({\n        where: {\n          deviceType: 'ios'\n        },\n        data: {\n          badge: 'increment',\n          alert: 'Hello world!'\n        }\n      });\n      fail();\n    } catch (err) {\n      expect(err.code).toEqual(Parse.Error.PUSH_MISCONFIGURED);\n    }\n  });","file":"Parse.Push.spec.js","skipped":false,"dir":"spec"},{"name":"does not get stuck with _PushStatus 'running' on 1 installation lost","suites":["Parse.Push"],"line":208,"updatePoint":{"line":208,"column":74,"index":6032},"code":"  it(\"does not get stuck with _PushStatus 'running' on 1 installation lost\", async () => {\n    await reconfigureServer({\n      push: {\n        adapter: losingAdapter\n      }\n    });\n    await Parse.Object.saveAll(provideInstallations());\n    const pushStatusId = await Parse.Push.send({\n      data: {\n        alert: 'We fixed our status!'\n      },\n      where: {\n        deviceType: 'android'\n      }\n    });\n    await pushCompleted(pushStatusId);\n    const result = await Parse.Push.getPushStatus(pushStatusId);\n    expect(result.get('status')).toEqual('succeeded');\n    expect(result.get('numSent')).toEqual(1);\n    expect(result.get('count')).toEqual(undefined);\n  });","file":"Parse.Push.spec.js","skipped":false,"dir":"spec"},{"name":"does not get stuck with _PushStatus 'running' on 1 installation added","suites":["Parse.Push"],"line":235,"updatePoint":{"line":235,"column":75,"index":6913},"code":"  it(\"does not get stuck with _PushStatus 'running' on 1 installation added\", async () => {\n    const installations = provideInstallations();\n\n    // add 1 iOS installation which we will omit & add later on\n    const iOSInstallation = new Parse.Object('_Installation');\n    iOSInstallation.set('installationId', 'installation_' + installations.length);\n    iOSInstallation.set('deviceToken', 'device_token_' + installations.length);\n    iOSInstallation.set('deviceType', 'ios');\n    installations.push(iOSInstallation);\n    await reconfigureServer({\n      push: {\n        adapter: {\n          send: function (body, installations) {\n            // simulate having added an installation before this was called\n            // thus invalidating our 'count' in _PushStatus\n            installations.push(iOSInstallation);\n            return successfulAny(body, installations);\n          },\n          getValidPushTypes: function () {\n            return ['android'];\n          }\n        }\n      }\n    });\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await Parse.Push.send({\n      data: {\n        alert: 'We fixed our status!'\n      },\n      where: {\n        deviceType: {\n          $ne: 'random'\n        }\n      }\n    });\n    await pushCompleted(pushStatusId);\n    const result = await Parse.Push.getPushStatus(pushStatusId);\n    expect(result.get('status')).toEqual('succeeded');\n    expect(result.get('numSent')).toEqual(3);\n    expect(result.get('count')).toEqual(undefined);\n  });","file":"Parse.Push.spec.js","skipped":false,"dir":"spec"},{"name":"does not get stuck with _PushStatus 'running' on many installations removed","suites":["Parse.Push"],"line":282,"updatePoint":{"line":282,"column":81,"index":8615},"code":"  it(\"does not get stuck with _PushStatus 'running' on many installations removed\", async () => {\n    const devices = 1000;\n    const installations = provideInstallations(devices);\n    await reconfigureServer({\n      push: {\n        adapter: losingAdapter\n      }\n    });\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await Parse.Push.send({\n      data: {\n        alert: 'We fixed our status!'\n      },\n      where: {\n        deviceType: 'android'\n      }\n    });\n    await pushCompleted(pushStatusId);\n    const result = await Parse.Push.getPushStatus(pushStatusId);\n    expect(result.get('status')).toEqual('succeeded');\n    // expect # less than # of batches used, assuming each batch is 100 pushes\n    expect(result.get('numSent')).toEqual(devices - devices / 100);\n    expect(result.get('count')).toEqual(undefined);\n  });","file":"Parse.Push.spec.js","skipped":false,"dir":"spec"},{"name":"does not get stuck with _PushStatus 'running' on many installations added","suites":["Parse.Push"],"line":312,"updatePoint":{"line":312,"column":79,"index":9656},"code":"  it(\"does not get stuck with _PushStatus 'running' on many installations added\", async () => {\n    const devices = 1000;\n    const installations = provideInstallations(devices);\n\n    // add 1 iOS installation which we will omit & add later on\n    const iOSInstallations = [];\n    while (iOSInstallations.length !== devices / 100) {\n      const iOSInstallation = new Parse.Object('_Installation');\n      iOSInstallation.set('installationId', 'installation_' + installations.length);\n      iOSInstallation.set('deviceToken', 'device_token_' + installations.length);\n      iOSInstallation.set('deviceType', 'ios');\n      installations.push(iOSInstallation);\n      iOSInstallations.push(iOSInstallation);\n    }\n    await reconfigureServer({\n      push: {\n        adapter: {\n          send: function (body, installations) {\n            // simulate having added an installation before this was called\n            // thus invalidating our 'count' in _PushStatus\n            installations.push(iOSInstallations.pop());\n            return successfulAny(body, installations);\n          },\n          getValidPushTypes: function () {\n            return ['android'];\n          }\n        }\n      }\n    });\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await Parse.Push.send({\n      data: {\n        alert: 'We fixed our status!'\n      },\n      where: {\n        deviceType: {\n          $ne: 'random'\n        }\n      }\n    });\n    await pushCompleted(pushStatusId);\n    const result = await Parse.Push.getPushStatus(pushStatusId);\n    expect(result.get('status')).toEqual('succeeded');\n    // expect # less than # of batches used, assuming each batch is 100 pushes\n    expect(result.get('numSent')).toEqual(devices + devices / 100);\n    expect(result.get('count')).toEqual(undefined);\n  });","file":"Parse.Push.spec.js","skipped":false,"dir":"spec"},{"name":"acl must be valid","suites":["Parse.ACL"],"line":7,"updatePoint":{"line":7,"column":23,"index":242},"code":"  it('acl must be valid', done => {\n    const user = new Parse.User();\n    ok(!user.setACL(\"Ceci n'est pas un ACL.\", {\n      error: function (user, error) {\n        equal(error.code, -1);\n        done();\n      }\n    }), 'setACL should have returned false.');\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"refresh object with acl","suites":["Parse.ACL"],"line":16,"updatePoint":{"line":16,"column":29,"index":513},"code":"  it('refresh object with acl', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp(null);\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    await object.fetch();\n    done();\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl an object owned by one user and public get","suites":["Parse.ACL"],"line":29,"updatePoint":{"line":29,"column":52,"index":930},"code":"  it('acl an object owned by one user and public get', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n    await Parse.User.logOut();\n    const query = new Parse.Query(TestObject);\n    try {\n      await query.get(object.id);\n      done.fail('Should not have retrieved the object.');\n    } catch (error) {\n      equal(error.code, Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl an object owned by one user and public find","suites":["Parse.ACL"],"line":54,"updatePoint":{"line":54,"column":53,"index":1834},"code":"  it('acl an object owned by one user and public find', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n\n    // Start making requests by the public, which should all fail.\n    await Parse.User.logOut();\n    // Find\n    const query = new Parse.Query(TestObject);\n    const results = await query.find();\n    equal(results.length, 0);\n    done();\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl an object owned by one user and public update","suites":["Parse.ACL"],"line":78,"updatePoint":{"line":78,"column":55,"index":2703},"code":"  it('acl an object owned by one user and public update', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n\n    // Start making requests by the public, which should all fail.\n    await Parse.User.logOut();\n    // Update\n    object.set('foo', 'bar');\n    try {\n      await object.save();\n      done.fail('Should not have been able to update the object.');\n    } catch (err) {\n      equal(err.code, Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl an object owned by one user and public delete","suites":["Parse.ACL"],"line":106,"updatePoint":{"line":106,"column":55,"index":3673},"code":"  it('acl an object owned by one user and public delete', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n\n    // Start making requests by the public, which should all fail.\n    await Parse.User.logOut();\n    try {\n      await object.destroy();\n      done.fail('destroy should fail');\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl an object owned by one user and logged in get","suites":["Parse.ACL"],"line":132,"updatePoint":{"line":132,"column":55,"index":4587},"code":"  it('acl an object owned by one user and logged in get', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n    await Parse.User.logOut();\n    await Parse.User.logIn('alice', 'wonderland');\n    // Get\n    const query = new Parse.Query(TestObject);\n    const result = await query.get(object.id);\n    ok(result);\n    equal(result.id, object.id);\n    equal(result.getACL().getReadAccess(user), true);\n    equal(result.getACL().getWriteAccess(user), true);\n    equal(result.getACL().getPublicReadAccess(), false);\n    equal(result.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n    done();\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl an object owned by one user and logged in find","suites":["Parse.ACL"],"line":161,"updatePoint":{"line":161,"column":56,"index":5716},"code":"  it('acl an object owned by one user and logged in find', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n    await Parse.User.logOut();\n    await Parse.User.logIn('alice', 'wonderland');\n    // Find\n    const query = new Parse.Query(TestObject);\n    const results = await query.find();\n    equal(results.length, 1);\n    const result = results[0];\n    ok(result);\n    if (!result) {\n      return fail();\n    }\n    equal(result.id, object.id);\n    equal(result.getACL().getReadAccess(user), true);\n    equal(result.getACL().getWriteAccess(user), true);\n    equal(result.getACL().getPublicReadAccess(), false);\n    equal(result.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n    done();\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl an object owned by one user and logged in update","suites":["Parse.ACL"],"line":195,"updatePoint":{"line":195,"column":58,"index":6948},"code":"  it('acl an object owned by one user and logged in update', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n    await Parse.User.logOut();\n    await Parse.User.logIn('alice', 'wonderland');\n    // Update\n    object.set('foo', 'bar');\n    await object.save();\n    done();\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl an object owned by one user and logged in delete","suites":["Parse.ACL"],"line":217,"updatePoint":{"line":217,"column":58,"index":7743},"code":"  it('acl an object owned by one user and logged in delete', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n    await Parse.User.logOut();\n    await Parse.User.logIn('alice', 'wonderland');\n    // Delete\n    await object.destroy();\n    done();\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl making an object publicly readable and public get","suites":["Parse.ACL"],"line":238,"updatePoint":{"line":238,"column":59,"index":8512},"code":"  it('acl making an object publicly readable and public get', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n\n    // Now make it public.\n    object.getACL().setPublicReadAccess(true);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), true);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n    await Parse.User.logOut();\n    // Get\n    const query = new Parse.Query(TestObject);\n    const result = await query.get(object.id);\n    ok(result);\n    equal(result.id, object.id);\n    done();\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl making an object publicly readable and public find","suites":["Parse.ACL"],"line":270,"updatePoint":{"line":270,"column":60,"index":9693},"code":"  it('acl making an object publicly readable and public find', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n\n    // Now make it public.\n    object.getACL().setPublicReadAccess(true);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), true);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n    await Parse.User.logOut();\n    // Find\n    const query = new Parse.Query(TestObject);\n    const results = await query.find();\n    equal(results.length, 1);\n    const result = results[0];\n    ok(result);\n    equal(result.id, object.id);\n    done();\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl making an object publicly readable and public update","suites":["Parse.ACL"],"line":304,"updatePoint":{"line":304,"column":62,"index":10931},"code":"  it('acl making an object publicly readable and public update', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n\n    // Now make it public.\n    object.getACL().setPublicReadAccess(true);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), true);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n    await Parse.User.logOut();\n    object.set('foo', 'bar');\n    object.save().then(() => {\n      fail('the save should fail');\n    }, error => {\n      expect(error.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl making an object publicly readable and public delete","suites":["Parse.ACL"],"line":337,"updatePoint":{"line":337,"column":62,"index":12149},"code":"  it('acl making an object publicly readable and public delete', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n\n    // Now make it public.\n    object.getACL().setPublicReadAccess(true);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), true);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n    Parse.User.logOut().then(() => object.destroy()).then(() => {\n      fail('expected failure');\n    }, error => {\n      expect(error.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl making an object publicly writable and public get","suites":["Parse.ACL"],"line":368,"updatePoint":{"line":368,"column":59,"index":13334},"code":"  it('acl making an object publicly writable and public get', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n\n    // Now make it public.\n    object.getACL().setPublicWriteAccess(true);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), true);\n    ok(object.get('ACL'));\n    await Parse.User.logOut();\n    // Get\n    const query = new Parse.Query(TestObject);\n    query.get(object.id).then(done.fail).catch(error => {\n      equal(error.code, Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl making an object publicly writable and public find","suites":["Parse.ACL"],"line":400,"updatePoint":{"line":400,"column":60,"index":14543},"code":"  it('acl making an object publicly writable and public find', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n\n    // Now make it public.\n    object.getACL().setPublicWriteAccess(true);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), true);\n    ok(object.get('ACL'));\n    await Parse.User.logOut();\n    // Find\n    const query = new Parse.Query(TestObject);\n    query.find().then(function (results) {\n      equal(results.length, 0);\n      done();\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl making an object publicly writable and public update","suites":["Parse.ACL"],"line":432,"updatePoint":{"line":432,"column":62,"index":15717},"code":"  it('acl making an object publicly writable and public update', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n\n    // Now make it public.\n    object.getACL().setPublicWriteAccess(true);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), true);\n    ok(object.get('ACL'));\n    Parse.User.logOut().then(() => {\n      // Update\n      object.set('foo', 'bar');\n      object.save().then(done);\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl making an object publicly writable and public delete","suites":["Parse.ACL"],"line":462,"updatePoint":{"line":462,"column":62,"index":16829},"code":"  it('acl making an object publicly writable and public delete', async done => {\n    // Create an object owned by Alice.\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    await user.signUp();\n    const object = new TestObject();\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    ok(object.get('ACL'));\n\n    // Now make it public.\n    object.getACL().setPublicWriteAccess(true);\n    await object.save();\n    equal(object.getACL().getReadAccess(user), true);\n    equal(object.getACL().getWriteAccess(user), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), true);\n    ok(object.get('ACL'));\n    Parse.User.logOut().then(() => {\n      // Delete\n      object.destroy().then(done);\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl making an object privately writable (#3194)","suites":["Parse.ACL"],"line":491,"updatePoint":{"line":491,"column":53,"index":17903},"code":"  it('acl making an object privately writable (#3194)', done => {\n    // Create an object owned by Alice.\n    let object;\n    let user2;\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'wonderland');\n    user.signUp().then(() => {\n      object = new TestObject();\n      const acl = new Parse.ACL(user);\n      acl.setPublicWriteAccess(false);\n      acl.setPublicReadAccess(true);\n      object.setACL(acl);\n      return object.save().then(() => {\n        return Parse.User.logOut();\n      });\n    }).then(() => {\n      user2 = new Parse.User();\n      user2.set('username', 'bob');\n      user2.set('password', 'burger');\n      return user2.signUp();\n    }).then(() => {\n      return object.destroy({\n        sessionToken: user2.getSessionToken()\n      });\n    }).then(() => {\n      fail('should not be able to destroy the object');\n      done();\n    }, err => {\n      expect(err).not.toBeUndefined();\n      done();\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl sharing with another user and get","suites":["Parse.ACL"],"line":524,"updatePoint":{"line":524,"column":43,"index":18866},"code":"  it('acl sharing with another user and get', async done => {\n    // Sign in as Bob.\n    const bob = await Parse.User.signUp('bob', 'pass');\n    await Parse.User.logOut();\n    const alice = await Parse.User.signUp('alice', 'wonderland');\n    // Create an object shared by Bob and Alice.\n    const object = new TestObject();\n    const acl = new Parse.ACL(alice);\n    acl.setWriteAccess(bob, true);\n    acl.setReadAccess(bob, true);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(alice), true);\n    equal(object.getACL().getWriteAccess(alice), true);\n    equal(object.getACL().getReadAccess(bob), true);\n    equal(object.getACL().getWriteAccess(bob), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n\n    // Sign in as Bob again.\n    await Parse.User.logIn('bob', 'pass');\n    const query = new Parse.Query(TestObject);\n    query.get(object.id).then(result => {\n      ok(result);\n      equal(result.id, object.id);\n      done();\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl sharing with another user and find","suites":["Parse.ACL"],"line":552,"updatePoint":{"line":552,"column":44,"index":19923},"code":"  it('acl sharing with another user and find', async done => {\n    // Sign in as Bob.\n    const bob = await Parse.User.signUp('bob', 'pass');\n    await Parse.User.logOut();\n    // Sign in as Alice.\n    const alice = await Parse.User.signUp('alice', 'wonderland');\n    // Create an object shared by Bob and Alice.\n    const object = new TestObject();\n    const acl = new Parse.ACL(alice);\n    acl.setWriteAccess(bob, true);\n    acl.setReadAccess(bob, true);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(alice), true);\n    equal(object.getACL().getWriteAccess(alice), true);\n    equal(object.getACL().getReadAccess(bob), true);\n    equal(object.getACL().getWriteAccess(bob), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n\n    // Sign in as Bob again.\n    await Parse.User.logIn('bob', 'pass');\n    const query = new Parse.Query(TestObject);\n    query.find().then(results => {\n      equal(results.length, 1);\n      const result = results[0];\n      ok(result);\n      if (!result) {\n        fail('should have result');\n      } else {\n        equal(result.id, object.id);\n      }\n      done();\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl sharing with another user and update","suites":["Parse.ACL"],"line":587,"updatePoint":{"line":587,"column":46,"index":21147},"code":"  it('acl sharing with another user and update', async done => {\n    // Sign in as Bob.\n    const bob = await Parse.User.signUp('bob', 'pass');\n    await Parse.User.logOut();\n    // Sign in as Alice.\n    const alice = await Parse.User.signUp('alice', 'wonderland');\n    // Create an object shared by Bob and Alice.\n    const object = new TestObject();\n    const acl = new Parse.ACL(alice);\n    acl.setWriteAccess(bob, true);\n    acl.setReadAccess(bob, true);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(alice), true);\n    equal(object.getACL().getWriteAccess(alice), true);\n    equal(object.getACL().getReadAccess(bob), true);\n    equal(object.getACL().getWriteAccess(bob), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n\n    // Sign in as Bob again.\n    await Parse.User.logIn('bob', 'pass');\n    object.set('foo', 'bar');\n    object.save().then(done);\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl sharing with another user and delete","suites":["Parse.ACL"],"line":612,"updatePoint":{"line":612,"column":46,"index":22127},"code":"  it('acl sharing with another user and delete', async done => {\n    // Sign in as Bob.\n    const bob = await Parse.User.signUp('bob', 'pass');\n    await Parse.User.logOut();\n    // Sign in as Alice.\n    const alice = await Parse.User.signUp('alice', 'wonderland');\n    // Create an object shared by Bob and Alice.\n    const object = new TestObject();\n    const acl = new Parse.ACL(alice);\n    acl.setWriteAccess(bob, true);\n    acl.setReadAccess(bob, true);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(alice), true);\n    equal(object.getACL().getWriteAccess(alice), true);\n    equal(object.getACL().getReadAccess(bob), true);\n    equal(object.getACL().getWriteAccess(bob), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n\n    // Sign in as Bob again.\n    await Parse.User.logIn('bob', 'pass');\n    object.set('foo', 'bar');\n    object.destroy().then(done);\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl sharing with another user and public get","suites":["Parse.ACL"],"line":637,"updatePoint":{"line":637,"column":50,"index":23114},"code":"  it('acl sharing with another user and public get', async done => {\n    const bob = await Parse.User.signUp('bob', 'pass');\n    await Parse.User.logOut();\n    // Sign in as Alice.\n    const alice = await Parse.User.signUp('alice', 'wonderland');\n    // Create an object shared by Bob and Alice.\n    const object = new TestObject();\n    const acl = new Parse.ACL(alice);\n    acl.setWriteAccess(bob, true);\n    acl.setReadAccess(bob, true);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(alice), true);\n    equal(object.getACL().getWriteAccess(alice), true);\n    equal(object.getACL().getReadAccess(bob), true);\n    equal(object.getACL().getWriteAccess(bob), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n    // Start making requests by the public.\n    await Parse.User.logOut();\n    const query = new Parse.Query(TestObject);\n    query.get(object.id).then(result => {\n      fail(result);\n    }, error => {\n      expect(error.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl sharing with another user and public find","suites":["Parse.ACL"],"line":665,"updatePoint":{"line":665,"column":51,"index":24231},"code":"  it('acl sharing with another user and public find', async done => {\n    const bob = await Parse.User.signUp('bob', 'pass');\n    await Parse.User.logOut();\n    // Sign in as Alice.\n    const alice = await Parse.User.signUp('alice', 'wonderland');\n    // Create an object shared by Bob and Alice.\n    const object = new TestObject();\n    const acl = new Parse.ACL(alice);\n    acl.setWriteAccess(bob, true);\n    acl.setReadAccess(bob, true);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(alice), true);\n    equal(object.getACL().getWriteAccess(alice), true);\n    equal(object.getACL().getReadAccess(bob), true);\n    equal(object.getACL().getWriteAccess(bob), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n\n    // Start making requests by the public.\n    Parse.User.logOut().then(() => {\n      const query = new Parse.Query(TestObject);\n      query.find().then(function (results) {\n        equal(results.length, 0);\n        done();\n      });\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl sharing with another user and public update","suites":["Parse.ACL"],"line":693,"updatePoint":{"line":693,"column":53,"index":25306},"code":"  it('acl sharing with another user and public update', async done => {\n    // Sign in as Bob.\n    const bob = await Parse.User.signUp('bob', 'pass');\n    await Parse.User.logOut();\n    // Sign in as Alice.\n    const alice = await Parse.User.signUp('alice', 'wonderland');\n    // Create an object shared by Bob and Alice.\n    const object = new TestObject();\n    const acl = new Parse.ACL(alice);\n    acl.setWriteAccess(bob, true);\n    acl.setReadAccess(bob, true);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(alice), true);\n    equal(object.getACL().getWriteAccess(alice), true);\n    equal(object.getACL().getReadAccess(bob), true);\n    equal(object.getACL().getWriteAccess(bob), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n\n    // Start making requests by the public.\n    Parse.User.logOut().then(() => {\n      object.set('foo', 'bar');\n      object.save().then(() => {\n        fail('expected failure');\n      }, error => {\n        expect(error.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n        done();\n      });\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl sharing with another user and public delete","suites":["Parse.ACL"],"line":724,"updatePoint":{"line":724,"column":53,"index":26461},"code":"  it('acl sharing with another user and public delete', async done => {\n    // Sign in as Bob.\n    const bob = await Parse.User.signUp('bob', 'pass');\n    await Parse.User.logOut();\n    // Sign in as Alice.\n    const alice = await Parse.User.signUp('alice', 'wonderland');\n    // Create an object shared by Bob and Alice.\n    const object = new TestObject();\n    const acl = new Parse.ACL(alice);\n    acl.setWriteAccess(bob, true);\n    acl.setReadAccess(bob, true);\n    object.setACL(acl);\n    await object.save();\n    equal(object.getACL().getReadAccess(alice), true);\n    equal(object.getACL().getWriteAccess(alice), true);\n    equal(object.getACL().getReadAccess(bob), true);\n    equal(object.getACL().getWriteAccess(bob), true);\n    equal(object.getACL().getPublicReadAccess(), false);\n    equal(object.getACL().getPublicWriteAccess(), false);\n\n    // Start making requests by the public.\n    Parse.User.logOut().then(() => object.destroy()).then(() => {\n      fail('expected failure');\n    }, error => {\n      expect(error.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"acl saveAll with permissions","suites":["Parse.ACL"],"line":752,"updatePoint":{"line":752,"column":34,"index":27543},"code":"  it('acl saveAll with permissions', async done => {\n    const alice = await Parse.User.signUp('alice', 'wonderland');\n    const acl = new Parse.ACL(alice);\n    const object1 = new TestObject();\n    const object2 = new TestObject();\n    object1.setACL(acl);\n    object2.setACL(acl);\n    await Parse.Object.saveAll([object1, object2]);\n    equal(object1.getACL().getReadAccess(alice), true);\n    equal(object1.getACL().getWriteAccess(alice), true);\n    equal(object1.getACL().getPublicReadAccess(), false);\n    equal(object1.getACL().getPublicWriteAccess(), false);\n    equal(object2.getACL().getReadAccess(alice), true);\n    equal(object2.getACL().getWriteAccess(alice), true);\n    equal(object2.getACL().getPublicReadAccess(), false);\n    equal(object2.getACL().getPublicWriteAccess(), false);\n\n    // Save all the objects after updating them.\n    object1.set('foo', 'bar');\n    object2.set('foo', 'bar');\n    await Parse.Object.saveAll([object1, object2]);\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    query.find().then(function (results) {\n      equal(results.length, 2);\n      done();\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"empty acl works","suites":["Parse.ACL"],"line":780,"updatePoint":{"line":780,"column":21,"index":28672},"code":"  it('empty acl works', async done => {\n    await Parse.User.signUp('tdurden', 'mayhem', {\n      ACL: new Parse.ACL(),\n      foo: 'bar'\n    });\n    await Parse.User.logOut();\n    const user = await Parse.User.logIn('tdurden', 'mayhem');\n    equal(user.get('foo'), 'bar');\n    done();\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"query for included object with ACL works","suites":["Parse.ACL"],"line":790,"updatePoint":{"line":790,"column":46,"index":28987},"code":"  it('query for included object with ACL works', async done => {\n    const obj1 = new Parse.Object('TestClass1');\n    const obj2 = new Parse.Object('TestClass2');\n    const acl = new Parse.ACL();\n    acl.setPublicReadAccess(true);\n    obj2.set('ACL', acl);\n    obj1.set('other', obj2);\n    await obj1.save();\n    obj2._clearServerData();\n    const query = new Parse.Query('TestClass1');\n    const obj1Again = await query.first();\n    ok(!obj1Again.get('other').get('ACL'));\n    query.include('other');\n    const obj1AgainWithInclude = await query.first();\n    ok(obj1AgainWithInclude.get('other').get('ACL'));\n    done();\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"restricted ACL does not have public access","suites":["Parse.ACL"],"line":807,"updatePoint":{"line":807,"column":48,"index":29617},"code":"  it('restricted ACL does not have public access', done => {\n    const obj = new Parse.Object('TestClassMasterACL');\n    const acl = new Parse.ACL();\n    obj.set('ACL', acl);\n    obj.save().then(() => {\n      const query = new Parse.Query('TestClassMasterACL');\n      return query.find();\n    }).then(results => {\n      ok(!results.length, 'Should not have returned object with secure ACL.');\n      done();\n    });\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"regression test #701","suites":["Parse.ACL"],"line":819,"updatePoint":{"line":819,"column":26,"index":30016},"code":"  it('regression test #701', done => {\n    const config = Config.get('test');\n    const anonUser = {\n      authData: {\n        anonymous: {\n          id: '00000000-0000-0000-0000-000000000001'\n        }\n      }\n    };\n    Parse.Cloud.afterSave(Parse.User, req => {\n      if (!req.object.existed()) {\n        const user = req.object;\n        const acl = new Parse.ACL(user);\n        user.setACL(acl);\n        user.save(null, {\n          useMasterKey: true\n        }).then(user => {\n          new Parse.Query('_User').get(user.objectId).then(() => {\n            fail('should not have fetched user without public read enabled');\n            done();\n          }, error => {\n            expect(error.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n            done();\n          });\n        }, done.fail);\n      }\n    });\n    rest.create(config, auth.nobody(config), '_User', anonUser);\n  });","file":"ParseACL.spec.js","skipped":false,"dir":"spec"},{"name":"db contains document after successful save","suites":["miscellaneous"],"line":21,"updatePoint":{"line":21,"column":48,"index":844},"code":"  it('db contains document after successful save', async () => {\n    const obj = new Parse.Object('TestObject');\n    obj.set('foo', 'bar');\n    await obj.save();\n    const config = Config.get(defaultConfiguration.appId);\n    const results = await config.database.adapter.find('TestObject', {\n      fields: {}\n    }, {}, {});\n    expect(results.length).toEqual(1);\n    expect(results[0]['foo']).toEqual('bar');\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"create a GameScore object","suites":["miscellaneous"],"line":34,"updatePoint":{"line":34,"column":31,"index":1287},"code":"  it('create a GameScore object', function (done) {\n    const obj = new Parse.Object('GameScore');\n    obj.set('score', 1337);\n    obj.save().then(function (obj) {\n      expect(typeof obj.id).toBe('string');\n      expect(typeof obj.createdAt.toGMTString()).toBe('string');\n      done();\n    }, done.fail);\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"get a TestObject","suites":["miscellaneous"],"line":43,"updatePoint":{"line":43,"column":22,"index":1590},"code":"  it('get a TestObject', function (done) {\n    create({\n      bloop: 'blarg'\n    }, async function (obj) {\n      const t2 = new TestObject({\n        objectId: obj.id\n      });\n      const obj2 = await t2.fetch();\n      expect(obj2.get('bloop')).toEqual('blarg');\n      expect(obj2.id).toBeTruthy();\n      expect(obj2.id).toEqual(obj.id);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"create a valid parse user","suites":["miscellaneous"],"line":57,"updatePoint":{"line":57,"column":31,"index":1965},"code":"  it('create a valid parse user', function (done) {\n    createTestUser().then(function (data) {\n      expect(data.id).not.toBeUndefined();\n      expect(data.getSessionToken()).not.toBeUndefined();\n      expect(data.get('password')).toBeUndefined();\n      done();\n    }, done.fail);\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"fail to create a duplicate username","suites":["miscellaneous"],"line":65,"updatePoint":{"line":65,"column":41,"index":2263},"code":"  it('fail to create a duplicate username', async () => {\n    await reconfigureServer();\n    let numFailed = 0;\n    let numCreated = 0;\n    const p1 = request({\n      method: 'POST',\n      url: Parse.serverURL + '/users',\n      body: {\n        password: 'asdf',\n        username: 'u1',\n        email: 'dupe@dupe.dupe'\n      },\n      headers\n    }).then(() => {\n      numCreated++;\n      expect(numCreated).toEqual(1);\n    }, response => {\n      numFailed++;\n      expect(response.data.code).toEqual(Parse.Error.USERNAME_TAKEN);\n    });\n    const p2 = request({\n      method: 'POST',\n      url: Parse.serverURL + '/users',\n      body: {\n        password: 'otherpassword',\n        username: 'u1',\n        email: 'email@other.email'\n      },\n      headers\n    }).then(() => {\n      numCreated++;\n    }, ({\n      data\n    }) => {\n      numFailed++;\n      expect(data.code).toEqual(Parse.Error.USERNAME_TAKEN);\n    });\n    await Promise.all([p1, p2]);\n    expect(numFailed).toEqual(1);\n    expect(numCreated).toBe(1);\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"ensure that email is uniquely indexed","suites":["miscellaneous"],"line":106,"updatePoint":{"line":106,"column":43,"index":3284},"code":"  it('ensure that email is uniquely indexed', async () => {\n    await reconfigureServer();\n    let numFailed = 0;\n    let numCreated = 0;\n    const p1 = request({\n      method: 'POST',\n      url: Parse.serverURL + '/users',\n      body: {\n        password: 'asdf',\n        username: 'u1',\n        email: 'dupe@dupe.dupe'\n      },\n      headers\n    }).then(() => {\n      numCreated++;\n      expect(numCreated).toEqual(1);\n    }, ({\n      data\n    }) => {\n      numFailed++;\n      expect(data.code).toEqual(Parse.Error.EMAIL_TAKEN);\n    });\n    const p2 = request({\n      url: Parse.serverURL + '/users',\n      method: 'POST',\n      body: {\n        password: 'asdf',\n        username: 'u2',\n        email: 'dupe@dupe.dupe'\n      },\n      headers\n    }).then(() => {\n      numCreated++;\n      expect(numCreated).toEqual(1);\n    }, ({\n      data\n    }) => {\n      numFailed++;\n      expect(data.code).toEqual(Parse.Error.EMAIL_TAKEN);\n    });\n    await Promise.all([p1, p2]);\n    expect(numFailed).toEqual(1);\n    expect(numCreated).toBe(1);\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"ensure that if people already have duplicate users, they can still sign up new users","suites":["miscellaneous"],"line":150,"updatePoint":{"line":150,"column":90,"index":4374},"code":"  it('ensure that if people already have duplicate users, they can still sign up new users', async done => {\n    try {\n      await Parse.User.logOut();\n    } catch (e) {\n      /* ignore */\n    }\n    const config = Config.get('test');\n    // Remove existing data to clear out unique index\n    TestUtils.destroyAllDataPermanently().then(() => config.database.adapter.performInitialization({\n      VolatileClassesSchemas: []\n    })).then(() => config.database.adapter.createClass('_User', userSchema)).then(() => config.database.adapter.createObject('_User', userSchema, {\n      objectId: 'x',\n      username: 'u'\n    }).catch(fail)).then(() => config.database.adapter.createObject('_User', userSchema, {\n      objectId: 'y',\n      username: 'u'\n    }).catch(fail))\n    // Create a new server to try to recreate the unique indexes\n    .then(reconfigureServer).catch(error => {\n      expect(error.code).toEqual(Parse.Error.DUPLICATE_VALUE);\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      return user.signUp().catch(fail);\n    }).then(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('u');\n      return user.signUp();\n    }).then(() => {\n      fail('should not have been able to sign up');\n      done();\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.USERNAME_TAKEN);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"ensure that if people already have duplicate emails, they can still sign up new users","suites":["miscellaneous"],"line":187,"updatePoint":{"line":187,"column":91,"index":5799},"code":"  it('ensure that if people already have duplicate emails, they can still sign up new users', done => {\n    const config = Config.get('test');\n    // Remove existing data to clear out unique index\n    TestUtils.destroyAllDataPermanently().then(() => config.database.adapter.performInitialization({\n      VolatileClassesSchemas: []\n    })).then(() => config.database.adapter.createClass('_User', userSchema)).then(() => config.database.adapter.createObject('_User', userSchema, {\n      objectId: 'x',\n      email: 'a@b.c'\n    })).then(() => config.database.adapter.createObject('_User', userSchema, {\n      objectId: 'y',\n      email: 'a@b.c'\n    })).then(reconfigureServer).catch(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('qqq');\n      user.setEmail('unique@unique.unique');\n      return user.signUp().catch(fail);\n    }).then(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('www');\n      user.setEmail('a@b.c');\n      return user.signUp();\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.EMAIL_TAKEN);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"ensure that if you try to sign up a user with a unique username and email, but duplicates in some other field that has a uniqueness constraint, you get a regular duplicate value error","suites":["miscellaneous"],"line":215,"updatePoint":{"line":215,"column":189,"index":7059},"code":"  it('ensure that if you try to sign up a user with a unique username and email, but duplicates in some other field that has a uniqueness constraint, you get a regular duplicate value error', async done => {\n    await reconfigureServer();\n    const config = Config.get('test');\n    config.database.adapter.addFieldIfNotExists('_User', 'randomField', {\n      type: 'String'\n    }).then(() => config.database.adapter.ensureUniqueness('_User', userSchema, ['randomField'])).then(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('1');\n      user.setEmail('1@b.c');\n      user.set('randomField', 'a');\n      return user.signUp();\n    }).then(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('2');\n      user.setEmail('2@b.c');\n      user.set('randomField', 'a');\n      return user.signUp();\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.DUPLICATE_VALUE);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"succeed in logging in","suites":["miscellaneous"],"line":239,"updatePoint":{"line":239,"column":27,"index":7900},"code":"  it('succeed in logging in', function (done) {\n    createTestUser().then(async function (u) {\n      expect(typeof u.id).toEqual('string');\n      const user = await Parse.User.logIn('test', 'moon-y');\n      expect(typeof user.id).toEqual('string');\n      expect(user.get('password')).toBeUndefined();\n      expect(user.getSessionToken()).not.toBeUndefined();\n      await Parse.User.logOut();\n      done();\n    }, fail);\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"increment with a user object","suites":["miscellaneous"],"line":250,"updatePoint":{"line":250,"column":34,"index":8333},"code":"  it('increment with a user object', function (done) {\n    createTestUser().then(user => {\n      user.increment('foo');\n      return user.save();\n    }).then(() => {\n      return Parse.User.logIn('test', 'moon-y');\n    }).then(user => {\n      expect(user.get('foo')).toEqual(1);\n      user.increment('foo');\n      return user.save();\n    }).then(() => Parse.User.logOut()).then(() => Parse.User.logIn('test', 'moon-y')).then(user => {\n      expect(user.get('foo')).toEqual(2);\n      Parse.User.logOut().then(done);\n    }, error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"save various data types","suites":["miscellaneous"],"line":268,"updatePoint":{"line":268,"column":29,"index":8924},"code":"  it('save various data types', function (done) {\n    const obj = new TestObject();\n    obj.set('date', new Date());\n    obj.set('array', [1, 2, 3]);\n    obj.set('object', {\n      one: 1,\n      two: 2\n    });\n    obj.save().then(() => {\n      const obj2 = new TestObject({\n        objectId: obj.id\n      });\n      return obj2.fetch();\n    }).then(obj2 => {\n      expect(obj2.get('date') instanceof Date).toBe(true);\n      expect(obj2.get('array') instanceof Array).toBe(true);\n      expect(obj2.get('object') instanceof Array).toBe(false);\n      expect(obj2.get('object') instanceof Object).toBe(true);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"query with limit","suites":["miscellaneous"],"line":289,"updatePoint":{"line":289,"column":22,"index":9548},"code":"  it('query with limit', function (done) {\n    const baz = new TestObject({\n      foo: 'baz'\n    });\n    const qux = new TestObject({\n      foo: 'qux'\n    });\n    baz.save().then(() => {\n      return qux.save();\n    }).then(() => {\n      const query = new Parse.Query(TestObject);\n      query.limit(1);\n      return query.find();\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      done();\n    }, error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"query without limit get default 100 records","suites":["miscellaneous"],"line":310,"updatePoint":{"line":310,"column":49,"index":10066},"code":"  it('query without limit get default 100 records', function (done) {\n    const objects = [];\n    for (let i = 0; i < 150; i++) {\n      objects.push(new TestObject({\n        name: 'name' + i\n      }));\n    }\n    Parse.Object.saveAll(objects).then(() => {\n      return new Parse.Query(TestObject).find();\n    }).then(results => {\n      expect(results.length).toEqual(100);\n      done();\n    }, error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"basic saveAll","suites":["miscellaneous"],"line":327,"updatePoint":{"line":327,"column":19,"index":10503},"code":"  it('basic saveAll', function (done) {\n    const alpha = new TestObject({\n      letter: 'alpha'\n    });\n    const beta = new TestObject({\n      letter: 'beta'\n    });\n    Parse.Object.saveAll([alpha, beta]).then(() => {\n      expect(alpha.id).toBeTruthy();\n      expect(beta.id).toBeTruthy();\n      return new Parse.Query(TestObject).find();\n    }).then(results => {\n      expect(results.length).toEqual(2);\n      done();\n    }, error => {\n      fail(error);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeSave set object acl success","suites":["miscellaneous"],"line":346,"updatePoint":{"line":346,"column":44,"index":11016},"code":"  it('test beforeSave set object acl success', function (done) {\n    const acl = new Parse.ACL({\n      '*': {\n        read: true,\n        write: false\n      }\n    });\n    Parse.Cloud.beforeSave('BeforeSaveAddACL', function (req) {\n      req.object.setACL(acl);\n    });\n    const obj = new Parse.Object('BeforeSaveAddACL');\n    obj.set('lol', true);\n    obj.save().then(function () {\n      const query = new Parse.Query('BeforeSaveAddACL');\n      query.get(obj.id).then(function (objAgain) {\n        expect(objAgain.get('lol')).toBeTruthy();\n        expect(objAgain.getACL().equals(acl));\n        done();\n      }, function (error) {\n        fail(error);\n        done();\n      });\n    }, error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"object is set on create and update","suites":["miscellaneous"],"line":373,"updatePoint":{"line":373,"column":40,"index":11772},"code":"  it('object is set on create and update', done => {\n    let triggerTime = 0;\n    // Register a mock beforeSave hook\n    Parse.Cloud.beforeSave('GameScore', req => {\n      const object = req.object;\n      expect(object instanceof Parse.Object).toBeTruthy();\n      expect(object.get('fooAgain')).toEqual('barAgain');\n      if (triggerTime == 0) {\n        // Create\n        expect(object.get('foo')).toEqual('bar');\n        // No objectId/createdAt/updatedAt\n        expect(object.id).toBeUndefined();\n        expect(object.createdAt).toBeUndefined();\n        expect(object.updatedAt).toBeUndefined();\n      } else if (triggerTime == 1) {\n        // Update\n        expect(object.get('foo')).toEqual('baz');\n        expect(object.id).not.toBeUndefined();\n        expect(object.createdAt).not.toBeUndefined();\n        expect(object.updatedAt).not.toBeUndefined();\n      } else {\n        throw new Error();\n      }\n      triggerTime++;\n    });\n    const obj = new Parse.Object('GameScore');\n    obj.set('foo', 'bar');\n    obj.set('fooAgain', 'barAgain');\n    obj.save().then(() => {\n      // We only update foo\n      obj.set('foo', 'baz');\n      return obj.save();\n    }).then(() => {\n      // Make sure the checking has been triggered\n      expect(triggerTime).toBe(2);\n      done();\n    }, error => {\n      fail(error);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"works when object is passed to success","suites":["miscellaneous"],"line":414,"updatePoint":{"line":414,"column":44,"index":13121},"code":"  it('works when object is passed to success', done => {\n    let triggerTime = 0;\n    // Register a mock beforeSave hook\n    Parse.Cloud.beforeSave('GameScore', req => {\n      const object = req.object;\n      object.set('foo', 'bar');\n      triggerTime++;\n      return object;\n    });\n    const obj = new Parse.Object('GameScore');\n    obj.set('foo', 'baz');\n    obj.save().then(() => {\n      expect(triggerTime).toBe(1);\n      expect(obj.get('foo')).toEqual('bar');\n      done();\n    }, error => {\n      fail(error);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"original object is set on update","suites":["miscellaneous"],"line":434,"updatePoint":{"line":434,"column":38,"index":13661},"code":"  it('original object is set on update', done => {\n    let triggerTime = 0;\n    // Register a mock beforeSave hook\n    Parse.Cloud.beforeSave('GameScore', req => {\n      const object = req.object;\n      expect(object instanceof Parse.Object).toBeTruthy();\n      expect(object.get('fooAgain')).toEqual('barAgain');\n      const originalObject = req.original;\n      if (triggerTime == 0) {\n        // No id/createdAt/updatedAt\n        expect(object.id).toBeUndefined();\n        expect(object.createdAt).toBeUndefined();\n        expect(object.updatedAt).toBeUndefined();\n        // Create\n        expect(object.get('foo')).toEqual('bar');\n        // Check the originalObject is undefined\n        expect(originalObject).toBeUndefined();\n      } else if (triggerTime == 1) {\n        // Update\n        expect(object.id).not.toBeUndefined();\n        expect(object.createdAt).not.toBeUndefined();\n        expect(object.updatedAt).not.toBeUndefined();\n        expect(object.get('foo')).toEqual('baz');\n        // Check the originalObject\n        expect(originalObject instanceof Parse.Object).toBeTruthy();\n        expect(originalObject.get('fooAgain')).toEqual('barAgain');\n        expect(originalObject.id).not.toBeUndefined();\n        expect(originalObject.createdAt).not.toBeUndefined();\n        expect(originalObject.updatedAt).not.toBeUndefined();\n        expect(originalObject.get('foo')).toEqual('bar');\n      } else {\n        throw new Error();\n      }\n      triggerTime++;\n    });\n    const obj = new Parse.Object('GameScore');\n    obj.set('foo', 'bar');\n    obj.set('fooAgain', 'barAgain');\n    obj.save().then(() => {\n      // We only update foo\n      obj.set('foo', 'baz');\n      return obj.save();\n    }).then(() => {\n      // Make sure the checking has been triggered\n      expect(triggerTime).toBe(2);\n      done();\n    }, error => {\n      fail(error);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"pointer mutation properly saves object","suites":["miscellaneous"],"line":485,"updatePoint":{"line":485,"column":44,"index":15554},"code":"  it('pointer mutation properly saves object', done => {\n    const className = 'GameScore';\n    Parse.Cloud.beforeSave(className, req => {\n      const object = req.object;\n      expect(object instanceof Parse.Object).toBeTruthy();\n      const child = object.get('child');\n      expect(child instanceof Parse.Object).toBeTruthy();\n      child.set('a', 'b');\n      return child.save();\n    });\n    const obj = new Parse.Object(className);\n    obj.set('foo', 'bar');\n    const child = new Parse.Object('Child');\n    child.save().then(() => {\n      obj.set('child', child);\n      return obj.save();\n    }).then(() => {\n      const query = new Parse.Query(className);\n      query.include('child');\n      return query.get(obj.id).then(objAgain => {\n        expect(objAgain.get('foo')).toEqual('bar');\n        const childAgain = objAgain.get('child');\n        expect(childAgain instanceof Parse.Object).toBeTruthy();\n        expect(childAgain.get('a')).toEqual('b');\n        return Promise.resolve();\n      });\n    }).then(() => {\n      done();\n    }, error => {\n      fail(error);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"pointer reassign is working properly (#1288)","suites":["miscellaneous"],"line":518,"updatePoint":{"line":518,"column":50,"index":16663},"code":"  it('pointer reassign is working properly (#1288)', done => {\n    Parse.Cloud.beforeSave('GameScore', req => {\n      const obj = req.object;\n      if (obj.get('point')) {\n        return;\n      }\n      const TestObject1 = Parse.Object.extend('TestObject1');\n      const newObj = new TestObject1({\n        key1: 1\n      });\n      return newObj.save().then(newObj => {\n        obj.set('point', newObj);\n      });\n    });\n    let pointId;\n    const obj = new Parse.Object('GameScore');\n    obj.set('foo', 'bar');\n    obj.save().then(() => {\n      expect(obj.get('point')).not.toBeUndefined();\n      pointId = obj.get('point').id;\n      expect(pointId).not.toBeUndefined();\n      obj.set('foo', 'baz');\n      return obj.save();\n    }).then(obj => {\n      expect(obj.get('point').id).toEqual(pointId);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"test afterSave get full object on create and update","suites":["miscellaneous"],"line":566,"updatePoint":{"line":566,"column":57,"index":18322},"code":"  it('test afterSave get full object on create and update', function (done) {\n    let triggerTime = 0;\n    // Register a mock beforeSave hook\n    Parse.Cloud.afterSave('GameScore', function (req) {\n      const object = req.object;\n      expect(object instanceof Parse.Object).toBeTruthy();\n      expect(object.id).not.toBeUndefined();\n      expect(object.createdAt).not.toBeUndefined();\n      expect(object.updatedAt).not.toBeUndefined();\n      expect(object.get('fooAgain')).toEqual('barAgain');\n      if (triggerTime == 0) {\n        // Create\n        expect(object.get('foo')).toEqual('bar');\n      } else if (triggerTime == 1) {\n        // Update\n        expect(object.get('foo')).toEqual('baz');\n      } else {\n        throw new Error();\n      }\n      triggerTime++;\n    });\n    const obj = new Parse.Object('GameScore');\n    obj.set('foo', 'bar');\n    obj.set('fooAgain', 'barAgain');\n    obj.save().then(function () {\n      // We only update foo\n      obj.set('foo', 'baz');\n      return obj.save();\n    }).then(function () {\n      // Make sure the checking has been triggered\n      expect(triggerTime).toBe(2);\n      done();\n    }, function (error) {\n      fail(error);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"test afterSave get original object on update","suites":["miscellaneous"],"line":603,"updatePoint":{"line":603,"column":50,"index":19520},"code":"  it('test afterSave get original object on update', function (done) {\n    let triggerTime = 0;\n    // Register a mock beforeSave hook\n\n    Parse.Cloud.afterSave('GameScore', function (req) {\n      const object = req.object;\n      expect(object instanceof Parse.Object).toBeTruthy();\n      expect(object.get('fooAgain')).toEqual('barAgain');\n      expect(object.id).not.toBeUndefined();\n      expect(object.createdAt).not.toBeUndefined();\n      expect(object.updatedAt).not.toBeUndefined();\n      const originalObject = req.original;\n      if (triggerTime == 0) {\n        // Create\n        expect(object.get('foo')).toEqual('bar');\n        // Check the originalObject is undefined\n        expect(originalObject).toBeUndefined();\n      } else if (triggerTime == 1) {\n        // Update\n        expect(object.get('foo')).toEqual('baz');\n        // Check the originalObject\n        expect(originalObject instanceof Parse.Object).toBeTruthy();\n        expect(originalObject.get('fooAgain')).toEqual('barAgain');\n        expect(originalObject.id).not.toBeUndefined();\n        expect(originalObject.createdAt).not.toBeUndefined();\n        expect(originalObject.updatedAt).not.toBeUndefined();\n        expect(originalObject.get('foo')).toEqual('bar');\n      } else {\n        throw new Error();\n      }\n      triggerTime++;\n    });\n    const obj = new Parse.Object('GameScore');\n    obj.set('foo', 'bar');\n    obj.set('fooAgain', 'barAgain');\n    obj.save().then(function () {\n      // We only update foo\n      obj.set('foo', 'baz');\n      return obj.save();\n    }).then(function () {\n      // Make sure the checking has been triggered\n      expect(triggerTime).toBe(2);\n      done();\n    }, function (error) {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"test afterSave get full original object even req auth can not query it","suites":["miscellaneous"],"line":651,"updatePoint":{"line":651,"column":76,"index":21296},"code":"  it('test afterSave get full original object even req auth can not query it', done => {\n    let triggerTime = 0;\n    // Register a mock beforeSave hook\n    Parse.Cloud.afterSave('GameScore', function (req) {\n      const object = req.object;\n      const originalObject = req.original;\n      if (triggerTime == 0) {\n        // Create\n      } else if (triggerTime == 1) {\n        // Update\n        expect(object.get('foo')).toEqual('baz');\n        // Make sure we get the full originalObject\n        expect(originalObject instanceof Parse.Object).toBeTruthy();\n        expect(originalObject.get('fooAgain')).toEqual('barAgain');\n        expect(originalObject.id).not.toBeUndefined();\n        expect(originalObject.createdAt).not.toBeUndefined();\n        expect(originalObject.updatedAt).not.toBeUndefined();\n        expect(originalObject.get('foo')).toEqual('bar');\n      } else {\n        throw new Error();\n      }\n      triggerTime++;\n    });\n    const obj = new Parse.Object('GameScore');\n    obj.set('foo', 'bar');\n    obj.set('fooAgain', 'barAgain');\n    const acl = new Parse.ACL();\n    // Make sure our update request can not query the object\n    acl.setPublicReadAccess(false);\n    acl.setPublicWriteAccess(true);\n    obj.setACL(acl);\n    obj.save().then(function () {\n      // We only update foo\n      obj.set('foo', 'baz');\n      return obj.save();\n    }).then(function () {\n      // Make sure the checking has been triggered\n      expect(triggerTime).toBe(2);\n      done();\n    }, function (error) {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"afterSave flattens custom operations","suites":["miscellaneous"],"line":695,"updatePoint":{"line":695,"column":42,"index":22819},"code":"  it('afterSave flattens custom operations', done => {\n    let triggerTime = 0;\n    // Register a mock beforeSave hook\n    Parse.Cloud.afterSave('GameScore', function (req) {\n      const object = req.object;\n      expect(object instanceof Parse.Object).toBeTruthy();\n      const originalObject = req.original;\n      if (triggerTime == 0) {\n        // Create\n        expect(object.get('yolo')).toEqual(1);\n      } else if (triggerTime == 1) {\n        // Update\n        expect(object.get('yolo')).toEqual(2);\n        // Check the originalObject\n        expect(originalObject.get('yolo')).toEqual(1);\n      } else {\n        throw new Error();\n      }\n      triggerTime++;\n    });\n    const obj = new Parse.Object('GameScore');\n    obj.increment('yolo', 1);\n    obj.save().then(() => {\n      obj.increment('yolo', 1);\n      return obj.save();\n    }).then(() => {\n      // Make sure the checking has been triggered\n      expect(triggerTime).toBe(2);\n      done();\n    }, error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave receives ACL","suites":["miscellaneous"],"line":729,"updatePoint":{"line":729,"column":29,"index":23831},"code":"  it('beforeSave receives ACL', done => {\n    let triggerTime = 0;\n    // Register a mock beforeSave hook\n    Parse.Cloud.beforeSave('GameScore', function (req) {\n      const object = req.object;\n      if (triggerTime == 0) {\n        const acl = object.getACL();\n        expect(acl.getPublicReadAccess()).toBeTruthy();\n        expect(acl.getPublicWriteAccess()).toBeTruthy();\n      } else if (triggerTime == 1) {\n        const acl = object.getACL();\n        expect(acl.getPublicReadAccess()).toBeFalsy();\n        expect(acl.getPublicWriteAccess()).toBeTruthy();\n      } else {\n        throw new Error();\n      }\n      triggerTime++;\n    });\n    const obj = new Parse.Object('GameScore');\n    const acl = new Parse.ACL();\n    acl.setPublicReadAccess(true);\n    acl.setPublicWriteAccess(true);\n    obj.setACL(acl);\n    obj.save().then(() => {\n      acl.setPublicReadAccess(false);\n      obj.setACL(acl);\n      return obj.save();\n    }).then(() => {\n      // Make sure the checking has been triggered\n      expect(triggerTime).toBe(2);\n      done();\n    }, error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"afterSave receives ACL","suites":["miscellaneous"],"line":765,"updatePoint":{"line":765,"column":28,"index":24943},"code":"  it('afterSave receives ACL', done => {\n    let triggerTime = 0;\n    // Register a mock beforeSave hook\n    Parse.Cloud.afterSave('GameScore', function (req) {\n      const object = req.object;\n      if (triggerTime == 0) {\n        const acl = object.getACL();\n        expect(acl.getPublicReadAccess()).toBeTruthy();\n        expect(acl.getPublicWriteAccess()).toBeTruthy();\n      } else if (triggerTime == 1) {\n        const acl = object.getACL();\n        expect(acl.getPublicReadAccess()).toBeFalsy();\n        expect(acl.getPublicWriteAccess()).toBeTruthy();\n      } else {\n        throw new Error();\n      }\n      triggerTime++;\n    });\n    const obj = new Parse.Object('GameScore');\n    const acl = new Parse.ACL();\n    acl.setPublicReadAccess(true);\n    acl.setPublicWriteAccess(true);\n    obj.setACL(acl);\n    obj.save().then(() => {\n      acl.setPublicReadAccess(false);\n      obj.setACL(acl);\n      return obj.save();\n    }).then(() => {\n      // Make sure the checking has been triggered\n      expect(triggerTime).toBe(2);\n      done();\n    }, error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"return the updated fields on PUT","suites":["miscellaneous"],"line":801,"updatePoint":{"line":801,"column":38,"index":26064},"code":"  it('return the updated fields on PUT', async () => {\n    const obj = new Parse.Object('GameScore');\n    const pointer = new Parse.Object('Child');\n    await pointer.save();\n    obj.set('point', new Parse.GeoPoint({\n      latitude: 37.4848,\n      longitude: -122.1483\n    }));\n    obj.set('array', ['obj1', 'obj2']);\n    obj.set('objects', {\n      a: 'b'\n    });\n    obj.set('string', 'abc');\n    obj.set('bool', true);\n    obj.set('number', 1);\n    obj.set('date', new Date());\n    obj.set('pointer', pointer);\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest',\n      'X-Parse-Installation-Id': 'yolo'\n    };\n    const saveResponse = await request({\n      method: 'POST',\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/GameScore',\n      body: JSON.stringify({\n        a: 'hello',\n        c: 1,\n        d: ['1'],\n        e: ['1'],\n        f: ['1', '2'],\n        ...obj.toJSON()\n      })\n    });\n    expect(Object.keys(saveResponse.data).sort()).toEqual(['createdAt', 'objectId']);\n    obj.id = saveResponse.data.objectId;\n    const response = await request({\n      method: 'PUT',\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/GameScore/' + obj.id,\n      body: JSON.stringify({\n        a: 'b',\n        c: {\n          __op: 'Increment',\n          amount: 2\n        },\n        d: {\n          __op: 'Add',\n          objects: ['2']\n        },\n        e: {\n          __op: 'AddUnique',\n          objects: ['1', '2']\n        },\n        f: {\n          __op: 'Remove',\n          objects: ['2']\n        },\n        selfThing: {\n          __type: 'Pointer',\n          className: 'GameScore',\n          objectId: obj.id\n        }\n      })\n    });\n    const body = response.data;\n    expect(Object.keys(body).sort()).toEqual(['c', 'd', 'e', 'f', 'updatedAt']);\n    expect(body.a).toBeUndefined();\n    expect(body.c).toEqual(3); // 2+1\n    expect(body.d.length).toBe(2);\n    expect(body.d.indexOf('1') > -1).toBe(true);\n    expect(body.d.indexOf('2') > -1).toBe(true);\n    expect(body.e.length).toBe(2);\n    expect(body.e.indexOf('1') > -1).toBe(true);\n    expect(body.e.indexOf('2') > -1).toBe(true);\n    expect(body.f.length).toBe(1);\n    expect(body.f.indexOf('1') > -1).toBe(true);\n    expect(body.selfThing).toBeUndefined();\n    expect(body.updatedAt).not.toBeUndefined();\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should response should not change with triggers","suites":["miscellaneous"],"line":883,"updatePoint":{"line":883,"column":53,"index":28483},"code":"  it('should response should not change with triggers', async () => {\n    const obj = new Parse.Object('GameScore');\n    const pointer = new Parse.Object('Child');\n    Parse.Cloud.beforeSave('GameScore', request => {\n      return request.object;\n    });\n    Parse.Cloud.afterSave('GameScore', request => {\n      return request.object;\n    });\n    await pointer.save();\n    obj.set('point', new Parse.GeoPoint({\n      latitude: 37.4848,\n      longitude: -122.1483\n    }));\n    obj.set('array', ['obj1', 'obj2']);\n    obj.set('objects', {\n      a: 'b'\n    });\n    obj.set('string', 'abc');\n    obj.set('bool', true);\n    obj.set('number', 1);\n    obj.set('date', new Date());\n    obj.set('pointer', pointer);\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest',\n      'X-Parse-Installation-Id': 'yolo'\n    };\n    const saveResponse = await request({\n      method: 'POST',\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/GameScore',\n      body: JSON.stringify({\n        a: 'hello',\n        c: 1,\n        d: ['1'],\n        e: ['1'],\n        f: ['1', '2'],\n        ...obj.toJSON()\n      })\n    });\n    expect(Object.keys(saveResponse.data).sort()).toEqual(['createdAt', 'objectId']);\n    obj.id = saveResponse.data.objectId;\n    const response = await request({\n      method: 'PUT',\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/GameScore/' + obj.id,\n      body: JSON.stringify({\n        a: 'b',\n        c: {\n          __op: 'Increment',\n          amount: 2\n        },\n        d: {\n          __op: 'Add',\n          objects: ['2']\n        },\n        e: {\n          __op: 'AddUnique',\n          objects: ['1', '2']\n        },\n        f: {\n          __op: 'Remove',\n          objects: ['2']\n        },\n        selfThing: {\n          __type: 'Pointer',\n          className: 'GameScore',\n          objectId: obj.id\n        }\n      })\n    });\n    const body = response.data;\n    expect(Object.keys(body).sort()).toEqual(['c', 'd', 'e', 'f', 'updatedAt']);\n    expect(body.a).toBeUndefined();\n    expect(body.c).toEqual(3); // 2+1\n    expect(body.d.length).toBe(2);\n    expect(body.d.indexOf('1') > -1).toBe(true);\n    expect(body.d.indexOf('2') > -1).toBe(true);\n    expect(body.e.length).toBe(2);\n    expect(body.e.indexOf('1') > -1).toBe(true);\n    expect(body.e.indexOf('2') > -1).toBe(true);\n    expect(body.f.length).toBe(1);\n    expect(body.f.indexOf('1') > -1).toBe(true);\n    expect(body.selfThing).toBeUndefined();\n    expect(body.updatedAt).not.toBeUndefined();\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"test cloud function error handling","suites":["miscellaneous"],"line":971,"updatePoint":{"line":971,"column":40,"index":31068},"code":"  it('test cloud function error handling', done => {\n    // Register a function which will fail\n    Parse.Cloud.define('willFail', () => {\n      throw new Error('noway');\n    });\n    Parse.Cloud.run('willFail').then(() => {\n      fail('Should not have succeeded.');\n      done();\n    }, e => {\n      expect(e.code).toEqual(Parse.Error.SCRIPT_FAILED);\n      expect(e.message).toEqual('noway');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"test cloud function error handling with custom error code","suites":["miscellaneous"],"line":985,"updatePoint":{"line":985,"column":63,"index":31512},"code":"  it('test cloud function error handling with custom error code', done => {\n    // Register a function which will fail\n    Parse.Cloud.define('willFail', () => {\n      throw new Parse.Error(999, 'noway');\n    });\n    Parse.Cloud.run('willFail').then(() => {\n      fail('Should not have succeeded.');\n      done();\n    }, e => {\n      expect(e.code).toEqual(999);\n      expect(e.message).toEqual('noway');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"test cloud function error handling with standard error code","suites":["miscellaneous"],"line":999,"updatePoint":{"line":999,"column":65,"index":31947},"code":"  it('test cloud function error handling with standard error code', done => {\n    // Register a function which will fail\n    Parse.Cloud.define('willFail', () => {\n      throw new Error('noway');\n    });\n    Parse.Cloud.run('willFail').then(() => {\n      fail('Should not have succeeded.');\n      done();\n    }, e => {\n      expect(e.code).toEqual(Parse.Error.SCRIPT_FAILED);\n      expect(e.message).toEqual('noway');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeSave/afterSave get installationId","suites":["miscellaneous"],"line":1013,"updatePoint":{"line":1013,"column":50,"index":32378},"code":"  it('test beforeSave/afterSave get installationId', function (done) {\n    let triggerTime = 0;\n    Parse.Cloud.beforeSave('GameScore', function (req) {\n      triggerTime++;\n      expect(triggerTime).toEqual(1);\n      expect(req.installationId).toEqual('yolo');\n    });\n    Parse.Cloud.afterSave('GameScore', function (req) {\n      triggerTime++;\n      expect(triggerTime).toEqual(2);\n      expect(req.installationId).toEqual('yolo');\n    });\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest',\n      'X-Parse-Installation-Id': 'yolo'\n    };\n    request({\n      method: 'POST',\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/GameScore',\n      body: JSON.stringify({\n        a: 'b'\n      })\n    }).then(() => {\n      expect(triggerTime).toEqual(2);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeDelete/afterDelete get installationId","suites":["miscellaneous"],"line":1043,"updatePoint":{"line":1043,"column":54,"index":33269},"code":"  it('test beforeDelete/afterDelete get installationId', function (done) {\n    let triggerTime = 0;\n    Parse.Cloud.beforeDelete('GameScore', function (req) {\n      triggerTime++;\n      expect(triggerTime).toEqual(1);\n      expect(req.installationId).toEqual('yolo');\n    });\n    Parse.Cloud.afterDelete('GameScore', function (req) {\n      triggerTime++;\n      expect(triggerTime).toEqual(2);\n      expect(req.installationId).toEqual('yolo');\n    });\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest',\n      'X-Parse-Installation-Id': 'yolo'\n    };\n    request({\n      method: 'POST',\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/GameScore',\n      body: JSON.stringify({\n        a: 'b'\n      })\n    }).then(response => {\n      request({\n        method: 'DELETE',\n        headers: headers,\n        url: 'http://localhost:8378/1/classes/GameScore/' + response.data.objectId\n      }).then(() => {\n        expect(triggerTime).toEqual(2);\n        done();\n      });\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"test beforeDelete with locked down ACL","suites":["miscellaneous"],"line":1079,"updatePoint":{"line":1079,"column":44,"index":34347},"code":"  it('test beforeDelete with locked down ACL', async () => {\n    let called = false;\n    Parse.Cloud.beforeDelete('GameScore', () => {\n      called = true;\n    });\n    const object = new Parse.Object('GameScore');\n    object.setACL(new Parse.ACL());\n    await object.save();\n    const objects = await new Parse.Query('GameScore').find();\n    expect(objects.length).toBe(0);\n    try {\n      await object.destroy();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    expect(called).toBe(false);\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"test cloud function query parameters","suites":["miscellaneous"],"line":1096,"updatePoint":{"line":1096,"column":42,"index":34878},"code":"  it('test cloud function query parameters', done => {\n    Parse.Cloud.define('echoParams', req => {\n      return req.params;\n    });\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-Javascript-Key': 'test'\n    };\n    request({\n      method: 'POST',\n      headers: headers,\n      url: 'http://localhost:8378/1/functions/echoParams',\n      //?option=1&other=2\n      qs: {\n        option: 1,\n        other: 2\n      },\n      body: '{\"foo\":\"bar\", \"other\": 1}'\n    }).then(response => {\n      const res = response.data.result;\n      expect(res.option).toEqual('1');\n      // Make sure query string params override body params\n      expect(res.other).toEqual('2');\n      expect(res.foo).toEqual('bar');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"can handle null params in cloud functions (regression test for #1742)","suites":["miscellaneous"],"line":1124,"updatePoint":{"line":1124,"column":75,"index":35706},"code":"  it('can handle null params in cloud functions (regression test for #1742)', done => {\n    Parse.Cloud.define('func', request => {\n      expect(request.params.nullParam).toEqual(null);\n      return 'yay';\n    });\n    Parse.Cloud.run('func', {\n      nullParam: null\n    }).then(() => {\n      done();\n    }, () => {\n      fail('cloud code call failed');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"can handle date params in cloud functions (#2214)","suites":["miscellaneous"],"line":1138,"updatePoint":{"line":1138,"column":55,"index":36067},"code":"  it('can handle date params in cloud functions (#2214)', done => {\n    const date = new Date();\n    Parse.Cloud.define('dateFunc', request => {\n      expect(request.params.date.__type).toEqual('Date');\n      expect(request.params.date.iso).toEqual(date.toISOString());\n      return 'yay';\n    });\n    Parse.Cloud.run('dateFunc', {\n      date: date\n    }).then(() => {\n      done();\n    }, () => {\n      fail('cloud code call failed');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"fails on invalid client key","suites":["miscellaneous"],"line":1154,"updatePoint":{"line":1154,"column":33,"index":36509},"code":"  it('fails on invalid client key', done => {\n    const headers = {\n      'Content-Type': 'application/octet-stream',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-Client-Key': 'notclient'\n    };\n    request({\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/TestObject'\n    }).then(fail, response => {\n      const b = response.data;\n      expect(b.error).toEqual('unauthorized');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"fails on invalid windows key","suites":["miscellaneous"],"line":1169,"updatePoint":{"line":1169,"column":34,"index":36947},"code":"  it('fails on invalid windows key', done => {\n    const headers = {\n      'Content-Type': 'application/octet-stream',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-Windows-Key': 'notwindows'\n    };\n    request({\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/TestObject'\n    }).then(fail, response => {\n      const b = response.data;\n      expect(b.error).toEqual('unauthorized');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"fails on invalid javascript key","suites":["miscellaneous"],"line":1184,"updatePoint":{"line":1184,"column":37,"index":37390},"code":"  it('fails on invalid javascript key', done => {\n    const headers = {\n      'Content-Type': 'application/octet-stream',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-Javascript-Key': 'notjavascript'\n    };\n    request({\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/TestObject'\n    }).then(fail, response => {\n      const b = response.data;\n      expect(b.error).toEqual('unauthorized');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"fails on invalid rest api key","suites":["miscellaneous"],"line":1199,"updatePoint":{"line":1199,"column":35,"index":37837},"code":"  it('fails on invalid rest api key', done => {\n    const headers = {\n      'Content-Type': 'application/octet-stream',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'notrest'\n    };\n    request({\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/TestObject'\n    }).then(fail, response => {\n      const b = response.data;\n      expect(b.error).toEqual('unauthorized');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"fails on invalid function","suites":["miscellaneous"],"line":1214,"updatePoint":{"line":1214,"column":31,"index":38272},"code":"  it('fails on invalid function', done => {\n    Parse.Cloud.run('somethingThatDoesDefinitelyNotExist').then(() => {\n      fail('This should have never suceeded');\n      done();\n    }, e => {\n      expect(e.code).toEqual(Parse.Error.SCRIPT_FAILED);\n      expect(e.message).toEqual('Invalid function: \"somethingThatDoesDefinitelyNotExist\"');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"dedupes an installation properly and returns updatedAt","suites":["miscellaneous"],"line":1224,"updatePoint":{"line":1224,"column":60,"index":38669},"code":"  it('dedupes an installation properly and returns updatedAt', done => {\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest'\n    };\n    const data = {\n      installationId: 'lkjsahdfkjhsdfkjhsdfkjhsdf',\n      deviceType: 'embedded'\n    };\n    const requestOptions = {\n      headers: headers,\n      method: 'POST',\n      url: 'http://localhost:8378/1/installations',\n      body: JSON.stringify(data)\n    };\n    request(requestOptions).then(response => {\n      const b = response.data;\n      expect(typeof b.objectId).toEqual('string');\n      request(requestOptions).then(response => {\n        const b = response.data;\n        expect(typeof b.updatedAt).toEqual('string');\n        done();\n      });\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"android login providing empty authData block works","suites":["miscellaneous"],"line":1250,"updatePoint":{"line":1250,"column":56,"index":39465},"code":"  it('android login providing empty authData block works', done => {\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest'\n    };\n    const data = {\n      username: 'pulse1989',\n      password: 'password1234',\n      authData: {}\n    };\n    const requestOptions = {\n      method: 'POST',\n      headers: headers,\n      url: 'http://localhost:8378/1/users',\n      body: JSON.stringify(data)\n    };\n    request(requestOptions).then(() => {\n      requestOptions.url = 'http://localhost:8378/1/login';\n      request(requestOptions).then(response => {\n        const b = response.data;\n        expect(typeof b['sessionToken']).toEqual('string');\n        done();\n      });\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"gets relation fields","suites":["miscellaneous"],"line":1276,"updatePoint":{"line":1276,"column":26,"index":40200},"code":"  it('gets relation fields', done => {\n    const object = new Parse.Object('AnObject');\n    const relatedObject = new Parse.Object('RelatedObject');\n    Parse.Object.saveAll([object, relatedObject]).then(() => {\n      object.relation('related').add(relatedObject);\n      return object.save();\n    }).then(() => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const requestOptions = {\n        headers: headers,\n        url: 'http://localhost:8378/1/classes/AnObject',\n        json: true\n      };\n      request(requestOptions).then(res => {\n        const body = res.data;\n        expect(body.results.length).toBe(1);\n        const result = body.results[0];\n        expect(result.related).toEqual({\n          __type: 'Relation',\n          className: 'RelatedObject'\n        });\n        done();\n      });\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"properly returns incremented values (#1554)","suites":["miscellaneous"],"line":1308,"updatePoint":{"line":1308,"column":49,"index":41210},"code":"  it('properly returns incremented values (#1554)', done => {\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest'\n    };\n    const requestOptions = {\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/AnObject',\n      json: true\n    };\n    const object = new Parse.Object('AnObject');\n    function runIncrement(amount) {\n      const options = Object.assign({}, requestOptions, {\n        body: {\n          key: {\n            __op: 'Increment',\n            amount: amount\n          }\n        },\n        url: 'http://localhost:8378/1/classes/AnObject/' + object.id,\n        method: 'PUT'\n      });\n      return request(options).then(res => res.data);\n    }\n    object.save().then(() => {\n      return runIncrement(1);\n    }).then(res => {\n      expect(res.key).toBe(1);\n      return runIncrement(-1);\n    }).then(res => {\n      expect(res.key).toBe(0);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"ignores _RevocableSession \"header\" send by JS SDK","suites":["miscellaneous"],"line":1343,"updatePoint":{"line":1343,"column":55,"index":42200},"code":"  it('ignores _RevocableSession \"header\" send by JS SDK', done => {\n    const object = new Parse.Object('AnObject');\n    object.set('a', 'b');\n    object.save().then(() => {\n      request({\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        url: 'http://localhost:8378/1/classes/AnObject',\n        body: {\n          _method: 'GET',\n          _ApplicationId: 'test',\n          _JavaScriptKey: 'test',\n          _ClientVersion: 'js1.8.3',\n          _InstallationId: 'iid',\n          _RevocableSession: '1'\n        }\n      }).then(res => {\n        const body = res.data;\n        expect(body.error).toBeUndefined();\n        expect(body.results).not.toBeUndefined();\n        expect(body.results.length).toBe(1);\n        const result = body.results[0];\n        expect(result.a).toBe('b');\n        done();\n      });\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"doesnt convert interior keys of objects that use special names","suites":["miscellaneous"],"line":1372,"updatePoint":{"line":1372,"column":68,"index":43092},"code":"  it('doesnt convert interior keys of objects that use special names', done => {\n    const obj = new Parse.Object('Obj');\n    obj.set('val', {\n      createdAt: 'a',\n      updatedAt: 1\n    });\n    obj.save().then(obj => new Parse.Query('Obj').get(obj.id)).then(obj => {\n      expect(obj.get('val').createdAt).toEqual('a');\n      expect(obj.get('val').updatedAt).toEqual(1);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"bans interior keys containing . or $","suites":["miscellaneous"],"line":1384,"updatePoint":{"line":1384,"column":42,"index":43467},"code":"  it('bans interior keys containing . or $', done => {\n    new Parse.Object('Obj').save({\n      innerObj: {\n        'key with a $': 'fails'\n      }\n    }).then(() => {\n      fail('should not succeed');\n    }, error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_NESTED_KEY);\n      return new Parse.Object('Obj').save({\n        innerObj: {\n          'key with a .': 'fails'\n        }\n      });\n    }).then(() => {\n      fail('should not succeed');\n    }, error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_NESTED_KEY);\n      return new Parse.Object('Obj').save({\n        innerObj: {\n          innerInnerObj: {\n            'key with $': 'fails'\n          }\n        }\n      });\n    }).then(() => {\n      fail('should not succeed');\n    }, error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_NESTED_KEY);\n      return new Parse.Object('Obj').save({\n        innerObj: {\n          innerInnerObj: {\n            'key with .': 'fails'\n          }\n        }\n      });\n    }).then(() => {\n      fail('should not succeed');\n      done();\n    }, error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_NESTED_KEY);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"does not change inner object keys named _auth_data_something","suites":["miscellaneous"],"line":1428,"updatePoint":{"line":1428,"column":66,"index":44665},"code":"  it('does not change inner object keys named _auth_data_something', done => {\n    new Parse.Object('O').save({\n      innerObj: {\n        _auth_data_facebook: 7\n      }\n    }).then(object => new Parse.Query('O').get(object.id)).then(object => {\n      expect(object.get('innerObj')).toEqual({\n        _auth_data_facebook: 7\n      });\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"does not change inner object key names _p_somethign","suites":["miscellaneous"],"line":1440,"updatePoint":{"line":1440,"column":57,"index":45017},"code":"  it('does not change inner object key names _p_somethign', done => {\n    new Parse.Object('O').save({\n      innerObj: {\n        _p_data: 7\n      }\n    }).then(object => new Parse.Query('O').get(object.id)).then(object => {\n      expect(object.get('innerObj')).toEqual({\n        _p_data: 7\n      });\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"does not change inner object key names _rperm, _wperm","suites":["miscellaneous"],"line":1452,"updatePoint":{"line":1452,"column":59,"index":45347},"code":"  it('does not change inner object key names _rperm, _wperm', done => {\n    new Parse.Object('O').save({\n      innerObj: {\n        _rperm: 7,\n        _wperm: 8\n      }\n    }).then(object => new Parse.Query('O').get(object.id)).then(object => {\n      expect(object.get('innerObj')).toEqual({\n        _rperm: 7,\n        _wperm: 8\n      });\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"does not change inner objects if the key has the same name as a geopoint field on the class, and the value is an array of length 2, or if the key has the same name as a file field on the class, and the value is a string","suites":["miscellaneous"],"line":1466,"updatePoint":{"line":1466,"column":225,"index":45879},"code":"  it('does not change inner objects if the key has the same name as a geopoint field on the class, and the value is an array of length 2, or if the key has the same name as a file field on the class, and the value is a string', done => {\n    const file = new Parse.File('myfile.txt', {\n      base64: 'eAo='\n    });\n    file.save().then(f => {\n      const obj = new Parse.Object('O');\n      obj.set('fileField', f);\n      obj.set('geoField', new Parse.GeoPoint(0, 0));\n      obj.set('innerObj', {\n        fileField: 'data',\n        geoField: [1, 2]\n      });\n      return obj.save();\n    }).then(object => object.fetch()).then(object => {\n      expect(object.get('innerObj')).toEqual({\n        fileField: 'data',\n        geoField: [1, 2]\n      });\n      done();\n    }).catch(e => {\n      jfail(e);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"purge all objects in class","suites":["miscellaneous"],"line":1490,"updatePoint":{"line":1490,"column":32,"index":46511},"code":"  it('purge all objects in class', done => {\n    const object = new Parse.Object('TestObject');\n    object.set('foo', 'bar');\n    const object2 = new Parse.Object('TestObject');\n    object2.set('alice', 'wonderland');\n    Parse.Object.saveAll([object, object2]).then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.count();\n    }).then(count => {\n      expect(count).toBe(2);\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Master-Key': 'test'\n      };\n      request({\n        method: 'DELETE',\n        headers: headers,\n        url: 'http://localhost:8378/1/purge/TestObject'\n      }).then(() => {\n        const query = new Parse.Query(TestObject);\n        return query.count().then(count => {\n          expect(count).toBe(0);\n          done();\n        });\n      });\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"fail on purge all objects in class without master key","suites":["miscellaneous"],"line":1518,"updatePoint":{"line":1518,"column":59,"index":47427},"code":"  it('fail on purge all objects in class without master key', done => {\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest'\n    };\n    request({\n      method: 'DELETE',\n      headers: headers,\n      url: 'http://localhost:8378/1/purge/TestObject'\n    }).then(() => {\n      fail('Should not succeed');\n    }).catch(response => {\n      expect(response.data.error).toEqual('unauthorized: master key is required');\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"purge all objects in _Role also purge cache","suites":["miscellaneous"],"line":1535,"updatePoint":{"line":1535,"column":49,"index":47945},"code":"  it('purge all objects in _Role also purge cache', done => {\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-Master-Key': 'test'\n    };\n    let user, object;\n    createTestUser().then(x => {\n      user = x;\n      const acl = new Parse.ACL();\n      acl.setPublicReadAccess(true);\n      acl.setPublicWriteAccess(false);\n      const role = new Parse.Object('_Role');\n      role.set('name', 'TestRole');\n      role.setACL(acl);\n      const users = role.relation('users');\n      users.add(user);\n      return role.save({}, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      const query = new Parse.Query('_Role');\n      return query.find({\n        useMasterKey: true\n      });\n    }).then(x => {\n      expect(x.length).toEqual(1);\n      const relation = x[0].relation('users').query();\n      return relation.first({\n        useMasterKey: true\n      });\n    }).then(x => {\n      expect(x.id).toEqual(user.id);\n      object = new Parse.Object('TestObject');\n      const acl = new Parse.ACL();\n      acl.setPublicReadAccess(false);\n      acl.setPublicWriteAccess(false);\n      acl.setRoleReadAccess('TestRole', true);\n      acl.setRoleWriteAccess('TestRole', true);\n      object.setACL(acl);\n      return object.save();\n    }).then(() => {\n      const query = new Parse.Query('TestObject');\n      return query.find({\n        sessionToken: user.getSessionToken()\n      });\n    }).then(x => {\n      expect(x.length).toEqual(1);\n      return request({\n        method: 'DELETE',\n        headers: headers,\n        url: 'http://localhost:8378/1/purge/_Role',\n        json: true\n      });\n    }).then(() => {\n      const query = new Parse.Query('TestObject');\n      return query.get(object.id, {\n        sessionToken: user.getSessionToken()\n      });\n    }).then(() => {\n      fail('Should not succeed');\n    }, e => {\n      expect(e.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"purge empty class","suites":["miscellaneous"],"line":1601,"updatePoint":{"line":1601,"column":23,"index":49897},"code":"  it('purge empty class', done => {\n    const testSchema = new Parse.Schema('UnknownClass');\n    testSchema.purge().then(done).catch(done.fail);\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should not update schema beforeSave #2672","suites":["miscellaneous"],"line":1605,"updatePoint":{"line":1605,"column":47,"index":50072},"code":"  it('should not update schema beforeSave #2672', done => {\n    Parse.Cloud.beforeSave('MyObject', request => {\n      if (request.object.get('secret')) {\n        throw 'cannot set secret here';\n      }\n    });\n    const object = new Parse.Object('MyObject');\n    object.set('key', 'value');\n    object.save().then(() => {\n      return object.save({\n        secret: 'should not update schema'\n      });\n    }).then(() => {\n      fail();\n      done();\n    }, () => {\n      return request({\n        method: 'GET',\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Master-Key': 'test'\n        },\n        url: 'http://localhost:8378/1/schemas/MyObject',\n        json: true\n      });\n    }).then(res => {\n      const fields = res.data.fields;\n      expect(fields.secret).toBeUndefined();\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should have _acl when locking down (regression for #2465)","suites":["miscellaneous"],"line":1641,"updatePoint":{"line":1641,"column":63,"index":51031},"code":"  it('should have _acl when locking down (regression for #2465)', done => {\n    const headers = {\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest',\n      'Content-Type': 'application/json'\n    };\n    request({\n      method: 'POST',\n      headers: headers,\n      url: 'http://localhost:8378/1/classes/Report',\n      body: {\n        ACL: {},\n        name: 'My Report'\n      },\n      json: true\n    }).then(() => {\n      const config = Config.get('test');\n      const adapter = config.database.adapter;\n      return adapter._adaptiveCollection('Report').then(collection => collection.find({}));\n    }).then(results => {\n      expect(results.length).toBe(1);\n      const result = results[0];\n      expect(result.name).toEqual('My Report');\n      expect(result._wperm).toEqual([]);\n      expect(result._rperm).toEqual([]);\n      expect(result._acl).toEqual({});\n      done();\n    }).catch(err => {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"ParseAPI.spec.js","skipped":false,"dir":"spec"},{"name":"can initialize","suites":["ParseCloudCodePublisher"],"line":19,"updatePoint":{"line":19,"column":20,"index":746},"code":"  it('can initialize', function () {\n    const config = {};\n    new ParseCloudCodePublisher(config);\n    const ParsePubSub = require('../lib/LiveQuery/ParsePubSub').ParsePubSub;\n    expect(ParsePubSub.createPublisher).toHaveBeenCalledWith(config);\n  });","file":"ParseCloudCodePublisher.spec.js","skipped":false,"dir":"spec"},{"name":"can handle cloud code afterSave request","suites":["ParseCloudCodePublisher"],"line":25,"updatePoint":{"line":25,"column":45,"index":1025},"code":"  it('can handle cloud code afterSave request', function () {\n    const publisher = new ParseCloudCodePublisher({});\n    publisher._onCloudCodeMessage = jasmine.createSpy('onCloudCodeMessage');\n    const request = {};\n    publisher.onCloudCodeAfterSave(request);\n    expect(publisher._onCloudCodeMessage).toHaveBeenCalledWith(Parse.applicationId + 'afterSave', request);\n  });","file":"ParseCloudCodePublisher.spec.js","skipped":false,"dir":"spec"},{"name":"can handle cloud code afterDelete request","suites":["ParseCloudCodePublisher"],"line":32,"updatePoint":{"line":32,"column":47,"index":1404},"code":"  it('can handle cloud code afterDelete request', function () {\n    const publisher = new ParseCloudCodePublisher({});\n    publisher._onCloudCodeMessage = jasmine.createSpy('onCloudCodeMessage');\n    const request = {};\n    publisher.onCloudCodeAfterDelete(request);\n    expect(publisher._onCloudCodeMessage).toHaveBeenCalledWith(Parse.applicationId + 'afterDelete', request);\n  });","file":"ParseCloudCodePublisher.spec.js","skipped":false,"dir":"spec"},{"name":"can handle cloud code request","suites":["ParseCloudCodePublisher"],"line":39,"updatePoint":{"line":39,"column":35,"index":1775},"code":"  it('can handle cloud code request', function () {\n    const publisher = new ParseCloudCodePublisher({});\n    const currentParseObject = new Parse.Object('Test');\n    currentParseObject.set('key', 'value');\n    const originalParseObject = new Parse.Object('Test');\n    originalParseObject.set('key', 'originalValue');\n    const request = {\n      object: currentParseObject,\n      original: originalParseObject\n    };\n    publisher._onCloudCodeMessage('afterSave', request);\n    const args = publisher.parsePublisher.publish.calls.mostRecent().args;\n    expect(args[0]).toBe('afterSave');\n    const message = JSON.parse(args[1]);\n    expect(message.currentParseObject).toEqual(request.object._toFullJSON());\n    expect(message.originalParseObject).toEqual(request.original._toFullJSON());\n  });","file":"ParseCloudCodePublisher.spec.js","skipped":false,"dir":"spec"},{"name":"works with Content-Type","suites":["Parse.File testing","creating files"],"line":17,"updatePoint":{"line":17,"column":31,"index":436},"code":"    it('works with Content-Type', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle'\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.txt$/);\n        request({\n          url: b.url\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"works with _ContentType","suites":["Parse.File testing","creating files"],"line":41,"updatePoint":{"line":41,"column":31,"index":1194},"code":"    it('works with _ContentType', done => {\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/files/file',\n        body: JSON.stringify({\n          _ApplicationId: 'test',\n          _JavaScriptKey: 'test',\n          _ContentType: 'text/html',\n          base64: 'PGh0bWw+PC9odG1sPgo='\n        })\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.html/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.html$/);\n        request({\n          url: b.url\n        }).then(response => {\n          const body = response.text;\n          try {\n            expect(response.headers['content-type']).toMatch('^text/html');\n            expect(body).toEqual('<html></html>\\n');\n          } catch (e) {\n            jfail(e);\n          }\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"works without Content-Type","suites":["Parse.File testing","creating files"],"line":69,"updatePoint":{"line":69,"column":34,"index":2074},"code":"    it('works without Content-Type', done => {\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle'\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.txt$/);\n        request({\n          url: b.url\n        }).then(response => {\n          expect(response.text).toEqual('argle bargle');\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports REST end-to-end file create, read, delete, read","suites":["Parse.File testing","creating files"],"line":91,"updatePoint":{"line":91,"column":64,"index":2784},"code":"    it('supports REST end-to-end file create, read, delete, read', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/testfile.txt',\n        body: 'check one two'\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_testfile.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*testfile.txt$/);\n        request({\n          url: b.url\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('check one two');\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n              'X-Parse-Master-Key': 'test'\n            },\n            url: 'http://localhost:8378/1/files/' + b.name\n          }).then(response => {\n            expect(response.status).toEqual(200);\n            request({\n              headers: {\n                'X-Parse-Application-Id': 'test',\n                'X-Parse-REST-API-Key': 'rest'\n              },\n              url: b.url\n            }).then(fail, response => {\n              expect(response.status).toEqual(404);\n              done();\n            });\n          });\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"blocks file deletions with missing or incorrect master-key header","suites":["Parse.File testing","creating files"],"line":135,"updatePoint":{"line":135,"column":73,"index":4262},"code":"    it('blocks file deletions with missing or incorrect master-key header', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/thefile.jpg',\n        body: 'the file body'\n      }).then(response => {\n        const b = response.data;\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*thefile.jpg$/);\n        // missing X-Parse-Master-Key header\n        request({\n          method: 'DELETE',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest'\n          },\n          url: 'http://localhost:8378/1/files/' + b.name\n        }).then(fail, response => {\n          const del_b = response.data;\n          expect(response.status).toEqual(403);\n          expect(del_b.error).toMatch(/unauthorized/);\n          // incorrect X-Parse-Master-Key header\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n              'X-Parse-Master-Key': 'tryagain'\n            },\n            url: 'http://localhost:8378/1/files/' + b.name\n          }).then(fail, response => {\n            const del_b2 = response.data;\n            expect(response.status).toEqual(403);\n            expect(del_b2.error).toMatch(/unauthorized/);\n            done();\n          });\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"handles other filetypes","suites":["Parse.File testing","creating files"],"line":179,"updatePoint":{"line":179,"column":31,"index":5802},"code":"    it('handles other filetypes', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.jpg',\n        body: 'argle bargle'\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.jpg$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/.*file.jpg$/);\n        request({\n          url: b.url\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"save file","suites":["Parse.File testing","creating files"],"line":203,"updatePoint":{"line":203,"column":17,"index":6526},"code":"    it('save file', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"saves the file with tags","suites":["Parse.File testing","creating files"],"line":212,"updatePoint":{"line":212,"column":32,"index":6834},"code":"    it('saves the file with tags', async () => {\n      spyOn(FilesController.prototype, 'createFile').and.callThrough();\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      const tags = {\n        hello: 'world'\n      };\n      file.setTags(tags);\n      expect(file.url()).toBeUndefined();\n      const result = await file.save();\n      expect(file.name()).toBeDefined();\n      expect(file.url()).toBeDefined();\n      expect(result.tags()).toEqual(tags);\n      expect(FilesController.prototype.createFile.calls.argsFor(0)[4]).toEqual({\n        tags: tags,\n        metadata: {}\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"does not pass empty file tags while saving","suites":["Parse.File testing","creating files"],"line":229,"updatePoint":{"line":229,"column":50,"index":7466},"code":"    it('does not pass empty file tags while saving', async () => {\n      spyOn(FilesController.prototype, 'createFile').and.callThrough();\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      expect(file.url()).toBeUndefined();\n      expect(file.name()).toBeDefined();\n      await file.save();\n      expect(file.url()).toBeDefined();\n      expect(FilesController.prototype.createFile.calls.argsFor(0)[4]).toEqual({\n        metadata: {}\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"save file in object","suites":["Parse.File testing","creating files"],"line":240,"updatePoint":{"line":240,"column":27,"index":7918},"code":"    it('save file in object', async done => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      const object = new Parse.Object('TestObject');\n      await object.save({\n        file: file\n      });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      ok(objectAgain.get('file') instanceof Parse.File);\n      done();\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"save file in object with escaped characters in filename","suites":["Parse.File testing","creating files"],"line":256,"updatePoint":{"line":256,"column":63,"index":8516},"code":"    it('save file in object with escaped characters in filename', async () => {\n      const file = new Parse.File('hello . txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello . txt');\n      const object = new Parse.Object('TestObject');\n      await object.save({\n        file\n      });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      ok(objectAgain.get('file') instanceof Parse.File);\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"autosave file in object","suites":["Parse.File testing","creating files"],"line":271,"updatePoint":{"line":271,"column":31,"index":9064},"code":"    it('autosave file in object', async done => {\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const object = new Parse.Object('TestObject');\n      await object.save({\n        file\n      });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      file = objectAgain.get('file');\n      ok(file instanceof Parse.File);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      done();\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"autosave file in object in object","suites":["Parse.File testing","creating files"],"line":286,"updatePoint":{"line":286,"column":41,"index":9578},"code":"    it('autosave file in object in object', async done => {\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const child = new Parse.Object('Child');\n      child.set('file', file);\n      const parent = new Parse.Object('Parent');\n      parent.set('child', child);\n      await parent.save();\n      const query = new Parse.Query('Parent');\n      query.include('child');\n      const parentAgain = await query.get(parent.id);\n      const childAgain = parentAgain.get('child');\n      file = childAgain.get('file');\n      ok(file instanceof Parse.File);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      done();\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"saving an already saved file","suites":["Parse.File testing","creating files"],"line":305,"updatePoint":{"line":305,"column":36,"index":10276},"code":"    it('saving an already saved file', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      const previousName = file.name();\n      await file.save();\n      equal(file.name(), previousName);\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"two saves at the same time","suites":["Parse.File testing","creating files"],"line":317,"updatePoint":{"line":317,"column":34,"index":10691},"code":"    it('two saves at the same time', done => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      let firstName;\n      let secondName;\n      const firstSave = file.save().then(function () {\n        firstName = file.name();\n      });\n      const secondSave = file.save().then(function () {\n        secondName = file.name();\n      });\n      Promise.all([firstSave, secondSave]).then(function () {\n        equal(firstName, secondName);\n        done();\n      }, function (error) {\n        ok(false, error);\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"file toJSON testing","suites":["Parse.File testing","creating files"],"line":335,"updatePoint":{"line":335,"column":27,"index":11244},"code":"    it('file toJSON testing', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const object = new Parse.Object('TestObject');\n      await object.save({\n        file: file\n      });\n      ok(object.toJSON().file.url);\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"content-type used with no extension","suites":["Parse.File testing","creating files"],"line":344,"updatePoint":{"line":344,"column":43,"index":11547},"code":"    it('content-type used with no extension', done => {\n      const headers = {\n        'Content-Type': 'text/html',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file',\n        body: 'fee fi fo'\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/\\.html$/);\n        request({\n          url: b.url\n        }).then(response => {\n          expect(response.headers['content-type']).toMatch(/^text\\/html/);\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"filename is url encoded","suites":["Parse.File testing","creating files"],"line":366,"updatePoint":{"line":366,"column":31,"index":12181},"code":"    it('filename is url encoded', done => {\n      const headers = {\n        'Content-Type': 'text/html',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/hello world.txt',\n        body: 'oh emm gee'\n      }).then(response => {\n        const b = response.data;\n        expect(b.url).toMatch(/hello%20world/);\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports array of files","suites":["Parse.File testing","creating files"],"line":383,"updatePoint":{"line":383,"column":31,"index":12674},"code":"    it('supports array of files', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://meep.meep',\n        name: 'meep'\n      };\n      const files = [file, file];\n      const obj = new Parse.Object('FilesArrayTest');\n      obj.set('files', files);\n      obj.save().then(() => {\n        const query = new Parse.Query('FilesArrayTest');\n        return query.first();\n      }).then(result => {\n        const filesAgain = result.get('files');\n        expect(filesAgain.length).toEqual(2);\n        expect(filesAgain[0].name()).toEqual('meep');\n        expect(filesAgain[0].url()).toEqual('http://meep.meep');\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"validates filename characters","suites":["Parse.File testing","creating files"],"line":403,"updatePoint":{"line":403,"column":37,"index":13341},"code":"    it('validates filename characters', done => {\n      const headers = {\n        'Content-Type': 'text/plain',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/di$avowed.txt',\n        body: 'will fail'\n      }).then(fail, response => {\n        const b = response.data;\n        expect(b.code).toEqual(122);\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"validates filename length","suites":["Parse.File testing","creating files"],"line":420,"updatePoint":{"line":420,"column":33,"index":13829},"code":"    it('validates filename length', done => {\n      const headers = {\n        'Content-Type': 'text/plain',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const fileName = 'Onceuponamidnightdrearywhileiponderedweak' + 'andwearyOveramanyquaintandcuriousvolumeof' + 'forgottenloreWhileinoddednearlynappingsud' + 'denlytherecameatapping';\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/' + fileName,\n        body: 'will fail'\n      }).then(fail, response => {\n        const b = response.data;\n        expect(b.code).toEqual(122);\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports a dictionary with file","suites":["Parse.File testing","creating files"],"line":438,"updatePoint":{"line":438,"column":39,"index":14508},"code":"    it('supports a dictionary with file', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://meep.meep',\n        name: 'meep'\n      };\n      const dict = {\n        file: file\n      };\n      const obj = new Parse.Object('FileObjTest');\n      obj.set('obj', dict);\n      obj.save().then(() => {\n        const query = new Parse.Query('FileObjTest');\n        return query.first();\n      }).then(result => {\n        const dictAgain = result.get('obj');\n        expect(typeof dictAgain).toEqual('object');\n        const fileAgain = dictAgain['file'];\n        expect(fileAgain.name()).toEqual('meep');\n        expect(fileAgain.url()).toEqual('http://meep.meep');\n        done();\n      }).catch(e => {\n        jfail(e);\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"creates correct url for old files hosted on files.parsetfss.com","suites":["Parse.File testing","creating files"],"line":464,"updatePoint":{"line":464,"column":71,"index":15311},"code":"    it('creates correct url for old files hosted on files.parsetfss.com', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://irrelevant.elephant/',\n        name: 'tfss-123.txt'\n      };\n      const obj = new Parse.Object('OldFileTest');\n      obj.set('oldfile', file);\n      obj.save().then(() => {\n        const query = new Parse.Query('OldFileTest');\n        return query.first();\n      }).then(result => {\n        const fileAgain = result.get('oldfile');\n        expect(fileAgain.url()).toEqual('http://files.parsetfss.com/test/tfss-123.txt');\n        done();\n      }).catch(e => {\n        jfail(e);\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"creates correct url for old files hosted on files.parse.com","suites":["Parse.File testing","creating files"],"line":484,"updatePoint":{"line":484,"column":67,"index":15969},"code":"    it('creates correct url for old files hosted on files.parse.com', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://irrelevant.elephant/',\n        name: 'd6e80979-a128-4c57-a167-302f874700dc-123.txt'\n      };\n      const obj = new Parse.Object('OldFileTest');\n      obj.set('oldfile', file);\n      obj.save().then(() => {\n        const query = new Parse.Query('OldFileTest');\n        return query.first();\n      }).then(result => {\n        const fileAgain = result.get('oldfile');\n        expect(fileAgain.url()).toEqual('http://files.parse.com/test/d6e80979-a128-4c57-a167-302f874700dc-123.txt');\n        done();\n      }).catch(e => {\n        jfail(e);\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports files in objects without urls","suites":["Parse.File testing","creating files"],"line":504,"updatePoint":{"line":504,"column":46,"index":16666},"code":"    it('supports files in objects without urls', done => {\n      const file = {\n        __type: 'File',\n        name: '123.txt'\n      };\n      const obj = new Parse.Object('FileTest');\n      obj.set('file', file);\n      obj.save().then(() => {\n        const query = new Parse.Query('FileTest');\n        return query.first();\n      }).then(result => {\n        const fileAgain = result.get('file');\n        expect(fileAgain.url()).toMatch(/123.txt$/);\n        done();\n      }).catch(e => {\n        jfail(e);\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"return with publicServerURL when provided","suites":["Parse.File testing","creating files"],"line":523,"updatePoint":{"line":523,"column":49,"index":17209},"code":"    it('return with publicServerURL when provided', done => {\n      reconfigureServer({\n        publicServerURL: 'https://mydomain/parse'\n      }).then(() => {\n        const file = {\n          __type: 'File',\n          name: '123.txt'\n        };\n        const obj = new Parse.Object('FileTest');\n        obj.set('file', file);\n        return obj.save();\n      }).then(() => {\n        const query = new Parse.Query('FileTest');\n        return query.first();\n      }).then(result => {\n        const fileAgain = result.get('file');\n        expect(fileAgain.url().indexOf('https://mydomain/parse')).toBe(0);\n        done();\n      }).catch(e => {\n        jfail(e);\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"fails to upload an empty file","suites":["Parse.File testing","creating files"],"line":546,"updatePoint":{"line":546,"column":37,"index":17891},"code":"    it('fails to upload an empty file', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: ''\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(body).toEqual('{\"code\":130,\"error\":\"Invalid file upload.\"}');\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"fails to upload without a file name","suites":["Parse.File testing","creating files"],"line":564,"updatePoint":{"line":564,"column":43,"index":18475},"code":"    it('fails to upload without a file name', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/',\n        body: 'yolo'\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(body).toEqual('{\"code\":122,\"error\":\"Filename not provided.\"}');\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"fails to delete an unkown file","suites":["Parse.File testing","deleting files"],"line":584,"updatePoint":{"line":584,"column":38,"index":19095},"code":"    it('fails to delete an unkown file', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Master-Key': 'test'\n      };\n      request({\n        method: 'DELETE',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt'\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(typeof body).toBe('string');\n        const {\n          code,\n          error\n        } = JSON.parse(body);\n        expect(code).toBe(153);\n        expect(typeof error).toBe('string');\n        expect(error.length).toBeGreaterThan(0);\n        done();\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"does not crash on file request with invalid app ID","suites":["Parse.File testing","getting files"],"line":611,"updatePoint":{"line":611,"column":58,"index":19929},"code":"    it('does not crash on file request with invalid app ID', async () => {\n      const res1 = await request({\n        url: 'http://localhost:8378/1/files/invalid-id/invalid-file.txt'\n      }).catch(e => e);\n      expect(res1.status).toBe(403);\n      expect(res1.data).toEqual({\n        code: 119,\n        error: 'Invalid application ID.'\n      });\n      // Ensure server did not crash\n      const res2 = await request({\n        url: 'http://localhost:8378/1/health'\n      });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({\n        status: 'ok'\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"does not crash on file request with invalid path","suites":["Parse.File testing","getting files"],"line":629,"updatePoint":{"line":629,"column":56,"index":20516},"code":"    it('does not crash on file request with invalid path', async () => {\n      const res1 = await request({\n        url: 'http://localhost:8378/1/files/invalid-id//invalid-path/%20/invalid-file.txt'\n      }).catch(e => e);\n      expect(res1.status).toBe(403);\n      expect(res1.data).toEqual({\n        error: 'unauthorized'\n      });\n      // Ensure server did not crash\n      const res2 = await request({\n        url: 'http://localhost:8378/1/health'\n      });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({\n        status: 'ok'\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"does not crash on file metadata request with invalid app ID","suites":["Parse.File testing","getting files"],"line":646,"updatePoint":{"line":646,"column":67,"index":21102},"code":"    it('does not crash on file metadata request with invalid app ID', async () => {\n      const res1 = await request({\n        url: `http://localhost:8378/1/files/invalid-id/metadata/invalid-file.txt`\n      });\n      expect(res1.status).toBe(200);\n      expect(res1.data).toEqual({});\n      // Ensure server did not crash\n      const res2 = await request({\n        url: 'http://localhost:8378/1/health'\n      });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({\n        status: 'ok'\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports bytes range out of range","suites":["Parse.File testing","getting files"],"line":663,"updatePoint":{"line":663,"column":41,"index":21663},"code":"    it('supports bytes range out of range', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100)\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=15000-18000'\n        }\n      });\n      expect(file.headers['content-range']).toBe('bytes 1212-1212/1212');\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports bytes range if end greater than start","suites":["Parse.File testing","getting files"],"line":686,"updatePoint":{"line":686,"column":54,"index":22440},"code":"    it('supports bytes range if end greater than start', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100)\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=15000-100'\n        }\n      });\n      expect(file.headers['content-range']).toBe('bytes 100-1212/1212');\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports bytes range if end is undefined","suites":["Parse.File testing","getting files"],"line":709,"updatePoint":{"line":709,"column":48,"index":23208},"code":"    it('supports bytes range if end is undefined', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100)\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=100-'\n        }\n      });\n      expect(file.headers['content-range']).toBe('bytes 100-1212/1212');\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports bytes range if start and end undefined","suites":["Parse.File testing","getting files"],"line":732,"updatePoint":{"line":732,"column":55,"index":23978},"code":"    it('supports bytes range if start and end undefined', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100)\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=abc-efs'\n        }\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBeUndefined();\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports bytes range if start and end undefined","suites":["Parse.File testing","getting files"],"line":755,"updatePoint":{"line":755,"column":55,"index":24753},"code":"    it('supports bytes range if start and end undefined', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100)\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test'\n        }\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBeUndefined();\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports bytes range if end is greater than size","suites":["Parse.File testing","getting files"],"line":777,"updatePoint":{"line":777,"column":56,"index":25495},"code":"    it('supports bytes range if end is greater than size', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100)\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=0-2000'\n        }\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBe('bytes 0-1212/1212');\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports bytes range if end is greater than size","suites":["Parse.File testing","getting files"],"line":800,"updatePoint":{"line":800,"column":56,"index":26280},"code":"    it('supports bytes range if end is greater than size', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100)\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=0-2000'\n        }\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBe('bytes 0-1212/1212');\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports bytes range with 0 length","suites":["Parse.File testing","getting files"],"line":823,"updatePoint":{"line":823,"column":42,"index":27051},"code":"    it('supports bytes range with 0 length', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: 'a'\n      }).catch(e => e);\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=-2000'\n        }\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBe('bytes 0-1/1');\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports range requests","suites":["Parse.File testing","getting files"],"line":846,"updatePoint":{"line":846,"column":31,"index":27794},"code":"    it('supports range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle'\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-5'\n          }\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle ');\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports small range requests","suites":["Parse.File testing","getting files"],"line":874,"updatePoint":{"line":874,"column":37,"index":28629},"code":"    it('supports small range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle'\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-2'\n          }\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('arg');\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports getting one byte","suites":["Parse.File testing","getting files"],"line":904,"updatePoint":{"line":904,"column":33,"index":29565},"code":"    it('supports getting one byte', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle'\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=2-2'\n          }\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('g');\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports getting last n bytes","suites":["Parse.File testing","getting files"],"line":932,"updatePoint":{"line":932,"column":37,"index":30395},"code":"    it('supports getting last n bytes', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'something different'\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=-4'\n          }\n        }).then(response => {\n          const body = response.text;\n          expect(body.length).toBe(4);\n          expect(body).toEqual('rent');\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports getting first n bytes","suites":["Parse.File testing","getting files"],"line":961,"updatePoint":{"line":961,"column":38,"index":31274},"code":"    it('supports getting first n bytes', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'something different'\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=10-'\n          }\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('different');\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"supports large range requests","suites":["Parse.File testing","getting files"],"line":997,"updatePoint":{"line":997,"column":37,"index":32272},"code":"    it('supports large range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: repeat('argle bargle', 100)\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=13-240'\n          }\n        }).then(response => {\n          const body = response.text;\n          expect(body.length).toEqual(228);\n          expect(body.indexOf('rgle barglea')).toBe(0);\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"fails to stream unknown file","suites":["Parse.File testing","getting files"],"line":1026,"updatePoint":{"line":1026,"column":36,"index":33180},"code":"    it('fails to stream unknown file', async () => {\n      const response = await request({\n        url: 'http://localhost:8378/1/files/test/file.txt',\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest',\n          Range: 'bytes=13-240'\n        }\n      }).catch(e => e);\n      expect(response.status).toBe(404);\n      const body = response.text;\n      expect(body).toEqual('File not found.');\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"fallback to regular request","suites":["Parse.File testing","getting files"],"line":1045,"updatePoint":{"line":1045,"column":35,"index":33841},"code":"    it('fallback to regular request', async done => {\n      await reconfigureServer();\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle'\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-5'\n          }\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"allows file upload only for authenticated user by default","suites":["Parse.File testing","file upload configuration"],"line":1076,"updatePoint":{"line":1076,"column":65,"index":34803},"code":"    it('allows file upload only for authenticated user by default', async () => {\n      await reconfigureServer({\n        fileUpload: {}\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({\n        sessionToken: anonUser.getSessionToken()\n      })).toBeRejectedWith(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.'));\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({\n        sessionToken: authUser.getSessionToken()\n      })).toBeResolved();\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"allows file upload with master key","suites":["Parse.File testing","file upload configuration"],"line":1093,"updatePoint":{"line":1093,"column":42,"index":35707},"code":"    it('allows file upload with master key', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false\n        }\n      });\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save({\n        useMasterKey: true\n      })).toBeResolved();\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"rejects all file uploads","suites":["Parse.File testing","file upload configuration"],"line":1106,"updatePoint":{"line":1106,"column":32,"index":36114},"code":"    it('rejects all file uploads', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false\n        }\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({\n        sessionToken: anonUser.getSessionToken()\n      })).toBeRejectedWith(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.'));\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({\n        sessionToken: authUser.getSessionToken()\n      })).toBeRejectedWith(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by authenticated user is disabled.'));\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"allows all file uploads","suites":["Parse.File testing","file upload configuration"],"line":1127,"updatePoint":{"line":1127,"column":31,"index":37233},"code":"    it('allows all file uploads', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          enableForAnonymousUser: true,\n          enableForAuthenticatedUser: true\n        }\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({\n        sessionToken: anonUser.getSessionToken()\n      })).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({\n        sessionToken: authUser.getSessionToken()\n      })).toBeResolved();\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"allows file upload only for public","suites":["Parse.File testing","file upload configuration"],"line":1148,"updatePoint":{"line":1148,"column":42,"index":38082},"code":"    it('allows file upload only for public', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false\n        }\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({\n        sessionToken: anonUser.getSessionToken()\n      })).toBeRejectedWith(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.'));\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({\n        sessionToken: authUser.getSessionToken()\n      })).toBeRejectedWith(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by authenticated user is disabled.'));\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"allows file upload only for anonymous user","suites":["Parse.File testing","file upload configuration"],"line":1169,"updatePoint":{"line":1169,"column":50,"index":39133},"code":"    it('allows file upload only for anonymous user', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: true,\n          enableForAuthenticatedUser: false\n        }\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({\n        sessionToken: anonUser.getSessionToken()\n      })).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({\n        sessionToken: authUser.getSessionToken()\n      })).toBeRejectedWith(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by authenticated user is disabled.'));\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"allows file upload only for authenticated user","suites":["Parse.File testing","file upload configuration"],"line":1190,"updatePoint":{"line":1190,"column":54,"index":40180},"code":"    it('allows file upload only for authenticated user', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: true\n        }\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({\n        sessionToken: anonUser.getSessionToken()\n      })).toBeRejectedWith(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.'));\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({\n        sessionToken: authUser.getSessionToken()\n      })).toBeResolved();\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"rejects invalid fileUpload configuration","suites":["Parse.File testing","file upload configuration"],"line":1211,"updatePoint":{"line":1211,"column":48,"index":41217},"code":"    it('rejects invalid fileUpload configuration', async () => {\n      const invalidConfigs = [{\n        fileUpload: undefined\n      }, {\n        fileUpload: null\n      }, {\n        fileUpload: []\n      }, {\n        fileUpload: 1\n      }, {\n        fileUpload: 'string'\n      }];\n      const validConfigs = [{\n        fileUpload: {}\n      }];\n      const keys = ['enableForPublic', 'enableForAnonymousUser', 'enableForAuthenticatedUser'];\n      const invalidValues = [[], {}, 1, 'string', null];\n      const validValues = [undefined, true, false];\n      for (const config of invalidConfigs) {\n        await expectAsync(reconfigureServer(config)).toBeRejectedWith('fileUpload must be an object value.');\n      }\n      for (const config of validConfigs) {\n        await expectAsync(reconfigureServer(config)).toBeResolved();\n      }\n      for (const key of keys) {\n        for (const value of invalidValues) {\n          await expectAsync(reconfigureServer({\n            fileUpload: {\n              [key]: value\n            }\n          })).toBeRejectedWith(`fileUpload.${key} must be a boolean value.`);\n        }\n        for (const value of validValues) {\n          await expectAsync(reconfigureServer({\n            fileUpload: {\n              [key]: value\n            }\n          })).toBeResolved();\n        }\n      }\n    });","file":"ParseFile.spec.js","skipped":false,"dir":"spec"},{"name":"geo point roundtrip","suites":["Parse.GeoPoint testing"],"line":7,"updatePoint":{"line":7,"column":25,"index":246},"code":"  it('geo point roundtrip', async () => {\n    const point = new Parse.GeoPoint(44.0, -11.0);\n    const obj = new TestObject();\n    obj.set('location', point);\n    obj.set('name', 'Ferndale');\n    await obj.save();\n    const result = await new Parse.Query(TestObject).get(obj.id);\n    const pointAgain = result.get('location');\n    ok(pointAgain);\n    equal(pointAgain.latitude, 44.0);\n    equal(pointAgain.longitude, -11.0);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"update geopoint","suites":["Parse.GeoPoint testing"],"line":19,"updatePoint":{"line":19,"column":21,"index":673},"code":"  it('update geopoint', done => {\n    const oldPoint = new Parse.GeoPoint(44.0, -11.0);\n    const newPoint = new Parse.GeoPoint(24.0, 19.0);\n    const obj = new TestObject();\n    obj.set('location', oldPoint);\n    obj.save().then(() => {\n      obj.set('location', newPoint);\n      return obj.save();\n    }).then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.get(obj.id);\n    }).then(result => {\n      const point = result.get('location');\n      equal(point.latitude, newPoint.latitude);\n      equal(point.longitude, newPoint.longitude);\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"has the correct __type field in the json response","suites":["Parse.GeoPoint testing"],"line":37,"updatePoint":{"line":37,"column":55,"index":1302},"code":"  it('has the correct __type field in the json response', async done => {\n    const point = new Parse.GeoPoint(44.0, -11.0);\n    const obj = new TestObject();\n    obj.set('location', point);\n    obj.set('name', 'Zhoul');\n    await obj.save();\n    Parse.Cloud.httpRequest({\n      url: 'http://localhost:8378/1/classes/TestObject/' + obj.id,\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Master-Key': 'test'\n      }\n    }).then(response => {\n      equal(response.data.location.__type, 'GeoPoint');\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"creating geo point exception two fields","suites":["Parse.GeoPoint testing"],"line":54,"updatePoint":{"line":54,"column":45,"index":1846},"code":"  it('creating geo point exception two fields', done => {\n    const point = new Parse.GeoPoint(20, 20);\n    const obj = new TestObject();\n    obj.set('locationOne', point);\n    obj.set('locationTwo', point);\n    obj.save().then(() => {\n      fail('expected error');\n    }, err => {\n      equal(err.code, Parse.Error.INCORRECT_TYPE);\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo line","suites":["Parse.GeoPoint testing"],"line":81,"updatePoint":{"line":81,"column":14,"index":2689},"code":"  it('geo line', async done => {\n    const line = [];\n    for (let i = 0; i < 10; ++i) {\n      const obj = new TestObject();\n      const point = new Parse.GeoPoint(i * 4.0 - 12.0, i * 3.2 - 11.0);\n      obj.set('location', point);\n      obj.set('construct', 'line');\n      obj.set('seq', i);\n      line.push(obj);\n    }\n    await Parse.Object.saveAll(line);\n    const query = new Parse.Query(TestObject);\n    const point = new Parse.GeoPoint(24, 19);\n    query.equalTo('construct', 'line');\n    query.withinMiles('location', point, 10000);\n    const results = await query.find();\n    equal(results.length, 10);\n    equal(results[0].get('seq'), 9);\n    equal(results[3].get('seq'), 6);\n    done();\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo max distance large","suites":["Parse.GeoPoint testing"],"line":102,"updatePoint":{"line":102,"column":28,"index":3406},"code":"  it('geo max distance large', done => {\n    const objects = [];\n    [0, 1, 2].map(function (i) {\n      const obj = new TestObject();\n      const point = new Parse.GeoPoint(0.0, i * 45.0);\n      obj.set('location', point);\n      obj.set('index', i);\n      objects.push(obj);\n    });\n    Parse.Object.saveAll(objects).then(() => {\n      const query = new Parse.Query(TestObject);\n      const point = new Parse.GeoPoint(1.0, -1.0);\n      query.withinRadians('location', point, 3.14);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 3);\n      done();\n    }, err => {\n      fail(\"Couldn't query GeoPoint\");\n      jfail(err);\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo max distance medium","suites":["Parse.GeoPoint testing"],"line":124,"updatePoint":{"line":124,"column":29,"index":4074},"code":"  it('geo max distance medium', async () => {\n    const objects = [];\n    [0, 1, 2].map(function (i) {\n      const obj = new TestObject();\n      const point = new Parse.GeoPoint(0.0, i * 45.0);\n      obj.set('location', point);\n      obj.set('index', i);\n      objects.push(obj);\n    });\n    await Parse.Object.saveAll(objects);\n    const query = new Parse.Query(TestObject);\n    const point = new Parse.GeoPoint(1.0, -1.0);\n    query.withinRadians('location', point, 3.14 * 0.5);\n    const results = await query.find();\n    equal(results.length, 2);\n    equal(results[0].get('index'), 0);\n    equal(results[1].get('index'), 1);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo max distance small","suites":["Parse.GeoPoint testing"],"line":142,"updatePoint":{"line":142,"column":28,"index":4708},"code":"  it('geo max distance small', async () => {\n    const objects = [];\n    [0, 1, 2].map(function (i) {\n      const obj = new TestObject();\n      const point = new Parse.GeoPoint(0.0, i * 45.0);\n      obj.set('location', point);\n      obj.set('index', i);\n      objects.push(obj);\n    });\n    await Parse.Object.saveAll(objects);\n    const query = new Parse.Query(TestObject);\n    const point = new Parse.GeoPoint(1.0, -1.0);\n    query.withinRadians('location', point, 3.14 * 0.25);\n    const results = await query.find();\n    equal(results.length, 1);\n    equal(results[0].get('index'), 0);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo max distance in km everywhere","suites":["Parse.GeoPoint testing"],"line":171,"updatePoint":{"line":171,"column":39,"index":5846},"code":"  it('geo max distance in km everywhere', async done => {\n    await makeSomeGeoPoints();\n    const sfo = new Parse.GeoPoint(37.6189722, -122.3748889);\n    const query = new Parse.Query(TestObject);\n    // Honolulu is 4300 km away from SFO on a sphere ;)\n    query.withinKilometers('location', sfo, 4800.0);\n    const results = await query.find();\n    equal(results.length, 3);\n    done();\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo max distance in km california","suites":["Parse.GeoPoint testing"],"line":181,"updatePoint":{"line":181,"column":39,"index":6241},"code":"  it('geo max distance in km california', async () => {\n    await makeSomeGeoPoints();\n    const sfo = new Parse.GeoPoint(37.6189722, -122.3748889);\n    const query = new Parse.Query(TestObject);\n    query.withinKilometers('location', sfo, 3700.0);\n    const results = await query.find();\n    equal(results.length, 2);\n    equal(results[0].get('name'), 'San Francisco');\n    equal(results[1].get('name'), 'Sacramento');\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo max distance in km bay area","suites":["Parse.GeoPoint testing"],"line":191,"updatePoint":{"line":191,"column":37,"index":6665},"code":"  it('geo max distance in km bay area', async () => {\n    await makeSomeGeoPoints();\n    const sfo = new Parse.GeoPoint(37.6189722, -122.3748889);\n    const query = new Parse.Query(TestObject);\n    query.withinKilometers('location', sfo, 100.0);\n    const results = await query.find();\n    equal(results.length, 1);\n    equal(results[0].get('name'), 'San Francisco');\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo max distance in km mid peninsula","suites":["Parse.GeoPoint testing"],"line":200,"updatePoint":{"line":200,"column":42,"index":7044},"code":"  it('geo max distance in km mid peninsula', async () => {\n    await makeSomeGeoPoints();\n    const sfo = new Parse.GeoPoint(37.6189722, -122.3748889);\n    const query = new Parse.Query(TestObject);\n    query.withinKilometers('location', sfo, 10.0);\n    const results = await query.find();\n    equal(results.length, 0);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo max distance in miles everywhere","suites":["Parse.GeoPoint testing"],"line":208,"updatePoint":{"line":208,"column":42,"index":7370},"code":"  it('geo max distance in miles everywhere', async () => {\n    await makeSomeGeoPoints();\n    const sfo = new Parse.GeoPoint(37.6189722, -122.3748889);\n    const query = new Parse.Query(TestObject);\n    query.withinMiles('location', sfo, 2600.0);\n    const results = await query.find();\n    equal(results.length, 3);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo max distance in miles california","suites":["Parse.GeoPoint testing"],"line":216,"updatePoint":{"line":216,"column":42,"index":7693},"code":"  it('geo max distance in miles california', async () => {\n    await makeSomeGeoPoints();\n    const sfo = new Parse.GeoPoint(37.6189722, -122.3748889);\n    const query = new Parse.Query(TestObject);\n    query.withinMiles('location', sfo, 2200.0);\n    const results = await query.find();\n    equal(results.length, 2);\n    equal(results[0].get('name'), 'San Francisco');\n    equal(results[1].get('name'), 'Sacramento');\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo max distance in miles bay area","suites":["Parse.GeoPoint testing"],"line":226,"updatePoint":{"line":226,"column":40,"index":8115},"code":"  it('geo max distance in miles bay area', async () => {\n    await makeSomeGeoPoints();\n    const sfo = new Parse.GeoPoint(37.6189722, -122.3748889);\n    const query = new Parse.Query(TestObject);\n    query.withinMiles('location', sfo, 62.0);\n    const results = await query.find();\n    equal(results.length, 1);\n    equal(results[0].get('name'), 'San Francisco');\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"geo max distance in miles mid peninsula","suites":["Parse.GeoPoint testing"],"line":235,"updatePoint":{"line":235,"column":45,"index":8491},"code":"  it('geo max distance in miles mid peninsula', async () => {\n    await makeSomeGeoPoints();\n    const sfo = new Parse.GeoPoint(37.6189722, -122.3748889);\n    const query = new Parse.Query(TestObject);\n    query.withinMiles('location', sfo, 10.0);\n    const results = await query.find();\n    equal(results.length, 0);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"returns nearest location","suites":["Parse.GeoPoint testing"],"line":243,"updatePoint":{"line":243,"column":30,"index":8800},"code":"  it('returns nearest location', async () => {\n    await makeSomeGeoPoints();\n    const sfo = new Parse.GeoPoint(37.6189722, -122.3748889);\n    const query = new Parse.Query(TestObject);\n    query.near('location', sfo);\n    const results = await query.find();\n    equal(results[0].get('name'), 'San Francisco');\n    equal(results[1].get('name'), 'Sacramento');\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"works with geobox queries","suites":["Parse.GeoPoint testing"],"line":252,"updatePoint":{"line":252,"column":31,"index":9168},"code":"  it('works with geobox queries', done => {\n    const inbound = new Parse.GeoPoint(1.5, 1.5);\n    const onbound = new Parse.GeoPoint(10, 10);\n    const outbound = new Parse.GeoPoint(20, 20);\n    const obj1 = new Parse.Object('TestObject', {\n      location: inbound\n    });\n    const obj2 = new Parse.Object('TestObject', {\n      location: onbound\n    });\n    const obj3 = new Parse.Object('TestObject', {\n      location: outbound\n    });\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const sw = new Parse.GeoPoint(0, 0);\n      const ne = new Parse.GeoPoint(10, 10);\n      const query = new Parse.Query(TestObject);\n      query.withinGeoBox('location', sw, ne);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 2);\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"supports a sub-object with a geo point","suites":["Parse.GeoPoint testing"],"line":276,"updatePoint":{"line":276,"column":44,"index":9972},"code":"  it('supports a sub-object with a geo point', async () => {\n    const point = new Parse.GeoPoint(44.0, -11.0);\n    const obj = new TestObject();\n    obj.set('subobject', {\n      location: point\n    });\n    await obj.save();\n    const query = new Parse.Query(TestObject);\n    const results = await query.find();\n    equal(results.length, 1);\n    const pointAgain = results[0].get('subobject')['location'];\n    ok(pointAgain);\n    equal(pointAgain.latitude, 44.0);\n    equal(pointAgain.longitude, -11.0);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"supports array of geo points","suites":["Parse.GeoPoint testing"],"line":291,"updatePoint":{"line":291,"column":34,"index":10472},"code":"  it('supports array of geo points', async () => {\n    const point1 = new Parse.GeoPoint(44.0, -11.0);\n    const point2 = new Parse.GeoPoint(22.0, -55.0);\n    const obj = new TestObject();\n    obj.set('locations', [point1, point2]);\n    await obj.save();\n    const query = new Parse.Query(TestObject);\n    const results = await query.find();\n    equal(results.length, 1);\n    const locations = results[0].get('locations');\n    expect(locations.length).toEqual(2);\n    expect(locations[0]).toEqual(point1);\n    expect(locations[1]).toEqual(point2);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"equalTo geopoint","suites":["Parse.GeoPoint testing"],"line":305,"updatePoint":{"line":305,"column":22,"index":11014},"code":"  it('equalTo geopoint', done => {\n    const point = new Parse.GeoPoint(44.0, -11.0);\n    const obj = new TestObject();\n    obj.set('location', point);\n    obj.save().then(() => {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('location', point);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 1);\n      const loc = results[0].get('location');\n      equal(loc.latitude, point.latitude);\n      equal(loc.longitude, point.longitude);\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"supports withinPolygon open path","suites":["Parse.GeoPoint testing"],"line":321,"updatePoint":{"line":321,"column":38,"index":11545},"code":"  it('supports withinPolygon open path', done => {\n    const inbound = new Parse.GeoPoint(1.5, 1.5);\n    const onbound = new Parse.GeoPoint(10, 10);\n    const outbound = new Parse.GeoPoint(20, 20);\n    const obj1 = new Parse.Object('Polygon', {\n      location: inbound\n    });\n    const obj2 = new Parse.Object('Polygon', {\n      location: onbound\n    });\n    const obj3 = new Parse.Object('Polygon', {\n      location: outbound\n    });\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const where = {\n        location: {\n          $geoWithin: {\n            $polygon: [{\n              __type: 'GeoPoint',\n              latitude: 0,\n              longitude: 0\n            }, {\n              __type: 'GeoPoint',\n              latitude: 0,\n              longitude: 10\n            }, {\n              __type: 'GeoPoint',\n              latitude: 10,\n              longitude: 10\n            }, {\n              __type: 'GeoPoint',\n              latitude: 10,\n              longitude: 0\n            }]\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/Polygon',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      expect(resp.data.results.length).toBe(2);\n      done();\n    }, done.fail);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"supports withinPolygon closed path","suites":["Parse.GeoPoint testing"],"line":376,"updatePoint":{"line":376,"column":40,"index":13059},"code":"  it('supports withinPolygon closed path', done => {\n    const inbound = new Parse.GeoPoint(1.5, 1.5);\n    const onbound = new Parse.GeoPoint(10, 10);\n    const outbound = new Parse.GeoPoint(20, 20);\n    const obj1 = new Parse.Object('Polygon', {\n      location: inbound\n    });\n    const obj2 = new Parse.Object('Polygon', {\n      location: onbound\n    });\n    const obj3 = new Parse.Object('Polygon', {\n      location: outbound\n    });\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const where = {\n        location: {\n          $geoWithin: {\n            $polygon: [{\n              __type: 'GeoPoint',\n              latitude: 0,\n              longitude: 0\n            }, {\n              __type: 'GeoPoint',\n              latitude: 0,\n              longitude: 10\n            }, {\n              __type: 'GeoPoint',\n              latitude: 10,\n              longitude: 10\n            }, {\n              __type: 'GeoPoint',\n              latitude: 10,\n              longitude: 0\n            }, {\n              __type: 'GeoPoint',\n              latitude: 0,\n              longitude: 0\n            }]\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/Polygon',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      expect(resp.data.results.length).toBe(2);\n      done();\n    }, done.fail);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"supports withinPolygon Polygon object","suites":["Parse.GeoPoint testing"],"line":435,"updatePoint":{"line":435,"column":43,"index":14681},"code":"  it('supports withinPolygon Polygon object', done => {\n    const inbound = new Parse.GeoPoint(1.5, 1.5);\n    const onbound = new Parse.GeoPoint(10, 10);\n    const outbound = new Parse.GeoPoint(20, 20);\n    const obj1 = new Parse.Object('Polygon', {\n      location: inbound\n    });\n    const obj2 = new Parse.Object('Polygon', {\n      location: onbound\n    });\n    const obj3 = new Parse.Object('Polygon', {\n      location: outbound\n    });\n    const polygon = {\n      __type: 'Polygon',\n      coordinates: [[0, 0], [10, 0], [10, 10], [0, 10], [0, 0]]\n    };\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const where = {\n        location: {\n          $geoWithin: {\n            $polygon: polygon\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/Polygon',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      expect(resp.data.results.length).toBe(2);\n      done();\n    }, done.fail);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"invalid Polygon object withinPolygon","suites":["Parse.GeoPoint testing"],"line":478,"updatePoint":{"line":478,"column":42,"index":15898},"code":"  it('invalid Polygon object withinPolygon', done => {\n    const point = new Parse.GeoPoint(1.5, 1.5);\n    const obj = new Parse.Object('Polygon', {\n      location: point\n    });\n    const polygon = {\n      __type: 'Polygon',\n      coordinates: [[0, 0], [10, 0]]\n    };\n    obj.save().then(() => {\n      const where = {\n        location: {\n          $geoWithin: {\n            $polygon: polygon\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/Polygon',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      fail(`no request should succeed: ${JSON.stringify(resp)}`);\n      done();\n    }).catch(err => {\n      expect(err.data.code).toEqual(Parse.Error.INVALID_JSON);\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"out of bounds Polygon object withinPolygon","suites":["Parse.GeoPoint testing"],"line":516,"updatePoint":{"line":516,"column":48,"index":16909},"code":"  it('out of bounds Polygon object withinPolygon', done => {\n    const point = new Parse.GeoPoint(1.5, 1.5);\n    const obj = new Parse.Object('Polygon', {\n      location: point\n    });\n    const polygon = {\n      __type: 'Polygon',\n      coordinates: [[0, 0], [181, 0], [0, 10]]\n    };\n    obj.save().then(() => {\n      const where = {\n        location: {\n          $geoWithin: {\n            $polygon: polygon\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/Polygon',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      fail(`no request should succeed: ${JSON.stringify(resp)}`);\n      done();\n    }).catch(err => {\n      expect(err.data.code).toEqual(1);\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"invalid input withinPolygon","suites":["Parse.GeoPoint testing"],"line":554,"updatePoint":{"line":554,"column":33,"index":17892},"code":"  it('invalid input withinPolygon', done => {\n    const point = new Parse.GeoPoint(1.5, 1.5);\n    const obj = new Parse.Object('Polygon', {\n      location: point\n    });\n    obj.save().then(() => {\n      const where = {\n        location: {\n          $geoWithin: {\n            $polygon: 1234\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/Polygon',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      fail(`no request should succeed: ${JSON.stringify(resp)}`);\n      done();\n    }).catch(err => {\n      expect(err.data.code).toEqual(Parse.Error.INVALID_JSON);\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"invalid geoPoint withinPolygon","suites":["Parse.GeoPoint testing"],"line":588,"updatePoint":{"line":588,"column":36,"index":18797},"code":"  it('invalid geoPoint withinPolygon', done => {\n    const point = new Parse.GeoPoint(1.5, 1.5);\n    const obj = new Parse.Object('Polygon', {\n      location: point\n    });\n    obj.save().then(() => {\n      const where = {\n        location: {\n          $geoWithin: {\n            $polygon: [{}]\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/Polygon',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      fail(`no request should succeed: ${JSON.stringify(resp)}`);\n      done();\n    }).catch(err => {\n      expect(err.data.code).toEqual(Parse.Error.INVALID_JSON);\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"invalid latitude withinPolygon","suites":["Parse.GeoPoint testing"],"line":622,"updatePoint":{"line":622,"column":36,"index":19702},"code":"  it('invalid latitude withinPolygon', done => {\n    const point = new Parse.GeoPoint(1.5, 1.5);\n    const obj = new Parse.Object('Polygon', {\n      location: point\n    });\n    obj.save().then(() => {\n      const where = {\n        location: {\n          $geoWithin: {\n            $polygon: [{\n              __type: 'GeoPoint',\n              latitude: 0,\n              longitude: 0\n            }, {\n              __type: 'GeoPoint',\n              latitude: 181,\n              longitude: 0\n            }, {\n              __type: 'GeoPoint',\n              latitude: 0,\n              longitude: 0\n            }]\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/Polygon',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      fail(`no request should succeed: ${JSON.stringify(resp)}`);\n      done();\n    }).catch(err => {\n      expect(err.data.code).toEqual(1);\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"invalid longitude withinPolygon","suites":["Parse.GeoPoint testing"],"line":668,"updatePoint":{"line":668,"column":37,"index":20898},"code":"  it('invalid longitude withinPolygon', done => {\n    const point = new Parse.GeoPoint(1.5, 1.5);\n    const obj = new Parse.Object('Polygon', {\n      location: point\n    });\n    obj.save().then(() => {\n      const where = {\n        location: {\n          $geoWithin: {\n            $polygon: [{\n              __type: 'GeoPoint',\n              latitude: 0,\n              longitude: 0\n            }, {\n              __type: 'GeoPoint',\n              latitude: 0,\n              longitude: 181\n            }, {\n              __type: 'GeoPoint',\n              latitude: 0,\n              longitude: 0\n            }]\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/Polygon',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      fail(`no request should succeed: ${JSON.stringify(resp)}`);\n      done();\n    }).catch(err => {\n      expect(err.data.code).toEqual(1);\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"minimum 3 points withinPolygon","suites":["Parse.GeoPoint testing"],"line":714,"updatePoint":{"line":714,"column":36,"index":22093},"code":"  it('minimum 3 points withinPolygon', done => {\n    const point = new Parse.GeoPoint(1.5, 1.5);\n    const obj = new Parse.Object('Polygon', {\n      location: point\n    });\n    obj.save().then(() => {\n      const where = {\n        location: {\n          $geoWithin: {\n            $polygon: []\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/Polygon',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      fail(`no request should succeed: ${JSON.stringify(resp)}`);\n      done();\n    }).catch(err => {\n      expect(err.data.code).toEqual(107);\n      done();\n    });\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"withinKilometers supports count","suites":["Parse.GeoPoint testing"],"line":748,"updatePoint":{"line":748,"column":37,"index":22976},"code":"  it('withinKilometers supports count', async () => {\n    const inside = new Parse.GeoPoint(10, 10);\n    const outside = new Parse.GeoPoint(20, 20);\n    const obj1 = new Parse.Object('TestObject', {\n      location: inside\n    });\n    const obj2 = new Parse.Object('TestObject', {\n      location: outside\n    });\n    await Parse.Object.saveAll([obj1, obj2]);\n    const q = new Parse.Query(TestObject).withinKilometers('location', inside, 5);\n    const count = await q.count();\n    equal(count, 1);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"withinKilometers complex supports count","suites":["Parse.GeoPoint testing"],"line":762,"updatePoint":{"line":762,"column":45,"index":23487},"code":"  it('withinKilometers complex supports count', async () => {\n    const inside = new Parse.GeoPoint(10, 10);\n    const middle = new Parse.GeoPoint(20, 20);\n    const outside = new Parse.GeoPoint(30, 30);\n    const obj1 = new Parse.Object('TestObject', {\n      location: inside\n    });\n    const obj2 = new Parse.Object('TestObject', {\n      location: middle\n    });\n    const obj3 = new Parse.Object('TestObject', {\n      location: outside\n    });\n    await Parse.Object.saveAll([obj1, obj2, obj3]);\n    const q1 = new Parse.Query(TestObject).withinKilometers('location', inside, 5);\n    const q2 = new Parse.Query(TestObject).withinKilometers('location', middle, 5);\n    const query = Parse.Query.or(q1, q2);\n    const count = await query.count();\n    equal(count, 2);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"fails to fetch geopoints that are specifically not at (0,0)","suites":["Parse.GeoPoint testing"],"line":782,"updatePoint":{"line":782,"column":65,"index":24283},"code":"  it('fails to fetch geopoints that are specifically not at (0,0)', async () => {\n    const tmp = new TestObject({\n      location: new Parse.GeoPoint({\n        latitude: 0,\n        longitude: 0\n      })\n    });\n    const tmp2 = new TestObject({\n      location: new Parse.GeoPoint({\n        latitude: 49.2577142,\n        longitude: -123.1941149\n      })\n    });\n    await Parse.Object.saveAll([tmp, tmp2]);\n    const query = new Parse.Query(TestObject);\n    query.notEqualTo('location', new Parse.GeoPoint({\n      latitude: 0,\n      longitude: 0\n    }));\n    const results = await query.find();\n    expect(results.length).toEqual(1);\n  });","file":"ParseGeoPoint.spec.js","skipped":false,"dir":"spec"},{"name":"can be retrieved","suites":["a GlobalConfig"],"line":48,"updatePoint":{"line":48,"column":22,"index":1040},"code":"  it('can be retrieved', done => {\n    request({\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      headers\n    }).then(response => {\n      const body = response.data;\n      try {\n        expect(response.status).toEqual(200);\n        expect(body.params.companies).toEqual(['US', 'DK']);\n      } catch (e) {\n        jfail(e);\n      }\n      done();\n    });\n  });","file":"ParseGlobalConfig.spec.js","skipped":false,"dir":"spec"},{"name":"internal parameter can be retrieved with master key","suites":["a GlobalConfig"],"line":64,"updatePoint":{"line":64,"column":57,"index":1454},"code":"  it('internal parameter can be retrieved with master key', done => {\n    request({\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      headers\n    }).then(response => {\n      const body = response.data;\n      try {\n        expect(response.status).toEqual(200);\n        expect(body.params.internalParam).toEqual('internal');\n      } catch (e) {\n        jfail(e);\n      }\n      done();\n    });\n  });","file":"ParseGlobalConfig.spec.js","skipped":false,"dir":"spec"},{"name":"internal parameter cannot be retrieved without master key","suites":["a GlobalConfig"],"line":80,"updatePoint":{"line":80,"column":63,"index":1876},"code":"  it('internal parameter cannot be retrieved without master key', done => {\n    request({\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      }\n    }).then(response => {\n      const body = response.data;\n      try {\n        expect(response.status).toEqual(200);\n        expect(body.params.internalParam).toBeUndefined();\n      } catch (e) {\n        jfail(e);\n      }\n      done();\n    });\n  });","file":"ParseGlobalConfig.spec.js","skipped":false,"dir":"spec"},{"name":"can be updated when a master key exists","suites":["a GlobalConfig"],"line":100,"updatePoint":{"line":100,"column":45,"index":2412},"code":"  it('can be updated when a master key exists', done => {\n    request({\n      method: 'PUT',\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      body: {\n        params: {\n          companies: ['US', 'DK', 'SE']\n        }\n      },\n      headers\n    }).then(response => {\n      const body = response.data;\n      expect(response.status).toEqual(200);\n      expect(body.result).toEqual(true);\n      done();\n    });\n  });","file":"ParseGlobalConfig.spec.js","skipped":false,"dir":"spec"},{"name":"can add and retrive files","suites":["a GlobalConfig"],"line":118,"updatePoint":{"line":118,"column":31,"index":2832},"code":"  it('can add and retrive files', done => {\n    request({\n      method: 'PUT',\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      body: {\n        params: {\n          file: {\n            __type: 'File',\n            name: 'name',\n            url: 'http://url'\n          }\n        }\n      },\n      headers\n    }).then(response => {\n      const body = response.data;\n      expect(response.status).toEqual(200);\n      expect(body.result).toEqual(true);\n      Parse.Config.get().then(res => {\n        const file = res.get('file');\n        expect(file.name()).toBe('name');\n        expect(file.url()).toBe('http://url');\n        done();\n      });\n    });\n  });","file":"ParseGlobalConfig.spec.js","skipped":false,"dir":"spec"},{"name":"can add and retrive Geopoints","suites":["a GlobalConfig"],"line":145,"updatePoint":{"line":145,"column":35,"index":3508},"code":"  it('can add and retrive Geopoints', done => {\n    const geopoint = new Parse.GeoPoint(10, -20);\n    request({\n      method: 'PUT',\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      body: {\n        params: {\n          point: geopoint.toJSON()\n        }\n      },\n      headers\n    }).then(response => {\n      const body = response.data;\n      expect(response.status).toEqual(200);\n      expect(body.result).toEqual(true);\n      Parse.Config.get().then(res => {\n        const point = res.get('point');\n        expect(point.latitude).toBe(10);\n        expect(point.longitude).toBe(-20);\n        done();\n      });\n    });\n  });","file":"ParseGlobalConfig.spec.js","skipped":false,"dir":"spec"},{"name":"properly handles delete op","suites":["a GlobalConfig"],"line":169,"updatePoint":{"line":169,"column":32,"index":4149},"code":"  it('properly handles delete op', done => {\n    request({\n      method: 'PUT',\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      body: {\n        params: {\n          companies: {\n            __op: 'Delete'\n          },\n          internalParam: {\n            __op: 'Delete'\n          },\n          foo: 'bar'\n        }\n      },\n      headers\n    }).then(response => {\n      const body = response.data;\n      expect(response.status).toEqual(200);\n      expect(body.result).toEqual(true);\n      request({\n        url: 'http://localhost:8378/1/config',\n        json: true,\n        headers\n      }).then(response => {\n        const body = response.data;\n        try {\n          expect(response.status).toEqual(200);\n          expect(body.params.companies).toBeUndefined();\n          expect(body.params.foo).toBe('bar');\n          expect(Object.keys(body.params).length).toBe(1);\n        } catch (e) {\n          jfail(e);\n        }\n        done();\n      });\n    });\n  });","file":"ParseGlobalConfig.spec.js","skipped":false,"dir":"spec"},{"name":"fail to update if master key is missing","suites":["a GlobalConfig"],"line":208,"updatePoint":{"line":208,"column":45,"index":5146},"code":"  it('fail to update if master key is missing', done => {\n    request({\n      method: 'PUT',\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      body: {\n        params: {\n          companies: []\n        }\n      },\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      }\n    }).then(fail, response => {\n      const body = response.data;\n      expect(response.status).toEqual(403);\n      expect(body.error).toEqual('unauthorized: master key is required');\n      done();\n    });\n  });","file":"ParseGlobalConfig.spec.js","skipped":false,"dir":"spec"},{"name":"failed getting config when it is missing","suites":["a GlobalConfig"],"line":230,"updatePoint":{"line":230,"column":46,"index":5740},"code":"  it('failed getting config when it is missing', done => {\n    const config = Config.get('test');\n    config.database.adapter.deleteObjectsByQuery('_GlobalConfig', {\n      fields: {\n        params: {\n          __type: 'String'\n        }\n      }\n    }, {\n      objectId: '1'\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/config',\n        json: true,\n        headers\n      }).then(response => {\n        const body = response.data;\n        expect(response.status).toEqual(200);\n        expect(body.params).toEqual({});\n        done();\n      });\n    }).catch(e => {\n      jfail(e);\n      done();\n    });\n  });","file":"ParseGlobalConfig.spec.js","skipped":false,"dir":"spec"},{"name":"should remove starting _ and tansform first letter to upper case","suites":["transformClassNameToGraphQL"],"line":5,"updatePoint":{"line":5,"column":70,"index":211},"code":"  it('should remove starting _ and tansform first letter to upper case', () => {\n    expect(['_User', '_user', 'User', 'user'].map(transformClassNameToGraphQL)).toEqual(['User', 'User', 'User', 'User']);\n  });","file":"ParseGraphQLClassNameTransformer.spec.js","skipped":false,"dir":"spec"},{"name":"should require a databaseController","suites":["ParseGraphQLController","constructor"],"line":63,"updatePoint":{"line":63,"column":43,"index":2209},"code":"    it('should require a databaseController', () => {\n      expect(() => new ParseGraphQLController()).toThrow('ParseGraphQLController requires a \"databaseController\" to be instantiated.');\n      expect(() => new ParseGraphQLController({\n        cacheController\n      })).toThrow('ParseGraphQLController requires a \"databaseController\" to be instantiated.');\n      expect(() => new ParseGraphQLController({\n        cacheController,\n        mountGraphQL: false\n      })).toThrow('ParseGraphQLController requires a \"databaseController\" to be instantiated.');\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should construct without a cacheController","suites":["ParseGraphQLController","constructor"],"line":73,"updatePoint":{"line":73,"column":50,"index":2781},"code":"    it('should construct without a cacheController', () => {\n      expect(() => new ParseGraphQLController({\n        databaseController\n      })).not.toThrow();\n      expect(() => new ParseGraphQLController({\n        databaseController,\n        mountGraphQL: true\n      })).not.toThrow();\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should set isMounted to true if config.mountGraphQL is true","suites":["ParseGraphQLController","constructor"],"line":82,"updatePoint":{"line":82,"column":67,"index":3095},"code":"    it('should set isMounted to true if config.mountGraphQL is true', () => {\n      const mountedController = new ParseGraphQLController({\n        databaseController,\n        mountGraphQL: true\n      });\n      expect(mountedController.isMounted).toBe(true);\n      const unmountedController = new ParseGraphQLController({\n        databaseController,\n        mountGraphQL: false\n      });\n      expect(unmountedController.isMounted).toBe(false);\n      const unmountedController2 = new ParseGraphQLController({\n        databaseController\n      });\n      expect(unmountedController2.isMounted).toBe(false);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should return an empty graphQLConfig if collection has none","suites":["ParseGraphQLController","getGraphQLConfig"],"line":100,"updatePoint":{"line":100,"column":67,"index":3751},"code":"    it('should return an empty graphQLConfig if collection has none', async () => {\n      removeConfigFromDb();\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController,\n        mountGraphQL: false\n      });\n      const graphQLConfig = await parseGraphQLController.getGraphQLConfig();\n      expect(graphQLConfig).toEqual({});\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should return an existing graphQLConfig","suites":["ParseGraphQLController","getGraphQLConfig"],"line":109,"updatePoint":{"line":109,"column":47,"index":4101},"code":"    it('should return an existing graphQLConfig', async () => {\n      setConfigOnDb({\n        enabledForClasses: ['_User']\n      });\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController,\n        mountGraphQL: false\n      });\n      const graphQLConfig = await parseGraphQLController.getGraphQLConfig();\n      expect(graphQLConfig).toEqual({\n        enabledForClasses: ['_User']\n      });\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should use the cache if mounted, and return the stored graphQLConfig","suites":["ParseGraphQLController","getGraphQLConfig"],"line":122,"updatePoint":{"line":122,"column":76,"index":4565},"code":"    it('should use the cache if mounted, and return the stored graphQLConfig', async () => {\n      removeConfigFromDb();\n      cacheController.graphQL.clear();\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController,\n        cacheController,\n        mountGraphQL: true\n      });\n      cacheController.graphQL.put(parseGraphQLController.configCacheKey, {\n        enabledForClasses: ['SuperCar']\n      });\n      const graphQLConfig = await parseGraphQLController.getGraphQLConfig();\n      expect(graphQLConfig).toEqual({\n        enabledForClasses: ['SuperCar']\n      });\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should use the database when mounted and cache is empty","suites":["ParseGraphQLController","getGraphQLConfig"],"line":138,"updatePoint":{"line":138,"column":63,"index":5166},"code":"    it('should use the database when mounted and cache is empty', async () => {\n      setConfigOnDb({\n        disabledForClasses: ['SuperCar']\n      });\n      cacheController.graphQL.clear();\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController,\n        cacheController,\n        mountGraphQL: true\n      });\n      const graphQLConfig = await parseGraphQLController.getGraphQLConfig();\n      expect(graphQLConfig).toEqual({\n        disabledForClasses: ['SuperCar']\n      });\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should store the graphQLConfig in cache if mounted","suites":["ParseGraphQLController","getGraphQLConfig"],"line":153,"updatePoint":{"line":153,"column":58,"index":5683},"code":"    it('should store the graphQLConfig in cache if mounted', async () => {\n      setConfigOnDb({\n        enabledForClasses: ['SuperCar']\n      });\n      cacheController.graphQL.clear();\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController,\n        cacheController,\n        mountGraphQL: true\n      });\n      const cachedValueBefore = await cacheController.graphQL.get(parseGraphQLController.configCacheKey);\n      expect(cachedValueBefore).toBeNull();\n      await parseGraphQLController.getGraphQLConfig();\n      const cachedValueAfter = await cacheController.graphQL.get(parseGraphQLController.configCacheKey);\n      expect(cachedValueAfter).toEqual({\n        enabledForClasses: ['SuperCar']\n      });\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if graphQLConfig is not provided","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":178,"updatePoint":{"line":178,"column":53,"index":6570},"code":"    it('should throw if graphQLConfig is not provided', async function () {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig()).toBeRejectedWith('You must provide a graphQLConfig!');\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should correct update the graphQLConfig object using the databaseController","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":184,"updatePoint":{"line":184,"column":83,"index":6906},"code":"    it('should correct update the graphQLConfig object using the databaseController', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      const graphQLConfig = {\n        enabledForClasses: ['ClassA', 'ClassB'],\n        disabledForClasses: [],\n        classConfigs: [{\n          className: 'ClassA',\n          query: {\n            get: false\n          }\n        }, {\n          className: 'ClassB',\n          mutation: {\n            destroy: false\n          },\n          type: {}\n        }]\n      };\n      await parseGraphQLController.updateGraphQLConfig(graphQLConfig);\n      expect(databaseUpdateArgs).toBeTruthy();\n      const [className, query, update, op] = databaseUpdateArgs;\n      expect(className).toBe(GraphQLConfigClassName);\n      expect(query).toEqual({\n        objectId: GraphQLConfigId\n      });\n      expect(update).toEqual({\n        [GraphQLConfigKey]: graphQLConfig\n      });\n      expect(op).toEqual({\n        upsert: true\n      });\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if graphQLConfig is not an object","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":218,"updatePoint":{"line":218,"column":54,"index":7906},"code":"    it('should throw if graphQLConfig is not an object', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig([])).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig(function () {})).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig(Promise.resolve({}))).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig('')).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({})).toBeResolvedTo(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if graphQLConfig has an invalid root key","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":228,"updatePoint":{"line":228,"column":61,"index":8560},"code":"    it('should throw if graphQLConfig has an invalid root key', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        invalidKey: true\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({})).toBeResolvedTo(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if graphQLConfig has invalid class filters","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":237,"updatePoint":{"line":237,"column":63,"index":8973},"code":"    it('should throw if graphQLConfig has invalid class filters', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        enabledForClasses: {}\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        enabledForClasses: [undefined]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        disabledForClasses: [null]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        enabledForClasses: ['_User', null]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        disabledForClasses: ['']\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        enabledForClasses: [],\n        disabledForClasses: ['_User']\n      })).toBeResolvedTo(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if classConfigs array is invalid","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":261,"updatePoint":{"line":261,"column":53,"index":9963},"code":"    it('should throw if classConfigs array is invalid', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: {}\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [null]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [undefined]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: 'ValidClass'\n        }, null]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: []\n      })).toBeResolvedTo(successfulUpdateResponse);\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User'\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if a classConfig has invalid type settings","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":288,"updatePoint":{"line":288,"column":63,"index":10994},"code":"    it('should throw if a classConfig has invalid type settings', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: []\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            invalidKey: true\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {}\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if a classConfig has invalid type.inputFields settings","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":313,"updatePoint":{"line":313,"column":75,"index":11785},"code":"    it('should throw if a classConfig has invalid type.inputFields settings', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: 'SuperCar',\n          type: {\n            inputFields: []\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: 'SuperCar',\n          type: {\n            inputFields: {\n              invalidKey: true\n            }\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: 'SuperCar',\n          type: {\n            inputFields: {\n              create: {}\n            }\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: 'SuperCar',\n          type: {\n            inputFields: {\n              update: [null]\n            }\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: 'SuperCar',\n          type: {\n            inputFields: {\n              create: [],\n              update: []\n            }\n          }\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: 'SuperCar',\n          type: {\n            inputFields: {\n              create: ['make', 'model'],\n              update: []\n            }\n          }\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if a classConfig has invalid type.outputFields settings","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":378,"updatePoint":{"line":378,"column":76,"index":13604},"code":"    it('should throw if a classConfig has invalid type.outputFields settings', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            outputFields: {}\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            outputFields: [null]\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            outputFields: ['name', undefined]\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            outputFields: ['']\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            outputFields: []\n          }\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            outputFields: ['name']\n          }\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if a classConfig has invalid type.constraintFields settings","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":431,"updatePoint":{"line":431,"column":80,"index":15177},"code":"    it('should throw if a classConfig has invalid type.constraintFields settings', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            constraintFields: {}\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            constraintFields: [null]\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            constraintFields: ['name', undefined]\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            constraintFields: ['']\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            constraintFields: []\n          }\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            constraintFields: ['name']\n          }\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if a classConfig has invalid type.sortFields settings","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":484,"updatePoint":{"line":484,"column":74,"index":16768},"code":"    it('should throw if a classConfig has invalid type.sortFields settings', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            sortFields: {}\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            sortFields: [null]\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            sortFields: [{\n              field: undefined,\n              asc: true,\n              desc: true\n            }]\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            sortFields: [{\n              field: '',\n              asc: true,\n              desc: false\n            }]\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            sortFields: [{\n              field: 'name',\n              asc: true,\n              desc: 'false'\n            }]\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            sortFields: [{\n              field: 'name',\n              asc: true,\n              desc: true\n            }, null]\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            sortFields: []\n          }\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            sortFields: [{\n              field: 'name',\n              asc: true,\n              desc: true\n            }]\n          }\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if a classConfig has invalid query params","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":573,"updatePoint":{"line":573,"column":62,"index":19189},"code":"    it('should throw if a classConfig has invalid query params', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          query: []\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          query: {\n            invalidKey: true\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          query: {\n            get: 1\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          query: {\n            find: 'true'\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          query: {\n            get: false,\n            find: true\n          }\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          query: {}\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if a classConfig has invalid mutation params","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":623,"updatePoint":{"line":623,"column":65,"index":20648},"code":"    it('should throw if a classConfig has invalid mutation params', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          mutation: []\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          mutation: {\n            invalidKey: true\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          mutation: {\n            destroy: 1\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          mutation: {\n            update: 'true'\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          mutation: {}\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          mutation: {\n            create: true,\n            update: true,\n            destroy: false\n          }\n        }]\n      })).toBeResolvedTo(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if _User create fields is missing username or password","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":674,"updatePoint":{"line":674,"column":75,"index":22173},"code":"    it('should throw if _User create fields is missing username or password', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            inputFields: {\n              create: ['username', 'no-password']\n            }\n          }\n        }]\n      })).toBeRejected();\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: '_User',\n          type: {\n            inputFields: {\n              create: ['username', 'password']\n            }\n          }\n        }]\n      })).toBeResolved(successfulUpdateResponse);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should update the cache if mounted","suites":["ParseGraphQLController","updateGraphQLConfig"],"line":699,"updatePoint":{"line":699,"column":42,"index":22916},"code":"    it('should update the cache if mounted', async () => {\n      removeConfigFromDb();\n      cacheController.graphQL.clear();\n      const mountedController = new ParseGraphQLController({\n        databaseController,\n        cacheController,\n        mountGraphQL: true\n      });\n      const unmountedController = new ParseGraphQLController({\n        databaseController,\n        cacheController,\n        mountGraphQL: false\n      });\n      let cacheBeforeValue;\n      let cacheAfterValue;\n      cacheBeforeValue = await cacheController.graphQL.get(mountedController.configCacheKey);\n      expect(cacheBeforeValue).toBeNull();\n      await mountedController.updateGraphQLConfig({\n        enabledForClasses: ['SuperCar']\n      });\n      cacheAfterValue = await cacheController.graphQL.get(mountedController.configCacheKey);\n      expect(cacheAfterValue).toEqual({\n        enabledForClasses: ['SuperCar']\n      });\n\n      // reset\n      removeConfigFromDb();\n      cacheController.graphQL.clear();\n      cacheBeforeValue = await cacheController.graphQL.get(unmountedController.configCacheKey);\n      expect(cacheBeforeValue).toBeNull();\n      await unmountedController.updateGraphQLConfig({\n        enabledForClasses: ['SuperCar']\n      });\n      cacheAfterValue = await cacheController.graphQL.get(unmountedController.configCacheKey);\n      expect(cacheAfterValue).toBeNull();\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if query alias is not a string","suites":["ParseGraphQLController","alias"],"line":737,"updatePoint":{"line":737,"column":50,"index":24337},"code":"    it('should fail if query alias is not a string', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      const className = 'Bar';\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className,\n          query: {\n            get: true,\n            getAlias: 1\n          }\n        }]\n      })).toBeRejected(`Invalid graphQLConfig: classConfig:${className} is invalid because \"query.getAlias\" must be a string`);\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className,\n          query: {\n            find: true,\n            findAlias: {\n              not: 'valid'\n            }\n          }\n        }]\n      })).toBeRejected(`Invalid graphQLConfig: classConfig:${className} is invalid because \"query.findAlias\" must be a string`);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if mutation alias is not a string","suites":["ParseGraphQLController","alias"],"line":763,"updatePoint":{"line":763,"column":53,"index":25245},"code":"    it('should fail if mutation alias is not a string', async () => {\n      const parseGraphQLController = new ParseGraphQLController({\n        databaseController\n      });\n      const className = 'Bar';\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className,\n          mutation: {\n            create: true,\n            createAlias: true\n          }\n        }]\n      })).toBeRejected(`Invalid graphQLConfig: classConfig:${className} is invalid because \"mutation.createAlias\" must be a string`);\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className,\n          mutation: {\n            update: true,\n            updateAlias: 1\n          }\n        }]\n      })).toBeRejected(`Invalid graphQLConfig: classConfig:${className} is invalid because \"mutation.updateAlias\" must be a string`);\n      expectAsync(parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className,\n          mutation: {\n            destroy: true,\n            destroyAlias: {\n              not: 'valid'\n            }\n          }\n        }]\n      })).toBeRejected(`Invalid graphQLConfig: classConfig:${className} is invalid because \"mutation.destroyAlias\" must be a string`);\n    });","file":"ParseGraphQLController.spec.js","skipped":false,"dir":"spec"},{"name":"should require a parseGraphQLController, databaseController, a log instance, and the appId","suites":["ParseGraphQLSchema","constructor"],"line":26,"updatePoint":{"line":26,"column":98,"index":857},"code":"    it('should require a parseGraphQLController, databaseController, a log instance, and the appId', () => {\n      expect(() => new ParseGraphQLSchema()).toThrow('You must provide a parseGraphQLController instance!');\n      expect(() => new ParseGraphQLSchema({\n        parseGraphQLController: {}\n      })).toThrow('You must provide a databaseController instance!');\n      expect(() => new ParseGraphQLSchema({\n        parseGraphQLController: {},\n        databaseController: {}\n      })).toThrow('You must provide a log instance!');\n      expect(() => new ParseGraphQLSchema({\n        parseGraphQLController: {},\n        databaseController: {},\n        log: {}\n      })).toThrow('You must provide the appId!');\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should cache schema","suites":["ParseGraphQLSchema","load"],"line":43,"updatePoint":{"line":43,"column":27,"index":1538},"code":"    it('should cache schema', async () => {\n      const graphQLSchema = await parseGraphQLSchema.load();\n      const updatedGraphQLSchema = await parseGraphQLSchema.load();\n      expect(graphQLSchema).toBe(updatedGraphQLSchema);\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should load a brand new GraphQL Schema if Parse Schema changes","suites":["ParseGraphQLSchema","load"],"line":48,"updatePoint":{"line":48,"column":70,"index":1818},"code":"    it('should load a brand new GraphQL Schema if Parse Schema changes', async () => {\n      await parseGraphQLSchema.load();\n      const parseClasses = parseGraphQLSchema.parseClasses;\n      const parseClassTypes = parseGraphQLSchema.parseClassTypes;\n      const graphQLSchema = parseGraphQLSchema.graphQLSchema;\n      const graphQLTypes = parseGraphQLSchema.graphQLTypes;\n      const graphQLQueries = parseGraphQLSchema.graphQLQueries;\n      const graphQLMutations = parseGraphQLSchema.graphQLMutations;\n      const graphQLSubscriptions = parseGraphQLSchema.graphQLSubscriptions;\n      const newClassObject = new Parse.Object('NewClass');\n      await newClassObject.save();\n      await parseServer.config.schemaCache.clear();\n      await new Promise(resolve => setTimeout(resolve, 200));\n      await parseGraphQLSchema.load();\n      expect(parseClasses).not.toBe(parseGraphQLSchema.parseClasses);\n      expect(parseClassTypes).not.toBe(parseGraphQLSchema.parseClassTypes);\n      expect(graphQLSchema).not.toBe(parseGraphQLSchema.graphQLSchema);\n      expect(graphQLTypes).not.toBe(parseGraphQLSchema.graphQLTypes);\n      expect(graphQLQueries).not.toBe(parseGraphQLSchema.graphQLQueries);\n      expect(graphQLMutations).not.toBe(parseGraphQLSchema.graphQLMutations);\n      expect(graphQLSubscriptions).not.toBe(parseGraphQLSchema.graphQLSubscriptions);\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should load a brand new GraphQL Schema if graphQLConfig changes","suites":["ParseGraphQLSchema","load"],"line":70,"updatePoint":{"line":70,"column":71,"index":3182},"code":"    it('should load a brand new GraphQL Schema if graphQLConfig changes', async () => {\n      const parseGraphQLController = {\n        graphQLConfig: {\n          enabledForClasses: []\n        },\n        getGraphQLConfig() {\n          return this.graphQLConfig;\n        }\n      };\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: defaultLogger,\n        appId\n      });\n      await parseGraphQLSchema.load();\n      const parseClasses = parseGraphQLSchema.parseClasses;\n      const parseClassTypes = parseGraphQLSchema.parseClassTypes;\n      const graphQLSchema = parseGraphQLSchema.graphQLSchema;\n      const graphQLTypes = parseGraphQLSchema.graphQLTypes;\n      const graphQLQueries = parseGraphQLSchema.graphQLQueries;\n      const graphQLMutations = parseGraphQLSchema.graphQLMutations;\n      const graphQLSubscriptions = parseGraphQLSchema.graphQLSubscriptions;\n      parseGraphQLController.graphQLConfig = {\n        enabledForClasses: ['_User']\n      };\n      await new Promise(resolve => setTimeout(resolve, 200));\n      await parseGraphQLSchema.load();\n      expect(parseClasses).not.toBe(parseGraphQLSchema.parseClasses);\n      expect(parseClassTypes).not.toBe(parseGraphQLSchema.parseClassTypes);\n      expect(graphQLSchema).not.toBe(parseGraphQLSchema.graphQLSchema);\n      expect(graphQLTypes).not.toBe(parseGraphQLSchema.graphQLTypes);\n      expect(graphQLQueries).not.toBe(parseGraphQLSchema.graphQLQueries);\n      expect(graphQLMutations).not.toBe(parseGraphQLSchema.graphQLMutations);\n      expect(graphQLSubscriptions).not.toBe(parseGraphQLSchema.graphQLSubscriptions);\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should not load and warn duplicated types","suites":["ParseGraphQLSchema","addGraphQLType"],"line":108,"updatePoint":{"line":108,"column":49,"index":4876},"code":"    it('should not load and warn duplicated types', async () => {\n      let logged = false;\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: message => {\n            logged = true;\n            expect(message).toEqual('Type SomeClass could not be added to the auto schema because it collided with an existing type.');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      const type = new GraphQLObjectType({\n        name: 'SomeClass'\n      });\n      expect(parseGraphQLSchema.addGraphQLType(type)).toBe(type);\n      expect(parseGraphQLSchema.graphQLTypes).toContain(type);\n      expect(parseGraphQLSchema.addGraphQLType(new GraphQLObjectType({\n        name: 'SomeClass'\n      }))).toBeUndefined();\n      expect(logged).toBeTruthy();\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error when required","suites":["ParseGraphQLSchema","addGraphQLType"],"line":132,"updatePoint":{"line":132,"column":40,"index":5746},"code":"    it('should throw error when required', async () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: () => {\n            fail('Should not warn');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      const type = new GraphQLObjectType({\n        name: 'SomeClass'\n      });\n      expect(parseGraphQLSchema.addGraphQLType(type, true)).toBe(type);\n      expect(parseGraphQLSchema.graphQLTypes).toContain(type);\n      expect(() => parseGraphQLSchema.addGraphQLType(new GraphQLObjectType({\n        name: 'SomeClass'\n      }), true)).toThrowError('Type SomeClass could not be added to the auto schema because it collided with an existing type.');\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should warn reserved name collision","suites":["ParseGraphQLSchema","addGraphQLType"],"line":153,"updatePoint":{"line":153,"column":43,"index":6541},"code":"    it('should warn reserved name collision', async () => {\n      let logged = false;\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: message => {\n            logged = true;\n            expect(message).toEqual('Type String could not be added to the auto schema because it collided with an existing type.');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      expect(parseGraphQLSchema.addGraphQLType(new GraphQLObjectType({\n        name: 'String'\n      }))).toBeUndefined();\n      expect(logged).toBeTruthy();\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should ignore collision when necessary","suites":["ParseGraphQLSchema","addGraphQLType"],"line":172,"updatePoint":{"line":172,"column":46,"index":7203},"code":"    it('should ignore collision when necessary', async () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: () => {\n            fail('Should not warn');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      const type = new GraphQLObjectType({\n        name: 'String'\n      });\n      expect(parseGraphQLSchema.addGraphQLType(type, true, true)).toBe(type);\n      expect(parseGraphQLSchema.graphQLTypes).toContain(type);\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should not load and warn duplicated queries","suites":["ParseGraphQLSchema","addGraphQLQuery"],"line":192,"updatePoint":{"line":192,"column":51,"index":7820},"code":"    it('should not load and warn duplicated queries', async () => {\n      let logged = false;\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: message => {\n            logged = true;\n            expect(message).toEqual('Query someClasses could not be added to the auto schema because it collided with an existing field.');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      const field = {};\n      expect(parseGraphQLSchema.addGraphQLQuery('someClasses', field)).toBe(field);\n      expect(parseGraphQLSchema.graphQLQueries['someClasses']).toBe(field);\n      expect(parseGraphQLSchema.addGraphQLQuery('someClasses', {})).toBeUndefined();\n      expect(logged).toBeTruthy();\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error when required","suites":["ParseGraphQLSchema","addGraphQLQuery"],"line":212,"updatePoint":{"line":212,"column":40,"index":8630},"code":"    it('should throw error when required', async () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: () => {\n            fail('Should not warn');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      const field = {};\n      expect(parseGraphQLSchema.addGraphQLQuery('someClasses', field)).toBe(field);\n      expect(parseGraphQLSchema.graphQLQueries['someClasses']).toBe(field);\n      expect(() => parseGraphQLSchema.addGraphQLQuery('someClasses', {}, true)).toThrowError('Query someClasses could not be added to the auto schema because it collided with an existing field.');\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should warn reserved name collision","suites":["ParseGraphQLSchema","addGraphQLQuery"],"line":229,"updatePoint":{"line":229,"column":43,"index":9359},"code":"    it('should warn reserved name collision', async () => {\n      let logged = false;\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: message => {\n            logged = true;\n            expect(message).toEqual('Query viewer could not be added to the auto schema because it collided with an existing field.');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      expect(parseGraphQLSchema.addGraphQLQuery('viewer', {})).toBeUndefined();\n      expect(logged).toBeTruthy();\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should ignore collision when necessary","suites":["ParseGraphQLSchema","addGraphQLQuery"],"line":246,"updatePoint":{"line":246,"column":46,"index":9981},"code":"    it('should ignore collision when necessary', async () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: () => {\n            fail('Should not warn');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      delete parseGraphQLSchema.graphQLQueries.viewer;\n      const field = {};\n      expect(parseGraphQLSchema.addGraphQLQuery('viewer', field, true, true)).toBe(field);\n      expect(parseGraphQLSchema.graphQLQueries['viewer']).toBe(field);\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should not load and warn duplicated mutations","suites":["ParseGraphQLSchema","addGraphQLMutation"],"line":265,"updatePoint":{"line":265,"column":53,"index":10627},"code":"    it('should not load and warn duplicated mutations', async () => {\n      let logged = false;\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: message => {\n            logged = true;\n            expect(message).toEqual('Mutation createSomeClass could not be added to the auto schema because it collided with an existing field.');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      const field = {};\n      expect(parseGraphQLSchema.addGraphQLMutation('createSomeClass', field)).toBe(field);\n      expect(parseGraphQLSchema.graphQLMutations['createSomeClass']).toBe(field);\n      expect(parseGraphQLSchema.addGraphQLMutation('createSomeClass', {})).toBeUndefined();\n      expect(logged).toBeTruthy();\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should throw error when required","suites":["ParseGraphQLSchema","addGraphQLMutation"],"line":285,"updatePoint":{"line":285,"column":40,"index":11464},"code":"    it('should throw error when required', async () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: () => {\n            fail('Should not warn');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      const field = {};\n      expect(parseGraphQLSchema.addGraphQLMutation('createSomeClass', field)).toBe(field);\n      expect(parseGraphQLSchema.graphQLMutations['createSomeClass']).toBe(field);\n      expect(() => parseGraphQLSchema.addGraphQLMutation('createSomeClass', {}, true)).toThrowError('Mutation createSomeClass could not be added to the auto schema because it collided with an existing field.');\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should warn reserved name collision","suites":["ParseGraphQLSchema","addGraphQLMutation"],"line":302,"updatePoint":{"line":302,"column":43,"index":12220},"code":"    it('should warn reserved name collision', async () => {\n      let logged = false;\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: message => {\n            logged = true;\n            expect(message).toEqual('Mutation signUp could not be added to the auto schema because it collided with an existing field.');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      expect(parseGraphQLSchema.addGraphQLMutation('signUp', {})).toBeUndefined();\n      expect(logged).toBeTruthy();\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should ignore collision when necessary","suites":["ParseGraphQLSchema","addGraphQLMutation"],"line":319,"updatePoint":{"line":319,"column":46,"index":12848},"code":"    it('should ignore collision when necessary', async () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: () => {\n            fail('Should not warn');\n          }\n        },\n        appId\n      });\n      await parseGraphQLSchema.load();\n      delete parseGraphQLSchema.graphQLMutations.signUp;\n      const field = {};\n      expect(parseGraphQLSchema.addGraphQLMutation('signUp', field, true, true)).toBe(field);\n      expect(parseGraphQLSchema.graphQLMutations['signUp']).toBe(field);\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should sort classes","suites":["ParseGraphQLSchema","_getParseClassesWithConfig"],"line":338,"updatePoint":{"line":338,"column":27,"index":13483},"code":"    it('should sort classes', () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: {\n          warn: () => {\n            fail('Should not warn');\n          }\n        },\n        appId\n      });\n      expect(parseGraphQLSchema._getParseClassesWithConfig([{\n        className: 'b'\n      }, {\n        className: '_b'\n      }, {\n        className: 'B'\n      }, {\n        className: '_B'\n      }, {\n        className: 'a'\n      }, {\n        className: '_a'\n      }, {\n        className: 'A'\n      }, {\n        className: '_A'\n      }], {\n        classConfigs: []\n      }).map(item => item[0])).toEqual([{\n        className: '_A'\n      }, {\n        className: '_B'\n      }, {\n        className: '_a'\n      }, {\n        className: '_b'\n      }, {\n        className: 'A'\n      }, {\n        className: 'B'\n      }, {\n        className: 'a'\n      }, {\n        className: 'b'\n      }]);\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should not generate duplicate types when colliding to default classes","suites":["ParseGraphQLSchema","name collision"],"line":387,"updatePoint":{"line":387,"column":77,"index":14545},"code":"    it('should not generate duplicate types when colliding to default classes', async () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: defaultLogger,\n        appId\n      });\n      await parseGraphQLSchema.schemaCache.clear();\n      const schema1 = await parseGraphQLSchema.load();\n      const types1 = parseGraphQLSchema.graphQLTypes;\n      const queries1 = parseGraphQLSchema.graphQLQueries;\n      const mutations1 = parseGraphQLSchema.graphQLMutations;\n      const user = new Parse.Object('User');\n      await user.save();\n      await parseGraphQLSchema.schemaCache.clear();\n      const schema2 = await parseGraphQLSchema.load();\n      const types2 = parseGraphQLSchema.graphQLTypes;\n      const queries2 = parseGraphQLSchema.graphQLQueries;\n      const mutations2 = parseGraphQLSchema.graphQLMutations;\n      expect(schema1).not.toBe(schema2);\n      expect(types1).not.toBe(types2);\n      expect(types1.map(type => type.name).sort()).toEqual(types2.map(type => type.name).sort());\n      expect(queries1).not.toBe(queries2);\n      expect(Object.keys(queries1).sort()).toEqual(Object.keys(queries2).sort());\n      expect(mutations1).not.toBe(mutations2);\n      expect(Object.keys(mutations1).sort()).toEqual(Object.keys(mutations2).sort());\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should not generate duplicate types when colliding the same name","suites":["ParseGraphQLSchema","name collision"],"line":414,"updatePoint":{"line":414,"column":72,"index":15880},"code":"    it('should not generate duplicate types when colliding the same name', async () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: defaultLogger,\n        appId\n      });\n      const car1 = new Parse.Object('Car');\n      await car1.save();\n      await parseGraphQLSchema.schemaCache.clear();\n      const schema1 = await parseGraphQLSchema.load();\n      const types1 = parseGraphQLSchema.graphQLTypes;\n      const queries1 = parseGraphQLSchema.graphQLQueries;\n      const mutations1 = parseGraphQLSchema.graphQLMutations;\n      const car2 = new Parse.Object('car');\n      await car2.save();\n      await parseGraphQLSchema.schemaCache.clear();\n      const schema2 = await parseGraphQLSchema.load();\n      const types2 = parseGraphQLSchema.graphQLTypes;\n      const queries2 = parseGraphQLSchema.graphQLQueries;\n      const mutations2 = parseGraphQLSchema.graphQLMutations;\n      expect(schema1).not.toBe(schema2);\n      expect(types1).not.toBe(types2);\n      expect(types1.map(type => type.name).sort()).toEqual(types2.map(type => type.name).sort());\n      expect(queries1).not.toBe(queries2);\n      expect(Object.keys(queries1).sort()).toEqual(Object.keys(queries2).sort());\n      expect(mutations1).not.toBe(mutations2);\n      expect(Object.keys(mutations1).sort()).toEqual(Object.keys(mutations2).sort());\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should not generate duplicate queries when query name collide","suites":["ParseGraphQLSchema","name collision"],"line":443,"updatePoint":{"line":443,"column":69,"index":17280},"code":"    it('should not generate duplicate queries when query name collide', async () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: defaultLogger,\n        appId\n      });\n      const car = new Parse.Object('Car');\n      await car.save();\n      await parseGraphQLSchema.schemaCache.clear();\n      const schema1 = await parseGraphQLSchema.load();\n      const queries1 = parseGraphQLSchema.graphQLQueries;\n      const mutations1 = parseGraphQLSchema.graphQLMutations;\n      const cars = new Parse.Object('cars');\n      await cars.save();\n      await parseGraphQLSchema.schemaCache.clear();\n      const schema2 = await parseGraphQLSchema.load();\n      const queries2 = parseGraphQLSchema.graphQLQueries;\n      const mutations2 = parseGraphQLSchema.graphQLMutations;\n      expect(schema1).not.toBe(schema2);\n      expect(queries1).not.toBe(queries2);\n      expect(Object.keys(queries1).sort()).toEqual(Object.keys(queries2).sort());\n      expect(mutations1).not.toBe(mutations2);\n      expect(Object.keys(mutations1).concat('createCars', 'updateCars', 'deleteCars').sort()).toEqual(Object.keys(mutations2).sort());\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"Should be able to define alias for get and find query","suites":["ParseGraphQLSchema","alias"],"line":470,"updatePoint":{"line":470,"column":61,"index":18509},"code":"    it('Should be able to define alias for get and find query', async () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: defaultLogger,\n        appId\n      });\n      await parseGraphQLSchema.parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: 'Data',\n          query: {\n            get: true,\n            getAlias: 'precious_data',\n            find: true,\n            findAlias: 'data_results'\n          }\n        }]\n      });\n      const data = new Parse.Object('Data');\n      await data.save();\n      await parseGraphQLSchema.schemaCache.clear();\n      await parseGraphQLSchema.load();\n      const queries1 = parseGraphQLSchema.graphQLQueries;\n      expect(Object.keys(queries1)).toContain('data_results');\n      expect(Object.keys(queries1)).toContain('precious_data');\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"Should be able to define alias for mutation","suites":["ParseGraphQLSchema","alias"],"line":496,"updatePoint":{"line":496,"column":51,"index":19407},"code":"    it('Should be able to define alias for mutation', async () => {\n      const parseGraphQLSchema = new ParseGraphQLSchema({\n        databaseController,\n        parseGraphQLController,\n        log: defaultLogger,\n        appId\n      });\n      await parseGraphQLSchema.parseGraphQLController.updateGraphQLConfig({\n        classConfigs: [{\n          className: 'Track',\n          mutation: {\n            create: true,\n            createAlias: 'addTrack',\n            update: true,\n            updateAlias: 'modifyTrack',\n            destroy: true,\n            destroyAlias: 'eraseTrack'\n          }\n        }]\n      });\n      const data = new Parse.Object('Track');\n      await data.save();\n      await parseGraphQLSchema.schemaCache.clear();\n      await parseGraphQLSchema.load();\n      const mutations = parseGraphQLSchema.graphQLMutations;\n      expect(Object.keys(mutations)).toContain('addTrack');\n      expect(Object.keys(mutations)).toContain('modifyTrack');\n      expect(Object.keys(mutations)).toContain('eraseTrack');\n    });","file":"ParseGraphQLSchema.spec.js","skipped":false,"dir":"spec"},{"name":"should require a parseServer instance","suites":["ParseGraphQLServer","constructor"],"line":81,"updatePoint":{"line":81,"column":45,"index":1906},"code":"    it('should require a parseServer instance', () => {\n      expect(() => new ParseGraphQLServer()).toThrow('You must provide a parseServer instance!');\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should require config.graphQLPath","suites":["ParseGraphQLServer","constructor"],"line":84,"updatePoint":{"line":84,"column":41,"index":2064},"code":"    it('should require config.graphQLPath', () => {\n      expect(() => new ParseGraphQLServer(parseServer)).toThrow('You must provide a config.graphQLPath!');\n      expect(() => new ParseGraphQLServer(parseServer, {})).toThrow('You must provide a config.graphQLPath!');\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should only require parseServer and config.graphQLPath args","suites":["ParseGraphQLServer","constructor"],"line":88,"updatePoint":{"line":88,"column":67,"index":2368},"code":"    it('should only require parseServer and config.graphQLPath args', () => {\n      let parseGraphQLServer;\n      expect(() => {\n        parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n          graphQLPath: 'graphql'\n        });\n      }).not.toThrow();\n      expect(parseGraphQLServer.parseGraphQLSchema).toBeDefined();\n      expect(parseGraphQLServer.parseGraphQLSchema.databaseController).toEqual(parseServer.config.databaseController);\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should initialize parseGraphQLSchema with a log controller","suites":["ParseGraphQLServer","constructor"],"line":98,"updatePoint":{"line":98,"column":66,"index":2826},"code":"    it('should initialize parseGraphQLSchema with a log controller', async () => {\n      const loggerAdapter = {\n        log: () => {},\n        error: () => {}\n      };\n      const parseServer = await global.reconfigureServer({\n        loggerAdapter\n      });\n      const parseGraphQLServer = new ParseGraphQLServer(parseServer, {\n        graphQLPath: 'graphql'\n      });\n      expect(parseGraphQLServer.parseGraphQLSchema.log.adapter).toBe(loggerAdapter);\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should only return new server on schema changes","suites":["ParseGraphQLServer","_getServer"],"line":113,"updatePoint":{"line":113,"column":55,"index":3319},"code":"    it('should only return new server on schema changes', async () => {\n      parseGraphQLServer.server = undefined;\n      const server1 = await parseGraphQLServer._getServer();\n      const server2 = await parseGraphQLServer._getServer();\n      expect(server1).toBe(server2);\n\n      // Trigger a schema change\n      const obj = new Parse.Object('SomeClass');\n      await obj.save();\n      const server3 = await parseGraphQLServer._getServer();\n      const server4 = await parseGraphQLServer._getServer();\n      expect(server3).not.toBe(server2);\n      expect(server3).toBe(server4);\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return schema and context with req's info, config and auth","suites":["ParseGraphQLServer","_getGraphQLOptions"],"line":134,"updatePoint":{"line":134,"column":73,"index":4079},"code":"    it(\"should return schema and context with req's info, config and auth\", async () => {\n      const options = await parseGraphQLServer._getGraphQLOptions();\n      expect(options.multipart).toEqual({\n        fileSize: 20971520\n      });\n      expect(options.schema).toEqual(parseGraphQLServer.parseGraphQLSchema.graphQLSchema);\n      const contextResponse = options.context({\n        req\n      });\n      expect(contextResponse.info).toEqual(req.info);\n      expect(contextResponse.config).toEqual(req.config);\n      expect(contextResponse.auth).toEqual(req.auth);\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should load GraphQL schema in every call","suites":["ParseGraphQLServer","_getGraphQLOptions"],"line":147,"updatePoint":{"line":147,"column":48,"index":4627},"code":"    it('should load GraphQL schema in every call', async () => {\n      const originalLoad = parseGraphQLServer.parseGraphQLSchema.load;\n      let counter = 0;\n      parseGraphQLServer.parseGraphQLSchema.load = () => ++counter;\n      expect((await parseGraphQLServer._getGraphQLOptions(req)).schema).toEqual(1);\n      expect((await parseGraphQLServer._getGraphQLOptions(req)).schema).toEqual(2);\n      expect((await parseGraphQLServer._getGraphQLOptions(req)).schema).toEqual(3);\n      parseGraphQLServer.parseGraphQLSchema.load = originalLoad;\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should transform to bytes","suites":["ParseGraphQLServer","_transformMaxUploadSizeToBytes"],"line":158,"updatePoint":{"line":158,"column":33,"index":5223},"code":"    it('should transform to bytes', () => {\n      expect(parseGraphQLServer._transformMaxUploadSizeToBytes('20mb')).toBe(20971520);\n      expect(parseGraphQLServer._transformMaxUploadSizeToBytes('333Gb')).toBe(357556027392);\n      expect(parseGraphQLServer._transformMaxUploadSizeToBytes('123456KB')).toBe(126418944);\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should require an Express.js app instance","suites":["ParseGraphQLServer","applyGraphQL"],"line":165,"updatePoint":{"line":165,"column":49,"index":5606},"code":"    it('should require an Express.js app instance', () => {\n      expect(() => parseGraphQLServer.applyGraphQL()).toThrow('You must provide an Express.js app instance!');\n      expect(() => parseGraphQLServer.applyGraphQL({})).toThrow('You must provide an Express.js app instance!');\n      expect(() => parseGraphQLServer.applyGraphQL(new express())).not.toThrow();\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should apply middlewares at config.graphQLPath","suites":["ParseGraphQLServer","applyGraphQL"],"line":170,"updatePoint":{"line":170,"column":54,"index":5985},"code":"    it('should apply middlewares at config.graphQLPath', () => {\n      let useCount = 0;\n      expect(() => new ParseGraphQLServer(parseServer, {\n        graphQLPath: 'somepath'\n      }).applyGraphQL({\n        use: path => {\n          useCount++;\n          expect(path).toEqual('somepath');\n        }\n      })).not.toThrow();\n      expect(useCount).toBeGreaterThan(0);\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should require an Express.js app instance","suites":["ParseGraphQLServer","applyPlayground"],"line":184,"updatePoint":{"line":184,"column":49,"index":6401},"code":"    it('should require an Express.js app instance', () => {\n      expect(() => parseGraphQLServer.applyPlayground()).toThrow('You must provide an Express.js app instance!');\n      expect(() => parseGraphQLServer.applyPlayground({})).toThrow('You must provide an Express.js app instance!');\n      expect(() => parseGraphQLServer.applyPlayground(new express())).not.toThrow();\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should require initialization with config.playgroundPath","suites":["ParseGraphQLServer","applyPlayground"],"line":189,"updatePoint":{"line":189,"column":64,"index":6799},"code":"    it('should require initialization with config.playgroundPath', () => {\n      expect(() => new ParseGraphQLServer(parseServer, {\n        graphQLPath: 'graphql'\n      }).applyPlayground(new express())).toThrow('You must provide a config.playgroundPath to applyPlayground!');\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should apply middlewares at config.playgroundPath","suites":["ParseGraphQLServer","applyPlayground"],"line":194,"updatePoint":{"line":194,"column":57,"index":7077},"code":"    it('should apply middlewares at config.playgroundPath', () => {\n      let useCount = 0;\n      expect(() => new ParseGraphQLServer(parseServer, {\n        graphQLPath: 'graphQL',\n        playgroundPath: 'somepath'\n      }).applyPlayground({\n        get: path => {\n          useCount++;\n          expect(path).toEqual('somepath');\n        }\n      })).not.toThrow();\n      expect(useCount).toBeGreaterThan(0);\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should require initialization with config.subscriptionsPath","suites":["ParseGraphQLServer","createSubscriptions"],"line":209,"updatePoint":{"line":209,"column":67,"index":7553},"code":"    it('should require initialization with config.subscriptionsPath', () => {\n      expect(() => new ParseGraphQLServer(parseServer, {\n        graphQLPath: 'graphql'\n      }).createSubscriptions({})).toThrow('You must provide a config.subscriptionsPath to createSubscriptions!');\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should pass the graphQLConfig onto the parseGraphQLController","suites":["ParseGraphQLServer","setGraphQLConfig"],"line":222,"updatePoint":{"line":222,"column":69,"index":8053},"code":"    it('should pass the graphQLConfig onto the parseGraphQLController', async () => {\n      let received;\n      parseGraphQLServer.parseGraphQLController = {\n        async updateGraphQLConfig(graphQLConfig) {\n          received = graphQLConfig;\n          return {};\n        }\n      };\n      const graphQLConfig = {\n        enabledForClasses: []\n      };\n      await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n      expect(received).toBe(graphQLConfig);\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should not absorb exceptions from parseGraphQLController","suites":["ParseGraphQLServer","setGraphQLConfig"],"line":236,"updatePoint":{"line":236,"column":64,"index":8518},"code":"    it('should not absorb exceptions from parseGraphQLController', async () => {\n      parseGraphQLServer.parseGraphQLController = {\n        async updateGraphQLConfig() {\n          throw new Error('Network request failed');\n        }\n      };\n      await expectAsync(parseGraphQLServer.setGraphQLConfig({})).toBeRejectedWith(new Error('Network request failed'));\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return the response from parseGraphQLController","suites":["ParseGraphQLServer","setGraphQLConfig"],"line":244,"updatePoint":{"line":244,"column":62,"index":8887},"code":"    it('should return the response from parseGraphQLController', async () => {\n      parseGraphQLServer.parseGraphQLController = {\n        async updateGraphQLConfig() {\n          return {\n            response: {\n              result: true\n            }\n          };\n        }\n      };\n      await expectAsync(parseGraphQLServer.setGraphQLConfig({})).toBeResolvedTo({\n        response: {\n          result: true\n        }\n      });\n    });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should be healthy","suites":["ParseGraphQLServer","Auto API","GraphQL"],"line":452,"updatePoint":{"line":452,"column":27,"index":15428},"code":"      it('should be healthy', async () => {\n        try {\n          const health = (await apolloClient.query({\n            query: gql`\n                query Health {\n                  health\n                }\n              `\n          })).data.health;\n          expect(health).toBeTruthy();\n        } catch (e) {\n          handleError(e);\n        }\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should be cors enabled and scope the response within the source origin","suites":["ParseGraphQLServer","Auto API","GraphQL"],"line":466,"updatePoint":{"line":466,"column":80,"index":15840},"code":"      it('should be cors enabled and scope the response within the source origin', async () => {\n        let checked = false;\n        const apolloClient = new ApolloClient({\n          link: new ApolloLink((operation, forward) => {\n            return forward(operation).map(response => {\n              const context = operation.getContext();\n              const {\n                response: {\n                  headers\n                }\n              } = context;\n              expect(headers.get('access-control-allow-origin')).toEqual('http://example.com');\n              checked = true;\n              return response;\n            });\n          }).concat(createHttpLink({\n            uri: 'http://localhost:13377/graphql',\n            fetch,\n            headers: {\n              ...headers,\n              Origin: 'http://example.com'\n            }\n          })),\n          cache: new InMemoryCache()\n        });\n        const healthResponse = await apolloClient.query({\n          query: gql`\n            query Health {\n              health\n            }\n          `\n        });\n        expect(healthResponse.data.health).toBeTruthy();\n        expect(checked).toBeTruthy();\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should handle Parse headers","suites":["ParseGraphQLServer","Auto API","GraphQL"],"line":501,"updatePoint":{"line":501,"column":37,"index":16980},"code":"      it('should handle Parse headers', async () => {\n        const test = {\n          context: ({\n            req: {\n              info,\n              config,\n              auth\n            }\n          }) => {\n            expect(req.info).toBeDefined();\n            expect(req.config).toBeDefined();\n            expect(req.auth).toBeDefined();\n            return {\n              info,\n              config,\n              auth\n            };\n          }\n        };\n        const contextSpy = spyOn(test, 'context');\n        const originalGetGraphQLOptions = parseGraphQLServer._getGraphQLOptions;\n        parseGraphQLServer._getGraphQLOptions = async () => {\n          return {\n            schema: await parseGraphQLServer.parseGraphQLSchema.load(),\n            context: test.context\n          };\n        };\n        const health = (await apolloClient.query({\n          query: gql`\n              query Health {\n                health\n              }\n            `\n        })).data.health;\n        expect(health).toBeTruthy();\n        expect(contextSpy).toHaveBeenCalledTimes(1);\n        parseGraphQLServer._getGraphQLOptions = originalGetGraphQLOptions;\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should mount playground","suites":["ParseGraphQLServer","Auto API","Playground"],"line":541,"updatePoint":{"line":541,"column":33,"index":18182},"code":"      it('should mount playground', async () => {\n        const res = await req({\n          method: 'GET',\n          url: 'http://localhost:13377/playground'\n        });\n        expect(res.status).toEqual(200);\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have Object scalar type","suites":["ParseGraphQLServer","Auto API","Schema","Default Types"],"line":554,"updatePoint":{"line":554,"column":42,"index":18709},"code":"        it('should have Object scalar type', async () => {\n          const objectType = (await apolloClient.query({\n            query: gql`\n                query ObjectType {\n                  __type(name: \"Object\") {\n                    kind\n                  }\n                }\n              `\n          })).data['__type'];\n          expect(objectType.kind).toEqual('SCALAR');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have Date scalar type","suites":["ParseGraphQLServer","Auto API","Schema","Default Types"],"line":566,"updatePoint":{"line":566,"column":40,"index":19099},"code":"        it('should have Date scalar type', async () => {\n          const dateType = (await apolloClient.query({\n            query: gql`\n                query DateType {\n                  __type(name: \"Date\") {\n                    kind\n                  }\n                }\n              `\n          })).data['__type'];\n          expect(dateType.kind).toEqual('SCALAR');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have ArrayResult type","suites":["ParseGraphQLServer","Auto API","Schema","Default Types"],"line":578,"updatePoint":{"line":578,"column":40,"index":19481},"code":"        it('should have ArrayResult type', async () => {\n          const arrayResultType = (await apolloClient.query({\n            query: gql`\n                query ArrayResultType {\n                  __type(name: \"ArrayResult\") {\n                    kind\n                  }\n                }\n              `\n          })).data['__type'];\n          expect(arrayResultType.kind).toEqual('UNION');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have File object type","suites":["ParseGraphQLServer","Auto API","Schema","Default Types"],"line":590,"updatePoint":{"line":590,"column":40,"index":19890},"code":"        it('should have File object type', async () => {\n          const fileType = (await apolloClient.query({\n            query: gql`\n                query FileType {\n                  __type(name: \"FileInfo\") {\n                    kind\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'];\n          expect(fileType.kind).toEqual('OBJECT');\n          expect(fileType.fields.map(field => field.name).sort()).toEqual(['name', 'url']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have Class interface type","suites":["ParseGraphQLServer","Auto API","Schema","Default Types"],"line":606,"updatePoint":{"line":606,"column":44,"index":20450},"code":"        it('should have Class interface type', async () => {\n          const classType = (await apolloClient.query({\n            query: gql`\n                query ClassType {\n                  __type(name: \"ParseObject\") {\n                    kind\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'];\n          expect(classType.kind).toEqual('INTERFACE');\n          expect(classType.fields.map(field => field.name).sort()).toEqual(['ACL', 'createdAt', 'objectId', 'updatedAt']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have ReadPreference enum type","suites":["ParseGraphQLServer","Auto API","Schema","Default Types"],"line":622,"updatePoint":{"line":622,"column":48,"index":21054},"code":"        it('should have ReadPreference enum type', async () => {\n          const readPreferenceType = (await apolloClient.query({\n            query: gql`\n                query ReadPreferenceType {\n                  __type(name: \"ReadPreference\") {\n                    kind\n                    enumValues {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'];\n          expect(readPreferenceType.kind).toEqual('ENUM');\n          expect(readPreferenceType.enumValues.map(value => value.name).sort()).toEqual(['NEAREST', 'PRIMARY', 'PRIMARY_PREFERRED', 'SECONDARY', 'SECONDARY_PREFERRED']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have GraphQLUpload object type","suites":["ParseGraphQLServer","Auto API","Schema","Default Types"],"line":638,"updatePoint":{"line":638,"column":49,"index":21735},"code":"        it('should have GraphQLUpload object type', async () => {\n          const graphQLUploadType = (await apolloClient.query({\n            query: gql`\n                query GraphQLUploadType {\n                  __type(name: \"Upload\") {\n                    kind\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'];\n          expect(graphQLUploadType.kind).toEqual('SCALAR');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have all expected types","suites":["ParseGraphQLServer","Auto API","Schema","Default Types"],"line":653,"updatePoint":{"line":653,"column":42,"index":22226},"code":"        it('should have all expected types', async () => {\n          const schemaTypes = (await apolloClient.query({\n            query: gql`\n                query SchemaTypes {\n                  __schema {\n                    types {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__schema'].types.map(type => type.name);\n          const expectedTypes = ['ParseObject', 'Date', 'FileInfo', 'ReadPreference', 'Upload'];\n          expect(expectedTypes.every(type => schemaTypes.indexOf(type) !== -1)).toBeTruthy(JSON.stringify(schemaTypes.types));\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have Node interface","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":680,"updatePoint":{"line":680,"column":38,"index":23173},"code":"        it('should have Node interface', async () => {\n          const schemaTypes = (await apolloClient.query({\n            query: gql`\n                query SchemaTypes {\n                  __schema {\n                    types {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__schema'].types.map(type => type.name);\n          expect(schemaTypes).toContain('Node');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have node query","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":694,"updatePoint":{"line":694,"column":34,"index":23624},"code":"        it('should have node query', async () => {\n          const queryFields = (await apolloClient.query({\n            query: gql`\n                query UserType {\n                  __type(name: \"Query\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name);\n          expect(queryFields).toContain('node');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return global id","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":708,"updatePoint":{"line":708,"column":35,"index":24088},"code":"        it('should return global id', async () => {\n          const userFields = (await apolloClient.query({\n            query: gql`\n                query UserType {\n                  __type(name: \"User\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name);\n          expect(userFields).toContain('id');\n          expect(userFields).toContain('objectId');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in create file input","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":723,"updatePoint":{"line":723,"column":61,"index":24625},"code":"        it('should have clientMutationId in create file input', async () => {\n          const createFileInputFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"CreateFileInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].inputFields.map(field => field.name).sort();\n          expect(createFileInputFields).toEqual(['clientMutationId', 'upload']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in create file payload","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":737,"updatePoint":{"line":737,"column":63,"index":25177},"code":"        it('should have clientMutationId in create file payload', async () => {\n          const createFilePayloadFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"CreateFilePayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name).sort();\n          expect(createFilePayloadFields).toEqual(['clientMutationId', 'fileInfo']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in call function input","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":751,"updatePoint":{"line":751,"column":63,"index":25727},"code":"        it('should have clientMutationId in call function input', async () => {\n          Parse.Cloud.define('hello', () => {});\n          const callFunctionInputFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"CallCloudCodeInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].inputFields.map(field => field.name).sort();\n          expect(callFunctionInputFields).toEqual(['clientMutationId', 'functionName', 'params']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in call function payload","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":766,"updatePoint":{"line":766,"column":65,"index":26353},"code":"        it('should have clientMutationId in call function payload', async () => {\n          Parse.Cloud.define('hello', () => {});\n          const callFunctionPayloadFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"CallCloudCodePayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name).sort();\n          expect(callFunctionPayloadFields).toEqual(['clientMutationId', 'result']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in sign up mutation input","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":781,"updatePoint":{"line":781,"column":66,"index":26960},"code":"        it('should have clientMutationId in sign up mutation input', async () => {\n          const inputFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"SignUpInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].inputFields.map(field => field.name).sort();\n          expect(inputFields).toEqual(['clientMutationId', 'fields']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in sign up mutation payload","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":795,"updatePoint":{"line":795,"column":68,"index":27493},"code":"        it('should have clientMutationId in sign up mutation payload', async () => {\n          const payloadFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"SignUpPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name).sort();\n          expect(payloadFields).toEqual(['clientMutationId', 'viewer']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in log in mutation input","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":809,"updatePoint":{"line":809,"column":65,"index":28019},"code":"        it('should have clientMutationId in log in mutation input', async () => {\n          const inputFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"LogInInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].inputFields.map(field => field.name).sort();\n          expect(inputFields).toEqual(['clientMutationId', 'password', 'username']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in log in mutation payload","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":823,"updatePoint":{"line":823,"column":67,"index":28564},"code":"        it('should have clientMutationId in log in mutation payload', async () => {\n          const payloadFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"LogInPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name).sort();\n          expect(payloadFields).toEqual(['clientMutationId', 'viewer']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in log out mutation input","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":837,"updatePoint":{"line":837,"column":66,"index":29090},"code":"        it('should have clientMutationId in log out mutation input', async () => {\n          const inputFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"LogOutInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].inputFields.map(field => field.name).sort();\n          expect(inputFields).toEqual(['clientMutationId']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in log out mutation payload","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":851,"updatePoint":{"line":851,"column":68,"index":29613},"code":"        it('should have clientMutationId in log out mutation payload', async () => {\n          const payloadFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"LogOutPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name).sort();\n          expect(payloadFields).toEqual(['clientMutationId', 'ok']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in createClass mutation input","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":865,"updatePoint":{"line":865,"column":70,"index":30140},"code":"        it('should have clientMutationId in createClass mutation input', async () => {\n          const inputFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"CreateClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].inputFields.map(field => field.name).sort();\n          expect(inputFields).toEqual(['clientMutationId', 'name', 'schemaFields']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in createClass mutation payload","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":879,"updatePoint":{"line":879,"column":72,"index":30696},"code":"        it('should have clientMutationId in createClass mutation payload', async () => {\n          const payloadFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"CreateClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name).sort();\n          expect(payloadFields).toEqual(['class', 'clientMutationId']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in updateClass mutation input","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":893,"updatePoint":{"line":893,"column":70,"index":31231},"code":"        it('should have clientMutationId in updateClass mutation input', async () => {\n          const inputFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"UpdateClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].inputFields.map(field => field.name).sort();\n          expect(inputFields).toEqual(['clientMutationId', 'name', 'schemaFields']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in updateClass mutation payload","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":907,"updatePoint":{"line":907,"column":72,"index":31787},"code":"        it('should have clientMutationId in updateClass mutation payload', async () => {\n          const payloadFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"UpdateClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name).sort();\n          expect(payloadFields).toEqual(['class', 'clientMutationId']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in deleteClass mutation input","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":921,"updatePoint":{"line":921,"column":70,"index":32322},"code":"        it('should have clientMutationId in deleteClass mutation input', async () => {\n          const inputFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"DeleteClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].inputFields.map(field => field.name).sort();\n          expect(inputFields).toEqual(['clientMutationId', 'name']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in deleteClass mutation payload","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":935,"updatePoint":{"line":935,"column":72,"index":32862},"code":"        it('should have clientMutationId in deleteClass mutation payload', async () => {\n          const payloadFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"UpdateClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name).sort();\n          expect(payloadFields).toEqual(['class', 'clientMutationId']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in custom create object mutation input","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":949,"updatePoint":{"line":949,"column":79,"index":33406},"code":"        it('should have clientMutationId in custom create object mutation input', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const createObjectInputFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"CreateSomeClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].inputFields.map(field => field.name).sort();\n          expect(createObjectInputFields).toEqual(['clientMutationId', 'fields']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in custom create object mutation payload","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":966,"updatePoint":{"line":966,"column":81,"index":34141},"code":"        it('should have clientMutationId in custom create object mutation payload', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const createObjectPayloadFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"CreateSomeClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name).sort();\n          expect(createObjectPayloadFields).toEqual(['clientMutationId', 'someClass']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in custom update object mutation input","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":983,"updatePoint":{"line":983,"column":79,"index":34873},"code":"        it('should have clientMutationId in custom update object mutation input', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const createObjectInputFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"UpdateSomeClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].inputFields.map(field => field.name).sort();\n          expect(createObjectInputFields).toEqual(['clientMutationId', 'fields', 'id']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in custom update object mutation payload","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":1000,"updatePoint":{"line":1000,"column":81,"index":35614},"code":"        it('should have clientMutationId in custom update object mutation payload', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const createObjectPayloadFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"UpdateSomeClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name).sort();\n          expect(createObjectPayloadFields).toEqual(['clientMutationId', 'someClass']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in custom delete object mutation input","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":1017,"updatePoint":{"line":1017,"column":79,"index":36346},"code":"        it('should have clientMutationId in custom delete object mutation input', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const createObjectInputFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"DeleteSomeClassInput\") {\n                    inputFields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].inputFields.map(field => field.name).sort();\n          expect(createObjectInputFields).toEqual(['clientMutationId', 'id']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have clientMutationId in custom delete object mutation payload","suites":["ParseGraphQLServer","Auto API","Schema","Relay Specific Types"],"line":1034,"updatePoint":{"line":1034,"column":81,"index":37077},"code":"        it('should have clientMutationId in custom delete object mutation payload', async () => {\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const createObjectPayloadFields = (await apolloClient.query({\n            query: gql`\n                query {\n                  __type(name: \"DeleteSomeClassPayload\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name).sort();\n          expect(createObjectPayloadFields).toEqual(['clientMutationId', 'someClass']);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have all expected types","suites":["ParseGraphQLServer","Auto API","Schema","Parse Class Types"],"line":1053,"updatePoint":{"line":1053,"column":42,"index":37826},"code":"        it('should have all expected types', async () => {\n          await parseServer.config.databaseController.loadSchema();\n          const schemaTypes = (await apolloClient.query({\n            query: gql`\n                query SchemaTypes {\n                  __schema {\n                    types {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__schema'].types.map(type => type.name);\n          const expectedTypes = ['Role', 'RoleWhereInput', 'CreateRoleFieldsInput', 'UpdateRoleFieldsInput', 'RoleConnection', 'User', 'UserWhereInput', 'UserConnection', 'CreateUserFieldsInput', 'UpdateUserFieldsInput'];\n          expect(expectedTypes.every(type => schemaTypes.indexOf(type) !== -1)).toBeTruthy(JSON.stringify(schemaTypes));\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should ArrayResult contains all types","suites":["ParseGraphQLServer","Auto API","Schema","Parse Class Types"],"line":1069,"updatePoint":{"line":1069,"column":49,"index":38654},"code":"        it('should ArrayResult contains all types', async () => {\n          const objectType = (await apolloClient.query({\n            query: gql`\n                query ObjectType {\n                  __type(name: \"ArrayResult\") {\n                    kind\n                    possibleTypes {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'];\n          const possibleTypes = objectType.possibleTypes.map(o => o.name);\n          expect(possibleTypes).toContain('User');\n          expect(possibleTypes).toContain('Role');\n          expect(possibleTypes).toContain('Element');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should update schema when it changes","suites":["ParseGraphQLServer","Auto API","Schema","Parse Class Types"],"line":1087,"updatePoint":{"line":1087,"column":48,"index":39320},"code":"        it('should update schema when it changes', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.updateClass('_User', {\n            foo: {\n              type: 'String'\n            }\n          });\n          const userFields = (await apolloClient.query({\n            query: gql`\n                query UserType {\n                  __type(name: \"User\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name);\n          expect(userFields.indexOf('foo') !== -1).toBeTruthy();\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should not contain password field from _User class","suites":["ParseGraphQLServer","Auto API","Schema","Parse Class Types"],"line":1107,"updatePoint":{"line":1107,"column":62,"index":40050},"code":"        it('should not contain password field from _User class', async () => {\n          const userFields = (await apolloClient.query({\n            query: gql`\n                query UserType {\n                  __type(name: \"User\") {\n                    fields {\n                      name\n                    }\n                  }\n                }\n              `\n          })).data['__type'].fields.map(field => field.name);\n          expect(userFields.includes('password')).toBeFalsy();\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should only include types in the enabledForClasses list","suites":["ParseGraphQLServer","Auto API","Schema","Configuration"],"line":1130,"updatePoint":{"line":1130,"column":67,"index":40977},"code":"        it('should only include types in the enabledForClasses list', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            foo: {\n              type: 'String'\n            }\n          });\n          const graphQLConfig = {\n            enabledForClasses: ['SuperCar']\n          };\n          await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n          await resetGraphQLCache();\n          const {\n            data\n          } = await apolloClient.query({\n            query: gql`\n              query UserType {\n                userType: __type(name: \"User\") {\n                  fields {\n                    name\n                  }\n                }\n                superCarType: __type(name: \"SuperCar\") {\n                  fields {\n                    name\n                  }\n                }\n              }\n            `\n          });\n          expect(data.userType).toBeNull();\n          expect(data.superCarType).toBeTruthy();\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should not include types in the disabledForClasses list","suites":["ParseGraphQLServer","Auto API","Schema","Configuration"],"line":1163,"updatePoint":{"line":1163,"column":67,"index":42060},"code":"        it('should not include types in the disabledForClasses list', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            foo: {\n              type: 'String'\n            }\n          });\n          const graphQLConfig = {\n            disabledForClasses: ['SuperCar']\n          };\n          await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n          await resetGraphQLCache();\n          const {\n            data\n          } = await apolloClient.query({\n            query: gql`\n              query UserType {\n                userType: __type(name: \"User\") {\n                  fields {\n                    name\n                  }\n                }\n                superCarType: __type(name: \"SuperCar\") {\n                  fields {\n                    name\n                  }\n                }\n              }\n            `\n          });\n          expect(data.superCarType).toBeNull();\n          expect(data.userType).toBeTruthy();\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should remove query operations when disabled","suites":["ParseGraphQLServer","Auto API","Schema","Configuration"],"line":1196,"updatePoint":{"line":1196,"column":56,"index":43133},"code":"        it('should remove query operations when disabled', async () => {\n          const superCar = new Parse.Object('SuperCar');\n          await superCar.save({\n            foo: 'bar'\n          });\n          const customer = new Parse.Object('Customer');\n          await customer.save({\n            foo: 'bar'\n          });\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                  }\n                }\n              `,\n            variables: {\n              id: superCar.id\n            }\n          })).toBeResolved();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query FindCustomer {\n                  customers {\n                    count\n                  }\n                }\n              `\n          })).toBeResolved();\n          const graphQLConfig = {\n            classConfigs: [{\n              className: 'SuperCar',\n              query: {\n                get: false,\n                find: true\n              }\n            }, {\n              className: 'Customer',\n              query: {\n                get: true,\n                find: false\n              }\n            }]\n          };\n          await parseGraphQLServer.setGraphQLConfig(graphQLConfig);\n          await resetGraphQLCache();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                  }\n                }\n              `,\n            variables: {\n              id: superCar.id\n            }\n          })).toBeRejected();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query GetCustomer($id: ID!) {\n                  customer(id: $id) {\n                    id\n                  }\n                }\n              `,\n            variables: {\n              id: customer.id\n            }\n          })).toBeResolved();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query FindSuperCar {\n                  superCars {\n                    count\n                  }\n                }\n              `\n          })).toBeResolved();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query FindCustomer {\n                  customers {\n                    count\n                  }\n                }\n              `\n          })).toBeRejected();\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should remove mutation operations, create, update and delete, when disabled","suites":["ParseGraphQLServer","Auto API","Schema","Configuration"],"line":1286,"updatePoint":{"line":1286,"column":87,"index":45728},"code":"        it('should remove mutation operations, create, update and delete, when disabled', async () => {\n          const superCar1 = new Parse.Object('SuperCar');\n          await superCar1.save({\n            foo: 'bar'\n          });\n          const customer1 = new Parse.Object('Customer');\n          await customer1.save({\n            foo: 'bar'\n          });\n          await expectAsync(apolloClient.query({\n            query: gql`\n                mutation UpdateSuperCar($id: ID!, $foo: String!) {\n                  updateSuperCar(input: { id: $id, fields: { foo: $foo } }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            variables: {\n              id: superCar1.id,\n              foo: 'lah'\n            }\n          })).toBeResolved();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                mutation DeleteCustomer($id: ID!) {\n                  deleteCustomer(input: { id: $id }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            variables: {\n              id: customer1.id\n            }\n          })).toBeResolved();\n          const {\n            data: customerData\n          } = await apolloClient.query({\n            query: gql`\n              mutation CreateCustomer($foo: String!) {\n                createCustomer(input: { fields: { foo: $foo } }) {\n                  customer {\n                    id\n                  }\n                }\n              }\n            `,\n            variables: {\n              foo: 'rah'\n            }\n          });\n          expect(customerData.createCustomer.customer).toBeTruthy();\n\n          // used later\n          const customer2Id = customerData.createCustomer.customer.id;\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [{\n              className: 'SuperCar',\n              mutation: {\n                create: true,\n                update: false,\n                destroy: true\n              }\n            }, {\n              className: 'Customer',\n              mutation: {\n                create: false,\n                update: true,\n                destroy: false\n              }\n            }]\n          });\n          await resetGraphQLCache();\n          const {\n            data: superCarData\n          } = await apolloClient.query({\n            query: gql`\n              mutation CreateSuperCar($foo: String!) {\n                createSuperCar(input: { fields: { foo: $foo } }) {\n                  superCar {\n                    id\n                  }\n                }\n              }\n            `,\n            variables: {\n              foo: 'mah'\n            }\n          });\n          expect(superCarData.createSuperCar).toBeTruthy();\n          const superCar3Id = superCarData.createSuperCar.superCar.id;\n          await expectAsync(apolloClient.query({\n            query: gql`\n                mutation UpdateSupercar($id: ID!, $foo: String!) {\n                  updateSuperCar(input: { id: $id, fields: { foo: $foo } }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            variables: {\n              id: superCar3Id\n            }\n          })).toBeRejected();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                mutation DeleteSuperCar($id: ID!) {\n                  deleteSuperCar(input: { id: $id }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            variables: {\n              id: superCar3Id\n            }\n          })).toBeResolved();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                mutation CreateCustomer($foo: String!) {\n                  createCustomer(input: { fields: { foo: $foo } }) {\n                    customer {\n                      id\n                    }\n                  }\n                }\n              `,\n            variables: {\n              foo: 'rah'\n            }\n          })).toBeRejected();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                mutation UpdateCustomer($id: ID!, $foo: String!) {\n                  updateCustomer(input: { id: $id, fields: { foo: $foo } }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            variables: {\n              id: customer2Id,\n              foo: 'tah'\n            }\n          })).toBeResolved();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                mutation DeleteCustomer($id: ID!, $foo: String!) {\n                  deleteCustomer(input: { id: $id }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            variables: {\n              id: customer2Id\n            }\n          })).toBeRejected();\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should only allow the supplied create and update fields for a class","suites":["ParseGraphQLServer","Auto API","Schema","Configuration"],"line":1440,"updatePoint":{"line":1440,"column":79,"index":50600},"code":"        it('should only allow the supplied create and update fields for a class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: {\n              type: 'String'\n            },\n            doors: {\n              type: 'Number'\n            },\n            price: {\n              type: 'String'\n            },\n            mileage: {\n              type: 'Number'\n            }\n          });\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [{\n              className: 'SuperCar',\n              type: {\n                inputFields: {\n                  create: ['engine', 'doors', 'price'],\n                  update: ['price', 'mileage']\n                }\n              }\n            }]\n          });\n          await resetGraphQLCache();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                mutation InvalidCreateSuperCar {\n                  createSuperCar(input: { fields: { engine: \"diesel\", mileage: 1000 } }) {\n                    superCar {\n                      id\n                    }\n                  }\n                }\n              `\n          })).toBeRejected();\n          const {\n            id: superCarId\n          } = (await apolloClient.query({\n            query: gql`\n                mutation ValidCreateSuperCar {\n                  createSuperCar(\n                    input: { fields: { engine: \"diesel\", doors: 5, price: \"£10000\" } }\n                  ) {\n                    superCar {\n                      id\n                    }\n                  }\n                }\n              `\n          })).data.createSuperCar.superCar;\n          expect(superCarId).toBeTruthy();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                mutation InvalidUpdateSuperCar($id: ID!) {\n                  updateSuperCar(input: { id: $id, fields: { engine: \"petrol\" } }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            variables: {\n              id: superCarId\n            }\n          })).toBeRejected();\n          const updatedSuperCar = (await apolloClient.query({\n            query: gql`\n                mutation ValidUpdateSuperCar($id: ID!) {\n                  updateSuperCar(input: { id: $id, fields: { mileage: 2000 } }) {\n                    clientMutationId\n                  }\n                }\n              `,\n            variables: {\n              id: superCarId\n            }\n          })).data.updateSuperCar;\n          expect(updatedSuperCar).toBeTruthy();\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should handle required fields from the Parse class","suites":["ParseGraphQLServer","Auto API","Schema","Configuration"],"line":1521,"updatePoint":{"line":1521,"column":62,"index":53273},"code":"        it('should handle required fields from the Parse class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: {\n              type: 'String',\n              required: true\n            },\n            doors: {\n              type: 'Number',\n              required: true\n            },\n            price: {\n              type: 'String'\n            },\n            mileage: {\n              type: 'Number'\n            }\n          });\n          await resetGraphQLCache();\n          const {\n            data: {\n              __type\n            }\n          } = await apolloClient.query({\n            query: gql`\n              query requiredFields {\n                __type(name: \"CreateSuperCarFieldsInput\") {\n                  inputFields {\n                    name\n                    type {\n                      kind\n                    }\n                  }\n                }\n              }\n            `\n          });\n          expect(__type.inputFields.find(o => o.name === 'price').type.kind).toEqual('SCALAR');\n          expect(__type.inputFields.find(o => o.name === 'engine').type.kind).toEqual('NON_NULL');\n          expect(__type.inputFields.find(o => o.name === 'doors').type.kind).toEqual('NON_NULL');\n          const {\n            data: {\n              __type: __type2\n            }\n          } = await apolloClient.query({\n            query: gql`\n              query requiredFields {\n                __type(name: \"SuperCar\") {\n                  fields {\n                    name\n                    type {\n                      kind\n                    }\n                  }\n                }\n              }\n            `\n          });\n          expect(__type2.fields.find(o => o.name === 'price').type.kind).toEqual('SCALAR');\n          expect(__type2.fields.find(o => o.name === 'engine').type.kind).toEqual('NON_NULL');\n          expect(__type2.fields.find(o => o.name === 'doors').type.kind).toEqual('NON_NULL');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should only allow the supplied output fields for a class","suites":["ParseGraphQLServer","Auto API","Schema","Configuration"],"line":1583,"updatePoint":{"line":1583,"column":68,"index":55364},"code":"        it('should only allow the supplied output fields for a class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: {\n              type: 'String'\n            },\n            doors: {\n              type: 'Number'\n            },\n            price: {\n              type: 'String'\n            },\n            mileage: {\n              type: 'Number'\n            },\n            insuranceClaims: {\n              type: 'Number'\n            }\n          });\n          const superCar = await new Parse.Object('SuperCar').save({\n            engine: 'petrol',\n            doors: 3,\n            price: '£7500',\n            mileage: 0,\n            insuranceCertificate: 'private-file.pdf'\n          });\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [{\n              className: 'SuperCar',\n              type: {\n                outputFields: ['engine', 'doors', 'price', 'mileage']\n              }\n            }]\n          });\n          await resetGraphQLCache();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                    objectId\n                    engine\n                    doors\n                    price\n                    mileage\n                    insuranceCertificate\n                  }\n                }\n              `,\n            variables: {\n              id: superCar.id\n            }\n          })).toBeRejected();\n          let getSuperCar = (await apolloClient.query({\n            query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                    objectId\n                    engine\n                    doors\n                    price\n                    mileage\n                  }\n                }\n              `,\n            variables: {\n              id: superCar.id\n            }\n          })).data.superCar;\n          expect(getSuperCar).toBeTruthy();\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [{\n              className: 'SuperCar',\n              type: {\n                outputFields: []\n              }\n            }]\n          });\n          await resetGraphQLCache();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    engine\n                  }\n                }\n              `,\n            variables: {\n              id: superCar.id\n            }\n          })).toBeRejected();\n          getSuperCar = (await apolloClient.query({\n            query: gql`\n                query GetSuperCar($id: ID!) {\n                  superCar(id: $id) {\n                    id\n                    objectId\n                  }\n                }\n              `,\n            variables: {\n              id: superCar.id\n            }\n          })).data.superCar;\n          expect(getSuperCar.objectId).toBe(superCar.id);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should only allow the supplied constraint fields for a class","suites":["ParseGraphQLServer","Auto API","Schema","Configuration"],"line":1690,"updatePoint":{"line":1690,"column":72,"index":58559},"code":"        it('should only allow the supplied constraint fields for a class', async () => {\n          try {\n            const schemaController = await parseServer.config.databaseController.loadSchema();\n            await schemaController.addClassIfNotExists('SuperCar', {\n              model: {\n                type: 'String'\n              },\n              engine: {\n                type: 'String'\n              },\n              doors: {\n                type: 'Number'\n              },\n              price: {\n                type: 'String'\n              },\n              mileage: {\n                type: 'Number'\n              },\n              insuranceCertificate: {\n                type: 'String'\n              }\n            });\n            await new Parse.Object('SuperCar').save({\n              model: 'McLaren',\n              engine: 'petrol',\n              doors: 3,\n              price: '£7500',\n              mileage: 0,\n              insuranceCertificate: 'private-file.pdf'\n            });\n            await parseGraphQLServer.setGraphQLConfig({\n              classConfigs: [{\n                className: 'SuperCar',\n                type: {\n                  constraintFields: ['engine', 'doors', 'price']\n                }\n              }]\n            });\n            await resetGraphQLCache();\n            await expectAsync(apolloClient.query({\n              query: gql`\n                  query FindSuperCar {\n                    superCars(where: { insuranceCertificate: { equalTo: \"private-file.pdf\" } }) {\n                      count\n                    }\n                  }\n                `\n            })).toBeRejected();\n            await expectAsync(apolloClient.query({\n              query: gql`\n                  query FindSuperCar {\n                    superCars(where: { mileage: { equalTo: 0 } }) {\n                      count\n                    }\n                  }\n                `\n            })).toBeRejected();\n            await expectAsync(apolloClient.query({\n              query: gql`\n                  query FindSuperCar {\n                    superCars(where: { engine: { equalTo: \"petrol\" } }) {\n                      count\n                    }\n                  }\n                `\n            })).toBeResolved();\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should only allow the supplied sort fields for a class","suites":["ParseGraphQLServer","Auto API","Schema","Configuration"],"line":1761,"updatePoint":{"line":1761,"column":66,"index":60879},"code":"        it('should only allow the supplied sort fields for a class', async () => {\n          const schemaController = await parseServer.config.databaseController.loadSchema();\n          await schemaController.addClassIfNotExists('SuperCar', {\n            engine: {\n              type: 'String'\n            },\n            doors: {\n              type: 'Number'\n            },\n            price: {\n              type: 'String'\n            },\n            mileage: {\n              type: 'Number'\n            }\n          });\n          await new Parse.Object('SuperCar').save({\n            engine: 'petrol',\n            doors: 3,\n            price: '£7500',\n            mileage: 0\n          });\n          await parseGraphQLServer.setGraphQLConfig({\n            classConfigs: [{\n              className: 'SuperCar',\n              type: {\n                sortFields: [{\n                  field: 'doors',\n                  asc: true,\n                  desc: true\n                }, {\n                  field: 'price',\n                  asc: true,\n                  desc: true\n                }, {\n                  field: 'mileage',\n                  asc: true,\n                  desc: false\n                }]\n              }\n            }]\n          });\n          await resetGraphQLCache();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query FindSuperCar {\n                  superCars(order: [engine_ASC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `\n          })).toBeRejected();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query FindSuperCar {\n                  superCars(order: [engine_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `\n          })).toBeRejected();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query FindSuperCar {\n                  superCars(order: [mileage_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `\n          })).toBeRejected();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query FindSuperCar {\n                  superCars(order: [mileage_ASC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `\n          })).toBeResolved();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query FindSuperCar {\n                  superCars(order: [doors_ASC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `\n          })).toBeResolved();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query FindSuperCar {\n                  superCars(order: [price_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `\n          })).toBeResolved();\n          await expectAsync(apolloClient.query({\n            query: gql`\n                query FindSuperCar {\n                  superCars(order: [price_ASC, doors_DESC]) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `\n          })).toBeResolved();\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"Class get custom method should return valid gobal id","suites":["ParseGraphQLServer","Auto API","Schema","Relay Spec","Object Identification"],"line":1902,"updatePoint":{"line":1902,"column":66,"index":64992},"code":"          it('Class get custom method should return valid gobal id', async () => {\n            const obj = new Parse.Object('SomeClass');\n            obj.set('someField', 'some value');\n            await obj.save();\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeClass($objectId: ID!) {\n                  someClass(id: $objectId) {\n                    id\n                    objectId\n                  }\n                }\n              `,\n              variables: {\n                objectId: obj.id\n              }\n            });\n            expect(getResult.data.someClass.objectId).toBe(obj.id);\n            const nodeResult = await apolloClient.query({\n              query: gql`\n                query Node($id: ID!) {\n                  node(id: $id) {\n                    id\n                    ... on SomeClass {\n                      objectId\n                      someField\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: getResult.data.someClass.id\n              }\n            });\n            expect(nodeResult.data.node.id).toBe(getResult.data.someClass.id);\n            expect(nodeResult.data.node.objectId).toBe(obj.id);\n            expect(nodeResult.data.node.someField).toBe('some value');\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"Class find custom method should return valid gobal id","suites":["ParseGraphQLServer","Auto API","Schema","Relay Spec","Object Identification"],"line":1940,"updatePoint":{"line":1940,"column":67,"index":66351},"code":"          it('Class find custom method should return valid gobal id', async () => {\n            const obj1 = new Parse.Object('SomeClass');\n            obj1.set('someField', 'some value 1');\n            await obj1.save();\n            const obj2 = new Parse.Object('SomeClass');\n            obj2.set('someField', 'some value 2');\n            await obj2.save();\n            const findResult = await apolloClient.query({\n              query: gql`\n                query FindSomeClass {\n                  someClasses(order: [createdAt_ASC]) {\n                    edges {\n                      node {\n                        id\n                        objectId\n                      }\n                    }\n                  }\n                }\n              `\n            });\n            expect(findResult.data.someClasses.edges[0].node.objectId).toBe(obj1.id);\n            expect(findResult.data.someClasses.edges[1].node.objectId).toBe(obj2.id);\n            const nodeResult = await apolloClient.query({\n              query: gql`\n                query Node($id1: ID!, $id2: ID!) {\n                  node1: node(id: $id1) {\n                    id\n                    ... on SomeClass {\n                      objectId\n                      someField\n                    }\n                  }\n                  node2: node(id: $id2) {\n                    id\n                    ... on SomeClass {\n                      objectId\n                      someField\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id1: findResult.data.someClasses.edges[0].node.id,\n                id2: findResult.data.someClasses.edges[1].node.id\n              }\n            });\n            expect(nodeResult.data.node1.id).toBe(findResult.data.someClasses.edges[0].node.id);\n            expect(nodeResult.data.node1.objectId).toBe(obj1.id);\n            expect(nodeResult.data.node1.someField).toBe('some value 1');\n            expect(nodeResult.data.node2.id).toBe(findResult.data.someClasses.edges[1].node.id);\n            expect(nodeResult.data.node2.objectId).toBe(obj2.id);\n            expect(nodeResult.data.node2.someField).toBe('some value 2');\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"Id inputs should work either with global id or object id","suites":["ParseGraphQLServer","Auto API","Schema","Relay Spec","Object Identification"],"line":1994,"updatePoint":{"line":1994,"column":70,"index":68565},"code":"          it('Id inputs should work either with global id or object id', async () => {\n            try {\n              await apolloClient.mutate({\n                mutation: gql`\n                  mutation CreateClasses {\n                    secondaryObject: createClass(\n                      input: {\n                        name: \"SecondaryObject\"\n                        schemaFields: { addStrings: [{ name: \"someField\" }] }\n                      }\n                    ) {\n                      clientMutationId\n                    }\n                    primaryObject: createClass(\n                      input: {\n                        name: \"PrimaryObject\"\n                        schemaFields: {\n                          addStrings: [{ name: \"stringField\" }]\n                          addArrays: [{ name: \"arrayField\" }]\n                          addPointers: [\n                            { name: \"pointerField\", targetClassName: \"SecondaryObject\" }\n                          ]\n                          addRelations: [\n                            { name: \"relationField\", targetClassName: \"SecondaryObject\" }\n                          ]\n                        }\n                      }\n                    ) {\n                      clientMutationId\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              await resetGraphQLCache();\n              const createSecondaryObjectsResult = await apolloClient.mutate({\n                mutation: gql`\n                  mutation CreateSecondaryObjects {\n                    secondaryObject1: createSecondaryObject(\n                      input: { fields: { someField: \"some value 1\" } }\n                    ) {\n                      secondaryObject {\n                        id\n                        objectId\n                        someField\n                      }\n                    }\n                    secondaryObject2: createSecondaryObject(\n                      input: { fields: { someField: \"some value 2\" } }\n                    ) {\n                      secondaryObject {\n                        id\n                        someField\n                      }\n                    }\n                    secondaryObject3: createSecondaryObject(\n                      input: { fields: { someField: \"some value 3\" } }\n                    ) {\n                      secondaryObject {\n                        objectId\n                        someField\n                      }\n                    }\n                    secondaryObject4: createSecondaryObject(\n                      input: { fields: { someField: \"some value 4\" } }\n                    ) {\n                      secondaryObject {\n                        id\n                        objectId\n                      }\n                    }\n                    secondaryObject5: createSecondaryObject(\n                      input: { fields: { someField: \"some value 5\" } }\n                    ) {\n                      secondaryObject {\n                        id\n                      }\n                    }\n                    secondaryObject6: createSecondaryObject(\n                      input: { fields: { someField: \"some value 6\" } }\n                    ) {\n                      secondaryObject {\n                        objectId\n                      }\n                    }\n                    secondaryObject7: createSecondaryObject(\n                      input: { fields: { someField: \"some value 7\" } }\n                    ) {\n                      secondaryObject {\n                        someField\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              const updateSecondaryObjectsResult = await apolloClient.mutate({\n                mutation: gql`\n                  mutation UpdateSecondaryObjects(\n                    $id1: ID!\n                    $id2: ID!\n                    $id3: ID!\n                    $id4: ID!\n                    $id5: ID!\n                    $id6: ID!\n                  ) {\n                    secondaryObject1: updateSecondaryObject(\n                      input: { id: $id1, fields: { someField: \"some value 11\" } }\n                    ) {\n                      secondaryObject {\n                        id\n                        objectId\n                        someField\n                      }\n                    }\n                    secondaryObject2: updateSecondaryObject(\n                      input: { id: $id2, fields: { someField: \"some value 22\" } }\n                    ) {\n                      secondaryObject {\n                        id\n                        someField\n                      }\n                    }\n                    secondaryObject3: updateSecondaryObject(\n                      input: { id: $id3, fields: { someField: \"some value 33\" } }\n                    ) {\n                      secondaryObject {\n                        objectId\n                        someField\n                      }\n                    }\n                    secondaryObject4: updateSecondaryObject(\n                      input: { id: $id4, fields: { someField: \"some value 44\" } }\n                    ) {\n                      secondaryObject {\n                        id\n                        objectId\n                      }\n                    }\n                    secondaryObject5: updateSecondaryObject(\n                      input: { id: $id5, fields: { someField: \"some value 55\" } }\n                    ) {\n                      secondaryObject {\n                        id\n                      }\n                    }\n                    secondaryObject6: updateSecondaryObject(\n                      input: { id: $id6, fields: { someField: \"some value 66\" } }\n                    ) {\n                      secondaryObject {\n                        objectId\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id1: createSecondaryObjectsResult.data.secondaryObject1.secondaryObject.id,\n                  id2: createSecondaryObjectsResult.data.secondaryObject2.secondaryObject.id,\n                  id3: createSecondaryObjectsResult.data.secondaryObject3.secondaryObject.objectId,\n                  id4: createSecondaryObjectsResult.data.secondaryObject4.secondaryObject.objectId,\n                  id5: createSecondaryObjectsResult.data.secondaryObject5.secondaryObject.id,\n                  id6: createSecondaryObjectsResult.data.secondaryObject6.secondaryObject.objectId\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              const deleteSecondaryObjectsResult = await apolloClient.mutate({\n                mutation: gql`\n                  mutation DeleteSecondaryObjects($id1: ID!, $id3: ID!, $id5: ID!, $id6: ID!) {\n                    secondaryObject1: deleteSecondaryObject(input: { id: $id1 }) {\n                      secondaryObject {\n                        id\n                        objectId\n                        someField\n                      }\n                    }\n                    secondaryObject3: deleteSecondaryObject(input: { id: $id3 }) {\n                      secondaryObject {\n                        objectId\n                        someField\n                      }\n                    }\n                    secondaryObject5: deleteSecondaryObject(input: { id: $id5 }) {\n                      secondaryObject {\n                        id\n                      }\n                    }\n                    secondaryObject6: deleteSecondaryObject(input: { id: $id6 }) {\n                      secondaryObject {\n                        objectId\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id1: updateSecondaryObjectsResult.data.secondaryObject1.secondaryObject.id,\n                  id3: updateSecondaryObjectsResult.data.secondaryObject3.secondaryObject.objectId,\n                  id5: updateSecondaryObjectsResult.data.secondaryObject5.secondaryObject.id,\n                  id6: updateSecondaryObjectsResult.data.secondaryObject6.secondaryObject.objectId\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              const getSecondaryObjectsResult = await apolloClient.query({\n                query: gql`\n                  query GetSecondaryObjects($id2: ID!, $id4: ID!) {\n                    secondaryObject2: secondaryObject(id: $id2) {\n                      id\n                      objectId\n                      someField\n                    }\n                    secondaryObject4: secondaryObject(id: $id4) {\n                      objectId\n                      someField\n                    }\n                  }\n                `,\n                variables: {\n                  id2: updateSecondaryObjectsResult.data.secondaryObject2.secondaryObject.id,\n                  id4: updateSecondaryObjectsResult.data.secondaryObject4.secondaryObject.objectId\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              const findSecondaryObjectsResult = await apolloClient.query({\n                query: gql`\n                  query FindSecondaryObjects(\n                    $id1: ID!\n                    $id2: ID!\n                    $id3: ID!\n                    $id4: ID!\n                    $id5: ID!\n                    $id6: ID!\n                  ) {\n                    secondaryObjects(\n                      where: {\n                        AND: [\n                          {\n                            OR: [\n                              { id: { equalTo: $id2 } }\n                              { AND: [{ id: { equalTo: $id4 } }, { objectId: { equalTo: $id4 } }] }\n                            ]\n                          }\n                          { id: { notEqualTo: $id1 } }\n                          { id: { notEqualTo: $id3 } }\n                          { objectId: { notEqualTo: $id2 } }\n                          { objectId: { notIn: [$id5, $id6] } }\n                          { id: { in: [$id2, $id4] } }\n                        ]\n                      }\n                      order: [id_ASC, objectId_ASC]\n                    ) {\n                      edges {\n                        node {\n                          id\n                          objectId\n                          someField\n                        }\n                      }\n                      count\n                    }\n                  }\n                `,\n                variables: {\n                  id1: deleteSecondaryObjectsResult.data.secondaryObject1.secondaryObject.objectId,\n                  id2: getSecondaryObjectsResult.data.secondaryObject2.id,\n                  id3: deleteSecondaryObjectsResult.data.secondaryObject3.secondaryObject.objectId,\n                  id4: getSecondaryObjectsResult.data.secondaryObject4.objectId,\n                  id5: deleteSecondaryObjectsResult.data.secondaryObject5.secondaryObject.id,\n                  id6: deleteSecondaryObjectsResult.data.secondaryObject6.secondaryObject.objectId\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              expect(findSecondaryObjectsResult.data.secondaryObjects.count).toEqual(2);\n              expect(findSecondaryObjectsResult.data.secondaryObjects.edges.map(value => value.node.someField).sort()).toEqual(['some value 22', 'some value 44']);\n              // NOTE: Here @davimacedo tried to test RelayID order, but the test is wrong since\n              // \"objectId1\" < \"objectId2\" do not always keep the order when objectId is transformed\n              // to base64 by Relay\n              // \"SecondaryObject:bBRgmzIRRM\" < \"SecondaryObject:nTMcuVbATY\" true\n              // base64(\"SecondaryObject:bBRgmzIRRM\"\") < base64(\"\"SecondaryObject:nTMcuVbATY\"\") false\n              // \"U2Vjb25kYXJ5T2JqZWN0OmJCUmdteklSUk0=\" < \"U2Vjb25kYXJ5T2JqZWN0Om5UTWN1VmJBVFk=\" false\n              const originalIds = [getSecondaryObjectsResult.data.secondaryObject2.objectId, getSecondaryObjectsResult.data.secondaryObject4.objectId];\n              expect(findSecondaryObjectsResult.data.secondaryObjects.edges[0].node.objectId).not.toBe(findSecondaryObjectsResult.data.secondaryObjects.edges[1].node.objectId);\n              expect(originalIds.includes(findSecondaryObjectsResult.data.secondaryObjects.edges[0].node.objectId)).toBeTrue();\n              expect(originalIds.includes(findSecondaryObjectsResult.data.secondaryObjects.edges[1].node.objectId)).toBeTrue();\n              const createPrimaryObjectResult = await apolloClient.mutate({\n                mutation: gql`\n                  mutation CreatePrimaryObject(\n                    $pointer: Any\n                    $secondaryObject2: ID!\n                    $secondaryObject4: ID!\n                  ) {\n                    createPrimaryObject(\n                      input: {\n                        fields: {\n                          stringField: \"some value\"\n                          arrayField: [1, \"abc\", $pointer]\n                          pointerField: { link: $secondaryObject2 }\n                          relationField: { add: [$secondaryObject2, $secondaryObject4] }\n                        }\n                      }\n                    ) {\n                      primaryObject {\n                        id\n                        stringField\n                        arrayField {\n                          ... on Element {\n                            value\n                          }\n                          ... on SecondaryObject {\n                            someField\n                          }\n                        }\n                        pointerField {\n                          id\n                          objectId\n                          someField\n                        }\n                        relationField {\n                          edges {\n                            node {\n                              id\n                              objectId\n                              someField\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  pointer: {\n                    __type: 'Pointer',\n                    className: 'SecondaryObject',\n                    objectId: getSecondaryObjectsResult.data.secondaryObject4.objectId\n                  },\n                  secondaryObject2: getSecondaryObjectsResult.data.secondaryObject2.id,\n                  secondaryObject4: getSecondaryObjectsResult.data.secondaryObject4.objectId\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              const updatePrimaryObjectResult = await apolloClient.mutate({\n                mutation: gql`\n                  mutation UpdatePrimaryObject(\n                    $id: ID!\n                    $secondaryObject2: ID!\n                    $secondaryObject4: ID!\n                  ) {\n                    updatePrimaryObject(\n                      input: {\n                        id: $id\n                        fields: {\n                          pointerField: { link: $secondaryObject4 }\n                          relationField: { remove: [$secondaryObject2, $secondaryObject4] }\n                        }\n                      }\n                    ) {\n                      primaryObject {\n                        id\n                        stringField\n                        arrayField {\n                          ... on Element {\n                            value\n                          }\n                          ... on SecondaryObject {\n                            someField\n                          }\n                        }\n                        pointerField {\n                          id\n                          objectId\n                          someField\n                        }\n                        relationField {\n                          edges {\n                            node {\n                              id\n                              objectId\n                              someField\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id: createPrimaryObjectResult.data.createPrimaryObject.primaryObject.id,\n                  secondaryObject2: getSecondaryObjectsResult.data.secondaryObject2.id,\n                  secondaryObject4: getSecondaryObjectsResult.data.secondaryObject4.objectId\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              expect(createPrimaryObjectResult.data.createPrimaryObject.primaryObject.stringField).toEqual('some value');\n              expect(createPrimaryObjectResult.data.createPrimaryObject.primaryObject.arrayField).toEqual([{\n                __typename: 'Element',\n                value: 1\n              }, {\n                __typename: 'Element',\n                value: 'abc'\n              }, {\n                __typename: 'SecondaryObject',\n                someField: 'some value 44'\n              }]);\n              expect(createPrimaryObjectResult.data.createPrimaryObject.primaryObject.pointerField.someField).toEqual('some value 22');\n              expect(createPrimaryObjectResult.data.createPrimaryObject.primaryObject.relationField.edges.map(value => value.node.someField).sort()).toEqual(['some value 22', 'some value 44']);\n              expect(updatePrimaryObjectResult.data.updatePrimaryObject.primaryObject.stringField).toEqual('some value');\n              expect(updatePrimaryObjectResult.data.updatePrimaryObject.primaryObject.arrayField).toEqual([{\n                __typename: 'Element',\n                value: 1\n              }, {\n                __typename: 'Element',\n                value: 'abc'\n              }, {\n                __typename: 'SecondaryObject',\n                someField: 'some value 44'\n              }]);\n              expect(updatePrimaryObjectResult.data.updatePrimaryObject.primaryObject.pointerField.someField).toEqual('some value 44');\n              expect(updatePrimaryObjectResult.data.updatePrimaryObject.primaryObject.relationField.edges).toEqual([]);\n            } catch (e) {\n              handleError(e);\n            }\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"Id inputs should work either with global id or object id with objectId higher than 19","suites":["ParseGraphQLServer","Auto API","Schema","Relay Spec","Object Identification"],"line":2447,"updatePoint":{"line":2447,"column":99,"index":87916},"code":"          it('Id inputs should work either with global id or object id with objectId higher than 19', async () => {\n            await reconfigureServer({\n              objectIdSize: 20\n            });\n            const obj = new Parse.Object('SomeClass');\n            await obj.save({\n              name: 'aname',\n              type: 'robot'\n            });\n            const result = await apolloClient.query({\n              query: gql`\n                query getSomeClass($id: ID!) {\n                  someClass(id: $id) {\n                    objectId\n                    id\n                  }\n                }\n              `,\n              variables: {\n                id: obj.id\n              }\n            });\n            expect(result.data.someClass.objectId).toEqual(obj.id);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should create a new class","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":2474,"updatePoint":{"line":2474,"column":37,"index":88724},"code":"        it('should create a new class', async () => {\n          try {\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  class1: createClass(input: { name: \"Class1\", clientMutationId: \"cmid1\" }) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class2: createClass(\n                    input: { name: \"Class2\", schemaFields: null, clientMutationId: \"cmid2\" }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class3: createClass(\n                    input: { name: \"Class3\", schemaFields: {}, clientMutationId: \"cmid3\" }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class4: createClass(\n                    input: {\n                      name: \"Class4\"\n                      schemaFields: {\n                        addStrings: null\n                        addNumbers: null\n                        addBooleans: null\n                        addArrays: null\n                        addObjects: null\n                        addDates: null\n                        addFiles: null\n                        addGeoPoint: null\n                        addPolygons: null\n                        addBytes: null\n                        addPointers: null\n                        addRelations: null\n                      }\n                      clientMutationId: \"cmid4\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class5: createClass(\n                    input: {\n                      name: \"Class5\"\n                      schemaFields: {\n                        addStrings: []\n                        addNumbers: []\n                        addBooleans: []\n                        addArrays: []\n                        addObjects: []\n                        addDates: []\n                        addFiles: []\n                        addPolygons: []\n                        addBytes: []\n                        addPointers: []\n                        addRelations: []\n                      }\n                      clientMutationId: \"cmid5\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  class6: createClass(\n                    input: {\n                      name: \"Class6\"\n                      schemaFields: {\n                        addStrings: [\n                          { name: \"stringField1\" }\n                          { name: \"stringField2\" }\n                          { name: \"stringField3\" }\n                        ]\n                        addNumbers: [\n                          { name: \"numberField1\" }\n                          { name: \"numberField2\" }\n                          { name: \"numberField3\" }\n                        ]\n                        addBooleans: [\n                          { name: \"booleanField1\" }\n                          { name: \"booleanField2\" }\n                          { name: \"booleanField3\" }\n                        ]\n                        addArrays: [\n                          { name: \"arrayField1\" }\n                          { name: \"arrayField2\" }\n                          { name: \"arrayField3\" }\n                        ]\n                        addObjects: [\n                          { name: \"objectField1\" }\n                          { name: \"objectField2\" }\n                          { name: \"objectField3\" }\n                        ]\n                        addDates: [\n                          { name: \"dateField1\" }\n                          { name: \"dateField2\" }\n                          { name: \"dateField3\" }\n                        ]\n                        addFiles: [\n                          { name: \"fileField1\" }\n                          { name: \"fileField2\" }\n                          { name: \"fileField3\" }\n                        ]\n                        addGeoPoint: { name: \"geoPointField\" }\n                        addPolygons: [\n                          { name: \"polygonField1\" }\n                          { name: \"polygonField2\" }\n                          { name: \"polygonField3\" }\n                        ]\n                        addBytes: [\n                          { name: \"bytesField1\" }\n                          { name: \"bytesField2\" }\n                          { name: \"bytesField3\" }\n                        ]\n                        addPointers: [\n                          { name: \"pointerField1\", targetClassName: \"Class1\" }\n                          { name: \"pointerField2\", targetClassName: \"Class6\" }\n                          { name: \"pointerField3\", targetClassName: \"Class2\" }\n                        ]\n                        addRelations: [\n                          { name: \"relationField1\", targetClassName: \"Class1\" }\n                          { name: \"relationField2\", targetClassName: \"Class6\" }\n                          { name: \"relationField3\", targetClassName: \"Class2\" }\n                        ]\n                        remove: [\n                          { name: \"stringField3\" }\n                          { name: \"numberField3\" }\n                          { name: \"booleanField3\" }\n                          { name: \"arrayField3\" }\n                          { name: \"objectField3\" }\n                          { name: \"dateField3\" }\n                          { name: \"fileField3\" }\n                          { name: \"polygonField3\" }\n                          { name: \"bytesField3\" }\n                          { name: \"pointerField3\" }\n                          { name: \"relationField3\" }\n                          { name: \"doesNotExist\" }\n                        ]\n                      }\n                      clientMutationId: \"cmid6\"\n                    }\n                  ) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                        ... on SchemaPointerField {\n                          targetClassName\n                        }\n                        ... on SchemaRelationField {\n                          targetClassName\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            const classes = Object.keys(result.data).map(fieldName => ({\n              clientMutationId: result.data[fieldName].clientMutationId,\n              class: {\n                name: result.data[fieldName].class.name,\n                schemaFields: result.data[fieldName].class.schemaFields.sort((a, b) => a.name > b.name ? 1 : -1),\n                __typename: result.data[fieldName].class.__typename\n              },\n              __typename: result.data[fieldName].__typename\n            }));\n            expect(classes).toEqual([{\n              clientMutationId: 'cmid1',\n              class: {\n                name: 'Class1',\n                schemaFields: [{\n                  name: 'ACL',\n                  __typename: 'SchemaACLField'\n                }, {\n                  name: 'createdAt',\n                  __typename: 'SchemaDateField'\n                }, {\n                  name: 'objectId',\n                  __typename: 'SchemaStringField'\n                }, {\n                  name: 'updatedAt',\n                  __typename: 'SchemaDateField'\n                }],\n                __typename: 'Class'\n              },\n              __typename: 'CreateClassPayload'\n            }, {\n              clientMutationId: 'cmid2',\n              class: {\n                name: 'Class2',\n                schemaFields: [{\n                  name: 'ACL',\n                  __typename: 'SchemaACLField'\n                }, {\n                  name: 'createdAt',\n                  __typename: 'SchemaDateField'\n                }, {\n                  name: 'objectId',\n                  __typename: 'SchemaStringField'\n                }, {\n                  name: 'updatedAt',\n                  __typename: 'SchemaDateField'\n                }],\n                __typename: 'Class'\n              },\n              __typename: 'CreateClassPayload'\n            }, {\n              clientMutationId: 'cmid3',\n              class: {\n                name: 'Class3',\n                schemaFields: [{\n                  name: 'ACL',\n                  __typename: 'SchemaACLField'\n                }, {\n                  name: 'createdAt',\n                  __typename: 'SchemaDateField'\n                }, {\n                  name: 'objectId',\n                  __typename: 'SchemaStringField'\n                }, {\n                  name: 'updatedAt',\n                  __typename: 'SchemaDateField'\n                }],\n                __typename: 'Class'\n              },\n              __typename: 'CreateClassPayload'\n            }, {\n              clientMutationId: 'cmid4',\n              class: {\n                name: 'Class4',\n                schemaFields: [{\n                  name: 'ACL',\n                  __typename: 'SchemaACLField'\n                }, {\n                  name: 'createdAt',\n                  __typename: 'SchemaDateField'\n                }, {\n                  name: 'objectId',\n                  __typename: 'SchemaStringField'\n                }, {\n                  name: 'updatedAt',\n                  __typename: 'SchemaDateField'\n                }],\n                __typename: 'Class'\n              },\n              __typename: 'CreateClassPayload'\n            }, {\n              clientMutationId: 'cmid5',\n              class: {\n                name: 'Class5',\n                schemaFields: [{\n                  name: 'ACL',\n                  __typename: 'SchemaACLField'\n                }, {\n                  name: 'createdAt',\n                  __typename: 'SchemaDateField'\n                }, {\n                  name: 'objectId',\n                  __typename: 'SchemaStringField'\n                }, {\n                  name: 'updatedAt',\n                  __typename: 'SchemaDateField'\n                }],\n                __typename: 'Class'\n              },\n              __typename: 'CreateClassPayload'\n            }, {\n              clientMutationId: 'cmid6',\n              class: {\n                name: 'Class6',\n                schemaFields: [{\n                  name: 'ACL',\n                  __typename: 'SchemaACLField'\n                }, {\n                  name: 'arrayField1',\n                  __typename: 'SchemaArrayField'\n                }, {\n                  name: 'arrayField2',\n                  __typename: 'SchemaArrayField'\n                }, {\n                  name: 'booleanField1',\n                  __typename: 'SchemaBooleanField'\n                }, {\n                  name: 'booleanField2',\n                  __typename: 'SchemaBooleanField'\n                }, {\n                  name: 'bytesField1',\n                  __typename: 'SchemaBytesField'\n                }, {\n                  name: 'bytesField2',\n                  __typename: 'SchemaBytesField'\n                }, {\n                  name: 'createdAt',\n                  __typename: 'SchemaDateField'\n                }, {\n                  name: 'dateField1',\n                  __typename: 'SchemaDateField'\n                }, {\n                  name: 'dateField2',\n                  __typename: 'SchemaDateField'\n                }, {\n                  name: 'fileField1',\n                  __typename: 'SchemaFileField'\n                }, {\n                  name: 'fileField2',\n                  __typename: 'SchemaFileField'\n                }, {\n                  name: 'geoPointField',\n                  __typename: 'SchemaGeoPointField'\n                }, {\n                  name: 'numberField1',\n                  __typename: 'SchemaNumberField'\n                }, {\n                  name: 'numberField2',\n                  __typename: 'SchemaNumberField'\n                }, {\n                  name: 'objectField1',\n                  __typename: 'SchemaObjectField'\n                }, {\n                  name: 'objectField2',\n                  __typename: 'SchemaObjectField'\n                }, {\n                  name: 'objectId',\n                  __typename: 'SchemaStringField'\n                }, {\n                  name: 'pointerField1',\n                  __typename: 'SchemaPointerField',\n                  targetClassName: 'Class1'\n                }, {\n                  name: 'pointerField2',\n                  __typename: 'SchemaPointerField',\n                  targetClassName: 'Class6'\n                }, {\n                  name: 'polygonField1',\n                  __typename: 'SchemaPolygonField'\n                }, {\n                  name: 'polygonField2',\n                  __typename: 'SchemaPolygonField'\n                }, {\n                  name: 'relationField1',\n                  __typename: 'SchemaRelationField',\n                  targetClassName: 'Class1'\n                }, {\n                  name: 'relationField2',\n                  __typename: 'SchemaRelationField',\n                  targetClassName: 'Class6'\n                }, {\n                  name: 'stringField1',\n                  __typename: 'SchemaStringField'\n                }, {\n                  name: 'stringField2',\n                  __typename: 'SchemaStringField'\n                }, {\n                  name: 'updatedAt',\n                  __typename: 'SchemaDateField'\n                }],\n                __typename: 'Class'\n              },\n              __typename: 'CreateClassPayload'\n            }]);\n            const findResult = await apolloClient.query({\n              query: gql`\n                query {\n                  classes {\n                    name\n                    schemaFields {\n                      name\n                      __typename\n                      ... on SchemaPointerField {\n                        targetClassName\n                      }\n                      ... on SchemaRelationField {\n                        targetClassName\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            findResult.data.classes = findResult.data.classes.filter(schemaClass => !schemaClass.name.startsWith('_')).sort((a, b) => a.name > b.name ? 1 : -1);\n            findResult.data.classes.forEach(schemaClass => {\n              schemaClass.schemaFields = schemaClass.schemaFields.sort((a, b) => a.name > b.name ? 1 : -1);\n            });\n            expect(findResult.data.classes).toEqual([{\n              name: 'Class1',\n              schemaFields: [{\n                name: 'ACL',\n                __typename: 'SchemaACLField'\n              }, {\n                name: 'createdAt',\n                __typename: 'SchemaDateField'\n              }, {\n                name: 'objectId',\n                __typename: 'SchemaStringField'\n              }, {\n                name: 'updatedAt',\n                __typename: 'SchemaDateField'\n              }],\n              __typename: 'Class'\n            }, {\n              name: 'Class2',\n              schemaFields: [{\n                name: 'ACL',\n                __typename: 'SchemaACLField'\n              }, {\n                name: 'createdAt',\n                __typename: 'SchemaDateField'\n              }, {\n                name: 'objectId',\n                __typename: 'SchemaStringField'\n              }, {\n                name: 'updatedAt',\n                __typename: 'SchemaDateField'\n              }],\n              __typename: 'Class'\n            }, {\n              name: 'Class3',\n              schemaFields: [{\n                name: 'ACL',\n                __typename: 'SchemaACLField'\n              }, {\n                name: 'createdAt',\n                __typename: 'SchemaDateField'\n              }, {\n                name: 'objectId',\n                __typename: 'SchemaStringField'\n              }, {\n                name: 'updatedAt',\n                __typename: 'SchemaDateField'\n              }],\n              __typename: 'Class'\n            }, {\n              name: 'Class4',\n              schemaFields: [{\n                name: 'ACL',\n                __typename: 'SchemaACLField'\n              }, {\n                name: 'createdAt',\n                __typename: 'SchemaDateField'\n              }, {\n                name: 'objectId',\n                __typename: 'SchemaStringField'\n              }, {\n                name: 'updatedAt',\n                __typename: 'SchemaDateField'\n              }],\n              __typename: 'Class'\n            }, {\n              name: 'Class5',\n              schemaFields: [{\n                name: 'ACL',\n                __typename: 'SchemaACLField'\n              }, {\n                name: 'createdAt',\n                __typename: 'SchemaDateField'\n              }, {\n                name: 'objectId',\n                __typename: 'SchemaStringField'\n              }, {\n                name: 'updatedAt',\n                __typename: 'SchemaDateField'\n              }],\n              __typename: 'Class'\n            }, {\n              name: 'Class6',\n              schemaFields: [{\n                name: 'ACL',\n                __typename: 'SchemaACLField'\n              }, {\n                name: 'arrayField1',\n                __typename: 'SchemaArrayField'\n              }, {\n                name: 'arrayField2',\n                __typename: 'SchemaArrayField'\n              }, {\n                name: 'booleanField1',\n                __typename: 'SchemaBooleanField'\n              }, {\n                name: 'booleanField2',\n                __typename: 'SchemaBooleanField'\n              }, {\n                name: 'bytesField1',\n                __typename: 'SchemaBytesField'\n              }, {\n                name: 'bytesField2',\n                __typename: 'SchemaBytesField'\n              }, {\n                name: 'createdAt',\n                __typename: 'SchemaDateField'\n              }, {\n                name: 'dateField1',\n                __typename: 'SchemaDateField'\n              }, {\n                name: 'dateField2',\n                __typename: 'SchemaDateField'\n              }, {\n                name: 'fileField1',\n                __typename: 'SchemaFileField'\n              }, {\n                name: 'fileField2',\n                __typename: 'SchemaFileField'\n              }, {\n                name: 'geoPointField',\n                __typename: 'SchemaGeoPointField'\n              }, {\n                name: 'numberField1',\n                __typename: 'SchemaNumberField'\n              }, {\n                name: 'numberField2',\n                __typename: 'SchemaNumberField'\n              }, {\n                name: 'objectField1',\n                __typename: 'SchemaObjectField'\n              }, {\n                name: 'objectField2',\n                __typename: 'SchemaObjectField'\n              }, {\n                name: 'objectId',\n                __typename: 'SchemaStringField'\n              }, {\n                name: 'pointerField1',\n                __typename: 'SchemaPointerField',\n                targetClassName: 'Class1'\n              }, {\n                name: 'pointerField2',\n                __typename: 'SchemaPointerField',\n                targetClassName: 'Class6'\n              }, {\n                name: 'polygonField1',\n                __typename: 'SchemaPolygonField'\n              }, {\n                name: 'polygonField2',\n                __typename: 'SchemaPolygonField'\n              }, {\n                name: 'relationField1',\n                __typename: 'SchemaRelationField',\n                targetClassName: 'Class1'\n              }, {\n                name: 'relationField2',\n                __typename: 'SchemaRelationField',\n                targetClassName: 'Class6'\n              }, {\n                name: 'stringField1',\n                __typename: 'SchemaStringField'\n              }, {\n                name: 'stringField2',\n                __typename: 'SchemaStringField'\n              }, {\n                name: 'updatedAt',\n                __typename: 'SchemaDateField'\n              }],\n              __typename: 'Class'\n            }]);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should require master key to create a new class","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":3076,"updatePoint":{"line":3076,"column":59,"index":110334},"code":"        it('should require master key to create a new class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(Parse.Error.OPERATION_FORBIDDEN);\n            expect(e.graphQLErrors[0].message).toEqual('unauthorized: master key is required');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow duplicated field names when creating","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":3093,"updatePoint":{"line":3093,"column":65,"index":110971},"code":"        it('should not allow duplicated field names when creating', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: {\n                        addStrings: [{ name: \"someField\" }]\n                        addNumbers: [{ name: \"someField\" }]\n                      }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(Parse.Error.INVALID_KEY_NAME);\n            expect(e.graphQLErrors[0].message).toEqual('Duplicated field name: someField');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should update an existing class","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":3123,"updatePoint":{"line":3123,"column":43,"index":111977},"code":"        it('should update an existing class', async () => {\n          try {\n            const clientMutationId = uuidv4();\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"MyNewClass\"\n                      schemaFields: { addStrings: [{ name: \"willBeRemoved\" }] }\n                    }\n                  ) {\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  updateClass(input: {\n                    clientMutationId: \"${clientMutationId}\"\n                    name: \"MyNewClass\"\n                    schemaFields: {\n                      addStrings: [\n                        { name: \"stringField1\" }\n                        { name: \"stringField2\" }\n                        { name: \"stringField3\" }\n                      ]\n                      addNumbers: [\n                        { name: \"numberField1\" }\n                        { name: \"numberField2\" }\n                        { name: \"numberField3\" }\n                      ]\n                      addBooleans: [\n                        { name: \"booleanField1\" }\n                        { name: \"booleanField2\" }\n                        { name: \"booleanField3\" }\n                      ]\n                      addArrays: [\n                        { name: \"arrayField1\" }\n                        { name: \"arrayField2\" }\n                        { name: \"arrayField3\" }\n                      ]\n                      addObjects: [\n                        { name: \"objectField1\" }\n                        { name: \"objectField2\" }\n                        { name: \"objectField3\" }\n                      ]\n                      addDates: [\n                        { name: \"dateField1\" }\n                        { name: \"dateField2\" }\n                        { name: \"dateField3\" }\n                      ]\n                      addFiles: [\n                        { name: \"fileField1\" }\n                        { name: \"fileField2\" }\n                        { name: \"fileField3\" }\n                      ]\n                      addGeoPoint: { name: \"geoPointField\" }\n                      addPolygons: [\n                        { name: \"polygonField1\" }\n                        { name: \"polygonField2\" }\n                        { name: \"polygonField3\" }\n                      ]\n                      addBytes: [\n                        { name: \"bytesField1\" }\n                        { name: \"bytesField2\" }\n                        { name: \"bytesField3\" }\n                      ]\n                      addPointers: [\n                        { name: \"pointerField1\", targetClassName: \"Class1\" }\n                        { name: \"pointerField2\", targetClassName: \"Class6\" }\n                        { name: \"pointerField3\", targetClassName: \"Class2\" }\n                      ]\n                      addRelations: [\n                        { name: \"relationField1\", targetClassName: \"Class1\" }\n                        { name: \"relationField2\", targetClassName: \"Class6\" }\n                        { name: \"relationField3\", targetClassName: \"Class2\" }\n                      ]\n                      remove: [\n                        { name: \"willBeRemoved\" }\n                        { name: \"stringField3\" }\n                        { name: \"numberField3\" }\n                        { name: \"booleanField3\" }\n                        { name: \"arrayField3\" }\n                        { name: \"objectField3\" }\n                        { name: \"dateField3\" }\n                        { name: \"fileField3\" }\n                        { name: \"polygonField3\" }\n                        { name: \"bytesField3\" }\n                        { name: \"pointerField3\" }\n                        { name: \"relationField3\" }\n                        { name: \"doesNotExist\" }\n                      ]\n                    }\n                  }) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                        ... on SchemaPointerField {\n                          targetClassName\n                        }\n                        ... on SchemaRelationField {\n                          targetClassName\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            result.data.createClass.class.schemaFields = result.data.createClass.class.schemaFields.sort((a, b) => a.name > b.name ? 1 : -1);\n            result.data.updateClass.class.schemaFields = result.data.updateClass.class.schemaFields.sort((a, b) => a.name > b.name ? 1 : -1);\n            expect(result).toEqual({\n              data: {\n                createClass: {\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [{\n                      name: 'ACL',\n                      __typename: 'SchemaACLField'\n                    }, {\n                      name: 'createdAt',\n                      __typename: 'SchemaDateField'\n                    }, {\n                      name: 'objectId',\n                      __typename: 'SchemaStringField'\n                    }, {\n                      name: 'updatedAt',\n                      __typename: 'SchemaDateField'\n                    }, {\n                      name: 'willBeRemoved',\n                      __typename: 'SchemaStringField'\n                    }],\n                    __typename: 'Class'\n                  },\n                  __typename: 'CreateClassPayload'\n                },\n                updateClass: {\n                  clientMutationId,\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [{\n                      name: 'ACL',\n                      __typename: 'SchemaACLField'\n                    }, {\n                      name: 'arrayField1',\n                      __typename: 'SchemaArrayField'\n                    }, {\n                      name: 'arrayField2',\n                      __typename: 'SchemaArrayField'\n                    }, {\n                      name: 'booleanField1',\n                      __typename: 'SchemaBooleanField'\n                    }, {\n                      name: 'booleanField2',\n                      __typename: 'SchemaBooleanField'\n                    }, {\n                      name: 'bytesField1',\n                      __typename: 'SchemaBytesField'\n                    }, {\n                      name: 'bytesField2',\n                      __typename: 'SchemaBytesField'\n                    }, {\n                      name: 'createdAt',\n                      __typename: 'SchemaDateField'\n                    }, {\n                      name: 'dateField1',\n                      __typename: 'SchemaDateField'\n                    }, {\n                      name: 'dateField2',\n                      __typename: 'SchemaDateField'\n                    }, {\n                      name: 'fileField1',\n                      __typename: 'SchemaFileField'\n                    }, {\n                      name: 'fileField2',\n                      __typename: 'SchemaFileField'\n                    }, {\n                      name: 'geoPointField',\n                      __typename: 'SchemaGeoPointField'\n                    }, {\n                      name: 'numberField1',\n                      __typename: 'SchemaNumberField'\n                    }, {\n                      name: 'numberField2',\n                      __typename: 'SchemaNumberField'\n                    }, {\n                      name: 'objectField1',\n                      __typename: 'SchemaObjectField'\n                    }, {\n                      name: 'objectField2',\n                      __typename: 'SchemaObjectField'\n                    }, {\n                      name: 'objectId',\n                      __typename: 'SchemaStringField'\n                    }, {\n                      name: 'pointerField1',\n                      __typename: 'SchemaPointerField',\n                      targetClassName: 'Class1'\n                    }, {\n                      name: 'pointerField2',\n                      __typename: 'SchemaPointerField',\n                      targetClassName: 'Class6'\n                    }, {\n                      name: 'polygonField1',\n                      __typename: 'SchemaPolygonField'\n                    }, {\n                      name: 'polygonField2',\n                      __typename: 'SchemaPolygonField'\n                    }, {\n                      name: 'relationField1',\n                      __typename: 'SchemaRelationField',\n                      targetClassName: 'Class1'\n                    }, {\n                      name: 'relationField2',\n                      __typename: 'SchemaRelationField',\n                      targetClassName: 'Class6'\n                    }, {\n                      name: 'stringField1',\n                      __typename: 'SchemaStringField'\n                    }, {\n                      name: 'stringField2',\n                      __typename: 'SchemaStringField'\n                    }, {\n                      name: 'updatedAt',\n                      __typename: 'SchemaDateField'\n                    }],\n                    __typename: 'Class'\n                  },\n                  __typename: 'UpdateClassPayload'\n                }\n              }\n            });\n            const getResult = await apolloClient.query({\n              query: gql`\n                query {\n                  class(name: \"MyNewClass\") {\n                    name\n                    schemaFields {\n                      name\n                      __typename\n                      ... on SchemaPointerField {\n                        targetClassName\n                      }\n                      ... on SchemaRelationField {\n                        targetClassName\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            getResult.data.class.schemaFields = getResult.data.class.schemaFields.sort((a, b) => a.name > b.name ? 1 : -1);\n            expect(getResult.data).toEqual({\n              class: {\n                name: 'MyNewClass',\n                schemaFields: [{\n                  name: 'ACL',\n                  __typename: 'SchemaACLField'\n                }, {\n                  name: 'arrayField1',\n                  __typename: 'SchemaArrayField'\n                }, {\n                  name: 'arrayField2',\n                  __typename: 'SchemaArrayField'\n                }, {\n                  name: 'booleanField1',\n                  __typename: 'SchemaBooleanField'\n                }, {\n                  name: 'booleanField2',\n                  __typename: 'SchemaBooleanField'\n                }, {\n                  name: 'bytesField1',\n                  __typename: 'SchemaBytesField'\n                }, {\n                  name: 'bytesField2',\n                  __typename: 'SchemaBytesField'\n                }, {\n                  name: 'createdAt',\n                  __typename: 'SchemaDateField'\n                }, {\n                  name: 'dateField1',\n                  __typename: 'SchemaDateField'\n                }, {\n                  name: 'dateField2',\n                  __typename: 'SchemaDateField'\n                }, {\n                  name: 'fileField1',\n                  __typename: 'SchemaFileField'\n                }, {\n                  name: 'fileField2',\n                  __typename: 'SchemaFileField'\n                }, {\n                  name: 'geoPointField',\n                  __typename: 'SchemaGeoPointField'\n                }, {\n                  name: 'numberField1',\n                  __typename: 'SchemaNumberField'\n                }, {\n                  name: 'numberField2',\n                  __typename: 'SchemaNumberField'\n                }, {\n                  name: 'objectField1',\n                  __typename: 'SchemaObjectField'\n                }, {\n                  name: 'objectField2',\n                  __typename: 'SchemaObjectField'\n                }, {\n                  name: 'objectId',\n                  __typename: 'SchemaStringField'\n                }, {\n                  name: 'pointerField1',\n                  __typename: 'SchemaPointerField',\n                  targetClassName: 'Class1'\n                }, {\n                  name: 'pointerField2',\n                  __typename: 'SchemaPointerField',\n                  targetClassName: 'Class6'\n                }, {\n                  name: 'polygonField1',\n                  __typename: 'SchemaPolygonField'\n                }, {\n                  name: 'polygonField2',\n                  __typename: 'SchemaPolygonField'\n                }, {\n                  name: 'relationField1',\n                  __typename: 'SchemaRelationField',\n                  targetClassName: 'Class1'\n                }, {\n                  name: 'relationField2',\n                  __typename: 'SchemaRelationField',\n                  targetClassName: 'Class6'\n                }, {\n                  name: 'stringField1',\n                  __typename: 'SchemaStringField'\n                }, {\n                  name: 'stringField2',\n                  __typename: 'SchemaStringField'\n                }, {\n                  name: 'updatedAt',\n                  __typename: 'SchemaDateField'\n                }],\n                __typename: 'Class'\n              }\n            });\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should require master key to update an existing class","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":3487,"updatePoint":{"line":3487,"column":65,"index":126073},"code":"        it('should require master key to update an existing class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n          } catch (e) {\n            handleError(e);\n          }\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  updateClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(Parse.Error.OPERATION_FORBIDDEN);\n            expect(e.graphQLErrors[0].message).toEqual('unauthorized: master key is required');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow duplicated field names when updating","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":3522,"updatePoint":{"line":3522,"column":65,"index":127189},"code":"        it('should not allow duplicated field names when updating', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: { addStrings: [{ name: \"someField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n          } catch (e) {\n            handleError(e);\n          }\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  updateClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: { addNumbers: [{ name: \"someField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(Parse.Error.INVALID_KEY_NAME);\n            expect(e.graphQLErrors[0].message).toEqual('Duplicated field name: someField');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if updating an inexistent class","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":3572,"updatePoint":{"line":3572,"column":55,"index":128738},"code":"        it('should fail if updating an inexistent class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  updateClass(\n                    input: {\n                      name: \"SomeInexistentClass\"\n                      schemaFields: { addNumbers: [{ name: \"someField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n            expect(e.graphQLErrors[0].message).toEqual('Class SomeInexistentClass does not exist.');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should delete an existing class","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":3599,"updatePoint":{"line":3599,"column":43,"index":129659},"code":"        it('should delete an existing class', async () => {\n          try {\n            const clientMutationId = uuidv4();\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(\n                    input: {\n                      name: \"MyNewClass\"\n                      schemaFields: { addStrings: [{ name: \"willBeRemoved\" }] }\n                    }\n                  ) {\n                    class {\n                      name\n                      schemaFields {\n                        name\n                        __typename\n                      }\n                    }\n                  }\n                  deleteClass(input: { clientMutationId: \"${clientMutationId}\" name: \"MyNewClass\" }) {\n                    clientMutationId\n                    class {\n                      name\n                      schemaFields {\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            result.data.createClass.class.schemaFields = result.data.createClass.class.schemaFields.sort((a, b) => a.name > b.name ? 1 : -1);\n            result.data.deleteClass.class.schemaFields = result.data.deleteClass.class.schemaFields.sort((a, b) => a.name > b.name ? 1 : -1);\n            expect(result).toEqual({\n              data: {\n                createClass: {\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [{\n                      name: 'ACL',\n                      __typename: 'SchemaACLField'\n                    }, {\n                      name: 'createdAt',\n                      __typename: 'SchemaDateField'\n                    }, {\n                      name: 'objectId',\n                      __typename: 'SchemaStringField'\n                    }, {\n                      name: 'updatedAt',\n                      __typename: 'SchemaDateField'\n                    }, {\n                      name: 'willBeRemoved',\n                      __typename: 'SchemaStringField'\n                    }],\n                    __typename: 'Class'\n                  },\n                  __typename: 'CreateClassPayload'\n                },\n                deleteClass: {\n                  clientMutationId,\n                  class: {\n                    name: 'MyNewClass',\n                    schemaFields: [{\n                      name: 'ACL',\n                      __typename: 'SchemaACLField'\n                    }, {\n                      name: 'createdAt',\n                      __typename: 'SchemaDateField'\n                    }, {\n                      name: 'objectId',\n                      __typename: 'SchemaStringField'\n                    }, {\n                      name: 'updatedAt',\n                      __typename: 'SchemaDateField'\n                    }, {\n                      name: 'willBeRemoved',\n                      __typename: 'SchemaStringField'\n                    }],\n                    __typename: 'Class'\n                  },\n                  __typename: 'DeleteClassPayload'\n                }\n              }\n            });\n            try {\n              await apolloClient.query({\n                query: gql`\n                  query {\n                    class(name: \"MyNewClass\") {\n                      name\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              fail('should fail');\n            } catch (e) {\n              expect(e.graphQLErrors[0].extensions.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n              expect(e.graphQLErrors[0].message).toEqual('Class MyNewClass does not exist.');\n            }\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should require master key to delete an existing class","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":3713,"updatePoint":{"line":3713,"column":65,"index":133746},"code":"        it('should require master key to delete an existing class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  createClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n          } catch (e) {\n            handleError(e);\n          }\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  deleteClass(input: { name: \"SomeClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(Parse.Error.OPERATION_FORBIDDEN);\n            expect(e.graphQLErrors[0].message).toEqual('unauthorized: master key is required');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if deleting an inexistent class","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":3748,"updatePoint":{"line":3748,"column":55,"index":134852},"code":"        it('should fail if deleting an inexistent class', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation {\n                  deleteClass(input: { name: \"SomeInexistentClass\" }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n            expect(e.graphQLErrors[0].message).toEqual('Class SomeInexistentClass does not exist.');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should require master key to get an existing class","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":3770,"updatePoint":{"line":3770,"column":62,"index":135634},"code":"        it('should require master key to get an existing class', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query {\n                  class(name: \"_User\") {\n                    name\n                  }\n                }\n              `\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(Parse.Error.OPERATION_FORBIDDEN);\n            expect(e.graphQLErrors[0].message).toEqual('unauthorized: master key is required');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should require master key to find the existing classes","suites":["ParseGraphQLServer","Auto API","Schema","Class Schema Mutations"],"line":3787,"updatePoint":{"line":3787,"column":66,"index":136232},"code":"        it('should require master key to find the existing classes', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query {\n                  classes {\n                    name\n                  }\n                }\n              `\n            });\n            fail('should fail');\n          } catch (e) {\n            expect(e.graphQLErrors[0].extensions.code).toEqual(Parse.Error.OPERATION_FORBIDDEN);\n            expect(e.graphQLErrors[0].message).toEqual('unauthorized: master key is required');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return a class object using class specific query","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Get"],"line":3807,"updatePoint":{"line":3807,"column":69,"index":136904},"code":"          it('should return a class object using class specific query', async () => {\n            const obj = new Parse.Object('Customer');\n            obj.set('someField', 'someValue');\n            await obj.save();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = (await apolloClient.query({\n              query: gql`\n                  query GetCustomer($id: ID!) {\n                    customer(id: $id) {\n                      id\n                      objectId\n                      someField\n                      createdAt\n                      updatedAt\n                    }\n                  }\n                `,\n              variables: {\n                id: obj.id\n              }\n            })).data.customer;\n            expect(result.objectId).toEqual(obj.id);\n            expect(result.someField).toEqual('someValue');\n            expect(new Date(result.createdAt)).toEqual(obj.createdAt);\n            expect(new Date(result.updatedAt)).toEqual(obj.updatedAt);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return many child objects in allow cyclic query","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Get"],"line":3886,"updatePoint":{"line":3886,"column":68,"index":140353},"code":"          it('should return many child objects in allow cyclic query', async () => {\n            const obj1 = new Parse.Object('Employee');\n            const obj2 = new Parse.Object('Team');\n            const obj3 = new Parse.Object('Company');\n            const obj4 = new Parse.Object('Country');\n            obj1.set('name', 'imAnEmployee');\n            await obj1.save();\n            obj2.set('name', 'imATeam');\n            obj2.set('employees', [obj1]);\n            await obj2.save();\n            obj3.set('name', 'imACompany');\n            obj3.set('teams', [obj2]);\n            obj3.set('employees', [obj1]);\n            await obj3.save();\n            obj4.set('name', 'imACountry');\n            obj4.set('companies', [obj3]);\n            await obj4.save();\n            obj1.set('country', obj4);\n            await obj1.save();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = (await apolloClient.query({\n              query: gql`\n                  query DeepComplexGraphQLQuery($id: ID!) {\n                    country(id: $id) {\n                      objectId\n                      name\n                      companies {\n                        ... on Company {\n                          objectId\n                          name\n                          employees {\n                            ... on Employee {\n                              objectId\n                              name\n                            }\n                          }\n                          teams {\n                            ... on Team {\n                              objectId\n                              name\n                              employees {\n                                ... on Employee {\n                                  objectId\n                                  name\n                                  country {\n                                    objectId\n                                    name\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n              variables: {\n                id: obj4.id\n              }\n            })).data.country;\n            const expectedResult = {\n              objectId: obj4.id,\n              name: 'imACountry',\n              __typename: 'Country',\n              companies: [{\n                objectId: obj3.id,\n                name: 'imACompany',\n                __typename: 'Company',\n                employees: [{\n                  objectId: obj1.id,\n                  name: 'imAnEmployee',\n                  __typename: 'Employee'\n                }],\n                teams: [{\n                  objectId: obj2.id,\n                  name: 'imATeam',\n                  __typename: 'Team',\n                  employees: [{\n                    objectId: obj1.id,\n                    name: 'imAnEmployee',\n                    __typename: 'Employee',\n                    country: {\n                      objectId: obj4.id,\n                      name: 'imACountry',\n                      __typename: 'Country'\n                    }\n                  }]\n                }]\n              }]\n            };\n            expect(result).toEqual(expectedResult);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should respect level permissions","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Get"],"line":3979,"updatePoint":{"line":3979,"column":46,"index":143723},"code":"          it('should respect level permissions', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            async function getObject(className, id, headers) {\n              const alias = className.charAt(0).toLowerCase() + className.slice(1);\n              const specificQueryResult = await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    get: ${alias}(id: $id) {\n                      id\n                      createdAt\n                      someField\n                    }\n                  }\n                `,\n                variables: {\n                  id\n                },\n                context: {\n                  headers\n                }\n              });\n              return specificQueryResult;\n            }\n            await Promise.all(objects.slice(0, 3).map(obj => expectAsync(getObject(obj.className, obj.id)).toBeRejectedWith(jasmine.stringMatching('Object not found'))));\n            expect((await getObject(object4.className, object4.id)).data.get.someField).toEqual('someValue4');\n            await Promise.all(objects.map(async obj => expect((await getObject(obj.className, obj.id, {\n              'X-Parse-Master-Key': 'test'\n            })).data.get.someField).toEqual(obj.get('someField'))));\n            await Promise.all(objects.map(async obj => expect((await getObject(obj.className, obj.id, {\n              'X-Parse-Session-Token': user1.getSessionToken()\n            })).data.get.someField).toEqual(obj.get('someField'))));\n            await Promise.all(objects.map(async obj => expect((await getObject(obj.className, obj.id, {\n              'X-Parse-Session-Token': user2.getSessionToken()\n            })).data.get.someField).toEqual(obj.get('someField'))));\n            await expectAsync(getObject(object2.className, object2.id, {\n              'X-Parse-Session-Token': user3.getSessionToken()\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            await Promise.all([object1, object3, object4].map(async obj => expect((await getObject(obj.className, obj.id, {\n              'X-Parse-Session-Token': user3.getSessionToken()\n            })).data.get.someField).toEqual(obj.get('someField'))));\n            await Promise.all(objects.slice(0, 3).map(obj => expectAsync(getObject(obj.className, obj.id, {\n              'X-Parse-Session-Token': user4.getSessionToken()\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'))));\n            expect((await getObject(object4.className, object4.id, {\n              'X-Parse-Session-Token': user4.getSessionToken()\n            })).data.get.someField).toEqual('someValue4');\n            await Promise.all(objects.slice(0, 2).map(obj => expectAsync(getObject(obj.className, obj.id, {\n              'X-Parse-Session-Token': user5.getSessionToken()\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'))));\n            expect((await getObject(object3.className, object3.id, {\n              'X-Parse-Session-Token': user5.getSessionToken()\n            })).data.get.someField).toEqual('someValue3');\n            expect((await getObject(object4.className, object4.id, {\n              'X-Parse-Session-Token': user5.getSessionToken()\n            })).data.get.someField).toEqual('someValue4');\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support keys argument","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Get"],"line":4036,"updatePoint":{"line":4036,"column":42,"index":147124},"code":"          it('should support keys argument', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result1 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  get: graphQLClass(id: $id) {\n                    someField\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken()\n                }\n              }\n            });\n            const result2 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  get: graphQLClass(id: $id) {\n                    someField\n                    pointerToUser {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken()\n                }\n              }\n            });\n            expect(result1.data.get.someField).toBeDefined();\n            expect(result1.data.get.pointerToUser).toBeUndefined();\n            expect(result2.data.get.someField).toBeDefined();\n            expect(result2.data.get.pointerToUser).toBeDefined();\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support include argument","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Get"],"line":4081,"updatePoint":{"line":4081,"column":45,"index":148661},"code":"          it('should support include argument', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result1 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  get: graphQLClass(id: $id) {\n                    pointerToUser {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken()\n                }\n              }\n            });\n            const result2 = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  graphQLClass(id: $id) {\n                    pointerToUser {\n                      username\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: object3.id\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken()\n                }\n              }\n            });\n            expect(result1.data.get.pointerToUser.username).toBeUndefined();\n            expect(result2.data.graphQLClass.pointerToUser.username).toBeDefined();\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should respect protectedFields","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Get"],"line":4125,"updatePoint":{"line":4125,"column":44,"index":150124},"code":"          it('should respect protectedFields', async done => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const className = 'GraphQLClass';\n            await updateCLP({\n              get: {\n                '*': true\n              },\n              find: {\n                '*': true\n              },\n              protectedFields: {\n                '*': ['someField', 'someOtherField'],\n                authenticated: ['someField'],\n                'userField:pointerToUser': [],\n                [user2.id]: []\n              }\n            }, className);\n            const getObject = async (className, id, user) => {\n              const headers = user ? {\n                ['X-Parse-Session-Token']: user.getSessionToken()\n              } : undefined;\n              const specificQueryResult = await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    get: graphQLClass(id: $id) {\n                      pointerToUser {\n                        username\n                        id\n                      }\n                      someField\n                      someOtherField\n                    }\n                  }\n                `,\n                variables: {\n                  id: id\n                },\n                context: {\n                  headers: headers\n                }\n              });\n              return specificQueryResult.data.get;\n            };\n            const id = object3.id;\n\n            /* not authenticated */\n            const objectPublic = await getObject(className, id, undefined);\n            expect(objectPublic.someField).toBeNull();\n            expect(objectPublic.someOtherField).toBeNull();\n\n            /* authenticated */\n            const objectAuth = await getObject(className, id, user1);\n            expect(objectAuth.someField).toBeNull();\n            expect(objectAuth.someOtherField).toBe('B');\n\n            /* pointer field */\n            const objectPointed = await getObject(className, id, user5);\n            expect(objectPointed.someField).toBe('someValue3');\n            expect(objectPointed.someOtherField).toBe('B');\n\n            /* for user id */\n            const objectForUser = await getObject(className, id, user2);\n            expect(objectForUser.someField).toBe('someValue3');\n            expect(objectForUser.someOtherField).toBe('B');\n            done();\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should read from primary by default","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Get"],"line":4193,"updatePoint":{"line":4193,"column":51,"index":152677},"code":"            it('should read from primary by default', async () => {\n              try {\n                await prepareData();\n                await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n                spyOn(Collection.prototype, 'find').and.callThrough();\n                await apolloClient.query({\n                  query: gql`\n                    query GetSomeObject($id: ID!) {\n                      graphQLClass(id: $id) {\n                        pointerToUser {\n                          username\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    id: object3.id\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Session-Token': user1.getSessionToken()\n                    }\n                  }\n                });\n                let foundGraphQLClassReadPreference = false;\n                let foundUserClassReadPreference = false;\n                Collection.prototype.find.calls.all().forEach(call => {\n                  if (call.object.s.namespace.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.object.s.readPreference.mode).toBe(ReadPreference.PRIMARY);\n                  } else if (call.object.s.namespace.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.object.s.readPreference.mode).toBe(ReadPreference.PRIMARY);\n                  }\n                });\n                expect(foundGraphQLClassReadPreference).toBe(true);\n                expect(foundUserClassReadPreference).toBe(true);\n              } catch (e) {\n                handleError(e);\n              }\n            });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support readPreference argument","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Get"],"line":4234,"updatePoint":{"line":4234,"column":54,"index":154511},"code":"            it('should support readPreference argument', async () => {\n              await prepareData();\n              await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n              spyOn(Collection.prototype, 'find').and.callThrough();\n              await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    graphQLClass(id: $id, options: { readPreference: SECONDARY }) {\n                      pointerToUser {\n                        username\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id: object3.id\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              Collection.prototype.find.calls.all().forEach(call => {\n                if (call.object.s.namespace.collection.indexOf('GraphQLClass') >= 0) {\n                  foundGraphQLClassReadPreference = true;\n                  expect(call.args[1].readPreference).toBe(ReadPreference.SECONDARY);\n                } else if (call.object.s.namespace.collection.indexOf('_User') >= 0) {\n                  foundUserClassReadPreference = true;\n                  expect(call.args[1].readPreference).toBe(ReadPreference.SECONDARY);\n                }\n              });\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support includeReadPreference argument","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Get"],"line":4271,"updatePoint":{"line":4271,"column":61,"index":156198},"code":"            it('should support includeReadPreference argument', async () => {\n              await prepareData();\n              await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n              spyOn(Collection.prototype, 'find').and.callThrough();\n              await apolloClient.query({\n                query: gql`\n                  query GetSomeObject($id: ID!) {\n                    graphQLClass(\n                      id: $id\n                      options: { readPreference: SECONDARY, includeReadPreference: NEAREST }\n                    ) {\n                      pointerToUser {\n                        username\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id: object3.id\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              Collection.prototype.find.calls.all().forEach(call => {\n                if (call.object.s.namespace.collection.indexOf('GraphQLClass') >= 0) {\n                  foundGraphQLClassReadPreference = true;\n                  expect(call.args[1].readPreference).toBe(ReadPreference.SECONDARY);\n                } else if (call.object.s.namespace.collection.indexOf('_User') >= 0) {\n                  foundUserClassReadPreference = true;\n                  expect(call.args[1].readPreference).toBe(ReadPreference.NEAREST);\n                }\n              });\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return class objects using class specific query","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4314,"updatePoint":{"line":4314,"column":68,"index":158046},"code":"          it('should return class objects using class specific query', async () => {\n            const obj1 = new Parse.Object('Customer');\n            obj1.set('someField', 'someValue1');\n            await obj1.save();\n            const obj2 = new Parse.Object('Customer');\n            obj2.set('someField', 'someValue1');\n            await obj2.save();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = await apolloClient.query({\n              query: gql`\n                query FindCustomer {\n                  customers {\n                    edges {\n                      node {\n                        objectId\n                        someField\n                        createdAt\n                        updatedAt\n                      }\n                    }\n                  }\n                }\n              `\n            });\n            expect(result.data.customers.edges.length).toEqual(2);\n            result.data.customers.edges.forEach(resultObj => {\n              const obj = resultObj.node.objectId === obj1.id ? obj1 : obj2;\n              expect(resultObj.node.objectId).toEqual(obj.id);\n              expect(resultObj.node.someField).toEqual(obj.get('someField'));\n              expect(new Date(resultObj.node.createdAt)).toEqual(obj.createdAt);\n              expect(new Date(resultObj.node.updatedAt)).toEqual(obj.updatedAt);\n            });\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should respect level permissions","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4347,"updatePoint":{"line":4347,"column":46,"index":159451},"code":"          it('should respect level permissions', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            async function findObjects(className, headers) {\n              const graphqlClassName = pluralize(className.charAt(0).toLowerCase() + className.slice(1));\n              const result = await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    find: ${graphqlClassName} {\n                      edges {\n                        node {\n                          id\n                          someField\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers\n                }\n              });\n              return result;\n            }\n            expect((await findObjects('GraphQLClass')).data.find.edges.map(object => object.node.someField)).toEqual([]);\n            expect((await findObjects('PublicClass')).data.find.edges.map(object => object.node.someField)).toEqual(['someValue4']);\n            expect((await findObjects('GraphQLClass', {\n              'X-Parse-Master-Key': 'test'\n            })).data.find.edges.map(object => object.node.someField).sort()).toEqual(['someValue1', 'someValue2', 'someValue3']);\n            expect((await findObjects('PublicClass', {\n              'X-Parse-Master-Key': 'test'\n            })).data.find.edges.map(object => object.node.someField)).toEqual(['someValue4']);\n            expect((await findObjects('GraphQLClass', {\n              'X-Parse-Session-Token': user1.getSessionToken()\n            })).data.find.edges.map(object => object.node.someField).sort()).toEqual(['someValue1', 'someValue2', 'someValue3']);\n            expect((await findObjects('PublicClass', {\n              'X-Parse-Session-Token': user1.getSessionToken()\n            })).data.find.edges.map(object => object.node.someField)).toEqual(['someValue4']);\n            expect((await findObjects('GraphQLClass', {\n              'X-Parse-Session-Token': user2.getSessionToken()\n            })).data.find.edges.map(object => object.node.someField).sort()).toEqual(['someValue1', 'someValue2', 'someValue3']);\n            expect((await findObjects('GraphQLClass', {\n              'X-Parse-Session-Token': user3.getSessionToken()\n            })).data.find.edges.map(object => object.node.someField).sort()).toEqual(['someValue1', 'someValue3']);\n            expect((await findObjects('GraphQLClass', {\n              'X-Parse-Session-Token': user4.getSessionToken()\n            })).data.find.edges.map(object => object.node.someField)).toEqual([]);\n            expect((await findObjects('GraphQLClass', {\n              'X-Parse-Session-Token': user5.getSessionToken()\n            })).data.find.edges.map(object => object.node.someField)).toEqual(['someValue3']);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support where argument using class specific query","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4398,"updatePoint":{"line":4398,"column":70,"index":162411},"code":"          it('should support where argument using class specific query', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($where: GraphQLClassWhereInput) {\n                  graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  someField: {\n                    in: ['someValue1', 'someValue2', 'someValue3']\n                  },\n                  OR: [{\n                    pointerToUser: {\n                      have: {\n                        objectId: {\n                          equalTo: user5.id\n                        }\n                      }\n                    }\n                  }, {\n                    id: {\n                      equalTo: object1.id\n                    }\n                  }]\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            expect(result.data.graphQLClasses.edges.map(object => object.node.someField).sort()).toEqual(['someValue1', 'someValue3']);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support in pointer operator using class specific query","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4441,"updatePoint":{"line":4441,"column":75,"index":163890},"code":"          it('should support in pointer operator using class specific query', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($where: GraphQLClassWhereInput) {\n                  graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  pointerToUser: {\n                    have: {\n                      objectId: {\n                        in: [user5.id]\n                      }\n                    }\n                  }\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            const {\n              edges\n            } = result.data.graphQLClasses;\n            expect(edges.length).toBe(1);\n            expect(edges[0].node.someField).toEqual('someValue3');\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support OR operation","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4479,"updatePoint":{"line":4479,"column":41,"index":165097},"code":"          it('should support OR operation', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = await apolloClient.query({\n              query: gql`\n                query {\n                  graphQLClasses(\n                    where: {\n                      OR: [\n                        { someField: { equalTo: \"someValue1\" } }\n                        { someField: { equalTo: \"someValue2\" } }\n                      ]\n                    }\n                  ) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            expect(result.data.graphQLClasses.edges.map(object => object.node.someField).sort()).toEqual(['someValue1', 'someValue2']);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support full text search","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4509,"updatePoint":{"line":4509,"column":45,"index":166153},"code":"          it('should support full text search', async () => {\n            try {\n              const obj = new Parse.Object('FullTextSearchTest');\n              obj.set('field1', 'Parse GraphQL Server');\n              obj.set('field2', 'It rocks!');\n              await obj.save();\n              await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n              const result = await apolloClient.query({\n                query: gql`\n                  query FullTextSearchTests($where: FullTextSearchTestWhereInput) {\n                    fullTextSearchTests(where: $where) {\n                      edges {\n                        node {\n                          objectId\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                },\n                variables: {\n                  where: {\n                    field1: {\n                      text: {\n                        search: {\n                          term: 'graphql'\n                        }\n                      }\n                    }\n                  }\n                }\n              });\n              expect(result.data.fullTextSearchTests.edges[0].node.objectId).toEqual(obj.id);\n            } catch (e) {\n              handleError(e);\n            }\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support in query key","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4550,"updatePoint":{"line":4550,"column":41,"index":167583},"code":"          it('should support in query key', async () => {\n            try {\n              const country = new Parse.Object('Country');\n              country.set('code', 'FR');\n              await country.save();\n              const country2 = new Parse.Object('Country');\n              country2.set('code', 'US');\n              await country2.save();\n              const city = new Parse.Object('City');\n              city.set('country', 'FR');\n              city.set('name', 'city1');\n              await city.save();\n              const city2 = new Parse.Object('City');\n              city2.set('country', 'US');\n              city2.set('name', 'city2');\n              await city2.save();\n              await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n              const {\n                data: {\n                  cities: {\n                    edges: result\n                  }\n                }\n              } = await apolloClient.query({\n                query: gql`\n                  query inQueryKey($where: CityWhereInput) {\n                    cities(where: $where) {\n                      edges {\n                        node {\n                          country\n                          name\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                },\n                variables: {\n                  where: {\n                    country: {\n                      inQueryKey: {\n                        query: {\n                          className: 'Country',\n                          where: {\n                            code: {\n                              equalTo: 'US'\n                            }\n                          }\n                        },\n                        key: 'code'\n                      }\n                    }\n                  }\n                }\n              });\n              expect(result.length).toEqual(1);\n              expect(result[0].node.name).toEqual('city2');\n            } catch (e) {\n              handleError(e);\n            }\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support order, skip and first arguments","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4615,"updatePoint":{"line":4615,"column":60,"index":169811},"code":"          it('should support order, skip and first arguments', async () => {\n            const promises = [];\n            for (let i = 0; i < 100; i++) {\n              const obj = new Parse.Object('SomeClass');\n              obj.set('someField', `someValue${i < 10 ? '0' : ''}${i}`);\n              obj.set('numberField', i % 3);\n              promises.push(obj.save());\n            }\n            await Promise.all(promises);\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects(\n                  $where: SomeClassWhereInput\n                  $order: [SomeClassOrder!]\n                  $skip: Int\n                  $first: Int\n                ) {\n                  find: someClasses(where: $where, order: $order, skip: $skip, first: $first) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  someField: {\n                    matchesRegex: '^someValue'\n                  }\n                },\n                order: ['numberField_DESC', 'someField_ASC'],\n                skip: 4,\n                first: 2\n              }\n            });\n            expect(result.data.find.edges.map(obj => obj.node.someField)).toEqual(['someValue14', 'someValue17']);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support pagination","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4655,"updatePoint":{"line":4655,"column":39,"index":171310},"code":"          it('should support pagination', async () => {\n            const numberArray = (first, last) => {\n              const array = [];\n              for (let i = first; i <= last; i++) {\n                array.push(i);\n              }\n              return array;\n            };\n            const promises = [];\n            for (let i = 0; i < 100; i++) {\n              const obj = new Parse.Object('SomeClass');\n              obj.set('numberField', i);\n              promises.push(obj.save());\n            }\n            await Promise.all(promises);\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const find = async ({\n              skip,\n              after,\n              first,\n              before,\n              last\n            } = {}) => {\n              return await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects(\n                    $order: [SomeClassOrder!]\n                    $skip: Int\n                    $after: String\n                    $first: Int\n                    $before: String\n                    $last: Int\n                  ) {\n                    someClasses(\n                      order: $order\n                      skip: $skip\n                      after: $after\n                      first: $first\n                      before: $before\n                      last: $last\n                    ) {\n                      edges {\n                        cursor\n                        node {\n                          numberField\n                        }\n                      }\n                      count\n                      pageInfo {\n                        hasPreviousPage\n                        startCursor\n                        endCursor\n                        hasNextPage\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  order: ['numberField_ASC'],\n                  skip,\n                  after,\n                  first,\n                  before,\n                  last\n                }\n              });\n            };\n            let result = await find();\n            expect(result.data.someClasses.edges.map(edge => edge.node.numberField)).toEqual(numberArray(0, 99));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(false);\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(result.data.someClasses.edges[0].cursor);\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(result.data.someClasses.edges[99].cursor);\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(false);\n            result = await find({\n              first: 10\n            });\n            expect(result.data.someClasses.edges.map(edge => edge.node.numberField)).toEqual(numberArray(0, 9));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(false);\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(result.data.someClasses.edges[0].cursor);\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(result.data.someClasses.edges[9].cursor);\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(true);\n            result = await find({\n              first: 10,\n              after: result.data.someClasses.pageInfo.endCursor\n            });\n            expect(result.data.someClasses.edges.map(edge => edge.node.numberField)).toEqual(numberArray(10, 19));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(true);\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(result.data.someClasses.edges[0].cursor);\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(result.data.someClasses.edges[9].cursor);\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(true);\n            result = await find({\n              last: 10\n            });\n            expect(result.data.someClasses.edges.map(edge => edge.node.numberField)).toEqual(numberArray(90, 99));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(true);\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(result.data.someClasses.edges[0].cursor);\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(result.data.someClasses.edges[9].cursor);\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(false);\n            result = await find({\n              last: 10,\n              before: result.data.someClasses.pageInfo.startCursor\n            });\n            expect(result.data.someClasses.edges.map(edge => edge.node.numberField)).toEqual(numberArray(80, 89));\n            expect(result.data.someClasses.count).toEqual(100);\n            expect(result.data.someClasses.pageInfo.hasPreviousPage).toEqual(true);\n            expect(result.data.someClasses.pageInfo.startCursor).toEqual(result.data.someClasses.edges[0].cursor);\n            expect(result.data.someClasses.pageInfo.endCursor).toEqual(result.data.someClasses.edges[9].cursor);\n            expect(result.data.someClasses.pageInfo.hasNextPage).toEqual(true);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support count","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4768,"updatePoint":{"line":4768,"column":34,"index":176775},"code":"          it('should support count', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const where = {\n              someField: {\n                in: ['someValue1', 'someValue2', 'someValue3']\n              },\n              OR: [{\n                pointerToUser: {\n                  have: {\n                    objectId: {\n                      equalTo: user5.id\n                    }\n                  }\n                }\n              }, {\n                id: {\n                  equalTo: object1.id\n                }\n              }]\n            };\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($where: GraphQLClassWhereInput, $first: Int) {\n                  find: graphQLClasses(where: $where, first: $first) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                    count\n                  }\n                }\n              `,\n              variables: {\n                where,\n                first: 0\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            expect(result.data.find.edges).toEqual([]);\n            expect(result.data.find.count).toEqual(2);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should only count","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4815,"updatePoint":{"line":4815,"column":31,"index":178222},"code":"          it('should only count', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const where = {\n              someField: {\n                in: ['someValue1', 'someValue2', 'someValue3']\n              },\n              OR: [{\n                pointerToUser: {\n                  have: {\n                    objectId: {\n                      equalTo: user5.id\n                    }\n                  }\n                }\n              }, {\n                id: {\n                  equalTo: object1.id\n                }\n              }]\n            };\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    count\n                  }\n                }\n              `,\n              variables: {\n                where\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            expect(result.data.find.edges).toBeUndefined();\n            expect(result.data.find.count).toEqual(2);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should respect max limit","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4856,"updatePoint":{"line":4856,"column":38,"index":179496},"code":"          it('should respect max limit', async () => {\n            parseServer = await global.reconfigureServer({\n              maxLimit: 10\n            });\n            const promises = [];\n            for (let i = 0; i < 100; i++) {\n              const obj = new Parse.Object('SomeClass');\n              promises.push(obj.save());\n            }\n            await Promise.all(promises);\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = await apolloClient.query({\n              query: gql`\n                query FindSomeObjects($limit: Int) {\n                  find: someClasses(where: { id: { exists: true } }, first: $limit) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                    count\n                  }\n                }\n              `,\n              variables: {\n                limit: 50\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            expect(result.data.find.edges.length).toEqual(10);\n            expect(result.data.find.count).toEqual(100);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support keys argument","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4892,"updatePoint":{"line":4892,"column":42,"index":180747},"code":"          it('should support keys argument', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result1 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  id: {\n                    equalTo: object3.id\n                  }\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken()\n                }\n              }\n            });\n            const result2 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        someField\n                        pointerToUser {\n                          username\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: {\n                  id: {\n                    equalTo: object3.id\n                  }\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken()\n                }\n              }\n            });\n            expect(result1.data.find.edges[0].node.someField).toBeDefined();\n            expect(result1.data.find.edges[0].node.pointerToUser).toBeUndefined();\n            expect(result2.data.find.edges[0].node.someField).toBeDefined();\n            expect(result2.data.find.edges[0].node.pointerToUser).toBeDefined();\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support include argument","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":4953,"updatePoint":{"line":4953,"column":45,"index":182832},"code":"          it('should support include argument', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const where = {\n              id: {\n                equalTo: object3.id\n              }\n            };\n            const result1 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        pointerToUser {\n                          id\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken()\n                }\n              }\n            });\n            const result2 = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: GraphQLClassWhereInput) {\n                  find: graphQLClasses(where: $where) {\n                    edges {\n                      node {\n                        pointerToUser {\n                          username\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where\n              },\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken()\n                }\n              }\n            });\n            expect(result1.data.find.edges[0].node.pointerToUser.username).toBeUndefined();\n            expect(result2.data.find.edges[0].node.pointerToUser.username).toBeDefined();\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should read from primary by default","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":5011,"updatePoint":{"line":5011,"column":51,"index":184783},"code":"            it('should read from primary by default', async () => {\n              await prepareData();\n              await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n              spyOn(Collection.prototype, 'find').and.callThrough();\n              await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    find: graphQLClasses {\n                      edges {\n                        node {\n                          pointerToUser {\n                            username\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Session-Token': user1.getSessionToken()\n                  }\n                }\n              });\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              Collection.prototype.find.calls.all().forEach(call => {\n                if (call.object.s.namespace.collection.indexOf('GraphQLClass') >= 0) {\n                  foundGraphQLClassReadPreference = true;\n                  expect(call.object.s.readPreference.mode).toBe(ReadPreference.PRIMARY);\n                } else if (call.object.s.namespace.collection.indexOf('_User') >= 0) {\n                  foundUserClassReadPreference = true;\n                  expect(call.object.s.readPreference.mode).toBe(ReadPreference.PRIMARY);\n                }\n              });\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support readPreference argument","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":5049,"updatePoint":{"line":5049,"column":54,"index":186484},"code":"            it('should support readPreference argument', async () => {\n              await prepareData();\n              await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n              spyOn(Collection.prototype, 'find').and.callThrough();\n              await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    find: graphQLClasses(options: { readPreference: SECONDARY }) {\n                      edges {\n                        node {\n                          pointerToUser {\n                            username\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              Collection.prototype.find.calls.all().forEach(call => {\n                if (call.object.s.namespace.collection.indexOf('GraphQLClass') >= 0) {\n                  foundGraphQLClassReadPreference = true;\n                  expect(call.args[1].readPreference).toBe(ReadPreference.SECONDARY);\n                } else if (call.object.s.namespace.collection.indexOf('_User') >= 0) {\n                  foundUserClassReadPreference = true;\n                  expect(call.args[1].readPreference).toBe(ReadPreference.SECONDARY);\n                }\n              });\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support includeReadPreference argument","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":5087,"updatePoint":{"line":5087,"column":61,"index":188204},"code":"            it('should support includeReadPreference argument', async () => {\n              await prepareData();\n              await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n              spyOn(Collection.prototype, 'find').and.callThrough();\n              await apolloClient.query({\n                query: gql`\n                  query FindSomeObjects {\n                    graphQLClasses(\n                      options: { readPreference: SECONDARY, includeReadPreference: NEAREST }\n                    ) {\n                      edges {\n                        node {\n                          pointerToUser {\n                            username\n                          }\n                        }\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n              let foundGraphQLClassReadPreference = false;\n              let foundUserClassReadPreference = false;\n              Collection.prototype.find.calls.all().forEach(call => {\n                if (call.object.s.namespace.collection.indexOf('GraphQLClass') >= 0) {\n                  foundGraphQLClassReadPreference = true;\n                  expect(call.args[1].readPreference).toBe(ReadPreference.SECONDARY);\n                } else if (call.object.s.namespace.collection.indexOf('_User') >= 0) {\n                  foundUserClassReadPreference = true;\n                  expect(call.args[1].readPreference).toBe(ReadPreference.NEAREST);\n                }\n              });\n              expect(foundGraphQLClassReadPreference).toBe(true);\n              expect(foundUserClassReadPreference).toBe(true);\n            });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support subqueryReadPreference argument","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":5127,"updatePoint":{"line":5127,"column":62,"index":189993},"code":"            it('should support subqueryReadPreference argument', async () => {\n              try {\n                await prepareData();\n                await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n                spyOn(Collection.prototype, 'find').and.callThrough();\n                await apolloClient.query({\n                  query: gql`\n                    query FindSomeObjects($where: GraphQLClassWhereInput) {\n                      find: graphQLClasses(\n                        where: $where\n                        options: { readPreference: SECONDARY, subqueryReadPreference: NEAREST }\n                      ) {\n                        edges {\n                          node {\n                            id\n                          }\n                        }\n                      }\n                    }\n                  `,\n                  variables: {\n                    where: {\n                      pointerToUser: {\n                        have: {\n                          objectId: {\n                            equalTo: 'xxxx'\n                          }\n                        }\n                      }\n                    }\n                  },\n                  context: {\n                    headers: {\n                      'X-Parse-Master-Key': 'test'\n                    }\n                  }\n                });\n                let foundGraphQLClassReadPreference = false;\n                let foundUserClassReadPreference = false;\n                Collection.prototype.find.calls.all().forEach(call => {\n                  if (call.object.s.namespace.collection.indexOf('GraphQLClass') >= 0) {\n                    foundGraphQLClassReadPreference = true;\n                    expect(call.args[1].readPreference).toBe(ReadPreference.SECONDARY);\n                  } else if (call.object.s.namespace.collection.indexOf('_User') >= 0) {\n                    foundUserClassReadPreference = true;\n                    expect(call.args[1].readPreference).toBe(ReadPreference.NEAREST);\n                  }\n                });\n                expect(foundGraphQLClassReadPreference).toBe(true);\n                expect(foundUserClassReadPreference).toBe(true);\n              } catch (e) {\n                handleError(e);\n              }\n            });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should order by multiple fields","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":5182,"updatePoint":{"line":5182,"column":45,"index":192280},"code":"          it('should order by multiple fields', async () => {\n            await prepareData();\n            await resetGraphQLCache();\n            let result;\n            try {\n              result = await apolloClient.query({\n                query: gql`\n                  query OrderByMultipleFields($order: [GraphQLClassOrder!]) {\n                    graphQLClasses(order: $order) {\n                      edges {\n                        node {\n                          objectId\n                        }\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  order: ['someOtherField_DESC', 'someField_ASC']\n                },\n                context: {\n                  headers: {\n                    'X-Parse-Master-Key': 'test'\n                  }\n                }\n              });\n            } catch (e) {\n              handleError(e);\n            }\n            expect(result.data.graphQLClasses.edges.map(edge => edge.node.objectId)).toEqual([object3.id, object1.id, object2.id]);\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support including relation","suites":["ParseGraphQLServer","Auto API","Schema","Objects Queries","Find"],"line":5253,"updatePoint":{"line":5253,"column":47,"index":194913},"code":"          it('should support including relation', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result1 = await apolloClient.query({\n              query: gql`\n                query FindRoles {\n                  roles {\n                    edges {\n                      node {\n                        name\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {},\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken()\n                }\n              }\n            });\n            const result2 = await apolloClient.query({\n              query: gql`\n                query FindRoles {\n                  roles {\n                    edges {\n                      node {\n                        name\n                        users {\n                          edges {\n                            node {\n                              username\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {},\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': user1.getSessionToken()\n                }\n              }\n            });\n            expect(result1.data.roles.edges[0].node.name).toBeDefined();\n            expect(result1.data.roles.edges[0].node.users).toBeUndefined();\n            expect(result1.data.roles.edges[0].node.roles).toBeUndefined();\n            expect(result2.data.roles.edges[0].node.name).toBeDefined();\n            expect(result2.data.roles.edges[0].node.users).toBeDefined();\n            expect(result2.data.roles.edges[0].node.users.edges[0].node.username).toBeDefined();\n            expect(result2.data.roles.edges[0].node.roles).toBeUndefined();\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return specific type object using class specific mutation","suites":["ParseGraphQLServer","Auto API","Schema","Objects Mutations","Create"],"line":5313,"updatePoint":{"line":5313,"column":78,"index":197054},"code":"          it('should return specific type object using class specific mutation', async () => {\n            const clientMutationId = uuidv4();\n            const customerSchema = new Parse.Schema('Customer');\n            customerSchema.addString('someField');\n            await customerSchema.save();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateCustomer($input: CreateCustomerInput!) {\n                  createCustomer(input: $input) {\n                    clientMutationId\n                    customer {\n                      id\n                      objectId\n                      createdAt\n                      someField\n                    }\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  fields: {\n                    someField: 'someValue'\n                  }\n                }\n              }\n            });\n            expect(result.data.createCustomer.clientMutationId).toEqual(clientMutationId);\n            expect(result.data.createCustomer.customer.id).toBeDefined();\n            expect(result.data.createCustomer.customer.someField).toEqual('someValue');\n            const customer = await new Parse.Query('Customer').get(result.data.createCustomer.customer.objectId);\n            expect(customer.createdAt).toEqual(new Date(result.data.createCustomer.customer.createdAt));\n            expect(customer.get('someField')).toEqual('someValue');\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should respect level permissions","suites":["ParseGraphQLServer","Auto API","Schema","Objects Mutations","Create"],"line":5349,"updatePoint":{"line":5349,"column":46,"index":198652},"code":"          it('should respect level permissions', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            async function createObject(className, headers) {\n              const getClassName = className.charAt(0).toLowerCase() + className.slice(1);\n              const result = await apolloClient.mutate({\n                mutation: gql`\n                  mutation CreateSomeObject {\n                    create${className}(input: {}) {\n                      ${getClassName} {\n                        id\n                        createdAt\n                      }\n                    }\n                  }\n                `,\n                context: {\n                  headers\n                }\n              });\n              const specificCreate = result.data[`create${className}`][getClassName];\n              expect(specificCreate.id).toBeDefined();\n              expect(specificCreate.createdAt).toBeDefined();\n              return result;\n            }\n            await expectAsync(createObject('GraphQLClass')).toBeRejectedWith(jasmine.stringMatching('Permission denied for action create on class GraphQLClass'));\n            await expectAsync(createObject('PublicClass')).toBeResolved();\n            await expectAsync(createObject('GraphQLClass', {\n              'X-Parse-Master-Key': 'test'\n            })).toBeResolved();\n            await expectAsync(createObject('PublicClass', {\n              'X-Parse-Master-Key': 'test'\n            })).toBeResolved();\n            await expectAsync(createObject('GraphQLClass', {\n              'X-Parse-Session-Token': user1.getSessionToken()\n            })).toBeResolved();\n            await expectAsync(createObject('PublicClass', {\n              'X-Parse-Session-Token': user1.getSessionToken()\n            })).toBeResolved();\n            await expectAsync(createObject('GraphQLClass', {\n              'X-Parse-Session-Token': user2.getSessionToken()\n            })).toBeResolved();\n            await expectAsync(createObject('PublicClass', {\n              'X-Parse-Session-Token': user2.getSessionToken()\n            })).toBeResolved();\n            await expectAsync(createObject('GraphQLClass', {\n              'X-Parse-Session-Token': user4.getSessionToken()\n            })).toBeRejectedWith(jasmine.stringMatching('Permission denied for action create on class GraphQLClass'));\n            await expectAsync(createObject('PublicClass', {\n              'X-Parse-Session-Token': user4.getSessionToken()\n            })).toBeResolved();\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return specific type object using class specific mutation","suites":["ParseGraphQLServer","Auto API","Schema","Objects Mutations","Update"],"line":5403,"updatePoint":{"line":5403,"column":78,"index":201307},"code":"          it('should return specific type object using class specific mutation', async () => {\n            const clientMutationId = uuidv4();\n            const obj = new Parse.Object('Customer');\n            obj.set('someField1', 'someField1Value1');\n            obj.set('someField2', 'someField2Value1');\n            await obj.save();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation UpdateCustomer($input: UpdateCustomerInput!) {\n                  updateCustomer(input: $input) {\n                    clientMutationId\n                    customer {\n                      updatedAt\n                      someField1\n                      someField2\n                    }\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  id: obj.id,\n                  fields: {\n                    someField1: 'someField1Value2'\n                  }\n                }\n              }\n            });\n            expect(result.data.updateCustomer.clientMutationId).toEqual(clientMutationId);\n            expect(result.data.updateCustomer.customer.updatedAt).toBeDefined();\n            expect(result.data.updateCustomer.customer.someField1).toEqual('someField1Value2');\n            expect(result.data.updateCustomer.customer.someField2).toEqual('someField2Value1');\n            await obj.fetch();\n            expect(obj.get('someField1')).toEqual('someField1Value2');\n            expect(obj.get('someField2')).toEqual('someField2Value1');\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return only id using class specific mutation","suites":["ParseGraphQLServer","Auto API","Schema","Objects Mutations","Update"],"line":5441,"updatePoint":{"line":5441,"column":65,"index":202974},"code":"          it('should return only id using class specific mutation', async () => {\n            const obj = new Parse.Object('Customer');\n            obj.set('someField1', 'someField1Value1');\n            obj.set('someField2', 'someField2Value1');\n            await obj.save();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation UpdateCustomer($id: ID!, $fields: UpdateCustomerFieldsInput) {\n                  updateCustomer(input: { id: $id, fields: $fields }) {\n                    customer {\n                      id\n                      objectId\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: obj.id,\n                fields: {\n                  someField1: 'someField1Value2'\n                }\n              }\n            });\n            expect(result.data.updateCustomer.customer.objectId).toEqual(obj.id);\n            await obj.fetch();\n            expect(obj.get('someField1')).toEqual('someField1Value2');\n            expect(obj.get('someField2')).toEqual('someField2Value1');\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should respect level permissions","suites":["ParseGraphQLServer","Auto API","Schema","Objects Mutations","Update"],"line":5470,"updatePoint":{"line":5470,"column":46,"index":204165},"code":"          it('should respect level permissions', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            async function updateObject(className, id, fields, headers) {\n              return await apolloClient.mutate({\n                mutation: gql`\n                  mutation UpdateSomeObject(\n                    $id: ID!\n                    $fields: Update${className}FieldsInput\n                  ) {\n                    update: update${className}(input: {\n                      id: $id\n                      fields: $fields\n                      clientMutationId: \"someid\"\n                    }) {\n                      clientMutationId\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                  fields\n                },\n                context: {\n                  headers\n                }\n              });\n            }\n            await Promise.all(objects.slice(0, 3).map(async obj => {\n              const originalFieldValue = obj.get('someField');\n              await expectAsync(updateObject(obj.className, obj.id, {\n                someField: 'changedValue1'\n              })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual(originalFieldValue);\n            }));\n            expect((await updateObject(object4.className, object4.id, {\n              someField: 'changedValue1'\n            })).data.update.clientMutationId).toBeDefined();\n            await object4.fetch({\n              useMasterKey: true\n            });\n            expect(object4.get('someField')).toEqual('changedValue1');\n            await Promise.all(objects.map(async obj => {\n              expect((await updateObject(obj.className, obj.id, {\n                someField: 'changedValue2'\n              }, {\n                'X-Parse-Master-Key': 'test'\n              })).data.update.clientMutationId).toBeDefined();\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual('changedValue2');\n            }));\n            await Promise.all(objects.map(async obj => {\n              expect((await updateObject(obj.className, obj.id, {\n                someField: 'changedValue3'\n              }, {\n                'X-Parse-Session-Token': user1.getSessionToken()\n              })).data.update.clientMutationId).toBeDefined();\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual('changedValue3');\n            }));\n            await Promise.all(objects.map(async obj => {\n              expect((await updateObject(obj.className, obj.id, {\n                someField: 'changedValue4'\n              }, {\n                'X-Parse-Session-Token': user2.getSessionToken()\n              })).data.update.clientMutationId).toBeDefined();\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual('changedValue4');\n            }));\n            await Promise.all([object1, object3, object4].map(async obj => {\n              expect((await updateObject(obj.className, obj.id, {\n                someField: 'changedValue5'\n              }, {\n                'X-Parse-Session-Token': user3.getSessionToken()\n              })).data.update.clientMutationId).toBeDefined();\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual('changedValue5');\n            }));\n            const originalFieldValue = object2.get('someField');\n            await expectAsync(updateObject(object2.className, object2.id, {\n              someField: 'changedValue5'\n            }, {\n              'X-Parse-Session-Token': user3.getSessionToken()\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            await object2.fetch({\n              useMasterKey: true\n            });\n            expect(object2.get('someField')).toEqual(originalFieldValue);\n            await Promise.all(objects.slice(0, 3).map(async obj => {\n              const originalFieldValue = obj.get('someField');\n              await expectAsync(updateObject(obj.className, obj.id, {\n                someField: 'changedValue6'\n              }, {\n                'X-Parse-Session-Token': user4.getSessionToken()\n              })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual(originalFieldValue);\n            }));\n            expect((await updateObject(object4.className, object4.id, {\n              someField: 'changedValue6'\n            }, {\n              'X-Parse-Session-Token': user4.getSessionToken()\n            })).data.update.clientMutationId).toBeDefined();\n            await object4.fetch({\n              useMasterKey: true\n            });\n            expect(object4.get('someField')).toEqual('changedValue6');\n            await Promise.all(objects.slice(0, 2).map(async obj => {\n              const originalFieldValue = obj.get('someField');\n              await expectAsync(updateObject(obj.className, obj.id, {\n                someField: 'changedValue7'\n              }, {\n                'X-Parse-Session-Token': user5.getSessionToken()\n              })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual(originalFieldValue);\n            }));\n            expect((await updateObject(object3.className, object3.id, {\n              someField: 'changedValue7'\n            }, {\n              'X-Parse-Session-Token': user5.getSessionToken()\n            })).data.update.clientMutationId).toBeDefined();\n            await object3.fetch({\n              useMasterKey: true\n            });\n            expect(object3.get('someField')).toEqual('changedValue7');\n            expect((await updateObject(object4.className, object4.id, {\n              someField: 'changedValue7'\n            }, {\n              'X-Parse-Session-Token': user5.getSessionToken()\n            })).data.update.clientMutationId).toBeDefined();\n            await object4.fetch({\n              useMasterKey: true\n            });\n            expect(object4.get('someField')).toEqual('changedValue7');\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should respect level permissions with specific class mutation","suites":["ParseGraphQLServer","Auto API","Schema","Objects Mutations","Update"],"line":5621,"updatePoint":{"line":5621,"column":75,"index":210836},"code":"          it('should respect level permissions with specific class mutation', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            function updateObject(className, id, fields, headers) {\n              const mutationName = className.charAt(0).toLowerCase() + className.slice(1);\n              return apolloClient.mutate({\n                mutation: gql`\n                  mutation UpdateSomeObject(\n                    $id: ID!\n                    $fields: Update${className}FieldsInput\n                  ) {\n                    update${className}(input: {\n                      id: $id\n                      fields: $fields\n                    }) {\n                      ${mutationName} {\n                        updatedAt\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id,\n                  fields\n                },\n                context: {\n                  headers\n                }\n              });\n            }\n            await Promise.all(objects.slice(0, 3).map(async obj => {\n              const originalFieldValue = obj.get('someField');\n              await expectAsync(updateObject(obj.className, obj.id, {\n                someField: 'changedValue1'\n              })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual(originalFieldValue);\n            }));\n            expect((await updateObject(object4.className, object4.id, {\n              someField: 'changedValue1'\n            })).data[`update${object4.className}`][object4.className.charAt(0).toLowerCase() + object4.className.slice(1)].updatedAt).toBeDefined();\n            await object4.fetch({\n              useMasterKey: true\n            });\n            expect(object4.get('someField')).toEqual('changedValue1');\n            await Promise.all(objects.map(async obj => {\n              expect((await updateObject(obj.className, obj.id, {\n                someField: 'changedValue2'\n              }, {\n                'X-Parse-Master-Key': 'test'\n              })).data[`update${obj.className}`][obj.className.charAt(0).toLowerCase() + obj.className.slice(1)].updatedAt).toBeDefined();\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual('changedValue2');\n            }));\n            await Promise.all(objects.map(async obj => {\n              expect((await updateObject(obj.className, obj.id, {\n                someField: 'changedValue3'\n              }, {\n                'X-Parse-Session-Token': user1.getSessionToken()\n              })).data[`update${obj.className}`][obj.className.charAt(0).toLowerCase() + obj.className.slice(1)].updatedAt).toBeDefined();\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual('changedValue3');\n            }));\n            await Promise.all(objects.map(async obj => {\n              expect((await updateObject(obj.className, obj.id, {\n                someField: 'changedValue4'\n              }, {\n                'X-Parse-Session-Token': user2.getSessionToken()\n              })).data[`update${obj.className}`][obj.className.charAt(0).toLowerCase() + obj.className.slice(1)].updatedAt).toBeDefined();\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual('changedValue4');\n            }));\n            await Promise.all([object1, object3, object4].map(async obj => {\n              expect((await updateObject(obj.className, obj.id, {\n                someField: 'changedValue5'\n              }, {\n                'X-Parse-Session-Token': user3.getSessionToken()\n              })).data[`update${obj.className}`][obj.className.charAt(0).toLowerCase() + obj.className.slice(1)].updatedAt).toBeDefined();\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual('changedValue5');\n            }));\n            const originalFieldValue = object2.get('someField');\n            await expectAsync(updateObject(object2.className, object2.id, {\n              someField: 'changedValue5'\n            }, {\n              'X-Parse-Session-Token': user3.getSessionToken()\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            await object2.fetch({\n              useMasterKey: true\n            });\n            expect(object2.get('someField')).toEqual(originalFieldValue);\n            await Promise.all(objects.slice(0, 3).map(async obj => {\n              const originalFieldValue = obj.get('someField');\n              await expectAsync(updateObject(obj.className, obj.id, {\n                someField: 'changedValue6'\n              }, {\n                'X-Parse-Session-Token': user4.getSessionToken()\n              })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual(originalFieldValue);\n            }));\n            expect((await updateObject(object4.className, object4.id, {\n              someField: 'changedValue6'\n            }, {\n              'X-Parse-Session-Token': user4.getSessionToken()\n            })).data[`update${object4.className}`][object4.className.charAt(0).toLowerCase() + object4.className.slice(1)].updatedAt).toBeDefined();\n            await object4.fetch({\n              useMasterKey: true\n            });\n            expect(object4.get('someField')).toEqual('changedValue6');\n            await Promise.all(objects.slice(0, 2).map(async obj => {\n              const originalFieldValue = obj.get('someField');\n              await expectAsync(updateObject(obj.className, obj.id, {\n                someField: 'changedValue7'\n              }, {\n                'X-Parse-Session-Token': user5.getSessionToken()\n              })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual(originalFieldValue);\n            }));\n            expect((await updateObject(object3.className, object3.id, {\n              someField: 'changedValue7'\n            }, {\n              'X-Parse-Session-Token': user5.getSessionToken()\n            })).data[`update${object3.className}`][object3.className.charAt(0).toLowerCase() + object3.className.slice(1)].updatedAt).toBeDefined();\n            await object3.fetch({\n              useMasterKey: true\n            });\n            expect(object3.get('someField')).toEqual('changedValue7');\n            expect((await updateObject(object4.className, object4.id, {\n              someField: 'changedValue7'\n            }, {\n              'X-Parse-Session-Token': user5.getSessionToken()\n            })).data[`update${object4.className}`][object4.className.charAt(0).toLowerCase() + object4.className.slice(1)].updatedAt).toBeDefined();\n            await object4.fetch({\n              useMasterKey: true\n            });\n            expect(object4.get('someField')).toEqual('changedValue7');\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return a specific type using class specific mutation","suites":["ParseGraphQLServer","Auto API","Schema","Objects Mutations","Delete"],"line":5776,"updatePoint":{"line":5776,"column":73,"index":218289},"code":"          it('should return a specific type using class specific mutation', async () => {\n            const clientMutationId = uuidv4();\n            const obj = new Parse.Object('Customer');\n            obj.set('someField1', 'someField1Value1');\n            obj.set('someField2', 'someField2Value1');\n            await obj.save();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation DeleteCustomer($input: DeleteCustomerInput!) {\n                  deleteCustomer(input: $input) {\n                    clientMutationId\n                    customer {\n                      id\n                      objectId\n                      someField1\n                      someField2\n                    }\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  id: obj.id\n                }\n              }\n            });\n            expect(result.data.deleteCustomer.clientMutationId).toEqual(clientMutationId);\n            expect(result.data.deleteCustomer.customer.objectId).toEqual(obj.id);\n            expect(result.data.deleteCustomer.customer.someField1).toEqual('someField1Value1');\n            expect(result.data.deleteCustomer.customer.someField2).toEqual('someField2Value1');\n            await expectAsync(obj.fetch({\n              useMasterKey: true\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should respect level permissions","suites":["ParseGraphQLServer","Auto API","Schema","Objects Mutations","Delete"],"line":5812,"updatePoint":{"line":5812,"column":46,"index":219842},"code":"          it('should respect level permissions', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            function deleteObject(className, id, headers) {\n              const mutationName = className.charAt(0).toLowerCase() + className.slice(1);\n              return apolloClient.mutate({\n                mutation: gql`\n                  mutation DeleteSomeObject(\n                    $id: ID!\n                  ) {\n                    delete: delete${className}(input: { id: $id }) {\n                      ${mutationName} {\n                        objectId\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id\n                },\n                context: {\n                  headers\n                }\n              });\n            }\n            await Promise.all(objects.slice(0, 3).map(async obj => {\n              const originalFieldValue = obj.get('someField');\n              await expectAsync(deleteObject(obj.className, obj.id)).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual(originalFieldValue);\n            }));\n            await Promise.all(objects.slice(0, 3).map(async obj => {\n              const originalFieldValue = obj.get('someField');\n              await expectAsync(deleteObject(obj.className, obj.id, {\n                'X-Parse-Session-Token': user4.getSessionToken()\n              })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual(originalFieldValue);\n            }));\n            expect((await deleteObject(object4.className, object4.id)).data.delete[object4.className.charAt(0).toLowerCase() + object4.className.slice(1)]).toEqual({\n              objectId: object4.id,\n              __typename: 'PublicClass'\n            });\n            await expectAsync(object4.fetch({\n              useMasterKey: true\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect((await deleteObject(object1.className, object1.id, {\n              'X-Parse-Master-Key': 'test'\n            })).data.delete[object1.className.charAt(0).toLowerCase() + object1.className.slice(1)]).toEqual({\n              objectId: object1.id,\n              __typename: 'GraphQLClass'\n            });\n            await expectAsync(object1.fetch({\n              useMasterKey: true\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect((await deleteObject(object2.className, object2.id, {\n              'X-Parse-Session-Token': user2.getSessionToken()\n            })).data.delete[object2.className.charAt(0).toLowerCase() + object2.className.slice(1)]).toEqual({\n              objectId: object2.id,\n              __typename: 'GraphQLClass'\n            });\n            await expectAsync(object2.fetch({\n              useMasterKey: true\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect((await deleteObject(object3.className, object3.id, {\n              'X-Parse-Session-Token': user5.getSessionToken()\n            })).data.delete[object3.className.charAt(0).toLowerCase() + object3.className.slice(1)]).toEqual({\n              objectId: object3.id,\n              __typename: 'GraphQLClass'\n            });\n            await expectAsync(object3.fetch({\n              useMasterKey: true\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should respect level permissions with specific class mutation","suites":["ParseGraphQLServer","Auto API","Schema","Objects Mutations","Delete"],"line":5890,"updatePoint":{"line":5890,"column":75,"index":223619},"code":"          it('should respect level permissions with specific class mutation', async () => {\n            await prepareData();\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            function deleteObject(className, id, headers) {\n              const mutationName = className.charAt(0).toLowerCase() + className.slice(1);\n              return apolloClient.mutate({\n                mutation: gql`\n                  mutation DeleteSomeObject(\n                    $id: ID!\n                  ) {\n                    delete${className}(input: { id: $id }) {\n                      ${mutationName} {\n                        objectId\n                      }\n                    }\n                  }\n                `,\n                variables: {\n                  id\n                },\n                context: {\n                  headers\n                }\n              });\n            }\n            await Promise.all(objects.slice(0, 3).map(async obj => {\n              const originalFieldValue = obj.get('someField');\n              await expectAsync(deleteObject(obj.className, obj.id)).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual(originalFieldValue);\n            }));\n            await Promise.all(objects.slice(0, 3).map(async obj => {\n              const originalFieldValue = obj.get('someField');\n              await expectAsync(deleteObject(obj.className, obj.id, {\n                'X-Parse-Session-Token': user4.getSessionToken()\n              })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n              await obj.fetch({\n                useMasterKey: true\n              });\n              expect(obj.get('someField')).toEqual(originalFieldValue);\n            }));\n            expect((await deleteObject(object4.className, object4.id)).data[`delete${object4.className}`][object4.className.charAt(0).toLowerCase() + object4.className.slice(1)].objectId).toEqual(object4.id);\n            await expectAsync(object4.fetch({\n              useMasterKey: true\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect((await deleteObject(object1.className, object1.id, {\n              'X-Parse-Master-Key': 'test'\n            })).data[`delete${object1.className}`][object1.className.charAt(0).toLowerCase() + object1.className.slice(1)].objectId).toEqual(object1.id);\n            await expectAsync(object1.fetch({\n              useMasterKey: true\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect((await deleteObject(object2.className, object2.id, {\n              'X-Parse-Session-Token': user2.getSessionToken()\n            })).data[`delete${object2.className}`][object2.className.charAt(0).toLowerCase() + object2.className.slice(1)].objectId).toEqual(object2.id);\n            await expectAsync(object2.fetch({\n              useMasterKey: true\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n            expect((await deleteObject(object3.className, object3.id, {\n              'X-Parse-Session-Token': user5.getSessionToken()\n            })).data[`delete${object3.className}`][object3.className.charAt(0).toLowerCase() + object3.className.slice(1)].objectId).toEqual(object3.id);\n            await expectAsync(object3.fetch({\n              useMasterKey: true\n            })).toBeRejectedWith(jasmine.stringMatching('Object not found'));\n          });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should unset fields when null used on update/create","suites":["ParseGraphQLServer","Auto API","Schema","Objects Mutations","Delete"],"line":5957,"updatePoint":{"line":5957,"column":63,"index":227189},"code":"        it('should unset fields when null used on update/create', async () => {\n          const customerSchema = new Parse.Schema('Customer');\n          customerSchema.addString('aString');\n          customerSchema.addBoolean('aBoolean');\n          customerSchema.addDate('aDate');\n          customerSchema.addArray('aArray');\n          customerSchema.addGeoPoint('aGeoPoint');\n          customerSchema.addPointer('aPointer', 'Customer');\n          customerSchema.addObject('aObject');\n          customerSchema.addPolygon('aPolygon');\n          await customerSchema.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const cus = new Parse.Object('Customer');\n          await cus.save({\n            aString: 'hello'\n          });\n          const fields = {\n            aString: \"i'm string\",\n            aBoolean: true,\n            aDate: new Date().toISOString(),\n            aArray: ['hello', 1],\n            aGeoPoint: {\n              latitude: 30,\n              longitude: 30\n            },\n            aPointer: {\n              link: cus.id\n            },\n            aObject: {\n              prop: {\n                subprop: 1\n              },\n              prop2: 'test'\n            },\n            aPolygon: [{\n              latitude: 30,\n              longitude: 30\n            }, {\n              latitude: 31,\n              longitude: 31\n            }, {\n              latitude: 32,\n              longitude: 32\n            }, {\n              latitude: 30,\n              longitude: 30\n            }]\n          };\n          const nullFields = Object.keys(fields).reduce((acc, k) => ({\n            ...acc,\n            [k]: null\n          }), {});\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation CreateCustomer($input: CreateCustomerInput!) {\n                createCustomer(input: $input) {\n                  customer {\n                    id\n                    aString\n                    aBoolean\n                    aDate\n                    aArray {\n                      ... on Element {\n                        value\n                      }\n                    }\n                    aGeoPoint {\n                      longitude\n                      latitude\n                    }\n                    aPointer {\n                      objectId\n                    }\n                    aObject\n                    aPolygon {\n                      longitude\n                      latitude\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                fields\n              }\n            }\n          });\n          const {\n            data: {\n              createCustomer: {\n                customer: {\n                  aPointer,\n                  aArray,\n                  id,\n                  ...otherFields\n                }\n              }\n            }\n          } = result;\n          expect(id).toBeDefined();\n          delete otherFields.__typename;\n          delete otherFields.aGeoPoint.__typename;\n          otherFields.aPolygon.forEach(v => {\n            delete v.__typename;\n          });\n          expect({\n            ...otherFields,\n            aPointer: {\n              link: aPointer.objectId\n            },\n            aArray: aArray.map(({\n              value\n            }) => value)\n          }).toEqual(fields);\n          const updated = await apolloClient.mutate({\n            mutation: gql`\n              mutation UpdateCustomer($input: UpdateCustomerInput!) {\n                updateCustomer(input: $input) {\n                  customer {\n                    aString\n                    aBoolean\n                    aDate\n                    aArray {\n                      ... on Element {\n                        value\n                      }\n                    }\n                    aGeoPoint {\n                      longitude\n                      latitude\n                    }\n                    aPointer {\n                      objectId\n                    }\n                    aObject\n                    aPolygon {\n                      longitude\n                      latitude\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                fields: nullFields,\n                id\n              }\n            }\n          });\n          const {\n            data: {\n              updateCustomer: {\n                customer\n              }\n            }\n          } = updated;\n          delete customer.__typename;\n          expect(Object.keys(customer).length).toEqual(8);\n          Object.keys(customer).forEach(k => {\n            expect(customer[k]).toBeNull();\n          });\n          try {\n            const queryResult = await apolloClient.query({\n              query: gql`\n                query getEmptyCustomer($where: CustomerWhereInput!) {\n                  customers(where: $where) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where: Object.keys(fields).reduce((acc, k) => ({\n                  ...acc,\n                  [k]: {\n                    exists: false\n                  }\n                }), {})\n              }\n            });\n            expect(queryResult.data.customers.edges.length).toEqual(1);\n          } catch (e) {\n            console.error(JSON.stringify(e));\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return current logged user","suites":["ParseGraphQLServer","Auto API","Schema","Users Queries"],"line":6199,"updatePoint":{"line":6199,"column":45,"index":234834},"code":"        it('should return current logged user', async () => {\n          const userName = 'user1',\n            password = 'user1',\n            email = 'emailUser1@parse.com';\n          const user = new Parse.User();\n          user.setUsername(userName);\n          user.setPassword(password);\n          user.setEmail(email);\n          await user.signUp();\n          const session = await Parse.Session.current();\n          const result = await apolloClient.query({\n            query: gql`\n              query GetCurrentUser {\n                viewer {\n                  user {\n                    id\n                    username\n                    email\n                  }\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Session-Token': session.getSessionToken()\n              }\n            }\n          });\n          const {\n            id,\n            username: resultUserName,\n            email: resultEmail\n          } = result.data.viewer.user;\n          expect(id).toBeDefined();\n          expect(resultUserName).toEqual(userName);\n          expect(resultEmail).toEqual(email);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return logged user including pointer","suites":["ParseGraphQLServer","Auto API","Schema","Users Queries"],"line":6236,"updatePoint":{"line":6236,"column":55,"index":236012},"code":"        it('should return logged user including pointer', async () => {\n          const foo = new Parse.Object('Foo');\n          foo.set('bar', 'hello');\n          const userName = 'user1',\n            password = 'user1',\n            email = 'emailUser1@parse.com';\n          const user = new Parse.User();\n          user.setUsername(userName);\n          user.setPassword(password);\n          user.setEmail(email);\n          user.set('userFoo', foo);\n          await user.signUp();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const session = await Parse.Session.current();\n          const result = await apolloClient.query({\n            query: gql`\n              query GetCurrentUser {\n                viewer {\n                  sessionToken\n                  user {\n                    id\n                    objectId\n                    userFoo {\n                      bar\n                    }\n                  }\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Session-Token': session.getSessionToken()\n              }\n            }\n          });\n          const sessionToken = result.data.viewer.sessionToken;\n          const {\n            objectId,\n            userFoo: resultFoo\n          } = result.data.viewer.user;\n          expect(objectId).toEqual(user.id);\n          expect(sessionToken).toBeDefined();\n          expect(resultFoo).toBeDefined();\n          expect(resultFoo.bar).toEqual('hello');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should return logged user and do not by pass pointer security","suites":["ParseGraphQLServer","Auto API","Schema","Users Queries"],"line":6281,"updatePoint":{"line":6281,"column":73,"index":237566},"code":"        it('should return logged user and do not by pass pointer security', async () => {\n          const masterKeyOnlyACL = new Parse.ACL();\n          masterKeyOnlyACL.setPublicReadAccess(false);\n          masterKeyOnlyACL.setPublicWriteAccess(false);\n          const foo = new Parse.Object('Foo');\n          foo.setACL(masterKeyOnlyACL);\n          foo.set('bar', 'hello');\n          await foo.save(null, {\n            useMasterKey: true\n          });\n          const userName = 'userx1',\n            password = 'user1',\n            email = 'emailUserx1@parse.com';\n          const user = new Parse.User();\n          user.setUsername(userName);\n          user.setPassword(password);\n          user.setEmail(email);\n          user.set('userFoo', foo);\n          await user.signUp();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const session = await Parse.Session.current();\n          const result = await apolloClient.query({\n            query: gql`\n              query GetCurrentUser {\n                viewer {\n                  sessionToken\n                  user {\n                    id\n                    objectId\n                    userFoo {\n                      bar\n                    }\n                  }\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Session-Token': session.getSessionToken()\n              }\n            }\n          });\n          const sessionToken = result.data.viewer.sessionToken;\n          const {\n            objectId,\n            userFoo: resultFoo\n          } = result.data.viewer.user;\n          expect(objectId).toEqual(user.id);\n          expect(sessionToken).toBeDefined();\n          expect(resultFoo).toEqual(null);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should sign user up","suites":["ParseGraphQLServer","Auto API","Schema","Users Mutations"],"line":6334,"updatePoint":{"line":6334,"column":31,"index":239363},"code":"        it('should sign user up', async () => {\n          const clientMutationId = uuidv4();\n          const userSchema = new Parse.Schema('_User');\n          userSchema.addString('someField');\n          userSchema.addPointer('aPointer', '_User');\n          await userSchema.update();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation SignUp($input: SignUpInput!) {\n                signUp(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                    user {\n                      someField\n                      aPointer {\n                        id\n                        username\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                fields: {\n                  username: 'user1',\n                  password: 'user1',\n                  aPointer: {\n                    createAndLink: {\n                      username: 'user2',\n                      password: 'user2',\n                      someField: 'someValue2'\n                    }\n                  },\n                  someField: 'someValue'\n                }\n              }\n            }\n          });\n          expect(result.data.signUp.clientMutationId).toEqual(clientMutationId);\n          expect(result.data.signUp.viewer.sessionToken).toBeDefined();\n          expect(result.data.signUp.viewer.user.someField).toEqual('someValue');\n          expect(result.data.signUp.viewer.user.aPointer.id).toBeDefined();\n          expect(result.data.signUp.viewer.user.aPointer.username).toEqual('user2');\n          expect(typeof result.data.signUp.viewer.sessionToken).toBe('string');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should login with user","suites":["ParseGraphQLServer","Auto API","Schema","Users Mutations"],"line":6384,"updatePoint":{"line":6384,"column":34,"index":241272},"code":"        it('should login with user', async () => {\n          const clientMutationId = uuidv4();\n          const userSchema = new Parse.Schema('_User');\n          parseServer = await global.reconfigureServer({\n            publicServerURL: 'http://localhost:13377/parse',\n            auth: {\n              myAuth: {\n                module: global.mockCustomAuthenticator('parse', 'graphql')\n              }\n            }\n          });\n          userSchema.addString('someField');\n          userSchema.addPointer('aPointer', '_User');\n          await userSchema.update();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogInWith($input: LogInWithInput!) {\n                logInWith(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                    user {\n                      someField\n                      aPointer {\n                        id\n                        username\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                authData: {\n                  myAuth: {\n                    id: 'parse',\n                    password: 'graphql'\n                  }\n                },\n                fields: {\n                  someField: 'someValue',\n                  aPointer: {\n                    createAndLink: {\n                      username: 'user2',\n                      password: 'user2',\n                      someField: 'someValue2'\n                    }\n                  }\n                }\n              }\n            }\n          });\n          expect(result.data.logInWith.clientMutationId).toEqual(clientMutationId);\n          expect(result.data.logInWith.viewer.sessionToken).toBeDefined();\n          expect(result.data.logInWith.viewer.user.someField).toEqual('someValue');\n          expect(typeof result.data.logInWith.viewer.sessionToken).toBe('string');\n          expect(result.data.logInWith.viewer.user.aPointer.id).toBeDefined();\n          expect(result.data.logInWith.viewer.user.aPointer.username).toEqual('user2');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should log the user in","suites":["ParseGraphQLServer","Auto API","Schema","Users Mutations"],"line":6446,"updatePoint":{"line":6446,"column":34,"index":243583},"code":"        it('should log the user in', async () => {\n          const clientMutationId = uuidv4();\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          user.set('someField', 'someValue');\n          await user.signUp();\n          await Parse.User.logOut();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogInUser($input: LogInInput!) {\n                logIn(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                    user {\n                      someField\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                username: 'user1',\n                password: 'user1'\n              }\n            }\n          });\n          expect(result.data.logIn.clientMutationId).toEqual(clientMutationId);\n          expect(result.data.logIn.viewer.sessionToken).toBeDefined();\n          expect(result.data.logIn.viewer.user.someField).toEqual('someValue');\n          expect(typeof result.data.logIn.viewer.sessionToken).toBe('string');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should log the user out","suites":["ParseGraphQLServer","Auto API","Schema","Users Mutations"],"line":6482,"updatePoint":{"line":6482,"column":35,"index":244921},"code":"        it('should log the user out', async () => {\n          const clientMutationId = uuidv4();\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          await user.signUp();\n          await Parse.User.logOut();\n          const logIn = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogInUser($input: LogInInput!) {\n                logIn(input: $input) {\n                  viewer {\n                    sessionToken\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                username: 'user1',\n                password: 'user1'\n              }\n            }\n          });\n          const sessionToken = logIn.data.logIn.viewer.sessionToken;\n          const logOut = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogOutUser($input: LogOutInput!) {\n                logOut(input: $input) {\n                  clientMutationId\n                  ok\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Session-Token': sessionToken\n              }\n            },\n            variables: {\n              input: {\n                clientMutationId\n              }\n            }\n          });\n          expect(logOut.data.logOut.clientMutationId).toEqual(clientMutationId);\n          expect(logOut.data.logOut.ok).toEqual(true);\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  viewer {\n                    username\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': sessionToken\n                }\n              }\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const {\n              statusCode,\n              result\n            } = err.networkError;\n            expect(statusCode).toBe(400);\n            expect(result).toEqual({\n              code: 209,\n              error: 'Invalid session token'\n            });\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should send reset password","suites":["ParseGraphQLServer","Auto API","Schema","Users Mutations"],"line":6557,"updatePoint":{"line":6557,"column":38,"index":247194},"code":"        it('should send reset password', async () => {\n          const clientMutationId = uuidv4();\n          const emailAdapter = {\n            sendVerificationEmail: () => {},\n            sendPasswordResetEmail: () => Promise.resolve(),\n            sendMail: () => {}\n          };\n          parseServer = await global.reconfigureServer({\n            appName: 'test',\n            emailAdapter: emailAdapter,\n            publicServerURL: 'http://test.test'\n          });\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          user.setEmail('user1@user1.user1');\n          await user.signUp();\n          await Parse.User.logOut();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation ResetPassword($input: ResetPasswordInput!) {\n                resetPassword(input: $input) {\n                  clientMutationId\n                  ok\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                email: 'user1@user1.user1'\n              }\n            }\n          });\n          expect(result.data.resetPassword.clientMutationId).toEqual(clientMutationId);\n          expect(result.data.resetPassword.ok).toBeTruthy();\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should reset password","suites":["ParseGraphQLServer","Auto API","Schema","Users Mutations"],"line":6594,"updatePoint":{"line":6594,"column":33,"index":248519},"code":"        it('should reset password', async () => {\n          const clientMutationId = uuidv4();\n          let resetPasswordToken;\n          const emailAdapter = {\n            sendVerificationEmail: () => {},\n            sendPasswordResetEmail: ({\n              link\n            }) => {\n              resetPasswordToken = link.split('token=')[1].split('&')[0];\n            },\n            sendMail: () => {}\n          };\n          parseServer = await global.reconfigureServer({\n            appName: 'test',\n            emailAdapter: emailAdapter,\n            publicServerURL: 'http://localhost:13377/parse',\n            auth: {\n              myAuth: {\n                module: global.mockCustomAuthenticator('parse', 'graphql')\n              }\n            }\n          });\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          user.setEmail('user1@user1.user1');\n          await user.signUp();\n          await Parse.User.logOut();\n          await Parse.User.requestPasswordReset('user1@user1.user1');\n          await apolloClient.mutate({\n            mutation: gql`\n              mutation ConfirmResetPassword($input: ConfirmResetPasswordInput!) {\n                confirmResetPassword(input: $input) {\n                  clientMutationId\n                  ok\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                username: 'user1',\n                password: 'newPassword',\n                token: resetPasswordToken\n              }\n            }\n          });\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation LogInUser($input: LogInInput!) {\n                logIn(input: $input) {\n                  clientMutationId\n                  viewer {\n                    sessionToken\n                  }\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                username: 'user1',\n                password: 'newPassword'\n              }\n            }\n          });\n          expect(result.data.logIn.clientMutationId).toEqual(clientMutationId);\n          expect(result.data.logIn.viewer.sessionToken).toBeDefined();\n          expect(typeof result.data.logIn.viewer.sessionToken).toBe('string');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should send verification email again","suites":["ParseGraphQLServer","Auto API","Schema","Users Mutations"],"line":6664,"updatePoint":{"line":6664,"column":48,"index":250933},"code":"        it('should send verification email again', async () => {\n          const clientMutationId = uuidv4();\n          const emailAdapter = {\n            sendVerificationEmail: () => {},\n            sendPasswordResetEmail: () => Promise.resolve(),\n            sendMail: () => {}\n          };\n          parseServer = await global.reconfigureServer({\n            appName: 'test',\n            emailAdapter: emailAdapter,\n            publicServerURL: 'http://test.test'\n          });\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          user.setEmail('user1@user1.user1');\n          await user.signUp();\n          await Parse.User.logOut();\n          const result = await apolloClient.mutate({\n            mutation: gql`\n              mutation SendVerificationEmail($input: SendVerificationEmailInput!) {\n                sendVerificationEmail(input: $input) {\n                  clientMutationId\n                  ok\n                }\n              }\n            `,\n            variables: {\n              input: {\n                clientMutationId,\n                email: 'user1@user1.user1'\n              }\n            }\n          });\n          expect(result.data.sendVerificationEmail.clientMutationId).toEqual(clientMutationId);\n          expect(result.data.sendVerificationEmail.ok).toBeTruthy();\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should fail due to invalid session token","suites":["ParseGraphQLServer","Auto API","Schema","Session Token"],"line":6703,"updatePoint":{"line":6703,"column":52,"index":252367},"code":"        it('should fail due to invalid session token', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  me {\n                    username\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': 'foo'\n                }\n              }\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const {\n              statusCode,\n              result\n            } = err.networkError;\n            expect(statusCode).toBe(400);\n            expect(result).toEqual({\n              code: 209,\n              error: 'Invalid session token'\n            });\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should fail due to empty session token","suites":["ParseGraphQLServer","Auto API","Schema","Session Token"],"line":6732,"updatePoint":{"line":6732,"column":50,"index":253203},"code":"        it('should fail due to empty session token', async () => {\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  viewer {\n                    user {\n                      username\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': ''\n                }\n              }\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const {\n              graphQLErrors\n            } = err;\n            expect(graphQLErrors.length).toBe(1);\n            expect(graphQLErrors[0].message).toBe('Invalid session token');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should find a user and fail due to empty session token","suites":["ParseGraphQLServer","Auto API","Schema","Session Token"],"line":6759,"updatePoint":{"line":6759,"column":66,"index":254036},"code":"        it('should find a user and fail due to empty session token', async () => {\n          const car = new Parse.Object('Car');\n          await car.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          try {\n            await apolloClient.query({\n              query: gql`\n                query GetCurrentUser {\n                  viewer {\n                    user {\n                      username\n                    }\n                  }\n                  cars {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Session-Token': ''\n                }\n              }\n            });\n            fail('should not retrieve current user due to session token');\n          } catch (err) {\n            const {\n              graphQLErrors\n            } = err;\n            expect(graphQLErrors.length).toBe(1);\n            expect(graphQLErrors[0].message).toBe('Invalid session token');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"can be called","suites":["ParseGraphQLServer","Auto API","Schema","Functions Mutations"],"line":6798,"updatePoint":{"line":6798,"column":25,"index":255209},"code":"        it('can be called', async () => {\n          try {\n            const clientMutationId = uuidv4();\n            Parse.Cloud.define('hello', async () => {\n              return 'Hello world!';\n            });\n            const result = await apolloClient.mutate({\n              mutation: gql`\n                mutation CallFunction($input: CallCloudCodeInput!) {\n                  callCloudCode(input: $input) {\n                    clientMutationId\n                    result\n                  }\n                }\n              `,\n              variables: {\n                input: {\n                  clientMutationId,\n                  functionName: 'hello'\n                }\n              }\n            });\n            expect(result.data.callCloudCode.clientMutationId).toEqual(clientMutationId);\n            expect(result.data.callCloudCode.result).toEqual('Hello world!');\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"can throw errors","suites":["ParseGraphQLServer","Auto API","Schema","Functions Mutations"],"line":6826,"updatePoint":{"line":6826,"column":28,"index":256167},"code":"        it('can throw errors', async () => {\n          Parse.Cloud.define('hello', async () => {\n            throw new Error('Some error message.');\n          });\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CallFunction {\n                  callCloudCode(input: { functionName: hello }) {\n                    result\n                  }\n                }\n              `\n            });\n            fail('Should throw an error');\n          } catch (e) {\n            const {\n              graphQLErrors\n            } = e;\n            expect(graphQLErrors.length).toBe(1);\n            expect(graphQLErrors[0].message).toBe('Some error message.');\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should accept different params","suites":["ParseGraphQLServer","Auto API","Schema","Functions Mutations"],"line":6849,"updatePoint":{"line":6849,"column":42,"index":256914},"code":"        it('should accept different params', done => {\n          Parse.Cloud.define('hello', async req => {\n            expect(req.params.date instanceof Date).toBe(true);\n            expect(req.params.date.getTime()).toBe(1463907600000);\n            expect(req.params.dateList[0] instanceof Date).toBe(true);\n            expect(req.params.dateList[0].getTime()).toBe(1463907600000);\n            expect(req.params.complexStructure.date[0] instanceof Date).toBe(true);\n            expect(req.params.complexStructure.date[0].getTime()).toBe(1463907600000);\n            expect(req.params.complexStructure.deepDate.date[0] instanceof Date).toBe(true);\n            expect(req.params.complexStructure.deepDate.date[0].getTime()).toBe(1463907600000);\n            expect(req.params.complexStructure.deepDate2[0].date instanceof Date).toBe(true);\n            expect(req.params.complexStructure.deepDate2[0].date.getTime()).toBe(1463907600000);\n            // Regression for #2294\n            expect(req.params.file instanceof Parse.File).toBe(true);\n            expect(req.params.file.url()).toEqual('https://some.url');\n            // Regression for #2204\n            expect(req.params.array).toEqual(['a', 'b', 'c']);\n            expect(Array.isArray(req.params.array)).toBe(true);\n            expect(req.params.arrayOfArray).toEqual([['a', 'b', 'c'], ['d', 'e', 'f']]);\n            expect(Array.isArray(req.params.arrayOfArray)).toBe(true);\n            expect(Array.isArray(req.params.arrayOfArray[0])).toBe(true);\n            expect(Array.isArray(req.params.arrayOfArray[1])).toBe(true);\n            done();\n          });\n          const params = {\n            date: {\n              __type: 'Date',\n              iso: '2016-05-22T09:00:00.000Z'\n            },\n            dateList: [{\n              __type: 'Date',\n              iso: '2016-05-22T09:00:00.000Z'\n            }],\n            lol: 'hello',\n            complexStructure: {\n              date: [{\n                __type: 'Date',\n                iso: '2016-05-22T09:00:00.000Z'\n              }],\n              deepDate: {\n                date: [{\n                  __type: 'Date',\n                  iso: '2016-05-22T09:00:00.000Z'\n                }]\n              },\n              deepDate2: [{\n                date: {\n                  __type: 'Date',\n                  iso: '2016-05-22T09:00:00.000Z'\n                }\n              }]\n            },\n            file: Parse.File.fromJSON({\n              __type: 'File',\n              name: 'name',\n              url: 'https://some.url'\n            }),\n            array: ['a', 'b', 'c'],\n            arrayOfArray: [['a', 'b', 'c'], ['d', 'e', 'f']]\n          };\n          apolloClient.mutate({\n            mutation: gql`\n              mutation CallFunction($params: Object) {\n                callCloudCode(input: { functionName: hello, params: $params }) {\n                  result\n                }\n              }\n            `,\n            variables: {\n              params\n            }\n          });\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should list all functions in the enum type","suites":["ParseGraphQLServer","Auto API","Schema","Functions Mutations"],"line":6922,"updatePoint":{"line":6922,"column":54,"index":259951},"code":"        it('should list all functions in the enum type', async () => {\n          try {\n            Parse.Cloud.define('a', async () => {\n              return 'hello a';\n            });\n            Parse.Cloud.define('b', async () => {\n              return 'hello b';\n            });\n            Parse.Cloud.define('_underscored', async () => {\n              return 'hello _underscored';\n            });\n            Parse.Cloud.define('contains1Number', async () => {\n              return 'hello contains1Number';\n            });\n            const functionEnum = (await apolloClient.query({\n              query: gql`\n                  query ObjectType {\n                    __type(name: \"CloudCodeFunction\") {\n                      kind\n                      enumValues {\n                        name\n                      }\n                    }\n                  }\n                `\n            })).data['__type'];\n            expect(functionEnum.kind).toEqual('ENUM');\n            expect(functionEnum.enumValues.map(value => value.name).sort()).toEqual(['_underscored', 'a', 'b', 'contains1Number']);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should warn functions not matching GraphQL allowed names","suites":["ParseGraphQLServer","Auto API","Schema","Functions Mutations"],"line":6954,"updatePoint":{"line":6954,"column":68,"index":261144},"code":"        it('should warn functions not matching GraphQL allowed names', async () => {\n          try {\n            spyOn(parseGraphQLServer.parseGraphQLSchema.log, 'warn').and.callThrough();\n            Parse.Cloud.define('a', async () => {\n              return 'hello a';\n            });\n            Parse.Cloud.define('double-barrelled', async () => {\n              return 'hello b';\n            });\n            Parse.Cloud.define('1NumberInTheBeggning', async () => {\n              return 'hello contains1Number';\n            });\n            const functionEnum = (await apolloClient.query({\n              query: gql`\n                  query ObjectType {\n                    __type(name: \"CloudCodeFunction\") {\n                      kind\n                      enumValues {\n                        name\n                      }\n                    }\n                  }\n                `\n            })).data['__type'];\n            expect(functionEnum.kind).toEqual('ENUM');\n            expect(functionEnum.enumValues.map(value => value.name).sort()).toEqual(['a']);\n            expect(parseGraphQLServer.parseGraphQLSchema.log.warn.calls.all().map(call => call.args[0]).sort()).toEqual(['Function 1NumberInTheBeggning could not be added to the auto schema because GraphQL names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/.', 'Function double-barrelled could not be added to the auto schema because GraphQL names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/.']);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support String","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":6987,"updatePoint":{"line":6987,"column":33,"index":262680},"code":"        it('should support String', async () => {\n          try {\n            const someFieldValue = 'some string';\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(input: { name: \"SomeClass\", schemaFields: $schemaFields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addStrings: [{\n                    name: 'someField'\n                  }]\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('String');\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue\n                }\n              }\n            });\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: String) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(where: { someField: { equalTo: $someFieldValue } }) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValue\n              }\n            });\n            expect(typeof getResult.data.someClass.someField).toEqual('string');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support Int numbers","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":7057,"updatePoint":{"line":7057,"column":38,"index":265180},"code":"        it('should support Int numbers', async () => {\n          try {\n            const someFieldValue = 123;\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(input: { name: \"SomeClass\", schemaFields: $schemaFields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addNumbers: [{\n                    name: 'someField'\n                  }]\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue\n                }\n              }\n            });\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Number');\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: Float) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(where: { someField: { equalTo: $someFieldValue } }) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValue\n              }\n            });\n            expect(typeof getResult.data.someClass.someField).toEqual('number');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support Float numbers","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":7127,"updatePoint":{"line":7127,"column":40,"index":267671},"code":"        it('should support Float numbers', async () => {\n          try {\n            const someFieldValue = 123.4;\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(input: { name: \"SomeClass\", schemaFields: $schemaFields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addNumbers: [{\n                    name: 'someField'\n                  }]\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Number');\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue\n                }\n              }\n            });\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: Float) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(where: { someField: { equalTo: $someFieldValue } }) {\n                    edges {\n                      node {\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValue\n              }\n            });\n            expect(typeof getResult.data.someClass.someField).toEqual('number');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support Boolean","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":7197,"updatePoint":{"line":7197,"column":34,"index":270158},"code":"        it('should support Boolean', async () => {\n          try {\n            const someFieldValueTrue = true;\n            const someFieldValueFalse = false;\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(input: { name: \"SomeClass\", schemaFields: $schemaFields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addBooleans: [{\n                    name: 'someFieldTrue'\n                  }, {\n                    name: 'someFieldFalse'\n                  }]\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someFieldTrue.type).toEqual('Boolean');\n            expect(schema.fields.someFieldFalse.type).toEqual('Boolean');\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someFieldTrue: someFieldValueTrue,\n                  someFieldFalse: someFieldValueFalse\n                }\n              }\n            });\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject(\n                  $id: ID!\n                  $someFieldValueTrue: Boolean\n                  $someFieldValueFalse: Boolean\n                ) {\n                  someClass(id: $id) {\n                    someFieldTrue\n                    someFieldFalse\n                  }\n                  someClasses(\n                    where: {\n                      someFieldTrue: { equalTo: $someFieldValueTrue }\n                      someFieldFalse: { equalTo: $someFieldValueFalse }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                someFieldValueTrue,\n                someFieldValueFalse\n              }\n            });\n            expect(typeof getResult.data.someClass.someFieldTrue).toEqual('boolean');\n            expect(typeof getResult.data.someClass.someFieldFalse).toEqual('boolean');\n            expect(getResult.data.someClass.someFieldTrue).toEqual(true);\n            expect(getResult.data.someClass.someFieldFalse).toEqual(false);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support Date","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":7285,"updatePoint":{"line":7285,"column":31,"index":273409},"code":"        it('should support Date', async () => {\n          try {\n            const someFieldValue = new Date();\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(input: { name: \"SomeClass\", schemaFields: $schemaFields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addDates: [{\n                    name: 'someField'\n                  }]\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Date');\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: someFieldValue\n                }\n              }\n            });\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(where: { someField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id\n              }\n            });\n            expect(new Date(getResult.data.someClass.someField)).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support createdAt and updatedAt","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":7353,"updatePoint":{"line":7353,"column":50,"index":275767},"code":"        it('should support createdAt and updatedAt', async () => {\n          await apolloClient.mutate({\n            mutation: gql`\n              mutation CreateClass {\n                createClass(input: { name: \"SomeClass\" }) {\n                  clientMutationId\n                }\n              }\n            `,\n            context: {\n              headers: {\n                'X-Parse-Master-Key': 'test'\n              }\n            }\n          });\n          const schema = await new Parse.Schema('SomeClass').get();\n          expect(schema.fields.createdAt.type).toEqual('Date');\n          expect(schema.fields.updatedAt.type).toEqual('Date');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support ACL","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":7372,"updatePoint":{"line":7372,"column":30,"index":276405},"code":"        it('should support ACL', async () => {\n          const someClass = new Parse.Object('SomeClass');\n          await someClass.save();\n          const user = new Parse.User();\n          user.set('username', 'username');\n          user.set('password', 'password');\n          await user.signUp();\n          const user2 = new Parse.User();\n          user2.set('username', 'username2');\n          user2.set('password', 'password2');\n          await user2.signUp();\n          const roleACL = new Parse.ACL();\n          roleACL.setPublicReadAccess(true);\n          const role = new Parse.Role('aRole', roleACL);\n          await role.save();\n          const role2 = new Parse.Role('aRole2', roleACL);\n          await role2.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const gqlUser = (await apolloClient.query({\n            query: gql`\n                query getUser($id: ID!) {\n                  user(id: $id) {\n                    id\n                  }\n                }\n              `,\n            variables: {\n              id: user.id\n            }\n          })).data.user;\n          const {\n            data: {\n              createSomeClass\n            }\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Create($fields: CreateSomeClassFieldsInput) {\n                createSomeClass(input: { fields: $fields }) {\n                  someClass {\n                    id\n                    objectId\n                    ACL {\n                      users {\n                        userId\n                        read\n                        write\n                      }\n                      roles {\n                        roleName\n                        read\n                        write\n                      }\n                      public {\n                        read\n                        write\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                ACL: {\n                  users: [{\n                    userId: gqlUser.id,\n                    read: true,\n                    write: true\n                  }, {\n                    userId: user2.id,\n                    read: true,\n                    write: false\n                  }],\n                  roles: [{\n                    roleName: 'aRole',\n                    read: true,\n                    write: false\n                  }, {\n                    roleName: 'aRole2',\n                    read: false,\n                    write: true\n                  }],\n                  public: {\n                    read: true,\n                    write: true\n                  }\n                }\n              }\n            }\n          });\n          const expectedCreateACL = {\n            __typename: 'ACL',\n            users: [{\n              userId: toGlobalId('_User', user.id),\n              read: true,\n              write: true,\n              __typename: 'UserACL'\n            }, {\n              userId: toGlobalId('_User', user2.id),\n              read: true,\n              write: false,\n              __typename: 'UserACL'\n            }],\n            roles: [{\n              roleName: 'aRole',\n              read: true,\n              write: false,\n              __typename: 'RoleACL'\n            }, {\n              roleName: 'aRole2',\n              read: false,\n              write: true,\n              __typename: 'RoleACL'\n            }],\n            public: {\n              read: true,\n              write: true,\n              __typename: 'PublicACL'\n            }\n          };\n          const query1 = new Parse.Query('SomeClass');\n          const obj1 = (await query1.get(createSomeClass.someClass.objectId, {\n            useMasterKey: true\n          })).toJSON();\n          expect(obj1.ACL[user.id]).toEqual({\n            read: true,\n            write: true\n          });\n          expect(obj1.ACL[user2.id]).toEqual({\n            read: true\n          });\n          expect(obj1.ACL['role:aRole']).toEqual({\n            read: true\n          });\n          expect(obj1.ACL['role:aRole2']).toEqual({\n            write: true\n          });\n          expect(obj1.ACL['*']).toEqual({\n            read: true,\n            write: true\n          });\n          expect(createSomeClass.someClass.ACL).toEqual(expectedCreateACL);\n          const {\n            data: {\n              updateSomeClass\n            }\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Update($id: ID!, $fields: UpdateSomeClassFieldsInput) {\n                updateSomeClass(input: { id: $id, fields: $fields }) {\n                  someClass {\n                    id\n                    objectId\n                    ACL {\n                      users {\n                        userId\n                        read\n                        write\n                      }\n                      roles {\n                        roleName\n                        read\n                        write\n                      }\n                      public {\n                        read\n                        write\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: createSomeClass.someClass.id,\n              fields: {\n                ACL: {\n                  roles: [{\n                    roleName: 'aRole',\n                    write: true,\n                    read: true\n                  }],\n                  public: {\n                    read: true,\n                    write: false\n                  }\n                }\n              }\n            }\n          });\n          const expectedUpdateACL = {\n            __typename: 'ACL',\n            users: null,\n            roles: [{\n              roleName: 'aRole',\n              read: true,\n              write: true,\n              __typename: 'RoleACL'\n            }],\n            public: {\n              read: true,\n              write: false,\n              __typename: 'PublicACL'\n            }\n          };\n          const query2 = new Parse.Query('SomeClass');\n          const obj2 = (await query2.get(createSomeClass.someClass.objectId, {\n            useMasterKey: true\n          })).toJSON();\n          expect(obj2.ACL['role:aRole']).toEqual({\n            write: true,\n            read: true\n          });\n          expect(obj2.ACL[user.id]).toBeUndefined();\n          expect(obj2.ACL['*']).toEqual({\n            read: true\n          });\n          expect(updateSomeClass.someClass.ACL).toEqual(expectedUpdateACL);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support pointer on create","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":7591,"updatePoint":{"line":7591,"column":44,"index":283096},"code":"        it('should support pointer on create', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n          const company2 = new Parse.Object('Company');\n          company2.set('name', 'imACompany2');\n          await company2.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const {\n            data: {\n              createCountry: {\n                country: result\n              }\n            }\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Create($fields: CreateCountryFieldsInput) {\n                createCountry(input: { fields: $fields }) {\n                  country {\n                    id\n                    objectId\n                    company {\n                      id\n                      objectId\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                name: 'imCountry2',\n                company: {\n                  link: company2.id\n                }\n              }\n            }\n          });\n          expect(result.id).toBeDefined();\n          expect(result.company.objectId).toEqual(company2.id);\n          expect(result.company.name).toEqual('imACompany2');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support nested pointer on create","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":7638,"updatePoint":{"line":7638,"column":51,"index":284685},"code":"        it('should support nested pointer on create', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const {\n            data: {\n              createCountry: {\n                country: result\n              }\n            }\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Create($fields: CreateCountryFieldsInput) {\n                createCountry(input: { fields: $fields }) {\n                  country {\n                    id\n                    company {\n                      id\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              fields: {\n                name: 'imCountry2',\n                company: {\n                  createAndLink: {\n                    name: 'imACompany2'\n                  }\n                }\n              }\n            }\n          });\n          expect(result.id).toBeDefined();\n          expect(result.company.id).toBeDefined();\n          expect(result.company.name).toEqual('imACompany2');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support pointer on update","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":7682,"updatePoint":{"line":7682,"column":44,"index":286117},"code":"        it('should support pointer on update', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n          const company2 = new Parse.Object('Company');\n          company2.set('name', 'imACompany2');\n          await company2.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const {\n            data: {\n              updateCountry: {\n                country: result\n              }\n            }\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Update($id: ID!, $fields: UpdateCountryFieldsInput) {\n                updateCountry(input: { id: $id, fields: $fields }) {\n                  country {\n                    id\n                    objectId\n                    company {\n                      id\n                      objectId\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: country.id,\n              fields: {\n                company: {\n                  link: company2.id\n                }\n              }\n            }\n          });\n          expect(result.id).toBeDefined();\n          expect(result.company.objectId).toEqual(company2.id);\n          expect(result.company.name).toEqual('imACompany2');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support nested pointer on update","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":7729,"updatePoint":{"line":7729,"column":51,"index":287719},"code":"        it('should support nested pointer on update', async () => {\n          const company = new Parse.Object('Company');\n          company.set('name', 'imACompany1');\n          await company.save();\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.set('company', company);\n          await country.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const {\n            data: {\n              updateCountry: {\n                country: result\n              }\n            }\n          } = await apolloClient.mutate({\n            mutation: gql`\n              mutation Update($id: ID!, $fields: UpdateCountryFieldsInput) {\n                updateCountry(input: { id: $id, fields: $fields }) {\n                  country {\n                    id\n                    company {\n                      id\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: country.id,\n              fields: {\n                company: {\n                  createAndLink: {\n                    name: 'imACompany2'\n                  }\n                }\n              }\n            }\n          });\n          expect(result.id).toBeDefined();\n          expect(result.company.id).toBeDefined();\n          expect(result.company.name).toEqual('imACompany2');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support relational where query","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":8102,"updatePoint":{"line":8102,"column":49,"index":300845},"code":"        it('should support relational where query', async () => {\n          const president = new Parse.Object('President');\n          president.set('name', 'James');\n          await president.save();\n          const employee = new Parse.Object('Employee');\n          employee.set('name', 'John');\n          await employee.save();\n          const company1 = new Parse.Object('Company');\n          company1.set('name', 'imACompany1');\n          await company1.save();\n          const company2 = new Parse.Object('Company');\n          company2.set('name', 'imACompany2');\n          company2.relation('employees').add([employee]);\n          await company2.save();\n          const country = new Parse.Object('Country');\n          country.set('name', 'imACountry');\n          country.relation('companies').add([company1, company2]);\n          await country.save();\n          const country2 = new Parse.Object('Country');\n          country2.set('name', 'imACountry2');\n          country2.relation('companies').add([company1]);\n          await country2.save();\n          const country3 = new Parse.Object('Country');\n          country3.set('name', 'imACountry3');\n          country3.set('president', president);\n          await country3.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          let {\n            data: {\n              countries: {\n                edges: result\n              }\n            }\n          } = await apolloClient.query({\n            query: gql`\n              query findCountry($where: CountryWhereInput) {\n                countries(where: $where) {\n                  edges {\n                    node {\n                      id\n                      objectId\n                      companies {\n                        edges {\n                          node {\n                            id\n                            objectId\n                            name\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              where: {\n                companies: {\n                  have: {\n                    employees: {\n                      have: {\n                        name: {\n                          equalTo: 'John'\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          });\n          expect(result.length).toEqual(1);\n          result = result[0].node;\n          expect(result.objectId).toEqual(country.id);\n          expect(result.companies.edges.length).toEqual(2);\n          const {\n            data: {\n              countries: {\n                edges: result2\n              }\n            }\n          } = await apolloClient.query({\n            query: gql`\n              query findCountry($where: CountryWhereInput) {\n                countries(where: $where) {\n                  edges {\n                    node {\n                      id\n                      objectId\n                      companies {\n                        edges {\n                          node {\n                            id\n                            objectId\n                            name\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              where: {\n                companies: {\n                  have: {\n                    OR: [{\n                      name: {\n                        equalTo: 'imACompany1'\n                      }\n                    }, {\n                      name: {\n                        equalTo: 'imACompany2'\n                      }\n                    }]\n                  }\n                }\n              }\n            }\n          });\n          expect(result2.length).toEqual(2);\n          const {\n            data: {\n              countries: {\n                edges: result3\n              }\n            }\n          } = await apolloClient.query({\n            query: gql`\n              query findCountry($where: CountryWhereInput) {\n                countries(where: $where) {\n                  edges {\n                    node {\n                      id\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              where: {\n                companies: {\n                  exists: false\n                }\n              }\n            }\n          });\n          expect(result3.length).toEqual(1);\n          expect(result3[0].node.name).toEqual('imACountry3');\n          const {\n            data: {\n              countries: {\n                edges: result4\n              }\n            }\n          } = await apolloClient.query({\n            query: gql`\n              query findCountry($where: CountryWhereInput) {\n                countries(where: $where) {\n                  edges {\n                    node {\n                      id\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              where: {\n                president: {\n                  exists: false\n                }\n              }\n            }\n          });\n          expect(result4.length).toEqual(2);\n          const {\n            data: {\n              countries: {\n                edges: result5\n              }\n            }\n          } = await apolloClient.query({\n            query: gql`\n              query findCountry($where: CountryWhereInput) {\n                countries(where: $where) {\n                  edges {\n                    node {\n                      id\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              where: {\n                president: {\n                  exists: true\n                }\n              }\n            }\n          });\n          expect(result5.length).toEqual(1);\n          const {\n            data: {\n              countries: {\n                edges: result6\n              }\n            }\n          } = await apolloClient.query({\n            query: gql`\n              query findCountry($where: CountryWhereInput) {\n                countries(where: $where) {\n                  edges {\n                    node {\n                      id\n                      objectId\n                      name\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              where: {\n                companies: {\n                  haveNot: {\n                    OR: [{\n                      name: {\n                        equalTo: 'imACompany1'\n                      }\n                    }, {\n                      name: {\n                        equalTo: 'imACompany2'\n                      }\n                    }]\n                  }\n                }\n              }\n            }\n          });\n          expect(result6.length).toEqual(1);\n          expect(result6.length).toEqual(1);\n          expect(result6[0].node.name).toEqual('imACountry3');\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support object values","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":8602,"updatePoint":{"line":8602,"column":40,"index":317881},"code":"        it('should support object values', async () => {\n          try {\n            const someObjectFieldValue = {\n              foo: {\n                bar: 'baz'\n              },\n              number: 10\n            };\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(input: { name: \"SomeClass\", schemaFields: $schemaFields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addObjects: [{\n                    name: 'someObjectField'\n                  }]\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someObjectField.type).toEqual('Object');\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someObjectField: someObjectFieldValue\n                }\n              }\n            });\n            const where = {\n              someObjectField: {\n                equalTo: {\n                  key: 'foo.bar',\n                  value: 'baz'\n                },\n                notEqualTo: {\n                  key: 'foo.bar',\n                  value: 'bat'\n                },\n                greaterThan: {\n                  key: 'number',\n                  value: 9\n                },\n                lessThan: {\n                  key: 'number',\n                  value: 11\n                }\n              }\n            };\n            const queryResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $where: SomeClassWhereInput) {\n                  someClass(id: $id) {\n                    id\n                    someObjectField\n                  }\n                  someClasses(where: $where) {\n                    edges {\n                      node {\n                        id\n                        someObjectField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                where\n              }\n            });\n            const {\n              someClass: getResult,\n              someClasses\n            } = queryResult.data;\n            const {\n              someObjectField\n            } = getResult;\n            expect(typeof someObjectField).toEqual('object');\n            expect(someObjectField).toEqual(someObjectFieldValue);\n\n            // Checks class query results\n            expect(someClasses.edges.length).toEqual(1);\n            expect(someClasses.edges[0].node.someObjectField).toEqual(someObjectFieldValue);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support where argument on object field that contains false boolean value or 0 number value","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":8709,"updatePoint":{"line":8709,"column":109,"index":321412},"code":"        it('should support where argument on object field that contains false boolean value or 0 number value', async () => {\n          try {\n            const someObjectFieldValue1 = {\n              foo: {\n                bar: true,\n                baz: 100\n              }\n            };\n            const someObjectFieldValue2 = {\n              foo: {\n                bar: false,\n                baz: 0\n              }\n            };\n            const object1 = new Parse.Object('SomeClass');\n            await object1.save({\n              someObjectField: someObjectFieldValue1\n            });\n            const object2 = new Parse.Object('SomeClass');\n            await object2.save({\n              someObjectField: someObjectFieldValue2\n            });\n            const whereToObject1 = {\n              someObjectField: {\n                equalTo: {\n                  key: 'foo.bar',\n                  value: true\n                },\n                notEqualTo: {\n                  key: 'foo.baz',\n                  value: 0\n                }\n              }\n            };\n            const whereToObject2 = {\n              someObjectField: {\n                notEqualTo: {\n                  key: 'foo.bar',\n                  value: true\n                },\n                equalTo: {\n                  key: 'foo.baz',\n                  value: 0\n                }\n              }\n            };\n            const whereToAll = {\n              someObjectField: {\n                lessThan: {\n                  key: 'foo.baz',\n                  value: 101\n                }\n              }\n            };\n            const whereToNone = {\n              someObjectField: {\n                notEqualTo: {\n                  key: 'foo.bar',\n                  value: true\n                },\n                equalTo: {\n                  key: 'foo.baz',\n                  value: 1\n                }\n              }\n            };\n            const queryResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject(\n                  $id1: ID!\n                  $id2: ID!\n                  $whereToObject1: SomeClassWhereInput\n                  $whereToObject2: SomeClassWhereInput\n                  $whereToAll: SomeClassWhereInput\n                  $whereToNone: SomeClassWhereInput\n                ) {\n                  obj1: someClass(id: $id1) {\n                    id\n                    someObjectField\n                  }\n                  obj2: someClass(id: $id2) {\n                    id\n                    someObjectField\n                  }\n                  onlyObj1: someClasses(where: $whereToObject1) {\n                    edges {\n                      node {\n                        id\n                        someObjectField\n                      }\n                    }\n                  }\n                  onlyObj2: someClasses(where: $whereToObject2) {\n                    edges {\n                      node {\n                        id\n                        someObjectField\n                      }\n                    }\n                  }\n                  all: someClasses(where: $whereToAll) {\n                    edges {\n                      node {\n                        id\n                        someObjectField\n                      }\n                    }\n                  }\n                  none: someClasses(where: $whereToNone) {\n                    edges {\n                      node {\n                        id\n                        someObjectField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id1: object1.id,\n                id2: object2.id,\n                whereToObject1,\n                whereToObject2,\n                whereToAll,\n                whereToNone\n              }\n            });\n            const {\n              obj1,\n              obj2,\n              onlyObj1,\n              onlyObj2,\n              all,\n              none\n            } = queryResult.data;\n            expect(obj1.someObjectField).toEqual(someObjectFieldValue1);\n            expect(obj2.someObjectField).toEqual(someObjectFieldValue2);\n\n            // Checks class query results\n            expect(onlyObj1.edges.length).toEqual(1);\n            expect(onlyObj1.edges[0].node.someObjectField).toEqual(someObjectFieldValue1);\n            expect(onlyObj2.edges.length).toEqual(1);\n            expect(onlyObj2.edges[0].node.someObjectField).toEqual(someObjectFieldValue2);\n            expect(all.edges.length).toEqual(2);\n            expect(none.edges.length).toEqual(0);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support object composed queries","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":8858,"updatePoint":{"line":8858,"column":50,"index":326058},"code":"        it('should support object composed queries', async () => {\n          try {\n            const someObjectFieldValue1 = {\n              lorem: 'ipsum',\n              number: 10\n            };\n            const someObjectFieldValue2 = {\n              foo: {\n                test: 'bar'\n              },\n              number: 10\n            };\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: { addObjects: [{ name: \"someObjectField\" }] }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject(\n                  $fields1: CreateSomeClassFieldsInput\n                  $fields2: CreateSomeClassFieldsInput\n                ) {\n                  create1: createSomeClass(input: { fields: $fields1 }) {\n                    someClass {\n                      id\n                    }\n                  }\n                  create2: createSomeClass(input: { fields: $fields2 }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields1: {\n                  someObjectField: someObjectFieldValue1\n                },\n                fields2: {\n                  someObjectField: someObjectFieldValue2\n                }\n              }\n            });\n            const where = {\n              AND: [{\n                someObjectField: {\n                  greaterThan: {\n                    key: 'number',\n                    value: 9\n                  }\n                }\n              }, {\n                someObjectField: {\n                  lessThan: {\n                    key: 'number',\n                    value: 11\n                  }\n                }\n              }, {\n                OR: [{\n                  someObjectField: {\n                    equalTo: {\n                      key: 'lorem',\n                      value: 'ipsum'\n                    }\n                  }\n                }, {\n                  someObjectField: {\n                    equalTo: {\n                      key: 'foo.test',\n                      value: 'bar'\n                    }\n                  }\n                }]\n              }]\n            };\n            const findResult = await apolloClient.query({\n              query: gql`\n                query FindSomeObject($where: SomeClassWhereInput) {\n                  someClasses(where: $where) {\n                    edges {\n                      node {\n                        id\n                        someObjectField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                where\n              }\n            });\n            const {\n              create1,\n              create2\n            } = createResult.data;\n            const {\n              someClasses\n            } = findResult.data;\n\n            // Checks class query results\n            const {\n              edges\n            } = someClasses;\n            expect(edges.length).toEqual(2);\n            expect(edges.find(result => result.node.id === create1.someClass.id).node.someObjectField).toEqual(someObjectFieldValue1);\n            expect(edges.find(result => result.node.id === create2.someClass.id).node.someObjectField).toEqual(someObjectFieldValue2);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support array values","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":8986,"updatePoint":{"line":8986,"column":39,"index":330029},"code":"        it('should support array values', async () => {\n          try {\n            const someArrayFieldValue = [1, 'foo', ['bar'], {\n              lorem: 'ipsum'\n            }, true];\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(input: { name: \"SomeClass\", schemaFields: $schemaFields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addArrays: [{\n                    name: 'someArrayField'\n                  }]\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someArrayField.type).toEqual('Array');\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someArrayField: someArrayFieldValue\n                }\n              }\n            });\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someArrayField {\n                      ... on Element {\n                        value\n                      }\n                    }\n                  }\n                  someClasses(where: { someArrayField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                        someArrayField {\n                          ... on Element {\n                            value\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id\n              }\n            });\n            const {\n              someArrayField\n            } = getResult.data.someClass;\n            expect(Array.isArray(someArrayField)).toBeTruthy();\n            expect(someArrayField.map(element => element.value)).toEqual(someArrayFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support undefined array","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":9069,"updatePoint":{"line":9069,"column":42,"index":332926},"code":"        it('should support undefined array', async () => {\n          const schema = await new Parse.Schema('SomeClass');\n          schema.addArray('someArray');\n          await schema.save();\n          const obj = new Parse.Object('SomeClass');\n          await obj.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                someClass(id: $id) {\n                  id\n                  someArray {\n                    ... on Element {\n                      value\n                    }\n                  }\n                }\n              }\n            `,\n            variables: {\n              id: obj.id\n            }\n          });\n          expect(getResult.data.someClass.someArray).toEqual(null);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support null values","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":9095,"updatePoint":{"line":9095,"column":38,"index":333797},"code":"        it('should support null values', async () => {\n          try {\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass {\n                  createClass(\n                    input: {\n                      name: \"SomeClass\"\n                      schemaFields: {\n                        addStrings: [{ name: \"someStringField\" }, { name: \"someNullField\" }]\n                        addNumbers: [{ name: \"someNumberField\" }]\n                        addBooleans: [{ name: \"someBooleanField\" }]\n                        addObjects: [{ name: \"someObjectField\" }]\n                      }\n                    }\n                  ) {\n                    clientMutationId\n                  }\n                }\n              `,\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someStringField: 'some string',\n                  someNumberField: 123,\n                  someBooleanField: true,\n                  someObjectField: {\n                    someField: 'some value'\n                  },\n                  someNullField: null\n                }\n              }\n            });\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation UpdateSomeObject($id: ID!, $fields: UpdateSomeClassFieldsInput) {\n                  updateSomeClass(input: { id: $id, fields: $fields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id,\n                fields: {\n                  someStringField: null,\n                  someNumberField: null,\n                  someBooleanField: null,\n                  someObjectField: null,\n                  someNullField: 'now it has a string'\n                }\n              }\n            });\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someStringField\n                    someNumberField\n                    someBooleanField\n                    someObjectField\n                    someNullField\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id\n              }\n            });\n            expect(getResult.data.someClass.someStringField).toBeFalsy();\n            expect(getResult.data.someClass.someNumberField).toBeFalsy();\n            expect(getResult.data.someClass.someBooleanField).toBeFalsy();\n            expect(getResult.data.someClass.someObjectField).toBeFalsy();\n            expect(getResult.data.someClass.someNullField).toEqual('now it has a string');\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support Bytes","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":9188,"updatePoint":{"line":9188,"column":32,"index":337241},"code":"        it('should support Bytes', async () => {\n          try {\n            const someFieldValue = 'aGVsbG8gd29ybGQ=';\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(input: { name: \"SomeClass\", schemaFields: $schemaFields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addBytes: [{\n                    name: 'someField'\n                  }]\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('Bytes');\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject(\n                  $fields1: CreateSomeClassFieldsInput\n                  $fields2: CreateSomeClassFieldsInput\n                ) {\n                  createSomeClass1: createSomeClass(input: { fields: $fields1 }) {\n                    someClass {\n                      id\n                    }\n                  }\n                  createSomeClass2: createSomeClass(input: { fields: $fields2 }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields1: {\n                  someField: someFieldValue\n                },\n                fields2: {\n                  someField: someFieldValue\n                }\n              }\n            });\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!, $someFieldValue: Bytes) {\n                  someClass(id: $id) {\n                    someField\n                  }\n                  someClasses(where: { someField: { equalTo: $someFieldValue } }) {\n                    edges {\n                      node {\n                        id\n                        someField\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass1.someClass.id,\n                someFieldValue\n              }\n            });\n            expect(typeof getResult.data.someClass.someField).toEqual('string');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(2);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support Geo Points","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":9270,"updatePoint":{"line":9270,"column":37,"index":340153},"code":"        it('should support Geo Points', async () => {\n          try {\n            const someFieldValue = {\n              __typename: 'GeoPoint',\n              latitude: 45,\n              longitude: 45\n            };\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(input: { name: \"SomeClass\", schemaFields: $schemaFields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addGeoPoint: {\n                    name: 'someField'\n                  }\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.someField.type).toEqual('GeoPoint');\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  someField: {\n                    latitude: someFieldValue.latitude,\n                    longitude: someFieldValue.longitude\n                  }\n                }\n              }\n            });\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    someField {\n                      latitude\n                      longitude\n                    }\n                  }\n                  someClasses(where: { someField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                        someField {\n                          latitude\n                          longitude\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id\n              }\n            });\n            expect(typeof getResult.data.someClass.someField).toEqual('object');\n            expect(getResult.data.someClass.someField).toEqual(someFieldValue);\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n            const getGeoWhere = await apolloClient.query({\n              query: gql`\n                query GeoQuery($latitude: Float!, $longitude: Float!) {\n                  nearSphere: someClasses(\n                    where: {\n                      someField: { nearSphere: { latitude: $latitude, longitude: $longitude } }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                  geoWithin: someClasses(\n                    where: {\n                      someField: {\n                        geoWithin: {\n                          centerSphere: {\n                            distance: 10\n                            center: { latitude: $latitude, longitude: $longitude }\n                          }\n                        }\n                      }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                  within: someClasses(\n                    where: {\n                      someField: {\n                        within: {\n                          box: {\n                            bottomLeft: { latitude: $latitude, longitude: $longitude }\n                            upperRight: { latitude: $latitude, longitude: $longitude }\n                          }\n                        }\n                      }\n                    }\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                latitude: 45,\n                longitude: 45\n              }\n            });\n            expect(getGeoWhere.data.nearSphere.edges[0].node.id).toEqual(createResult.data.createSomeClass.someClass.id);\n            expect(getGeoWhere.data.geoWithin.edges[0].node.id).toEqual(createResult.data.createSomeClass.someClass.id);\n            expect(getGeoWhere.data.within.edges[0].node.id).toEqual(createResult.data.createSomeClass.someClass.id);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support Polygons","suites":["ParseGraphQLServer","Auto API","Schema","Data Types"],"line":9413,"updatePoint":{"line":9413,"column":35,"index":345240},"code":"        it('should support Polygons', async () => {\n          try {\n            const somePolygonFieldValue = [[44, 45], [46, 47], [48, 49], [44, 45]].map(point => ({\n              latitude: point[0],\n              longitude: point[1]\n            }));\n            await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateClass($schemaFields: SchemaFieldsInput) {\n                  createClass(input: { name: \"SomeClass\", schemaFields: $schemaFields }) {\n                    clientMutationId\n                  }\n                }\n              `,\n              variables: {\n                schemaFields: {\n                  addPolygons: [{\n                    name: 'somePolygonField'\n                  }]\n                }\n              },\n              context: {\n                headers: {\n                  'X-Parse-Master-Key': 'test'\n                }\n              }\n            });\n            await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n            const schema = await new Parse.Schema('SomeClass').get();\n            expect(schema.fields.somePolygonField.type).toEqual('Polygon');\n            const createResult = await apolloClient.mutate({\n              mutation: gql`\n                mutation CreateSomeObject($fields: CreateSomeClassFieldsInput) {\n                  createSomeClass(input: { fields: $fields }) {\n                    someClass {\n                      id\n                    }\n                  }\n                }\n              `,\n              variables: {\n                fields: {\n                  somePolygonField: somePolygonFieldValue\n                }\n              }\n            });\n            const getResult = await apolloClient.query({\n              query: gql`\n                query GetSomeObject($id: ID!) {\n                  someClass(id: $id) {\n                    somePolygonField {\n                      latitude\n                      longitude\n                    }\n                  }\n                  someClasses(where: { somePolygonField: { exists: true } }) {\n                    edges {\n                      node {\n                        id\n                        somePolygonField {\n                          latitude\n                          longitude\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                id: createResult.data.createSomeClass.someClass.id\n              }\n            });\n            expect(typeof getResult.data.someClass.somePolygonField).toEqual('object');\n            expect(getResult.data.someClass.somePolygonField).toEqual(somePolygonFieldValue.map(geoPoint => ({\n              ...geoPoint,\n              __typename: 'GeoPoint'\n            })));\n            expect(getResult.data.someClasses.edges.length).toEqual(1);\n            const getIntersect = await apolloClient.query({\n              query: gql`\n                query IntersectQuery($point: GeoPointInput!) {\n                  someClasses(where: { somePolygonField: { geoIntersects: { point: $point } } }) {\n                    edges {\n                      node {\n                        id\n                        somePolygonField {\n                          latitude\n                          longitude\n                        }\n                      }\n                    }\n                  }\n                }\n              `,\n              variables: {\n                point: {\n                  latitude: 44,\n                  longitude: 45\n                }\n              }\n            });\n            expect(getIntersect.data.someClasses.edges.length).toEqual(1);\n            expect(getIntersect.data.someClasses.edges[0].node.id).toEqual(createResult.data.createSomeClass.someClass.id);\n          } catch (e) {\n            handleError(e);\n          }\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support User class","suites":["ParseGraphQLServer","Auto API","Schema","Special Classes"],"line":9615,"updatePoint":{"line":9615,"column":37,"index":352369},"code":"        it('should support User class', async () => {\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          await user.signUp();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: user(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: user.id\n            }\n          });\n          expect(getResult.data.get.objectId).toEqual(user.id);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support Installation class","suites":["ParseGraphQLServer","Auto API","Schema","Special Classes"],"line":9635,"updatePoint":{"line":9635,"column":45,"index":353045},"code":"        it('should support Installation class', async () => {\n          const installation = new Parse.Installation();\n          await installation.save({\n            deviceType: 'foo'\n          });\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: installation(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: installation.id\n            }\n          });\n          expect(getResult.data.get.objectId).toEqual(installation.id);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support Role class","suites":["ParseGraphQLServer","Auto API","Schema","Special Classes"],"line":9655,"updatePoint":{"line":9655,"column":37,"index":353728},"code":"        it('should support Role class', async () => {\n          const roleACL = new Parse.ACL();\n          roleACL.setPublicReadAccess(true);\n          const role = new Parse.Role('MyRole', roleACL);\n          await role.save();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: role(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: role.id\n            }\n          });\n          expect(getResult.data.get.objectId).toEqual(role.id);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support Session class","suites":["ParseGraphQLServer","Auto API","Schema","Special Classes"],"line":9675,"updatePoint":{"line":9675,"column":40,"index":354428},"code":"        it('should support Session class', async () => {\n          const user = new Parse.User();\n          user.setUsername('user1');\n          user.setPassword('user1');\n          await user.signUp();\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const session = await Parse.Session.current();\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: session(id: $id) {\n                  id\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: session.id\n            },\n            context: {\n              headers: {\n                'X-Parse-Session-Token': session.getSessionToken()\n              }\n            }\n          });\n          expect(getResult.data.get.objectId).toEqual(session.id);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should support Product class","suites":["ParseGraphQLServer","Auto API","Schema","Special Classes"],"line":9702,"updatePoint":{"line":9702,"column":40,"index":355332},"code":"        it('should support Product class', async () => {\n          const Product = Parse.Object.extend('_Product');\n          const product = new Product();\n          await product.save({\n            productIdentifier: 'foo',\n            icon: new Parse.File('icon', ['foo']),\n            order: 1,\n            title: 'Foo',\n            subtitle: 'My product'\n          }, {\n            useMasterKey: true\n          });\n          await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n          const getResult = await apolloClient.query({\n            query: gql`\n              query GetSomeObject($id: ID!) {\n                get: product(id: $id) {\n                  objectId\n                }\n              }\n            `,\n            variables: {\n              id: product.id\n            },\n            context: {\n              headers: {\n                'X-Parse-Master-Key': 'test'\n              }\n            }\n          });\n          expect(getResult.data.get.objectId).toEqual(product.id);\n        });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"can resolve a custom query using default function name","suites":["ParseGraphQLServer","Custom API","SDL based"],"line":9782,"updatePoint":{"line":9782,"column":64,"index":357851},"code":"      it('can resolve a custom query using default function name', async () => {\n        Parse.Cloud.define('hello', async () => {\n          return 'Hello world!';\n        });\n        const result = await apolloClient.query({\n          query: gql`\n            query Hello {\n              hello\n            }\n          `\n        });\n        expect(result.data.hello).toEqual('Hello world!');\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"can resolve a custom query using function name set by \"to\" argument","suites":["ParseGraphQLServer","Custom API","SDL based"],"line":9795,"updatePoint":{"line":9795,"column":77,"index":358265},"code":"      it('can resolve a custom query using function name set by \"to\" argument', async () => {\n        Parse.Cloud.define('hello', async () => {\n          return 'Hello world!';\n        });\n        const result = await apolloClient.query({\n          query: gql`\n            query Hello {\n              hello2\n            }\n          `\n        });\n        expect(result.data.hello2).toEqual('Hello world!');\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"order option should continue working","suites":["ParseGraphQLServer","Custom API","SDL based"],"line":9808,"updatePoint":{"line":9808,"column":46,"index":358650},"code":"      it('order option should continue working', async () => {\n        const schemaController = await parseServer.config.databaseController.loadSchema();\n        await schemaController.addClassIfNotExists('SuperCar', {\n          engine: {\n            type: 'String'\n          },\n          doors: {\n            type: 'Number'\n          },\n          price: {\n            type: 'String'\n          },\n          mileage: {\n            type: 'Number'\n          }\n        });\n        await new Parse.Object('SuperCar').save({\n          engine: 'petrol',\n          doors: 3,\n          price: '£7500',\n          mileage: 0\n        });\n        await new Parse.Object('SuperCar').save({\n          engine: 'petrol',\n          doors: 3,\n          price: '£7500',\n          mileage: 10000\n        });\n        await Promise.all([parseGraphQLServer.parseGraphQLController.cacheController.graphQL.clear(), parseGraphQLServer.parseGraphQLSchema.schemaCache.clear()]);\n        await expectAsync(apolloClient.query({\n          query: gql`\n              query FindSuperCar {\n                superCars(order: [mileage_ASC]) {\n                  edges {\n                    node {\n                      id\n                    }\n                  }\n                }\n              }\n            `\n        })).toBeResolved();\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"can resolve a custom query","suites":["ParseGraphQLServer","Custom API","GraphQL Schema Based"],"line":10020,"updatePoint":{"line":10020,"column":36,"index":365293},"code":"      it('can resolve a custom query', async () => {\n        const result = await apolloClient.query({\n          variables: {\n            message: 'hello'\n          },\n          query: gql`\n            query CustomQuery($message: String!) {\n              customQuery(message: $message)\n            }\n          `\n        });\n        expect(result.data.customQuery).toEqual('hello');\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"can forward original error of a custom query","suites":["ParseGraphQLServer","Custom API","GraphQL Schema Based"],"line":10033,"updatePoint":{"line":10033,"column":54,"index":365703},"code":"      it('can forward original error of a custom query', async () => {\n        await expectAsync(apolloClient.query({\n          query: gql`\n              query ErrorQuery {\n                errorQuery\n              }\n            `\n        })).toBeRejectedWithError('A test error');\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"can resolve a custom query with auto type return","suites":["ParseGraphQLServer","Custom API","GraphQL Schema Based"],"line":10042,"updatePoint":{"line":10042,"column":58,"index":365998},"code":"      it('can resolve a custom query with auto type return', async () => {\n        const obj = new Parse.Object('SomeClass');\n        await obj.save({\n          name: 'aname',\n          type: 'robot'\n        });\n        await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n        const result = await apolloClient.query({\n          variables: {\n            id: obj.id\n          },\n          query: gql`\n            query CustomQuery($id: String!) {\n              customQueryWithAutoTypeReturn(id: $id) {\n                objectId\n                nameUpperCase\n                name\n                type\n              }\n            }\n          `\n        });\n        expect(result.data.customQueryWithAutoTypeReturn.objectId).toEqual(obj.id);\n        expect(result.data.customQueryWithAutoTypeReturn.name).toEqual('aname');\n        expect(result.data.customQueryWithAutoTypeReturn.nameUpperCase).toEqual('ANAME');\n        expect(result.data.customQueryWithAutoTypeReturn.type).toEqual('robot');\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"can resolve a custom query with auto type list return","suites":["ParseGraphQLServer","Custom API","GraphQL Schema Based"],"line":10069,"updatePoint":{"line":10069,"column":63,"index":367017},"code":"      it('can resolve a custom query with auto type list return', async () => {\n        const obj = new Parse.Object('SomeClass');\n        await obj.save({\n          name: 'aname',\n          type: 'robot'\n        });\n        await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n        const result = await apolloClient.query({\n          variables: {\n            id: obj.id\n          },\n          query: gql`\n            query CustomQuery($id: String!) {\n              customQueryWithAutoTypeReturnList(id: $id) {\n                id\n                objectId\n                nameUpperCase\n                name\n                type\n              }\n            }\n          `\n        });\n        result.data.customQueryWithAutoTypeReturnList.forEach(rObj => {\n          expect(rObj.objectId).toBeDefined();\n          expect(rObj.objectId).toEqual(obj.id);\n          expect(rObj.name).toEqual('aname');\n          expect(rObj.nameUpperCase).toEqual('ANAME');\n          expect(rObj.type).toEqual('robot');\n        });\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"can resolve a stacked query with same where variables on overloaded where input","suites":["ParseGraphQLServer","Custom API","GraphQL Schema Based"],"line":10100,"updatePoint":{"line":10100,"column":89,"index":368076},"code":"      it('can resolve a stacked query with same where variables on overloaded where input', async () => {\n        const objPointer = new Parse.Object('SomeClass2');\n        await objPointer.save({\n          name: 'aname',\n          type: 'robot'\n        });\n        const obj = new Parse.Object('SomeClass');\n        await obj.save({\n          name: 'aname',\n          type: 'robot',\n          pointer: objPointer\n        });\n        await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n        const result = await apolloClient.query({\n          variables: {\n            where: {\n              OR: [{\n                pointer: {\n                  have: {\n                    objectId: {\n                      exists: true\n                    }\n                  }\n                }\n              }]\n            }\n          },\n          query: gql`\n            query someQuery($where: SomeClassWhereInput!) {\n              q1: someClasses(where: $where) {\n                edges {\n                  node {\n                    id\n                  }\n                }\n              }\n              q2: someClasses(where: $where) {\n                edges {\n                  node {\n                    id\n                  }\n                }\n              }\n            }\n          `\n        });\n        expect(result.data.q1.edges.length).toEqual(1);\n        expect(result.data.q2.edges.length).toEqual(1);\n        expect(result.data.q1.edges[0].node.id).toEqual(result.data.q2.edges[0].node.id);\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"can resolve a custom extend type","suites":["ParseGraphQLServer","Custom API","GraphQL Schema Based"],"line":10150,"updatePoint":{"line":10150,"column":42,"index":369545},"code":"      it('can resolve a custom extend type', async () => {\n        const obj = new Parse.Object('SomeClass');\n        await obj.save({\n          name: 'aname',\n          type: 'robot'\n        });\n        await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n        const result = await apolloClient.query({\n          variables: {\n            id: obj.id\n          },\n          query: gql`\n            query someClass($id: ID!) {\n              someClass(id: $id) {\n                nameUpperCase\n                language\n                type\n              }\n            }\n          `\n        });\n        expect(result.data.someClass.nameUpperCase).toEqual('ANAME');\n        expect(result.data.someClass.language).toEqual('fr');\n        expect(result.data.someClass.type).toEqual('robot');\n        const result2 = await apolloClient.query({\n          variables: {\n            id: obj.id\n          },\n          query: gql`\n            query someClass($id: ID!) {\n              someClass(id: $id) {\n                name\n                language\n              }\n            }\n          `\n        });\n        expect(result2.data.someClass.name).toEqual('aname');\n        expect(result.data.someClass.language).toEqual('fr');\n        const result3 = await apolloClient.mutate({\n          variables: {\n            id: obj.id,\n            name: 'anewname',\n            type: 'human'\n          },\n          mutation: gql`\n            mutation someClass($id: ID!, $name: String!, $type: TypeEnum!) {\n              updateSomeClass(input: { id: $id, fields: { name: $name, type: $type } }) {\n                someClass {\n                  nameUpperCase\n                  type\n                }\n              }\n            }\n          `\n        });\n        expect(result3.data.updateSomeClass.someClass.nameUpperCase).toEqual('ANEWNAME');\n        expect(result3.data.updateSomeClass.someClass.type).toEqual('human');\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"can resolve a query","suites":["ParseGraphQLServer","Custom API","Async Function Based Merge"],"line":10252,"updatePoint":{"line":10252,"column":29,"index":372748},"code":"      it('can resolve a query', async () => {\n        const result = await apolloClient.query({\n          query: gql`\n            query Health {\n              health\n            }\n          `\n        });\n        expect(result.data.health).toEqual(true);\n      });","file":"ParseGraphQLServer.spec.js","skipped":false,"dir":"spec"},{"name":"should have no hooks registered","suites":["Hooks"],"line":29,"updatePoint":{"line":29,"column":37,"index":763},"code":"  it('should have no hooks registered', done => {\n    Parse.Hooks.getFunctions().then(res => {\n      expect(res.constructor).toBe(Array.prototype.constructor);\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should have no triggers registered","suites":["Hooks"],"line":38,"updatePoint":{"line":38,"column":40,"index":1002},"code":"  it('should have no triggers registered', done => {\n    Parse.Hooks.getTriggers().then(res => {\n      expect(res.constructor).toBe(Array.prototype.constructor);\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should CRUD a function registration","suites":["Hooks"],"line":47,"updatePoint":{"line":47,"column":41,"index":1241},"code":"  it('should CRUD a function registration', done => {\n    // Create\n    Parse.Hooks.createFunction('My-Test-Function', 'http://someurl').then(response => {\n      expect(response.functionName).toBe('My-Test-Function');\n      expect(response.url).toBe('http://someurl');\n      // Find\n      return Parse.Hooks.getFunction('My-Test-Function');\n    }).then(response => {\n      expect(response.objectId).toBeUndefined();\n      expect(response.url).toBe('http://someurl');\n      return Parse.Hooks.updateFunction('My-Test-Function', 'http://anotherurl');\n    }).then(res => {\n      expect(res.objectId).toBeUndefined();\n      expect(res.functionName).toBe('My-Test-Function');\n      expect(res.url).toBe('http://anotherurl');\n      // delete\n      return Parse.Hooks.removeFunction('My-Test-Function');\n    }).then(() => {\n      // Find again! but should be deleted\n      return Parse.Hooks.getFunction('My-Test-Function').then(res => {\n        fail('Failed to delete hook');\n        fail(res);\n        done();\n        return Promise.resolve();\n      }, err => {\n        expect(err.code).toBe(143);\n        expect(err.message).toBe('no function named: My-Test-Function is defined');\n        done();\n        return Promise.resolve();\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should CRUD a trigger registration","suites":["Hooks"],"line":82,"updatePoint":{"line":82,"column":40,"index":2549},"code":"  it('should CRUD a trigger registration', done => {\n    // Create\n    Parse.Hooks.createTrigger('MyClass', 'beforeDelete', 'http://someurl').then(res => {\n      expect(res.className).toBe('MyClass');\n      expect(res.triggerName).toBe('beforeDelete');\n      expect(res.url).toBe('http://someurl');\n      // Find\n      return Parse.Hooks.getTrigger('MyClass', 'beforeDelete');\n    }, err => {\n      fail(err);\n      done();\n    }).then(res => {\n      expect(res).not.toBe(null);\n      expect(res).not.toBe(undefined);\n      expect(res.objectId).toBeUndefined();\n      expect(res.url).toBe('http://someurl');\n      // delete\n      return Parse.Hooks.updateTrigger('MyClass', 'beforeDelete', 'http://anotherurl');\n    }, err => {\n      jfail(err);\n      done();\n    }).then(res => {\n      expect(res.className).toBe('MyClass');\n      expect(res.url).toBe('http://anotherurl');\n      expect(res.objectId).toBeUndefined();\n      return Parse.Hooks.removeTrigger('MyClass', 'beforeDelete');\n    }, err => {\n      jfail(err);\n      done();\n    }).then(() => {\n      // Find again! but should be deleted\n      return Parse.Hooks.getTrigger('MyClass', 'beforeDelete');\n    }, err => {\n      jfail(err);\n      done();\n    }).then(function () {\n      fail('should not succeed');\n      done();\n    }, err => {\n      if (err) {\n        expect(err).not.toBe(null);\n        expect(err).not.toBe(undefined);\n        expect(err.code).toBe(143);\n        expect(err.message).toBe('class MyClass does not exist');\n      } else {\n        fail('should have errored');\n      }\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should fail to register hooks without Master Key","suites":["Hooks"],"line":132,"updatePoint":{"line":132,"column":54,"index":4146},"code":"  it('should fail to register hooks without Master Key', done => {\n    request({\n      method: 'POST',\n      url: Parse.serverURL + '/hooks/functions',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId\n      },\n      body: JSON.stringify({\n        url: 'http://hello.word',\n        functionName: 'SomeFunction'\n      })\n    }).then(fail, response => {\n      const body = response.data;\n      expect(body.error).toBe('unauthorized');\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should fail trying to create two times the same function","suites":["Hooks"],"line":149,"updatePoint":{"line":149,"column":62,"index":4636},"code":"  it('should fail trying to create two times the same function', done => {\n    Parse.Hooks.createFunction('my_new_function', 'http://url.com').then(() => new Promise(resolve => setTimeout(resolve, 100))).then(() => {\n      return Parse.Hooks.createFunction('my_new_function', 'http://url.com');\n    }, () => {\n      fail('should create a new function');\n    }).then(() => {\n      fail('should not be able to create the same function');\n    }, err => {\n      expect(err).not.toBe(undefined);\n      expect(err).not.toBe(null);\n      if (err) {\n        expect(err.code).toBe(143);\n        expect(err.message).toBe('function name: my_new_function already exits');\n      }\n      return Parse.Hooks.removeFunction('my_new_function');\n    }).then(() => {\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should fail trying to create two times the same trigger","suites":["Hooks"],"line":171,"updatePoint":{"line":171,"column":61,"index":5459},"code":"  it('should fail trying to create two times the same trigger', done => {\n    Parse.Hooks.createTrigger('MyClass', 'beforeSave', 'http://url.com').then(() => {\n      return Parse.Hooks.createTrigger('MyClass', 'beforeSave', 'http://url.com');\n    }, () => {\n      fail('should create a new trigger');\n    }).then(() => {\n      fail('should not be able to create the same trigger');\n    }, err => {\n      expect(err).not.toBe(undefined);\n      expect(err).not.toBe(null);\n      if (err) {\n        expect(err.code).toBe(143);\n        expect(err.message).toBe('class MyClass already has trigger beforeSave');\n      }\n      return Parse.Hooks.removeTrigger('MyClass', 'beforeSave');\n    }).then(() => {\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should fail trying to update a function that don't exist","suites":["Hooks"],"line":193,"updatePoint":{"line":193,"column":62,"index":6235},"code":"  it(\"should fail trying to update a function that don't exist\", done => {\n    Parse.Hooks.updateFunction('A_COOL_FUNCTION', 'http://url.com').then(() => {\n      fail('Should not succeed');\n    }, err => {\n      expect(err).not.toBe(undefined);\n      expect(err).not.toBe(null);\n      if (err) {\n        expect(err.code).toBe(143);\n        expect(err.message).toBe('no function named: A_COOL_FUNCTION is defined');\n      }\n      return Parse.Hooks.getFunction('A_COOL_FUNCTION');\n    }).then(() => {\n      fail('the function should not exist');\n      done();\n    }, err => {\n      expect(err).not.toBe(undefined);\n      expect(err).not.toBe(null);\n      if (err) {\n        expect(err.code).toBe(143);\n        expect(err.message).toBe('no function named: A_COOL_FUNCTION is defined');\n      }\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should fail trying to update a trigger that don't exist","suites":["Hooks"],"line":217,"updatePoint":{"line":217,"column":61,"index":7054},"code":"  it(\"should fail trying to update a trigger that don't exist\", done => {\n    Parse.Hooks.updateTrigger('AClassName', 'beforeSave', 'http://url.com').then(() => {\n      fail('Should not succeed');\n    }, err => {\n      expect(err).not.toBe(undefined);\n      expect(err).not.toBe(null);\n      if (err) {\n        expect(err.code).toBe(143);\n        expect(err.message).toBe('class AClassName does not exist');\n      }\n      return Parse.Hooks.getTrigger('AClassName', 'beforeSave');\n    }).then(() => {\n      fail('the function should not exist');\n      done();\n    }, err => {\n      expect(err).not.toBe(undefined);\n      expect(err).not.toBe(null);\n      if (err) {\n        expect(err.code).toBe(143);\n        expect(err.message).toBe('class AClassName does not exist');\n      }\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should fail trying to create a malformed function","suites":["Hooks"],"line":241,"updatePoint":{"line":241,"column":55,"index":7855},"code":"  it('should fail trying to create a malformed function', done => {\n    Parse.Hooks.createFunction('MyFunction').then(res => {\n      fail(res);\n    }, err => {\n      expect(err).not.toBe(undefined);\n      expect(err).not.toBe(null);\n      if (err) {\n        expect(err.code).toBe(143);\n        expect(err.error).toBe('invalid hook declaration');\n      }\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should fail trying to create a malformed function (REST)","suites":["Hooks"],"line":254,"updatePoint":{"line":254,"column":62,"index":8244},"code":"  it('should fail trying to create a malformed function (REST)', done => {\n    request({\n      method: 'POST',\n      url: Parse.serverURL + '/hooks/functions',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': Parse.masterKey\n      },\n      body: JSON.stringify({\n        functionName: 'SomeFunction'\n      })\n    }).then(fail, response => {\n      const body = response.data;\n      expect(body.error).toBe('invalid hook declaration');\n      expect(body.code).toBe(143);\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should create hooks and properly preload them","suites":["Hooks"],"line":272,"updatePoint":{"line":272,"column":51,"index":8783},"code":"  it('should create hooks and properly preload them', done => {\n    const promises = [];\n    for (let i = 0; i < 5; i++) {\n      promises.push(Parse.Hooks.createTrigger('MyClass' + i, 'beforeSave', 'http://url.com/beforeSave/' + i));\n      promises.push(Parse.Hooks.createFunction('AFunction' + i, 'http://url.com/function' + i));\n    }\n    Promise.all(promises).then(function () {\n      for (let i = 0; i < 5; i++) {\n        // Delete everything from memory, as the server just started\n        triggers.removeTrigger('beforeSave', 'MyClass' + i, Parse.applicationId);\n        triggers.removeFunction('AFunction' + i, Parse.applicationId);\n        expect(triggers.getTrigger('MyClass' + i, 'beforeSave', Parse.applicationId)).toBeUndefined();\n        expect(triggers.getFunction('AFunction' + i, Parse.applicationId)).toBeUndefined();\n      }\n      const hooksController = new HooksController(Parse.applicationId, Config.get('test').database);\n      return hooksController.load();\n    }, err => {\n      jfail(err);\n      fail('Should properly create all hooks');\n      done();\n    }).then(function () {\n      for (let i = 0; i < 5; i++) {\n        expect(triggers.getTrigger('MyClass' + i, 'beforeSave', Parse.applicationId)).not.toBeUndefined();\n        expect(triggers.getFunction('AFunction' + i, Parse.applicationId)).not.toBeUndefined();\n      }\n      done();\n    }, err => {\n      jfail(err);\n      fail('should properly load all hooks');\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should run the function on the test server","suites":["Hooks"],"line":304,"updatePoint":{"line":304,"column":48,"index":10252},"code":"  it('should run the function on the test server', done => {\n    app.post('/SomeFunction', function (req, res) {\n      res.json({\n        success: 'OK!'\n      });\n    });\n    Parse.Hooks.createFunction('SOME_TEST_FUNCTION', hookServerURL + '/SomeFunction').then(function () {\n      return Parse.Cloud.run('SOME_TEST_FUNCTION');\n    }, err => {\n      jfail(err);\n      fail('Should not fail creating a function');\n      done();\n    }).then(function (res) {\n      expect(res).toBe('OK!');\n      done();\n    }, err => {\n      jfail(err);\n      fail('Should not fail calling a function');\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should run the function on the test server (error handling)","suites":["Hooks"],"line":325,"updatePoint":{"line":325,"column":65,"index":10882},"code":"  it('should run the function on the test server (error handling)', done => {\n    app.post('/SomeFunctionError', function (req, res) {\n      res.json({\n        error: {\n          code: 1337,\n          error: 'hacking that one!'\n        }\n      });\n    });\n    // The function is deleted as the DB is dropped between calls\n    Parse.Hooks.createFunction('SOME_TEST_FUNCTION', hookServerURL + '/SomeFunctionError').then(function () {\n      return Parse.Cloud.run('SOME_TEST_FUNCTION');\n    }, err => {\n      jfail(err);\n      fail('Should not fail creating a function');\n      done();\n    }).then(function () {\n      fail('Should not succeed calling that function');\n      done();\n    }, err => {\n      expect(err).not.toBe(undefined);\n      expect(err).not.toBe(null);\n      if (err) {\n        expect(err.code).toBe(Parse.Error.SCRIPT_FAILED);\n        expect(err.message.code).toEqual(1337);\n        expect(err.message.error).toEqual('hacking that one!');\n      }\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should provide X-Parse-Webhook-Key when defined","suites":["Hooks"],"line":355,"updatePoint":{"line":355,"column":53,"index":11861},"code":"  it('should provide X-Parse-Webhook-Key when defined', done => {\n    app.post('/ExpectingKey', function (req, res) {\n      if (req.get('X-Parse-Webhook-Key') === 'hook') {\n        res.json({\n          success: 'correct key provided'\n        });\n      } else {\n        res.json({\n          error: 'incorrect key provided'\n        });\n      }\n    });\n    Parse.Hooks.createFunction('SOME_TEST_FUNCTION', hookServerURL + '/ExpectingKey').then(function () {\n      return Parse.Cloud.run('SOME_TEST_FUNCTION');\n    }, err => {\n      jfail(err);\n      fail('Should not fail creating a function');\n      done();\n    }).then(function (res) {\n      expect(res).toBe('correct key provided');\n      done();\n    }, err => {\n      jfail(err);\n      fail('Should not fail calling a function');\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should not pass X-Parse-Webhook-Key if not provided","suites":["Hooks"],"line":382,"updatePoint":{"line":382,"column":57,"index":12674},"code":"  it('should not pass X-Parse-Webhook-Key if not provided', done => {\n    reconfigureServer({\n      webhookKey: undefined\n    }).then(() => {\n      app.post('/ExpectingKeyAlso', function (req, res) {\n        if (req.get('X-Parse-Webhook-Key') === 'hook') {\n          res.json({\n            success: 'correct key provided'\n          });\n        } else {\n          res.json({\n            error: 'incorrect key provided'\n          });\n        }\n      });\n      Parse.Hooks.createFunction('SOME_TEST_FUNCTION', hookServerURL + '/ExpectingKeyAlso').then(function () {\n        return Parse.Cloud.run('SOME_TEST_FUNCTION');\n      }, err => {\n        jfail(err);\n        fail('Should not fail creating a function');\n        done();\n      }).then(function () {\n        fail('Should not succeed calling that function');\n        done();\n      }, err => {\n        expect(err).not.toBe(undefined);\n        expect(err).not.toBe(null);\n        if (err) {\n          expect(err.code).toBe(Parse.Error.SCRIPT_FAILED);\n          expect(err.message).toEqual('incorrect key provided');\n        }\n        done();\n      });\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should run the beforeSave hook on the test server","suites":["Hooks"],"line":417,"updatePoint":{"line":417,"column":55,"index":13787},"code":"  it('should run the beforeSave hook on the test server', done => {\n    let triggerCount = 0;\n    app.post('/BeforeSaveSome', function (req, res) {\n      triggerCount++;\n      const object = req.body.object;\n      object.hello = 'world';\n      // Would need parse cloud express to set much more\n      // But this should override the key upon return\n      res.json({\n        success: object\n      });\n    });\n    // The function is deleted as the DB is dropped between calls\n    Parse.Hooks.createTrigger('SomeRandomObject', 'beforeSave', hookServerURL + '/BeforeSaveSome').then(function () {\n      const obj = new Parse.Object('SomeRandomObject');\n      return obj.save();\n    }).then(function (res) {\n      expect(triggerCount).toBe(1);\n      return res.fetch();\n    }).then(function (res) {\n      expect(res.get('hello')).toEqual('world');\n      done();\n    }).catch(err => {\n      jfail(err);\n      fail('Should not fail creating a function');\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave hooks should correctly handle responses containing entire object","suites":["Hooks"],"line":445,"updatePoint":{"line":445,"column":81,"index":14788},"code":"  it('beforeSave hooks should correctly handle responses containing entire object', done => {\n    app.post('/BeforeSaveSome2', function (req, res) {\n      const object = Parse.Object.fromJSON(req.body.object);\n      object.set('hello', 'world');\n      res.json({\n        success: object\n      });\n    });\n    Parse.Hooks.createTrigger('SomeRandomObject2', 'beforeSave', hookServerURL + '/BeforeSaveSome2').then(function () {\n      const obj = new Parse.Object('SomeRandomObject2');\n      return obj.save();\n    }).then(function (res) {\n      return res.save();\n    }).then(function (res) {\n      expect(res.get('hello')).toEqual('world');\n      done();\n    }).catch(err => {\n      fail(`Should not fail: ${JSON.stringify(err)}`);\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should run the afterSave hook on the test server","suites":["Hooks"],"line":466,"updatePoint":{"line":466,"column":54,"index":15519},"code":"  it('should run the afterSave hook on the test server', done => {\n    let triggerCount = 0;\n    let newObjectId;\n    app.post('/AfterSaveSome', function (req, res) {\n      triggerCount++;\n      const obj = new Parse.Object('AnotherObject');\n      obj.set('foo', 'bar');\n      obj.save().then(function (obj) {\n        newObjectId = obj.id;\n        res.json({\n          success: {}\n        });\n      });\n    });\n    // The function is deleted as the DB is dropped between calls\n    Parse.Hooks.createTrigger('SomeRandomObject', 'afterSave', hookServerURL + '/AfterSaveSome').then(function () {\n      const obj = new Parse.Object('SomeRandomObject');\n      return obj.save();\n    }).then(function () {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          expect(triggerCount).toBe(1);\n          new Parse.Query('AnotherObject').get(newObjectId).then(r => resolve(r));\n        }, 500);\n      });\n    }).then(function (res) {\n      expect(res.get('foo')).toEqual('bar');\n      done();\n    }).catch(err => {\n      jfail(err);\n      fail('Should not fail creating a function');\n      done();\n    });\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should produce a proper request object with context in beforeSave","suites":["triggers"],"line":502,"updatePoint":{"line":502,"column":71,"index":16691},"code":"  it('should produce a proper request object with context in beforeSave', () => {\n    const config = Config.get('test');\n    const master = auth.master(config);\n    const context = {\n      originalKey: 'original'\n    };\n    const req = triggers.getRequestObject(triggers.Types.beforeSave, master, {}, {}, config, context);\n    expect(req.context.originalKey).toBe('original');\n    req.context = {\n      key: 'value'\n    };\n    expect(context.key).toBe(undefined);\n    req.context = {\n      key: 'newValue'\n    };\n    expect(context.key).toBe(undefined);\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should produce a proper request object with context in afterSave","suites":["triggers"],"line":519,"updatePoint":{"line":519,"column":70,"index":17250},"code":"  it('should produce a proper request object with context in afterSave', () => {\n    const config = Config.get('test');\n    const master = auth.master(config);\n    const context = {};\n    const req = triggers.getRequestObject(triggers.Types.afterSave, master, {}, {}, config, context);\n    expect(req.context).not.toBeUndefined();\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"should not set context on beforeFind","suites":["triggers"],"line":526,"updatePoint":{"line":526,"column":42,"index":17559},"code":"  it('should not set context on beforeFind', () => {\n    const config = Config.get('test');\n    const master = auth.master(config);\n    const context = {};\n    const req = triggers.getRequestObject(triggers.Types.beforeFind, master, {}, {}, config, context);\n    expect(req.context).toBeUndefined();\n  });","file":"ParseHooks.spec.js","skipped":false,"dir":"spec"},{"name":"creates an android installation with ids","suites":["Installations"],"line":24,"updatePoint":{"line":24,"column":46,"index":835},"code":"  it('creates an android installation with ids', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const device = 'android';\n    const input = {\n      installationId: installId,\n      deviceType: device\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const obj = results[0];\n      expect(obj.installationId).toEqual(installId);\n      expect(obj.deviceType).toEqual(device);\n      done();\n    }).catch(error => {\n      console.log(error);\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"creates an ios installation with ids","suites":["Installations"],"line":43,"updatePoint":{"line":43,"column":42,"index":1515},"code":"  it('creates an ios installation with ids', done => {\n    const t = '11433856eed2f1285fb3aa11136718c1198ed5647875096952c66bf8cb976306';\n    const device = 'ios';\n    const input = {\n      deviceToken: t,\n      deviceType: device\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const obj = results[0];\n      expect(obj.deviceToken).toEqual(t);\n      expect(obj.deviceType).toEqual(device);\n      done();\n    }).catch(error => {\n      console.log(error);\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"creates an embedded installation with ids","suites":["Installations"],"line":62,"updatePoint":{"line":62,"column":47,"index":2194},"code":"  it('creates an embedded installation with ids', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const device = 'embedded';\n    const input = {\n      installationId: installId,\n      deviceType: device\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const obj = results[0];\n      expect(obj.installationId).toEqual(installId);\n      expect(obj.deviceType).toEqual(device);\n      done();\n    }).catch(error => {\n      console.log(error);\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"creates an android installation with all fields","suites":["Installations"],"line":81,"updatePoint":{"line":81,"column":53,"index":2886},"code":"  it('creates an android installation with all fields', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const device = 'android';\n    const input = {\n      installationId: installId,\n      deviceType: device,\n      channels: ['foo', 'bar']\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const obj = results[0];\n      expect(obj.installationId).toEqual(installId);\n      expect(obj.deviceType).toEqual(device);\n      expect(typeof obj.channels).toEqual('object');\n      expect(obj.channels.length).toEqual(2);\n      expect(obj.channels[0]).toEqual('foo');\n      expect(obj.channels[1]).toEqual('bar');\n      done();\n    }).catch(error => {\n      console.log(error);\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"creates an ios installation with all fields","suites":["Installations"],"line":105,"updatePoint":{"line":105,"column":49,"index":3796},"code":"  it('creates an ios installation with all fields', done => {\n    const t = '11433856eed2f1285fb3aa11136718c1198ed5647875096952c66bf8cb976306';\n    const device = 'ios';\n    const input = {\n      deviceToken: t,\n      deviceType: device,\n      channels: ['foo', 'bar']\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const obj = results[0];\n      expect(obj.deviceToken).toEqual(t);\n      expect(obj.deviceType).toEqual(device);\n      expect(typeof obj.channels).toEqual('object');\n      expect(obj.channels.length).toEqual(2);\n      expect(obj.channels[0]).toEqual('foo');\n      expect(obj.channels[1]).toEqual('bar');\n      done();\n    }).catch(error => {\n      console.log(error);\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"should properly fail queying installations","suites":["Installations"],"line":129,"updatePoint":{"line":129,"column":48,"index":4699},"code":"  it('should properly fail queying installations', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const device = 'android';\n    const input = {\n      installationId: installId,\n      deviceType: device\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      const query = new Parse.Query(Parse.Installation);\n      return query.find();\n    }).then(() => {\n      fail('Should not succeed!');\n      done();\n    }).catch(error => {\n      expect(error.code).toBe(119);\n      expect(error.message).toBe(\"Clients aren't allowed to perform the find operation on the installation collection.\");\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"should properly queying installations with masterKey","suites":["Installations"],"line":148,"updatePoint":{"line":148,"column":58,"index":5392},"code":"  it('should properly queying installations with masterKey', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const device = 'android';\n    const input = {\n      installationId: installId,\n      deviceType: device\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      const query = new Parse.Query(Parse.Installation);\n      return query.find({\n        useMasterKey: true\n      });\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      const obj = results[0].toJSON();\n      expect(obj.installationId).toEqual(installId);\n      expect(obj.deviceType).toEqual(device);\n      done();\n    }).catch(() => {\n      fail('Should not fail');\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"fails with missing ids","suites":["Installations"],"line":171,"updatePoint":{"line":171,"column":28,"index":6110},"code":"  it('fails with missing ids', done => {\n    const input = {\n      deviceType: 'android',\n      channels: ['foo', 'bar']\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      fail('Should not have been able to create an Installation.');\n      done();\n    }).catch(error => {\n      expect(error.code).toEqual(135);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"fails for android with missing type","suites":["Installations"],"line":184,"updatePoint":{"line":184,"column":41,"index":6506},"code":"  it('fails for android with missing type', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const input = {\n      installationId: installId,\n      channels: ['foo', 'bar']\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      fail('Should not have been able to create an Installation.');\n      done();\n    }).catch(error => {\n      expect(error.code).toEqual(135);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"creates an object with custom fields","suites":["Installations"],"line":198,"updatePoint":{"line":198,"column":42,"index":6969},"code":"  it('creates an object with custom fields', done => {\n    const t = '11433856eed2f1285fb3aa11136718c1198ed5647875096952c66bf8cb976306';\n    const input = {\n      deviceToken: t,\n      deviceType: 'ios',\n      channels: ['foo', 'bar'],\n      custom: 'allowed'\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const obj = results[0];\n      expect(obj.custom).toEqual('allowed');\n      done();\n    }).catch(error => {\n      console.log(error);\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"merging when installationId already exists","suites":["Installations"],"line":218,"updatePoint":{"line":218,"column":48,"index":7662},"code":"  it('merging when installationId already exists', done => {\n    const installId1 = '12345678-abcd-abcd-abcd-123456789abc';\n    const t = '11433856eed2f1285fb3aa11136718c1198ed5647875096952c66bf8cb976306';\n    const input = {\n      deviceToken: t,\n      deviceType: 'ios',\n      installationId: installId1,\n      channels: ['foo', 'bar']\n    };\n    let firstObject;\n    let secondObject;\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      firstObject = results[0];\n      delete input.deviceToken;\n      delete input.channels;\n      input['foo'] = 'bar';\n      return rest.create(config, auth.nobody(config), '_Installation', input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      secondObject = results[0];\n      expect(firstObject._id).toEqual(secondObject._id);\n      expect(secondObject.channels.length).toEqual(2);\n      expect(secondObject.foo).toEqual('bar');\n      done();\n    }).catch(error => {\n      console.log(error);\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"merging when two objects both only have one id","suites":["Installations"],"line":247,"updatePoint":{"line":247,"column":52,"index":8876},"code":"  it('merging when two objects both only have one id', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const t = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';\n    const input1 = {\n      installationId: installId,\n      deviceType: 'ios'\n    };\n    const input2 = {\n      deviceToken: t,\n      deviceType: 'ios'\n    };\n    const input3 = {\n      deviceToken: t,\n      installationId: installId,\n      deviceType: 'ios'\n    };\n    let firstObject;\n    let secondObject;\n    rest.create(config, auth.nobody(config), '_Installation', input1).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      firstObject = results[0];\n      return rest.create(config, auth.nobody(config), '_Installation', input2);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(2);\n      if (results[0]['_id'] == firstObject._id) {\n        secondObject = results[1];\n      } else {\n        secondObject = results[0];\n      }\n      return rest.create(config, auth.nobody(config), '_Installation', input3);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0]['_id']).toEqual(secondObject._id);\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"creating multiple devices with same device token works","suites":["Installations"],"line":286,"updatePoint":{"line":286,"column":61,"index":10381},"skipped":true,"code":"  xit('creating multiple devices with same device token works', done => {\n    const installId1 = '11111111-abcd-abcd-abcd-123456789abc';\n    const installId2 = '22222222-abcd-abcd-abcd-123456789abc';\n    const installId3 = '33333333-abcd-abcd-abcd-123456789abc';\n    const t = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';\n    const input = {\n      installationId: installId1,\n      deviceType: 'ios',\n      deviceToken: t\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      input.installationId = installId2;\n      return rest.create(config, auth.nobody(config), '_Installation', input);\n    }).then(() => {\n      input.installationId = installId3;\n      return rest.create(config, auth.nobody(config), '_Installation', input);\n    }).then(() => database.adapter.find('_Installation', {\n      installationId: installId1\n    }, installationSchema, {})).then(results => {\n      expect(results.length).toEqual(1);\n      return database.adapter.find('_Installation', {\n        installationId: installId2\n      }, installationSchema, {});\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      return database.adapter.find('_Installation', {\n        installationId: installId3\n      }, installationSchema, {});\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      done();\n    }).catch(error => {\n      console.log(error);\n    });\n  });","file":"ParseInstallation.spec.js","dir":"spec"},{"name":"updating with new channels","suites":["Installations"],"line":321,"updatePoint":{"line":321,"column":32,"index":11785},"code":"  it('updating with new channels', done => {\n    const input = {\n      installationId: '12345678-abcd-abcd-abcd-123456789abc',\n      deviceType: 'android',\n      channels: ['foo', 'bar']\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const objectId = results[0].objectId;\n      const update = {\n        channels: ['baz']\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId\n      }, update);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].channels.length).toEqual(1);\n      expect(results[0].channels[0]).toEqual('baz');\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update android fails with new installation id","suites":["Installations"],"line":346,"updatePoint":{"line":346,"column":51,"index":12752},"code":"  it('update android fails with new installation id', done => {\n    const installId1 = '12345678-abcd-abcd-abcd-123456789abc';\n    const installId2 = '87654321-abcd-abcd-abcd-123456789abc';\n    let input = {\n      installationId: installId1,\n      deviceType: 'android',\n      channels: ['foo', 'bar']\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      input = {\n        installationId: installId2\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId: results[0].objectId\n      }, input);\n    }).then(() => {\n      fail('Updating the installation should have failed.');\n      done();\n    }).catch(error => {\n      expect(error.code).toEqual(136);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update ios fails with new deviceToken and no installationId","suites":["Installations"],"line":370,"updatePoint":{"line":370,"column":65,"index":13656},"code":"  it('update ios fails with new deviceToken and no installationId', done => {\n    const a = '11433856eed2f1285fb3aa11136718c1198ed5647875096952c66bf8cb976306';\n    const b = '91433856eed2f1285fb3aa11136718c1198ed5647875096952c66bf8cb976306';\n    let input = {\n      deviceToken: a,\n      deviceType: 'ios',\n      channels: ['foo', 'bar']\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      input = {\n        deviceToken: b\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId: results[0].objectId\n      }, input);\n    }).then(() => {\n      fail('Updating the installation should have failed.');\n    }).catch(error => {\n      expect(error.code).toEqual(136);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update ios updates device token","suites":["Installations"],"line":393,"updatePoint":{"line":393,"column":37,"index":14528},"code":"  it('update ios updates device token', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const t = '11433856eed2f1285fb3aa11136718c1198ed5647875096952c66bf8cb976306';\n    const u = '91433856eed2f1285fb3aa11136718c1198ed5647875096952c66bf8cb976306';\n    let input = {\n      installationId: installId,\n      deviceType: 'ios',\n      deviceToken: t,\n      channels: ['foo', 'bar']\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      input = {\n        installationId: installId,\n        deviceToken: u,\n        deviceType: 'ios'\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId: results[0].objectId\n      }, input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].deviceToken).toEqual(u);\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update fails to change deviceType","suites":["Installations"],"line":422,"updatePoint":{"line":422,"column":39,"index":15663},"code":"  it('update fails to change deviceType', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    let input = {\n      installationId: installId,\n      deviceType: 'android',\n      channels: ['foo', 'bar']\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      input = {\n        deviceType: 'ios'\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId: results[0].objectId\n      }, input);\n    }).then(() => {\n      fail('Should not have been able to update Installation.');\n      done();\n    }).catch(error => {\n      expect(error.code).toEqual(136);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update android with custom field","suites":["Installations"],"line":445,"updatePoint":{"line":445,"column":38,"index":16470},"code":"  it('update android with custom field', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    let input = {\n      installationId: installId,\n      deviceType: 'android',\n      channels: ['foo', 'bar']\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      input = {\n        custom: 'allowed'\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId: results[0].objectId\n      }, input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0]['custom']).toEqual('allowed');\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update android device token with duplicate device token","suites":["Installations"],"line":466,"updatePoint":{"line":466,"column":61,"index":17338},"code":"  it('update android device token with duplicate device token', async () => {\n    const installId1 = '11111111-abcd-abcd-abcd-123456789abc';\n    const installId2 = '22222222-abcd-abcd-abcd-123456789abc';\n    const t = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';\n    let input = {\n      installationId: installId1,\n      deviceToken: t,\n      deviceType: 'android'\n    };\n    await rest.create(config, auth.nobody(config), '_Installation', input);\n    input = {\n      installationId: installId2,\n      deviceType: 'android'\n    };\n    await rest.create(config, auth.nobody(config), '_Installation', input);\n    await delay(100);\n    let results = await database.adapter.find('_Installation', installationSchema, {\n      installationId: installId1\n    }, {});\n    expect(results.length).toEqual(1);\n    const firstObject = results[0];\n    results = await database.adapter.find('_Installation', installationSchema, {\n      installationId: installId2\n    }, {});\n    expect(results.length).toEqual(1);\n    const secondObject = results[0];\n\n    // Update second installation to conflict with first installation\n    input = {\n      objectId: secondObject.objectId,\n      deviceToken: t\n    };\n    await rest.update(config, auth.nobody(config), '_Installation', {\n      objectId: secondObject.objectId\n    }, input);\n    await delay(100);\n    results = await database.adapter.find('_Installation', installationSchema, {\n      objectId: firstObject.objectId\n    }, {});\n    expect(results.length).toEqual(0);\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update ios device token with duplicate device token","suites":["Installations"],"line":507,"updatePoint":{"line":507,"column":57,"index":18865},"code":"  it('update ios device token with duplicate device token', done => {\n    const installId1 = '11111111-abcd-abcd-abcd-123456789abc';\n    const installId2 = '22222222-abcd-abcd-abcd-123456789abc';\n    const t = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';\n    let input = {\n      installationId: installId1,\n      deviceToken: t,\n      deviceType: 'ios'\n    };\n    let firstObject;\n    let secondObject;\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      input = {\n        installationId: installId2,\n        deviceType: 'ios'\n      };\n      return rest.create(config, auth.nobody(config), '_Installation', input);\n    }).then(() => delay(100)).then(() => database.adapter.find('_Installation', installationSchema, {\n      installationId: installId1\n    }, {})).then(results => {\n      expect(results.length).toEqual(1);\n      firstObject = results[0];\n    }).then(() => delay(100)).then(() => database.adapter.find('_Installation', installationSchema, {\n      installationId: installId2\n    }, {})).then(results => {\n      expect(results.length).toEqual(1);\n      secondObject = results[0];\n      // Update second installation to conflict with first installation id\n      input = {\n        installationId: installId2,\n        deviceToken: t\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId: secondObject.objectId\n      }, input);\n    }).then(() => delay(100)).then(() => database.adapter.find('_Installation', installationSchema, {\n      objectId: firstObject.objectId\n    }, {})).then(results => {\n      // The first object should have been deleted\n      expect(results.length).toEqual(0);\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update ios device token with duplicate token different app","suites":["Installations"],"line":553,"updatePoint":{"line":553,"column":65,"index":20660},"skipped":true,"code":"  xit('update ios device token with duplicate token different app', done => {\n    const installId1 = '11111111-abcd-abcd-abcd-123456789abc';\n    const installId2 = '22222222-abcd-abcd-abcd-123456789abc';\n    const t = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';\n    const input = {\n      installationId: installId1,\n      deviceToken: t,\n      deviceType: 'ios',\n      appIdentifier: 'foo'\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      input.installationId = installId2;\n      input.appIdentifier = 'bar';\n      return rest.create(config, auth.nobody(config), '_Installation', input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      // The first object should have been deleted during merge\n      expect(results.length).toEqual(1);\n      expect(results[0].installationId).toEqual(installId2);\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","dir":"spec"},{"name":"update ios token and channels","suites":["Installations"],"line":577,"updatePoint":{"line":577,"column":35,"index":21644},"code":"  it('update ios token and channels', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const t = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';\n    let input = {\n      installationId: installId,\n      deviceType: 'ios'\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      input = {\n        deviceToken: t,\n        channels: []\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId: results[0].objectId\n      }, input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].installationId).toEqual(installId);\n      expect(results[0].deviceToken).toEqual(t);\n      expect(results[0].channels.length).toEqual(0);\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update ios linking two existing objects","suites":["Installations"],"line":604,"updatePoint":{"line":604,"column":45,"index":22726},"code":"  it('update ios linking two existing objects', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const t = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';\n    let input = {\n      installationId: installId,\n      deviceType: 'ios'\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      input = {\n        deviceToken: t,\n        deviceType: 'ios'\n      };\n      return rest.create(config, auth.nobody(config), '_Installation', input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {\n      deviceToken: t\n    }, {})).then(results => {\n      expect(results.length).toEqual(1);\n      input = {\n        deviceToken: t,\n        installationId: installId,\n        deviceType: 'ios'\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId: results[0].objectId\n      }, input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].installationId).toEqual(installId);\n      expect(results[0].deviceToken).toEqual(t);\n      expect(results[0].deviceType).toEqual('ios');\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update is linking two existing objects w/ increment","suites":["Installations"],"line":640,"updatePoint":{"line":640,"column":57,"index":24059},"code":"  it('update is linking two existing objects w/ increment', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const t = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';\n    let input = {\n      installationId: installId,\n      deviceType: 'ios'\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      input = {\n        deviceToken: t,\n        deviceType: 'ios'\n      };\n      return rest.create(config, auth.nobody(config), '_Installation', input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {\n      deviceToken: t\n    }, {})).then(results => {\n      expect(results.length).toEqual(1);\n      input = {\n        deviceToken: t,\n        installationId: installId,\n        deviceType: 'ios',\n        score: {\n          __op: 'Increment',\n          amount: 1\n        }\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId: results[0].objectId\n      }, input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].installationId).toEqual(installId);\n      expect(results[0].deviceToken).toEqual(t);\n      expect(results[0].deviceType).toEqual('ios');\n      expect(results[0].score).toEqual(1);\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update is linking two existing with installation id","suites":["Installations"],"line":681,"updatePoint":{"line":681,"column":57,"index":25512},"code":"  it('update is linking two existing with installation id', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const t = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';\n    let input = {\n      installationId: installId,\n      deviceType: 'ios'\n    };\n    let installObj;\n    let tokenObj;\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      installObj = results[0];\n      input = {\n        deviceToken: t,\n        deviceType: 'ios'\n      };\n      return rest.create(config, auth.nobody(config), '_Installation', input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {\n      deviceToken: t\n    }, {})).then(results => {\n      expect(results.length).toEqual(1);\n      tokenObj = results[0];\n      input = {\n        installationId: installId,\n        deviceToken: t,\n        deviceType: 'ios'\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId: installObj.objectId\n      }, input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {\n      objectId: tokenObj.objectId\n    }, {})).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].installationId).toEqual(installId);\n      expect(results[0].deviceToken).toEqual(t);\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"update is linking two existing with installation id w/ op","suites":["Installations"],"line":723,"updatePoint":{"line":723,"column":63,"index":27061},"code":"  it('update is linking two existing with installation id w/ op', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const t = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';\n    let input = {\n      installationId: installId,\n      deviceType: 'ios'\n    };\n    let installObj;\n    let tokenObj;\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      installObj = results[0];\n      input = {\n        deviceToken: t,\n        deviceType: 'ios'\n      };\n      return rest.create(config, auth.nobody(config), '_Installation', input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {\n      deviceToken: t\n    }, {})).then(results => {\n      expect(results.length).toEqual(1);\n      tokenObj = results[0];\n      input = {\n        installationId: installId,\n        deviceToken: t,\n        deviceType: 'ios',\n        score: {\n          __op: 'Increment',\n          amount: 1\n        }\n      };\n      return rest.update(config, auth.nobody(config), '_Installation', {\n        objectId: installObj.objectId\n      }, input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {\n      objectId: tokenObj.objectId\n    }, {})).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].installationId).toEqual(installId);\n      expect(results[0].deviceToken).toEqual(t);\n      expect(results[0].score).toEqual(1);\n      done();\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"ios merge existing same token no installation id","suites":["Installations"],"line":770,"updatePoint":{"line":770,"column":54,"index":28721},"code":"  it('ios merge existing same token no installation id', done => {\n    // Test creating installation when there is an existing object with the\n    // same device token but no installation ID.  This is possible when\n    // developers import device tokens from another push provider; the import\n    // process does not generate installation IDs. When they later integrate\n    // the Parse SDK, their app is going to save the installation. This save\n    // op will have a client-generated installation ID as well as a device\n    // token. At this point, if the device token matches the originally-\n    // imported installation, then we should reuse the existing installation\n    // object in case the developer already added additional fields via Data\n    // Browser or REST API (e.g. channel targeting info).\n    const t = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    let input = {\n      deviceToken: t,\n      deviceType: 'ios'\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      input = {\n        installationId: installId,\n        deviceToken: t,\n        deviceType: 'ios'\n      };\n      return rest.create(config, auth.nobody(config), '_Installation', input);\n    }).then(() => database.adapter.find('_Installation', installationSchema, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].deviceToken).toEqual(t);\n      expect(results[0].installationId).toEqual(installId);\n      done();\n    }).catch(error => {\n      console.log(error);\n      fail();\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"allows you to get your own installation (regression test for #1718)","suites":["Installations"],"line":806,"updatePoint":{"line":806,"column":73,"index":30518},"code":"  it('allows you to get your own installation (regression test for #1718)', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const device = 'android';\n    const input = {\n      installationId: installId,\n      deviceType: device\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(createResult => {\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      return request({\n        headers: headers,\n        url: 'http://localhost:8378/1/installations/' + createResult.response.objectId\n      }).then(response => {\n        const body = response.data;\n        expect(body.objectId).toEqual(createResult.response.objectId);\n        done();\n      });\n    }).catch(error => {\n      console.log(error);\n      fail('failed');\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"allows you to update installation from header (#2090)","suites":["Installations"],"line":832,"updatePoint":{"line":832,"column":59,"index":31370},"code":"  it('allows you to update installation from header (#2090)', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const device = 'android';\n    const input = {\n      installationId: installId,\n      deviceType: device\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Installation-Id': installId\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/classes/_Installation',\n        json: true,\n        body: {\n          date: new Date()\n        }\n      }).then(response => {\n        const body = response.data;\n        expect(response.status).toBe(200);\n        expect(body.updatedAt).not.toBeUndefined();\n        done();\n      });\n    }).catch(error => {\n      console.log(error);\n      fail('failed');\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"allows you to update installation with masterKey","suites":["Installations"],"line":865,"updatePoint":{"line":865,"column":54,"index":32342},"code":"  it('allows you to update installation with masterKey', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const device = 'android';\n    const input = {\n      installationId: installId,\n      deviceType: device\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(createResult => {\n      const installationObj = Parse.Installation.createWithoutData(createResult.response.objectId);\n      installationObj.set('customField', 'custom value');\n      return installationObj.save(null, {\n        useMasterKey: true\n      });\n    }).then(updateResult => {\n      expect(updateResult).not.toBeUndefined();\n      expect(updateResult.get('customField')).toEqual('custom value');\n      done();\n    }).catch(error => {\n      console.log(error);\n      fail('failed');\n      done();\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"should properly handle installation save #2780","suites":["Installations"],"line":888,"updatePoint":{"line":888,"column":52,"index":33176},"code":"  it('should properly handle installation save #2780', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const device = 'android';\n    const input = {\n      installationId: installId,\n      deviceType: device\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      const query = new Parse.Query(Parse.Installation);\n      query.equalTo('installationId', installId);\n      query.first({\n        useMasterKey: true\n      }).then(installation => {\n        return installation.save({\n          key: 'value'\n        }, {\n          useMasterKey: true\n        });\n      }).then(() => {\n        done();\n      }, err => {\n        jfail(err);\n        done();\n      });\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"should properly reject updating installationId","suites":["Installations"],"line":914,"updatePoint":{"line":914,"column":52,"index":33914},"code":"  it('should properly reject updating installationId', done => {\n    const installId = '12345678-abcd-abcd-abcd-123456789abc';\n    const device = 'android';\n    const input = {\n      installationId: installId,\n      deviceType: device\n    };\n    rest.create(config, auth.nobody(config), '_Installation', input).then(() => {\n      const query = new Parse.Query(Parse.Installation);\n      query.equalTo('installationId', installId);\n      query.first({\n        useMasterKey: true\n      }).then(installation => {\n        return installation.save({\n          key: 'value',\n          installationId: '22222222-abcd-abcd-abcd-123456789abc'\n        }, {\n          useMasterKey: true\n        });\n      }).then(() => {\n        fail('should not succeed');\n        done();\n      }, err => {\n        expect(err.code).toBe(136);\n        expect(err.message).toBe('installationId may not be changed in this operation');\n        done();\n      });\n    });\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"can use push with beforeSave","suites":["Installations"],"line":943,"updatePoint":{"line":943,"column":34,"index":34841},"code":"  it('can use push with beforeSave', async () => {\n    const input = {\n      deviceToken: '11433856eed2f1285fb3aa11136718c1198ed5647875096952c66bf8cb976306',\n      deviceType: 'ios'\n    };\n    await rest.create(config, auth.nobody(config), '_Installation', input);\n    const functions = {\n      beforeSave() {},\n      afterSave() {}\n    };\n    spyOn(functions, 'beforeSave').and.callThrough();\n    spyOn(functions, 'afterSave').and.callThrough();\n    Parse.Cloud.beforeSave(Parse.Installation, functions.beforeSave);\n    Parse.Cloud.afterSave(Parse.Installation, functions.afterSave);\n    await Parse.Push.send({\n      where: {\n        deviceType: 'ios'\n      },\n      data: {\n        badge: 'increment',\n        alert: 'Hello world!'\n      }\n    });\n    await Parse.Push.send({\n      where: {\n        deviceType: 'ios'\n      },\n      data: {\n        badge: 'increment',\n        alert: 'Hello world!'\n      }\n    });\n    await Parse.Push.send({\n      where: {\n        deviceType: 'ios'\n      },\n      data: {\n        badge: 'increment',\n        alert: 'Hello world!'\n      }\n    });\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const installation = await new Parse.Query(Parse.Installation).first({\n      useMasterKey: true\n    });\n    expect(installation.get('badge')).toEqual(3);\n    expect(functions.beforeSave).not.toHaveBeenCalled();\n    expect(functions.afterSave).not.toHaveBeenCalled();\n  });","file":"ParseInstallation.spec.js","skipped":false,"dir":"spec"},{"name":"access user on onLiveQueryEvent disconnect","suites":["ParseLiveQuery"],"line":9,"updatePoint":{"line":9,"column":48,"index":297},"code":"  it('access user on onLiveQueryEvent disconnect', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    Parse.CoreManager.getLiveQueryController().setDefaultLiveQueryClient(null);\n    const requestedUser = new Parse.User();\n    requestedUser.setUsername('username');\n    requestedUser.setPassword('password');\n    Parse.Cloud.onLiveQueryEvent(req => {\n      const {\n        event,\n        sessionToken\n      } = req;\n      if (event === 'ws_disconnect') {\n        Parse.Cloud._removeAllHooks();\n        expect(sessionToken).toBeDefined();\n        expect(sessionToken).toBe(requestedUser.getSessionToken());\n        done();\n      }\n    });\n    await requestedUser.signUp();\n    const query = new Parse.Query(TestObject);\n    await query.subscribe();\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.close();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can subscribe to query","suites":["ParseLiveQuery"],"line":40,"updatePoint":{"line":40,"column":28,"index":1292},"code":"  it('can subscribe to query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can use patterns in className","suites":["ParseLiveQuery"],"line":63,"updatePoint":{"line":63,"column":35,"index":1905},"code":"  it('can use patterns in className', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['Test.*']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"expect afterEvent create","suites":["ParseLiveQuery"],"line":86,"updatePoint":{"line":86,"column":30,"index":2509},"code":"  it('expect afterEvent create', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('create');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n    });\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"expect afterEvent payload","suites":["ParseLiveQuery"],"line":110,"updatePoint":{"line":110,"column":31,"index":3235},"code":"  it('expect afterEvent payload', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('update');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n      done();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"expect afterEvent enter","suites":["ParseLiveQuery"],"line":136,"updatePoint":{"line":136,"column":29,"index":3977},"code":"  it('expect afterEvent enter', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('enter');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n    });\n    const object = new TestObject();\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('enter', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set('foo', 'bar');\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"expect afterEvent leave","suites":["ParseLiveQuery"],"line":163,"updatePoint":{"line":163,"column":29,"index":4812},"code":"  it('expect afterEvent leave', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('leave');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBeUndefined();\n      expect(req.original.get('foo')).toBe('bar');\n    });\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('leave', object => {\n      expect(object.get('foo')).toBeUndefined();\n      done();\n    });\n    object.unset('foo');\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"expect afterEvent delete","suites":["ParseLiveQuery"],"line":191,"updatePoint":{"line":191,"column":30,"index":5677},"code":"  it('expect afterEvent delete', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('delete');\n      expect(req.user).toBeUndefined();\n      req.object.set('foo', 'bar');\n    });\n    const object = new TestObject();\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('delete', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    await object.destroy();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle afterEvent modification","suites":["ParseLiveQuery"],"line":216,"updatePoint":{"line":216,"column":40,"index":6439},"code":"  it('can handle afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      current.set('foo', 'yolo');\n      const original = req.original;\n      original.set('yolo', 'foo');\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', (object, original) => {\n      expect(object.get('foo')).toBe('yolo');\n      expect(original.get('yolo')).toBe('foo');\n      done();\n    });\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can return different object in afterEvent","suites":["ParseLiveQuery"],"line":246,"updatePoint":{"line":246,"column":47,"index":7332},"code":"  it('can return different object in afterEvent', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const object = new Parse.Object('Yolo');\n      req.object = object;\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.className).toBe('Yolo');\n      done();\n    });\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle afterEvent throw","suites":["ParseLiveQuery"],"line":273,"updatePoint":{"line":273,"column":33,"index":8084},"code":"  it('can handle afterEvent throw', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    Parse.Cloud.afterLiveQueryEvent('TestObject', () => {\n      throw 'Throw error from LQ afterEvent.';\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', () => {\n      fail('update should not have been called.');\n    });\n    subscription.on('error', e => {\n      expect(e).toBe('Throw error from LQ afterEvent.');\n      done();\n    });\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can log on afterLiveQueryEvent throw","suites":["ParseLiveQuery"],"line":302,"updatePoint":{"line":302,"column":42,"index":8920},"code":"  it('can log on afterLiveQueryEvent throw', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'error').and.callFake(() => {});\n    let session = undefined;\n    Parse.Cloud.afterLiveQueryEvent('TestObject', ({\n      sessionToken\n    }) => {\n      session = sessionToken;\n      /* eslint-disable no-undef */\n      foo.bar();\n      /* eslint-enable no-undef */\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n    await new Promise(resolve => subscription.on('error', resolve));\n    expect(logger.error).toHaveBeenCalledWith(`Failed running afterLiveQueryEvent on class TestObject for event update with session ${session} with:\\n Error: {\"message\":\"foo is not defined\",\"code\":141}`);\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle afterEvent sendEvent to false","suites":["ParseLiveQuery"],"line":335,"updatePoint":{"line":335,"column":46,"index":10050},"code":"  it('can handle afterEvent sendEvent to false', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      const original = req.original;\n      setTimeout(() => {\n        done();\n      }, 2000);\n      if (current.get('foo') != original.get('foo')) {\n        req.sendEvent = false;\n      }\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', () => {\n      fail('update should not have been called.');\n    });\n    subscription.on('error', () => {\n      fail('error should not have been called.');\n    });\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle afterEvent set pointers","suites":["ParseLiveQuery"],"line":370,"updatePoint":{"line":370,"column":40,"index":11040},"code":"  it('can handle afterEvent set pointers', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    const secondObject = new Parse.Object('Test2');\n    secondObject.set('foo', 'bar');\n    await secondObject.save();\n    Parse.Cloud.afterLiveQueryEvent('TestObject', async ({\n      object\n    }) => {\n      const query = new Parse.Query('Test2');\n      const obj = await query.first();\n      object.set('obj', obj);\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('obj')).toBeDefined();\n      expect(object.get('obj').get('foo')).toBe('bar');\n      done();\n    });\n    subscription.on('error', () => {\n      fail('error should not have been called.');\n    });\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle async afterEvent modification","suites":["ParseLiveQuery"],"line":407,"updatePoint":{"line":407,"column":46,"index":12143},"code":"  it('can handle async afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const parent = new TestObject();\n    const child = new TestObject();\n    child.set('bar', 'foo');\n    await Parse.Object.saveAll([parent, child]);\n    Parse.Cloud.afterLiveQueryEvent('TestObject', async req => {\n      const current = req.object;\n      const pointer = current.get('child');\n      await pointer.fetch();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', parent.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('child')).toBeDefined();\n      expect(object.get('child').get('bar')).toBe('foo');\n      done();\n    });\n    parent.set('child', child);\n    await parent.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle beforeConnect / beforeSubscribe hooks","suites":["ParseLiveQuery"],"line":436,"updatePoint":{"line":436,"column":54,"index":13096},"code":"  it('can handle beforeConnect / beforeSubscribe hooks', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    Parse.Cloud.beforeSubscribe('TestObject', req => {\n      expect(req.op).toBe('subscribe');\n      expect(req.requestId).toBe(1);\n      expect(req.query).toBeDefined();\n      expect(req.user).toBeUndefined();\n    });\n    Parse.Cloud.beforeConnect(req => {\n      expect(req.event).toBe('connect');\n      expect(req.clients).toBe(0);\n      expect(req.subscriptions).toBe(0);\n      expect(req.useMasterKey).toBe(false);\n      expect(req.installationId).toBeDefined();\n      expect(req.user).toBeUndefined();\n      expect(req.client).toBeDefined();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle beforeConnect validation function","suites":["ParseLiveQuery"],"line":474,"updatePoint":{"line":474,"column":50,"index":14279},"code":"  it('can handle beforeConnect validation function', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    Parse.Cloud.beforeConnect(() => {}, validatorFail);\n    let complete = false;\n    Parse.LiveQuery.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      if (complete) {\n        return;\n      }\n      complete = true;\n      expect(error).toBe('you are not authorized');\n      done();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle beforeSubscribe validation function","suites":["ParseLiveQuery"],"line":500,"updatePoint":{"line":500,"column":52,"index":15031},"code":"  it('can handle beforeSubscribe validation function', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    Parse.Cloud.beforeSubscribe(TestObject, () => {}, validatorFail);\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      expect(error).toBe('you are not authorized');\n      done();\n    });\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle afterEvent validation function","suites":["ParseLiveQuery"],"line":520,"updatePoint":{"line":520,"column":47,"index":15664},"code":"  it('can handle afterEvent validation function', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', () => {}, validatorFail);\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      expect(error).toBe('you are not authorized');\n      done();\n    });\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle beforeConnect error","suites":["ParseLiveQuery"],"line":540,"updatePoint":{"line":540,"column":36,"index":16280},"code":"  it('can handle beforeConnect error', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    Parse.Cloud.beforeConnect(() => {\n      throw new Error('You shall not pass!');\n    });\n    Parse.LiveQuery.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      expect(error).toBe('You shall not pass!');\n      done();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can log on beforeConnect throw","suites":["ParseLiveQuery"],"line":563,"updatePoint":{"line":563,"column":36,"index":16954},"code":"  it('can log on beforeConnect throw', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'error').and.callFake(() => {});\n    let token = undefined;\n    Parse.Cloud.beforeConnect(({\n      sessionToken\n    }) => {\n      token = sessionToken;\n      /* eslint-disable no-undef */\n      foo.bar();\n      /* eslint-enable no-undef */\n    });\n\n    new Parse.Query(TestObject).subscribe();\n    await new Promise(resolve => Parse.LiveQuery.on('error', resolve));\n    Parse.LiveQuery.removeAllListeners('error');\n    expect(logger.error).toHaveBeenCalledWith(`Failed running beforeConnect for session ${token} with:\\n Error: {\"message\":\"foo is not defined\",\"code\":141}`);\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle beforeSubscribe error","suites":["ParseLiveQuery"],"line":589,"updatePoint":{"line":589,"column":38,"index":17835},"code":"  it('can handle beforeSubscribe error', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    await object.save();\n    Parse.Cloud.beforeSubscribe(TestObject, () => {\n      throw new Error('You shall not subscribe!');\n    });\n    Parse.LiveQuery.on('error', error => {\n      expect(error).toBe('You shall not subscribe!');\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      expect(error).toBe('You shall not subscribe!');\n      done();\n    });\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can log on beforeSubscribe error","suites":["ParseLiveQuery"],"line":615,"updatePoint":{"line":615,"column":38,"index":18658},"code":"  it('can log on beforeSubscribe error', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'error').and.callFake(() => {});\n    Parse.Cloud.beforeSubscribe(TestObject, () => {\n      /* eslint-disable no-undef */\n      foo.bar();\n      /* eslint-enable no-undef */\n    });\n\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    await new Promise(resolve => subscription.on('error', resolve));\n    expect(logger.error).toHaveBeenCalledWith(`Failed running beforeSubscribe on TestObject for session undefined with:\\n Error: {\"message\":\"foo is not defined\",\"code\":141}`);\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle mutate beforeSubscribe query","suites":["ParseLiveQuery"],"line":637,"updatePoint":{"line":637,"column":45,"index":19496},"code":"  it('can handle mutate beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = request.query;\n      query.equalTo('yolo', 'abc');\n    });\n    const object = new TestObject();\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', () => {\n      fail();\n    });\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n    setTimeout(async () => {\n      done();\n    }, 1000);\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can return a new beforeSubscribe query","suites":["ParseLiveQuery"],"line":666,"updatePoint":{"line":666,"column":44,"index":20262},"code":"  it('can return a new beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'yolo');\n      request.query = query;\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('yolo');\n      done();\n    });\n    const object = new TestObject();\n    object.set({\n      foo: 'yolo'\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can handle select beforeSubscribe query","suites":["ParseLiveQuery"],"line":693,"updatePoint":{"line":693,"column":45,"index":21032},"code":"  it('can handle select beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = request.query;\n      query.select('yolo');\n    });\n    const object = new TestObject();\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBeUndefined();\n      expect(object.get('yolo')).toBe('abc');\n      done();\n    });\n    object.set({\n      foo: 'bar',\n      yolo: 'abc'\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"LiveQuery with ACL","suites":["ParseLiveQuery"],"line":722,"updatePoint":{"line":722,"column":24,"index":21831},"code":"  it('LiveQuery with ACL', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['Chat']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    await user.signUp();\n    const calls = {\n      beforeConnect(req) {\n        expect(req.event).toBe('connect');\n        expect(req.clients).toBe(0);\n        expect(req.subscriptions).toBe(0);\n        expect(req.useMasterKey).toBe(false);\n        expect(req.installationId).toBeDefined();\n        expect(req.client).toBeDefined();\n      },\n      beforeSubscribe(req) {\n        expect(req.op).toBe('subscribe');\n        expect(req.requestId).toBe(1);\n        expect(req.query).toBeDefined();\n        expect(req.user).toBeDefined();\n      },\n      afterLiveQueryEvent(req) {\n        expect(req.user).toBeDefined();\n        expect(req.object.get('foo')).toBe('bar');\n      },\n      create(object) {\n        expect(object.get('foo')).toBe('bar');\n      },\n      delete(object) {\n        expect(object.get('foo')).toBe('bar');\n      }\n    };\n    for (const key in calls) {\n      spyOn(calls, key).and.callThrough();\n    }\n    Parse.Cloud.beforeConnect(calls.beforeConnect);\n    Parse.Cloud.beforeSubscribe('Chat', calls.beforeSubscribe);\n    Parse.Cloud.afterLiveQueryEvent('Chat', calls.afterLiveQueryEvent);\n    const chatQuery = new Parse.Query('Chat');\n    const subscription = await chatQuery.subscribe();\n    subscription.on('create', calls.create);\n    subscription.on('delete', calls.delete);\n    const object = new Parse.Object('Chat');\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    object.set({\n      foo: 'bar'\n    });\n    await object.save();\n    await object.destroy();\n    await new Promise(resolve => setTimeout(resolve, 200));\n    for (const key in calls) {\n      expect(calls[key]).toHaveBeenCalled();\n    }\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"LiveQuery should work with changing role","suites":["ParseLiveQuery"],"line":784,"updatePoint":{"line":784,"column":46,"index":23814},"code":"  it('LiveQuery should work with changing role', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['Chat']\n      },\n      startLiveQueryServer: true\n    });\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    await user.signUp();\n    const role = new Parse.Role('Test', new Parse.ACL(user));\n    await role.save();\n    const chatQuery = new Parse.Query('Chat');\n    const subscription = await chatQuery.subscribe();\n    subscription.on('create', () => {\n      fail('should not call create as user is not part of role.');\n    });\n    const object = new Parse.Object('Chat');\n    const acl = new Parse.ACL();\n    acl.setRoleReadAccess(role, true);\n    object.setACL(acl);\n    object.set({\n      foo: 'bar'\n    });\n    await object.save(null, {\n      useMasterKey: true\n    });\n    role.getUsers().add(user);\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    await role.save();\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    object.set('foo', 'yolo');\n    await Promise.all([new Promise(resolve => {\n      subscription.on('update', obj => {\n        expect(obj.get('foo')).toBe('yolo');\n        expect(obj.getACL().toJSON()).toEqual({\n          'role:Test': {\n            read: true\n          }\n        });\n        resolve();\n      });\n    }), object.save(null, {\n      useMasterKey: true\n    })]);\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"liveQuery on Session class","suites":["ParseLiveQuery"],"line":831,"updatePoint":{"line":831,"column":32,"index":25223},"code":"  it('liveQuery on Session class', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: [Parse.Session]\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    await user.signUp();\n    const query = new Parse.Query(Parse.Session);\n    const subscription = await query.subscribe();\n    subscription.on('create', async obj => {\n      await new Promise(resolve => setTimeout(resolve, 200));\n      expect(obj.get('user').id).toBe(user.id);\n      expect(obj.get('createdWith')).toEqual({\n        action: 'login',\n        authProvider: 'password'\n      });\n      expect(obj.get('expiresAt')).toBeInstanceOf(Date);\n      expect(obj.get('installationId')).toBeDefined();\n      expect(obj.get('createdAt')).toBeInstanceOf(Date);\n      expect(obj.get('updatedAt')).toBeInstanceOf(Date);\n      done();\n    });\n    await Parse.User.logIn('username', 'password');\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"prevent liveQuery on Session class when not logged in","suites":["ParseLiveQuery"],"line":861,"updatePoint":{"line":861,"column":59,"index":26282},"code":"  it('prevent liveQuery on Session class when not logged in', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: [Parse.Session]\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    Parse.LiveQuery.on('error', error => {\n      expect(error).toBe('Invalid session token');\n    });\n    const query = new Parse.Query(Parse.Session);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      expect(error).toBe('Invalid session token');\n      done();\n    });\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"handle invalid websocket payload length","suites":["ParseLiveQuery"],"line":881,"updatePoint":{"line":881,"column":45,"index":26895},"code":"  it('handle invalid websocket payload length', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      websocketTimeout: 100\n    });\n    const object = new TestObject();\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    // All control frames must have a payload length of 125 bytes or less.\n    // https://tools.ietf.org/html/rfc6455#section-5.5\n    //\n    // 0x89 = 10001001 = ping\n    // 0xfe = 11111110 = first bit is masking the remaining 7 are 1111110 or 126 the payload length\n    // https://tools.ietf.org/html/rfc6455#section-5.2\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.socket._socket.write(Buffer.from([0x89, 0xfe]));\n    subscription.on('update', async object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    // Wait for Websocket timeout to reconnect\n    setTimeout(async () => {\n      object.set({\n        foo: 'bar'\n      });\n      await object.save();\n    }, 1000);\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should execute live query update on email validation","suites":["ParseLiveQuery"],"line":917,"updatePoint":{"line":917,"column":58,"index":28144},"code":"  it('should execute live query update on email validation', async done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    await reconfigureServer({\n      liveQuery: {\n        classNames: [Parse.User]\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      websocketTimeout: 100,\n      appName: 'liveQueryEmailValidation',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 20,\n      // 0.5 second\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      const user = new Parse.User();\n      user.set('password', 'asdf');\n      user.set('email', 'asdf@example.com');\n      user.set('username', 'zxcv');\n      user.signUp().then(() => {\n        const config = Config.get('test');\n        return config.database.find('_User', {\n          username: 'zxcv'\n        });\n      }).then(async results => {\n        const foundUser = results[0];\n        const query = new Parse.Query('_User');\n        query.equalTo('objectId', foundUser.objectId);\n        const subscription = await query.subscribe();\n        subscription.on('update', async object => {\n          expect(object).toBeDefined();\n          expect(object.get('emailVerified')).toBe(true);\n          done();\n        });\n        const userController = new UserController(emailAdapter, 'test', {\n          verifyUserEmails: true\n        });\n        userController.verifyEmail(foundUser.username, foundUser._email_verify_token);\n      });\n    });\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should not broadcast event to client with invalid session token - avisory GHSA-2xm2-xj2q-qgpj","suites":["ParseLiveQuery"],"line":964,"updatePoint":{"line":964,"column":99,"index":29805},"code":"  it('should not broadcast event to client with invalid session token - avisory GHSA-2xm2-xj2q-qgpj', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      liveQueryServerOptions: {\n        cacheTimeout: 100\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      cacheTTL: 100\n    });\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    await user.signUp();\n    const obj1 = new Parse.Object('TestObject');\n    const obj1ACL = new Parse.ACL();\n    obj1ACL.setPublicReadAccess(false);\n    obj1ACL.setReadAccess(user, true);\n    obj1.setACL(obj1ACL);\n    const obj2 = new Parse.Object('TestObject');\n    const obj2ACL = new Parse.ACL();\n    obj2ACL.setPublicReadAccess(false);\n    obj2ACL.setReadAccess(user, true);\n    obj2.setACL(obj2ACL);\n    const query = new Parse.Query('TestObject');\n    const subscription = await query.subscribe();\n    subscription.on('create', obj => {\n      if (obj.id !== obj1.id) {\n        done.fail('should not fire');\n      }\n    });\n    await obj1.save();\n    await Parse.User.logOut();\n    await new Promise(resolve => setTimeout(resolve, 200));\n    await obj2.save();\n    await new Promise(resolve => setTimeout(resolve, 200));\n    done();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should strip out session token in LiveQuery","suites":["ParseLiveQuery"],"line":1005,"updatePoint":{"line":1005,"column":49,"index":31086},"code":"  it('should strip out session token in LiveQuery', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['_User']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    user.set('foo', 'bar');\n    const query = new Parse.Query(Parse.User);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    const events = ['create', 'update', 'enter', 'leave', 'delete'];\n    const response = (obj, prev) => {\n      expect(obj.get('sessionToken')).toBeUndefined();\n      expect(obj.sessionToken).toBeUndefined();\n      expect(prev && prev.sessionToken).toBeUndefined();\n      if (prev && prev.get) {\n        expect(prev.get('sessionToken')).toBeUndefined();\n      }\n    };\n    const calls = {};\n    for (const key of events) {\n      calls[key] = response;\n      spyOn(calls, key).and.callThrough();\n      subscription.on(key, calls[key]);\n    }\n    await user.signUp();\n    user.unset('foo');\n    await user.save();\n    user.set('foo', 'bar');\n    await user.save();\n    user.set('yolo', 'bar');\n    await user.save();\n    await user.destroy();\n    await new Promise(resolve => setTimeout(resolve, 10));\n    for (const key of events) {\n      expect(calls[key]).toHaveBeenCalled();\n    }\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should strip out protected fields","suites":["ParseLiveQuery"],"line":1049,"updatePoint":{"line":1049,"column":39,"index":32464},"code":"  it('should strip out protected fields', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['Test']\n      },\n      startLiveQueryServer: true\n    });\n    const obj1 = new Parse.Object('Test');\n    obj1.set('foo', 'foo');\n    obj1.set('bar', 'bar');\n    obj1.set('qux', 'qux');\n    await obj1.save();\n    const config = Config.get(Parse.applicationId);\n    const schemaController = await config.database.loadSchema();\n    await schemaController.updateClass('Test', {}, {\n      get: {\n        '*': true\n      },\n      find: {\n        '*': true\n      },\n      update: {\n        '*': true\n      },\n      protectedFields: {\n        '*': ['foo']\n      }\n    });\n    const object = await obj1.fetch();\n    expect(object.get('foo')).toBe(undefined);\n    expect(object.get('bar')).toBeDefined();\n    expect(object.get('qux')).toBeDefined();\n    const subscription = await new Parse.Query('Test').subscribe();\n    await Promise.all([new Promise(resolve => {\n      subscription.on('update', (obj, original) => {\n        expect(obj.get('foo')).toBe(undefined);\n        expect(obj.get('bar')).toBeDefined();\n        expect(obj.get('qux')).toBeDefined();\n        expect(original.get('foo')).toBe(undefined);\n        expect(original.get('bar')).toBeDefined();\n        expect(original.get('qux')).toBeDefined();\n        resolve();\n      });\n    }), obj1.save({\n      foo: 'abc'\n    })]);\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can subscribe to query and return object with withinKilometers with last parameter on update","suites":["ParseLiveQuery"],"line":1096,"updatePoint":{"line":1096,"column":98,"index":33935},"code":"  it('can subscribe to query and return object with withinKilometers with last parameter on update', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const object = new TestObject();\n    const firstPoint = new Parse.GeoPoint({\n      latitude: 40.0,\n      longitude: -30.0\n    });\n    object.set({\n      location: firstPoint\n    });\n    await object.save();\n\n    // unsorted will use $centerSphere operator\n    const sorted = false;\n    const query = new Parse.Query(TestObject);\n    query.withinKilometers('location', new Parse.GeoPoint({\n      latitude: 40.0,\n      longitude: -30.0\n    }), 2, sorted);\n    const subscription = await query.subscribe();\n    subscription.on('update', obj => {\n      expect(obj.id).toBe(object.id);\n      done();\n    });\n    const secondPoint = new Parse.GeoPoint({\n      latitude: 40.0,\n      longitude: -30.0\n    });\n    object.set({\n      location: secondPoint\n    });\n    await object.save();\n  });","file":"ParseLiveQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can be initialized","suites":["ParseLiveQueryServer"],"line":87,"updatePoint":{"line":87,"column":24,"index":3670},"code":"  it('can be initialized', function () {\n    const httpServer = {};\n    const parseLiveQueryServer = new ParseLiveQueryServer(httpServer);\n    expect(parseLiveQueryServer.clientId).toBeUndefined();\n    expect(parseLiveQueryServer.clients.size).toBe(0);\n    expect(parseLiveQueryServer.subscriptions.size).toBe(0);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can be initialized from ParseServer","suites":["ParseLiveQueryServer"],"line":94,"updatePoint":{"line":94,"column":41,"index":4007},"code":"  it('can be initialized from ParseServer', function () {\n    const httpServer = {};\n    const parseLiveQueryServer = ParseServer.createLiveQueryServer(httpServer, {});\n    expect(parseLiveQueryServer.clientId).toBeUndefined();\n    expect(parseLiveQueryServer.clients.size).toBe(0);\n    expect(parseLiveQueryServer.subscriptions.size).toBe(0);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can be initialized from ParseServer without httpServer","suites":["ParseLiveQueryServer"],"line":101,"updatePoint":{"line":101,"column":60,"index":4376},"code":"  it('can be initialized from ParseServer without httpServer', function (done) {\n    const parseLiveQueryServer = ParseServer.createLiveQueryServer(undefined, {\n      port: 22345\n    });\n    expect(parseLiveQueryServer.clientId).toBeUndefined();\n    expect(parseLiveQueryServer.clients.size).toBe(0);\n    expect(parseLiveQueryServer.subscriptions.size).toBe(0);\n    parseLiveQueryServer.server.close(done);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can be initialized through ParseServer without liveQueryServerOptions","suites":["ParseLiveQueryServer"],"line":111,"updatePoint":{"line":111,"column":77,"index":4860},"code":"    it('can be initialized through ParseServer without liveQueryServerOptions', function (done) {\n      const parseServer = ParseServer.start({\n        appId: 'hello',\n        masterKey: 'world',\n        port: 22345,\n        mountPath: '/1',\n        serverURL: 'http://localhost:12345/1',\n        liveQuery: {\n          classNames: ['Yolo']\n        },\n        startLiveQueryServer: true,\n        serverStartComplete: () => {\n          expect(parseServer.liveQueryServer).not.toBeUndefined();\n          expect(parseServer.liveQueryServer.server).toBe(parseServer.server);\n          parseServer.server.close(async () => {\n            await reconfigureServer();\n            done();\n          });\n        }\n      });\n    });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can be initialized through ParseServer with liveQueryServerOptions","suites":["ParseLiveQueryServer"],"line":132,"updatePoint":{"line":132,"column":74,"index":5578},"code":"    it('can be initialized through ParseServer with liveQueryServerOptions', function (done) {\n      const parseServer = ParseServer.start({\n        appId: 'hello',\n        masterKey: 'world',\n        port: 22346,\n        mountPath: '/1',\n        serverURL: 'http://localhost:12345/1',\n        liveQuery: {\n          classNames: ['Yolo']\n        },\n        liveQueryServerOptions: {\n          port: 22347\n        },\n        serverStartComplete: () => {\n          expect(parseServer.liveQueryServer).not.toBeUndefined();\n          expect(parseServer.liveQueryServer.server).not.toBe(parseServer.server);\n          parseServer.liveQueryServer.server.close(parseServer.server.close.bind(parseServer.server, async () => {\n            await reconfigureServer();\n            done();\n          }));\n        }\n      });\n    });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"properly passes the CLP to afterSave/afterDelete hook","suites":["ParseLiveQueryServer"],"line":156,"updatePoint":{"line":156,"column":59,"index":6389},"code":"  it('properly passes the CLP to afterSave/afterDelete hook', function (done) {\n    function setPermissionsOnClass(className, permissions, doPut) {\n      const request = require('request');\n      let op = request.post;\n      if (doPut) {\n        op = request.put;\n      }\n      return new Promise((resolve, reject) => {\n        op({\n          url: Parse.serverURL + '/schemas/' + className,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Master-Key': Parse.masterKey\n          },\n          json: true,\n          body: {\n            classLevelPermissions: permissions\n          }\n        }, (error, response, body) => {\n          if (error) {\n            return reject(error);\n          }\n          if (body.error) {\n            return reject(body);\n          }\n          return resolve(body);\n        });\n      });\n    }\n    let saveSpy;\n    let deleteSpy;\n    reconfigureServer({\n      liveQuery: {\n        classNames: ['Yolo']\n      }\n    }).then(parseServer => {\n      saveSpy = spyOn(parseServer.config.liveQueryController, 'onAfterSave');\n      deleteSpy = spyOn(parseServer.config.liveQueryController, 'onAfterDelete');\n      return setPermissionsOnClass('Yolo', {\n        create: {\n          '*': true\n        },\n        delete: {\n          '*': true\n        }\n      });\n    }).then(() => {\n      const obj = new Parse.Object('Yolo');\n      return obj.save();\n    }).then(obj => {\n      return obj.destroy();\n    }).then(() => {\n      expect(saveSpy).toHaveBeenCalled();\n      const saveArgs = saveSpy.calls.mostRecent().args;\n      expect(saveArgs.length).toBe(4);\n      expect(saveArgs[0]).toBe('Yolo');\n      expect(saveArgs[3]).toEqual({\n        get: {},\n        count: {},\n        addField: {},\n        create: {\n          '*': true\n        },\n        find: {},\n        update: {},\n        delete: {\n          '*': true\n        },\n        protectedFields: {}\n      });\n      expect(deleteSpy).toHaveBeenCalled();\n      const deleteArgs = deleteSpy.calls.mostRecent().args;\n      expect(deleteArgs.length).toBe(4);\n      expect(deleteArgs[0]).toBe('Yolo');\n      expect(deleteArgs[3]).toEqual({\n        get: {},\n        count: {},\n        addField: {},\n        create: {\n          '*': true\n        },\n        find: {},\n        update: {},\n        delete: {\n          '*': true\n        },\n        protectedFields: {}\n      });\n      done();\n    }).catch(done.fail);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle connect command","suites":["ParseLiveQueryServer"],"line":247,"updatePoint":{"line":247,"column":32,"index":8799},"code":"  it('can handle connect command', async () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const parseWebSocket = {\n      clientId: -1\n    };\n    parseLiveQueryServer._validateKeys = jasmine.createSpy('validateKeys').and.returnValue(true);\n    await parseLiveQueryServer._handleConnect(parseWebSocket, {\n      sessionToken: 'token'\n    });\n    const clientKeys = parseLiveQueryServer.clients.keys();\n    expect(parseLiveQueryServer.clients.size).toBe(1);\n    const firstKey = clientKeys.next().value;\n    expect(parseWebSocket.clientId).toBe(firstKey);\n    const client = parseLiveQueryServer.clients.get(firstKey);\n    expect(client).not.toBeNull();\n    // Make sure we send connect response to the client\n    expect(client.pushConnect).toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeConnect rejection","suites":["ParseLiveQueryServer"],"line":265,"updatePoint":{"line":265,"column":35,"index":9591},"code":"  it('basic beforeConnect rejection', async () => {\n    Parse.Cloud.beforeConnect(function () {\n      throw new Error('You shall not pass!');\n    });\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const parseWebSocket = {\n      clientId: -1\n    };\n    await parseLiveQueryServer._handleConnect(parseWebSocket, {\n      sessionToken: 'token'\n    });\n    expect(parseLiveQueryServer.clients.size).toBe(0);\n    const Client = require('../lib/LiveQuery/Client').Client;\n    expect(Client.pushError).toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"basic beforeSubscribe rejection","suites":["ParseLiveQueryServer"],"line":280,"updatePoint":{"line":280,"column":37,"index":10133},"code":"  it('basic beforeSubscribe rejection', async () => {\n    Parse.Cloud.beforeSubscribe('test', function () {\n      throw new Error('You shall not pass!');\n    });\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const parseWebSocket = {\n      clientId: -1\n    };\n    await parseLiveQueryServer._handleConnect(parseWebSocket, {\n      sessionToken: 'token'\n    });\n    const query = {\n      className: 'test',\n      where: {\n        key: 'value'\n      },\n      fields: ['test']\n    };\n    const requestId = 2;\n    const request = {\n      query: query,\n      requestId: requestId,\n      sessionToken: 'sessionToken'\n    };\n    await parseLiveQueryServer._handleSubscribe(parseWebSocket, request);\n    expect(parseLiveQueryServer.clients.size).toBe(1);\n    const Client = require('../lib/LiveQuery/Client').Client;\n    expect(Client.pushError).toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle subscribe command without clientId","suites":["ParseLiveQueryServer"],"line":309,"updatePoint":{"line":309,"column":51,"index":11030},"code":"  it('can handle subscribe command without clientId', async () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const incompleteParseConn = {};\n    await parseLiveQueryServer._handleSubscribe(incompleteParseConn, {});\n    const Client = require('../lib/LiveQuery/Client').Client;\n    expect(Client.pushError).toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle subscribe command with new query","suites":["ParseLiveQueryServer"],"line":316,"updatePoint":{"line":316,"column":49,"index":11386},"code":"  it('can handle subscribe command with new query', async () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Add mock client\n    const clientId = 1;\n    const client = addMockClient(parseLiveQueryServer, clientId);\n    // Handle mock subscription\n    const parseWebSocket = {\n      clientId: clientId\n    };\n    const query = {\n      className: 'test',\n      where: {\n        key: 'value'\n      },\n      fields: ['test']\n    };\n    const requestId = 2;\n    const request = {\n      query: query,\n      requestId: requestId,\n      sessionToken: 'sessionToken'\n    };\n    await parseLiveQueryServer._handleSubscribe(parseWebSocket, request);\n\n    // Make sure we add the subscription to the server\n    const subscriptions = parseLiveQueryServer.subscriptions;\n    expect(subscriptions.size).toBe(1);\n    expect(subscriptions.get(query.className)).not.toBeNull();\n    const classSubscriptions = subscriptions.get(query.className);\n    expect(classSubscriptions.size).toBe(1);\n    expect(classSubscriptions.get('hash')).not.toBeNull();\n    // TODO(check subscription constructor to verify we pass the right argument)\n    // Make sure we add clientInfo to the subscription\n    const subscription = classSubscriptions.get('hash');\n    expect(subscription.addClientSubscription).toHaveBeenCalledWith(clientId, requestId);\n    // Make sure we add subscriptionInfo to the client\n    const args = client.addSubscriptionInfo.calls.first().args;\n    expect(args[0]).toBe(requestId);\n    expect(args[1].fields).toBe(query.fields);\n    expect(args[1].sessionToken).toBe(request.sessionToken);\n    // Make sure we send subscribe response to the client\n    expect(client.pushSubscribe).toHaveBeenCalledWith(requestId);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle subscribe command with existing query","suites":["ParseLiveQueryServer"],"line":359,"updatePoint":{"line":359,"column":54,"index":13126},"code":"  it('can handle subscribe command with existing query', async () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Add two mock clients\n    const clientId = 1;\n    addMockClient(parseLiveQueryServer, clientId);\n    const clientIdAgain = 2;\n    const clientAgain = addMockClient(parseLiveQueryServer, clientIdAgain);\n    // Add subscription for mock client 1\n    const parseWebSocket = {\n      clientId: clientId\n    };\n    const requestId = 2;\n    const query = {\n      className: 'test',\n      where: {\n        key: 'value'\n      },\n      fields: ['test']\n    };\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId, parseWebSocket, query);\n    // Add subscription for mock client 2\n    const parseWebSocketAgain = {\n      clientId: clientIdAgain\n    };\n    const queryAgain = {\n      className: 'test',\n      where: {\n        key: 'value'\n      },\n      fields: ['testAgain']\n    };\n    const requestIdAgain = 1;\n    await addMockSubscription(parseLiveQueryServer, clientIdAgain, requestIdAgain, parseWebSocketAgain, queryAgain);\n\n    // Make sure we only have one subscription\n    const subscriptions = parseLiveQueryServer.subscriptions;\n    expect(subscriptions.size).toBe(1);\n    expect(subscriptions.get(query.className)).not.toBeNull();\n    const classSubscriptions = subscriptions.get(query.className);\n    expect(classSubscriptions.size).toBe(1);\n    expect(classSubscriptions.get('hash')).not.toBeNull();\n    // Make sure we add clientInfo to the subscription\n    const subscription = classSubscriptions.get('hash');\n    // Make sure client 2 info has been added\n    let args = subscription.addClientSubscription.calls.mostRecent().args;\n    expect(args).toEqual([clientIdAgain, requestIdAgain]);\n    // Make sure we add subscriptionInfo to the client 2\n    args = clientAgain.addSubscriptionInfo.calls.mostRecent().args;\n    expect(args[0]).toBe(requestIdAgain);\n    expect(args[1].fields).toBe(queryAgain.fields);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle unsubscribe command without clientId","suites":["ParseLiveQueryServer"],"line":410,"updatePoint":{"line":410,"column":53,"index":15103},"code":"  it('can handle unsubscribe command without clientId', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const incompleteParseConn = {};\n    parseLiveQueryServer._handleUnsubscribe(incompleteParseConn, {});\n    const Client = require('../lib/LiveQuery/Client').Client;\n    expect(Client.pushError).toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle unsubscribe command without not existed client","suites":["ParseLiveQueryServer"],"line":417,"updatePoint":{"line":417,"column":63,"index":15469},"code":"  it('can handle unsubscribe command without not existed client', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const parseWebSocket = {\n      clientId: 1\n    };\n    parseLiveQueryServer._handleUnsubscribe(parseWebSocket, {});\n    const Client = require('../lib/LiveQuery/Client').Client;\n    expect(Client.pushError).toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle unsubscribe command without not existed query","suites":["ParseLiveQueryServer"],"line":426,"updatePoint":{"line":426,"column":62,"index":15847},"code":"  it('can handle unsubscribe command without not existed query', async () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Add mock client\n    const clientId = 1;\n    addMockClient(parseLiveQueryServer, clientId);\n    // Handle unsubscribe command\n    const parseWebSocket = {\n      clientId: 1\n    };\n    parseLiveQueryServer._handleUnsubscribe(parseWebSocket, {});\n    const Client = require('../lib/LiveQuery/Client').Client;\n    expect(Client.pushError).toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle unsubscribe command","suites":["ParseLiveQueryServer"],"line":439,"updatePoint":{"line":439,"column":36,"index":16331},"code":"  it('can handle unsubscribe command', async () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Add mock client\n    const clientId = 1;\n    const client = addMockClient(parseLiveQueryServer, clientId);\n    // Add subscription for mock client\n    const parseWebSocket = {\n      clientId: 1\n    };\n    const requestId = 2;\n    const subscription = await addMockSubscription(parseLiveQueryServer, clientId, requestId, parseWebSocket);\n    // Mock client.getSubscriptionInfo\n    const subscriptionInfo = client.addSubscriptionInfo.calls.mostRecent().args[1];\n    client.getSubscriptionInfo = function () {\n      return subscriptionInfo;\n    };\n    // Handle unsubscribe command\n    const requestAgain = {\n      requestId: requestId\n    };\n    parseLiveQueryServer._handleUnsubscribe(parseWebSocket, requestAgain);\n\n    // Make sure we delete subscription from client\n    expect(client.deleteSubscriptionInfo).toHaveBeenCalledWith(requestId);\n    // Make sure we delete client from subscription\n    expect(subscription.deleteClientSubscription).toHaveBeenCalledWith(clientId, requestId);\n    // Make sure we clear subscription in the server\n    const subscriptions = parseLiveQueryServer.subscriptions;\n    expect(subscriptions.size).toBe(0);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can set connect command message handler for a parseWebSocket","suites":["ParseLiveQueryServer"],"line":469,"updatePoint":{"line":469,"column":66,"index":17632},"code":"  it('can set connect command message handler for a parseWebSocket', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Register mock connect/subscribe/unsubscribe handler for the server\n    parseLiveQueryServer._handleConnect = jasmine.createSpy('_handleSubscribe');\n    // Make mock parseWebsocket\n    const EventEmitter = require('events');\n    const parseWebSocket = new EventEmitter();\n    // Register message handlers for the parseWebSocket\n    parseLiveQueryServer._onConnect(parseWebSocket);\n\n    // Check connect request\n    const connectRequest = {\n      op: 'connect',\n      applicationId: '1',\n      installationId: '1234'\n    };\n    // Trigger message event\n    parseWebSocket.emit('message', connectRequest);\n    // Make sure _handleConnect is called\n    const args = parseLiveQueryServer._handleConnect.calls.mostRecent().args;\n    expect(args[0]).toBe(parseWebSocket);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can set subscribe command message handler for a parseWebSocket","suites":["ParseLiveQueryServer"],"line":491,"updatePoint":{"line":491,"column":68,"index":18558},"code":"  it('can set subscribe command message handler for a parseWebSocket', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Register mock connect/subscribe/unsubscribe handler for the server\n    parseLiveQueryServer._handleSubscribe = jasmine.createSpy('_handleSubscribe');\n    // Make mock parseWebsocket\n    const EventEmitter = require('events');\n    const parseWebSocket = new EventEmitter();\n    // Register message handlers for the parseWebSocket\n    parseLiveQueryServer._onConnect(parseWebSocket);\n\n    // Check subscribe request\n    const subscribeRequest = JSON.stringify({\n      op: 'subscribe',\n      requestId: 1,\n      query: {\n        className: 'Test',\n        where: {}\n      }\n    });\n    // Trigger message event\n    parseWebSocket.emit('message', subscribeRequest);\n    // Make sure _handleSubscribe is called\n    const args = parseLiveQueryServer._handleSubscribe.calls.mostRecent().args;\n    expect(args[0]).toBe(parseWebSocket);\n    expect(JSON.stringify(args[1])).toBe(subscribeRequest);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can set unsubscribe command message handler for a parseWebSocket","suites":["ParseLiveQueryServer"],"line":517,"updatePoint":{"line":517,"column":70,"index":19609},"code":"  it('can set unsubscribe command message handler for a parseWebSocket', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Register mock connect/subscribe/unsubscribe handler for the server\n    parseLiveQueryServer._handleUnsubscribe = jasmine.createSpy('_handleSubscribe');\n    // Make mock parseWebsocket\n    const EventEmitter = require('events');\n    const parseWebSocket = new EventEmitter();\n    // Register message handlers for the parseWebSocket\n    parseLiveQueryServer._onConnect(parseWebSocket);\n\n    // Check unsubscribe request\n    const unsubscribeRequest = JSON.stringify({\n      op: 'unsubscribe',\n      requestId: 1\n    });\n    // Trigger message event\n    parseWebSocket.emit('message', unsubscribeRequest);\n    // Make sure _handleUnsubscribe is called\n    const args = parseLiveQueryServer._handleUnsubscribe.calls.mostRecent().args;\n    expect(args[0]).toBe(parseWebSocket);\n    expect(JSON.stringify(args[1])).toBe(unsubscribeRequest);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can set update command message handler for a parseWebSocket","suites":["ParseLiveQueryServer"],"line":539,"updatePoint":{"line":539,"column":65,"index":20602},"code":"  it('can set update command message handler for a parseWebSocket', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Register mock connect/subscribe/unsubscribe handler for the server\n    spyOn(parseLiveQueryServer, '_handleUpdateSubscription').and.callThrough();\n    spyOn(parseLiveQueryServer, '_handleUnsubscribe').and.callThrough();\n    spyOn(parseLiveQueryServer, '_handleSubscribe').and.callThrough();\n\n    // Make mock parseWebsocket\n    const EventEmitter = require('events');\n    const parseWebSocket = new EventEmitter();\n\n    // Register message handlers for the parseWebSocket\n    parseLiveQueryServer._onConnect(parseWebSocket);\n\n    // Check updateRequest request\n    const updateRequest = JSON.stringify({\n      op: 'update',\n      requestId: 1,\n      query: {\n        className: 'Test',\n        where: {}\n      }\n    });\n    // Trigger message event\n    parseWebSocket.emit('message', updateRequest);\n    // Make sure _handleUnsubscribe is called\n    const args = parseLiveQueryServer._handleUpdateSubscription.calls.mostRecent().args;\n    expect(args[0]).toBe(parseWebSocket);\n    expect(JSON.stringify(args[1])).toBe(updateRequest);\n    expect(parseLiveQueryServer._handleUnsubscribe).toHaveBeenCalled();\n    const unsubArgs = parseLiveQueryServer._handleUnsubscribe.calls.mostRecent().args;\n    expect(unsubArgs.length).toBe(3);\n    expect(unsubArgs[2]).toBe(false);\n    expect(parseLiveQueryServer._handleSubscribe).toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can set missing command message handler for a parseWebSocket","suites":["ParseLiveQueryServer"],"line":574,"updatePoint":{"line":574,"column":66,"index":22100},"code":"  it('can set missing command message handler for a parseWebSocket', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock parseWebsocket\n    const EventEmitter = require('events');\n    const parseWebSocket = new EventEmitter();\n    // Register message handlers for the parseWebSocket\n    parseLiveQueryServer._onConnect(parseWebSocket);\n\n    // Check invalid request\n    const invalidRequest = '{}';\n    // Trigger message event\n    parseWebSocket.emit('message', invalidRequest);\n    const Client = require('../lib/LiveQuery/Client').Client;\n    expect(Client.pushError).toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can set unknown command message handler for a parseWebSocket","suites":["ParseLiveQueryServer"],"line":589,"updatePoint":{"line":589,"column":66,"index":22739},"code":"  it('can set unknown command message handler for a parseWebSocket', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock parseWebsocket\n    const EventEmitter = require('events');\n    const parseWebSocket = new EventEmitter();\n    // Register message handlers for the parseWebSocket\n    parseLiveQueryServer._onConnect(parseWebSocket);\n\n    // Check unknown request\n    const unknownRequest = '{\"op\":\"unknown\"}';\n    // Trigger message event\n    parseWebSocket.emit('message', unknownRequest);\n    const Client = require('../lib/LiveQuery/Client').Client;\n    expect(Client.pushError).toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can set disconnect command message handler for a parseWebSocket which has not registered to the server","suites":["ParseLiveQueryServer"],"line":604,"updatePoint":{"line":604,"column":108,"index":23434},"code":"  it('can set disconnect command message handler for a parseWebSocket which has not registered to the server', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const EventEmitter = require('events');\n    const parseWebSocket = new EventEmitter();\n    parseWebSocket.clientId = 1;\n    // Register message handlers for the parseWebSocket\n    parseLiveQueryServer._onConnect(parseWebSocket);\n\n    // Make sure we do not crash\n    // Trigger disconnect event\n    parseWebSocket.emit('disconnect');\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can forward event to cloud code","suites":["ParseLiveQueryServer"],"line":616,"updatePoint":{"line":616,"column":37,"index":23895},"code":"  it('can forward event to cloud code', function () {\n    const cloudCodeHandler = {\n      handler: () => {}\n    };\n    const spy = spyOn(cloudCodeHandler, 'handler').and.callThrough();\n    Parse.Cloud.onLiveQueryEvent(cloudCodeHandler.handler);\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const EventEmitter = require('events');\n    const parseWebSocket = new EventEmitter();\n    parseWebSocket.clientId = 1;\n    // Register message handlers for the parseWebSocket\n    parseLiveQueryServer._onConnect(parseWebSocket);\n\n    // Make sure we do not crash\n    // Trigger disconnect event\n    parseWebSocket.emit('disconnect');\n    expect(spy).toHaveBeenCalled();\n    // call for ws_connect, another for ws_disconnect\n    expect(spy.calls.count()).toBe(2);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"has no subscription and can handle object delete command","suites":["ParseLiveQueryServer"],"line":639,"updatePoint":{"line":639,"column":62,"index":24791},"code":"  it('has no subscription and can handle object delete command', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make deletedParseObject\n    const parseObject = new Parse.Object(testClassName);\n    parseObject._finishFetch({\n      key: 'value',\n      className: testClassName\n    });\n    // Make mock message\n    const message = {\n      currentParseObject: parseObject\n    };\n    // Make sure we do not crash in this case\n    parseLiveQueryServer._onAfterDelete(message, {});\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle object delete command which does not match any subscription","suites":["ParseLiveQueryServer"],"line":654,"updatePoint":{"line":654,"column":76,"index":25323},"code":"  it('can handle object delete command which does not match any subscription', async () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make deletedParseObject\n    const parseObject = new Parse.Object(testClassName);\n    parseObject._finishFetch({\n      key: 'value',\n      className: testClassName\n    });\n    // Make mock message\n    const message = {\n      currentParseObject: parseObject\n    };\n\n    // Add mock client\n    const clientId = 1;\n    addMockClient(parseLiveQueryServer, clientId);\n    // Add mock subscription\n    const requestId = 2;\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId);\n    const client = parseLiveQueryServer.clients.get(clientId);\n    // Mock _matchesSubscription to return not matching\n    parseLiveQueryServer._matchesSubscription = function () {\n      return false;\n    };\n    parseLiveQueryServer._matchesACL = function () {\n      return true;\n    };\n    parseLiveQueryServer._onAfterDelete(message);\n\n    // Make sure we do not send command to client\n    expect(client.pushDelete).not.toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle object delete command which matches some subscriptions","suites":["ParseLiveQueryServer"],"line":686,"updatePoint":{"line":686,"column":71,"index":26419},"code":"  it('can handle object delete command which matches some subscriptions', async done => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make deletedParseObject\n    const parseObject = new Parse.Object(testClassName);\n    parseObject._finishFetch({\n      key: 'value',\n      className: testClassName\n    });\n    // Make mock message\n    const message = {\n      currentParseObject: parseObject\n    };\n    // Add mock client\n    const clientId = 1;\n    addMockClient(parseLiveQueryServer, clientId);\n    // Add mock subscription\n    const requestId = 2;\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId);\n    const client = parseLiveQueryServer.clients.get(clientId);\n    // Mock _matchesSubscription to return matching\n    parseLiveQueryServer._matchesSubscription = function () {\n      return true;\n    };\n    parseLiveQueryServer._matchesACL = function () {\n      return Promise.resolve(true);\n    };\n    parseLiveQueryServer._onAfterDelete(message);\n\n    // Make sure we send command to client, since _matchesACL is async, we have to\n    // wait and check\n    await timeout();\n    expect(client.pushDelete).toHaveBeenCalled();\n    done();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"has no subscription and can handle object save command","suites":["ParseLiveQueryServer"],"line":720,"updatePoint":{"line":720,"column":60,"index":27601},"code":"  it('has no subscription and can handle object save command', async () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock request message\n    const message = generateMockMessage();\n    // Make sure we do not crash in this case\n    parseLiveQueryServer._onAfterSave(message);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle object save command which does not match any subscription","suites":["ParseLiveQueryServer"],"line":727,"updatePoint":{"line":727,"column":74,"index":27931},"code":"  it('can handle object save command which does not match any subscription', async done => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock request message\n    const message = generateMockMessage();\n    // Add mock client\n    const clientId = 1;\n    const client = addMockClient(parseLiveQueryServer, clientId);\n    // Add mock subscription\n    const requestId = 2;\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId);\n    // Mock _matchesSubscription to return not matching\n    parseLiveQueryServer._matchesSubscription = function () {\n      return false;\n    };\n    parseLiveQueryServer._matchesACL = function () {\n      return Promise.resolve(true);\n    };\n    // Trigger onAfterSave\n    parseLiveQueryServer._onAfterSave(message);\n\n    // Make sure we do not send command to client\n    await timeout();\n    expect(client.pushCreate).not.toHaveBeenCalled();\n    expect(client.pushEnter).not.toHaveBeenCalled();\n    expect(client.pushUpdate).not.toHaveBeenCalled();\n    expect(client.pushDelete).not.toHaveBeenCalled();\n    expect(client.pushLeave).not.toHaveBeenCalled();\n    done();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle object enter command which matches some subscriptions","suites":["ParseLiveQueryServer"],"line":756,"updatePoint":{"line":756,"column":70,"index":29074},"code":"  it('can handle object enter command which matches some subscriptions', async done => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock request message\n    const message = generateMockMessage(true);\n    // Add mock client\n    const clientId = 1;\n    const client = addMockClient(parseLiveQueryServer, clientId);\n    // Add mock subscription\n    const requestId = 2;\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId);\n    // Mock _matchesSubscription to return matching\n    // In order to mimic a enter, we need original match return false\n    // and the current match return true\n    let counter = 0;\n    parseLiveQueryServer._matchesSubscription = function (parseObject) {\n      if (!parseObject) {\n        return false;\n      }\n      counter += 1;\n      return counter % 2 === 0;\n    };\n    parseLiveQueryServer._matchesACL = function () {\n      return Promise.resolve(true);\n    };\n    parseLiveQueryServer._onAfterSave(message);\n\n    // Make sure we send enter command to client\n    await timeout();\n    expect(client.pushCreate).not.toHaveBeenCalled();\n    expect(client.pushEnter).toHaveBeenCalled();\n    expect(client.pushUpdate).not.toHaveBeenCalled();\n    expect(client.pushDelete).not.toHaveBeenCalled();\n    expect(client.pushLeave).not.toHaveBeenCalled();\n    done();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle object update command which matches some subscriptions","suites":["ParseLiveQueryServer"],"line":791,"updatePoint":{"line":791,"column":71,"index":30417},"code":"  it('can handle object update command which matches some subscriptions', async done => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock request message\n    const message = generateMockMessage(true);\n    // Add mock client\n    const clientId = 1;\n    const client = addMockClient(parseLiveQueryServer, clientId);\n    // Add mock subscription\n    const requestId = 2;\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId);\n    // Mock _matchesSubscription to return matching\n    parseLiveQueryServer._matchesSubscription = function (parseObject) {\n      if (!parseObject) {\n        return false;\n      }\n      return true;\n    };\n    parseLiveQueryServer._matchesACL = function () {\n      return Promise.resolve(true);\n    };\n    parseLiveQueryServer._onAfterSave(message);\n\n    // Make sure we send update command to client\n    await timeout();\n    expect(client.pushCreate).not.toHaveBeenCalled();\n    expect(client.pushEnter).not.toHaveBeenCalled();\n    expect(client.pushUpdate).toHaveBeenCalled();\n    expect(client.pushDelete).not.toHaveBeenCalled();\n    expect(client.pushLeave).not.toHaveBeenCalled();\n    done();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle object leave command which matches some subscriptions","suites":["ParseLiveQueryServer"],"line":822,"updatePoint":{"line":822,"column":70,"index":31595},"code":"  it('can handle object leave command which matches some subscriptions', async done => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock request message\n    const message = generateMockMessage(true);\n    // Add mock client\n    const clientId = 1;\n    const client = addMockClient(parseLiveQueryServer, clientId);\n    // Add mock subscription\n    const requestId = 2;\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId);\n    // Mock _matchesSubscription to return matching\n    // In order to mimic a leave, we need original match return true\n    // and the current match return false\n    let counter = 0;\n    parseLiveQueryServer._matchesSubscription = function (parseObject) {\n      if (!parseObject) {\n        return false;\n      }\n      counter += 1;\n      return counter % 2 !== 0;\n    };\n    parseLiveQueryServer._matchesACL = function () {\n      return Promise.resolve(true);\n    };\n    parseLiveQueryServer._onAfterSave(message);\n\n    // Make sure we send leave command to client\n    await timeout();\n    expect(client.pushCreate).not.toHaveBeenCalled();\n    expect(client.pushEnter).not.toHaveBeenCalled();\n    expect(client.pushUpdate).not.toHaveBeenCalled();\n    expect(client.pushDelete).not.toHaveBeenCalled();\n    expect(client.pushLeave).toHaveBeenCalled();\n    done();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"sends correct events for object with multiple subscriptions","suites":["ParseLiveQueryServer"],"line":857,"updatePoint":{"line":857,"column":65,"index":32932},"code":"  it('sends correct events for object with multiple subscriptions', async done => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    Parse.Cloud.afterLiveQueryEvent('TestObject', () => {\n      // Simulate delay due to trigger, auth, etc.\n      return jasmine.timeout(10);\n    });\n\n    // Make mock request message\n    const message = generateMockMessage(true);\n    // Add mock client\n    const clientId = 1;\n    const client = addMockClient(parseLiveQueryServer, clientId);\n    client.sessionToken = 'sessionToken';\n\n    // Mock queryHash for this special test\n    const mockQueryHash = jasmine.createSpy('matchesQuery').and.returnValue('hash1');\n    jasmine.mockLibrary('../lib/LiveQuery/QueryTools', 'queryHash', mockQueryHash);\n    // Add mock subscription 1\n    const requestId2 = 2;\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId2, null, null, 'hash1');\n\n    // Mock queryHash for this special test\n    const mockQueryHash2 = jasmine.createSpy('matchesQuery').and.returnValue('hash2');\n    jasmine.mockLibrary('../lib/LiveQuery/QueryTools', 'queryHash', mockQueryHash2);\n    // Add mock subscription 2\n    const requestId3 = 3;\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId3, null, null, 'hash2');\n    // Mock _matchesSubscription to return matching\n    // In order to mimic a leave, then enter, we need original match return true\n    // and the current match return false, then the other way around\n    let counter = 0;\n    parseLiveQueryServer._matchesSubscription = function (parseObject) {\n      if (!parseObject) {\n        return false;\n      }\n      counter += 1;\n      // true, false, false, true\n      return counter < 2 || counter > 3;\n    };\n    parseLiveQueryServer._matchesACL = function () {\n      // Simulate call\n      return jasmine.timeout(10).then(() => true);\n    };\n    parseLiveQueryServer._onAfterSave(message);\n\n    // Make sure we send leave and enter command to client\n    await timeout();\n    expect(client.pushCreate).not.toHaveBeenCalled();\n    expect(client.pushEnter).toHaveBeenCalledTimes(1);\n    expect(client.pushEnter).toHaveBeenCalledWith(requestId3, {\n      key: 'value',\n      className: 'TestObject'\n    }, {\n      key: 'originalValue',\n      className: 'TestObject'\n    });\n    expect(client.pushUpdate).not.toHaveBeenCalled();\n    expect(client.pushDelete).not.toHaveBeenCalled();\n    expect(client.pushLeave).toHaveBeenCalledTimes(1);\n    expect(client.pushLeave).toHaveBeenCalledWith(requestId2, {\n      key: 'value',\n      className: 'TestObject'\n    }, {\n      key: 'originalValue',\n      className: 'TestObject'\n    });\n    done();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle update command with original object","suites":["ParseLiveQueryServer"],"line":925,"updatePoint":{"line":925,"column":52,"index":35576},"code":"  it('can handle update command with original object', async done => {\n    jasmine.restoreLibrary('../lib/LiveQuery/Client', 'Client');\n    const Client = require('../lib/LiveQuery/Client').Client;\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock request message\n    const message = generateMockMessage(true);\n    const clientId = 1;\n    const parseWebSocket = {\n      clientId,\n      send: jasmine.createSpy('send')\n    };\n    const client = new Client(clientId, parseWebSocket);\n    spyOn(client, 'pushUpdate').and.callThrough();\n    parseLiveQueryServer.clients.set(clientId, client);\n\n    // Add mock subscription\n    const requestId = 2;\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId, parseWebSocket);\n    // Mock _matchesSubscription to return matching\n    parseLiveQueryServer._matchesSubscription = function (parseObject) {\n      if (!parseObject) {\n        return false;\n      }\n      return true;\n    };\n    parseLiveQueryServer._matchesACL = function () {\n      return Promise.resolve(true);\n    };\n    parseLiveQueryServer._onAfterSave(message);\n\n    // Make sure we send update command to client\n    await timeout();\n    expect(client.pushUpdate).toHaveBeenCalled();\n    const args = parseWebSocket.send.calls.mostRecent().args;\n    const toSend = JSON.parse(args[0]);\n    expect(toSend.object).toBeDefined();\n    expect(toSend.original).toBeDefined();\n    done();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle object create command which matches some subscriptions","suites":["ParseLiveQueryServer"],"line":964,"updatePoint":{"line":964,"column":71,"index":37036},"code":"  it('can handle object create command which matches some subscriptions', async done => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock request message\n    const message = generateMockMessage();\n    // Add mock client\n    const clientId = 1;\n    const client = addMockClient(parseLiveQueryServer, clientId);\n    // Add mock subscription\n    const requestId = 2;\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId);\n    // Mock _matchesSubscription to return matching\n    parseLiveQueryServer._matchesSubscription = function (parseObject) {\n      if (!parseObject) {\n        return false;\n      }\n      return true;\n    };\n    parseLiveQueryServer._matchesACL = function () {\n      return Promise.resolve(true);\n    };\n    parseLiveQueryServer._onAfterSave(message);\n\n    // Make sure we send create command to client\n    await timeout();\n    expect(client.pushCreate).toHaveBeenCalled();\n    expect(client.pushEnter).not.toHaveBeenCalled();\n    expect(client.pushUpdate).not.toHaveBeenCalled();\n    expect(client.pushDelete).not.toHaveBeenCalled();\n    expect(client.pushLeave).not.toHaveBeenCalled();\n    done();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle create command with fields","suites":["ParseLiveQueryServer"],"line":995,"updatePoint":{"line":995,"column":43,"index":38183},"code":"  it('can handle create command with fields', async done => {\n    jasmine.restoreLibrary('../lib/LiveQuery/Client', 'Client');\n    const Client = require('../lib/LiveQuery/Client').Client;\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock request message\n    const message = generateMockMessage();\n    const clientId = 1;\n    const parseWebSocket = {\n      clientId,\n      send: jasmine.createSpy('send')\n    };\n    const client = new Client(clientId, parseWebSocket);\n    spyOn(client, 'pushCreate').and.callThrough();\n    parseLiveQueryServer.clients.set(clientId, client);\n\n    // Add mock subscription\n    const requestId = 2;\n    const query = {\n      className: testClassName,\n      where: {\n        key: 'value'\n      },\n      fields: ['test']\n    };\n    await addMockSubscription(parseLiveQueryServer, clientId, requestId, parseWebSocket, query);\n    // Mock _matchesSubscription to return matching\n    parseLiveQueryServer._matchesSubscription = function (parseObject) {\n      if (!parseObject) {\n        return false;\n      }\n      return true;\n    };\n    parseLiveQueryServer._matchesACL = function () {\n      return Promise.resolve(true);\n    };\n    parseLiveQueryServer._onAfterSave(message);\n\n    // Make sure we send create command to client\n    await timeout();\n    expect(client.pushCreate).toHaveBeenCalled();\n    const args = parseWebSocket.send.calls.mostRecent().args;\n    const toSend = JSON.parse(args[0]);\n    expect(toSend.object).toBeDefined();\n    expect(toSend.original).toBeUndefined();\n    done();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can match subscription for null or undefined parse object","suites":["ParseLiveQueryServer"],"line":1041,"updatePoint":{"line":1041,"column":63,"index":39767},"code":"  it('can match subscription for null or undefined parse object', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock subscription\n    const subscription = {\n      match: jasmine.createSpy('match')\n    };\n    expect(parseLiveQueryServer._matchesSubscription(null, subscription)).toBe(false);\n    expect(parseLiveQueryServer._matchesSubscription(undefined, subscription)).toBe(false);\n    // Make sure subscription.match is not called\n    expect(subscription.match).not.toHaveBeenCalled();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can match subscription","suites":["ParseLiveQueryServer"],"line":1052,"updatePoint":{"line":1052,"column":28,"index":40269},"code":"  it('can match subscription', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock subscription\n    const subscription = {\n      query: {}\n    };\n    const parseObject = {};\n    expect(parseLiveQueryServer._matchesSubscription(parseObject, subscription)).toBe(true);\n    // Make sure matchesQuery is called\n    const matchesQuery = require('../lib/LiveQuery/QueryTools').matchesQuery;\n    expect(matchesQuery).toHaveBeenCalledWith(parseObject, subscription.query);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can inflate parse object","suites":["ParseLiveQueryServer"],"line":1064,"updatePoint":{"line":1064,"column":30,"index":40784},"code":"  it('can inflate parse object', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    // Make mock request\n    const objectJSON = {\n      className: 'testClassName',\n      createdAt: '2015-12-22T01:51:12.955Z',\n      key: 'value',\n      objectId: 'BfwxBCz6yW',\n      updatedAt: '2016-01-05T00:46:45.659Z'\n    };\n    const originalObjectJSON = {\n      className: 'testClassName',\n      createdAt: '2015-12-22T01:51:12.955Z',\n      key: 'originalValue',\n      objectId: 'BfwxBCz6yW',\n      updatedAt: '2016-01-05T00:46:45.659Z'\n    };\n    const message = {\n      currentParseObject: objectJSON,\n      originalParseObject: originalObjectJSON\n    };\n    // Inflate the object\n    parseLiveQueryServer._inflateParseObject(message);\n\n    // Verify object\n    const object = message.currentParseObject;\n    expect(object instanceof Parse.Object).toBeTruthy();\n    expect(object.get('key')).toEqual('value');\n    expect(object.className).toEqual('testClassName');\n    expect(object.id).toBe('BfwxBCz6yW');\n    expect(object.createdAt).not.toBeUndefined();\n    expect(object.updatedAt).not.toBeUndefined();\n    // Verify original object\n    const originalObject = message.originalParseObject;\n    expect(originalObject instanceof Parse.Object).toBeTruthy();\n    expect(originalObject.get('key')).toEqual('originalValue');\n    expect(originalObject.className).toEqual('testClassName');\n    expect(originalObject.id).toBe('BfwxBCz6yW');\n    expect(originalObject.createdAt).not.toBeUndefined();\n    expect(originalObject.updatedAt).not.toBeUndefined();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can inflate user object","suites":["ParseLiveQueryServer"],"line":1105,"updatePoint":{"line":1105,"column":29,"index":42359},"code":"  it('can inflate user object', async () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const userJSON = {\n      username: 'test',\n      ACL: {},\n      createdAt: '2018-12-21T23:09:51.784Z',\n      sessionToken: 'r:1234',\n      updatedAt: '2018-12-21T23:09:51.784Z',\n      objectId: 'NhF2u9n72W',\n      __type: 'Object',\n      className: '_User',\n      _hashed_password: '1234',\n      _email_verify_token: '1234'\n    };\n    const originalUserJSON = {\n      username: 'test',\n      ACL: {},\n      createdAt: '2018-12-21T23:09:51.784Z',\n      sessionToken: 'r:1234',\n      updatedAt: '2018-12-21T23:09:51.784Z',\n      objectId: 'NhF2u9n72W',\n      __type: 'Object',\n      className: '_User',\n      _hashed_password: '12345',\n      _email_verify_token: '12345'\n    };\n    const message = {\n      currentParseObject: userJSON,\n      originalParseObject: originalUserJSON\n    };\n    parseLiveQueryServer._inflateParseObject(message);\n    const object = message.currentParseObject;\n    expect(object instanceof Parse.Object).toBeTruthy();\n    expect(object.get('_hashed_password')).toBeUndefined();\n    expect(object.get('_email_verify_token')).toBeUndefined();\n    expect(object.className).toEqual('_User');\n    expect(object.id).toBe('NhF2u9n72W');\n    expect(object.createdAt).not.toBeUndefined();\n    expect(object.updatedAt).not.toBeUndefined();\n    const originalObject = message.originalParseObject;\n    expect(originalObject instanceof Parse.Object).toBeTruthy();\n    expect(originalObject.get('_hashed_password')).toBeUndefined();\n    expect(originalObject.get('_email_verify_token')).toBeUndefined();\n    expect(originalObject.className).toEqual('_User');\n    expect(originalObject.id).toBe('NhF2u9n72W');\n    expect(originalObject.createdAt).not.toBeUndefined();\n    expect(originalObject.updatedAt).not.toBeUndefined();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can match undefined ACL","suites":["ParseLiveQueryServer"],"line":1153,"updatePoint":{"line":1153,"column":29,"index":44215},"code":"  it('can match undefined ACL', function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const client = {};\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(undefined, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(true);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can match ACL with none exist requestId","suites":["ParseLiveQueryServer"],"line":1162,"updatePoint":{"line":1162,"column":45,"index":44551},"code":"  it('can match ACL with none exist requestId', function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    const client = {\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue(undefined)\n    };\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(false);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can match ACL with public read access","suites":["ParseLiveQueryServer"],"line":1174,"updatePoint":{"line":1174,"column":43,"index":45013},"code":"  it('can match ACL with public read access', function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setPublicReadAccess(true);\n    const client = {\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n        sessionToken: 'sessionToken'\n      })\n    };\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(true);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can match ACL with valid subscription sessionToken","suites":["ParseLiveQueryServer"],"line":1189,"updatePoint":{"line":1189,"column":56,"index":45559},"code":"  it('can match ACL with valid subscription sessionToken', function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setReadAccess(testUserId, true);\n    const client = {\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n        sessionToken: 'sessionToken'\n      })\n    };\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(true);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can match ACL with valid client sessionToken","suites":["ParseLiveQueryServer"],"line":1204,"updatePoint":{"line":1204,"column":50,"index":46105},"code":"  it('can match ACL with valid client sessionToken', function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setReadAccess(testUserId, true);\n    // Mock sessionTokenCache will return false when sessionToken is undefined\n    const client = {\n      sessionToken: 'sessionToken',\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n        sessionToken: undefined\n      })\n    };\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(true);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can match ACL with invalid subscription and client sessionToken","suites":["ParseLiveQueryServer"],"line":1221,"updatePoint":{"line":1221,"column":69,"index":46780},"code":"  it('can match ACL with invalid subscription and client sessionToken', function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setReadAccess(testUserId, true);\n    // Mock sessionTokenCache will return false when sessionToken is undefined\n    const client = {\n      sessionToken: undefined,\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n        sessionToken: undefined\n      })\n    };\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(false);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can match ACL with subscription sessionToken checking error","suites":["ParseLiveQueryServer"],"line":1238,"updatePoint":{"line":1238,"column":65,"index":47447},"code":"  it('can match ACL with subscription sessionToken checking error', function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setReadAccess(testUserId, true);\n    // Mock sessionTokenCache will return error when sessionToken is null, this is just\n    // the behaviour of our mock sessionTokenCache, not real sessionTokenCache\n    const client = {\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n        sessionToken: null\n      })\n    };\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(false);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can match ACL with client sessionToken checking error","suites":["ParseLiveQueryServer"],"line":1255,"updatePoint":{"line":1255,"column":59,"index":48160},"code":"  it('can match ACL with client sessionToken checking error', function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setReadAccess(testUserId, true);\n    // Mock sessionTokenCache will return error when sessionToken is null\n    const client = {\n      sessionToken: null,\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n        sessionToken: null\n      })\n    };\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(false);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"won't match ACL that doesn't have public read or any roles","suites":["ParseLiveQueryServer"],"line":1272,"updatePoint":{"line":1272,"column":64,"index":48811},"code":"  it(\"won't match ACL that doesn't have public read or any roles\", function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setPublicReadAccess(false);\n    const client = {\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n        sessionToken: 'sessionToken'\n      })\n    };\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(false);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"won't match non-public ACL with role when there is no user","suites":["ParseLiveQueryServer"],"line":1287,"updatePoint":{"line":1287,"column":64,"index":49367},"code":"  it(\"won't match non-public ACL with role when there is no user\", function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setPublicReadAccess(false);\n    acl.setRoleReadAccess('livequery', true);\n    const client = {\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({})\n    };\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(false);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"won't match ACL with role based read access set to false","suites":["ParseLiveQueryServer"],"line":1301,"updatePoint":{"line":1301,"column":62,"index":49940},"code":"  it(\"won't match ACL with role based read access set to false\", function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setPublicReadAccess(false);\n    acl.setRoleReadAccess('otherLiveQueryRead', true);\n    const client = {\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n        sessionToken: 'sessionToken'\n      })\n    };\n    const requestId = 0;\n    spyOn(Parse, 'Query').and.callFake(function () {\n      let shouldReturn = false;\n      return {\n        equalTo() {\n          shouldReturn = true;\n          // Nothing to do here\n          return this;\n        },\n        containedIn() {\n          shouldReturn = false;\n          return this;\n        },\n        find() {\n          if (!shouldReturn) {\n            return Promise.resolve([]);\n          }\n          //Return a role with the name \"liveQueryRead\" as that is what was set on the ACL\n          const liveQueryRole = new Parse.Role('liveQueryRead', new Parse.ACL());\n          liveQueryRole.id = 'abcdef1234';\n          return Promise.resolve([liveQueryRole]);\n        }\n      };\n    });\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(false);\n      done();\n    });\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(false);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"will match ACL with role based read access set to true","suites":["ParseLiveQueryServer"],"line":1344,"updatePoint":{"line":1344,"column":60,"index":51396},"code":"  it('will match ACL with role based read access set to true', function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setPublicReadAccess(false);\n    acl.setRoleReadAccess('liveQueryRead', true);\n    const client = {\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n        sessionToken: 'sessionToken'\n      })\n    };\n    const requestId = 0;\n    spyOn(Parse, 'Query').and.callFake(function () {\n      let shouldReturn = false;\n      return {\n        equalTo() {\n          shouldReturn = true;\n          // Nothing to do here\n          return this;\n        },\n        containedIn() {\n          shouldReturn = false;\n          return this;\n        },\n        find() {\n          if (!shouldReturn) {\n            return Promise.resolve([]);\n          }\n          //Return a role with the name \"liveQueryRead\" as that is what was set on the ACL\n          const liveQueryRole = new Parse.Role('liveQueryRead', new Parse.ACL());\n          liveQueryRole.id = 'abcdef1234';\n          return Promise.resolve([liveQueryRole]);\n        },\n        each(callback) {\n          //Return a role with the name \"liveQueryRead\" as that is what was set on the ACL\n          const liveQueryRole = new Parse.Role('liveQueryRead', new Parse.ACL());\n          liveQueryRole.id = 'abcdef1234';\n          callback(liveQueryRole);\n          return Promise.resolve();\n        }\n      };\n    });\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(true);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"matches CLP when find is closed","suites":["ParseLiveQueryServer","class level permissions"],"line":1391,"updatePoint":{"line":1391,"column":39,"index":53046},"code":"    it('matches CLP when find is closed', done => {\n      const parseLiveQueryServer = new ParseLiveQueryServer({});\n      const acl = new Parse.ACL();\n      acl.setReadAccess(testUserId, true);\n      // Mock sessionTokenCache will return false when sessionToken is undefined\n      const client = {\n        sessionToken: 'sessionToken',\n        getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n          sessionToken: undefined\n        })\n      };\n      const requestId = 0;\n      parseLiveQueryServer._matchesCLP({\n        find: {}\n      }, {\n        className: 'Yolo'\n      }, client, requestId, 'find').then(isMatched => {\n        expect(isMatched).toBe(false);\n        done();\n      });\n    });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"matches CLP when find is open","suites":["ParseLiveQueryServer","class level permissions"],"line":1412,"updatePoint":{"line":1412,"column":37,"index":53774},"code":"    it('matches CLP when find is open', done => {\n      const parseLiveQueryServer = new ParseLiveQueryServer({});\n      const acl = new Parse.ACL();\n      acl.setReadAccess(testUserId, true);\n      // Mock sessionTokenCache will return false when sessionToken is undefined\n      const client = {\n        sessionToken: 'sessionToken',\n        getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n          sessionToken: undefined\n        })\n      };\n      const requestId = 0;\n      parseLiveQueryServer._matchesCLP({\n        find: {\n          '*': true\n        }\n      }, {\n        className: 'Yolo'\n      }, client, requestId, 'find').then(isMatched => {\n        expect(isMatched).toBe(true);\n        done();\n      });\n    });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"matches CLP when find is restricted to userIds","suites":["ParseLiveQueryServer","class level permissions"],"line":1435,"updatePoint":{"line":1435,"column":54,"index":54547},"code":"    it('matches CLP when find is restricted to userIds', done => {\n      const parseLiveQueryServer = new ParseLiveQueryServer({});\n      const acl = new Parse.ACL();\n      acl.setReadAccess(testUserId, true);\n      // Mock sessionTokenCache will return false when sessionToken is undefined\n      const client = {\n        sessionToken: 'sessionToken',\n        getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n          sessionToken: 'userId'\n        })\n      };\n      const requestId = 0;\n      parseLiveQueryServer._matchesCLP({\n        find: {\n          userId: true\n        }\n      }, {\n        className: 'Yolo'\n      }, client, requestId, 'find').then(isMatched => {\n        expect(isMatched).toBe(true);\n        done();\n      });\n    });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"matches CLP when find is restricted to userIds","suites":["ParseLiveQueryServer","class level permissions"],"line":1458,"updatePoint":{"line":1458,"column":54,"index":55322},"code":"    it('matches CLP when find is restricted to userIds', done => {\n      const parseLiveQueryServer = new ParseLiveQueryServer({});\n      const acl = new Parse.ACL();\n      acl.setReadAccess(testUserId, true);\n      // Mock sessionTokenCache will return false when sessionToken is undefined\n      const client = {\n        sessionToken: 'sessionToken',\n        getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({\n          sessionToken: undefined\n        })\n      };\n      const requestId = 0;\n      parseLiveQueryServer._matchesCLP({\n        find: {\n          userId: true\n        }\n      }, {\n        className: 'Yolo'\n      }, client, requestId, 'find').then(isMatched => {\n        expect(isMatched).toBe(false);\n        done();\n      });\n    });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can validate key when valid key is provided","suites":["ParseLiveQueryServer","class level permissions"],"line":1482,"updatePoint":{"line":1482,"column":49,"index":56100},"code":"  it('can validate key when valid key is provided', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({}, {\n      keyPairs: {\n        clientKey: 'test'\n      }\n    });\n    const request = {\n      clientKey: 'test'\n    };\n    expect(parseLiveQueryServer._validateKeys(request, parseLiveQueryServer.keyPairs)).toBeTruthy();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can validate key when invalid key is provided","suites":["ParseLiveQueryServer","class level permissions"],"line":1493,"updatePoint":{"line":1493,"column":51,"index":56452},"code":"  it('can validate key when invalid key is provided', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({}, {\n      keyPairs: {\n        clientKey: 'test'\n      }\n    });\n    const request = {\n      clientKey: 'error'\n    };\n    expect(parseLiveQueryServer._validateKeys(request, parseLiveQueryServer.keyPairs)).not.toBeTruthy();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can validate key when key is not provided","suites":["ParseLiveQueryServer","class level permissions"],"line":1504,"updatePoint":{"line":1504,"column":47,"index":56805},"code":"  it('can validate key when key is not provided', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({}, {\n      keyPairs: {\n        clientKey: 'test'\n      }\n    });\n    const request = {};\n    expect(parseLiveQueryServer._validateKeys(request, parseLiveQueryServer.keyPairs)).not.toBeTruthy();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can validate key when validKerPairs is empty","suites":["ParseLiveQueryServer","class level permissions"],"line":1513,"updatePoint":{"line":1513,"column":50,"index":57131},"code":"  it('can validate key when validKerPairs is empty', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({}, {});\n    const request = {};\n    expect(parseLiveQueryServer._validateKeys(request, parseLiveQueryServer.keyPairs)).toBeTruthy();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can validate client has master key when valid","suites":["ParseLiveQueryServer","class level permissions"],"line":1518,"updatePoint":{"line":1518,"column":51,"index":57397},"code":"  it('can validate client has master key when valid', function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({}, {\n      keyPairs: {\n        masterKey: 'test'\n      }\n    });\n    const request = {\n      masterKey: 'test'\n    };\n    expect(parseLiveQueryServer._hasMasterKey(request, parseLiveQueryServer.keyPairs)).toBeTruthy();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can validate client doesn't have master key when invalid","suites":["ParseLiveQueryServer","class level permissions"],"line":1529,"updatePoint":{"line":1529,"column":62,"index":57760},"code":"  it(\"can validate client doesn't have master key when invalid\", function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({}, {\n      keyPairs: {\n        masterKey: 'test'\n      }\n    });\n    const request = {\n      masterKey: 'notValid'\n    };\n    expect(parseLiveQueryServer._hasMasterKey(request, parseLiveQueryServer.keyPairs)).not.toBeTruthy();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can validate client doesn't have master key when not provided","suites":["ParseLiveQueryServer","class level permissions"],"line":1540,"updatePoint":{"line":1540,"column":67,"index":58136},"code":"  it(\"can validate client doesn't have master key when not provided\", function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({}, {\n      keyPairs: {\n        masterKey: 'test'\n      }\n    });\n    expect(parseLiveQueryServer._hasMasterKey({}, parseLiveQueryServer.keyPairs)).not.toBeTruthy();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"can validate client doesn't have master key when validKeyPairs is empty","suites":["ParseLiveQueryServer","class level permissions"],"line":1548,"updatePoint":{"line":1548,"column":77,"index":58460},"code":"  it(\"can validate client doesn't have master key when validKeyPairs is empty\", function () {\n    const parseLiveQueryServer = new ParseLiveQueryServer({}, {});\n    const request = {\n      masterKey: 'test'\n    };\n    expect(parseLiveQueryServer._hasMasterKey(request, parseLiveQueryServer.keyPairs)).not.toBeTruthy();\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"will match non-public ACL when client has master key","suites":["ParseLiveQueryServer","class level permissions"],"line":1555,"updatePoint":{"line":1555,"column":58,"index":58766},"code":"  it('will match non-public ACL when client has master key', function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setPublicReadAccess(false);\n    const client = {\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({}),\n      hasMasterKey: true\n    };\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(true);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"won't match non-public ACL when client has no master key","suites":["ParseLiveQueryServer","class level permissions"],"line":1569,"updatePoint":{"line":1569,"column":62,"index":59301},"code":"  it(\"won't match non-public ACL when client has no master key\", function (done) {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const acl = new Parse.ACL();\n    acl.setPublicReadAccess(false);\n    const client = {\n      getSubscriptionInfo: jasmine.createSpy('getSubscriptionInfo').and.returnValue({}),\n      hasMasterKey: false\n    };\n    const requestId = 0;\n    parseLiveQueryServer._matchesACL(acl, client, requestId).then(function (isMatched) {\n      expect(isMatched).toBe(false);\n      done();\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"should properly pull auth from cache","suites":["ParseLiveQueryServer","class level permissions"],"line":1583,"updatePoint":{"line":1583,"column":42,"index":59818},"code":"  it('should properly pull auth from cache', () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const promise = parseLiveQueryServer.getAuthForSessionToken('sessionToken');\n    const secondPromise = parseLiveQueryServer.getAuthForSessionToken('sessionToken');\n    // should be in the cache\n    expect(parseLiveQueryServer.authCache.get('sessionToken')).toBe(promise);\n    // should be the same promise returned\n    expect(promise).toBe(secondPromise);\n    // the auth should be called only once\n    expect(auth.getAuthForSessionToken.calls.count()).toBe(1);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"should delete from cache throwing auth calls","suites":["ParseLiveQueryServer","class level permissions"],"line":1594,"updatePoint":{"line":1594,"column":50,"index":60414},"code":"  it('should delete from cache throwing auth calls', async () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const promise = parseLiveQueryServer.getAuthForSessionToken('pleaseThrow');\n    expect(parseLiveQueryServer.authCache.get('pleaseThrow')).toBe(promise);\n    // after the promise finishes, it should have removed it from the cache\n    expect(await promise).toEqual({});\n    expect(parseLiveQueryServer.authCache.get('pleaseThrow')).toBe(undefined);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"should keep a cache of invalid sessions","suites":["ParseLiveQueryServer","class level permissions"],"line":1602,"updatePoint":{"line":1602,"column":45,"index":60896},"code":"  it('should keep a cache of invalid sessions', async () => {\n    const parseLiveQueryServer = new ParseLiveQueryServer({});\n    const promise = parseLiveQueryServer.getAuthForSessionToken('invalid');\n    expect(parseLiveQueryServer.authCache.get('invalid')).toBe(promise);\n    // after the promise finishes, it should have removed it from the cache\n    await promise;\n    const finalResult = await parseLiveQueryServer.authCache.get('invalid');\n    expect(finalResult.error).not.toBeUndefined();\n    expect(parseLiveQueryServer.authCache.get('invalid')).not.toBe(undefined);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"properly passes the CLP to afterSave/afterDelete hook","suites":["LiveQueryController"],"line":1689,"updatePoint":{"line":1689,"column":59,"index":64338},"code":"  it('properly passes the CLP to afterSave/afterDelete hook', function (done) {\n    function setPermissionsOnClass(className, permissions, doPut) {\n      const request = require('request');\n      let op = request.post;\n      if (doPut) {\n        op = request.put;\n      }\n      return new Promise((resolve, reject) => {\n        op({\n          url: Parse.serverURL + '/schemas/' + className,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Master-Key': Parse.masterKey\n          },\n          json: true,\n          body: {\n            classLevelPermissions: permissions\n          }\n        }, (error, response, body) => {\n          if (error) {\n            return reject(error);\n          }\n          if (body.error) {\n            return reject(body);\n          }\n          return resolve(body);\n        });\n      });\n    }\n    let saveSpy;\n    let deleteSpy;\n    reconfigureServer({\n      liveQuery: {\n        classNames: ['Yolo']\n      }\n    }).then(parseServer => {\n      saveSpy = spyOn(parseServer.config.liveQueryController, 'onAfterSave').and.callThrough();\n      deleteSpy = spyOn(parseServer.config.liveQueryController, 'onAfterDelete').and.callThrough();\n      return setPermissionsOnClass('Yolo', {\n        create: {\n          '*': true\n        },\n        delete: {\n          '*': true\n        }\n      });\n    }).then(() => {\n      const obj = new Parse.Object('Yolo');\n      return obj.save();\n    }).then(obj => {\n      return obj.destroy();\n    }).then(() => {\n      expect(saveSpy).toHaveBeenCalled();\n      const saveArgs = saveSpy.calls.mostRecent().args;\n      expect(saveArgs.length).toBe(4);\n      expect(saveArgs[0]).toBe('Yolo');\n      expect(saveArgs[3]).toEqual({\n        get: {},\n        count: {},\n        addField: {},\n        create: {\n          '*': true\n        },\n        find: {},\n        update: {},\n        delete: {\n          '*': true\n        },\n        protectedFields: {}\n      });\n      expect(deleteSpy).toHaveBeenCalled();\n      const deleteArgs = deleteSpy.calls.mostRecent().args;\n      expect(deleteArgs.length).toBe(4);\n      expect(deleteArgs[0]).toBe('Yolo');\n      expect(deleteArgs[3]).toEqual({\n        get: {},\n        count: {},\n        addField: {},\n        create: {\n          '*': true\n        },\n        find: {},\n        update: {},\n        delete: {\n          '*': true\n        },\n        protectedFields: {}\n      });\n      done();\n    }).catch(done.fail);\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"should properly pack message request on afterSave","suites":["LiveQueryController"],"line":1780,"updatePoint":{"line":1780,"column":55,"index":66807},"code":"  it('should properly pack message request on afterSave', () => {\n    const controller = new LiveQueryController({\n      classNames: ['Yolo']\n    });\n    const spy = spyOn(controller.liveQueryPublisher, 'onCloudCodeAfterSave');\n    controller.onAfterSave('Yolo', {\n      o: 1\n    }, {\n      o: 2\n    }, {\n      yolo: true\n    });\n    expect(spy).toHaveBeenCalled();\n    const args = spy.calls.mostRecent().args;\n    expect(args.length).toBe(1);\n    expect(args[0]).toEqual({\n      object: {\n        o: 1\n      },\n      original: {\n        o: 2\n      },\n      classLevelPermissions: {\n        yolo: true\n      }\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"should properly pack message request on afterDelete","suites":["LiveQueryController"],"line":1807,"updatePoint":{"line":1807,"column":57,"index":67434},"code":"  it('should properly pack message request on afterDelete', () => {\n    const controller = new LiveQueryController({\n      classNames: ['Yolo']\n    });\n    const spy = spyOn(controller.liveQueryPublisher, 'onCloudCodeAfterDelete');\n    controller.onAfterDelete('Yolo', {\n      o: 1\n    }, {\n      o: 2\n    }, {\n      yolo: true\n    });\n    expect(spy).toHaveBeenCalled();\n    const args = spy.calls.mostRecent().args;\n    expect(args.length).toBe(1);\n    expect(args[0]).toEqual({\n      object: {\n        o: 1\n      },\n      original: {\n        o: 2\n      },\n      classLevelPermissions: {\n        yolo: true\n      }\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"should properly pack message request","suites":["LiveQueryController"],"line":1834,"updatePoint":{"line":1834,"column":42,"index":68050},"code":"  it('should properly pack message request', () => {\n    const controller = new LiveQueryController({\n      classNames: ['Yolo']\n    });\n    expect(controller._makePublisherRequest({})).toEqual({\n      object: {},\n      original: undefined\n    });\n  });","file":"ParseLiveQueryServer.spec.js","skipped":false,"dir":"spec"},{"name":"create","suites":["Parse.Object testing"],"line":16,"updatePoint":{"line":16,"column":12,"index":587},"code":"  it('create', function (done) {\n    create({\n      test: 'test'\n    }, function (model) {\n      ok(model.id, 'Should have an objectId set');\n      equal(model.get('test'), 'test', 'Should have the right attribute');\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"update","suites":["Parse.Object testing"],"line":25,"updatePoint":{"line":25,"column":12,"index":832},"code":"  it('update', function (done) {\n    create({\n      test: 'test'\n    }, function (model) {\n      const t2 = new TestObject({\n        objectId: model.id\n      });\n      t2.set('test', 'changed');\n      t2.save().then(function (model) {\n        equal(model.get('test'), 'changed', 'Update should have succeeded');\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"save without null","suites":["Parse.Object testing"],"line":39,"updatePoint":{"line":39,"column":23,"index":1195},"code":"  it('save without null', function (done) {\n    const object = new TestObject();\n    object.set('favoritePony', 'Rainbow Dash');\n    object.save().then(function (objectAgain) {\n      equal(objectAgain, object);\n      done();\n    }, function (objectAgain, error) {\n      ok(null, 'Error ' + error.code + ': ' + error.message);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"save cycle","suites":["Parse.Object testing"],"line":50,"updatePoint":{"line":50,"column":16,"index":1542},"code":"  it('save cycle', done => {\n    const a = new Parse.Object('TestObject');\n    const b = new Parse.Object('TestObject');\n    a.set('b', b);\n    a.save().then(function () {\n      b.set('a', a);\n      return b.save();\n    }).then(function () {\n      ok(a.id);\n      ok(b.id);\n      strictEqual(a.get('b'), b);\n      strictEqual(b.get('a'), a);\n    }).then(function () {\n      done();\n    }, function (error) {\n      ok(false, error);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"get","suites":["Parse.Object testing"],"line":69,"updatePoint":{"line":69,"column":9,"index":1995},"code":"  it('get', function (done) {\n    create({\n      test: 'test'\n    }, function (model) {\n      const t2 = new TestObject({\n        objectId: model.id\n      });\n      t2.fetch().then(function (model2) {\n        equal(model2.get('test'), 'test', 'Update should have succeeded');\n        ok(model2.id);\n        equal(model2.id, model.id, 'Ids should match');\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"delete","suites":["Parse.Object testing"],"line":84,"updatePoint":{"line":84,"column":12,"index":2393},"code":"  it('delete', function (done) {\n    const t = new TestObject();\n    t.set('test', 'test');\n    t.save().then(function () {\n      t.destroy().then(function () {\n        const t2 = new TestObject({\n          objectId: t.id\n        });\n        t2.fetch().then(fail, () => done());\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"find","suites":["Parse.Object testing"],"line":96,"updatePoint":{"line":96,"column":10,"index":2694},"code":"  it('find', function (done) {\n    const t = new TestObject();\n    t.set('foo', 'bar');\n    t.save().then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'bar');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"relational fields","suites":["Parse.Object testing"],"line":108,"updatePoint":{"line":108,"column":23,"index":3030},"code":"  it('relational fields', function (done) {\n    const item = new Item();\n    item.set('property', 'x');\n    const container = new Container();\n    container.set('item', item);\n    Parse.Object.saveAll([item, container]).then(function () {\n      const query = new Parse.Query(Container);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const containerAgain = results[0];\n        const itemAgain = containerAgain.get('item');\n        itemAgain.fetch().then(function () {\n          equal(itemAgain.get('property'), 'x');\n          done();\n        });\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"save adds no data keys (other than createdAt and updatedAt)","suites":["Parse.Object testing"],"line":126,"updatePoint":{"line":126,"column":65,"index":3683},"code":"  it('save adds no data keys (other than createdAt and updatedAt)', function (done) {\n    const object = new TestObject();\n    object.save().then(function () {\n      const keys = Object.keys(object.attributes).sort();\n      equal(keys.length, 2);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"recursive save","suites":["Parse.Object testing"],"line":134,"updatePoint":{"line":134,"column":20,"index":3913},"code":"  it('recursive save', function (done) {\n    const item = new Item();\n    item.set('property', 'x');\n    const container = new Container();\n    container.set('item', item);\n    container.save().then(function () {\n      const query = new Parse.Query(Container);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const containerAgain = results[0];\n        const itemAgain = containerAgain.get('item');\n        itemAgain.fetch().then(function () {\n          equal(itemAgain.get('property'), 'x');\n          done();\n        });\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fetch","suites":["Parse.Object testing"],"line":152,"updatePoint":{"line":152,"column":11,"index":4489},"code":"  it('fetch', function (done) {\n    const item = new Item({\n      foo: 'bar'\n    });\n    item.save().then(function () {\n      const itemAgain = new Item();\n      itemAgain.id = item.id;\n      itemAgain.fetch().then(function () {\n        itemAgain.save({\n          foo: 'baz'\n        }).then(function () {\n          item.fetch().then(function () {\n            equal(item.get('foo'), itemAgain.get('foo'));\n            done();\n          });\n        });\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"createdAt doesn't change","suites":["Parse.Object testing"],"line":171,"updatePoint":{"line":171,"column":30,"index":4983},"code":"  it(\"createdAt doesn't change\", function (done) {\n    const object = new TestObject({\n      foo: 'bar'\n    });\n    object.save().then(function () {\n      const objectAgain = new TestObject();\n      objectAgain.id = object.id;\n      objectAgain.fetch().then(function () {\n        equal(object.createdAt.getTime(), objectAgain.createdAt.getTime());\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"createdAt and updatedAt exposed","suites":["Parse.Object testing"],"line":184,"updatePoint":{"line":184,"column":37,"index":5378},"code":"  it('createdAt and updatedAt exposed', function (done) {\n    const object = new TestObject({\n      foo: 'bar'\n    });\n    object.save().then(function () {\n      notEqual(object.updatedAt, undefined);\n      notEqual(object.createdAt, undefined);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"updatedAt gets updated","suites":["Parse.Object testing"],"line":194,"updatePoint":{"line":194,"column":28,"index":5643},"code":"  it('updatedAt gets updated', function (done) {\n    const object = new TestObject({\n      foo: 'bar'\n    });\n    object.save().then(function () {\n      ok(object.updatedAt, 'initial save should cause updatedAt to exist');\n      const firstUpdatedAt = object.updatedAt;\n      object.save({\n        foo: 'baz'\n      }).then(function () {\n        ok(object.updatedAt, 'two saves should cause updatedAt to exist');\n        notEqual(firstUpdatedAt, object.updatedAt);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"createdAt is reasonable","suites":["Parse.Object testing"],"line":210,"updatePoint":{"line":210,"column":29,"index":6148},"code":"  it('createdAt is reasonable', function (done) {\n    const startTime = new Date();\n    const object = new TestObject({\n      foo: 'bar'\n    });\n    object.save().then(function () {\n      const endTime = new Date();\n      const startDiff = Math.abs(startTime.getTime() - object.createdAt.getTime());\n      ok(startDiff < 5000);\n      const endDiff = Math.abs(endTime.getTime() - object.createdAt.getTime());\n      ok(endDiff < 5000);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"can set null","suites":["Parse.Object testing"],"line":224,"updatePoint":{"line":224,"column":18,"index":6599},"code":"  it('can set null', function (done) {\n    const obj = new Parse.Object('TestObject');\n    obj.set('foo', null);\n    obj.save().then(function (obj) {\n      on_db('mongo', () => {\n        equal(obj.get('foo'), null);\n      });\n      on_db('postgres', () => {\n        equal(obj.get('foo'), null);\n      });\n      done();\n    }, function () {\n      fail('should not fail');\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"can set boolean","suites":["Parse.Object testing"],"line":240,"updatePoint":{"line":240,"column":21,"index":7001},"code":"  it('can set boolean', function (done) {\n    const obj = new Parse.Object('TestObject');\n    obj.set('yes', true);\n    obj.set('no', false);\n    obj.save().then(function (obj) {\n      equal(obj.get('yes'), true);\n      equal(obj.get('no'), false);\n      done();\n    }, function (obj, error) {\n      ok(false, error.message);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"cannot set invalid date","suites":["Parse.Object testing"],"line":253,"updatePoint":{"line":253,"column":29,"index":7363},"code":"  it('cannot set invalid date', async function (done) {\n    const obj = new Parse.Object('TestObject');\n    obj.set('when', new Date(Date.parse(null)));\n    try {\n      await obj.save();\n    } catch (e) {\n      ok(true);\n      done();\n      return;\n    }\n    ok(false, 'Saving an invalid date should throw');\n    done();\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"can set authData when not user class","suites":["Parse.Object testing"],"line":266,"updatePoint":{"line":266,"column":42,"index":7703},"code":"  it('can set authData when not user class', async () => {\n    const obj = new Parse.Object('TestObject');\n    obj.set('authData', 'random');\n    await obj.save();\n    expect(obj.get('authData')).toBe('random');\n    const query = new Parse.Query('TestObject');\n    const object = await query.get(obj.id, {\n      useMasterKey: true\n    });\n    expect(object.get('authData')).toBe('random');\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"invalid class name","suites":["Parse.Object testing"],"line":277,"updatePoint":{"line":277,"column":24,"index":8081},"code":"  it('invalid class name', function (done) {\n    const item = new Parse.Object('Foo^bar');\n    item.save().then(function () {\n      ok(false, 'The name should have been invalid.');\n      done();\n    }, function () {\n      // Because the class name is invalid, the router will not be able to route\n      // it, so it will actually return a -1 error code.\n      // equal(error.code, Parse.Error.INVALID_CLASS_NAME);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"invalid key name","suites":["Parse.Object testing"],"line":289,"updatePoint":{"line":289,"column":22,"index":8521},"code":"  it('invalid key name', function (done) {\n    const item = new Parse.Object('Item');\n    ok(!item.set({\n      'foo^bar': 'baz'\n    }), 'Item should not be updated with invalid key.');\n    item.save({\n      'foo^bar': 'baz'\n    }).then(fail, () => done());\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"invalid __type","suites":["Parse.Object testing"],"line":298,"updatePoint":{"line":298,"column":20,"index":8782},"code":"  it('invalid __type', function (done) {\n    const item = new Parse.Object('Item');\n    const types = ['Pointer', 'File', 'Date', 'GeoPoint', 'Bytes', 'Polygon', 'Relation'];\n    const tests = types.map(type => {\n      const test = new Parse.Object('Item');\n      test.set('foo', {\n        __type: type\n      });\n      return test;\n    });\n    const next = function (index) {\n      if (index < tests.length) {\n        tests[index].save().then(fail, error => {\n          expect(error.code).toEqual(Parse.Error.INCORRECT_TYPE);\n          next(index + 1);\n        });\n      } else {\n        done();\n      }\n    };\n    item.save({\n      foo: {\n        __type: 'IvalidName'\n      }\n    }).then(fail, () => next(0));\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"simple field deletion","suites":["Parse.Object testing"],"line":324,"updatePoint":{"line":324,"column":27,"index":9506},"code":"  it('simple field deletion', function (done) {\n    const simple = new Parse.Object('SimpleObject');\n    simple.save({\n      foo: 'bar'\n    }).then(function (simple) {\n      simple.unset('foo');\n      ok(!simple.has('foo'), 'foo should have been unset.');\n      ok(simple.dirty('foo'), 'foo should be dirty.');\n      ok(simple.dirty(), 'the whole object should be dirty.');\n      simple.save().then(function (simple) {\n        ok(!simple.has('foo'), 'foo should have been unset.');\n        ok(!simple.dirty('foo'), 'the whole object was just saved.');\n        ok(!simple.dirty(), 'the whole object was just saved.');\n        const query = new Parse.Query('SimpleObject');\n        query.get(simple.id).then(function (simpleAgain) {\n          ok(!simpleAgain.has('foo'), 'foo should have been removed.');\n          done();\n        }, function (simpleAgain, error) {\n          ok(false, 'Error ' + error.code + ': ' + error.message);\n          done();\n        });\n      }, function (simple, error) {\n        ok(false, 'Error ' + error.code + ': ' + error.message);\n        done();\n      });\n    }, function (simple, error) {\n      ok(false, 'Error ' + error.code + ': ' + error.message);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"field deletion before first save","suites":["Parse.Object testing"],"line":354,"updatePoint":{"line":354,"column":38,"index":10730},"code":"  it('field deletion before first save', function (done) {\n    const simple = new Parse.Object('SimpleObject');\n    simple.set('foo', 'bar');\n    simple.unset('foo');\n    ok(!simple.has('foo'), 'foo should have been unset.');\n    ok(simple.dirty('foo'), 'foo should be dirty.');\n    ok(simple.dirty(), 'the whole object should be dirty.');\n    simple.save().then(function (simple) {\n      ok(!simple.has('foo'), 'foo should have been unset.');\n      ok(!simple.dirty('foo'), 'the whole object was just saved.');\n      ok(!simple.dirty(), 'the whole object was just saved.');\n      const query = new Parse.Query('SimpleObject');\n      query.get(simple.id).then(function (simpleAgain) {\n        ok(!simpleAgain.has('foo'), 'foo should have been removed.');\n        done();\n      }, function (simpleAgain, error) {\n        ok(false, 'Error ' + error.code + ': ' + error.message);\n        done();\n      });\n    }, function (simple, error) {\n      ok(false, 'Error ' + error.code + ': ' + error.message);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"relation deletion","suites":["Parse.Object testing"],"line":378,"updatePoint":{"line":378,"column":23,"index":11743},"code":"  it('relation deletion', function (done) {\n    const simple = new Parse.Object('SimpleObject');\n    const child = new Parse.Object('Child');\n    simple.save({\n      child: child\n    }).then(function (simple) {\n      simple.unset('child');\n      ok(!simple.has('child'), 'child should have been unset.');\n      ok(simple.dirty('child'), 'child should be dirty.');\n      ok(simple.dirty(), 'the whole object should be dirty.');\n      simple.save().then(function (simple) {\n        ok(!simple.has('child'), 'child should have been unset.');\n        ok(!simple.dirty('child'), 'the whole object was just saved.');\n        ok(!simple.dirty(), 'the whole object was just saved.');\n        const query = new Parse.Query('SimpleObject');\n        query.get(simple.id).then(function (simpleAgain) {\n          ok(!simpleAgain.has('child'), 'child should have been removed.');\n          done();\n        }, function (simpleAgain, error) {\n          ok(false, 'Error ' + error.code + ': ' + error.message);\n          done();\n        });\n      }, function (simple, error) {\n        ok(false, 'Error ' + error.code + ': ' + error.message);\n        done();\n      });\n    }, function (simple, error) {\n      ok(false, 'Error ' + error.code + ': ' + error.message);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"deleted keys get cleared","suites":["Parse.Object testing"],"line":409,"updatePoint":{"line":409,"column":30,"index":13026},"code":"  it('deleted keys get cleared', function (done) {\n    const simpleObject = new Parse.Object('SimpleObject');\n    simpleObject.set('foo', 'bar');\n    simpleObject.unset('foo');\n    simpleObject.save().then(function (simpleObject) {\n      simpleObject.set('foo', 'baz');\n      simpleObject.save().then(function (simpleObject) {\n        const query = new Parse.Query('SimpleObject');\n        query.get(simpleObject.id).then(function (simpleObjectAgain) {\n          equal(simpleObjectAgain.get('foo'), 'baz');\n          done();\n        }, done.fail);\n      }, done.fail);\n    }, done.fail);\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"setting after deleting","suites":["Parse.Object testing"],"line":424,"updatePoint":{"line":424,"column":28,"index":13618},"code":"  it('setting after deleting', function (done) {\n    const simpleObject = new Parse.Object('SimpleObject');\n    simpleObject.set('foo', 'bar');\n    simpleObject.save().then(function (simpleObject) {\n      simpleObject.unset('foo');\n      simpleObject.set('foo', 'baz');\n      simpleObject.save().then(function (simpleObject) {\n        const query = new Parse.Query('SimpleObject');\n        query.get(simpleObject.id).then(function (simpleObjectAgain) {\n          equal(simpleObjectAgain.get('foo'), 'baz');\n          done();\n        }, function (error) {\n          ok(false, 'Error ' + error.code + ': ' + error.message);\n          done();\n        });\n      }, function (error) {\n        ok(false, 'Error ' + error.code + ': ' + error.message);\n        done();\n      });\n    }, function (error) {\n      ok(false, 'Error ' + error.code + ': ' + error.message);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"increment","suites":["Parse.Object testing"],"line":448,"updatePoint":{"line":448,"column":15,"index":14493},"code":"  it('increment', function (done) {\n    const simple = new Parse.Object('SimpleObject');\n    simple.save({\n      foo: 5\n    }).then(function (simple) {\n      simple.increment('foo');\n      equal(simple.get('foo'), 6);\n      ok(simple.dirty('foo'), 'foo should be dirty.');\n      ok(simple.dirty(), 'the whole object should be dirty.');\n      simple.save().then(function (simple) {\n        equal(simple.get('foo'), 6);\n        ok(!simple.dirty('foo'), 'the whole object was just saved.');\n        ok(!simple.dirty(), 'the whole object was just saved.');\n        const query = new Parse.Query('SimpleObject');\n        query.get(simple.id).then(function (simpleAgain) {\n          equal(simpleAgain.get('foo'), 6);\n          done();\n        });\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"addUnique","suites":["Parse.Object testing"],"line":469,"updatePoint":{"line":469,"column":15,"index":15258},"code":"  it('addUnique', function (done) {\n    const x1 = new Parse.Object('X');\n    x1.set('stuff', [1, 2]);\n    x1.save().then(() => {\n      const objectId = x1.id;\n      const x2 = new Parse.Object('X', {\n        objectId: objectId\n      });\n      x2.addUnique('stuff', 2);\n      x2.addUnique('stuff', 4);\n      expect(x2.get('stuff')).toEqual([2, 4]);\n      return x2.save();\n    }).then(() => {\n      const query = new Parse.Query('X');\n      return query.get(x1.id);\n    }).then(x3 => {\n      const stuff = x3.get('stuff');\n      const expected = [1, 2, 4];\n      expect(stuff.length).toBe(expected.length);\n      for (const i of stuff) {\n        expect(expected.indexOf(i) >= 0).toBe(true);\n      }\n      done();\n    }, error => {\n      on_db('mongo', () => {\n        jfail(error);\n      });\n      on_db('postgres', () => {\n        expect(error.message).toEqual('Postgres does not support AddUnique operator.');\n      });\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"addUnique with object","suites":["Parse.Object testing"],"line":502,"updatePoint":{"line":502,"column":27,"index":16220},"code":"  it('addUnique with object', function (done) {\n    const x1 = new Parse.Object('X');\n    x1.set('stuff', [1, {\n      hello: 'world'\n    }, {\n      foo: 'bar'\n    }]);\n    x1.save().then(() => {\n      const objectId = x1.id;\n      const x2 = new Parse.Object('X', {\n        objectId: objectId\n      });\n      x2.addUnique('stuff', {\n        hello: 'world'\n      });\n      x2.addUnique('stuff', {\n        bar: 'baz'\n      });\n      expect(x2.get('stuff')).toEqual([{\n        hello: 'world'\n      }, {\n        bar: 'baz'\n      }]);\n      return x2.save();\n    }).then(() => {\n      const query = new Parse.Query('X');\n      return query.get(x1.id);\n    }).then(x3 => {\n      const stuff = x3.get('stuff');\n      const target = [1, {\n        hello: 'world'\n      }, {\n        foo: 'bar'\n      }, {\n        bar: 'baz'\n      }];\n      expect(stuff.length).toEqual(target.length);\n      let found = 0;\n      for (const thing in target) {\n        for (const st in stuff) {\n          if (st == thing) {\n            found++;\n          }\n        }\n      }\n      expect(found).toBe(target.length);\n      done();\n    }, error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"removes with object","suites":["Parse.Object testing"],"line":554,"updatePoint":{"line":554,"column":25,"index":17385},"code":"  it('removes with object', function (done) {\n    const x1 = new Parse.Object('X');\n    x1.set('stuff', [1, {\n      hello: 'world'\n    }, {\n      foo: 'bar'\n    }]);\n    x1.save().then(() => {\n      const objectId = x1.id;\n      const x2 = new Parse.Object('X', {\n        objectId: objectId\n      });\n      x2.remove('stuff', {\n        hello: 'world'\n      });\n      expect(x2.get('stuff')).toEqual([]);\n      return x2.save();\n    }).then(() => {\n      const query = new Parse.Query('X');\n      return query.get(x1.id);\n    }).then(x3 => {\n      expect(x3.get('stuff')).toEqual([1, {\n        foo: 'bar'\n      }]);\n      done();\n    }, error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"dirty attributes","suites":["Parse.Object testing"],"line":584,"updatePoint":{"line":584,"column":22,"index":18077},"code":"  it('dirty attributes', function (done) {\n    const object = new Parse.Object('TestObject');\n    object.set('cat', 'good');\n    object.set('dog', 'bad');\n    object.save().then(function (object) {\n      ok(!object.dirty());\n      ok(!object.dirty('cat'));\n      ok(!object.dirty('dog'));\n      object.set('dog', 'okay');\n      ok(object.dirty());\n      ok(!object.dirty('cat'));\n      ok(object.dirty('dog'));\n      done();\n    }, function () {\n      ok(false, 'This should have saved.');\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"dirty keys","suites":["Parse.Object testing"],"line":602,"updatePoint":{"line":602,"column":16,"index":18589},"code":"  it('dirty keys', function (done) {\n    const object = new Parse.Object('TestObject');\n    object.set('gogo', 'good');\n    object.set('sito', 'sexy');\n    ok(object.dirty());\n    let dirtyKeys = object.dirtyKeys();\n    equal(dirtyKeys.length, 2);\n    ok(arrayContains(dirtyKeys, 'gogo'));\n    ok(arrayContains(dirtyKeys, 'sito'));\n    object.save().then(function (obj) {\n      ok(!obj.dirty());\n      dirtyKeys = obj.dirtyKeys();\n      equal(dirtyKeys.length, 0);\n      ok(!arrayContains(dirtyKeys, 'gogo'));\n      ok(!arrayContains(dirtyKeys, 'sito'));\n\n      // try removing keys\n      obj.unset('sito');\n      ok(obj.dirty());\n      dirtyKeys = obj.dirtyKeys();\n      equal(dirtyKeys.length, 1);\n      ok(!arrayContains(dirtyKeys, 'gogo'));\n      ok(arrayContains(dirtyKeys, 'sito'));\n      return obj.save();\n    }).then(function (obj) {\n      ok(!obj.dirty());\n      equal(obj.get('gogo'), 'good');\n      equal(obj.get('sito'), undefined);\n      dirtyKeys = obj.dirtyKeys();\n      equal(dirtyKeys.length, 0);\n      ok(!arrayContains(dirtyKeys, 'gogo'));\n      ok(!arrayContains(dirtyKeys, 'sito'));\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"acl attribute","suites":["Parse.Object testing"],"line":637,"updatePoint":{"line":637,"column":19,"index":19725},"code":"  it('acl attribute', function (done) {\n    Parse.User.signUp('bob', 'password').then(function (user) {\n      const TestObject = Parse.Object.extend('TestObject');\n      const obj = new TestObject({\n        ACL: new Parse.ACL(user) // ACLs cause things like validation to run\n      });\n\n      ok(obj.get('ACL') instanceof Parse.ACL);\n      obj.save().then(function (obj) {\n        ok(obj.get('ACL') instanceof Parse.ACL);\n        const query = new Parse.Query(TestObject);\n        query.get(obj.id).then(function (obj) {\n          ok(obj.get('ACL') instanceof Parse.ACL);\n          const query = new Parse.Query(TestObject);\n          query.find().then(function (results) {\n            obj = results[0];\n            ok(obj.get('ACL') instanceof Parse.ACL);\n            done();\n          });\n        });\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"cannot save object with invalid field","suites":["Parse.Object testing"],"line":660,"updatePoint":{"line":660,"column":43,"index":20576},"code":"  it('cannot save object with invalid field', async () => {\n    const invalidFields = ['className', 'length'];\n    const promises = invalidFields.map(async field => {\n      const obj = new TestObject();\n      obj.set(field, 'bar');\n      try {\n        await obj.save();\n        fail('should not succeed');\n      } catch (e) {\n        expect(e.message).toBe(`Invalid field name: ${field}.`);\n      }\n    });\n    await Promise.all(promises);\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"old attribute unset then unset","suites":["Parse.Object testing"],"line":674,"updatePoint":{"line":674,"column":36,"index":21015},"code":"  it('old attribute unset then unset', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.set('x', 3);\n    obj.save().then(function () {\n      obj.unset('x');\n      obj.unset('x');\n      obj.save().then(function () {\n        equal(obj.has('x'), false);\n        equal(obj.get('x'), undefined);\n        const query = new Parse.Query(TestObject);\n        query.get(obj.id).then(function (objAgain) {\n          equal(objAgain.has('x'), false);\n          equal(objAgain.get('x'), undefined);\n          done();\n        });\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"new attribute unset then unset","suites":["Parse.Object testing"],"line":693,"updatePoint":{"line":693,"column":36,"index":21623},"code":"  it('new attribute unset then unset', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.set('x', 5);\n    obj.unset('x');\n    obj.unset('x');\n    obj.save().then(function () {\n      equal(obj.has('x'), false);\n      equal(obj.get('x'), undefined);\n      const query = new Parse.Query(TestObject);\n      query.get(obj.id).then(function (objAgain) {\n        equal(objAgain.has('x'), false);\n        equal(objAgain.get('x'), undefined);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"unknown attribute unset then unset","suites":["Parse.Object testing"],"line":710,"updatePoint":{"line":710,"column":40,"index":22169},"code":"  it('unknown attribute unset then unset', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.unset('x');\n    obj.unset('x');\n    obj.save().then(function () {\n      equal(obj.has('x'), false);\n      equal(obj.get('x'), undefined);\n      const query = new Parse.Query(TestObject);\n      query.get(obj.id).then(function (objAgain) {\n        equal(objAgain.has('x'), false);\n        equal(objAgain.get('x'), undefined);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"old attribute unset then clear","suites":["Parse.Object testing"],"line":726,"updatePoint":{"line":726,"column":36,"index":22690},"code":"  it('old attribute unset then clear', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.set('x', 3);\n    obj.save().then(function () {\n      obj.unset('x');\n      obj.clear();\n      obj.save().then(function () {\n        equal(obj.has('x'), false);\n        equal(obj.get('x'), undefined);\n        const query = new Parse.Query(TestObject);\n        query.get(obj.id).then(function (objAgain) {\n          equal(objAgain.has('x'), false);\n          equal(objAgain.get('x'), undefined);\n          done();\n        });\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"new attribute unset then clear","suites":["Parse.Object testing"],"line":745,"updatePoint":{"line":745,"column":36,"index":23295},"code":"  it('new attribute unset then clear', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.set('x', 5);\n    obj.unset('x');\n    obj.clear();\n    obj.save().then(function () {\n      equal(obj.has('x'), false);\n      equal(obj.get('x'), undefined);\n      const query = new Parse.Query(TestObject);\n      query.get(obj.id).then(function (objAgain) {\n        equal(objAgain.has('x'), false);\n        equal(objAgain.get('x'), undefined);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"unknown attribute unset then clear","suites":["Parse.Object testing"],"line":762,"updatePoint":{"line":762,"column":40,"index":23838},"code":"  it('unknown attribute unset then clear', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.unset('x');\n    obj.clear();\n    obj.save().then(function () {\n      equal(obj.has('x'), false);\n      equal(obj.get('x'), undefined);\n      const query = new Parse.Query(TestObject);\n      query.get(obj.id).then(function (objAgain) {\n        equal(objAgain.has('x'), false);\n        equal(objAgain.get('x'), undefined);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"old attribute clear then unset","suites":["Parse.Object testing"],"line":778,"updatePoint":{"line":778,"column":36,"index":24356},"code":"  it('old attribute clear then unset', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.set('x', 3);\n    obj.save().then(function () {\n      obj.clear();\n      obj.unset('x');\n      obj.save().then(function () {\n        equal(obj.has('x'), false);\n        equal(obj.get('x'), undefined);\n        const query = new Parse.Query(TestObject);\n        query.get(obj.id).then(function (objAgain) {\n          equal(objAgain.has('x'), false);\n          equal(objAgain.get('x'), undefined);\n          done();\n        });\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"new attribute clear then unset","suites":["Parse.Object testing"],"line":797,"updatePoint":{"line":797,"column":36,"index":24961},"code":"  it('new attribute clear then unset', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.set('x', 5);\n    obj.clear();\n    obj.unset('x');\n    obj.save().then(function () {\n      equal(obj.has('x'), false);\n      equal(obj.get('x'), undefined);\n      const query = new Parse.Query(TestObject);\n      query.get(obj.id).then(function (objAgain) {\n        equal(objAgain.has('x'), false);\n        equal(objAgain.get('x'), undefined);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"unknown attribute clear then unset","suites":["Parse.Object testing"],"line":814,"updatePoint":{"line":814,"column":40,"index":25504},"code":"  it('unknown attribute clear then unset', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.clear();\n    obj.unset('x');\n    obj.save().then(function () {\n      equal(obj.has('x'), false);\n      equal(obj.get('x'), undefined);\n      const query = new Parse.Query(TestObject);\n      query.get(obj.id).then(function (objAgain) {\n        equal(objAgain.has('x'), false);\n        equal(objAgain.get('x'), undefined);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"old attribute clear then clear","suites":["Parse.Object testing"],"line":830,"updatePoint":{"line":830,"column":36,"index":26022},"code":"  it('old attribute clear then clear', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.set('x', 3);\n    obj.save().then(function () {\n      obj.clear();\n      obj.clear();\n      obj.save().then(function () {\n        equal(obj.has('x'), false);\n        equal(obj.get('x'), undefined);\n        const query = new Parse.Query(TestObject);\n        query.get(obj.id).then(function (objAgain) {\n          equal(objAgain.has('x'), false);\n          equal(objAgain.get('x'), undefined);\n          done();\n        });\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"new attribute clear then clear","suites":["Parse.Object testing"],"line":849,"updatePoint":{"line":849,"column":36,"index":26624},"code":"  it('new attribute clear then clear', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.set('x', 5);\n    obj.clear();\n    obj.clear();\n    obj.save().then(function () {\n      equal(obj.has('x'), false);\n      equal(obj.get('x'), undefined);\n      const query = new Parse.Query(TestObject);\n      query.get(obj.id).then(function (objAgain) {\n        equal(objAgain.has('x'), false);\n        equal(objAgain.get('x'), undefined);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"unknown attribute clear then clear","suites":["Parse.Object testing"],"line":866,"updatePoint":{"line":866,"column":40,"index":27164},"code":"  it('unknown attribute clear then clear', function (done) {\n    const TestObject = Parse.Object.extend('TestObject');\n    const obj = new TestObject();\n    obj.clear();\n    obj.clear();\n    obj.save().then(function () {\n      equal(obj.has('x'), false);\n      equal(obj.get('x'), undefined);\n      const query = new Parse.Query(TestObject);\n      query.get(obj.id).then(function (objAgain) {\n        equal(objAgain.has('x'), false);\n        equal(objAgain.get('x'), undefined);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"saving children in an array","suites":["Parse.Object testing"],"line":882,"updatePoint":{"line":882,"column":33,"index":27676},"code":"  it('saving children in an array', function (done) {\n    const Parent = Parse.Object.extend('Parent');\n    const Child = Parse.Object.extend('Child');\n    const child1 = new Child();\n    const child2 = new Child();\n    const parent = new Parent();\n    child1.set('name', 'jamie');\n    child2.set('name', 'cersei');\n    parent.set('children', [child1, child2]);\n    parent.save().then(function () {\n      const query = new Parse.Query(Child);\n      query.ascending('name');\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        equal(results[0].get('name'), 'cersei');\n        equal(results[1].get('name'), 'jamie');\n        done();\n      });\n    }, done.fail);\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"two saves at the same time","suites":["Parse.Object testing"],"line":902,"updatePoint":{"line":902,"column":32,"index":28376},"code":"  it('two saves at the same time', function (done) {\n    const object = new Parse.Object('TestObject');\n    let firstSave = true;\n    const success = function () {\n      if (firstSave) {\n        firstSave = false;\n        return;\n      }\n      const query = new Parse.Query('TestObject');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('cat'), 'meow');\n        equal(results[0].get('dog'), 'bark');\n        done();\n      });\n    };\n    object.save({\n      cat: 'meow'\n    }).then(success, fail);\n    object.save({\n      dog: 'bark'\n    }).then(success, fail);\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"many saves after a failure","suites":["Parse.Object testing"],"line":931,"updatePoint":{"line":931,"column":32,"index":29257},"code":"  it('many saves after a failure', function (done) {\n    // Make a class with a number in the schema.\n    const o1 = new Parse.Object('TestObject');\n    o1.set('number', 1);\n    let object = null;\n    o1.save().then(() => {\n      object = new Parse.Object('TestObject');\n      object.set('number', 'two');\n      return object.save();\n    }).then(fail, error => {\n      expect(error.code).toEqual(Parse.Error.INCORRECT_TYPE);\n      object.set('other', 'foo');\n      return object.save();\n    }).then(fail, error => {\n      expect(error.code).toEqual(Parse.Error.INCORRECT_TYPE);\n      object.set('other', 'bar');\n      return object.save();\n    }).then(fail, error => {\n      expect(error.code).toEqual(Parse.Error.INCORRECT_TYPE);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"is not dirty after save","suites":["Parse.Object testing"],"line":953,"updatePoint":{"line":953,"column":29,"index":30013},"code":"  it('is not dirty after save', function (done) {\n    const obj = new Parse.Object('TestObject');\n    obj.save().then(function () {\n      obj.set({\n        content: 'x'\n      });\n      obj.fetch().then(function () {\n        equal(false, obj.dirty('content'));\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"add with an object","suites":["Parse.Object testing"],"line":965,"updatePoint":{"line":965,"column":24,"index":30308},"code":"  it('add with an object', function (done) {\n    const child = new Parse.Object('Person');\n    const parent = new Parse.Object('Person');\n    Promise.resolve().then(function () {\n      return child.save();\n    }).then(function () {\n      parent.add('children', child);\n      return parent.save();\n    }).then(function () {\n      const query = new Parse.Query('Person');\n      return query.get(parent.id);\n    }).then(function (parentAgain) {\n      equal(parentAgain.get('children')[0].id, child.id);\n    }).then(function () {\n      done();\n    }, function (error) {\n      ok(false, error);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"toJSON saved object","suites":["Parse.Object testing"],"line":985,"updatePoint":{"line":985,"column":25,"index":30927},"code":"  it('toJSON saved object', function (done) {\n    create({\n      foo: 'bar'\n    }, function (model) {\n      const objJSON = model.toJSON();\n      ok(objJSON.foo, \"expected json to contain key 'foo'\");\n      ok(objJSON.objectId, \"expected json to contain key 'objectId'\");\n      ok(objJSON.createdAt, \"expected json to contain key 'createdAt'\");\n      ok(objJSON.updatedAt, \"expected json to contain key 'updatedAt'\");\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"remove object from array","suites":["Parse.Object testing"],"line":997,"updatePoint":{"line":997,"column":30,"index":31378},"code":"  it('remove object from array', function (done) {\n    const obj = new TestObject();\n    obj.save().then(function () {\n      const container = new TestObject();\n      container.add('array', obj);\n      equal(container.get('array').length, 1);\n      container.save(null).then(function () {\n        const objAgain = new TestObject();\n        objAgain.id = obj.id;\n        container.remove('array', objAgain);\n        equal(container.get('array').length, 0);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"async methods","suites":["Parse.Object testing"],"line":1012,"updatePoint":{"line":1012,"column":19,"index":31863},"code":"  it('async methods', function (done) {\n    const obj = new TestObject();\n    obj.set('time', 'adventure');\n    obj.save().then(function (obj) {\n      ok(obj.id, 'objectId should not be null.');\n      const objAgain = new TestObject();\n      objAgain.id = obj.id;\n      return objAgain.fetch();\n    }).then(function (objAgain) {\n      equal(objAgain.get('time'), 'adventure');\n      return objAgain.destroy();\n    }).then(function () {\n      const query = new Parse.Query(TestObject);\n      return query.find();\n    }).then(function (results) {\n      equal(results.length, 0);\n    }).then(function () {\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fail validation with promise","suites":["Parse.Object testing"],"line":1032,"updatePoint":{"line":1032,"column":34,"index":32509},"code":"  it('fail validation with promise', function (done) {\n    const PickyEater = Parse.Object.extend('PickyEater', {\n      validate: function (attrs) {\n        if (attrs.meal === 'tomatoes') {\n          return 'Ew. Tomatoes are gross.';\n        }\n        return Parse.Object.prototype.validate.apply(this, arguments);\n      }\n    });\n    const bryan = new PickyEater();\n    bryan.save({\n      meal: 'burrito'\n    }).then(function () {\n      return bryan.save({\n        meal: 'tomatoes'\n      });\n    }, function () {\n      ok(false, 'Save should have succeeded.');\n    }).then(function () {\n      ok(false, 'Save should have failed.');\n    }, function (error) {\n      equal(error, 'Ew. Tomatoes are gross.');\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave doesn't make object dirty with new field","suites":["Parse.Object testing"],"line":1057,"updatePoint":{"line":1057,"column":57,"index":33266},"code":"  it(\"beforeSave doesn't make object dirty with new field\", function (done) {\n    const restController = Parse.CoreManager.getRESTController();\n    const r = restController.request;\n    restController.request = function () {\n      return r.apply(this, arguments).then(function (result) {\n        result.aDate = {\n          __type: 'Date',\n          iso: '2014-06-24T06:06:06.452Z'\n        };\n        return result;\n      });\n    };\n    const obj = new Parse.Object('Thing');\n    obj.save().then(function () {\n      ok(!obj.dirty(), 'The object should not be dirty');\n      ok(obj.get('aDate'));\n    }).then(function () {\n      restController.request = r;\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"beforeSave doesn't make object dirty with existing field","suites":["Parse.Object testing"],"line":1078,"updatePoint":{"line":1078,"column":63,"index":33955},"skipped":true,"code":"  xit(\"beforeSave doesn't make object dirty with existing field\", function (done) {\n    const restController = Parse.CoreManager.getRESTController();\n    const r = restController.request;\n    restController.request = function () {\n      return r.apply(restController, arguments).then(function (result) {\n        result.aDate = {\n          __type: 'Date',\n          iso: '2014-06-24T06:06:06.452Z'\n        };\n        return result;\n      });\n    };\n    const now = new Date();\n    const obj = new Parse.Object('Thing');\n    const promise = obj.save();\n    obj.set('aDate', now);\n    promise.then(function () {\n      ok(obj.dirty(), 'The object should be dirty');\n      equal(now, obj.get('aDate'));\n    }).then(function () {\n      restController.request = r;\n      done();\n    });\n  });","file":"ParseObject.spec.js","dir":"spec"},{"name":"bytes work","suites":["Parse.Object testing"],"line":1102,"updatePoint":{"line":1102,"column":16,"index":34694},"code":"  it('bytes work', function (done) {\n    Promise.resolve().then(function () {\n      const obj = new TestObject();\n      obj.set('bytes', {\n        __type: 'Bytes',\n        base64: 'ZnJveW8='\n      });\n      return obj.save();\n    }).then(function (obj) {\n      const query = new Parse.Query(TestObject);\n      return query.get(obj.id);\n    }).then(function (obj) {\n      equal(obj.get('bytes').__type, 'Bytes');\n      equal(obj.get('bytes').base64, 'ZnJveW8=');\n      done();\n    }, function (error) {\n      ok(false, JSON.stringify(error));\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"destroyAll no objects","suites":["Parse.Object testing"],"line":1122,"updatePoint":{"line":1122,"column":27,"index":35275},"code":"  it('destroyAll no objects', function (done) {\n    Parse.Object.destroyAll([]).then(function (success) {\n      ok(success, 'Should be able to destroy no objects');\n      done();\n    }).catch(done.fail);\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"destroyAll new objects only","suites":["Parse.Object testing"],"line":1128,"updatePoint":{"line":1128,"column":33,"index":35491},"code":"  it('destroyAll new objects only', function (done) {\n    const objects = [new TestObject(), new TestObject()];\n    Parse.Object.destroyAll(objects).then(function (success) {\n      ok(success, 'Should be able to destroy only new objects');\n      done();\n    }).catch(done.fail);\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fetchAll","suites":["Parse.Object testing"],"line":1135,"updatePoint":{"line":1135,"column":14,"index":35757},"code":"  it('fetchAll', function (done) {\n    const numItems = 11;\n    const container = new Container();\n    const items = [];\n    for (let i = 0; i < numItems; i++) {\n      const item = new Item();\n      item.set('x', i);\n      items.push(item);\n    }\n    Parse.Object.saveAll(items).then(function () {\n      container.set('items', items);\n      return container.save();\n    }).then(function () {\n      const query = new Parse.Query(Container);\n      return query.get(container.id);\n    }).then(function (containerAgain) {\n      const itemsAgain = containerAgain.get('items');\n      if (!itemsAgain || !itemsAgain.forEach) {\n        fail('no itemsAgain retrieved', itemsAgain);\n        done();\n        return;\n      }\n      equal(itemsAgain.length, numItems, 'Should get the array back');\n      itemsAgain.forEach(function (item, i) {\n        const newValue = i * 2;\n        item.set('x', newValue);\n      });\n      return Parse.Object.saveAll(itemsAgain);\n    }).then(function () {\n      return Parse.Object.fetchAll(items);\n    }).then(function (fetchedItemsAgain) {\n      equal(fetchedItemsAgain.length, numItems, 'Number of items fetched should not change');\n      fetchedItemsAgain.forEach(function (item, i) {\n        equal(item.get('x'), i * 2);\n      });\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fetchAll no objects","suites":["Parse.Object testing"],"line":1173,"updatePoint":{"line":1173,"column":25,"index":37054},"code":"  it('fetchAll no objects', function (done) {\n    Parse.Object.fetchAll([]).then(function (success) {\n      ok(Array.isArray(success), 'Should be able to fetchAll no objects');\n      done();\n    }).catch(done.fail);\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fetchAll updates dates","suites":["Parse.Object testing"],"line":1179,"updatePoint":{"line":1179,"column":28,"index":37279},"code":"  it('fetchAll updates dates', function (done) {\n    let updatedObject;\n    const object = new TestObject();\n    object.set('x', 7);\n    object.save().then(function () {\n      const query = new Parse.Query(TestObject);\n      return query.find(object.id);\n    }).then(function (results) {\n      updatedObject = results[0];\n      updatedObject.set('x', 11);\n      return updatedObject.save();\n    }).then(function () {\n      return Parse.Object.fetchAll([object]);\n    }).then(function () {\n      equal(object.createdAt.getTime(), updatedObject.createdAt.getTime());\n      equal(object.updatedAt.getTime(), updatedObject.updatedAt.getTime());\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fetchAll backbone-style callbacks","suites":["Parse.Object testing"],"line":1198,"updatePoint":{"line":1198,"column":40,"index":37960},"skipped":true,"code":"  xit('fetchAll backbone-style callbacks', function (done) {\n    const numItems = 11;\n    const container = new Container();\n    const items = [];\n    for (let i = 0; i < numItems; i++) {\n      const item = new Item();\n      item.set('x', i);\n      items.push(item);\n    }\n    Parse.Object.saveAll(items).then(function () {\n      container.set('items', items);\n      return container.save();\n    }).then(function () {\n      const query = new Parse.Query(Container);\n      return query.get(container.id);\n    }).then(function (containerAgain) {\n      const itemsAgain = containerAgain.get('items');\n      if (!itemsAgain || !itemsAgain.forEach) {\n        fail('no itemsAgain retrieved', itemsAgain);\n        done();\n        return;\n      }\n      equal(itemsAgain.length, numItems, 'Should get the array back');\n      itemsAgain.forEach(function (item, i) {\n        const newValue = i * 2;\n        item.set('x', newValue);\n      });\n      return Parse.Object.saveAll(itemsAgain);\n    }).then(function () {\n      return Parse.Object.fetchAll(items).then(function (fetchedItemsAgain) {\n        equal(fetchedItemsAgain.length, numItems, 'Number of items fetched should not change');\n        fetchedItemsAgain.forEach(function (item, i) {\n          equal(item.get('x'), i * 2);\n        });\n        done();\n      }, function () {\n        ok(false, 'Failed to fetchAll');\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","dir":"spec"},{"name":"fetchAll error on multiple classes","suites":["Parse.Object testing"],"line":1239,"updatePoint":{"line":1239,"column":40,"index":39364},"code":"  it('fetchAll error on multiple classes', function (done) {\n    const container = new Container();\n    container.set('item', new Item());\n    container.set('subcontainer', new Container());\n    return container.save().then(function () {\n      const query = new Parse.Query(Container);\n      return query.get(container.id);\n    }).then(function (containerAgain) {\n      const subContainerAgain = containerAgain.get('subcontainer');\n      const itemAgain = containerAgain.get('item');\n      const multiClassArray = [subContainerAgain, itemAgain];\n      return Parse.Object.fetchAll(multiClassArray).catch(e => {\n        expect(e.code).toBe(Parse.Error.INVALID_CLASS_NAME);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fetchAll error on unsaved object","suites":["Parse.Object testing"],"line":1256,"updatePoint":{"line":1256,"column":38,"index":40074},"code":"  it('fetchAll error on unsaved object', async function (done) {\n    const unsavedObjectArray = [new TestObject()];\n    await Parse.Object.fetchAll(unsavedObjectArray).catch(e => {\n      expect(e.code).toBe(Parse.Error.MISSING_OBJECT_ID);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fetchAll error on deleted object","suites":["Parse.Object testing"],"line":1263,"updatePoint":{"line":1263,"column":38,"index":40341},"code":"  it('fetchAll error on deleted object', function (done) {\n    const numItems = 11;\n    const items = [];\n    for (let i = 0; i < numItems; i++) {\n      const item = new Item();\n      item.set('x', i);\n      items.push(item);\n    }\n    Parse.Object.saveAll(items).then(function () {\n      const query = new Parse.Query(Item);\n      return query.get(items[0].id);\n    }).then(function (objectToDelete) {\n      return objectToDelete.destroy();\n    }).then(function (deletedObject) {\n      const nonExistentObject = new Item({\n        objectId: deletedObject.id\n      });\n      const nonExistentObjectArray = [nonExistentObject, items[1]];\n      return Parse.Object.fetchAll(nonExistentObjectArray).catch(e => {\n        expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fetchAll User attributes get merged","suites":["Parse.Object testing"],"line":1290,"updatePoint":{"line":1290,"column":42,"index":41280},"skipped":true,"code":"  xit('fetchAll User attributes get merged', function (done) {\n    let sameUser;\n    let user = new Parse.User();\n    user.set('username', 'asdf');\n    user.set('password', 'zxcv');\n    user.set('foo', 'bar');\n    user.signUp().then(function () {\n      Parse.User.logOut();\n      const query = new Parse.Query(Parse.User);\n      return query.get(user.id);\n    }).then(function (userAgain) {\n      user = userAgain;\n      sameUser = new Parse.User();\n      sameUser.set('username', 'asdf');\n      sameUser.set('password', 'zxcv');\n      return sameUser.logIn();\n    }).then(function () {\n      ok(!user.getSessionToken(), 'user should not have a sessionToken');\n      ok(sameUser.getSessionToken(), 'sameUser should have a sessionToken');\n      sameUser.set('baz', 'qux');\n      return sameUser.save();\n    }).then(function () {\n      return Parse.Object.fetchAll([user]);\n    }).then(function () {\n      equal(user.getSessionToken(), sameUser.getSessionToken());\n      equal(user.createdAt.getTime(), sameUser.createdAt.getTime());\n      equal(user.updatedAt.getTime(), sameUser.updatedAt.getTime());\n      Parse.User.logOut();\n      done();\n    });\n  });","file":"ParseObject.spec.js","dir":"spec"},{"name":"fetchAllIfNeeded","suites":["Parse.Object testing"],"line":1321,"updatePoint":{"line":1321,"column":22,"index":42416},"code":"  it('fetchAllIfNeeded', function (done) {\n    const numItems = 11;\n    const container = new Container();\n    const items = [];\n    for (let i = 0; i < numItems; i++) {\n      const item = new Item();\n      item.set('x', i);\n      items.push(item);\n    }\n    Parse.Object.saveAll(items).then(function () {\n      container.set('items', items);\n      return container.save();\n    }).then(function () {\n      const query = new Parse.Query(Container);\n      return query.get(container.id);\n    }).then(function (containerAgain) {\n      const itemsAgain = containerAgain.get('items');\n      if (!itemsAgain || !itemsAgain.forEach) {\n        fail('no itemsAgain retrieved', itemsAgain);\n        done();\n        return;\n      }\n      itemsAgain.forEach(function (item, i) {\n        item.set('x', i * 2);\n      });\n      return Parse.Object.saveAll(itemsAgain);\n    }).then(function () {\n      return Parse.Object.fetchAllIfNeeded(items);\n    }).then(function (fetchedItems) {\n      equal(fetchedItems.length, numItems, 'Number of items should not change');\n      fetchedItems.forEach(function (item, i) {\n        equal(item.get('x'), i);\n      });\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fetchAllIfNeeded backbone-style callbacks","suites":["Parse.Object testing"],"line":1357,"updatePoint":{"line":1357,"column":48,"index":43611},"skipped":true,"code":"  xit('fetchAllIfNeeded backbone-style callbacks', function (done) {\n    const numItems = 11;\n    const container = new Container();\n    const items = [];\n    for (let i = 0; i < numItems; i++) {\n      const item = new Item();\n      item.set('x', i);\n      items.push(item);\n    }\n    Parse.Object.saveAll(items).then(function () {\n      container.set('items', items);\n      return container.save();\n    }).then(function () {\n      const query = new Parse.Query(Container);\n      return query.get(container.id);\n    }).then(function (containerAgain) {\n      const itemsAgain = containerAgain.get('items');\n      if (!itemsAgain || !itemsAgain.forEach) {\n        fail('no itemsAgain retrieved', itemsAgain);\n        done();\n        return;\n      }\n      itemsAgain.forEach(function (item, i) {\n        item.set('x', i * 2);\n      });\n      return Parse.Object.saveAll(itemsAgain);\n    }).then(function () {\n      const items = container.get('items');\n      return Parse.Object.fetchAllIfNeeded(items).then(function (fetchedItems) {\n        equal(fetchedItems.length, numItems, 'Number of items should not change');\n        fetchedItems.forEach(function (item, j) {\n          equal(item.get('x'), j);\n        });\n        done();\n      }, function () {\n        ok(false, 'Failed to fetchAll');\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","dir":"spec"},{"name":"fetchAllIfNeeded no objects","suites":["Parse.Object testing"],"line":1397,"updatePoint":{"line":1397,"column":33,"index":44927},"code":"  it('fetchAllIfNeeded no objects', function (done) {\n    Parse.Object.fetchAllIfNeeded([]).then(function (success) {\n      ok(Array.isArray(success), 'Should be able to fetchAll no objects');\n      done();\n    }).catch(done.fail);\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fetchAllIfNeeded unsaved object","suites":["Parse.Object testing"],"line":1403,"updatePoint":{"line":1403,"column":37,"index":45169},"code":"  it('fetchAllIfNeeded unsaved object', async function (done) {\n    const unsavedObjectArray = [new TestObject()];\n    await Parse.Object.fetchAllIfNeeded(unsavedObjectArray).catch(e => {\n      expect(e.code).toBe(Parse.Error.MISSING_OBJECT_ID);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"fetchAllIfNeeded error on multiple classes","suites":["Parse.Object testing"],"line":1410,"updatePoint":{"line":1410,"column":48,"index":45454},"code":"  it('fetchAllIfNeeded error on multiple classes', function (done) {\n    const container = new Container();\n    container.set('item', new Item());\n    container.set('subcontainer', new Container());\n    return container.save().then(function () {\n      const query = new Parse.Query(Container);\n      return query.get(container.id);\n    }).then(function (containerAgain) {\n      const subContainerAgain = containerAgain.get('subcontainer');\n      const itemAgain = containerAgain.get('item');\n      const multiClassArray = [subContainerAgain, itemAgain];\n      return Parse.Object.fetchAllIfNeeded(multiClassArray).catch(e => {\n        expect(e.code).toBe(Parse.Error.INVALID_CLASS_NAME);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"Objects with className User","suites":["Parse.Object testing"],"line":1427,"updatePoint":{"line":1427,"column":33,"index":46167},"code":"  it('Objects with className User', function (done) {\n    equal(Parse.CoreManager.get('PERFORM_USER_REWRITE'), true);\n    const User1 = Parse.Object.extend({\n      className: 'User'\n    });\n    equal(User1.className, '_User', 'className is rewritten by default');\n    Parse.User.allowCustomUserClass(true);\n    equal(Parse.CoreManager.get('PERFORM_USER_REWRITE'), false);\n    const User2 = Parse.Object.extend({\n      className: 'User'\n    });\n    equal(User2.className, 'User', 'className is not rewritten when allowCustomUserClass(true)');\n\n    // Set back to default so as not to break other tests.\n    Parse.User.allowCustomUserClass(false);\n    equal(Parse.CoreManager.get('PERFORM_USER_REWRITE'), true, 'PERFORM_USER_REWRITE is reset');\n    const user = new User2();\n    user.set('name', 'Me');\n    user.save({\n      height: 181\n    }).then(function (user) {\n      equal(user.get('name'), 'Me');\n      equal(user.get('height'), 181);\n      const query = new Parse.Query(User2);\n      query.get(user.id).then(function (user) {\n        equal(user.className, 'User');\n        equal(user.get('name'), 'Me');\n        equal(user.get('height'), 181);\n        done();\n      });\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"create without data","suites":["Parse.Object testing"],"line":1459,"updatePoint":{"line":1459,"column":25,"index":47349},"code":"  it('create without data', function (done) {\n    const t1 = new TestObject({\n      test: 'test'\n    });\n    t1.save().then(function (t1) {\n      const t2 = TestObject.createWithoutData(t1.id);\n      return t2.fetch();\n    }).then(function (t2) {\n      equal(t2.get('test'), 'test', 'Fetch should have grabbed ' + \"'test' property.\");\n      const t3 = TestObject.createWithoutData(t2.id);\n      t3.set('test', 'not test');\n      return t3.fetch();\n    }).then(function (t3) {\n      equal(t3.get('test'), 'test', \"Fetch should have grabbed server 'test' property.\");\n      done();\n    }, function (error) {\n      ok(false, error);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"remove from new field creates array key","suites":["Parse.Object testing"],"line":1479,"updatePoint":{"line":1479,"column":45,"index":48027},"code":"  it('remove from new field creates array key', done => {\n    const obj = new TestObject();\n    obj.remove('shouldBeArray', 'foo');\n    obj.save().then(() => {\n      const query = new Parse.Query('TestObject');\n      return query.get(obj.id);\n    }).then(objAgain => {\n      const arr = objAgain.get('shouldBeArray');\n      ok(Array.isArray(arr), 'Should have created array key');\n      ok(!arr || arr.length === 0, 'Should have an empty array.');\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"increment with type conflict fails","suites":["Parse.Object testing"],"line":1492,"updatePoint":{"line":1492,"column":40,"index":48498},"code":"  it('increment with type conflict fails', done => {\n    const obj = new TestObject();\n    obj.set('astring', 'foo');\n    obj.save().then(() => {\n      const obj2 = new TestObject();\n      obj2.increment('astring');\n      return obj2.save();\n    }).then(() => {\n      fail('Should not have saved.');\n      done();\n    }, error => {\n      expect(error.code).toEqual(111);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"increment with empty field solidifies type","suites":["Parse.Object testing"],"line":1507,"updatePoint":{"line":1507,"column":48,"index":48905},"code":"  it('increment with empty field solidifies type', done => {\n    const obj = new TestObject();\n    obj.increment('aninc');\n    obj.save().then(() => {\n      const obj2 = new TestObject();\n      obj2.set('aninc', 'foo');\n      return obj2.save();\n    }).then(() => {\n      fail('Should not have saved.');\n      done();\n    }, error => {\n      expect(error.code).toEqual(111);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"increment update with type conflict fails","suites":["Parse.Object testing"],"line":1522,"updatePoint":{"line":1522,"column":47,"index":49307},"code":"  it('increment update with type conflict fails', done => {\n    const obj = new TestObject();\n    obj.set('someString', 'foo');\n    obj.save().then(objAgain => {\n      const obj2 = new TestObject();\n      obj2.id = objAgain.id;\n      obj2.increment('someString');\n      return obj2.save();\n    }).then(() => {\n      fail('Should not have saved.');\n      done();\n    }, error => {\n      expect(error.code).toEqual(111);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"dictionary fetched pointers do not lose data on fetch","suites":["Parse.Object testing"],"line":1538,"updatePoint":{"line":1538,"column":59,"index":49766},"code":"  it('dictionary fetched pointers do not lose data on fetch', done => {\n    const parent = new Parse.Object('Parent');\n    const dict = {};\n    for (let i = 0; i < 5; i++) {\n      const proc = iter => {\n        const child = new Parse.Object('Child');\n        child.set('name', 'testname' + i);\n        dict[iter] = child;\n      };\n      proc(i);\n    }\n    parent.set('childDict', dict);\n    parent.save().then(() => {\n      return parent.fetch();\n    }).then(parentAgain => {\n      const dictAgain = parentAgain.get('childDict');\n      if (!dictAgain) {\n        fail('Should have been a dictionary.');\n        return done();\n      }\n      expect(typeof dictAgain).toEqual('object');\n      expect(typeof dictAgain['0']).toEqual('object');\n      expect(typeof dictAgain['1']).toEqual('object');\n      expect(typeof dictAgain['2']).toEqual('object');\n      expect(typeof dictAgain['3']).toEqual('object');\n      expect(typeof dictAgain['4']).toEqual('object');\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"should create nested keys with _","suites":["Parse.Object testing"],"line":1567,"updatePoint":{"line":1567,"column":38,"index":50732},"code":"  it('should create nested keys with _', done => {\n    const object = new Parse.Object('AnObject');\n    object.set('foo', {\n      _bar: '_',\n      baz_bar: 1,\n      __foo_bar: true,\n      _0: 'underscore_zero',\n      _more: {\n        _nested: 'key'\n      }\n    });\n    object.save().then(res => {\n      ok(res);\n      return res.fetch();\n    }).then(res => {\n      const foo = res.get('foo');\n      expect(foo['_bar']).toEqual('_');\n      expect(foo['baz_bar']).toEqual(1);\n      expect(foo['__foo_bar']).toBe(true);\n      expect(foo['_0']).toEqual('underscore_zero');\n      expect(foo['_more']['_nested']).toEqual('key');\n      done();\n    }).catch(err => {\n      jfail(err);\n      fail('should not fail');\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"should have undefined includes when object is missing","suites":["Parse.Object testing"],"line":1595,"updatePoint":{"line":1595,"column":59,"index":51489},"code":"  it('should have undefined includes when object is missing', done => {\n    const obj1 = new Parse.Object('AnObject');\n    const obj2 = new Parse.Object('AnObject');\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      obj1.set('obj', obj2);\n      // Save the pointer, delete the pointee\n      return obj1.save().then(() => {\n        return obj2.destroy();\n      });\n    }).then(() => {\n      const query = new Parse.Query('AnObject');\n      query.include('obj');\n      return query.find();\n    }).then(res => {\n      expect(res.length).toBe(1);\n      if (res[0]) {\n        expect(res[0].get('obj')).toBe(undefined);\n      }\n      const query = new Parse.Query('AnObject');\n      return query.find();\n    }).then(res => {\n      expect(res.length).toBe(1);\n      if (res[0]) {\n        expect(res[0].get('obj')).not.toBe(undefined);\n        return res[0].get('obj').fetch();\n      } else {\n        done();\n      }\n    }).then(() => {\n      fail('Should not fetch a deleted object');\n    }, err => {\n      expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"should have undefined includes when object is missing on deeper path","suites":["Parse.Object testing"],"line":1630,"updatePoint":{"line":1630,"column":74,"index":52593},"code":"  it('should have undefined includes when object is missing on deeper path', done => {\n    const obj1 = new Parse.Object('AnObject');\n    const obj2 = new Parse.Object('AnObject');\n    const obj3 = new Parse.Object('AnObject');\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      obj1.set('obj', obj2);\n      obj2.set('obj', obj3);\n      // Save the pointer, delete the pointee\n      return Parse.Object.saveAll([obj1, obj2]).then(() => {\n        return obj3.destroy();\n      });\n    }).then(() => {\n      const query = new Parse.Query('AnObject');\n      query.include('obj.obj');\n      return query.get(obj1.id);\n    }).then(res => {\n      expect(res.get('obj')).not.toBe(undefined);\n      expect(res.get('obj').get('obj')).toBe(undefined);\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"should handle includes on null arrays #2752","suites":["Parse.Object testing"],"line":1654,"updatePoint":{"line":1654,"column":49,"index":53404},"code":"  it('should handle includes on null arrays #2752', done => {\n    const obj1 = new Parse.Object('AnObject');\n    const obj2 = new Parse.Object('AnotherObject');\n    const obj3 = new Parse.Object('NestedObject');\n    obj3.set({\n      foo: 'bar'\n    });\n    obj2.set({\n      key: obj3\n    });\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      obj1.set('objects', [null, null, obj2]);\n      return obj1.save();\n    }).then(() => {\n      const query = new Parse.Query('AnObject');\n      query.include('objects.key');\n      return query.find();\n    }).then(res => {\n      const obj = res[0];\n      expect(obj.get('objects')).not.toBe(undefined);\n      const array = obj.get('objects');\n      expect(Array.isArray(array)).toBe(true);\n      expect(array[0]).toBe(null);\n      expect(array[1]).toBe(null);\n      expect(array[2].get('key').get('foo')).toEqual('bar');\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"should handle select and include #2786","suites":["Parse.Object testing"],"line":1685,"updatePoint":{"line":1685,"column":44,"index":54348},"code":"  it('should handle select and include #2786', done => {\n    const score = new Parse.Object('GameScore');\n    const player = new Parse.Object('Player');\n    score.set({\n      score: 1234\n    });\n    score.save().then(() => {\n      player.set('gameScore', score);\n      player.set('other', 'value');\n      return player.save();\n    }).then(() => {\n      const query = new Parse.Query('Player');\n      query.include('gameScore');\n      query.select('gameScore');\n      return query.find();\n    }).then(res => {\n      const obj = res[0];\n      const gameScore = obj.get('gameScore');\n      const other = obj.get('other');\n      expect(other).toBeUndefined();\n      expect(gameScore).not.toBeUndefined();\n      expect(gameScore.get('score')).toBe(1234);\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"should include ACLs with select","suites":["Parse.Object testing"],"line":1713,"updatePoint":{"line":1713,"column":37,"index":55173},"code":"  it('should include ACLs with select', done => {\n    const score = new Parse.Object('GameScore');\n    const player = new Parse.Object('Player');\n    score.set({\n      score: 1234\n    });\n    const acl = new Parse.ACL();\n    acl.setPublicReadAccess(true);\n    acl.setPublicWriteAccess(false);\n    score.save().then(() => {\n      player.set('gameScore', score);\n      player.set('other', 'value');\n      player.setACL(acl);\n      return player.save();\n    }).then(() => {\n      const query = new Parse.Query('Player');\n      query.include('gameScore');\n      query.select('gameScore');\n      return query.find();\n    }).then(res => {\n      const obj = res[0];\n      const gameScore = obj.get('gameScore');\n      const other = obj.get('other');\n      expect(other).toBeUndefined();\n      expect(gameScore).not.toBeUndefined();\n      expect(gameScore.get('score')).toBe(1234);\n      expect(obj.getACL().getPublicReadAccess()).toBe(true);\n      expect(obj.getACL().getPublicWriteAccess()).toBe(false);\n    }).then(done).catch(done.fail);\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"Update object field should store exactly same sent object","suites":["Parse.Object testing"],"line":1743,"updatePoint":{"line":1743,"column":63,"index":56239},"code":"  it('Update object field should store exactly same sent object', async done => {\n    let object = new TestObject();\n\n    // Set initial data\n    object.set('jsonData', {\n      a: 'b'\n    });\n    object = await object.save();\n    equal(object.get('jsonData'), {\n      a: 'b'\n    });\n\n    // Set empty JSON\n    object.set('jsonData', {});\n    object = await object.save();\n    equal(object.get('jsonData'), {});\n\n    // Set new JSON data\n    object.unset('jsonData');\n    object.set('jsonData', {\n      c: 'd'\n    });\n    object = await object.save();\n    equal(object.get('jsonData'), {\n      c: 'd'\n    });\n\n    // Fetch object from server\n    object = await object.fetch();\n    equal(object.get('jsonData'), {\n      c: 'd'\n    });\n    done();\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"isNew in cloud code","suites":["Parse.Object testing"],"line":1777,"updatePoint":{"line":1777,"column":25,"index":56952},"code":"  it('isNew in cloud code', async () => {\n    Parse.Cloud.beforeSave('CloudCodeIsNew', req => {\n      expect(req.object.isNew()).toBeTruthy();\n      expect(req.object.id).toBeUndefined();\n    });\n    Parse.Cloud.afterSave('CloudCodeIsNew', req => {\n      expect(req.object.isNew()).toBeFalsy();\n      expect(req.object.id).toBeDefined();\n    });\n    const object = new Parse.Object('CloudCodeIsNew');\n    await object.save();\n  });","file":"ParseObject.spec.js","skipped":false,"dir":"spec"},{"name":"polygon save open path","suites":["Parse.Polygon testing"],"line":10,"updatePoint":{"line":10,"column":28,"index":350},"code":"  it('polygon save open path', done => {\n    const coords = [[0, 0], [0, 1], [1, 1], [1, 0]];\n    const closed = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n    const obj = new TestObject();\n    obj.set('polygon', new Parse.Polygon(coords));\n    return obj.save().then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.get(obj.id);\n    }).then(result => {\n      const polygon = result.get('polygon');\n      equal(polygon instanceof Parse.Polygon, true);\n      equal(polygon.coordinates, closed);\n      done();\n    }, done.fail);\n  });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygon save closed path","suites":["Parse.Polygon testing"],"line":25,"updatePoint":{"line":25,"column":30,"index":911},"code":"  it('polygon save closed path', done => {\n    const coords = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n    const obj = new TestObject();\n    obj.set('polygon', new Parse.Polygon(coords));\n    return obj.save().then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.get(obj.id);\n    }).then(result => {\n      const polygon = result.get('polygon');\n      equal(polygon instanceof Parse.Polygon, true);\n      equal(polygon.coordinates, coords);\n      done();\n    }, done.fail);\n  });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygon equalTo (open/closed) path","suites":["Parse.Polygon testing"],"line":39,"updatePoint":{"line":39,"column":40,"index":1429},"code":"  it('polygon equalTo (open/closed) path', done => {\n    const openPoints = [[0, 0], [0, 1], [1, 1], [1, 0]];\n    const closedPoints = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n    const openPolygon = new Parse.Polygon(openPoints);\n    const closedPolygon = new Parse.Polygon(closedPoints);\n    const obj = new TestObject();\n    obj.set('polygon', openPolygon);\n    return obj.save().then(() => {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('polygon', openPolygon);\n      return query.find();\n    }).then(results => {\n      const polygon = results[0].get('polygon');\n      equal(polygon instanceof Parse.Polygon, true);\n      equal(polygon.coordinates, closedPoints);\n      const query = new Parse.Query(TestObject);\n      query.equalTo('polygon', closedPolygon);\n      return query.find();\n    }).then(results => {\n      const polygon = results[0].get('polygon');\n      equal(polygon instanceof Parse.Polygon, true);\n      equal(polygon.coordinates, closedPoints);\n      done();\n    }, done.fail);\n  });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygon update","suites":["Parse.Polygon testing"],"line":64,"updatePoint":{"line":64,"column":20,"index":2439},"code":"  it('polygon update', done => {\n    const oldCoords = [[0, 0], [0, 1], [1, 1], [1, 0]];\n    const oldPolygon = new Parse.Polygon(oldCoords);\n    const newCoords = [[2, 2], [2, 3], [3, 3], [3, 2]];\n    const newPolygon = new Parse.Polygon(newCoords);\n    const obj = new TestObject();\n    obj.set('polygon', oldPolygon);\n    return obj.save().then(() => {\n      obj.set('polygon', newPolygon);\n      return obj.save();\n    }).then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.get(obj.id);\n    }).then(result => {\n      const polygon = result.get('polygon');\n      newCoords.push(newCoords[0]);\n      equal(polygon instanceof Parse.Polygon, true);\n      equal(polygon.coordinates, newCoords);\n      done();\n    }, done.fail);\n  });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygon invalid value","suites":["Parse.Polygon testing"],"line":85,"updatePoint":{"line":85,"column":27,"index":3208},"code":"  it('polygon invalid value', done => {\n    const coords = [['foo', 'bar'], [0, 1], [1, 0], [1, 1], [0, 0]];\n    const obj = new TestObject();\n    obj.set('polygon', {\n      __type: 'Polygon',\n      coordinates: coords\n    });\n    return obj.save().then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.get(obj.id);\n    }).then(done.fail, () => done());\n  });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygon three points minimum","suites":["Parse.Polygon testing"],"line":97,"updatePoint":{"line":97,"column":34,"index":3602},"code":"  it('polygon three points minimum', done => {\n    const coords = [[0, 0]];\n    const obj = new TestObject();\n    // use raw so we test the server validates properly\n    obj.set('polygon', {\n      __type: 'Polygon',\n      coordinates: coords\n    });\n    obj.save().then(done.fail, () => done());\n  });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygon three different points minimum","suites":["Parse.Polygon testing"],"line":107,"updatePoint":{"line":107,"column":44,"index":3914},"code":"  it('polygon three different points minimum', done => {\n    const coords = [[0, 0], [0, 1], [0, 0]];\n    const obj = new TestObject();\n    obj.set('polygon', new Parse.Polygon(coords));\n    obj.save().then(done.fail, () => done());\n  });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygon counterclockwise","suites":["Parse.Polygon testing"],"line":113,"updatePoint":{"line":113,"column":30,"index":4139},"code":"  it('polygon counterclockwise', done => {\n    const coords = [[1, 1], [0, 1], [0, 0], [1, 0]];\n    const closed = [[1, 1], [0, 1], [0, 0], [1, 0], [1, 1]];\n    const obj = new TestObject();\n    obj.set('polygon', new Parse.Polygon(coords));\n    obj.save().then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.get(obj.id);\n    }).then(result => {\n      const polygon = result.get('polygon');\n      equal(polygon instanceof Parse.Polygon, true);\n      equal(polygon.coordinates, closed);\n      done();\n    }, done.fail);\n  });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygonContain query","suites":["Parse.Polygon testing","with location"],"line":132,"updatePoint":{"line":132,"column":28,"index":4867},"code":"    it('polygonContain query', done => {\n      const points1 = [[0, 0], [0, 1], [1, 1], [1, 0]];\n      const points2 = [[0, 0], [0, 2], [2, 2], [2, 0]];\n      const points3 = [[10, 10], [10, 15], [15, 15], [15, 10], [10, 10]];\n      const polygon1 = new Parse.Polygon(points1);\n      const polygon2 = new Parse.Polygon(points2);\n      const polygon3 = new Parse.Polygon(points3);\n      const obj1 = new TestObject({\n        boundary: polygon1\n      });\n      const obj2 = new TestObject({\n        boundary: polygon2\n      });\n      const obj3 = new TestObject({\n        boundary: polygon3\n      });\n      Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n        const where = {\n          boundary: {\n            $geoIntersects: {\n              $point: {\n                __type: 'GeoPoint',\n                latitude: 0.5,\n                longitude: 0.5\n              }\n            }\n          }\n        };\n        return request({\n          method: 'POST',\n          url: Parse.serverURL + '/classes/TestObject',\n          body: {\n            where,\n            _method: 'GET'\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json'\n          }\n        });\n      }).then(resp => {\n        expect(resp.data.results.length).toBe(2);\n        done();\n      }, done.fail);\n    });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygonContain query no reverse input (Regression test for #4608)","suites":["Parse.Polygon testing","with location"],"line":178,"updatePoint":{"line":178,"column":73,"index":6335},"code":"    it('polygonContain query no reverse input (Regression test for #4608)', done => {\n      const points1 = [[0.25, 0], [0.25, 1.25], [0.75, 1.25], [0.75, 0]];\n      const points2 = [[0, 0], [0, 2], [2, 2], [2, 0]];\n      const points3 = [[10, 10], [10, 15], [15, 15], [15, 10], [10, 10]];\n      const polygon1 = new Parse.Polygon(points1);\n      const polygon2 = new Parse.Polygon(points2);\n      const polygon3 = new Parse.Polygon(points3);\n      const obj1 = new TestObject({\n        boundary: polygon1\n      });\n      const obj2 = new TestObject({\n        boundary: polygon2\n      });\n      const obj3 = new TestObject({\n        boundary: polygon3\n      });\n      Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n        const where = {\n          boundary: {\n            $geoIntersects: {\n              $point: {\n                __type: 'GeoPoint',\n                latitude: 0.5,\n                longitude: 1.0\n              }\n            }\n          }\n        };\n        return request({\n          method: 'POST',\n          url: Parse.serverURL + '/classes/TestObject',\n          body: {\n            where,\n            _method: 'GET'\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json'\n          }\n        });\n      }).then(resp => {\n        expect(resp.data.results.length).toBe(2);\n        done();\n      }, done.fail);\n    });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygonContain query real data (Regression test for #4608)","suites":["Parse.Polygon testing","with location"],"line":224,"updatePoint":{"line":224,"column":66,"index":7814},"code":"    it('polygonContain query real data (Regression test for #4608)', done => {\n      const detroit = [[42.631655189280224, -83.78406753121705], [42.633047793854814, -83.75333640366955], [42.61625254348911, -83.75149921669944], [42.61526926650296, -83.78161794858735], [42.631655189280224, -83.78406753121705]];\n      const polygon = new Parse.Polygon(detroit);\n      const obj = new TestObject({\n        boundary: polygon\n      });\n      obj.save().then(() => {\n        const where = {\n          boundary: {\n            $geoIntersects: {\n              $point: {\n                __type: 'GeoPoint',\n                latitude: 42.624599,\n                longitude: -83.770162\n              }\n            }\n          }\n        };\n        return request({\n          method: 'POST',\n          url: Parse.serverURL + '/classes/TestObject',\n          body: {\n            where,\n            _method: 'GET'\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json'\n          }\n        });\n      }).then(resp => {\n        expect(resp.data.results.length).toBe(1);\n        done();\n      }, done.fail);\n    });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygonContain invalid input","suites":["Parse.Polygon testing","with location"],"line":260,"updatePoint":{"line":260,"column":36,"index":9023},"code":"    it('polygonContain invalid input', done => {\n      const points = [[0, 0], [0, 1], [1, 1], [1, 0]];\n      const polygon = new Parse.Polygon(points);\n      const obj = new TestObject({\n        boundary: polygon\n      });\n      obj.save().then(() => {\n        const where = {\n          boundary: {\n            $geoIntersects: {\n              $point: {\n                __type: 'GeoPoint',\n                latitude: 181,\n                longitude: 181\n              }\n            }\n          }\n        };\n        return request({\n          method: 'POST',\n          url: Parse.serverURL + '/classes/TestObject',\n          body: {\n            where,\n            _method: 'GET'\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey\n          }\n        });\n      }).then(done.fail, () => done());\n    });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygonContain invalid geoPoint","suites":["Parse.Polygon testing","with location"],"line":292,"updatePoint":{"line":292,"column":39,"index":9925},"code":"    it('polygonContain invalid geoPoint', done => {\n      const points = [[0, 0], [0, 1], [1, 1], [1, 0]];\n      const polygon = new Parse.Polygon(points);\n      const obj = new TestObject({\n        boundary: polygon\n      });\n      obj.save().then(() => {\n        const where = {\n          boundary: {\n            $geoIntersects: {\n              $point: []\n            }\n          }\n        };\n        return request({\n          method: 'POST',\n          url: Parse.serverURL + '/classes/TestObject',\n          body: {\n            where,\n            _method: 'GET'\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey\n          }\n        });\n      }).then(done.fail, () => done());\n    });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"support 2d and 2dsphere","suites":["Parse.Polygon testing","with location"],"line":332,"updatePoint":{"line":332,"column":29,"index":11044},"code":"  it('support 2d and 2dsphere', done => {\n    const coords = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n    // testings against REST API, use raw formats\n    const polygon = {\n      __type: 'Polygon',\n      coordinates: coords\n    };\n    const location = {\n      __type: 'GeoPoint',\n      latitude: 10,\n      longitude: 10\n    };\n    const databaseAdapter = config.database.adapter;\n    return reconfigureServer({\n      appId: 'test',\n      restAPIKey: 'rest',\n      publicServerURL: 'http://localhost:8378/1',\n      databaseAdapter\n    }).then(() => {\n      return databaseAdapter.createIndex('TestObject', {\n        location: '2d'\n      });\n    }).then(() => {\n      return databaseAdapter.createIndex('TestObject', {\n        polygon: '2dsphere'\n      });\n    }).then(() => {\n      return request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/TestObject',\n        body: {\n          _method: 'POST',\n          location,\n          polygon,\n          polygon2: polygon\n        },\n        headers: defaultHeaders\n      });\n    }).then(resp => {\n      return request({\n        method: 'POST',\n        url: `http://localhost:8378/1/classes/TestObject/${resp.data.objectId}`,\n        body: {\n          _method: 'GET'\n        },\n        headers: defaultHeaders\n      });\n    }).then(resp => {\n      equal(resp.data.location, location);\n      equal(resp.data.polygon, polygon);\n      equal(resp.data.polygon2, polygon);\n      return databaseAdapter.getIndexes('TestObject');\n    }).then(indexes => {\n      equal(indexes.length, 4);\n      equal(indexes[0].key, {\n        _id: 1\n      });\n      equal(indexes[1].key, {\n        location: '2d'\n      });\n      equal(indexes[2].key, {\n        polygon: '2dsphere'\n      });\n      equal(indexes[3].key, {\n        polygon2: '2dsphere'\n      });\n      done();\n    }, done.fail);\n  });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygon coordinates reverse input","suites":["Parse.Polygon testing","with location"],"line":401,"updatePoint":{"line":401,"column":39,"index":12898},"code":"  it('polygon coordinates reverse input', done => {\n    const Config = require('../lib/Config');\n    const config = Config.get('test');\n\n    // When stored the first point should be the last point\n    const input = [[12, 11], [14, 13], [16, 15], [18, 17]];\n    const output = [[[11, 12], [13, 14], [15, 16], [17, 18], [11, 12]]];\n    const obj = new TestObject();\n    obj.set('polygon', new Parse.Polygon(input));\n    obj.save().then(() => {\n      return config.database.adapter._rawFind('TestObject', {\n        _id: obj.id\n      });\n    }).then(results => {\n      expect(results.length).toBe(1);\n      expect(results[0].polygon.coordinates).toEqual(output);\n      done();\n    });\n  });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"polygon loop is not valid","suites":["Parse.Polygon testing","with location"],"line":420,"updatePoint":{"line":420,"column":31,"index":13577},"code":"  it('polygon loop is not valid', done => {\n    const coords = [[0, 0], [0, 1], [1, 0], [1, 1]];\n    const obj = new TestObject();\n    obj.set('polygon', new Parse.Polygon(coords));\n    obj.save().then(done.fail, () => done());\n  });","file":"ParsePolygon.spec.js","skipped":false,"dir":"spec"},{"name":"can create redis publisher","suites":["ParsePubSub"],"line":18,"updatePoint":{"line":18,"column":32,"index":820},"code":"  it('can create redis publisher', function () {\n    ParsePubSub.createPublisher({\n      redisURL: 'redisURL',\n      redisOptions: {\n        socket_keepalive: true\n      }\n    });\n    const RedisPubSub = require('../lib/Adapters/PubSub/RedisPubSub').RedisPubSub;\n    const EventEmitterPubSub = require('../lib/Adapters/PubSub/EventEmitterPubSub').EventEmitterPubSub;\n    expect(RedisPubSub.createPublisher).toHaveBeenCalledWith({\n      redisURL: 'redisURL',\n      redisOptions: {\n        socket_keepalive: true\n      }\n    });\n    expect(EventEmitterPubSub.createPublisher).not.toHaveBeenCalled();\n  });","file":"ParsePubSub.spec.js","skipped":false,"dir":"spec"},{"name":"can create event emitter publisher","suites":["ParsePubSub"],"line":35,"updatePoint":{"line":35,"column":40,"index":1432},"code":"  it('can create event emitter publisher', function () {\n    ParsePubSub.createPublisher({});\n    const RedisPubSub = require('../lib/Adapters/PubSub/RedisPubSub').RedisPubSub;\n    const EventEmitterPubSub = require('../lib/Adapters/PubSub/EventEmitterPubSub').EventEmitterPubSub;\n    expect(RedisPubSub.createPublisher).not.toHaveBeenCalled();\n    expect(EventEmitterPubSub.createPublisher).toHaveBeenCalled();\n  });","file":"ParsePubSub.spec.js","skipped":false,"dir":"spec"},{"name":"can create redis subscriber","suites":["ParsePubSub"],"line":42,"updatePoint":{"line":42,"column":33,"index":1843},"code":"  it('can create redis subscriber', function () {\n    ParsePubSub.createSubscriber({\n      redisURL: 'redisURL',\n      redisOptions: {\n        socket_keepalive: true\n      }\n    });\n    const RedisPubSub = require('../lib/Adapters/PubSub/RedisPubSub').RedisPubSub;\n    const EventEmitterPubSub = require('../lib/Adapters/PubSub/EventEmitterPubSub').EventEmitterPubSub;\n    expect(RedisPubSub.createSubscriber).toHaveBeenCalledWith({\n      redisURL: 'redisURL',\n      redisOptions: {\n        socket_keepalive: true\n      }\n    });\n    expect(EventEmitterPubSub.createSubscriber).not.toHaveBeenCalled();\n  });","file":"ParsePubSub.spec.js","skipped":false,"dir":"spec"},{"name":"can create event emitter subscriber","suites":["ParsePubSub"],"line":59,"updatePoint":{"line":59,"column":41,"index":2459},"code":"  it('can create event emitter subscriber', function () {\n    ParsePubSub.createSubscriber({});\n    const RedisPubSub = require('../lib/Adapters/PubSub/RedisPubSub').RedisPubSub;\n    const EventEmitterPubSub = require('../lib/Adapters/PubSub/EventEmitterPubSub').EventEmitterPubSub;\n    expect(RedisPubSub.createSubscriber).not.toHaveBeenCalled();\n    expect(EventEmitterPubSub.createSubscriber).toHaveBeenCalled();\n  });","file":"ParsePubSub.spec.js","skipped":false,"dir":"spec"},{"name":"can create publisher/sub with custom adapter","suites":["ParsePubSub"],"line":66,"updatePoint":{"line":66,"column":50,"index":2890},"code":"  it('can create publisher/sub with custom adapter', function () {\n    const adapter = {\n      createPublisher: jasmine.createSpy('createPublisher'),\n      createSubscriber: jasmine.createSpy('createSubscriber')\n    };\n    ParsePubSub.createPublisher({\n      pubSubAdapter: adapter\n    });\n    expect(adapter.createPublisher).toHaveBeenCalled();\n    ParsePubSub.createSubscriber({\n      pubSubAdapter: adapter\n    });\n    expect(adapter.createSubscriber).toHaveBeenCalled();\n    const RedisPubSub = require('../lib/Adapters/PubSub/RedisPubSub').RedisPubSub;\n    const EventEmitterPubSub = require('../lib/Adapters/PubSub/EventEmitterPubSub').EventEmitterPubSub;\n    expect(RedisPubSub.createSubscriber).not.toHaveBeenCalled();\n    expect(EventEmitterPubSub.createSubscriber).not.toHaveBeenCalled();\n    expect(RedisPubSub.createPublisher).not.toHaveBeenCalled();\n    expect(EventEmitterPubSub.createPublisher).not.toHaveBeenCalled();\n  });","file":"ParsePubSub.spec.js","skipped":false,"dir":"spec"},{"name":"can create publisher/sub with custom function adapter","suites":["ParsePubSub"],"line":86,"updatePoint":{"line":86,"column":59,"index":3839},"code":"  it('can create publisher/sub with custom function adapter', function () {\n    const adapter = {\n      createPublisher: jasmine.createSpy('createPublisher'),\n      createSubscriber: jasmine.createSpy('createSubscriber')\n    };\n    ParsePubSub.createPublisher({\n      pubSubAdapter: function () {\n        return adapter;\n      }\n    });\n    expect(adapter.createPublisher).toHaveBeenCalled();\n    ParsePubSub.createSubscriber({\n      pubSubAdapter: function () {\n        return adapter;\n      }\n    });\n    expect(adapter.createSubscriber).toHaveBeenCalled();\n    const RedisPubSub = require('../lib/Adapters/PubSub/RedisPubSub').RedisPubSub;\n    const EventEmitterPubSub = require('../lib/Adapters/PubSub/EventEmitterPubSub').EventEmitterPubSub;\n    expect(RedisPubSub.createSubscriber).not.toHaveBeenCalled();\n    expect(EventEmitterPubSub.createSubscriber).not.toHaveBeenCalled();\n    expect(RedisPubSub.createPublisher).not.toHaveBeenCalled();\n    expect(EventEmitterPubSub.createPublisher).not.toHaveBeenCalled();\n  });","file":"ParsePubSub.spec.js","skipped":false,"dir":"spec"},{"name":"should only query aggregate with master key","suites":["Parse.Query Aggregate testing"],"line":84,"updatePoint":{"line":84,"column":49,"index":2008},"code":"  it('should only query aggregate with master key', done => {\n    Parse._request('GET', `aggregate/someClass`, {}).then(() => {}, error => {\n      expect(error.message).toEqual('unauthorized: master key is required');\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"invalid query group _id required","suites":["Parse.Query Aggregate testing"],"line":90,"updatePoint":{"line":90,"column":38,"index":2243},"code":"  it('invalid query group _id required', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        group: {} // TODO: write as `$group`. See [#7339](https://bit.ly/3incnWx)\n      }\n    });\n\n    get(Parse.serverURL + '/aggregate/TestObject', options).catch(error => {\n      expect(error.error.code).toEqual(Parse.Error.INVALID_QUERY);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group by field","suites":["Parse.Query Aggregate testing"],"line":102,"updatePoint":{"line":102,"column":20,"index":2619},"code":"  it('group by field', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        group: {\n          objectId: '$name'\n        } // TODO: write as `$group`. See [#7339](https://bit.ly/3incnWx)\n      }\n    });\n\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(3);\n      expect(Object.prototype.hasOwnProperty.call(resp.results[0], 'objectId')).toBe(true);\n      expect(Object.prototype.hasOwnProperty.call(resp.results[1], 'objectId')).toBe(true);\n      expect(Object.prototype.hasOwnProperty.call(resp.results[2], 'objectId')).toBe(true);\n      expect(resp.results[0].objectId).not.toBe(undefined);\n      expect(resp.results[1].objectId).not.toBe(undefined);\n      expect(resp.results[2].objectId).not.toBe(undefined);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group by pipeline operator","suites":["Parse.Query Aggregate testing"],"line":122,"updatePoint":{"line":122,"column":32,"index":3491},"code":"  it('group by pipeline operator', async () => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        pipeline: {\n          group: {\n            objectId: '$name'\n          } // TODO: write as `$group`. See [#7339](https://bit.ly/3incnWx)\n        }\n      }\n    });\n\n    const resp = await get(Parse.serverURL + '/aggregate/TestObject', options);\n    expect(resp.results.length).toBe(3);\n    expect(Object.prototype.hasOwnProperty.call(resp.results[0], 'objectId')).toBe(true);\n    expect(Object.prototype.hasOwnProperty.call(resp.results[1], 'objectId')).toBe(true);\n    expect(Object.prototype.hasOwnProperty.call(resp.results[2], 'objectId')).toBe(true);\n    expect(resp.results[0].objectId).not.toBe(undefined);\n    expect(resp.results[1].objectId).not.toBe(undefined);\n    expect(resp.results[2].objectId).not.toBe(undefined);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group by empty object","suites":["Parse.Query Aggregate testing"],"line":142,"updatePoint":{"line":142,"column":27,"index":4350},"code":"  it('group by empty object', done => {\n    const obj = new TestObject();\n    const pipeline = [{\n      group: {\n        objectId: {}\n      } // TODO: write as `$group`. See [#7339](https://bit.ly/3incnWx)\n    }];\n\n    obj.save().then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results[0].objectId).toEqual(null);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group by empty string","suites":["Parse.Query Aggregate testing"],"line":158,"updatePoint":{"line":158,"column":27,"index":4784},"code":"  it('group by empty string', done => {\n    const obj = new TestObject();\n    const pipeline = [{\n      group: {\n        objectId: ''\n      } // TODO: write as `$group`. See [#7339](https://bit.ly/3incnWx)\n    }];\n\n    obj.save().then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results[0].objectId).toEqual(null);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group by empty array","suites":["Parse.Query Aggregate testing"],"line":174,"updatePoint":{"line":174,"column":26,"index":5217},"code":"  it('group by empty array', done => {\n    const obj = new TestObject();\n    const pipeline = [{\n      group: {\n        objectId: []\n      } // TODO: write as `$group`. See [#7339](https://bit.ly/3incnWx)\n    }];\n\n    obj.save().then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results[0].objectId).toEqual(null);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group by multiple columns ","suites":["Parse.Query Aggregate testing"],"line":190,"updatePoint":{"line":190,"column":32,"index":5656},"code":"  it('group by multiple columns ', done => {\n    const obj1 = new TestObject();\n    const obj2 = new TestObject();\n    const obj3 = new TestObject();\n    const pipeline = [{\n      // TODO: update to new syntax. See [#7339](https://bit.ly/3incnWx)\n      group: {\n        objectId: {\n          score: '$score',\n          views: '$views'\n        },\n        count: {\n          $sum: 1\n        }\n      }\n    }];\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results.length).toEqual(5);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group by date object","suites":["Parse.Query Aggregate testing"],"line":214,"updatePoint":{"line":214,"column":26,"index":6298},"code":"  it('group by date object', done => {\n    const obj1 = new TestObject();\n    const obj2 = new TestObject();\n    const obj3 = new TestObject();\n    const pipeline = [{\n      $group: {\n        _id: {\n          day: {\n            $dayOfMonth: '$_updated_at'\n          },\n          month: {\n            $month: '$_created_at'\n          },\n          year: {\n            $year: '$_created_at'\n          }\n        },\n        count: {\n          $sum: 1\n        }\n      }\n    }];\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      const createdAt = new Date(obj1.createdAt);\n      expect(results[0].objectId.day).toEqual(createdAt.getUTCDate());\n      expect(results[0].objectId.month).toEqual(createdAt.getUTCMonth() + 1);\n      expect(results[0].objectId.year).toEqual(createdAt.getUTCFullYear());\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group by date object transform","suites":["Parse.Query Aggregate testing"],"line":247,"updatePoint":{"line":247,"column":36,"index":7255},"code":"  it('group by date object transform', done => {\n    const obj1 = new TestObject();\n    const obj2 = new TestObject();\n    const obj3 = new TestObject();\n    const pipeline = [{\n      $group: {\n        _id: {\n          day: {\n            $dayOfMonth: '$updatedAt'\n          },\n          month: {\n            $month: '$createdAt'\n          },\n          year: {\n            $year: '$createdAt'\n          }\n        },\n        count: {\n          $sum: 1\n        }\n      }\n    }];\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      const createdAt = new Date(obj1.createdAt);\n      expect(results[0].objectId.day).toEqual(createdAt.getUTCDate());\n      expect(results[0].objectId.month).toEqual(createdAt.getUTCMonth() + 1);\n      expect(results[0].objectId.year).toEqual(createdAt.getUTCFullYear());\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group by number","suites":["Parse.Query Aggregate testing"],"line":280,"updatePoint":{"line":280,"column":21,"index":8191},"code":"  it('group by number', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        group: {\n          objectId: '$score'\n        } // TODO: update to new syntax. See [#7339](https://bit.ly/3incnWx)\n      }\n    });\n\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(2);\n      expect(Object.prototype.hasOwnProperty.call(resp.results[0], 'objectId')).toBe(true);\n      expect(Object.prototype.hasOwnProperty.call(resp.results[1], 'objectId')).toBe(true);\n      expect(resp.results.sort((a, b) => a.objectId > b.objectId ? 1 : -1)).toEqual([{\n        objectId: 10\n      }, {\n        objectId: 20\n      }]);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group by pointer","suites":["Parse.Query Aggregate testing"],"line":519,"updatePoint":{"line":519,"column":22,"index":14867},"code":"  it('group by pointer', done => {\n    const pointer1 = new TestObject();\n    const pointer2 = new TestObject();\n    const obj1 = new TestObject({\n      pointer: pointer1\n    });\n    const obj2 = new TestObject({\n      pointer: pointer2\n    });\n    const obj3 = new TestObject({\n      pointer: pointer1\n    });\n    const pipeline = [{\n      group: {\n        objectId: '$pointer'\n      }\n    }];\n    Parse.Object.saveAll([pointer1, pointer2, obj1, obj2, obj3]).then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results.length).toEqual(3);\n      expect(results.some(result => result.objectId === pointer1.id)).toEqual(true);\n      expect(results.some(result => result.objectId === pointer2.id)).toEqual(true);\n      expect(results.some(result => result.objectId === null)).toEqual(true);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group sum query","suites":["Parse.Query Aggregate testing"],"line":547,"updatePoint":{"line":547,"column":21,"index":15770},"code":"  it('group sum query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        // TODO: update to new syntax. See [#7339](https://bit.ly/3incnWx)\n        group: {\n          objectId: null,\n          total: {\n            $sum: '$score'\n          }\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(Object.prototype.hasOwnProperty.call(resp.results[0], 'objectId')).toBe(true);\n      expect(resp.results[0].objectId).toBe(null);\n      expect(resp.results[0].total).toBe(50);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group count query","suites":["Parse.Query Aggregate testing"],"line":566,"updatePoint":{"line":566,"column":23,"index":16389},"code":"  it('group count query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        // TODO: update to new syntax. See [#7339](https://bit.ly/3incnWx)\n        group: {\n          objectId: null,\n          total: {\n            $sum: 1\n          }\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(Object.prototype.hasOwnProperty.call(resp.results[0], 'objectId')).toBe(true);\n      expect(resp.results[0].objectId).toBe(null);\n      expect(resp.results[0].total).toBe(4);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group min query","suites":["Parse.Query Aggregate testing"],"line":585,"updatePoint":{"line":585,"column":21,"index":16998},"code":"  it('group min query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        // TODO: update to new syntax. See [#7339](https://bit.ly/3incnWx)\n        group: {\n          objectId: null,\n          minScore: {\n            $min: '$score'\n          }\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(Object.prototype.hasOwnProperty.call(resp.results[0], 'objectId')).toBe(true);\n      expect(resp.results[0].objectId).toBe(null);\n      expect(resp.results[0].minScore).toBe(10);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group max query","suites":["Parse.Query Aggregate testing"],"line":604,"updatePoint":{"line":604,"column":21,"index":17621},"code":"  it('group max query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        // TODO: update to new syntax. See [#7339](https://bit.ly/3incnWx)\n        group: {\n          objectId: null,\n          maxScore: {\n            $max: '$score'\n          }\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(Object.prototype.hasOwnProperty.call(resp.results[0], 'objectId')).toBe(true);\n      expect(resp.results[0].objectId).toBe(null);\n      expect(resp.results[0].maxScore).toBe(20);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"group avg query","suites":["Parse.Query Aggregate testing"],"line":623,"updatePoint":{"line":623,"column":21,"index":18244},"code":"  it('group avg query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        // TODO: update to new syntax. See [#7339](https://bit.ly/3incnWx)\n        group: {\n          objectId: null,\n          avgScore: {\n            $avg: '$score'\n          }\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(Object.prototype.hasOwnProperty.call(resp.results[0], 'objectId')).toBe(true);\n      expect(resp.results[0].objectId).toBe(null);\n      expect(resp.results[0].avgScore).toBe(12.5);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"limit query","suites":["Parse.Query Aggregate testing"],"line":642,"updatePoint":{"line":642,"column":17,"index":18865},"code":"  it('limit query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        limit: 2\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(2);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"sort ascending query","suites":["Parse.Query Aggregate testing"],"line":653,"updatePoint":{"line":653,"column":26,"index":19172},"code":"  it('sort ascending query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        sort: {\n          name: 1\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(4);\n      expect(resp.results[0].name).toBe('bar');\n      expect(resp.results[1].name).toBe('dpl');\n      expect(resp.results[2].name).toBe('foo');\n      expect(resp.results[3].name).toBe('foo');\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"sort decending query","suites":["Parse.Query Aggregate testing"],"line":670,"updatePoint":{"line":670,"column":26,"index":19698},"code":"  it('sort decending query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        sort: {\n          name: -1\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(4);\n      expect(resp.results[0].name).toBe('foo');\n      expect(resp.results[1].name).toBe('foo');\n      expect(resp.results[2].name).toBe('dpl');\n      expect(resp.results[3].name).toBe('bar');\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"skip query","suites":["Parse.Query Aggregate testing"],"line":687,"updatePoint":{"line":687,"column":16,"index":20215},"code":"  it('skip query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        skip: 2\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(2);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match comparison date query","suites":["Parse.Query Aggregate testing"],"line":698,"updatePoint":{"line":698,"column":33,"index":20528},"code":"  it('match comparison date query', done => {\n    const today = new Date();\n    const yesterday = new Date();\n    const tomorrow = new Date();\n    yesterday.setDate(today.getDate() - 1);\n    tomorrow.setDate(today.getDate() + 1);\n    const obj1 = new TestObject({\n      dateField: yesterday\n    });\n    const obj2 = new TestObject({\n      dateField: today\n    });\n    const obj3 = new TestObject({\n      dateField: tomorrow\n    });\n    const pipeline = [{\n      match: {\n        dateField: {\n          $lt: tomorrow\n        }\n      }\n    }];\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results.length).toBe(2);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"should aggregate with Date object (directAccess)","suites":["Parse.Query Aggregate testing"],"line":728,"updatePoint":{"line":728,"column":54,"index":21329},"code":"  it('should aggregate with Date object (directAccess)', async () => {\n    const rest = require('../lib/rest');\n    const auth = require('../lib/Auth');\n    const TestObject = Parse.Object.extend('TestObject');\n    const date = new Date();\n    await new TestObject({\n      date: date\n    }).save(null, {\n      useMasterKey: true\n    });\n    const config = Config.get(Parse.applicationId);\n    const resp = await rest.find(config, auth.master(config), 'TestObject', {}, {\n      pipeline: [{\n        $match: {\n          date: {\n            $lte: new Date()\n          }\n        }\n      }]\n    });\n    expect(resp.results.length).toBe(1);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match comparison query","suites":["Parse.Query Aggregate testing"],"line":750,"updatePoint":{"line":750,"column":28,"index":21944},"code":"  it('match comparison query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        match: {\n          score: {\n            $gt: 15\n          }\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(1);\n      expect(resp.results[0].score).toBe(20);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match multiple comparison query","suites":["Parse.Query Aggregate testing"],"line":766,"updatePoint":{"line":766,"column":37,"index":22369},"code":"  it('match multiple comparison query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        match: {\n          score: {\n            $gt: 5,\n            $lt: 15\n          }\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(3);\n      expect(resp.results[0].score).toBe(10);\n      expect(resp.results[1].score).toBe(10);\n      expect(resp.results[2].score).toBe(10);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match complex comparison query","suites":["Parse.Query Aggregate testing"],"line":785,"updatePoint":{"line":785,"column":36,"index":22905},"code":"  it('match complex comparison query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        match: {\n          score: {\n            $gt: 5,\n            $lt: 15\n          },\n          views: {\n            $gt: 850,\n            $lt: 1000\n          }\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(1);\n      expect(resp.results[0].score).toBe(10);\n      expect(resp.results[0].views).toBe(900);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match comparison and equality query","suites":["Parse.Query Aggregate testing"],"line":807,"updatePoint":{"line":807,"column":41,"index":23477},"code":"  it('match comparison and equality query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        match: {\n          score: {\n            $gt: 5,\n            $lt: 15\n          },\n          views: 900\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(1);\n      expect(resp.results[0].score).toBe(10);\n      expect(resp.results[0].views).toBe(900);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match $or query","suites":["Parse.Query Aggregate testing"],"line":826,"updatePoint":{"line":826,"column":21,"index":23975},"code":"  it('match $or query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        match: {\n          $or: [{\n            score: {\n              $gt: 15,\n              $lt: 25\n            }\n          }, {\n            views: {\n              $gt: 750,\n              $lt: 850\n            }\n          }]\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(2);\n      // Match score { $gt: 15, $lt: 25 }\n      expect(resp.results.some(result => result.score === 20)).toEqual(true);\n      expect(resp.results.some(result => result.views === 700)).toEqual(true);\n\n      // Match view { $gt: 750, $lt: 850 }\n      expect(resp.results.some(result => result.score === 10)).toEqual(true);\n      expect(resp.results.some(result => result.views === 800)).toEqual(true);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match objectId query","suites":["Parse.Query Aggregate testing"],"line":856,"updatePoint":{"line":856,"column":26,"index":24900},"code":"  it('match objectId query', done => {\n    const obj1 = new TestObject();\n    const obj2 = new TestObject();\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      const pipeline = [{\n        match: {\n          objectId: obj1.id\n        }\n      }];\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].objectId).toEqual(obj1.id);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match field query","suites":["Parse.Query Aggregate testing"],"line":873,"updatePoint":{"line":873,"column":23,"index":25384},"code":"  it('match field query', done => {\n    const obj1 = new TestObject({\n      name: 'TestObject1'\n    });\n    const obj2 = new TestObject({\n      name: 'TestObject2'\n    });\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      const pipeline = [{\n        match: {\n          name: 'TestObject1'\n        }\n      }];\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].objectId).toEqual(obj1.id);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match pointer query","suites":["Parse.Query Aggregate testing"],"line":894,"updatePoint":{"line":894,"column":25,"index":25938},"code":"  it('match pointer query', done => {\n    const pointer1 = new PointerObject();\n    const pointer2 = new PointerObject();\n    const obj1 = new TestObject({\n      pointer: pointer1\n    });\n    const obj2 = new TestObject({\n      pointer: pointer2\n    });\n    const obj3 = new TestObject({\n      pointer: pointer1\n    });\n    Parse.Object.saveAll([pointer1, pointer2, obj1, obj2, obj3]).then(() => {\n      const pipeline = [{\n        match: {\n          pointer: pointer1.id\n        }\n      }];\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results.length).toEqual(2);\n      expect(results[0].pointer.objectId).toEqual(pointer1.id);\n      expect(results[1].pointer.objectId).toEqual(pointer1.id);\n      expect(results.some(result => result.objectId === obj1.id)).toEqual(true);\n      expect(results.some(result => result.objectId === obj3.id)).toEqual(true);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match date query - createdAt","suites":["Parse.Query Aggregate testing"],"line":937,"updatePoint":{"line":937,"column":34,"index":27245},"code":"  it('match date query - createdAt', done => {\n    const obj1 = new TestObject();\n    const obj2 = new TestObject();\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      const now = new Date();\n      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      const pipeline = [{\n        match: {\n          createdAt: {\n            $gte: today\n          }\n        }\n      }];\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      // Four objects were created initially, we added two more.\n      expect(results.length).toEqual(6);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match date query - updatedAt","suites":["Parse.Query Aggregate testing"],"line":958,"updatePoint":{"line":958,"column":34,"index":27894},"code":"  it('match date query - updatedAt', done => {\n    const obj1 = new TestObject();\n    const obj2 = new TestObject();\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      const now = new Date();\n      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      const pipeline = [{\n        match: {\n          updatedAt: {\n            $gte: today\n          }\n        }\n      }];\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      // Four objects were added initially, we added two more.\n      expect(results.length).toEqual(6);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"match date query - empty","suites":["Parse.Query Aggregate testing"],"line":979,"updatePoint":{"line":979,"column":30,"index":28537},"code":"  it('match date query - empty', done => {\n    const obj1 = new TestObject();\n    const obj2 = new TestObject();\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      const now = new Date();\n      const future = new Date(now.getFullYear(), now.getMonth() + 1, now.getDate());\n      const pipeline = [{\n        match: {\n          createdAt: future\n        }\n      }];\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results.length).toEqual(0);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"project query","suites":["Parse.Query Aggregate testing"],"line":1062,"updatePoint":{"line":1062,"column":19,"index":31294},"code":"  it('project query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        project: {\n          name: 1\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      resp.results.forEach(result => {\n        expect(result.objectId).not.toBe(undefined);\n        expect(result.name).not.toBe(undefined);\n        expect(result.sender).toBe(undefined);\n        expect(result.size).toBe(undefined);\n        expect(result.score).toBe(undefined);\n      });\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"multiple project query","suites":["Parse.Query Aggregate testing"],"line":1081,"updatePoint":{"line":1081,"column":28,"index":31879},"code":"  it('multiple project query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        project: {\n          name: 1,\n          score: 1,\n          sender: 1\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      resp.results.forEach(result => {\n        expect(result.objectId).not.toBe(undefined);\n        expect(result.name).not.toBe(undefined);\n        expect(result.score).not.toBe(undefined);\n        expect(result.sender).not.toBe(undefined);\n        expect(result.size).toBe(undefined);\n      });\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"project pointer query","suites":["Parse.Query Aggregate testing"],"line":1102,"updatePoint":{"line":1102,"column":27,"index":32512},"code":"  it('project pointer query', done => {\n    const pointer = new PointerObject();\n    const obj = new TestObject({\n      pointer,\n      name: 'hello'\n    });\n    obj.save().then(() => {\n      const pipeline = [{\n        match: {\n          objectId: obj.id\n        }\n      }, {\n        project: {\n          pointer: 1,\n          name: 1,\n          createdAt: 1\n        }\n      }];\n      const query = new Parse.Query(TestObject);\n      return query.aggregate(pipeline);\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].name).toEqual('hello');\n      expect(results[0].createdAt).not.toBe(undefined);\n      expect(results[0].pointer.objectId).toEqual(pointer.id);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"project with group query","suites":["Parse.Query Aggregate testing"],"line":1130,"updatePoint":{"line":1130,"column":30,"index":33244},"code":"  it('project with group query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        project: {\n          score: 1\n        },\n        // TODO: update to new syntax. See [#7339](https://bit.ly/3incnWx)\n        group: {\n          objectId: '$score',\n          score: {\n            $sum: '$score'\n          }\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(2);\n      resp.results.forEach(result => {\n        expect(Object.prototype.hasOwnProperty.call(result, 'objectId')).toBe(true);\n        expect(result.name).toBe(undefined);\n        expect(result.sender).toBe(undefined);\n        expect(result.size).toBe(undefined);\n        expect(result.score).not.toBe(undefined);\n        if (result.objectId === 10) {\n          expect(result.score).toBe(30);\n        }\n        if (result.objectId === 20) {\n          expect(result.score).toBe(20);\n        }\n      });\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"class does not exist return empty","suites":["Parse.Query Aggregate testing"],"line":1163,"updatePoint":{"line":1163,"column":39,"index":34285},"code":"  it('class does not exist return empty', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        // TODO: update to new syntax. See [#7339](https://bit.ly/3incnWx)\n        group: {\n          objectId: null,\n          total: {\n            $sum: '$score'\n          }\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/UnknownClass', options).then(resp => {\n      expect(resp.results.length).toBe(0);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"field does not exist return empty","suites":["Parse.Query Aggregate testing"],"line":1180,"updatePoint":{"line":1180,"column":39,"index":34776},"code":"  it('field does not exist return empty', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        // TODO: update to new syntax. See [#7339](https://bit.ly/3incnWx)\n        group: {\n          objectId: null,\n          total: {\n            $sum: '$unknownfield'\n          }\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/UnknownClass', options).then(resp => {\n      expect(resp.results.length).toBe(0);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct query","suites":["Parse.Query Aggregate testing"],"line":1197,"updatePoint":{"line":1197,"column":20,"index":35255},"code":"  it('distinct query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        distinct: 'score'\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(2);\n      expect(resp.results.includes(10)).toBe(true);\n      expect(resp.results.includes(20)).toBe(true);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct query with where","suites":["Parse.Query Aggregate testing"],"line":1210,"updatePoint":{"line":1210,"column":31,"index":35680},"code":"  it('distinct query with where', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        distinct: 'score',\n        where: {\n          name: 'bar'\n        }\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results[0]).toBe(10);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct query with where string","suites":["Parse.Query Aggregate testing"],"line":1224,"updatePoint":{"line":1224,"column":38,"index":36055},"code":"  it('distinct query with where string', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        distinct: 'score',\n        where: JSON.stringify({\n          name: 'bar'\n        })\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results[0]).toBe(10);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct nested","suites":["Parse.Query Aggregate testing"],"line":1238,"updatePoint":{"line":1238,"column":21,"index":36429},"code":"  it('distinct nested', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        distinct: 'sender.group'\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(2);\n      expect(resp.results.includes('A')).toBe(true);\n      expect(resp.results.includes('B')).toBe(true);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct pointer","suites":["Parse.Query Aggregate testing"],"line":1251,"updatePoint":{"line":1251,"column":22,"index":36854},"code":"  it('distinct pointer', done => {\n    const pointer1 = new PointerObject();\n    const pointer2 = new PointerObject();\n    const obj1 = new TestObject({\n      pointer: pointer1\n    });\n    const obj2 = new TestObject({\n      pointer: pointer2\n    });\n    const obj3 = new TestObject({\n      pointer: pointer1\n    });\n    Parse.Object.saveAll([pointer1, pointer2, obj1, obj2, obj3]).then(() => {\n      const query = new Parse.Query(TestObject);\n      return query.distinct('pointer');\n    }).then(results => {\n      expect(results.length).toEqual(2);\n      expect(results.some(result => result.objectId === pointer1.id)).toEqual(true);\n      expect(results.some(result => result.objectId === pointer2.id)).toEqual(true);\n      done();\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct class does not exist return empty","suites":["Parse.Query Aggregate testing"],"line":1273,"updatePoint":{"line":1273,"column":48,"index":37628},"code":"  it('distinct class does not exist return empty', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        distinct: 'unknown'\n      }\n    });\n    get(Parse.serverURL + '/aggregate/UnknownClass', options).then(resp => {\n      expect(resp.results.length).toBe(0);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct field does not exist return empty","suites":["Parse.Query Aggregate testing"],"line":1284,"updatePoint":{"line":1284,"column":48,"index":37970},"code":"  it('distinct field does not exist return empty', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        distinct: 'unknown'\n      }\n    });\n    const obj = new TestObject();\n    obj.save().then(() => {\n      return get(Parse.serverURL + '/aggregate/TestObject', options);\n    }).then(resp => {\n      expect(resp.results.length).toBe(0);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct array","suites":["Parse.Query Aggregate testing"],"line":1298,"updatePoint":{"line":1298,"column":20,"index":38361},"code":"  it('distinct array', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        distinct: 'size'\n      }\n    });\n    get(Parse.serverURL + '/aggregate/TestObject', options).then(resp => {\n      expect(resp.results.length).toBe(3);\n      expect(resp.results.includes('S')).toBe(true);\n      expect(resp.results.includes('M')).toBe(true);\n      expect(resp.results.includes('L')).toBe(true);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct objectId","suites":["Parse.Query Aggregate testing"],"line":1312,"updatePoint":{"line":1312,"column":23,"index":38832},"code":"  it('distinct objectId', async () => {\n    const query = new Parse.Query(TestObject);\n    const results = await query.distinct('objectId');\n    expect(results.length).toBe(4);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct createdAt","suites":["Parse.Query Aggregate testing"],"line":1317,"updatePoint":{"line":1317,"column":24,"index":39016},"code":"  it('distinct createdAt', async () => {\n    const object1 = new TestObject({\n      createdAt_test: true\n    });\n    await object1.save();\n    const object2 = new TestObject({\n      createdAt_test: true\n    });\n    await object2.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('createdAt_test', true);\n    const results = await query.distinct('createdAt');\n    expect(results.length).toBe(2);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct updatedAt","suites":["Parse.Query Aggregate testing"],"line":1331,"updatePoint":{"line":1331,"column":24,"index":39440},"code":"  it('distinct updatedAt', async () => {\n    const object1 = new TestObject({\n      updatedAt_test: true\n    });\n    await object1.save();\n    const object2 = new TestObject();\n    await object2.save();\n    object2.set('updatedAt_test', true);\n    await object2.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('updatedAt_test', true);\n    const results = await query.distinct('updatedAt');\n    expect(results.length).toBe(2);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"distinct null field","suites":["Parse.Query Aggregate testing"],"line":1345,"updatePoint":{"line":1345,"column":25,"index":39898},"code":"  it('distinct null field', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        distinct: 'distinctField'\n      }\n    });\n    const user1 = new Parse.User();\n    user1.setUsername('distinct_1');\n    user1.setPassword('password');\n    user1.set('distinctField', 'one');\n    const user2 = new Parse.User();\n    user2.setUsername('distinct_2');\n    user2.setPassword('password');\n    user2.set('distinctField', null);\n    user1.signUp().then(() => {\n      return user2.signUp();\n    }).then(() => {\n      return get(Parse.serverURL + '/aggregate/_User', options);\n    }).then(resp => {\n      expect(resp.results.length).toEqual(1);\n      expect(resp.results).toEqual(['one']);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"does not return sensitive hidden properties","suites":["Parse.Query Aggregate testing"],"line":1369,"updatePoint":{"line":1369,"column":49,"index":40679},"code":"  it('does not return sensitive hidden properties', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      body: {\n        match: {\n          score: {\n            $gt: 5\n          }\n        }\n      }\n    });\n    const username = 'leaky_user';\n    const score = 10;\n    const user = new Parse.User();\n    user.setUsername(username);\n    user.setPassword('password');\n    user.set('score', score);\n    user.signUp().then(function () {\n      return get(Parse.serverURL + '/aggregate/_User', options);\n    }).then(function (resp) {\n      expect(resp.results.length).toBe(1);\n      const result = resp.results[0];\n\n      // verify server-side keys are not present...\n      expect(result._hashed_password).toBe(undefined);\n      expect(result._wperm).toBe(undefined);\n      expect(result._rperm).toBe(undefined);\n      expect(result._acl).toBe(undefined);\n      expect(result._created_at).toBe(undefined);\n      expect(result._updated_at).toBe(undefined);\n\n      // verify createdAt, updatedAt and others are present\n      expect(result.createdAt).not.toBe(undefined);\n      expect(result.updatedAt).not.toBe(undefined);\n      expect(result.objectId).not.toBe(undefined);\n      expect(result.username).toBe(username);\n      expect(result.score).toBe(score);\n      done();\n    }).catch(function (err) {\n      fail(err);\n    });\n  });","file":"ParseQuery.Aggregate.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $search","suites":["Parse.Query Full Text Search testing"],"line":23,"updatePoint":{"line":23,"column":29,"index":787},"code":"  it('fullTextSearch: $search', async () => {\n    await fullTextHelper();\n    const query = new Parse.Query('TestObject');\n    query.fullText('subject', 'coffee');\n    const results = await query.find();\n    expect(results.length).toBe(3);\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $search, sort","suites":["Parse.Query Full Text Search testing"],"line":30,"updatePoint":{"line":30,"column":35,"index":1039},"code":"  it('fullTextSearch: $search, sort', async () => {\n    await fullTextHelper();\n    const query = new Parse.Query('TestObject');\n    query.fullText('subject', 'coffee');\n    query.select('$score');\n    query.ascending('$score');\n    const results = await query.find();\n    expect(results.length).toBe(3);\n    expect(results[0].get('score'));\n    expect(results[1].get('score'));\n    expect(results[2].get('score'));\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fulltext descending by $score","suites":["Parse.Query Full Text Search testing"],"line":42,"updatePoint":{"line":42,"column":35,"index":1461},"code":"  it('fulltext descending by $score', async () => {\n    await fullTextHelper();\n    const query = new Parse.Query('TestObject');\n    query.fullText('subject', 'coffee');\n    query.descending('$score');\n    query.select('$score');\n    const [first, second, third] = await query.find();\n    expect(first).toBeDefined();\n    expect(second).toBeDefined();\n    expect(third).toBeDefined();\n    expect(first.get('score'));\n    expect(second.get('score'));\n    expect(third.get('score'));\n    expect(first.get('score') >= second.get('score')).toBeTrue();\n    expect(second.get('score') >= third.get('score')).toBeTrue();\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $language","suites":["Parse.Query Full Text Search testing"],"line":58,"updatePoint":{"line":58,"column":31,"index":2077},"code":"  it('fullTextSearch: $language', async () => {\n    await fullTextHelper();\n    const query = new Parse.Query('TestObject');\n    query.fullText('subject', 'leche', {\n      language: 'spanish'\n    });\n    const resp = await query.find();\n    expect(resp.length).toBe(2);\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $diacriticSensitive","suites":["Parse.Query Full Text Search testing"],"line":67,"updatePoint":{"line":67,"column":41,"index":2363},"code":"  it('fullTextSearch: $diacriticSensitive', async () => {\n    await fullTextHelper();\n    const query = new Parse.Query('TestObject');\n    query.fullText('subject', 'CAFÉ', {\n      diacriticSensitive: true\n    });\n    const resp = await query.find();\n    expect(resp.length).toBe(1);\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $search, invalid input","suites":["Parse.Query Full Text Search testing"],"line":76,"updatePoint":{"line":76,"column":44,"index":2656},"code":"  it('fullTextSearch: $search, invalid input', async () => {\n    await fullTextHelper();\n    const invalidQuery = async () => {\n      const where = {\n        subject: {\n          $text: {\n            $search: true\n          }\n        }\n      };\n      try {\n        await request({\n          method: 'POST',\n          url: 'http://localhost:8378/1/classes/TestObject',\n          body: {\n            where,\n            _method: 'GET'\n          },\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'test',\n            'Content-Type': 'application/json'\n          }\n        });\n      } catch (e) {\n        throw new Parse.Error(e.data.code, e.data.error);\n      }\n    };\n    await expectAsync(invalidQuery()).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_JSON, 'bad $text: $search, should be object'));\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $language, invalid input","suites":["Parse.Query Full Text Search testing"],"line":106,"updatePoint":{"line":106,"column":46,"index":3523},"code":"  it('fullTextSearch: $language, invalid input', async () => {\n    await fullTextHelper();\n    const query = new Parse.Query('TestObject');\n    query.fullText('subject', 'leche', {\n      language: true\n    });\n    await expectAsync(query.find()).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_JSON, 'bad $text: $language, should be string'));\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $caseSensitive, invalid input","suites":["Parse.Query Full Text Search testing"],"line":114,"updatePoint":{"line":114,"column":51,"index":3883},"code":"  it('fullTextSearch: $caseSensitive, invalid input', async () => {\n    await fullTextHelper();\n    const query = new Parse.Query('TestObject');\n    query.fullText('subject', 'leche', {\n      caseSensitive: 'string'\n    });\n    await expectAsync(query.find()).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_JSON, 'bad $text: $caseSensitive, should be boolean'));\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $diacriticSensitive, invalid input","suites":["Parse.Query Full Text Search testing"],"line":122,"updatePoint":{"line":122,"column":56,"index":4263},"code":"  it('fullTextSearch: $diacriticSensitive, invalid input', async () => {\n    await fullTextHelper();\n    const query = new Parse.Query('TestObject');\n    query.fullText('subject', 'leche', {\n      diacriticSensitive: 'string'\n    });\n    await expectAsync(query.find()).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_JSON, 'bad $text: $diacriticSensitive, should be boolean'));\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: does not create text index if compound index exist","suites":["Parse.Query Full Text Search testing"],"line":132,"updatePoint":{"line":132,"column":72,"index":4757},"code":"  it('fullTextSearch: does not create text index if compound index exist', async () => {\n    await fullTextHelper();\n    await databaseAdapter.dropAllIndexes('TestObject');\n    let indexes = await databaseAdapter.getIndexes('TestObject');\n    expect(indexes.length).toEqual(1);\n    await databaseAdapter.createIndex('TestObject', {\n      subject: 'text',\n      comment: 'text'\n    });\n    indexes = await databaseAdapter.getIndexes('TestObject');\n    const query = new Parse.Query('TestObject');\n    query.fullText('subject', 'coffee');\n    query.select('$score');\n    query.ascending('$score');\n    const results = await query.find();\n    expect(results.length).toBe(3);\n    expect(results[0].get('score'));\n    expect(results[1].get('score'));\n    expect(results[2].get('score'));\n    indexes = await databaseAdapter.getIndexes('TestObject');\n    expect(indexes.length).toEqual(2);\n    const schemas = await new Parse.Schema('TestObject').get();\n    expect(schemas.indexes._id_).toBeDefined();\n    expect(schemas.indexes._id_._id).toEqual(1);\n    expect(schemas.indexes.subject_text_comment_text).toBeDefined();\n    expect(schemas.indexes.subject_text_comment_text.subject).toEqual('text');\n    expect(schemas.indexes.subject_text_comment_text.comment).toEqual('text');\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: does not create text index if schema compound index exist","suites":["Parse.Query Full Text Search testing"],"line":160,"updatePoint":{"line":160,"column":79,"index":6042},"code":"  it('fullTextSearch: does not create text index if schema compound index exist', done => {\n    fullTextHelper().then(() => {\n      return databaseAdapter.dropAllIndexes('TestObject');\n    }).then(() => {\n      return databaseAdapter.getIndexes('TestObject');\n    }).then(indexes => {\n      expect(indexes.length).toEqual(1);\n      return request({\n        method: 'PUT',\n        url: 'http://localhost:8378/1/schemas/TestObject',\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'test',\n          'X-Parse-Master-Key': 'test',\n          'Content-Type': 'application/json'\n        },\n        body: {\n          indexes: {\n            text_test: {\n              subject: 'text',\n              comment: 'text'\n            }\n          }\n        }\n      });\n    }).then(() => {\n      return databaseAdapter.getIndexes('TestObject');\n    }).then(indexes => {\n      expect(indexes.length).toEqual(2);\n      const where = {\n        subject: {\n          $text: {\n            $search: {\n              $term: 'coffee'\n            }\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/TestObject',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'test',\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      expect(resp.data.results.length).toEqual(3);\n      return databaseAdapter.getIndexes('TestObject');\n    }).then(indexes => {\n      expect(indexes.length).toEqual(2);\n      request({\n        url: 'http://localhost:8378/1/schemas/TestObject',\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Master-Key': 'test',\n          'Content-Type': 'application/json'\n        }\n      }).then(response => {\n        const body = response.data;\n        expect(body.indexes._id_).toBeDefined();\n        expect(body.indexes._id_._id).toEqual(1);\n        expect(body.indexes.text_test).toBeDefined();\n        expect(body.indexes.text_test.subject).toEqual('text');\n        expect(body.indexes.text_test.comment).toEqual('text');\n        done();\n      });\n    }).catch(done.fail);\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $diacriticSensitive - false","suites":["Parse.Query Full Text Search testing"],"line":234,"updatePoint":{"line":234,"column":49,"index":8286},"code":"  it('fullTextSearch: $diacriticSensitive - false', async () => {\n    await fullTextHelper();\n    const query = new Parse.Query('TestObject');\n    query.fullText('subject', 'CAFÉ', {\n      diacriticSensitive: false\n    });\n    const resp = await query.find();\n    expect(resp.length).toBe(2);\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $caseSensitive","suites":["Parse.Query Full Text Search testing"],"line":243,"updatePoint":{"line":243,"column":36,"index":8572},"code":"  it('fullTextSearch: $caseSensitive', async () => {\n    await fullTextHelper();\n    const query = new Parse.Query('TestObject');\n    query.fullText('subject', 'Coffee', {\n      caseSensitive: true\n    });\n    const results = await query.find();\n    expect(results.length).toBe(1);\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $diacriticSensitive - false","suites":["Parse.Query Full Text Search testing"],"line":254,"updatePoint":{"line":254,"column":49,"index":8965},"code":"  it('fullTextSearch: $diacriticSensitive - false', done => {\n    fullTextHelper().then(() => {\n      const where = {\n        subject: {\n          $text: {\n            $search: {\n              $term: 'CAFÉ',\n              $diacriticSensitive: false\n            }\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/TestObject',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'test',\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      fail(`$diacriticSensitive - false should not supported: ${JSON.stringify(resp)}`);\n      done();\n    }).catch(err => {\n      expect(err.data.code).toEqual(Parse.Error.INVALID_JSON);\n      done();\n    });\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"fullTextSearch: $caseSensitive","suites":["Parse.Query Full Text Search testing"],"line":287,"updatePoint":{"line":287,"column":36,"index":9829},"code":"  it('fullTextSearch: $caseSensitive', done => {\n    fullTextHelper().then(() => {\n      const where = {\n        subject: {\n          $text: {\n            $search: {\n              $term: 'Coffee',\n              $caseSensitive: true\n            }\n          }\n        }\n      };\n      return request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/TestObject',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'test',\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(resp => {\n      fail(`$caseSensitive should not supported: ${JSON.stringify(resp)}`);\n      done();\n    }).catch(err => {\n      expect(err.data.code).toEqual(Parse.Error.INVALID_JSON);\n      done();\n    });\n  });","file":"ParseQuery.FullTextSearch.spec.js","skipped":false,"dir":"spec"},{"name":"basic query","suites":["Parse.Query testing"],"line":22,"updatePoint":{"line":22,"column":17,"index":560},"code":"  it('basic query', function (done) {\n    const baz = new TestObject({\n      foo: 'baz'\n    });\n    const qux = new TestObject({\n      foo: 'qux'\n    });\n    Parse.Object.saveAll([baz, qux]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'baz');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('foo'), 'baz');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"searching for null","suites":["Parse.Query testing"],"line":84,"updatePoint":{"line":84,"column":24,"index":2813},"code":"  it('searching for null', function (done) {\n    const baz = new TestObject({\n      foo: null\n    });\n    const qux = new TestObject({\n      foo: 'qux'\n    });\n    const qux2 = new TestObject({});\n    Parse.Object.saveAll([baz, qux, qux2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', null);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        qux.set('foo', null);\n        qux.save().then(function () {\n          query.find().then(function (results) {\n            equal(results.length, 3);\n            done();\n          });\n        });\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"searching for not null","suites":["Parse.Query testing"],"line":107,"updatePoint":{"line":107,"column":28,"index":3463},"code":"  it('searching for not null', function (done) {\n    const baz = new TestObject({\n      foo: null\n    });\n    const qux = new TestObject({\n      foo: 'qux'\n    });\n    const qux2 = new TestObject({});\n    Parse.Object.saveAll([baz, qux, qux2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.notEqualTo('foo', null);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        qux.set('foo', null);\n        qux.save().then(function () {\n          query.find().then(function (results) {\n            equal(results.length, 0);\n            done();\n          });\n        });\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"notEqualTo with Relation is working","suites":["Parse.Query testing"],"line":130,"updatePoint":{"line":130,"column":41,"index":4129},"code":"  it('notEqualTo with Relation is working', function (done) {\n    const user = new Parse.User();\n    user.setPassword('asdf');\n    user.setUsername('zxcv');\n    const user1 = new Parse.User();\n    user1.setPassword('asdf');\n    user1.setUsername('qwerty');\n    const user2 = new Parse.User();\n    user2.setPassword('asdf');\n    user2.setUsername('asdf');\n    const Cake = Parse.Object.extend('Cake');\n    const cake1 = new Cake();\n    const cake2 = new Cake();\n    const cake3 = new Cake();\n    user.signUp().then(function () {\n      return user1.signUp();\n    }).then(function () {\n      return user2.signUp();\n    }).then(function () {\n      const relLike1 = cake1.relation('liker');\n      relLike1.add([user, user1]);\n      const relDislike1 = cake1.relation('hater');\n      relDislike1.add(user2);\n      return cake1.save();\n    }).then(function () {\n      const rellike2 = cake2.relation('liker');\n      rellike2.add([user, user1]);\n      const relDislike2 = cake2.relation('hater');\n      relDislike2.add(user2);\n      const relSomething = cake2.relation('something');\n      relSomething.add(user);\n      return cake2.save();\n    }).then(function () {\n      const rellike3 = cake3.relation('liker');\n      rellike3.add(user);\n      const relDislike3 = cake3.relation('hater');\n      relDislike3.add([user1, user2]);\n      return cake3.save();\n    }).then(function () {\n      const query = new Parse.Query(Cake);\n      // User2 likes nothing so we should receive 0\n      query.equalTo('liker', user2);\n      return query.find().then(function (results) {\n        equal(results.length, 0);\n      });\n    }).then(function () {\n      const query = new Parse.Query(Cake);\n      // User1 likes two of three cakes\n      query.equalTo('liker', user1);\n      return query.find().then(function (results) {\n        // It should return 2 -> cake 1 and cake 2\n        equal(results.length, 2);\n      });\n    }).then(function () {\n      const query = new Parse.Query(Cake);\n      // We want to know which cake the user1 is not appreciating -> cake3\n      query.notEqualTo('liker', user1);\n      return query.find().then(function (results) {\n        // Should return 1 -> the cake 3\n        equal(results.length, 1);\n      });\n    }).then(function () {\n      const query = new Parse.Query(Cake);\n      // User2 is a hater of everything so we should receive 0\n      query.notEqualTo('hater', user2);\n      return query.find().then(function (results) {\n        equal(results.length, 0);\n      });\n    }).then(function () {\n      const query = new Parse.Query(Cake);\n      // Only cake3 is liked by user\n      query.notContainedIn('liker', [user1]);\n      return query.find().then(function (results) {\n        equal(results.length, 1);\n      });\n    }).then(function () {\n      const query = new Parse.Query(Cake);\n      // All the users\n      query.containedIn('liker', [user, user1, user2]);\n      // Exclude user 1\n      query.notEqualTo('liker', user1);\n      // Only cake3 is liked only by user1\n      return query.find().then(function (results) {\n        equal(results.length, 1);\n        const cake = results[0];\n        expect(cake.id).toBe(cake3.id);\n      });\n    }).then(function () {\n      const query = new Parse.Query(Cake);\n      // Exclude user1\n      query.notEqualTo('liker', user1);\n      // Only cake1\n      query.equalTo('objectId', cake1.id);\n      // user1 likes cake1 so this should return no results\n      return query.find().then(function (results) {\n        equal(results.length, 0);\n      });\n    }).then(function () {\n      const query = new Parse.Query(Cake);\n      query.notEqualTo('hater', user2);\n      query.notEqualTo('liker', user2);\n      // user2 doesn't like any cake so this should be 0\n      return query.find().then(function (results) {\n        equal(results.length, 0);\n      });\n    }).then(function () {\n      const query = new Parse.Query(Cake);\n      query.equalTo('hater', user);\n      query.equalTo('liker', user);\n      // user doesn't hate any cake so this should be 0\n      return query.find().then(function (results) {\n        equal(results.length, 0);\n      });\n    }).then(function () {\n      const query = new Parse.Query(Cake);\n      query.equalTo('hater', null);\n      query.equalTo('liker', null);\n      // user doesn't hate any cake so this should be 0\n      return query.find().then(function (results) {\n        equal(results.length, 0);\n      });\n    }).then(function () {\n      const query = new Parse.Query(Cake);\n      query.equalTo('something', null);\n      // user doesn't hate any cake so this should be 0\n      return query.find().then(function (results) {\n        equal(results.length, 0);\n      });\n    }).then(function () {\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query notContainedIn on empty array","suites":["Parse.Query testing"],"line":265,"updatePoint":{"line":265,"column":41,"index":8894},"code":"  it('query notContainedIn on empty array', async () => {\n    const object = new TestObject();\n    object.set('value', 100);\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    query.notContainedIn('value', []);\n    const results = await query.find();\n    equal(results.length, 1);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query containedIn on empty array","suites":["Parse.Query testing"],"line":274,"updatePoint":{"line":274,"column":38,"index":9203},"code":"  it('query containedIn on empty array', async () => {\n    const object = new TestObject();\n    object.set('value', 100);\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    query.containedIn('value', []);\n    const results = await query.find();\n    equal(results.length, 0);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query without limit respects default limit","suites":["Parse.Query testing"],"line":283,"updatePoint":{"line":283,"column":48,"index":9519},"code":"  it('query without limit respects default limit', async () => {\n    await reconfigureServer({\n      defaultLimit: 1\n    });\n    const obj1 = new TestObject({\n      foo: 'baz'\n    });\n    const obj2 = new TestObject({\n      foo: 'qux'\n    });\n    await Parse.Object.saveAll([obj1, obj2]);\n    const query = new Parse.Query(TestObject);\n    const result = await query.find();\n    expect(result.length).toBe(1);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query with limit","suites":["Parse.Query testing"],"line":298,"updatePoint":{"line":298,"column":22,"index":9909},"code":"  it('query with limit', async () => {\n    const obj1 = new TestObject({\n      foo: 'baz'\n    });\n    const obj2 = new TestObject({\n      foo: 'qux'\n    });\n    await Parse.Object.saveAll([obj1, obj2]);\n    const query = new Parse.Query(TestObject);\n    query.limit(1);\n    const result = await query.find();\n    expect(result.length).toBe(1);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query with limit overrides default limit","suites":["Parse.Query testing"],"line":311,"updatePoint":{"line":311,"column":46,"index":10283},"code":"  it('query with limit overrides default limit', async () => {\n    await reconfigureServer({\n      defaultLimit: 2\n    });\n    const obj1 = new TestObject({\n      foo: 'baz'\n    });\n    const obj2 = new TestObject({\n      foo: 'qux'\n    });\n    await Parse.Object.saveAll([obj1, obj2]);\n    const query = new Parse.Query(TestObject);\n    query.limit(1);\n    const result = await query.find();\n    expect(result.length).toBe(1);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query with limit equal to maxlimit","suites":["Parse.Query testing"],"line":327,"updatePoint":{"line":327,"column":40,"index":10711},"code":"  it('query with limit equal to maxlimit', async () => {\n    await reconfigureServer({\n      maxLimit: 1\n    });\n    const obj1 = new TestObject({\n      foo: 'baz'\n    });\n    const obj2 = new TestObject({\n      foo: 'qux'\n    });\n    await Parse.Object.saveAll([obj1, obj2]);\n    const query = new Parse.Query(TestObject);\n    query.limit(1);\n    const result = await query.find();\n    expect(result.length).toBe(1);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query with limit exceeding maxlimit","suites":["Parse.Query testing"],"line":343,"updatePoint":{"line":343,"column":41,"index":11136},"code":"  it('query with limit exceeding maxlimit', async () => {\n    await reconfigureServer({\n      maxLimit: 1\n    });\n    const obj1 = new TestObject({\n      foo: 'baz'\n    });\n    const obj2 = new TestObject({\n      foo: 'qux'\n    });\n    await Parse.Object.saveAll([obj1, obj2]);\n    const query = new Parse.Query(TestObject);\n    query.limit(2);\n    const result = await query.find();\n    expect(result.length).toBe(1);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containedIn object array queries","suites":["Parse.Query testing"],"line":359,"updatePoint":{"line":359,"column":38,"index":11558},"code":"  it('containedIn object array queries', function (done) {\n    const messageList = [];\n    for (let i = 0; i < 4; ++i) {\n      const message = new TestObject({});\n      if (i > 0) {\n        message.set('prior', messageList[i - 1]);\n      }\n      messageList.push(message);\n    }\n    Parse.Object.saveAll(messageList).then(function () {\n      equal(messageList.length, 4);\n      const inList = [];\n      inList.push(messageList[0]);\n      inList.push(messageList[2]);\n      const query = new Parse.Query(TestObject);\n      query.containedIn('prior', inList);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      }, function (e) {\n        jfail(e);\n        done();\n      });\n    }, e => {\n      jfail(e);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containedIn null array","suites":["Parse.Query testing"],"line":387,"updatePoint":{"line":387,"column":28,"index":12327},"code":"  it('containedIn null array', done => {\n    const emails = ['contact@xyz.com', 'contact@zyx.com', null];\n    const user = new Parse.User();\n    user.setUsername(emails[0]);\n    user.setPassword('asdf');\n    user.signUp().then(() => {\n      const query = new Parse.Query(Parse.User);\n      query.containedIn('username', emails);\n      return query.find({\n        useMasterKey: true\n      });\n    }).then(results => {\n      equal(results.length, 1);\n      done();\n    }, done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"nested equalTo string with single quote","suites":["Parse.Query testing"],"line":403,"updatePoint":{"line":403,"column":45,"index":12832},"code":"  it('nested equalTo string with single quote', async () => {\n    const obj = new TestObject({\n      nested: {\n        foo: \"single'quote\"\n      }\n    });\n    await obj.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('nested.foo', \"single'quote\");\n    const result = await query.get(obj.id);\n    equal(result.get('nested').foo, \"single'quote\");\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"nested containedIn string with single quote","suites":["Parse.Query testing"],"line":415,"updatePoint":{"line":415,"column":49,"index":13212},"code":"  it('nested containedIn string with single quote', async () => {\n    const obj = new TestObject({\n      nested: {\n        foo: [\"single'quote\"]\n      }\n    });\n    await obj.save();\n    const query = new Parse.Query(TestObject);\n    query.containedIn('nested.foo', [\"single'quote\"]);\n    const result = await query.get(obj.id);\n    equal(result.get('nested').foo[0], \"single'quote\");\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"nested containedIn string","suites":["Parse.Query testing"],"line":427,"updatePoint":{"line":427,"column":31,"index":13585},"code":"  it('nested containedIn string', done => {\n    const sender1 = {\n      group: ['A', 'B']\n    };\n    const sender2 = {\n      group: ['A', 'C']\n    };\n    const sender3 = {\n      group: ['B', 'C']\n    };\n    const obj1 = new TestObject({\n      sender: sender1\n    });\n    const obj2 = new TestObject({\n      sender: sender2\n    });\n    const obj3 = new TestObject({\n      sender: sender3\n    });\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const query = new Parse.Query(TestObject);\n      query.containedIn('sender.group', ['A']);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 2);\n      done();\n    }, done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"nested containedIn number","suites":["Parse.Query testing"],"line":455,"updatePoint":{"line":455,"column":31,"index":14258},"code":"  it('nested containedIn number', done => {\n    const sender1 = {\n      group: [1, 2]\n    };\n    const sender2 = {\n      group: [1, 3]\n    };\n    const sender3 = {\n      group: [2, 3]\n    };\n    const obj1 = new TestObject({\n      sender: sender1\n    });\n    const obj2 = new TestObject({\n      sender: sender2\n    });\n    const obj3 = new TestObject({\n      sender: sender3\n    });\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const query = new Parse.Query(TestObject);\n      query.containedIn('sender.group', [1]);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 2);\n      done();\n    }, done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containsAll number array queries","suites":["Parse.Query testing"],"line":483,"updatePoint":{"line":483,"column":38,"index":14924},"code":"  it('containsAll number array queries', function (done) {\n    const NumberSet = Parse.Object.extend({\n      className: 'NumberSet'\n    });\n    const objectsList = [];\n    objectsList.push(new NumberSet({\n      numbers: [1, 2, 3, 4, 5]\n    }));\n    objectsList.push(new NumberSet({\n      numbers: [1, 3, 4, 5]\n    }));\n    Parse.Object.saveAll(objectsList).then(function () {\n      const query = new Parse.Query(NumberSet);\n      query.containsAll('numbers', [1, 2, 3]);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      }, function (err) {\n        jfail(err);\n        done();\n      });\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containsAll string array queries","suites":["Parse.Query testing"],"line":509,"updatePoint":{"line":509,"column":38,"index":15630},"code":"  it('containsAll string array queries', function (done) {\n    const StringSet = Parse.Object.extend({\n      className: 'StringSet'\n    });\n    const objectsList = [];\n    objectsList.push(new StringSet({\n      strings: ['a', 'b', 'c', 'd', 'e']\n    }));\n    objectsList.push(new StringSet({\n      strings: ['a', 'c', 'd', 'e']\n    }));\n    Parse.Object.saveAll(objectsList).then(function () {\n      const query = new Parse.Query(StringSet);\n      query.containsAll('strings', ['a', 'b', 'c']);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containsAll date array queries","suites":["Parse.Query testing"],"line":532,"updatePoint":{"line":532,"column":36,"index":16296},"code":"  it('containsAll date array queries', function (done) {\n    const DateSet = Parse.Object.extend({\n      className: 'DateSet'\n    });\n    function parseDate(iso8601) {\n      const regexp = new RegExp('^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})' + 'T' + '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})' + '(.([0-9]+))?' + 'Z$');\n      const match = regexp.exec(iso8601);\n      if (!match) {\n        return null;\n      }\n      const year = match[1] || 0;\n      const month = (match[2] || 1) - 1;\n      const day = match[3] || 0;\n      const hour = match[4] || 0;\n      const minute = match[5] || 0;\n      const second = match[6] || 0;\n      const milli = match[8] || 0;\n      return new Date(Date.UTC(year, month, day, hour, minute, second, milli));\n    }\n    const makeDates = function (stringArray) {\n      return stringArray.map(function (dateStr) {\n        return parseDate(dateStr + 'T00:00:00Z');\n      });\n    };\n    const objectsList = [];\n    objectsList.push(new DateSet({\n      dates: makeDates(['2013-02-01', '2013-02-02', '2013-02-03', '2013-02-04'])\n    }));\n    objectsList.push(new DateSet({\n      dates: makeDates(['2013-02-01', '2013-02-03', '2013-02-04'])\n    }));\n    Parse.Object.saveAll(objectsList).then(function () {\n      const query = new Parse.Query(DateSet);\n      query.containsAll('dates', makeDates(['2013-02-01', '2013-02-02', '2013-02-03']));\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      }, function (e) {\n        jfail(e);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containsAll object array queries","suites":["Parse.Query testing"],"line":575,"updatePoint":{"line":575,"column":38,"index":17838},"code":"  it('containsAll object array queries', function (done) {\n    const MessageSet = Parse.Object.extend({\n      className: 'MessageSet'\n    });\n    const messageList = [];\n    for (let i = 0; i < 4; ++i) {\n      messageList.push(new TestObject({\n        i: i\n      }));\n    }\n    Parse.Object.saveAll(messageList).then(function () {\n      equal(messageList.length, 4);\n      const messageSetList = [];\n      messageSetList.push(new MessageSet({\n        messages: messageList\n      }));\n      const someList = [];\n      someList.push(messageList[0]);\n      someList.push(messageList[1]);\n      someList.push(messageList[3]);\n      messageSetList.push(new MessageSet({\n        messages: someList\n      }));\n      Parse.Object.saveAll(messageSetList).then(function () {\n        const inList = [];\n        inList.push(messageList[0]);\n        inList.push(messageList[2]);\n        const query = new Parse.Query(MessageSet);\n        query.containsAll('messages', inList);\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          done();\n        });\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containsAllStartingWith should match all strings that starts with string","suites":["Parse.Query testing"],"line":611,"updatePoint":{"line":611,"column":78,"index":18979},"code":"  it('containsAllStartingWith should match all strings that starts with string', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n    const object2 = new Parse.Object('Object');\n    object2.set('strings', ['the', 'brown', 'fox', 'jumps']);\n    const object3 = new Parse.Object('Object');\n    object3.set('strings', ['over', 'the', 'lazy', 'dog']);\n    const objectList = [object, object2, object3];\n    Parse.Object.saveAll(objectList).then(results => {\n      equal(objectList.length, results.length);\n      return request({\n        url: Parse.serverURL + '/classes/Object',\n        qs: {\n          where: JSON.stringify({\n            strings: {\n              $all: [{\n                $regex: '^\\\\Qthe\\\\E'\n              }, {\n                $regex: '^\\\\Qfox\\\\E'\n              }, {\n                $regex: '^\\\\Qlazy\\\\E'\n              }]\n            }\n          })\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      }).then(function (response) {\n        const results = response.data;\n        equal(results.results.length, 1);\n        arrayContains(results.results, object);\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [{\n                  $regex: '^\\\\Qthe\\\\E'\n                }, {\n                  $regex: '^\\\\Qlazy\\\\E'\n                }]\n              }\n            })\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json'\n          }\n        });\n      }).then(function (response) {\n        const results = response.data;\n        equal(results.results.length, 2);\n        arrayContains(results.results, object);\n        arrayContains(results.results, object3);\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [{\n                  $regex: '^\\\\Qhe\\\\E'\n                }, {\n                  $regex: '^\\\\Qlazy\\\\E'\n                }]\n              }\n            })\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json'\n          }\n        });\n      }).then(function (response) {\n        const results = response.data;\n        equal(results.results.length, 0);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containsAllStartingWith values must be all of type starting with regex","suites":["Parse.Query testing"],"line":695,"updatePoint":{"line":695,"column":76,"index":21755},"code":"  it('containsAllStartingWith values must be all of type starting with regex', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n    object.save().then(() => {\n      equal(object.isNew(), false);\n      return request({\n        url: Parse.serverURL + '/classes/Object',\n        qs: {\n          where: JSON.stringify({\n            strings: {\n              $all: [{\n                $regex: '^\\\\Qthe\\\\E'\n              }, {\n                $regex: '^\\\\Qlazy\\\\E'\n              }, {\n                $regex: '^\\\\Qfox\\\\E'\n              }, {\n                $unknown: /unknown/\n              }]\n            }\n          })\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(done.fail, function () {\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containsAllStartingWith empty array values should return empty results","suites":["Parse.Query testing"],"line":727,"updatePoint":{"line":727,"column":76,"index":22717},"code":"  it('containsAllStartingWith empty array values should return empty results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n    object.save().then(() => {\n      equal(object.isNew(), false);\n      return request({\n        url: Parse.serverURL + '/classes/Object',\n        qs: {\n          where: JSON.stringify({\n            strings: {\n              $all: []\n            }\n          })\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(function (response) {\n      const results = response.data;\n      equal(results.results.length, 0);\n      done();\n    }, function () {});\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containsAllStartingWith single empty value returns empty results","suites":["Parse.Query testing"],"line":753,"updatePoint":{"line":753,"column":70,"index":23541},"code":"  it('containsAllStartingWith single empty value returns empty results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n    object.save().then(() => {\n      equal(object.isNew(), false);\n      return request({\n        url: Parse.serverURL + '/classes/Object',\n        qs: {\n          where: JSON.stringify({\n            strings: {\n              $all: [{}]\n            }\n          })\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(function (response) {\n      const results = response.data;\n      equal(results.results.length, 0);\n      done();\n    }, function () {});\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containsAllStartingWith single regex value should return corresponding matching results","suites":["Parse.Query testing"],"line":779,"updatePoint":{"line":779,"column":93,"index":24390},"code":"  it('containsAllStartingWith single regex value should return corresponding matching results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n    const object2 = new Parse.Object('Object');\n    object2.set('strings', ['the', 'brown', 'fox', 'jumps']);\n    const object3 = new Parse.Object('Object');\n    object3.set('strings', ['over', 'the', 'lazy', 'dog']);\n    const objectList = [object, object2, object3];\n    Parse.Object.saveAll(objectList).then(results => {\n      equal(objectList.length, results.length);\n      return request({\n        url: Parse.serverURL + '/classes/Object',\n        qs: {\n          where: JSON.stringify({\n            strings: {\n              $all: [{\n                $regex: '^\\\\Qlazy\\\\E'\n              }]\n            }\n          })\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(function (response) {\n      const results = response.data;\n      equal(results.results.length, 2);\n      done();\n    }, function () {});\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containsAllStartingWith single invalid regex returns empty results","suites":["Parse.Query testing"],"line":812,"updatePoint":{"line":812,"column":72,"index":25576},"code":"  it('containsAllStartingWith single invalid regex returns empty results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n    object.save().then(() => {\n      equal(object.isNew(), false);\n      return request({\n        url: Parse.serverURL + '/classes/Object',\n        qs: {\n          where: JSON.stringify({\n            strings: {\n              $all: [{\n                $unknown: '^\\\\Qlazy\\\\E'\n              }]\n            }\n          })\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey\n        }\n      });\n    }).then(function (response) {\n      const results = response.data;\n      equal(results.results.length, 0);\n      done();\n    }, function () {});\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containedBy pointer array","suites":["Parse.Query testing"],"line":839,"updatePoint":{"line":839,"column":31,"index":26372},"code":"  it('containedBy pointer array', done => {\n    const objects = Array.from(Array(10).keys()).map(idx => {\n      const obj = new Parse.Object('Object');\n      obj.set('key', idx);\n      return obj;\n    });\n    const parent = new Parse.Object('Parent');\n    const parent2 = new Parse.Object('Parent');\n    const parent3 = new Parse.Object('Parent');\n    Parse.Object.saveAll(objects).then(() => {\n      // [0, 1, 2]\n      parent.set('objects', objects.slice(0, 3));\n      const shift = objects.shift();\n      // [2, 0]\n      parent2.set('objects', [objects[1], shift]);\n\n      // [1, 2, 3, 4]\n      parent3.set('objects', objects.slice(1, 4));\n      return Parse.Object.saveAll([parent, parent2, parent3]);\n    }).then(() => {\n      // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n      const pointers = objects.map(object => object.toPointer());\n\n      // Return all Parent where all parent.objects are contained in objects\n      return request({\n        url: Parse.serverURL + '/classes/Parent',\n        qs: {\n          where: JSON.stringify({\n            objects: {\n              $containedBy: pointers\n            }\n          })\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(response => {\n      const results = response.data;\n      expect(results.results[0].objectId).not.toBeUndefined();\n      expect(results.results[0].objectId).toBe(parent3.id);\n      expect(results.results.length).toBe(1);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containedBy number array","suites":["Parse.Query testing"],"line":886,"updatePoint":{"line":886,"column":30,"index":27954},"code":"  it('containedBy number array', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          numbers: {\n            $containedBy: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n          }\n        })\n      }\n    });\n    const obj1 = new TestObject({\n      numbers: [0, 1, 2]\n    });\n    const obj2 = new TestObject({\n      numbers: [2, 0]\n    });\n    const obj3 = new TestObject({\n      numbers: [1, 2, 3, 4]\n    });\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      return request(Object.assign({\n        url: Parse.serverURL + '/classes/TestObject'\n      }, options));\n    }).then(response => {\n      const results = response.data;\n      expect(results.results[0].objectId).not.toBeUndefined();\n      expect(results.results[0].objectId).toBe(obj3.id);\n      expect(results.results.length).toBe(1);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containedBy empty array","suites":["Parse.Query testing"],"line":917,"updatePoint":{"line":917,"column":29,"index":28838},"code":"  it('containedBy empty array', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          numbers: {\n            $containedBy: []\n          }\n        })\n      }\n    });\n    const obj1 = new TestObject({\n      numbers: [0, 1, 2]\n    });\n    const obj2 = new TestObject({\n      numbers: [2, 0]\n    });\n    const obj3 = new TestObject({\n      numbers: [1, 2, 3, 4]\n    });\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      return request(Object.assign({\n        url: Parse.serverURL + '/classes/TestObject'\n      }, options));\n    }).then(response => {\n      const results = response.data;\n      expect(results.results.length).toBe(0);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containedBy invalid query","suites":["Parse.Query testing"],"line":946,"updatePoint":{"line":946,"column":31,"index":29579},"code":"  it('containedBy invalid query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          objects: {\n            $containedBy: 1234\n          }\n        })\n      }\n    });\n    const obj = new TestObject();\n    obj.save().then(() => {\n      return request(Object.assign({\n        url: Parse.serverURL + '/classes/TestObject'\n      }, options));\n    }).then(done.fail).catch(response => {\n      equal(response.data.code, Parse.Error.INVALID_JSON);\n      equal(response.data.error, 'bad $containedBy: should be an array');\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"equalTo queries","suites":["Parse.Query testing"],"line":967,"updatePoint":{"line":967,"column":21,"index":30182},"code":"  it('equalTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('number', 3);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"equalTo undefined","suites":["Parse.Query testing"],"line":982,"updatePoint":{"line":982,"column":23,"index":30635},"code":"  it('equalTo undefined', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('number', undefined);\n      query.find().then(function (results) {\n        equal(results.length, 0);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"lessThan queries","suites":["Parse.Query testing"],"line":997,"updatePoint":{"line":997,"column":22,"index":31095},"code":"  it('lessThan queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThan('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 7);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"lessThanOrEqualTo queries","suites":["Parse.Query testing"],"line":1012,"updatePoint":{"line":1012,"column":31,"index":31557},"code":"  it('lessThanOrEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThanOrEqualTo('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 8);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"lessThan zero queries","suites":["Parse.Query testing"],"line":1027,"updatePoint":{"line":1027,"column":27,"index":32024},"code":"  it('lessThan zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers).then(() => {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThan('number', 0);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 3);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"lessThanOrEqualTo zero queries","suites":["Parse.Query testing"],"line":1044,"updatePoint":{"line":1044,"column":36,"index":32518},"code":"  it('lessThanOrEqualTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers).then(() => {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThanOrEqualTo('number', 0);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 4);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"greaterThan queries","suites":["Parse.Query testing"],"line":1061,"updatePoint":{"line":1061,"column":25,"index":33010},"code":"  it('greaterThan queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.greaterThan('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"greaterThanOrEqualTo queries","suites":["Parse.Query testing"],"line":1076,"updatePoint":{"line":1076,"column":34,"index":33478},"code":"  it('greaterThanOrEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.greaterThanOrEqualTo('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"greaterThan zero queries","suites":["Parse.Query testing"],"line":1091,"updatePoint":{"line":1091,"column":30,"index":33951},"code":"  it('greaterThan zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers).then(() => {\n      const query = new Parse.Query(BoxedNumber);\n      query.greaterThan('number', 0);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 1);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"greaterThanOrEqualTo zero queries","suites":["Parse.Query testing"],"line":1108,"updatePoint":{"line":1108,"column":39,"index":34451},"code":"  it('greaterThanOrEqualTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers).then(() => {\n      const query = new Parse.Query(BoxedNumber);\n      query.greaterThanOrEqualTo('number', 0);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 2);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"lessThanOrEqualTo greaterThanOrEqualTo queries","suites":["Parse.Query testing"],"line":1125,"updatePoint":{"line":1125,"column":52,"index":34973},"code":"  it('lessThanOrEqualTo greaterThanOrEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThanOrEqualTo('number', 7);\n      query.greaterThanOrEqualTo('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"lessThan greaterThan queries","suites":["Parse.Query testing"],"line":1141,"updatePoint":{"line":1141,"column":34,"index":35494},"code":"  it('lessThan greaterThan queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThan('number', 9);\n      query.greaterThan('number', 3);\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"notEqualTo queries","suites":["Parse.Query testing"],"line":1157,"updatePoint":{"line":1157,"column":24,"index":35987},"code":"  it('notEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.notEqualTo('number', 5);\n      query.find().then(function (results) {\n        equal(results.length, 9);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"notEqualTo zero queries","suites":["Parse.Query testing"],"line":1172,"updatePoint":{"line":1172,"column":29,"index":36449},"code":"  it('notEqualTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers).then(() => {\n      const query = new Parse.Query(BoxedNumber);\n      query.notEqualTo('number', 0);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 4);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"equalTo zero queries","suites":["Parse.Query testing"],"line":1189,"updatePoint":{"line":1189,"column":26,"index":36935},"code":"  it('equalTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers).then(() => {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('number', 0);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 1);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"number equalTo boolean queries","suites":["Parse.Query testing"],"line":1206,"updatePoint":{"line":1206,"column":36,"index":37428},"code":"  it('number equalTo boolean queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers).then(() => {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('number', false);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 0);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"equalTo false queries","suites":["Parse.Query testing"],"line":1223,"updatePoint":{"line":1223,"column":27,"index":37916},"code":"  it('equalTo false queries', done => {\n    const obj1 = new TestObject({\n      field: false\n    });\n    const obj2 = new TestObject({\n      field: true\n    });\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('field', false);\n      return query.find();\n    }).then(results => {\n      equal(results.length, 1);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"where $eq false queries (rest)","suites":["Parse.Query testing"],"line":1239,"updatePoint":{"line":1239,"column":36,"index":38336},"code":"  it('where $eq false queries (rest)', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          field: {\n            $eq: false\n          }\n        })\n      }\n    });\n    const obj1 = new TestObject({\n      field: false\n    });\n    const obj2 = new TestObject({\n      field: true\n    });\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      request(Object.assign({\n        url: Parse.serverURL + '/classes/TestObject'\n      }, options)).then(resp => {\n        equal(resp.data.results.length, 1);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"where $eq null queries (rest)","suites":["Parse.Query testing"],"line":1264,"updatePoint":{"line":1264,"column":35,"index":38941},"code":"  it('where $eq null queries (rest)', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          field: {\n            $eq: null\n          }\n        })\n      }\n    });\n    const obj1 = new TestObject({\n      field: false\n    });\n    const obj2 = new TestObject({\n      field: null\n    });\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      return request(Object.assign({\n        url: Parse.serverURL + '/classes/TestObject'\n      }, options)).then(resp => {\n        equal(resp.data.results.length, 1);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containedIn queries","suites":["Parse.Query testing"],"line":1289,"updatePoint":{"line":1289,"column":25,"index":39542},"code":"  it('containedIn queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.containedIn('number', [3, 5, 7, 9, 11]);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containedIn false queries","suites":["Parse.Query testing"],"line":1304,"updatePoint":{"line":1304,"column":31,"index":40022},"code":"  it('containedIn false queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers).then(() => {\n      const query = new Parse.Query(BoxedNumber);\n      query.containedIn('number', false);\n      return query.find();\n    }).then(done.fail).catch(error => {\n      equal(error.code, Parse.Error.INVALID_JSON);\n      equal(error.message, 'bad $in value');\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"notContainedIn false queries","suites":["Parse.Query testing"],"line":1322,"updatePoint":{"line":1322,"column":34,"index":40600},"code":"  it('notContainedIn false queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers).then(() => {\n      const query = new Parse.Query(BoxedNumber);\n      query.notContainedIn('number', false);\n      return query.find();\n    }).then(done.fail).catch(error => {\n      equal(error.code, Parse.Error.INVALID_JSON);\n      equal(error.message, 'bad $nin value');\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"notContainedIn queries","suites":["Parse.Query testing"],"line":1340,"updatePoint":{"line":1340,"column":28,"index":41176},"code":"  it('notContainedIn queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.notContainedIn('number', [3, 5, 7, 9, 11]);\n      query.find().then(function (results) {\n        equal(results.length, 6);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"objectId containedIn queries","suites":["Parse.Query testing"],"line":1355,"updatePoint":{"line":1355,"column":34,"index":41662},"code":"  it('objectId containedIn queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function (list) {\n      const query = new Parse.Query(BoxedNumber);\n      query.containedIn('objectId', [list[2].id, list[3].id, list[0].id, 'NONSENSE']);\n      query.ascending('number');\n      query.find().then(function (results) {\n        if (results.length != 3) {\n          fail('expected 3 results');\n        } else {\n          equal(results[0].get('number'), 0);\n          equal(results[1].get('number'), 2);\n          equal(results[2].get('number'), 3);\n        }\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"objectId equalTo queries","suites":["Parse.Query testing"],"line":1377,"updatePoint":{"line":1377,"column":30,"index":42416},"code":"  it('objectId equalTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function (list) {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('objectId', list[4].id);\n      query.find().then(function (results) {\n        if (results.length != 1) {\n          fail('expected 1 result');\n          done();\n        } else {\n          equal(results[0].get('number'), 4);\n        }\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"find no elements","suites":["Parse.Query testing"],"line":1397,"updatePoint":{"line":1397,"column":22,"index":43012},"code":"  it('find no elements', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('number', 17);\n      query.find().then(function (results) {\n        equal(results.length, 0);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"find with error","suites":["Parse.Query testing"],"line":1412,"updatePoint":{"line":1412,"column":21,"index":43464},"code":"  it('find with error', function (done) {\n    const query = new Parse.Query(BoxedNumber);\n    query.equalTo('$foo', 'bar');\n    query.find().then(done.fail).catch(error => expect(error.code).toBe(Parse.Error.INVALID_KEY_NAME)).then(done);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"get","suites":["Parse.Query testing"],"line":1417,"updatePoint":{"line":1417,"column":9,"index":43697},"code":"  it('get', function (done) {\n    Parse.Object.saveAll([new TestObject({\n      foo: 'bar'\n    })]).then(function (items) {\n      ok(items[0]);\n      const objectId = items[0].id;\n      const query = new Parse.Query(TestObject);\n      query.get(objectId).then(function (result) {\n        ok(result);\n        equal(result.id, objectId);\n        equal(result.get('foo'), 'bar');\n        ok(result.createdAt instanceof Date);\n        ok(result.updatedAt instanceof Date);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"get undefined","suites":["Parse.Query testing"],"line":1434,"updatePoint":{"line":1434,"column":19,"index":44215},"code":"  it('get undefined', function (done) {\n    Parse.Object.saveAll([new TestObject({\n      foo: 'bar'\n    })]).then(function (items) {\n      ok(items[0]);\n      const query = new Parse.Query(TestObject);\n      query.get(undefined).then(fail, () => done());\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"get error","suites":["Parse.Query testing"],"line":1443,"updatePoint":{"line":1443,"column":15,"index":44480},"code":"  it('get error', function (done) {\n    Parse.Object.saveAll([new TestObject({\n      foo: 'bar'\n    })]).then(function (items) {\n      ok(items[0]);\n      const query = new Parse.Query(TestObject);\n      query.get('InvalidObjectID').then(function () {\n        ok(false, 'The get should have failed.');\n        done();\n      }, function (error) {\n        equal(error.code, Parse.Error.OBJECT_NOT_FOUND);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"first","suites":["Parse.Query testing"],"line":1458,"updatePoint":{"line":1458,"column":11,"index":44919},"code":"  it('first', function (done) {\n    Parse.Object.saveAll([new TestObject({\n      foo: 'bar'\n    })]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'bar');\n      query.first().then(function (result) {\n        equal(result.get('foo'), 'bar');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"first no result","suites":["Parse.Query testing"],"line":1470,"updatePoint":{"line":1470,"column":21,"index":45259},"code":"  it('first no result', function (done) {\n    Parse.Object.saveAll([new TestObject({\n      foo: 'bar'\n    })]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'baz');\n      query.first().then(function (result) {\n        equal(result, undefined);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"first with two results","suites":["Parse.Query testing"],"line":1482,"updatePoint":{"line":1482,"column":28,"index":45599},"code":"  it('first with two results', function (done) {\n    Parse.Object.saveAll([new TestObject({\n      foo: 'bar'\n    }), new TestObject({\n      foo: 'bar'\n    })]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'bar');\n      query.first().then(function (result) {\n        equal(result.get('foo'), 'bar');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"first with error","suites":["Parse.Query testing"],"line":1496,"updatePoint":{"line":1496,"column":22,"index":45982},"code":"  it('first with error', function (done) {\n    const query = new Parse.Query(BoxedNumber);\n    query.equalTo('$foo', 'bar');\n    query.first().then(done.fail).catch(e => expect(e.code).toBe(Parse.Error.INVALID_KEY_NAME)).then(done);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"notEqualTo object","suites":["Parse.Query testing"],"line":1504,"updatePoint":{"line":1504,"column":23,"index":46297},"code":"  it('notEqualTo object', function (done) {\n    const item1 = new TestObject();\n    const item2 = new TestObject();\n    const container1 = new Container({\n      item: item1\n    });\n    const container2 = new Container({\n      item: item2\n    });\n    Parse.Object.saveAll([item1, item2, container1, container2]).then(function () {\n      const query = new Parse.Query(Container);\n      query.notEqualTo('item', item1);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"skip","suites":["Parse.Query testing"],"line":1522,"updatePoint":{"line":1522,"column":10,"index":46820},"code":"  it('skip', function (done) {\n    Parse.Object.saveAll([new TestObject(), new TestObject()]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.skip(1);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        query.skip(3);\n        query.find().then(function (results) {\n          equal(results.length, 0);\n          done();\n        });\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"skip doesn't affect count","suites":["Parse.Query testing"],"line":1536,"updatePoint":{"line":1536,"column":31,"index":47263},"code":"  it(\"skip doesn't affect count\", function (done) {\n    Parse.Object.saveAll([new TestObject(), new TestObject()]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.count().then(function (count) {\n        equal(count, 2);\n        query.skip(1);\n        query.count().then(function (count) {\n          equal(count, 2);\n          query.skip(3);\n          query.count().then(function (count) {\n            equal(count, 2);\n            done();\n          });\n        });\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"count","suites":["Parse.Query testing"],"line":1553,"updatePoint":{"line":1553,"column":11,"index":47763},"code":"  it('count', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.greaterThan('number', 1);\n      query.count().then(function (count) {\n        equal(count, 8);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by ascending number","suites":["Parse.Query testing"],"line":1568,"updatePoint":{"line":1568,"column":31,"index":48218},"code":"  it('order by ascending number', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.ascending('number');\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        equal(results[0].get('number'), 1);\n        equal(results[1].get('number'), 2);\n        equal(results[2].get('number'), 3);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by descending number","suites":["Parse.Query testing"],"line":1586,"updatePoint":{"line":1586,"column":32,"index":48790},"code":"  it('order by descending number', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('number');\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        equal(results[0].get('number'), 3);\n        equal(results[1].get('number'), 2);\n        equal(results[2].get('number'), 1);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can order on an object string field","suites":["Parse.Query testing"],"line":1604,"updatePoint":{"line":1604,"column":41,"index":49372},"code":"  it('can order on an object string field', function (done) {\n    const testSet = [{\n      sortField: {\n        value: 'Z'\n      }\n    }, {\n      sortField: {\n        value: 'A'\n      }\n    }, {\n      sortField: {\n        value: 'M'\n      }\n    }];\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects).then(() => new Parse.Query('Test').addDescending('sortField.value').first()).then(result => {\n      expect(result.get('sortField').value).toBe('Z');\n      return new Parse.Query('Test').addAscending('sortField.value').first();\n    }).then(result => {\n      expect(result.get('sortField').value).toBe('A');\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can order on an object string field (level 2)","suites":["Parse.Query testing"],"line":1627,"updatePoint":{"line":1627,"column":51,"index":50083},"code":"  it('can order on an object string field (level 2)', function (done) {\n    const testSet = [{\n      sortField: {\n        value: {\n          field: 'Z'\n        }\n      }\n    }, {\n      sortField: {\n        value: {\n          field: 'A'\n        }\n      }\n    }, {\n      sortField: {\n        value: {\n          field: 'M'\n        }\n      }\n    }];\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects).then(() => new Parse.Query('Test').addDescending('sortField.value.field').first()).then(result => {\n      expect(result.get('sortField').value.field).toBe('Z');\n      return new Parse.Query('Test').addAscending('sortField.value.field').first();\n    }).then(result => {\n      expect(result.get('sortField').value.field).toBe('A');\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can order on an object number field","suites":["Parse.Query testing"],"line":1656,"updatePoint":{"line":1656,"column":41,"index":50895},"code":"  it('can order on an object number field', function (done) {\n    const testSet = [{\n      sortField: {\n        value: 10\n      }\n    }, {\n      sortField: {\n        value: 1\n      }\n    }, {\n      sortField: {\n        value: 5\n      }\n    }];\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects).then(() => new Parse.Query('Test').addDescending('sortField.value').first()).then(result => {\n      expect(result.get('sortField').value).toBe(10);\n      return new Parse.Query('Test').addAscending('sortField.value').first();\n    }).then(result => {\n      expect(result.get('sortField').value).toBe(1);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can order on an object number field (level 2)","suites":["Parse.Query testing"],"line":1679,"updatePoint":{"line":1679,"column":51,"index":51598},"code":"  it('can order on an object number field (level 2)', function (done) {\n    const testSet = [{\n      sortField: {\n        value: {\n          field: 10\n        }\n      }\n    }, {\n      sortField: {\n        value: {\n          field: 1\n        }\n      }\n    }, {\n      sortField: {\n        value: {\n          field: 5\n        }\n      }\n    }];\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects).then(() => new Parse.Query('Test').addDescending('sortField.value.field').first()).then(result => {\n      expect(result.get('sortField').value.field).toBe(10);\n      return new Parse.Query('Test').addAscending('sortField.value.field').first();\n    }).then(result => {\n      expect(result.get('sortField').value.field).toBe(1);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by ascending number then descending string","suites":["Parse.Query testing"],"line":1708,"updatePoint":{"line":1708,"column":54,"index":52415},"code":"  it('order by ascending number then descending string', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({\n        number: num,\n        string: strings[i]\n      });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.ascending('number').addDescending('string');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 1);\n        equal(results[0].get('string'), 'b');\n        equal(results[1].get('number'), 2);\n        equal(results[1].get('string'), 'd');\n        equal(results[2].get('number'), 3);\n        equal(results[2].get('string'), 'c');\n        equal(results[3].get('number'), 3);\n        equal(results[3].get('string'), 'a');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by non-existing string","suites":["Parse.Query testing"],"line":1733,"updatePoint":{"line":1733,"column":34,"index":53321},"code":"  it('order by non-existing string', async () => {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({\n        number: num,\n        string: strings[i]\n      });\n    };\n    await Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber));\n    const results = await new Parse.Query(BoxedNumber).ascending('foo').find();\n    expect(results.length).toBe(4);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by descending number then ascending string","suites":["Parse.Query testing"],"line":1745,"updatePoint":{"line":1745,"column":54,"index":53767},"code":"  it('order by descending number then ascending string', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({\n        number: num,\n        string: strings[i]\n      });\n    };\n    const objects = [3, 1, 3, 2].map(makeBoxedNumber);\n    Parse.Object.saveAll(objects).then(() => {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('number').addAscending('string');\n      return query.find();\n    }).then(results => {\n      equal(results.length, 4);\n      equal(results[0].get('number'), 3);\n      equal(results[0].get('string'), 'a');\n      equal(results[1].get('number'), 3);\n      equal(results[1].get('string'), 'c');\n      equal(results[2].get('number'), 2);\n      equal(results[2].get('string'), 'd');\n      equal(results[3].get('number'), 1);\n      equal(results[3].get('string'), 'b');\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by descending number and string","suites":["Parse.Query testing"],"line":1774,"updatePoint":{"line":1774,"column":43,"index":54730},"code":"  it('order by descending number and string', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({\n        number: num,\n        string: strings[i]\n      });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('number,string');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 3);\n        equal(results[0].get('string'), 'c');\n        equal(results[1].get('number'), 3);\n        equal(results[1].get('string'), 'a');\n        equal(results[2].get('number'), 2);\n        equal(results[2].get('string'), 'd');\n        equal(results[3].get('number'), 1);\n        equal(results[3].get('string'), 'b');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by descending number and string, with space","suites":["Parse.Query testing"],"line":1799,"updatePoint":{"line":1799,"column":55,"index":55641},"code":"  it('order by descending number and string, with space', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({\n        number: num,\n        string: strings[i]\n      });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('number, string');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 3);\n        equal(results[0].get('string'), 'c');\n        equal(results[1].get('number'), 3);\n        equal(results[1].get('string'), 'a');\n        equal(results[2].get('number'), 2);\n        equal(results[2].get('string'), 'd');\n        equal(results[3].get('number'), 1);\n        equal(results[3].get('string'), 'b');\n        done();\n      });\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by descending number and string, with array arg","suites":["Parse.Query testing"],"line":1827,"updatePoint":{"line":1827,"column":59,"index":56605},"code":"  it('order by descending number and string, with array arg', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({\n        number: num,\n        string: strings[i]\n      });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending(['number', 'string']);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 3);\n        equal(results[0].get('string'), 'c');\n        equal(results[1].get('number'), 3);\n        equal(results[1].get('string'), 'a');\n        equal(results[2].get('number'), 2);\n        equal(results[2].get('string'), 'd');\n        equal(results[3].get('number'), 1);\n        equal(results[3].get('string'), 'b');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by descending number and string, with multiple args","suites":["Parse.Query testing"],"line":1852,"updatePoint":{"line":1852,"column":63,"index":57529},"code":"  it('order by descending number and string, with multiple args', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({\n        number: num,\n        string: strings[i]\n      });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('number', 'string');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 3);\n        equal(results[0].get('string'), 'c');\n        equal(results[1].get('number'), 3);\n        equal(results[1].get('string'), 'a');\n        equal(results[2].get('number'), 2);\n        equal(results[2].get('string'), 'd');\n        equal(results[3].get('number'), 1);\n        equal(results[3].get('string'), 'b');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can't order by password","suites":["Parse.Query testing"],"line":1877,"updatePoint":{"line":1877,"column":29,"index":58417},"code":"  it(\"can't order by password\", function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.ascending('_password');\n      query.find().then(done.fail).catch(e => expect(e.code).toBe(Parse.Error.INVALID_KEY_NAME)).then(done);\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by _created_at","suites":["Parse.Query testing"],"line":1889,"updatePoint":{"line":1889,"column":26,"index":58858},"code":"  it('order by _created_at', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0].save().then(() => {\n      return numbers[1].save();\n    }).then(() => {\n      return numbers[2].save();\n    }).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.ascending('_created_at');\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        equal(results[0].get('number'), 3);\n        equal(results[1].get('number'), 1);\n        equal(results[2].get('number'), 2);\n        done();\n      }, done.fail);\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by createdAt","suites":["Parse.Query testing"],"line":1912,"updatePoint":{"line":1912,"column":24,"index":59559},"code":"  it('order by createdAt', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0].save().then(() => {\n      return numbers[1].save();\n    }).then(() => {\n      return numbers[2].save();\n    }).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('createdAt');\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        equal(results[0].get('number'), 2);\n        equal(results[1].get('number'), 1);\n        equal(results[2].get('number'), 3);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by _updated_at","suites":["Parse.Query testing"],"line":1935,"updatePoint":{"line":1935,"column":26,"index":60250},"code":"  it('order by _updated_at', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0].save().then(() => {\n      return numbers[1].save();\n    }).then(() => {\n      return numbers[2].save();\n    }).then(function () {\n      numbers[1].set('number', 4);\n      numbers[1].save().then(function () {\n        const query = new Parse.Query(BoxedNumber);\n        query.ascending('_updated_at');\n        query.find().then(function (results) {\n          equal(results.length, 3);\n          equal(results[0].get('number'), 3);\n          equal(results[1].get('number'), 2);\n          equal(results[2].get('number'), 4);\n          done();\n        });\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"order by updatedAt","suites":["Parse.Query testing"],"line":1961,"updatePoint":{"line":1961,"column":24,"index":61046},"code":"  it('order by updatedAt', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({\n        number: i\n      });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0].save().then(() => {\n      return numbers[1].save();\n    }).then(() => {\n      return numbers[2].save();\n    }).then(function () {\n      numbers[1].set('number', 4);\n      numbers[1].save().then(function () {\n        const query = new Parse.Query(BoxedNumber);\n        query.descending('_updated_at');\n        query.find().then(function (results) {\n          equal(results.length, 3);\n          equal(results[0].get('number'), 4);\n          equal(results[1].get('number'), 2);\n          equal(results[2].get('number'), 3);\n          done();\n        });\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"time equality","suites":["Parse.Query testing"],"line":2014,"updatePoint":{"line":2014,"column":19,"index":62486},"code":"  it('time equality', function (done) {\n    makeThreeTimeObjects().then(function (list) {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('time', list[1].get('time'));\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'item2');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"time lessThan","suites":["Parse.Query testing"],"line":2025,"updatePoint":{"line":2025,"column":19,"index":62842},"code":"  it('time lessThan', function (done) {\n    makeThreeTimeObjects().then(function (list) {\n      const query = new Parse.Query(TestObject);\n      query.lessThan('time', list[2].get('time'));\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"time createdAt","suites":["Parse.Query testing"],"line":2037,"updatePoint":{"line":2037,"column":20,"index":63227},"code":"  it('time createdAt', function (done) {\n    makeThreeTimeObjects().then(function (list) {\n      const query = new Parse.Query(TestObject);\n      query.greaterThanOrEqualTo('createdAt', list[0].createdAt);\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"matches string","suites":["Parse.Query testing"],"line":2047,"updatePoint":{"line":2047,"column":20,"index":63552},"code":"  it('matches string', function (done) {\n    const thing1 = new TestObject();\n    thing1.set('myString', 'football');\n    const thing2 = new TestObject();\n    thing2.set('myString', 'soccer');\n    Parse.Object.saveAll([thing1, thing2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', '^fo*\\\\wb[^o]l+$');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"matches regex","suites":["Parse.Query testing"],"line":2061,"updatePoint":{"line":2061,"column":19,"index":64026},"code":"  it('matches regex', function (done) {\n    const thing1 = new TestObject();\n    thing1.set('myString', 'football');\n    const thing2 = new TestObject();\n    thing2.set('myString', 'soccer');\n    Parse.Object.saveAll([thing1, thing2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', /^fo*\\wb[^o]l+$/);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"case insensitive regex success","suites":["Parse.Query testing"],"line":2075,"updatePoint":{"line":2075,"column":36,"index":64516},"code":"  it('case insensitive regex success', function (done) {\n    const thing = new TestObject();\n    thing.set('myString', 'football');\n    Parse.Object.saveAll([thing]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', 'FootBall', 'i');\n      query.find().then(done);\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"regexes with invalid options fail","suites":["Parse.Query testing"],"line":2084,"updatePoint":{"line":2084,"column":39,"index":64848},"code":"  it('regexes with invalid options fail', function (done) {\n    const query = new Parse.Query(TestObject);\n    query.matches('myString', 'FootBall', 'some invalid option');\n    query.find().then(done.fail).catch(e => expect(e.code).toBe(Parse.Error.INVALID_QUERY)).then(done);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"Use a regex that requires all modifiers","suites":["Parse.Query testing"],"line":2089,"updatePoint":{"line":2089,"column":45,"index":65137},"code":"  it('Use a regex that requires all modifiers', function (done) {\n    const thing = new TestObject();\n    thing.set('myString', 'PArSe\\nCom');\n    Parse.Object.saveAll([thing]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', \"parse # First fragment. We'll write this in one case but match insensitively\\n\" + '.com  # Second fragment. This can be separated by any character, including newline;' + 'however, this comment must end with a newline to recognize it as a comment\\n', 'mixs');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      }, function (err) {\n        jfail(err);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"Regular expression constructor includes modifiers inline","suites":["Parse.Query testing"],"line":2104,"updatePoint":{"line":2104,"column":62,"index":65872},"code":"  it('Regular expression constructor includes modifiers inline', function (done) {\n    const thing = new TestObject();\n    thing.set('myString', '\\n\\nbuffer\\n\\nparse.COM');\n    Parse.Object.saveAll([thing]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', /parse\\.com/im);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"contains","suites":["Parse.Query testing"],"line":2117,"updatePoint":{"line":2117,"column":14,"index":66398},"code":"  it('contains', function (done) {\n    Parse.Object.saveAll([new TestObject({\n      myString: 'zax' + someAscii + 'qub'\n    }), new TestObject({\n      myString: 'start' + someAscii\n    }), new TestObject({\n      myString: someAscii + 'end'\n    }), new TestObject({\n      myString: someAscii\n    })]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.contains('myString', someAscii);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"nested contains","suites":["Parse.Query testing"],"line":2135,"updatePoint":{"line":2135,"column":21,"index":66937},"code":"  it('nested contains', done => {\n    const sender1 = {\n      group: ['A', 'B']\n    };\n    const sender2 = {\n      group: ['A', 'C']\n    };\n    const sender3 = {\n      group: ['B', 'C']\n    };\n    const obj1 = new TestObject({\n      sender: sender1\n    });\n    const obj2 = new TestObject({\n      sender: sender2\n    });\n    const obj3 = new TestObject({\n      sender: sender3\n    });\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const query = new Parse.Query(TestObject);\n      query.contains('sender.group', 'A');\n      return query.find();\n    }).then(results => {\n      equal(results.length, 2);\n      done();\n    }, done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"startsWith","suites":["Parse.Query testing"],"line":2163,"updatePoint":{"line":2163,"column":16,"index":67590},"code":"  it('startsWith', function (done) {\n    Parse.Object.saveAll([new TestObject({\n      myString: 'zax' + someAscii + 'qub'\n    }), new TestObject({\n      myString: 'start' + someAscii\n    }), new TestObject({\n      myString: someAscii + 'end'\n    }), new TestObject({\n      myString: someAscii\n    })]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.startsWith('myString', someAscii);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"endsWith","suites":["Parse.Query testing"],"line":2181,"updatePoint":{"line":2181,"column":14,"index":68124},"code":"  it('endsWith', function (done) {\n    Parse.Object.saveAll([new TestObject({\n      myString: 'zax' + someAscii + 'qub'\n    }), new TestObject({\n      myString: 'start' + someAscii\n    }), new TestObject({\n      myString: someAscii + 'end'\n    }), new TestObject({\n      myString: someAscii\n    })]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.endsWith('myString', someAscii);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exists","suites":["Parse.Query testing"],"line":2199,"updatePoint":{"line":2199,"column":12,"index":68654},"code":"  it('exists', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {\n      const item = new TestObject();\n      if (i % 2 === 0) {\n        item.set('x', i + 1);\n      } else {\n        item.set('y', i + 1);\n      }\n      objects.push(item);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.exists('x');\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        for (const result of results) {\n          ok(result.get('x'));\n        }\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"doesNotExist","suites":["Parse.Query testing"],"line":2222,"updatePoint":{"line":2222,"column":18,"index":69272},"code":"  it('doesNotExist', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {\n      const item = new TestObject();\n      if (i % 2 === 0) {\n        item.set('x', i + 1);\n      } else {\n        item.set('y', i + 1);\n      }\n      objects.push(item);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.doesNotExist('x');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        for (const result of results) {\n          ok(result.get('y'));\n        }\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exists relation","suites":["Parse.Query testing"],"line":2245,"updatePoint":{"line":2245,"column":21,"index":69899},"code":"  it('exists relation', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {\n      const container = new Container();\n      if (i % 2 === 0) {\n        const item = new TestObject();\n        item.set('x', i);\n        container.set('x', item);\n        objects.push(item);\n      } else {\n        container.set('y', i);\n      }\n      objects.push(container);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(Container);\n      query.exists('x');\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        for (const result of results) {\n          ok(result.get('x'));\n        }\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"doesNotExist relation","suites":["Parse.Query testing"],"line":2271,"updatePoint":{"line":2271,"column":27,"index":70632},"code":"  it('doesNotExist relation', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7]) {\n      const container = new Container();\n      if (i % 2 === 0) {\n        const item = new TestObject();\n        item.set('x', i);\n        container.set('x', item);\n        objects.push(item);\n      } else {\n        container.set('y', i);\n      }\n      objects.push(container);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(Container);\n      query.doesNotExist('x');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        for (const result of results) {\n          ok(result.get('y'));\n        }\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"don't include by default","suites":["Parse.Query testing"],"line":2297,"updatePoint":{"line":2297,"column":30,"index":71371},"code":"  it(\"don't include by default\", function (done) {\n    const child = new TestObject();\n    const parent = new Container();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      child._clearServerData();\n      const query = new Parse.Query(Container);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const goodURL = Parse.serverURL;\n        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';\n        const childAgain = parentAgain.get('child');\n        ok(childAgain);\n        equal(childAgain.get('foo'), undefined);\n        Parse.serverURL = goodURL;\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"include relation","suites":["Parse.Query testing"],"line":2318,"updatePoint":{"line":2318,"column":22,"index":72103},"code":"  it('include relation', function (done) {\n    const child = new TestObject();\n    const parent = new Container();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      const query = new Parse.Query(Container);\n      query.include('child');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const goodURL = Parse.serverURL;\n        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';\n        const childAgain = parentAgain.get('child');\n        ok(childAgain);\n        equal(childAgain.get('foo'), 'bar');\n        Parse.serverURL = goodURL;\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"include relation array","suites":["Parse.Query testing"],"line":2339,"updatePoint":{"line":2339,"column":28,"index":72835},"code":"  it('include relation array', function (done) {\n    const child = new TestObject();\n    const parent = new Container();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      const query = new Parse.Query(Container);\n      query.include(['child']);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const goodURL = Parse.serverURL;\n        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';\n        const childAgain = parentAgain.get('child');\n        ok(childAgain);\n        equal(childAgain.get('foo'), 'bar');\n        Parse.serverURL = goodURL;\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"nested include","suites":["Parse.Query testing"],"line":2360,"updatePoint":{"line":2360,"column":20,"index":73561},"code":"  it('nested include', function (done) {\n    const Child = Parse.Object.extend('Child');\n    const Parent = Parse.Object.extend('Parent');\n    const Grandparent = Parse.Object.extend('Grandparent');\n    const objects = [];\n    for (let i = 0; i < 5; ++i) {\n      const grandparent = new Grandparent({\n        z: i,\n        parent: new Parent({\n          y: i,\n          child: new Child({\n            x: i\n          })\n        })\n      });\n      objects.push(grandparent);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(Grandparent);\n      query.include(['parent.child']);\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        for (const object of results) {\n          equal(object.get('z'), object.get('parent').get('y'));\n          equal(object.get('z'), object.get('parent').get('child').get('x'));\n        }\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"include doesn't make dirty wrong","suites":["Parse.Query testing"],"line":2390,"updatePoint":{"line":2390,"column":38,"index":74512},"code":"  it(\"include doesn't make dirty wrong\", function (done) {\n    const Parent = Parse.Object.extend('ParentObject');\n    const Child = Parse.Object.extend('ChildObject');\n    const parent = new Parent();\n    const child = new Child();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      const query = new Parse.Query(Parent);\n      query.include('child');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const childAgain = parentAgain.get('child');\n        equal(childAgain.id, child.id);\n        equal(parentAgain.id, parent.id);\n        equal(childAgain.get('foo'), 'bar');\n        equal(false, parentAgain.dirty());\n        equal(false, childAgain.dirty());\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"properly includes array","suites":["Parse.Query testing"],"line":2413,"updatePoint":{"line":2413,"column":29,"index":75357},"code":"  it('properly includes array', done => {\n    const objects = [];\n    let total = 0;\n    while (objects.length != 5) {\n      const object = new Parse.Object('AnObject');\n      object.set('key', objects.length);\n      total += objects.length;\n      objects.push(object);\n    }\n    Parse.Object.saveAll(objects).then(() => {\n      const object = new Parse.Object('AContainer');\n      object.set('objects', objects);\n      return object.save();\n    }).then(() => {\n      const query = new Parse.Query('AContainer');\n      query.include('objects');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(1);\n      const res = results[0];\n      const objects = res.get('objects');\n      expect(objects.length).toBe(5);\n      objects.forEach(object => {\n        total -= object.get('key');\n      });\n      expect(total).toBe(0);\n      done();\n    }, () => {\n      fail('should not fail');\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"properly includes array of mixed objects","suites":["Parse.Query testing"],"line":2445,"updatePoint":{"line":2445,"column":46,"index":76316},"code":"  it('properly includes array of mixed objects', done => {\n    const objects = [];\n    let total = 0;\n    while (objects.length != 5) {\n      const object = new Parse.Object('AnObject');\n      object.set('key', objects.length);\n      total += objects.length;\n      objects.push(object);\n    }\n    while (objects.length != 10) {\n      const object = new Parse.Object('AnotherObject');\n      object.set('key', objects.length);\n      total += objects.length;\n      objects.push(object);\n    }\n    Parse.Object.saveAll(objects).then(() => {\n      const object = new Parse.Object('AContainer');\n      object.set('objects', objects);\n      return object.save();\n    }).then(() => {\n      const query = new Parse.Query('AContainer');\n      query.include('objects');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(1);\n      const res = results[0];\n      const objects = res.get('objects');\n      expect(objects.length).toBe(10);\n      objects.forEach(object => {\n        total -= object.get('key');\n      });\n      expect(total).toBe(0);\n      done();\n    }, e => {\n      fail('should not fail');\n      fail(JSON.stringify(e));\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"properly nested array of mixed objects with bad ids","suites":["Parse.Query testing"],"line":2484,"updatePoint":{"line":2484,"column":57,"index":77514},"code":"  it('properly nested array of mixed objects with bad ids', done => {\n    const objects = [];\n    let total = 0;\n    while (objects.length != 5) {\n      const object = new Parse.Object('AnObject');\n      object.set('key', objects.length);\n      objects.push(object);\n    }\n    while (objects.length != 10) {\n      const object = new Parse.Object('AnotherObject');\n      object.set('key', objects.length);\n      objects.push(object);\n    }\n    Parse.Object.saveAll(objects).then(() => {\n      const object = new Parse.Object('AContainer');\n      for (let i = 0; i < objects.length; i++) {\n        if (i % 2 == 0) {\n          objects[i].id = 'randomThing';\n        } else {\n          total += objects[i].get('key');\n        }\n      }\n      object.set('objects', objects);\n      return object.save();\n    }).then(() => {\n      const query = new Parse.Query('AContainer');\n      query.include('objects');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(1);\n      const res = results[0];\n      const objects = res.get('objects');\n      expect(objects.length).toBe(5);\n      objects.forEach(object => {\n        total -= object.get('key');\n      });\n      expect(total).toBe(0);\n      done();\n    }, err => {\n      jfail(err);\n      fail('should not fail');\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"properly fetches nested pointers","suites":["Parse.Query testing"],"line":2528,"updatePoint":{"line":2528,"column":38,"index":78812},"code":"  it('properly fetches nested pointers', done => {\n    const color = new Parse.Object('Color');\n    color.set('hex', '#133733');\n    const circle = new Parse.Object('Circle');\n    circle.set('radius', 1337);\n    Parse.Object.saveAll([color, circle]).then(() => {\n      circle.set('color', color);\n      const badCircle = new Parse.Object('Circle');\n      badCircle.id = 'badId';\n      const complexFigure = new Parse.Object('ComplexFigure');\n      complexFigure.set('consistsOf', [circle, badCircle]);\n      return complexFigure.save();\n    }).then(() => {\n      const q = new Parse.Query('ComplexFigure');\n      q.include('consistsOf.color');\n      return q.find();\n    }).then(results => {\n      expect(results.length).toBe(1);\n      const figure = results[0];\n      expect(figure.get('consistsOf').length).toBe(1);\n      expect(figure.get('consistsOf')[0].get('color').get('hex')).toBe('#133733');\n      done();\n    }, () => {\n      fail('should not fail');\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"result object creation uses current extension","suites":["Parse.Query testing"],"line":2555,"updatePoint":{"line":2555,"column":51,"index":79814},"code":"  it('result object creation uses current extension', function (done) {\n    const ParentObject = Parse.Object.extend({\n      className: 'ParentObject'\n    });\n    // Add a foo() method to ChildObject.\n    let ChildObject = Parse.Object.extend('ChildObject', {\n      foo: function () {\n        return 'foo';\n      }\n    });\n    const parent = new ParentObject();\n    const child = new ChildObject();\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      // Add a bar() method to ChildObject.\n      ChildObject = Parse.Object.extend('ChildObject', {\n        bar: function () {\n          return 'bar';\n        }\n      });\n      const query = new Parse.Query(ParentObject);\n      query.include('child');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const childAgain = parentAgain.get('child');\n        equal(childAgain.foo(), 'foo');\n        equal(childAgain.bar(), 'bar');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"matches query","suites":["Parse.Query testing"],"line":2587,"updatePoint":{"line":2587,"column":19,"index":80819},"code":"  it('matches query', function (done) {\n    const ParentObject = Parse.Object.extend('ParentObject');\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const objects = [];\n    for (let i = 0; i < 10; ++i) {\n      objects.push(new ParentObject({\n        child: new ChildObject({\n          x: i\n        }),\n        x: 10 + i\n      }));\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const subQuery = new Parse.Query(ChildObject);\n      subQuery.greaterThan('x', 5);\n      const query = new Parse.Query(ParentObject);\n      query.matchesQuery('child', subQuery);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        for (const object of results) {\n          ok(object.get('x') > 15);\n        }\n        const query = new Parse.Query(ParentObject);\n        query.doesNotMatchQuery('child', subQuery);\n        query.find().then(function (results) {\n          equal(results.length, 6);\n          for (const object of results) {\n            ok(object.get('x') >= 10);\n            ok(object.get('x') <= 15);\n            done();\n          }\n        });\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"select query","suites":["Parse.Query testing"],"line":2622,"updatePoint":{"line":2622,"column":18,"index":81951},"code":"  it('select query', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [new RestaurantObject({\n      ratings: 5,\n      location: 'Djibouti'\n    }), new RestaurantObject({\n      ratings: 3,\n      location: 'Ouagadougou'\n    }), new PersonObject({\n      name: 'Bob',\n      hometown: 'Djibouti'\n    }), new PersonObject({\n      name: 'Tom',\n      hometown: 'Ouagadougou'\n    }), new PersonObject({\n      name: 'Billy',\n      hometown: 'Detroit'\n    })];\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      query.greaterThan('ratings', 4);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.matchesKeyInQuery('hometown', 'location', query);\n      mainQuery.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Bob');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"$select inside $or","suites":["Parse.Query testing"],"line":2653,"updatePoint":{"line":2653,"column":24,"index":82953},"code":"  it('$select inside $or', done => {\n    const Restaurant = Parse.Object.extend('Restaurant');\n    const Person = Parse.Object.extend('Person');\n    const objects = [new Restaurant({\n      ratings: 5,\n      location: 'Djibouti'\n    }), new Restaurant({\n      ratings: 3,\n      location: 'Ouagadougou'\n    }), new Person({\n      name: 'Bob',\n      hometown: 'Djibouti'\n    }), new Person({\n      name: 'Tom',\n      hometown: 'Ouagadougou'\n    }), new Person({\n      name: 'Billy',\n      hometown: 'Detroit'\n    })];\n    Parse.Object.saveAll(objects).then(() => {\n      const subquery = new Parse.Query(Restaurant);\n      subquery.greaterThan('ratings', 4);\n      const query1 = new Parse.Query(Person);\n      query1.matchesKeyInQuery('hometown', 'location', subquery);\n      const query2 = new Parse.Query(Person);\n      query2.equalTo('name', 'Tom');\n      const query = Parse.Query.or(query1, query2);\n      return query.find();\n    }).then(results => {\n      expect(results.length).toEqual(2);\n      done();\n    }, error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"$nor valid query","suites":["Parse.Query testing"],"line":2689,"updatePoint":{"line":2689,"column":22,"index":84027},"code":"  it('$nor valid query', done => {\n    const objects = Array.from(Array(10).keys()).map(rating => {\n      return new TestObject({\n        rating: rating\n      });\n    });\n    const highValue = 5;\n    const lowValue = 3;\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          $nor: [{\n            rating: {\n              $gt: highValue\n            }\n          }, {\n            rating: {\n              $lte: lowValue\n            }\n          }]\n        })\n      }\n    });\n    Parse.Object.saveAll(objects).then(() => {\n      return request(Object.assign({\n        url: Parse.serverURL + '/classes/TestObject'\n      }, options));\n    }).then(response => {\n      const results = response.data;\n      expect(results.results.length).toBe(highValue - lowValue);\n      expect(results.results.every(res => res.rating > lowValue && res.rating <= highValue)).toBe(true);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"$nor invalid query - empty array","suites":["Parse.Query testing"],"line":2723,"updatePoint":{"line":2723,"column":38,"index":84987},"code":"  it('$nor invalid query - empty array', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          $nor: []\n        })\n      }\n    });\n    const obj = new TestObject();\n    obj.save().then(() => {\n      return request(Object.assign({\n        url: Parse.serverURL + '/classes/TestObject'\n      }, options));\n    }).then(done.fail).catch(response => {\n      equal(response.data.code, Parse.Error.INVALID_QUERY);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"$nor invalid query - wrong type","suites":["Parse.Query testing"],"line":2741,"updatePoint":{"line":2741,"column":37,"index":85488},"code":"  it('$nor invalid query - wrong type', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          $nor: 1337\n        })\n      }\n    });\n    const obj = new TestObject();\n    obj.save().then(() => {\n      return request(Object.assign({\n        url: Parse.serverURL + '/classes/TestObject'\n      }, options));\n    }).then(done.fail).catch(response => {\n      equal(response.data.code, Parse.Error.INVALID_QUERY);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"dontSelect query","suites":["Parse.Query testing"],"line":2759,"updatePoint":{"line":2759,"column":22,"index":85976},"code":"  it('dontSelect query', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [new RestaurantObject({\n      ratings: 5,\n      location: 'Djibouti'\n    }), new RestaurantObject({\n      ratings: 3,\n      location: 'Ouagadougou'\n    }), new PersonObject({\n      name: 'Bob',\n      hometown: 'Djibouti'\n    }), new PersonObject({\n      name: 'Tom',\n      hometown: 'Ouagadougou'\n    }), new PersonObject({\n      name: 'Billy',\n      hometown: 'Djibouti'\n    })];\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      query.greaterThan('ratings', 4);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.doesNotMatchKeyInQuery('hometown', 'location', query);\n      mainQuery.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Tom');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"dontSelect query without conditions","suites":["Parse.Query testing"],"line":2790,"updatePoint":{"line":2790,"column":41,"index":87001},"code":"  it('dontSelect query without conditions', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [new RestaurantObject({\n      location: 'Djibouti'\n    }), new RestaurantObject({\n      location: 'Ouagadougou'\n    }), new PersonObject({\n      name: 'Bob',\n      hometown: 'Djibouti'\n    }), new PersonObject({\n      name: 'Tom',\n      hometown: 'Yoloblahblahblah'\n    }), new PersonObject({\n      name: 'Billy',\n      hometown: 'Ouagadougou'\n    })];\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.doesNotMatchKeyInQuery('hometown', 'location', query);\n      mainQuery.find().then(results => {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Tom');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"equalTo on same column as $dontSelect should not break $dontSelect functionality (#3678)","suites":["Parse.Query testing"],"line":2818,"updatePoint":{"line":2818,"column":94,"index":88004},"code":"  it('equalTo on same column as $dontSelect should not break $dontSelect functionality (#3678)', function (done) {\n    const AuthorObject = Parse.Object.extend('Author');\n    const BlockedObject = Parse.Object.extend('Blocked');\n    const PostObject = Parse.Object.extend('Post');\n    let postAuthor = null;\n    let requestUser = null;\n    return new AuthorObject({\n      name: 'Julius'\n    }).save().then(user => {\n      postAuthor = user;\n      return new AuthorObject({\n        name: 'Bob'\n      }).save();\n    }).then(user => {\n      requestUser = user;\n      const objects = [new PostObject({\n        author: postAuthor,\n        title: 'Lorem ipsum'\n      }), new PostObject({\n        author: requestUser,\n        title: 'Kafka'\n      }), new PostObject({\n        author: requestUser,\n        title: 'Brown fox'\n      }), new BlockedObject({\n        blockedBy: postAuthor,\n        blockedUser: requestUser\n      })];\n      return Parse.Object.saveAll(objects);\n    }).then(() => {\n      const banListQuery = new Parse.Query(BlockedObject);\n      banListQuery.equalTo('blockedUser', requestUser);\n      return new Parse.Query(PostObject).equalTo('author', postAuthor).doesNotMatchKeyInQuery('author', 'blockedBy', banListQuery).find().then(r => {\n        expect(r.length).toEqual(0);\n        done();\n      }, done.fail);\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"multiple dontSelect query","suites":["Parse.Query testing"],"line":2856,"updatePoint":{"line":2856,"column":31,"index":89280},"code":"  it('multiple dontSelect query', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [new RestaurantObject({\n      ratings: 7,\n      location: 'Djibouti2'\n    }), new RestaurantObject({\n      ratings: 5,\n      location: 'Djibouti'\n    }), new RestaurantObject({\n      ratings: 3,\n      location: 'Ouagadougou'\n    }), new PersonObject({\n      name: 'Bob2',\n      hometown: 'Djibouti2'\n    }), new PersonObject({\n      name: 'Bob',\n      hometown: 'Djibouti'\n    }), new PersonObject({\n      name: 'Tom',\n      hometown: 'Ouagadougou'\n    })];\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      query.greaterThan('ratings', 6);\n      const query2 = new Parse.Query(RestaurantObject);\n      query2.lessThan('ratings', 4);\n      const subQuery = new Parse.Query(PersonObject);\n      subQuery.matchesKeyInQuery('hometown', 'location', query);\n      const subQuery2 = new Parse.Query(PersonObject);\n      subQuery2.matchesKeyInQuery('hometown', 'location', query2);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.doesNotMatchKeyInQuery('objectId', 'objectId', Parse.Query.or(subQuery, subQuery2));\n      mainQuery.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Bob');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"include user","suites":["Parse.Query testing"],"line":2896,"updatePoint":{"line":2896,"column":18,"index":90723},"code":"  it('include user', function (done) {\n    Parse.User.signUp('bob', 'password', {\n      age: 21\n    }).then(function (user) {\n      const TestObject = Parse.Object.extend('TestObject');\n      const obj = new TestObject();\n      obj.save({\n        owner: user\n      }).then(function (obj) {\n        const query = new Parse.Query(TestObject);\n        query.include('owner');\n        query.get(obj.id).then(function (objAgain) {\n          equal(objAgain.id, obj.id);\n          ok(objAgain.get('owner') instanceof Parse.User);\n          equal(objAgain.get('owner').get('age'), 21);\n          done();\n        }, done.fail);\n      }, done.fail);\n    }, done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"or queries","suites":["Parse.Query testing"],"line":2916,"updatePoint":{"line":2916,"column":16,"index":91386},"code":"  it('or queries', function (done) {\n    const objects = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {\n      const object = new Parse.Object('BoxedNumber');\n      object.set('x', x);\n      return object;\n    });\n    Parse.Object.saveAll(objects).then(function () {\n      const query1 = new Parse.Query('BoxedNumber');\n      query1.lessThan('x', 2);\n      const query2 = new Parse.Query('BoxedNumber');\n      query2.greaterThan('x', 5);\n      const orQuery = Parse.Query.or(query1, query2);\n      orQuery.find().then(function (results) {\n        equal(results.length, 6);\n        for (const number of results) {\n          ok(number.get('x') < 2 || number.get('x') > 5);\n        }\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"or complex queries","suites":["Parse.Query testing"],"line":2939,"updatePoint":{"line":2939,"column":24,"index":92177},"code":"  it('or complex queries', function (done) {\n    const objects = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {\n      const child = new Parse.Object('Child');\n      child.set('x', x);\n      const parent = new Parse.Object('Parent');\n      parent.set('child', child);\n      parent.set('y', x);\n      return parent;\n    });\n    Parse.Object.saveAll(objects).then(function () {\n      const subQuery = new Parse.Query('Child');\n      subQuery.equalTo('x', 4);\n      const query1 = new Parse.Query('Parent');\n      query1.matchesQuery('child', subQuery);\n      const query2 = new Parse.Query('Parent');\n      query2.lessThan('y', 2);\n      const orQuery = Parse.Query.or(query1, query2);\n      orQuery.find().then(function (results) {\n        equal(results.length, 3);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"async methods","suites":["Parse.Query testing"],"line":2962,"updatePoint":{"line":2962,"column":19,"index":92979},"code":"  it('async methods', function (done) {\n    const saves = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {\n      const obj = new Parse.Object('TestObject');\n      obj.set('x', x + 1);\n      return obj;\n    });\n    Parse.Object.saveAll(saves).then(function () {\n      const query = new Parse.Query('TestObject');\n      query.ascending('x');\n      return query.first();\n    }).then(function (obj) {\n      equal(obj.get('x'), 1);\n      const query = new Parse.Query('TestObject');\n      query.descending('x');\n      return query.find();\n    }).then(function (results) {\n      equal(results.length, 10);\n      const query = new Parse.Query('TestObject');\n      return query.get(results[0].id);\n    }).then(function (obj1) {\n      equal(obj1.get('x'), 10);\n      const query = new Parse.Query('TestObject');\n      return query.count();\n    }).then(function (count) {\n      equal(count, 10);\n    }).then(function () {\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query.each","suites":["Parse.Query testing"],"line":2991,"updatePoint":{"line":2991,"column":16,"index":93917},"code":"  it('query.each', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n    Parse.Object.saveAll(items).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.lessThan('x', COUNT);\n      const seen = [];\n      query.each(function (obj) {\n        seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n      }, {\n        batchSize: 10\n      }).then(function () {\n        equal(seen.length, COUNT);\n        for (let i = 0; i < COUNT; i++) {\n          equal(seen[i], 1, 'Should have seen object number ' + i);\n        }\n        done();\n      }, done.fail);\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query.each async","suites":["Parse.Query testing"],"line":3016,"updatePoint":{"line":3016,"column":22,"index":94657},"code":"  it('query.each async', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n    expect(COUNT + 1);\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n    const seen = [];\n    Parse.Object.saveAll(items).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.lessThan('x', COUNT);\n      return query.each(function (obj) {\n        return new Promise(resolve => {\n          process.nextTick(function () {\n            seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n            resolve();\n          });\n        });\n      }, {\n        batchSize: 10\n      });\n    }).then(function () {\n      equal(seen.length, COUNT);\n      for (let i = 0; i < COUNT; i++) {\n        equal(seen[i], 1, 'Should have seen object number ' + i);\n      }\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query.each fails with order","suites":["Parse.Query testing"],"line":3047,"updatePoint":{"line":3047,"column":33,"index":95547},"code":"  it('query.each fails with order', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n    const seen = [];\n    Parse.Object.saveAll(items).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.lessThan('x', COUNT);\n      query.ascending('x');\n      return query.each(function (obj) {\n        seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n      });\n    }).then(function () {\n      ok(false, 'This should have failed.');\n      done();\n    }, function () {\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query.each fails with skip","suites":["Parse.Query testing"],"line":3070,"updatePoint":{"line":3070,"column":32,"index":96207},"code":"  it('query.each fails with skip', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n    const seen = [];\n    Parse.Object.saveAll(items).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.lessThan('x', COUNT);\n      query.skip(5);\n      return query.each(function (obj) {\n        seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n      });\n    }).then(function () {\n      ok(false, 'This should have failed.');\n      done();\n    }, function () {\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query.each fails with limit","suites":["Parse.Query testing"],"line":3093,"updatePoint":{"line":3093,"column":33,"index":96861},"code":"  it('query.each fails with limit', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n    expect(0);\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n    const seen = [];\n    Parse.Object.saveAll(items).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.lessThan('x', COUNT);\n      query.limit(5);\n      return query.each(function (obj) {\n        seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n      });\n    }).then(function () {\n      ok(false, 'This should have failed.');\n      done();\n    }, function () {\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"select keys query JS SDK","suites":["Parse.Query testing"],"line":3117,"updatePoint":{"line":3117,"column":30,"index":97528},"code":"  it('select keys query JS SDK', async () => {\n    const obj = new TestObject({\n      foo: 'baz',\n      bar: 1,\n      qux: 2\n    });\n    await obj.save();\n    obj._clearServerData();\n    const query1 = new Parse.Query(TestObject);\n    query1.select('foo');\n    const result1 = await query1.first();\n    ok(result1.id, 'expected object id to be set');\n    ok(result1.createdAt, 'expected object createdAt to be set');\n    ok(result1.updatedAt, 'expected object updatedAt to be set');\n    ok(!result1.dirty(), 'expected result not to be dirty');\n    strictEqual(result1.get('foo'), 'baz');\n    strictEqual(result1.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result1.get('qux'), undefined, \"expected 'qux' field to be unset\");\n    const result2 = await result1.fetch();\n    strictEqual(result2.get('foo'), 'baz');\n    strictEqual(result2.get('bar'), 1);\n    strictEqual(result2.get('qux'), 2);\n    obj._clearServerData();\n    const query2 = new Parse.Query(TestObject);\n    query2.select();\n    const result3 = await query2.first();\n    ok(result3.id, 'expected object id to be set');\n    ok(result3.createdAt, 'expected object createdAt to be set');\n    ok(result3.updatedAt, 'expected object updatedAt to be set');\n    ok(!result3.dirty(), 'expected result not to be dirty');\n    strictEqual(result3.get('foo'), undefined, \"expected 'foo' field to be unset\");\n    strictEqual(result3.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result3.get('qux'), undefined, \"expected 'qux' field to be unset\");\n    obj._clearServerData();\n    const query3 = new Parse.Query(TestObject);\n    query3.select([]);\n    const result4 = await query3.first();\n    ok(result4.id, 'expected object id to be set');\n    ok(result4.createdAt, 'expected object createdAt to be set');\n    ok(result4.updatedAt, 'expected object updatedAt to be set');\n    ok(!result4.dirty(), 'expected result not to be dirty');\n    strictEqual(result4.get('foo'), undefined, \"expected 'foo' field to be unset\");\n    strictEqual(result4.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result4.get('qux'), undefined, \"expected 'qux' field to be unset\");\n    obj._clearServerData();\n    const query4 = new Parse.Query(TestObject);\n    query4.select(['foo']);\n    const result5 = await query4.first();\n    ok(result5.id, 'expected object id to be set');\n    ok(result5.createdAt, 'expected object createdAt to be set');\n    ok(result5.updatedAt, 'expected object updatedAt to be set');\n    ok(!result5.dirty(), 'expected result not to be dirty');\n    strictEqual(result5.get('foo'), 'baz');\n    strictEqual(result5.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result5.get('qux'), undefined, \"expected 'qux' field to be unset\");\n    obj._clearServerData();\n    const query5 = new Parse.Query(TestObject);\n    query5.select(['foo', 'bar']);\n    const result6 = await query5.first();\n    ok(result6.id, 'expected object id to be set');\n    ok(!result6.dirty(), 'expected result not to be dirty');\n    strictEqual(result6.get('foo'), 'baz');\n    strictEqual(result6.get('bar'), 1);\n    strictEqual(result6.get('qux'), undefined, \"expected 'qux' field to be unset\");\n    obj._clearServerData();\n    const query6 = new Parse.Query(TestObject);\n    query6.select(['foo', 'bar', 'qux']);\n    const result7 = await query6.first();\n    ok(result7.id, 'expected object id to be set');\n    ok(!result7.dirty(), 'expected result not to be dirty');\n    strictEqual(result7.get('foo'), 'baz');\n    strictEqual(result7.get('bar'), 1);\n    strictEqual(result7.get('qux'), 2);\n    obj._clearServerData();\n    const query7 = new Parse.Query(TestObject);\n    query7.select('foo', 'bar');\n    const result8 = await query7.first();\n    ok(result8.id, 'expected object id to be set');\n    ok(!result8.dirty(), 'expected result not to be dirty');\n    strictEqual(result8.get('foo'), 'baz');\n    strictEqual(result8.get('bar'), 1);\n    strictEqual(result8.get('qux'), undefined, \"expected 'qux' field to be unset\");\n    obj._clearServerData();\n    const query8 = new Parse.Query(TestObject);\n    query8.select('foo', 'bar', 'qux');\n    const result9 = await query8.first();\n    ok(result9.id, 'expected object id to be set');\n    ok(!result9.dirty(), 'expected result not to be dirty');\n    strictEqual(result9.get('foo'), 'baz');\n    strictEqual(result9.get('bar'), 1);\n    strictEqual(result9.get('qux'), 2);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"select keys (arrays)","suites":["Parse.Query testing"],"line":3209,"updatePoint":{"line":3209,"column":26,"index":101988},"code":"  it('select keys (arrays)', async () => {\n    const obj = new TestObject({\n      foo: 'baz',\n      bar: 1,\n      hello: 'world'\n    });\n    await obj.save();\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: 'hello',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].bar).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: ['foo', 'hello'],\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    expect(response2.data.results[0].foo).toBe('baz');\n    expect(response2.data.results[0].bar).toBeUndefined();\n    expect(response2.data.results[0].hello).toBe('world');\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: ['foo', 'bar', 'hello'],\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].bar).toBe(1);\n    expect(response3.data.results[0].hello).toBe('world');\n    const response4 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: [''],\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response4.data.results[0].objectId, 'expected objectId to be set');\n    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response4.data.results[0].foo).toBeUndefined();\n    expect(response4.data.results[0].bar).toBeUndefined();\n    expect(response4.data.results[0].hello).toBeUndefined();\n    const response5 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: [],\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response5.data.results[0].objectId, 'expected objectId to be set');\n    ok(response5.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response5.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response5.data.results[0].foo).toBe('baz');\n    expect(response5.data.results[0].bar).toBe(1);\n    expect(response5.data.results[0].hello).toBe('world');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"select keys (strings)","suites":["Parse.Query testing"],"line":3288,"updatePoint":{"line":3288,"column":27,"index":104732},"code":"  it('select keys (strings)', async () => {\n    const obj = new TestObject({\n      foo: 'baz',\n      bar: 1,\n      hello: 'world'\n    });\n    await obj.save();\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: '',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response.data.results[0].objectId, 'expected objectId to be set');\n    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].bar).toBeUndefined();\n    expect(response.data.results[0].hello).toBeUndefined();\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: '[\"foo\", \"hello\"]',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response2.data.results[0].objectId, 'expected objectId to be set');\n    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response2.data.results[0].foo).toBe('baz');\n    expect(response2.data.results[0].bar).toBeUndefined();\n    expect(response2.data.results[0].hello).toBe('world');\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: '[\"foo\", \"bar\", \"hello\"]',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response3.data.results[0].objectId, 'expected objectId to be set');\n    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].bar).toBe(1);\n    expect(response3.data.results[0].hello).toBe('world');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exclude keys query JS SDK","suites":["Parse.Query testing"],"line":3344,"updatePoint":{"line":3344,"column":31,"index":106897},"code":"  it('exclude keys query JS SDK', async () => {\n    const obj = new TestObject({\n      foo: 'baz',\n      bar: 1,\n      qux: 2\n    });\n    await obj.save();\n    obj._clearServerData();\n    const query1 = new Parse.Query(TestObject);\n    query1.exclude('foo');\n    const result1 = await query1.first();\n    ok(result1.id, 'expected object id to be set');\n    ok(result1.createdAt, 'expected object createdAt to be set');\n    ok(result1.updatedAt, 'expected object updatedAt to be set');\n    ok(!result1.dirty(), 'expected result not to be dirty');\n    strictEqual(result1.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result1.get('bar'), 1);\n    strictEqual(result1.get('qux'), 2);\n    const result2 = await result1.fetch();\n    strictEqual(result2.get('foo'), 'baz');\n    strictEqual(result2.get('bar'), 1);\n    strictEqual(result2.get('qux'), 2);\n    obj._clearServerData();\n    const query2 = new Parse.Query(TestObject);\n    query2.exclude();\n    const result3 = await query2.first();\n    ok(result3.id, 'expected object id to be set');\n    ok(result3.createdAt, 'expected object createdAt to be set');\n    ok(result3.updatedAt, 'expected object updatedAt to be set');\n    ok(!result3.dirty(), 'expected result not to be dirty');\n    strictEqual(result3.get('foo'), 'baz');\n    strictEqual(result3.get('bar'), 1);\n    strictEqual(result3.get('qux'), 2);\n    obj._clearServerData();\n    const query3 = new Parse.Query(TestObject);\n    query3.exclude([]);\n    const result4 = await query3.first();\n    ok(result4.id, 'expected object id to be set');\n    ok(result4.createdAt, 'expected object createdAt to be set');\n    ok(result4.updatedAt, 'expected object updatedAt to be set');\n    ok(!result4.dirty(), 'expected result not to be dirty');\n    strictEqual(result4.get('foo'), 'baz');\n    strictEqual(result4.get('bar'), 1);\n    strictEqual(result4.get('qux'), 2);\n    obj._clearServerData();\n    const query4 = new Parse.Query(TestObject);\n    query4.exclude(['foo']);\n    const result5 = await query4.first();\n    ok(result5.id, 'expected object id to be set');\n    ok(result5.createdAt, 'expected object createdAt to be set');\n    ok(result5.updatedAt, 'expected object updatedAt to be set');\n    ok(!result5.dirty(), 'expected result not to be dirty');\n    strictEqual(result5.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result5.get('bar'), 1);\n    strictEqual(result5.get('qux'), 2);\n    obj._clearServerData();\n    const query5 = new Parse.Query(TestObject);\n    query5.exclude(['foo', 'bar']);\n    const result6 = await query5.first();\n    ok(result6.id, 'expected object id to be set');\n    ok(!result6.dirty(), 'expected result not to be dirty');\n    strictEqual(result6.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result6.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result6.get('qux'), 2);\n    obj._clearServerData();\n    const query6 = new Parse.Query(TestObject);\n    query6.exclude(['foo', 'bar', 'qux']);\n    const result7 = await query6.first();\n    ok(result7.id, 'expected object id to be set');\n    ok(!result7.dirty(), 'expected result not to be dirty');\n    strictEqual(result7.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result7.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result7.get('qux'), undefined, \"expected 'bar' field to be unset\");\n    obj._clearServerData();\n    const query7 = new Parse.Query(TestObject);\n    query7.exclude('foo');\n    const result8 = await query7.first();\n    ok(result8.id, 'expected object id to be set');\n    ok(!result8.dirty(), 'expected result not to be dirty');\n    strictEqual(result8.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result8.get('bar'), 1);\n    strictEqual(result8.get('qux'), 2);\n    obj._clearServerData();\n    const query8 = new Parse.Query(TestObject);\n    query8.exclude('foo', 'bar');\n    const result9 = await query8.first();\n    ok(result9.id, 'expected object id to be set');\n    ok(!result9.dirty(), 'expected result not to be dirty');\n    strictEqual(result9.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result9.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result9.get('qux'), 2);\n    obj._clearServerData();\n    const query9 = new Parse.Query(TestObject);\n    query9.exclude('foo', 'bar', 'qux');\n    const result10 = await query9.first();\n    ok(result10.id, 'expected object id to be set');\n    ok(!result10.dirty(), 'expected result not to be dirty');\n    strictEqual(result10.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result10.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result10.get('qux'), undefined, \"expected 'bar' field to be unset\");\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exclude keys (arrays)","suites":["Parse.Query testing"],"line":3445,"updatePoint":{"line":3445,"column":27,"index":111778},"code":"  it('exclude keys (arrays)', async () => {\n    const obj = new TestObject({\n      foo: 'baz',\n      hello: 'world'\n    });\n    await obj.save();\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: ['foo'],\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response.data.results[0].objectId, 'expected objectId to be set');\n    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: ['foo', 'hello'],\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response2.data.results[0].objectId, 'expected objectId to be set');\n    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response2.data.results[0].foo).toBeUndefined();\n    expect(response2.data.results[0].hello).toBeUndefined();\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: [],\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response3.data.results[0].objectId, 'expected objectId to be set');\n    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].hello).toBe('world');\n    const response4 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: [''],\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response4.data.results[0].objectId, 'expected objectId to be set');\n    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response4.data.results[0].foo).toBe('baz');\n    expect(response4.data.results[0].hello).toBe('world');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exclude keys (strings)","suites":["Parse.Query testing"],"line":3512,"updatePoint":{"line":3512,"column":28,"index":114368},"code":"  it('exclude keys (strings)', async () => {\n    const obj = new TestObject({\n      foo: 'baz',\n      hello: 'world'\n    });\n    await obj.save();\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: 'foo',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response.data.results[0].objectId, 'expected objectId to be set');\n    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: '',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response2.data.results[0].objectId, 'expected objectId to be set');\n    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response2.data.results[0].foo).toBe('baz');\n    expect(response2.data.results[0].hello).toBe('world');\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: '[\"hello\"]',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response3.data.results[0].objectId, 'expected objectId to be set');\n    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].hello).toBeUndefined();\n    const response4 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: '[\"foo\", \"hello\"]',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    ok(response4.data.results[0].objectId, 'expected objectId to be set');\n    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response4.data.results[0].foo).toBeUndefined();\n    expect(response4.data.results[0].hello).toBeUndefined();\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exclude keys with select same key","suites":["Parse.Query testing"],"line":3579,"updatePoint":{"line":3579,"column":39,"index":116978},"code":"  it('exclude keys with select same key', async () => {\n    const obj = new TestObject({\n      foo: 'baz',\n      hello: 'world'\n    });\n    await obj.save();\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: 'foo',\n        excludeKeys: 'foo',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBeUndefined();\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exclude keys with select different key","suites":["Parse.Query testing"],"line":3599,"updatePoint":{"line":3599,"column":44,"index":117534},"code":"  it('exclude keys with select different key', async () => {\n    const obj = new TestObject({\n      foo: 'baz',\n      hello: 'world'\n    });\n    await obj.save();\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: 'foo,hello',\n        excludeKeys: 'foo',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exclude keys with include same key","suites":["Parse.Query testing"],"line":3619,"updatePoint":{"line":3619,"column":40,"index":118090},"code":"  it('exclude keys with include same key', async () => {\n    const pointer = new TestObject();\n    await pointer.save();\n    const obj = new TestObject({\n      child: pointer,\n      hello: 'world'\n    });\n    await obj.save();\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        include: 'child',\n        excludeKeys: 'child',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    expect(response.data.results[0].child).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exclude keys with include different key","suites":["Parse.Query testing"],"line":3641,"updatePoint":{"line":3641,"column":45,"index":118722},"code":"  it('exclude keys with include different key', async () => {\n    const pointer = new TestObject();\n    await pointer.save();\n    const obj = new TestObject({\n      child1: pointer,\n      child2: pointer,\n      hello: 'world'\n    });\n    await obj.save();\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        include: 'child1,child2',\n        excludeKeys: 'child1',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    expect(response.data.results[0].child1).toBeUndefined();\n    expect(response.data.results[0].child2.objectId).toEqual(pointer.id);\n    expect(response.data.results[0].hello).toBe('world');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exclude keys with includeAll","suites":["Parse.Query testing"],"line":3665,"updatePoint":{"line":3665,"column":34,"index":119451},"code":"  it('exclude keys with includeAll', async () => {\n    const pointer = new TestObject();\n    await pointer.save();\n    const obj = new TestObject({\n      child1: pointer,\n      child2: pointer,\n      hello: 'world'\n    });\n    await obj.save();\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        includeAll: true,\n        excludeKeys: 'child1',\n        where: JSON.stringify({\n          objectId: obj.id\n        })\n      },\n      headers: masterKeyHeaders\n    });\n    expect(response.data.results[0].child).toBeUndefined();\n    expect(response.data.results[0].child2.objectId).toEqual(pointer.id);\n    expect(response.data.results[0].hello).toBe('world');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"select keys with each query","suites":["Parse.Query testing"],"line":3689,"updatePoint":{"line":3689,"column":33,"index":120170},"code":"  it('select keys with each query', function (done) {\n    const obj = new TestObject({\n      foo: 'baz',\n      bar: 1\n    });\n    obj.save().then(function () {\n      obj._clearServerData();\n      const query = new Parse.Query(TestObject);\n      query.select('foo');\n      query.each(function (result) {\n        ok(result.id, 'expected object id to be set');\n        ok(result.createdAt, 'expected object createdAt to be set');\n        ok(result.updatedAt, 'expected object updatedAt to be set');\n        ok(!result.dirty(), 'expected result not to be dirty');\n        strictEqual(result.get('foo'), 'baz');\n        strictEqual(result.get('bar'), undefined, 'expected \"bar\" field to be unset');\n      }).then(function () {\n        done();\n      }, function (err) {\n        jfail(err);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"notEqual with array of pointers","suites":["Parse.Query testing"],"line":3713,"updatePoint":{"line":3713,"column":37,"index":120998},"code":"  it('notEqual with array of pointers', done => {\n    const children = [];\n    const parents = [];\n    const promises = [];\n    for (let i = 0; i < 2; i++) {\n      const proc = iter => {\n        const child = new Parse.Object('Child');\n        children.push(child);\n        const parent = new Parse.Object('Parent');\n        parents.push(parent);\n        promises.push(child.save().then(() => {\n          parents[iter].set('child', [children[iter]]);\n          return parents[iter].save();\n        }));\n      };\n      proc(i);\n    }\n    Promise.all(promises).then(() => {\n      const query = new Parse.Query('Parent');\n      query.notEqualTo('child', children[0]);\n      return query.find();\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      expect(results[0].id).toEqual(parents[1].id);\n      done();\n    }).catch(error => {\n      console.log(error);\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query within dictionary","suites":["Parse.Query testing"],"line":3757,"updatePoint":{"line":3757,"column":29,"index":122357},"code":"  it('query within dictionary', done => {\n    const promises = [];\n    for (let i = 0; i < 2; i++) {\n      const proc = iter => {\n        const obj = new Parse.Object('TestObject');\n        obj.set('aDict', {\n          x: iter + 1,\n          y: iter + 2\n        });\n        promises.push(obj.save());\n      };\n      proc(i);\n    }\n    Promise.all(promises).then(() => {\n      const query = new Parse.Query('TestObject');\n      query.equalTo('aDict.x', 1);\n      return query.find();\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      done();\n    }, error => {\n      console.log(error);\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"supports include on the wrong key type (#2262)","suites":["Parse.Query testing"],"line":3781,"updatePoint":{"line":3781,"column":52,"index":123001},"code":"  it('supports include on the wrong key type (#2262)', function (done) {\n    const childObject = new Parse.Object('TestChildObject');\n    childObject.set('hello', 'world');\n    childObject.save().then(() => {\n      const obj = new Parse.Object('TestObject');\n      obj.set('foo', 'bar');\n      obj.set('child', childObject);\n      return obj.save();\n    }).then(() => {\n      const q = new Parse.Query('TestObject');\n      q.include('child');\n      q.include('child.parent');\n      q.include('createdAt');\n      q.include('createdAt.createdAt');\n      return q.find();\n    }).then(objs => {\n      expect(objs.length).toBe(1);\n      expect(objs[0].get('child').get('hello')).toEqual('world');\n      expect(objs[0].createdAt instanceof Date).toBe(true);\n      done();\n    }, () => {\n      fail('should not fail');\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query match on array with single object","suites":["Parse.Query testing"],"line":3806,"updatePoint":{"line":3806,"column":45,"index":123834},"code":"  it('query match on array with single object', done => {\n    const target = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: 'abc123'\n    };\n    const obj = new Parse.Object('TestObject');\n    obj.set('someObjs', [target]);\n    obj.save().then(() => {\n      const query = new Parse.Query('TestObject');\n      query.equalTo('someObjs', target);\n      return query.find();\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      done();\n    }, error => {\n      console.log(error);\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query match on array with multiple objects","suites":["Parse.Query testing"],"line":3825,"updatePoint":{"line":3825,"column":48,"index":124372},"code":"  it('query match on array with multiple objects', done => {\n    const target1 = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: 'abc'\n    };\n    const target2 = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: '123'\n    };\n    const obj = new Parse.Object('TestObject');\n    obj.set('someObjs', [target1, target2]);\n    obj.save().then(() => {\n      const query = new Parse.Query('TestObject');\n      query.equalTo('someObjs', target1);\n      return query.find();\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      done();\n    }, error => {\n      console.log(error);\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query should not match on array when searching for null","suites":["Parse.Query testing"],"line":3849,"updatePoint":{"line":3849,"column":61,"index":125039},"code":"  it('query should not match on array when searching for null', done => {\n    const target = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: '123'\n    };\n    const obj = new Parse.Object('TestObject');\n    obj.set('someKey', 'someValue');\n    obj.set('someObjs', [target]);\n    obj.save().then(() => {\n      const query = new Parse.Query('TestObject');\n      query.equalTo('someKey', 'someValue');\n      query.equalTo('someObjs', null);\n      return query.find();\n    }).then(results => {\n      expect(results.length).toEqual(0);\n      done();\n    }, error => {\n      console.log(error);\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should properly interpret a query v1","suites":["Parse.Query testing"],"line":3872,"updatePoint":{"line":3872,"column":42,"index":125659},"code":"  it('should properly interpret a query v1', done => {\n    const query = new Parse.Query('C1');\n    const auxQuery = new Parse.Query('C1');\n    query.matchesKeyInQuery('A1', 'A2', auxQuery);\n    query.include('A3');\n    query.include('A2');\n    query.find().then(() => {\n      done();\n    }, err => {\n      jfail(err);\n      fail('should not failt');\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should properly interpret a query v2","suites":["Parse.Query testing"],"line":3886,"updatePoint":{"line":3886,"column":42,"index":126038},"code":"  it('should properly interpret a query v2', done => {\n    const user = new Parse.User();\n    user.set('username', 'foo');\n    user.set('password', 'bar');\n    return user.save().then(user => {\n      const objIdQuery = new Parse.Query('_User').equalTo('objectId', user.id);\n      const blockedUserQuery = user.relation('blockedUsers').query();\n      const aResponseQuery = new Parse.Query('MatchRelationshipActivityResponse');\n      aResponseQuery.equalTo('userA', user);\n      aResponseQuery.equalTo('userAResponse', 1);\n      const bResponseQuery = new Parse.Query('MatchRelationshipActivityResponse');\n      bResponseQuery.equalTo('userB', user);\n      bResponseQuery.equalTo('userBResponse', 1);\n      const matchOr = Parse.Query.or(aResponseQuery, bResponseQuery);\n      const matchRelationshipA = new Parse.Query('_User');\n      matchRelationshipA.matchesKeyInQuery('objectId', 'userAObjectId', matchOr);\n      const matchRelationshipB = new Parse.Query('_User');\n      matchRelationshipB.matchesKeyInQuery('objectId', 'userBObjectId', matchOr);\n      const orQuery = Parse.Query.or(objIdQuery, blockedUserQuery, matchRelationshipA, matchRelationshipB);\n      const query = new Parse.Query('_User');\n      query.doesNotMatchQuery('objectId', orQuery);\n      return query.find();\n    }).then(() => {\n      done();\n    }, err => {\n      jfail(err);\n      fail('should not fail');\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should match a key in an array (#3195)","suites":["Parse.Query testing"],"line":3916,"updatePoint":{"line":3916,"column":44,"index":127452},"code":"  it('should match a key in an array (#3195)', function (done) {\n    const AuthorObject = Parse.Object.extend('Author');\n    const GroupObject = Parse.Object.extend('Group');\n    const PostObject = Parse.Object.extend('Post');\n    return new AuthorObject().save().then(user => {\n      const post = new PostObject({\n        author: user\n      });\n      const group = new GroupObject({\n        members: [user]\n      });\n      return Promise.all([post.save(), group.save()]);\n    }).then(results => {\n      const p = results[0];\n      return new Parse.Query(PostObject).matchesKeyInQuery('author', 'members', new Parse.Query(GroupObject)).find().then(r => {\n        expect(r.length).toEqual(1);\n        if (r.length > 0) {\n          expect(r[0].id).toEqual(p.id);\n        }\n        done();\n      }, done.fail);\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should find objects with array of pointers","suites":["Parse.Query testing"],"line":3939,"updatePoint":{"line":3939,"column":48,"index":128278},"code":"  it('should find objects with array of pointers', done => {\n    const objects = [];\n    while (objects.length != 5) {\n      const object = new Parse.Object('ContainedObject');\n      object.set('index', objects.length);\n      objects.push(object);\n    }\n    Parse.Object.saveAll(objects).then(objects => {\n      const container = new Parse.Object('Container');\n      const pointers = objects.map(obj => {\n        return {\n          __type: 'Pointer',\n          className: 'ContainedObject',\n          objectId: obj.id\n        };\n      });\n      container.set('objects', pointers);\n      const container2 = new Parse.Object('Container');\n      container2.set('objects', pointers.slice(2, 3));\n      return Parse.Object.saveAll([container, container2]);\n    }).then(() => {\n      const inQuery = new Parse.Query('ContainedObject');\n      inQuery.greaterThanOrEqualTo('index', 1);\n      const query = new Parse.Query('Container');\n      query.matchesQuery('objects', inQuery);\n      return query.find();\n    }).then(results => {\n      if (results) {\n        expect(results.length).toBe(2);\n      }\n      done();\n    }).catch(err => {\n      jfail(err);\n      fail('should not fail');\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query with two OR subqueries (regression test #1259)","suites":["Parse.Query testing"],"line":3976,"updatePoint":{"line":3976,"column":58,"index":129496},"code":"  it('query with two OR subqueries (regression test #1259)', done => {\n    const relatedObject = new Parse.Object('Class2');\n    relatedObject.save().then(relatedObject => {\n      const anObject = new Parse.Object('Class1');\n      const relation = anObject.relation('relation');\n      relation.add(relatedObject);\n      return anObject.save();\n    }).then(anObject => {\n      const q1 = anObject.relation('relation').query();\n      q1.doesNotExist('nonExistantKey1');\n      const q2 = anObject.relation('relation').query();\n      q2.doesNotExist('nonExistantKey2');\n      Parse.Query.or(q1, q2).find().then(results => {\n        expect(results.length).toEqual(1);\n        if (results.length == 1) {\n          expect(results[0].objectId).toEqual(q1.objectId);\n        }\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"objectId containedIn with multiple large array","suites":["Parse.Query testing"],"line":3997,"updatePoint":{"line":3997,"column":52,"index":130298},"code":"  it('objectId containedIn with multiple large array', done => {\n    const obj = new Parse.Object('MyClass');\n    obj.save().then(obj => {\n      const longListOfStrings = [];\n      for (let i = 0; i < 130; i++) {\n        longListOfStrings.push(i.toString());\n      }\n      longListOfStrings.push(obj.id);\n      const q = new Parse.Query('MyClass');\n      q.containedIn('objectId', longListOfStrings);\n      q.containedIn('objectId', longListOfStrings);\n      return q.find();\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containedIn with pointers should work with string array","suites":["Parse.Query testing"],"line":4014,"updatePoint":{"line":4014,"column":61,"index":130877},"code":"  it('containedIn with pointers should work with string array', done => {\n    const obj = new Parse.Object('MyClass');\n    const child = new Parse.Object('Child');\n    child.save().then(() => {\n      obj.set('child', child);\n      return obj.save();\n    }).then(() => {\n      const objs = [];\n      for (let i = 0; i < 10; i++) {\n        objs.push(new Parse.Object('MyClass'));\n      }\n      return Parse.Object.saveAll(objs);\n    }).then(() => {\n      const query = new Parse.Query('MyClass');\n      query.containedIn('child', [child.id]);\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(1);\n    }).then(done).catch(done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"containedIn with pointers should work with string array, with many objects","suites":["Parse.Query testing"],"line":4034,"updatePoint":{"line":4034,"column":80,"index":131569},"code":"  it('containedIn with pointers should work with string array, with many objects', done => {\n    const objs = [];\n    const children = [];\n    for (let i = 0; i < 10; i++) {\n      const obj = new Parse.Object('MyClass');\n      const child = new Parse.Object('Child');\n      objs.push(obj);\n      children.push(child);\n    }\n    Parse.Object.saveAll(children).then(() => {\n      return Parse.Object.saveAll(objs.map((obj, i) => {\n        obj.set('child', children[i]);\n        return obj;\n      }));\n    }).then(() => {\n      const query = new Parse.Query('MyClass');\n      const subset = children.slice(0, 5).map(child => {\n        return child.id;\n      });\n      query.containedIn('child', subset);\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(5);\n    }).then(done).catch(done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"include for specific object","suites":["Parse.Query testing"],"line":4059,"updatePoint":{"line":4059,"column":33,"index":132355},"code":"  it('include for specific object', function (done) {\n    const child = new Parse.Object('Child');\n    const parent = new Parse.Object('Parent');\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function (response) {\n      const savedParent = response[1];\n      const parentQuery = new Parse.Query('Parent');\n      parentQuery.include('child');\n      parentQuery.get(savedParent.id).then(function (parentObj) {\n        const childPointer = parentObj.get('child');\n        ok(childPointer);\n        equal(childPointer.get('foo'), 'bar');\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"select keys for specific object","suites":["Parse.Query testing"],"line":4076,"updatePoint":{"line":4076,"column":37,"index":132995},"code":"  it('select keys for specific object', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    Foobar.set('foo', 'bar');\n    Foobar.set('fizz', 'buzz');\n    Foobar.save().then(function (savedFoobar) {\n      const foobarQuery = new Parse.Query('Foobar');\n      foobarQuery.select('fizz');\n      foobarQuery.get(savedFoobar.id).then(function (foobarObj) {\n        equal(foobarObj.get('fizz'), 'buzz');\n        equal(foobarObj.get('foo'), undefined);\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"select nested keys (issue #1567)","suites":["Parse.Query testing"],"line":4090,"updatePoint":{"line":4090,"column":38,"index":133498},"code":"  it('select nested keys (issue #1567)', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    BarBaz.set('key', 'value');\n    BarBaz.set('otherKey', 'value');\n    BarBaz.save().then(() => {\n      Foobar.set('foo', 'bar');\n      Foobar.set('fizz', 'buzz');\n      Foobar.set('barBaz', BarBaz);\n      return Foobar.save();\n    }).then(function (savedFoobar) {\n      const foobarQuery = new Parse.Query('Foobar');\n      foobarQuery.select(['fizz', 'barBaz.key']);\n      foobarQuery.get(savedFoobar.id).then(function (foobarObj) {\n        equal(foobarObj.get('fizz'), 'buzz');\n        equal(foobarObj.get('foo'), undefined);\n        if (foobarObj.has('barBaz')) {\n          equal(foobarObj.get('barBaz').get('key'), 'value');\n          equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n        } else {\n          fail('barBaz should be set');\n        }\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"select nested keys 2 level (issue #1567)","suites":["Parse.Query testing"],"line":4116,"updatePoint":{"line":4116,"column":46,"index":134466},"code":"  it('select nested keys 2 level (issue #1567)', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    Bazoo.save().then(() => {\n      BarBaz.set('key', 'value');\n      BarBaz.set('otherKey', 'value');\n      BarBaz.set('bazoo', Bazoo);\n      return BarBaz.save();\n    }).then(() => {\n      Foobar.set('foo', 'bar');\n      Foobar.set('fizz', 'buzz');\n      Foobar.set('barBaz', BarBaz);\n      return Foobar.save();\n    }).then(function (savedFoobar) {\n      const foobarQuery = new Parse.Query('Foobar');\n      foobarQuery.select(['fizz', 'barBaz.key', 'barBaz.bazoo.some']);\n      foobarQuery.get(savedFoobar.id).then(function (foobarObj) {\n        equal(foobarObj.get('fizz'), 'buzz');\n        equal(foobarObj.get('foo'), undefined);\n        if (foobarObj.has('barBaz')) {\n          equal(foobarObj.get('barBaz').get('key'), 'value');\n          equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n          equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');\n          equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);\n        } else {\n          fail('barBaz should be set');\n        }\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exclude nested keys","suites":["Parse.Query testing"],"line":4150,"updatePoint":{"line":4150,"column":25,"index":135792},"code":"  it('exclude nested keys', async () => {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    BarBaz.set('key', 'value');\n    BarBaz.set('otherKey', 'value');\n    await BarBaz.save();\n    Foobar.set('foo', 'bar');\n    Foobar.set('fizz', 'buzz');\n    Foobar.set('barBaz', BarBaz);\n    const savedFoobar = await Foobar.save();\n    const foobarQuery = new Parse.Query('Foobar');\n    foobarQuery.exclude(['foo', 'barBaz.otherKey']);\n    const foobarObj = await foobarQuery.get(savedFoobar.id);\n    equal(foobarObj.get('fizz'), 'buzz');\n    equal(foobarObj.get('foo'), undefined);\n    if (foobarObj.has('barBaz')) {\n      equal(foobarObj.get('barBaz').get('key'), 'value');\n      equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n    } else {\n      fail('barBaz should be set');\n    }\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"exclude nested keys 2 level","suites":["Parse.Query testing"],"line":4172,"updatePoint":{"line":4172,"column":33,"index":136641},"code":"  it('exclude nested keys 2 level', async () => {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    await Bazoo.save();\n    BarBaz.set('key', 'value');\n    BarBaz.set('otherKey', 'value');\n    BarBaz.set('bazoo', Bazoo);\n    await BarBaz.save();\n    Foobar.set('foo', 'bar');\n    Foobar.set('fizz', 'buzz');\n    Foobar.set('barBaz', BarBaz);\n    const savedFoobar = await Foobar.save();\n    const foobarQuery = new Parse.Query('Foobar');\n    foobarQuery.exclude(['foo', 'barBaz.otherKey', 'barBaz.bazoo.otherSome']);\n    const foobarObj = await foobarQuery.get(savedFoobar.id);\n    equal(foobarObj.get('fizz'), 'buzz');\n    equal(foobarObj.get('foo'), undefined);\n    if (foobarObj.has('barBaz')) {\n      equal(foobarObj.get('barBaz').get('key'), 'value');\n      equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n      equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');\n      equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);\n    } else {\n      fail('barBaz should be set');\n    }\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"include with *","suites":["Parse.Query testing"],"line":4201,"updatePoint":{"line":4201,"column":20,"index":137824},"code":"  it('include with *', async () => {\n    const child1 = new TestObject({\n      foo: 'bar',\n      name: 'ac'\n    });\n    const child2 = new TestObject({\n      foo: 'baz',\n      name: 'flo'\n    });\n    const child3 = new TestObject({\n      foo: 'bad',\n      name: 'mo'\n    });\n    const parent = new Container({\n      child1,\n      child2,\n      child3\n    });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          objectId: parent.id\n        }),\n        include: '*'\n      }\n    });\n    const resp = await request(Object.assign({\n      url: Parse.serverURL + '/classes/Container'\n    }, options));\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"include with [\"*\"]","suites":["Parse.Query testing"],"line":4239,"updatePoint":{"line":4239,"column":24,"index":138819},"code":"  it('include with [\"*\"]', async () => {\n    const child1 = new TestObject({\n      foo: 'bar',\n      name: 'ac'\n    });\n    const child2 = new TestObject({\n      foo: 'baz',\n      name: 'flo'\n    });\n    const child3 = new TestObject({\n      foo: 'bad',\n      name: 'mo'\n    });\n    const parent = new Container({\n      child1,\n      child2,\n      child3\n    });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          objectId: parent.id\n        }),\n        include: '[\"*\"]'\n      }\n    });\n    const resp = await request(Object.assign({\n      url: Parse.serverURL + '/classes/Container'\n    }, options));\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"include with * overrides","suites":["Parse.Query testing"],"line":4277,"updatePoint":{"line":4277,"column":30,"index":139824},"code":"  it('include with * overrides', async () => {\n    const child1 = new TestObject({\n      foo: 'bar',\n      name: 'ac'\n    });\n    const child2 = new TestObject({\n      foo: 'baz',\n      name: 'flo'\n    });\n    const child3 = new TestObject({\n      foo: 'bad',\n      name: 'mo'\n    });\n    const parent = new Container({\n      child1,\n      child2,\n      child3\n    });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          objectId: parent.id\n        }),\n        include: 'child2,*'\n      }\n    });\n    const resp = await request(Object.assign({\n      url: Parse.serverURL + '/classes/Container'\n    }, options));\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"include with [\"*\"] overrides","suites":["Parse.Query testing"],"line":4315,"updatePoint":{"line":4315,"column":34,"index":140836},"code":"  it('include with [\"*\"] overrides', async () => {\n    const child1 = new TestObject({\n      foo: 'bar',\n      name: 'ac'\n    });\n    const child2 = new TestObject({\n      foo: 'baz',\n      name: 'flo'\n    });\n    const child3 = new TestObject({\n      foo: 'bad',\n      name: 'mo'\n    });\n    const parent = new Container({\n      child1,\n      child2,\n      child3\n    });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          objectId: parent.id\n        }),\n        include: '[\"child2\",\"*\"]'\n      }\n    });\n    const resp = await request(Object.assign({\n      url: Parse.serverURL + '/classes/Container'\n    }, options));\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"includeAll","suites":["Parse.Query testing"],"line":4353,"updatePoint":{"line":4353,"column":16,"index":141836},"code":"  it('includeAll', done => {\n    const child1 = new TestObject({\n      foo: 'bar',\n      name: 'ac'\n    });\n    const child2 = new TestObject({\n      foo: 'baz',\n      name: 'flo'\n    });\n    const child3 = new TestObject({\n      foo: 'bad',\n      name: 'mo'\n    });\n    const parent = new Container({\n      child1,\n      child2,\n      child3\n    });\n    Parse.Object.saveAll([parent, child1, child2, child3]).then(() => {\n      const options = Object.assign({}, masterKeyOptions, {\n        qs: {\n          where: JSON.stringify({\n            objectId: parent.id\n          }),\n          includeAll: true\n        }\n      });\n      return request(Object.assign({\n        url: Parse.serverURL + '/classes/Container'\n      }, options));\n    }).then(resp => {\n      const result = resp.data.results[0];\n      equal(result.child1.foo, 'bar');\n      equal(result.child2.foo, 'baz');\n      equal(result.child3.foo, 'bad');\n      equal(result.child1.name, 'ac');\n      equal(result.child2.name, 'flo');\n      equal(result.child3.name, 'mo');\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"include pointer and pointer array","suites":["Parse.Query testing"],"line":4394,"updatePoint":{"line":4394,"column":39,"index":142920},"code":"  it('include pointer and pointer array', function (done) {\n    const child = new TestObject();\n    const child2 = new TestObject();\n    child.set('foo', 'bar');\n    child2.set('hello', 'world');\n    Parse.Object.saveAll([child, child2]).then(function () {\n      const parent = new Container();\n      parent.set('child', child.toPointer());\n      parent.set('child2', [child2.toPointer()]);\n      parent.save().then(function () {\n        const query = new Parse.Query(Container);\n        query.include(['child', 'child2']);\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          const parentAgain = results[0];\n          const childAgain = parentAgain.get('child');\n          ok(childAgain);\n          equal(childAgain.get('foo'), 'bar');\n          const child2Again = parentAgain.get('child2');\n          equal(child2Again.length, 1);\n          ok(child2Again);\n          equal(child2Again[0].get('hello'), 'world');\n          done();\n        });\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"include pointer and pointer array (keys switched)","suites":["Parse.Query testing"],"line":4421,"updatePoint":{"line":4421,"column":55,"index":143946},"code":"  it('include pointer and pointer array (keys switched)', function (done) {\n    const child = new TestObject();\n    const child2 = new TestObject();\n    child.set('foo', 'bar');\n    child2.set('hello', 'world');\n    Parse.Object.saveAll([child, child2]).then(function () {\n      const parent = new Container();\n      parent.set('child', child.toPointer());\n      parent.set('child2', [child2.toPointer()]);\n      parent.save().then(function () {\n        const query = new Parse.Query(Container);\n        query.include(['child2', 'child']);\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          const parentAgain = results[0];\n          const childAgain = parentAgain.get('child');\n          ok(childAgain);\n          equal(childAgain.get('foo'), 'bar');\n          const child2Again = parentAgain.get('child2');\n          equal(child2Again.length, 1);\n          ok(child2Again);\n          equal(child2Again[0].get('hello'), 'world');\n          done();\n        });\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"includeAll pointer and pointer array","suites":["Parse.Query testing"],"line":4448,"updatePoint":{"line":4448,"column":42,"index":144959},"code":"  it('includeAll pointer and pointer array', function (done) {\n    const child = new TestObject();\n    const child2 = new TestObject();\n    child.set('foo', 'bar');\n    child2.set('hello', 'world');\n    Parse.Object.saveAll([child, child2]).then(function () {\n      const parent = new Container();\n      parent.set('child', child.toPointer());\n      parent.set('child2', [child2.toPointer()]);\n      parent.save().then(function () {\n        const query = new Parse.Query(Container);\n        query.includeAll();\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          const parentAgain = results[0];\n          const childAgain = parentAgain.get('child');\n          ok(childAgain);\n          equal(childAgain.get('foo'), 'bar');\n          const child2Again = parentAgain.get('child2');\n          equal(child2Again.length, 1);\n          ok(child2Again);\n          equal(child2Again[0].get('hello'), 'world');\n          done();\n        });\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"select nested keys 2 level includeAll","suites":["Parse.Query testing"],"line":4475,"updatePoint":{"line":4475,"column":43,"index":145957},"code":"  it('select nested keys 2 level includeAll', done => {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n    const Tang = new Parse.Object('Tang');\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    Bazoo.save().then(() => {\n      BarBaz.set('key', 'value');\n      BarBaz.set('otherKey', 'value');\n      BarBaz.set('bazoo', Bazoo);\n      return BarBaz.save();\n    }).then(() => {\n      Tang.set('clan', 'wu');\n      return Tang.save();\n    }).then(() => {\n      Foobar.set('foo', 'bar');\n      Foobar.set('fizz', 'buzz');\n      Foobar.set('barBaz', BarBaz);\n      Foobar.set('group', Tang);\n      return Foobar.save();\n    }).then(savedFoobar => {\n      const options = Object.assign({\n        url: Parse.serverURL + '/classes/Foobar'\n      }, masterKeyOptions, {\n        qs: {\n          where: JSON.stringify({\n            objectId: savedFoobar.id\n          }),\n          includeAll: true,\n          keys: 'fizz,barBaz.key,barBaz.bazoo.some'\n        }\n      });\n      return request(options);\n    }).then(resp => {\n      const result = resp.data.results[0];\n      equal(result.group.clan, 'wu');\n      equal(result.foo, undefined);\n      equal(result.fizz, 'buzz');\n      equal(result.barBaz.key, 'value');\n      equal(result.barBaz.otherKey, undefined);\n      equal(result.barBaz.bazoo.some, 'thing');\n      equal(result.barBaz.bazoo.otherSome, undefined);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"select nested keys 2 level without include (issue #3185)","suites":["Parse.Query testing"],"line":4521,"updatePoint":{"line":4521,"column":62,"index":147492},"code":"  it('select nested keys 2 level without include (issue #3185)', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    Bazoo.save().then(() => {\n      BarBaz.set('key', 'value');\n      BarBaz.set('otherKey', 'value');\n      BarBaz.set('bazoo', Bazoo);\n      return BarBaz.save();\n    }).then(() => {\n      Foobar.set('foo', 'bar');\n      Foobar.set('fizz', 'buzz');\n      Foobar.set('barBaz', BarBaz);\n      return Foobar.save();\n    }).then(function (savedFoobar) {\n      const foobarQuery = new Parse.Query('Foobar');\n      foobarQuery.select(['fizz', 'barBaz.key', 'barBaz.bazoo.some']);\n      return foobarQuery.get(savedFoobar.id);\n    }).then(foobarObj => {\n      equal(foobarObj.get('fizz'), 'buzz');\n      equal(foobarObj.get('foo'), undefined);\n      if (foobarObj.has('barBaz')) {\n        equal(foobarObj.get('barBaz').get('key'), 'value');\n        equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n        if (foobarObj.get('barBaz').has('bazoo')) {\n          equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');\n          equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);\n        } else {\n          fail('bazoo should be set');\n        }\n      } else {\n        fail('barBaz should be set');\n      }\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"properly handles nested ors","suites":["Parse.Query testing"],"line":4559,"updatePoint":{"line":4559,"column":33,"index":148923},"code":"  it('properly handles nested ors', function (done) {\n    const objects = [];\n    while (objects.length != 4) {\n      const obj = new Parse.Object('Object');\n      obj.set('x', objects.length);\n      objects.push(obj);\n    }\n    Parse.Object.saveAll(objects).then(() => {\n      const q0 = new Parse.Query('Object');\n      q0.equalTo('x', 0);\n      const q1 = new Parse.Query('Object');\n      q1.equalTo('x', 1);\n      const q2 = new Parse.Query('Object');\n      q2.equalTo('x', 2);\n      const or01 = Parse.Query.or(q0, q1);\n      return Parse.Query.or(or01, q2).find();\n    }).then(results => {\n      expect(results.length).toBe(3);\n      done();\n    }).catch(error => {\n      fail('should not fail');\n      jfail(error);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should not depend on parameter order #3169","suites":["Parse.Query testing"],"line":4584,"updatePoint":{"line":4584,"column":48,"index":149689},"code":"  it('should not depend on parameter order #3169', function (done) {\n    const score1 = new Parse.Object('Score', {\n      scoreId: '1'\n    });\n    const score2 = new Parse.Object('Score', {\n      scoreId: '2'\n    });\n    const game1 = new Parse.Object('Game', {\n      gameId: '1'\n    });\n    const game2 = new Parse.Object('Game', {\n      gameId: '2'\n    });\n    Parse.Object.saveAll([score1, score2, game1, game2]).then(() => {\n      game1.set('score', [score1]);\n      game2.set('score', [score2]);\n      return Parse.Object.saveAll([game1, game2]);\n    }).then(() => {\n      const where = {\n        score: {\n          objectId: score1.id,\n          className: 'Score',\n          __type: 'Pointer'\n        }\n      };\n      return request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/Game',\n        body: {\n          where,\n          _method: 'GET'\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json'\n        }\n      });\n    }).then(response => {\n      const results = response.data;\n      expect(results.results.length).toBe(1);\n      done();\n    }, res => done.fail(res.data));\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should not interfere with has when using select on field with undefined value #3999","suites":["Parse.Query testing"],"line":4628,"updatePoint":{"line":4628,"column":89,"index":150976},"code":"  it('should not interfere with has when using select on field with undefined value #3999', done => {\n    const obj1 = new Parse.Object('TestObject');\n    const obj2 = new Parse.Object('OtherObject');\n    obj2.set('otherField', 1);\n    obj1.set('testPointerField', obj2);\n    obj1.set('shouldBe', true);\n    const obj3 = new Parse.Object('TestObject');\n    obj3.set('shouldBe', false);\n    Parse.Object.saveAll([obj1, obj3]).then(() => {\n      const query = new Parse.Query('TestObject');\n      query.include('testPointerField');\n      query.select(['testPointerField', 'testPointerField.otherField', 'shouldBe']);\n      return query.find();\n    }).then(results => {\n      results.forEach(result => {\n        equal(result.has('testPointerField'), result.get('shouldBe'));\n      });\n      done();\n    }).catch(done.fail);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should handle relative times correctly","suites":["Parse.Query testing"],"line":4648,"updatePoint":{"line":4648,"column":44,"index":151758},"code":"  it('should handle relative times correctly', async () => {\n    const now = Date.now();\n    const obj1 = new Parse.Object('MyCustomObject', {\n      name: 'obj1',\n      ttl: new Date(now + 2 * 24 * 60 * 60 * 1000) // 2 days from now\n    });\n\n    const obj2 = new Parse.Object('MyCustomObject', {\n      name: 'obj2',\n      ttl: new Date(now - 2 * 24 * 60 * 60 * 1000) // 2 days ago\n    });\n\n    await Parse.Object.saveAll([obj1, obj2]);\n    const q1 = new Parse.Query('MyCustomObject');\n    q1.greaterThan('ttl', {\n      $relativeTime: 'in 1 day'\n    });\n    const results1 = await q1.find({\n      useMasterKey: true\n    });\n    expect(results1.length).toBe(1);\n    const q2 = new Parse.Query('MyCustomObject');\n    q2.greaterThan('ttl', {\n      $relativeTime: '1 day ago'\n    });\n    const results2 = await q2.find({\n      useMasterKey: true\n    });\n    expect(results2.length).toBe(1);\n    const q3 = new Parse.Query('MyCustomObject');\n    q3.lessThan('ttl', {\n      $relativeTime: '5 days ago'\n    });\n    const results3 = await q3.find({\n      useMasterKey: true\n    });\n    expect(results3.length).toBe(0);\n    const q4 = new Parse.Query('MyCustomObject');\n    q4.greaterThan('ttl', {\n      $relativeTime: '3 days ago'\n    });\n    const results4 = await q4.find({\n      useMasterKey: true\n    });\n    expect(results4.length).toBe(2);\n    const q5 = new Parse.Query('MyCustomObject');\n    q5.greaterThan('ttl', {\n      $relativeTime: 'now'\n    });\n    const results5 = await q5.find({\n      useMasterKey: true\n    });\n    expect(results5.length).toBe(1);\n    const q6 = new Parse.Query('MyCustomObject');\n    q6.greaterThan('ttl', {\n      $relativeTime: 'now'\n    });\n    q6.lessThan('ttl', {\n      $relativeTime: 'in 1 day'\n    });\n    const results6 = await q6.find({\n      useMasterKey: true\n    });\n    expect(results6.length).toBe(0);\n    const q7 = new Parse.Query('MyCustomObject');\n    q7.greaterThan('ttl', {\n      $relativeTime: '1 year 3 weeks ago'\n    });\n    const results7 = await q7.find({\n      useMasterKey: true\n    });\n    expect(results7.length).toBe(2);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should error on invalid relative time","suites":["Parse.Query testing"],"line":4721,"updatePoint":{"line":4721,"column":43,"index":153841},"code":"  it('should error on invalid relative time', async () => {\n    const obj1 = new Parse.Object('MyCustomObject', {\n      name: 'obj1',\n      ttl: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000) // 2 days from now\n    });\n\n    await obj1.save({\n      useMasterKey: true\n    });\n    const q = new Parse.Query('MyCustomObject');\n    q.greaterThan('ttl', {\n      $relativeTime: '-12 bananas ago'\n    });\n    try {\n      await q.find({\n        useMasterKey: true\n      });\n      fail('Should have thrown error');\n    } catch (error) {\n      expect(error.code).toBe(Parse.Error.INVALID_JSON);\n    }\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should error when using $relativeTime on non-Date field","suites":["Parse.Query testing"],"line":4743,"updatePoint":{"line":4743,"column":61,"index":154456},"code":"  it('should error when using $relativeTime on non-Date field', async () => {\n    const obj1 = new Parse.Object('MyCustomObject', {\n      name: 'obj1',\n      nonDateField: 'abcd',\n      ttl: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000) // 2 days from now\n    });\n\n    await obj1.save({\n      useMasterKey: true\n    });\n    const q = new Parse.Query('MyCustomObject');\n    q.greaterThan('nonDateField', {\n      $relativeTime: '1 day ago'\n    });\n    try {\n      await q.find({\n        useMasterKey: true\n      });\n      fail('Should have thrown error');\n    } catch (error) {\n      expect(error.code).toBe(Parse.Error.INVALID_JSON);\n    }\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should match complex structure with dot notation when using matchesKeyInQuery","suites":["Parse.Query testing"],"line":4766,"updatePoint":{"line":4766,"column":83,"index":155124},"code":"  it('should match complex structure with dot notation when using matchesKeyInQuery', function (done) {\n    const group1 = new Parse.Object('Group', {\n      name: 'Group #1'\n    });\n    const group2 = new Parse.Object('Group', {\n      name: 'Group #2'\n    });\n    Parse.Object.saveAll([group1, group2]).then(() => {\n      const role1 = new Parse.Object('Role', {\n        name: 'Role #1',\n        type: 'x',\n        belongsTo: group1\n      });\n      const role2 = new Parse.Object('Role', {\n        name: 'Role #2',\n        type: 'y',\n        belongsTo: group1\n      });\n      return Parse.Object.saveAll([role1, role2]);\n    }).then(() => {\n      const rolesOfTypeX = new Parse.Query('Role');\n      rolesOfTypeX.equalTo('type', 'x');\n      const groupsWithRoleX = new Parse.Query('Group');\n      groupsWithRoleX.matchesKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n      groupsWithRoleX.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), group1.get('name'));\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should match complex structure with dot notation when using doesNotMatchKeyInQuery","suites":["Parse.Query testing"],"line":4797,"updatePoint":{"line":4797,"column":88,"index":156196},"code":"  it('should match complex structure with dot notation when using doesNotMatchKeyInQuery', function (done) {\n    const group1 = new Parse.Object('Group', {\n      name: 'Group #1'\n    });\n    const group2 = new Parse.Object('Group', {\n      name: 'Group #2'\n    });\n    Parse.Object.saveAll([group1, group2]).then(() => {\n      const role1 = new Parse.Object('Role', {\n        name: 'Role #1',\n        type: 'x',\n        belongsTo: group1\n      });\n      const role2 = new Parse.Object('Role', {\n        name: 'Role #2',\n        type: 'y',\n        belongsTo: group1\n      });\n      return Parse.Object.saveAll([role1, role2]);\n    }).then(() => {\n      const rolesOfTypeX = new Parse.Query('Role');\n      rolesOfTypeX.equalTo('type', 'x');\n      const groupsWithRoleX = new Parse.Query('Group');\n      groupsWithRoleX.doesNotMatchKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n      groupsWithRoleX.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), group2.get('name'));\n        done();\n      });\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should not throw error with undefined dot notation when using matchesKeyInQuery","suites":["Parse.Query testing"],"line":4828,"updatePoint":{"line":4828,"column":85,"index":157270},"code":"  it('should not throw error with undefined dot notation when using matchesKeyInQuery', async () => {\n    const group = new Parse.Object('Group', {\n      name: 'Group #1'\n    });\n    await group.save();\n    const role1 = new Parse.Object('Role', {\n      name: 'Role #1',\n      type: 'x',\n      belongsTo: group\n    });\n    const role2 = new Parse.Object('Role', {\n      name: 'Role #2',\n      type: 'y',\n      belongsTo: undefined\n    });\n    await Parse.Object.saveAll([role1, role2]);\n    const rolesOfTypeX = new Parse.Query('Role');\n    rolesOfTypeX.equalTo('type', 'x');\n    const groupsWithRoleX = new Parse.Query('Group');\n    groupsWithRoleX.matchesKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n    const results = await groupsWithRoleX.find();\n    equal(results.length, 1);\n    equal(results[0].get('name'), group.get('name'));\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should not throw error with undefined dot notation when using doesNotMatchKeyInQuery","suites":["Parse.Query testing"],"line":4852,"updatePoint":{"line":4852,"column":90,"index":158132},"code":"  it('should not throw error with undefined dot notation when using doesNotMatchKeyInQuery', async () => {\n    const group1 = new Parse.Object('Group', {\n      name: 'Group #1'\n    });\n    const group2 = new Parse.Object('Group', {\n      name: 'Group #2'\n    });\n    await Parse.Object.saveAll([group1, group2]);\n    const role1 = new Parse.Object('Role', {\n      name: 'Role #1',\n      type: 'x',\n      belongsTo: group1\n    });\n    const role2 = new Parse.Object('Role', {\n      name: 'Role #2',\n      type: 'y',\n      belongsTo: undefined\n    });\n    await Parse.Object.saveAll([role1, role2]);\n    const rolesOfTypeX = new Parse.Query('Role');\n    rolesOfTypeX.equalTo('type', 'x');\n    const groupsWithRoleX = new Parse.Query('Group');\n    groupsWithRoleX.doesNotMatchKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n    const results = await groupsWithRoleX.find();\n    equal(results.length, 1);\n    equal(results[0].get('name'), group2.get('name'));\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"withJSON supports geoWithin.centerSphere","suites":["Parse.Query testing"],"line":4879,"updatePoint":{"line":4879,"column":46,"index":159062},"code":"  it('withJSON supports geoWithin.centerSphere', done => {\n    const inbound = new Parse.GeoPoint(1.5, 1.5);\n    const onbound = new Parse.GeoPoint(10, 10);\n    const outbound = new Parse.GeoPoint(20, 20);\n    const obj1 = new Parse.Object('TestObject', {\n      location: inbound\n    });\n    const obj2 = new Parse.Object('TestObject', {\n      location: onbound\n    });\n    const obj3 = new Parse.Object('TestObject', {\n      location: outbound\n    });\n    const center = new Parse.GeoPoint(0, 0);\n    const distanceInKilometers = 1569 + 1; // 1569km is the approximate distance between {0, 0} and {10, 10}.\n    Parse.Object.saveAll([obj1, obj2, obj3]).then(() => {\n      const q = new Parse.Query(TestObject);\n      const jsonQ = q.toJSON();\n      jsonQ.where.location = {\n        $geoWithin: {\n          $centerSphere: [center, distanceInKilometers / 6371.0]\n        }\n      };\n      q.withJSON(jsonQ);\n      return q.find();\n    }).then(results => {\n      equal(results.length, 2);\n      const q = new Parse.Query(TestObject);\n      const jsonQ = q.toJSON();\n      jsonQ.where.location = {\n        $geoWithin: {\n          $centerSphere: [[0, 0], distanceInKilometers / 6371.0]\n        }\n      };\n      q.withJSON(jsonQ);\n      return q.find();\n    }).then(results => {\n      equal(results.length, 2);\n      done();\n    }).catch(error => {\n      fail(error);\n      done();\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"withJSON with geoWithin.centerSphere fails without parameters","suites":["Parse.Query testing"],"line":4923,"updatePoint":{"line":4923,"column":67,"index":160472},"code":"  it('withJSON with geoWithin.centerSphere fails without parameters', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: []\n      }\n    };\n    q.withJSON(jsonQ);\n    q.find().then(done.fail).catch(e => expect(e.code).toBe(Parse.Error.INVALID_JSON)).then(done);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"withJSON with geoWithin.centerSphere fails with invalid distance","suites":["Parse.Query testing"],"line":4934,"updatePoint":{"line":4934,"column":70,"index":160846},"code":"  it('withJSON with geoWithin.centerSphere fails with invalid distance', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: [[0, 0], 'invalid_distance']\n      }\n    };\n    q.withJSON(jsonQ);\n    q.find().then(done.fail).catch(e => expect(e.code).toBe(Parse.Error.INVALID_JSON)).then(done);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"withJSON with geoWithin.centerSphere fails with invalid coordinate","suites":["Parse.Query testing"],"line":4945,"updatePoint":{"line":4945,"column":72,"index":161248},"code":"  it('withJSON with geoWithin.centerSphere fails with invalid coordinate', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: [[-190, -190], 1]\n      }\n    };\n    q.withJSON(jsonQ);\n    q.find().then(done.fail).catch(() => done());\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"withJSON with geoWithin.centerSphere fails with invalid geo point","suites":["Parse.Query testing"],"line":4956,"updatePoint":{"line":4956,"column":71,"index":161589},"code":"  it('withJSON with geoWithin.centerSphere fails with invalid geo point', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: [{\n          longitude: 0,\n          dummytude: 0\n        }, 1]\n      }\n    };\n    q.withJSON(jsonQ);\n    q.find().then(done.fail).catch(() => done());\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can add new config to existing config","suites":["Parse.Query testing"],"line":4970,"updatePoint":{"line":4970,"column":43,"index":161948},"code":"  it('can add new config to existing config', async () => {\n    await request({\n      method: 'PUT',\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      body: {\n        params: {\n          files: [{\n            __type: 'File',\n            name: 'name',\n            url: 'http://url'\n          }]\n        }\n      },\n      headers: masterKeyHeaders\n    });\n    await request({\n      method: 'PUT',\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      body: {\n        params: {\n          newConfig: 'good'\n        }\n      },\n      headers: masterKeyHeaders\n    });\n    const result = await Parse.Config.get();\n    equal(result.get('files')[0].toJSON(), {\n      __type: 'File',\n      name: 'name',\n      url: 'http://url'\n    });\n    equal(result.get('newConfig'), 'good');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can set object type key","suites":["Parse.Query testing"],"line":5005,"updatePoint":{"line":5005,"column":29,"index":162743},"code":"  it('can set object type key', async () => {\n    const data = {\n      bar: true,\n      baz: 100\n    };\n    const object = new TestObject();\n    object.set('objectField', data);\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    let result = await query.get(object.id);\n    equal(result.get('objectField'), data);\n    object.set('objectField.baz', 50, {\n      ignoreValidation: true\n    });\n    await object.save();\n    result = await query.get(object.id);\n    equal(result.get('objectField'), {\n      bar: true,\n      baz: 50\n    });\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can update numeric array","suites":["Parse.Query testing"],"line":5026,"updatePoint":{"line":5026,"column":30,"index":163310},"code":"  it('can update numeric array', async () => {\n    const data1 = [0, 1.1, 1, -2, 3];\n    const data2 = [0, 1.1, 1, -2, 3, 4];\n    const obj1 = new TestObject();\n    obj1.set('array', data1);\n    await obj1.save();\n    equal(obj1.get('array'), data1);\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', obj1.id);\n    const result = await query.first();\n    equal(result.get('array'), data1);\n    result.set('array', data2);\n    equal(result.get('array'), data2);\n    await result.save();\n    equal(result.get('array'), data2);\n    const results = await query.find();\n    equal(results[0].get('array'), data2);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can update mixed array","suites":["Parse.Query testing"],"line":5044,"updatePoint":{"line":5044,"column":28,"index":163949},"code":"  it('can update mixed array', async () => {\n    const data1 = [0, 1.1, 'hello world', {\n      foo: 'bar'\n    }];\n    const data2 = [0, 1, {\n      foo: 'bar'\n    }, [], [1, 2, 'bar']];\n    const obj1 = new TestObject();\n    obj1.set('array', data1);\n    await obj1.save();\n    equal(obj1.get('array'), data1);\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', obj1.id);\n    const result = await query.first();\n    equal(result.get('array'), data1);\n    result.set('array', data2);\n    equal(result.get('array'), data2);\n    await result.save();\n    equal(result.get('array'), data2);\n    const results = await query.find();\n    equal(results[0].get('array'), data2);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can query regex with unicode","suites":["Parse.Query testing"],"line":5066,"updatePoint":{"line":5066,"column":34,"index":164655},"code":"  it('can query regex with unicode', async () => {\n    const object = new TestObject();\n    object.set('field', 'autoöo');\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    query.contains('field', 'autoöo');\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('field')).toBe('autoöo');\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"can update mixed array more than 100 elements","suites":["Parse.Query testing"],"line":5076,"updatePoint":{"line":5076,"column":51,"index":165040},"code":"  it('can update mixed array more than 100 elements', async () => {\n    const array = [0, 1.1, 'hello world', {\n      foo: 'bar'\n    }, null];\n    const obj = new TestObject({\n      array\n    });\n    await obj.save();\n    const query = new Parse.Query(TestObject);\n    const result = await query.get(obj.id);\n    equal(result.get('array').length, 5);\n    for (let i = 0; i < 100; i += 1) {\n      array.push(i);\n    }\n    obj.set('array', array);\n    await obj.save();\n    const results = await query.find();\n    equal(results[0].get('array').length, 105);\n  });","file":"ParseQuery.spec.js","skipped":false,"dir":"spec"},{"name":"todo: exclude keys with select key (sdk query get)","suites":["Parse.Query testing"],"line":5095,"updatePoint":{"line":5095,"column":57,"index":165608},"skipped":true,"code":"  xit('todo: exclude keys with select key (sdk query get)', async done => {\n    // there is some problem with js sdk caching\n\n    const obj = new TestObject({\n      foo: 'baz',\n      hello: 'world'\n    });\n    await obj.save();\n    const query = new Parse.Query('TestObject');\n    query.withJSON({\n      keys: 'hello',\n      excludeKeys: 'hello'\n    });\n    const object = await query.get(obj.id);\n    expect(object.get('foo')).toBeUndefined();\n    expect(object.get('hello')).toBeUndefined();\n    done();\n  });","file":"ParseQuery.spec.js","dir":"spec"},{"name":"simple add and remove relation","suites":["Parse.Relation testing"],"line":12,"updatePoint":{"line":12,"column":36,"index":321},"code":"  it('simple add and remove relation', done => {\n    const child = new ChildObject();\n    child.set('x', 2);\n    const parent = new ParentObject();\n    parent.set('x', 4);\n    const relation = parent.relation('child');\n    child.save().then(() => {\n      relation.add(child);\n      return parent.save();\n    }, e => {\n      fail(e);\n    }).then(() => {\n      return relation.query().find();\n    }).then(list => {\n      equal(list.length, 1, 'Should have gotten one element back');\n      equal(list[0].id, child.id, 'Should have gotten the right value');\n      ok(!parent.dirty('child'), 'The relation should not be dirty');\n      relation.remove(child);\n      return parent.save();\n    }).then(() => {\n      return relation.query().find();\n    }).then(list => {\n      equal(list.length, 0, 'Delete should have worked');\n      ok(!parent.dirty('child'), 'The relation should not be dirty');\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"query relation without schema","suites":["Parse.Relation testing"],"line":39,"updatePoint":{"line":39,"column":35,"index":1238},"code":"  it('query relation without schema', async () => {\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const childObjects = [];\n    for (let i = 0; i < 10; i++) {\n      childObjects.push(new ChildObject({\n        x: i\n      }));\n    }\n    await Parse.Object.saveAll(childObjects);\n    const ParentObject = Parse.Object.extend('ParentObject');\n    const parent = new ParentObject();\n    parent.set('x', 4);\n    let relation = parent.relation('child');\n    relation.add(childObjects[0]);\n    await parent.save();\n    const parentAgain = new ParentObject();\n    parentAgain.id = parent.id;\n    relation = parentAgain.relation('child');\n    const list = await relation.query().find();\n    equal(list.length, 1, 'Should have gotten one element back');\n    equal(list[0].id, childObjects[0].id, 'Should have gotten the right value');\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"relations are constructed right from query","suites":["Parse.Relation testing"],"line":61,"updatePoint":{"line":61,"column":48,"index":2098},"code":"  it('relations are constructed right from query', async () => {\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const childObjects = [];\n    for (let i = 0; i < 10; i++) {\n      childObjects.push(new ChildObject({\n        x: i\n      }));\n    }\n    await Parse.Object.saveAll(childObjects);\n    const ParentObject = Parse.Object.extend('ParentObject');\n    const parent = new ParentObject();\n    parent.set('x', 4);\n    const relation = parent.relation('child');\n    relation.add(childObjects[0]);\n    await parent.save();\n    const query = new Parse.Query(ParentObject);\n    const object = await query.get(parent.id);\n    const relationAgain = object.relation('child');\n    const list = await relationAgain.query().find();\n    equal(list.length, 1, 'Should have gotten one element back');\n    equal(list[0].id, childObjects[0].id, 'Should have gotten the right value');\n    ok(!parent.dirty('child'), 'The relation should not be dirty');\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"compound add and remove relation","suites":["Parse.Relation testing"],"line":84,"updatePoint":{"line":84,"column":38,"index":3049},"code":"  it('compound add and remove relation', done => {\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const childObjects = [];\n    for (let i = 0; i < 10; i++) {\n      childObjects.push(new ChildObject({\n        x: i\n      }));\n    }\n    let parent;\n    let relation;\n    Parse.Object.saveAll(childObjects).then(function () {\n      const ParentObject = Parse.Object.extend('ParentObject');\n      parent = new ParentObject();\n      parent.set('x', 4);\n      relation = parent.relation('child');\n      relation.add(childObjects[0]);\n      relation.add(childObjects[1]);\n      relation.remove(childObjects[0]);\n      relation.add(childObjects[2]);\n      return parent.save();\n    }).then(function () {\n      return relation.query().find();\n    }).then(function (list) {\n      equal(list.length, 2, 'Should have gotten two elements back');\n      ok(!parent.dirty('child'), 'The relation should not be dirty');\n      relation.remove(childObjects[1]);\n      relation.remove(childObjects[2]);\n      relation.add(childObjects[1]);\n      relation.add(childObjects[0]);\n      return parent.save();\n    }).then(function () {\n      return relation.query().find();\n    }).then(function (list) {\n      equal(list.length, 2, 'Deletes and then adds should have worked');\n      ok(!parent.dirty('child'), 'The relation should not be dirty');\n      done();\n    }, function (err) {\n      ok(false, err.message);\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"related at ordering optimizations","suites":["Parse.Relation testing"],"line":125,"updatePoint":{"line":125,"column":39,"index":4484},"code":"  it('related at ordering optimizations', done => {\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const childObjects = [];\n    for (let i = 0; i < 10; i++) {\n      childObjects.push(new ChildObject({\n        x: i\n      }));\n    }\n    let parent;\n    let relation;\n    Parse.Object.saveAll(childObjects).then(function () {\n      const ParentObject = Parse.Object.extend('ParentObject');\n      parent = new ParentObject();\n      parent.set('x', 4);\n      relation = parent.relation('child');\n      relation.add(childObjects);\n      return parent.save();\n    }).then(function () {\n      const query = relation.query();\n      query.descending('createdAt');\n      query.skip(1);\n      query.limit(3);\n      return query.find();\n    }).then(function (list) {\n      expect(list.length).toBe(3);\n    }).then(done, done.fail);\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"queries with relations","suites":["Parse.Relation testing"],"line":152,"updatePoint":{"line":152,"column":28,"index":5315},"code":"  it('queries with relations', async () => {\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const childObjects = [];\n    for (let i = 0; i < 10; i++) {\n      childObjects.push(new ChildObject({\n        x: i\n      }));\n    }\n    await Parse.Object.saveAll(childObjects);\n    const ParentObject = Parse.Object.extend('ParentObject');\n    const parent = new ParentObject();\n    parent.set('x', 4);\n    const relation = parent.relation('child');\n    relation.add(childObjects[0]);\n    relation.add(childObjects[1]);\n    relation.add(childObjects[2]);\n    await parent.save();\n    const query = relation.query();\n    query.equalTo('x', 2);\n    const list = await query.find();\n    equal(list.length, 1, 'There should only be one element');\n    ok(list[0] instanceof ChildObject, 'Should be of type ChildObject');\n    equal(list[0].id, childObjects[2].id, 'We should have gotten back the right result');\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"queries on relation fields","suites":["Parse.Relation testing"],"line":176,"updatePoint":{"line":176,"column":32,"index":6240},"code":"  it('queries on relation fields', async () => {\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const childObjects = [];\n    for (let i = 0; i < 10; i++) {\n      childObjects.push(new ChildObject({\n        x: i\n      }));\n    }\n    await Parse.Object.saveAll(childObjects);\n    const ParentObject = Parse.Object.extend('ParentObject');\n    const parent = new ParentObject();\n    parent.set('x', 4);\n    const relation = parent.relation('child');\n    relation.add(childObjects[0]);\n    relation.add(childObjects[1]);\n    relation.add(childObjects[2]);\n    const parent2 = new ParentObject();\n    parent2.set('x', 3);\n    const relation2 = parent2.relation('child');\n    relation2.add(childObjects[4]);\n    relation2.add(childObjects[5]);\n    relation2.add(childObjects[6]);\n    const parents = [];\n    parents.push(parent);\n    parents.push(parent2);\n    await Parse.Object.saveAll(parents);\n    const query = new Parse.Query(ParentObject);\n    const objects = [];\n    objects.push(childObjects[4]);\n    objects.push(childObjects[9]);\n    const list = await query.containedIn('child', objects).find();\n    equal(list.length, 1, 'There should be only one result');\n    equal(list[0].id, parent2.id, 'Should have gotten back the right result');\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"queries on relation fields with multiple containedIn (regression test for #1271)","suites":["Parse.Relation testing"],"line":210,"updatePoint":{"line":210,"column":86,"index":7559},"code":"  it('queries on relation fields with multiple containedIn (regression test for #1271)', done => {\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const childObjects = [];\n    for (let i = 0; i < 10; i++) {\n      childObjects.push(new ChildObject({\n        x: i\n      }));\n    }\n    Parse.Object.saveAll(childObjects).then(() => {\n      const ParentObject = Parse.Object.extend('ParentObject');\n      const parent = new ParentObject();\n      parent.set('x', 4);\n      const parent1Children = parent.relation('child');\n      parent1Children.add(childObjects[0]);\n      parent1Children.add(childObjects[1]);\n      parent1Children.add(childObjects[2]);\n      const parent2 = new ParentObject();\n      parent2.set('x', 3);\n      const parent2Children = parent2.relation('child');\n      parent2Children.add(childObjects[4]);\n      parent2Children.add(childObjects[5]);\n      parent2Children.add(childObjects[6]);\n      const parent2OtherChildren = parent2.relation('otherChild');\n      parent2OtherChildren.add(childObjects[0]);\n      parent2OtherChildren.add(childObjects[1]);\n      parent2OtherChildren.add(childObjects[2]);\n      return Parse.Object.saveAll([parent, parent2]);\n    }).then(() => {\n      const objectsWithChild0InBothChildren = new Parse.Query(ParentObject);\n      objectsWithChild0InBothChildren.containedIn('child', [childObjects[0]]);\n      objectsWithChild0InBothChildren.containedIn('otherChild', [childObjects[0]]);\n      return objectsWithChild0InBothChildren.find();\n    }).then(objectsWithChild0InBothChildren => {\n      //No parent has child 0 in both it's \"child\" and \"otherChild\" field;\n      expect(objectsWithChild0InBothChildren.length).toEqual(0);\n    }).then(() => {\n      const objectsWithChild4andOtherChild1 = new Parse.Query(ParentObject);\n      objectsWithChild4andOtherChild1.containedIn('child', [childObjects[4]]);\n      objectsWithChild4andOtherChild1.containedIn('otherChild', [childObjects[1]]);\n      return objectsWithChild4andOtherChild1.find();\n    }).then(objects => {\n      // parent2 has child 4 and otherChild 1\n      expect(objects.length).toEqual(1);\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"query on pointer and relation fields with equal","suites":["Parse.Relation testing"],"line":256,"updatePoint":{"line":256,"column":53,"index":9673},"code":"  it('query on pointer and relation fields with equal', done => {\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const childObjects = [];\n    for (let i = 0; i < 10; i++) {\n      childObjects.push(new ChildObject({\n        x: i\n      }));\n    }\n    Parse.Object.saveAll(childObjects).then(() => {\n      const ParentObject = Parse.Object.extend('ParentObject');\n      const parent = new ParentObject();\n      parent.set('x', 4);\n      const relation = parent.relation('toChilds');\n      relation.add(childObjects[0]);\n      relation.add(childObjects[1]);\n      relation.add(childObjects[2]);\n      const parent2 = new ParentObject();\n      parent2.set('x', 3);\n      parent2.set('toChild', childObjects[2]);\n      const parents = [];\n      parents.push(parent);\n      parents.push(parent2);\n      parents.push(new ParentObject());\n      return Parse.Object.saveAll(parents).then(() => {\n        const query = new Parse.Query(ParentObject);\n        query.equalTo('objectId', parent.id);\n        query.equalTo('toChilds', childObjects[2]);\n        return query.find().then(list => {\n          equal(list.length, 1, 'There should be 1 result');\n          done();\n        });\n      });\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"query on pointer and relation fields with equal bis","suites":["Parse.Relation testing"],"line":293,"updatePoint":{"line":293,"column":57,"index":10943},"code":"  it('query on pointer and relation fields with equal bis', done => {\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const childObjects = [];\n    for (let i = 0; i < 10; i++) {\n      childObjects.push(new ChildObject({\n        x: i\n      }));\n    }\n    Parse.Object.saveAll(childObjects).then(() => {\n      const ParentObject = Parse.Object.extend('ParentObject');\n      const parent = new ParentObject();\n      parent.set('x', 4);\n      const relation = parent.relation('toChilds');\n      relation.add(childObjects[0]);\n      relation.add(childObjects[1]);\n      relation.add(childObjects[2]);\n      const parent2 = new ParentObject();\n      parent2.set('x', 3);\n      parent2.relation('toChilds').add(childObjects[2]);\n      const parents = [];\n      parents.push(parent);\n      parents.push(parent2);\n      parents.push(new ParentObject());\n      return Parse.Object.saveAll(parents).then(() => {\n        const query = new Parse.Query(ParentObject);\n        query.equalTo('objectId', parent2.id);\n        // childObjects[2] is in 2 relations\n        // before the fix, that woul yield 2 results\n        query.equalTo('toChilds', childObjects[2]);\n        return query.find().then(list => {\n          equal(list.length, 1, 'There should be 1 result');\n          done();\n        });\n      });\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"or queries on pointer and relation fields","suites":["Parse.Relation testing"],"line":329,"updatePoint":{"line":329,"column":47,"index":12258},"code":"  it('or queries on pointer and relation fields', done => {\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const childObjects = [];\n    for (let i = 0; i < 10; i++) {\n      childObjects.push(new ChildObject({\n        x: i\n      }));\n    }\n    Parse.Object.saveAll(childObjects).then(() => {\n      const ParentObject = Parse.Object.extend('ParentObject');\n      const parent = new ParentObject();\n      parent.set('x', 4);\n      const relation = parent.relation('toChilds');\n      relation.add(childObjects[0]);\n      relation.add(childObjects[1]);\n      relation.add(childObjects[2]);\n      const parent2 = new ParentObject();\n      parent2.set('x', 3);\n      parent2.set('toChild', childObjects[2]);\n      const parents = [];\n      parents.push(parent);\n      parents.push(parent2);\n      parents.push(new ParentObject());\n      return Parse.Object.saveAll(parents).then(() => {\n        const query1 = new Parse.Query(ParentObject);\n        query1.containedIn('toChilds', [childObjects[2]]);\n        const query2 = new Parse.Query(ParentObject);\n        query2.equalTo('toChild', childObjects[2]);\n        const query = Parse.Query.or(query1, query2);\n        return query.find().then(list => {\n          const objectIds = list.map(function (item) {\n            return item.id;\n          });\n          expect(objectIds.indexOf(parent.id)).not.toBe(-1);\n          expect(objectIds.indexOf(parent2.id)).not.toBe(-1);\n          equal(list.length, 2, 'There should be 2 results');\n          done();\n        });\n      });\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"Get query on relation using un-fetched parent object","suites":["Parse.Relation testing"],"line":370,"updatePoint":{"line":370,"column":58,"index":13818},"code":"  it('Get query on relation using un-fetched parent object', done => {\n    // Setup data model\n    const Wheel = Parse.Object.extend('Wheel');\n    const Car = Parse.Object.extend('Car');\n    const origWheel = new Wheel();\n    origWheel.save().then(function () {\n      const car = new Car();\n      const relation = car.relation('wheels');\n      relation.add(origWheel);\n      return car.save();\n    }).then(function (car) {\n      // Test starts here.\n      // Create an un-fetched shell car object\n      const unfetchedCar = new Car();\n      unfetchedCar.id = car.id;\n      const relation = unfetchedCar.relation('wheels');\n      const query = relation.query();\n\n      // Parent object is un-fetched, so this will call /1/classes/Car instead\n      // of /1/classes/Wheel and pass { \"redirectClassNameForKey\":\"wheels\" }.\n      return query.get(origWheel.id);\n    }).then(function (wheel) {\n      // Make sure this is Wheel and not Car.\n      strictEqual(wheel.className, 'Wheel');\n      strictEqual(wheel.id, origWheel.id);\n    }).then(function () {\n      done();\n    }, function (err) {\n      ok(false, 'unexpected error: ' + JSON.stringify(err));\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"Find query on relation using un-fetched parent object","suites":["Parse.Relation testing"],"line":402,"updatePoint":{"line":402,"column":59,"index":14994},"code":"  it('Find query on relation using un-fetched parent object', done => {\n    // Setup data model\n    const Wheel = Parse.Object.extend('Wheel');\n    const Car = Parse.Object.extend('Car');\n    const origWheel = new Wheel();\n    origWheel.save().then(function () {\n      const car = new Car();\n      const relation = car.relation('wheels');\n      relation.add(origWheel);\n      return car.save();\n    }).then(function (car) {\n      // Test starts here.\n      // Create an un-fetched shell car object\n      const unfetchedCar = new Car();\n      unfetchedCar.id = car.id;\n      const relation = unfetchedCar.relation('wheels');\n      const query = relation.query();\n\n      // Parent object is un-fetched, so this will call /1/classes/Car instead\n      // of /1/classes/Wheel and pass { \"redirectClassNameForKey\":\"wheels\" }.\n      return query.find(origWheel.id);\n    }).then(function (results) {\n      // Make sure this is Wheel and not Car.\n      const wheel = results[0];\n      strictEqual(wheel.className, 'Wheel');\n      strictEqual(wheel.id, origWheel.id);\n    }).then(function () {\n      done();\n    }, function (err) {\n      ok(false, 'unexpected error: ' + JSON.stringify(err));\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"Find objects with a related object using equalTo","suites":["Parse.Relation testing"],"line":435,"updatePoint":{"line":435,"column":54,"index":16200},"code":"  it('Find objects with a related object using equalTo', done => {\n    // Setup the objects\n    const Card = Parse.Object.extend('Card');\n    const House = Parse.Object.extend('House');\n    const card = new Card();\n    card.save().then(() => {\n      const house = new House();\n      const relation = house.relation('cards');\n      relation.add(card);\n      return house.save();\n    }).then(() => {\n      const query = new Parse.Query('House');\n      query.equalTo('cards', card);\n      return query.find();\n    }).then(results => {\n      expect(results.length).toEqual(1);\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"should properly get related objects with unfetched queries","suites":["Parse.Relation testing"],"line":454,"updatePoint":{"line":454,"column":64,"index":16811},"code":"  it('should properly get related objects with unfetched queries', done => {\n    const objects = [];\n    const owners = [];\n    const allObjects = [];\n    // Build 10 Objects and 10 owners\n    while (objects.length != 10) {\n      const object = new Parse.Object('AnObject');\n      object.set({\n        index: objects.length,\n        even: objects.length % 2 == 0\n      });\n      objects.push(object);\n      const owner = new Parse.Object('AnOwner');\n      owners.push(owner);\n      allObjects.push(object);\n      allObjects.push(owner);\n    }\n    const anotherOwner = new Parse.Object('AnotherOwner');\n    return Parse.Object.saveAll(allObjects.concat([anotherOwner])).then(() => {\n      // put all the AnObject into the anotherOwner relationKey\n      anotherOwner.relation('relationKey').add(objects);\n      // Set each object[i] into owner[i];\n      owners.forEach((owner, i) => {\n        owner.set('key', objects[i]);\n      });\n      return Parse.Object.saveAll(owners.concat([anotherOwner]));\n    }).then(() => {\n      // Query on the relation of another owner\n      const object = new Parse.Object('AnotherOwner');\n      object.id = anotherOwner.id;\n      const relationQuery = object.relation('relationKey').query();\n      // Just get the even ones\n      relationQuery.equalTo('even', true);\n      // Make the query on anOwner\n      const query = new Parse.Query('AnOwner');\n      // where key match the relation query.\n      query.matchesQuery('key', relationQuery);\n      query.include('key');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(5);\n      results.forEach(result => {\n        expect(result.get('key').get('even')).toBe(true);\n      });\n      return Promise.resolve();\n    }).then(() => {\n      // Query on the relation of another owner\n      const object = new Parse.Object('AnotherOwner');\n      object.id = anotherOwner.id;\n      const relationQuery = object.relation('relationKey').query();\n      // Just get the even ones\n      relationQuery.equalTo('even', true);\n      // Make the query on anOwner\n      const query = new Parse.Query('AnOwner');\n      // where key match the relation query.\n      query.doesNotMatchQuery('key', relationQuery);\n      query.include('key');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(5);\n      results.forEach(result => {\n        expect(result.get('key').get('even')).toBe(false);\n      });\n      done();\n    }, e => {\n      fail(JSON.stringify(e));\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"select query","suites":["Parse.Relation testing"],"line":523,"updatePoint":{"line":523,"column":18,"index":19281},"code":"  it('select query', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const OwnerObject = Parse.Object.extend('Owner');\n    const restaurants = [new RestaurantObject({\n      ratings: 5,\n      location: 'Djibouti'\n    }), new RestaurantObject({\n      ratings: 3,\n      location: 'Ouagadougou'\n    })];\n    const persons = [new PersonObject({\n      name: 'Bob',\n      hometown: 'Djibouti'\n    }), new PersonObject({\n      name: 'Tom',\n      hometown: 'Ouagadougou'\n    }), new PersonObject({\n      name: 'Billy',\n      hometown: 'Detroit'\n    })];\n    const owner = new OwnerObject({\n      name: 'Joe'\n    });\n    const allObjects = [owner].concat(restaurants).concat(persons);\n    expect(allObjects.length).toEqual(6);\n    Parse.Object.saveAll([owner].concat(restaurants).concat(persons)).then(function () {\n      owner.relation('restaurants').add(restaurants);\n      return owner.save();\n    }).then(async () => {\n      const unfetchedOwner = new OwnerObject();\n      unfetchedOwner.id = owner.id;\n      const query = unfetchedOwner.relation('restaurants').query();\n      query.greaterThan('ratings', 4);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.matchesKeyInQuery('hometown', 'location', query);\n      const results = await mainQuery.find();\n      equal(results.length, 1);\n      if (results.length > 0) {\n        equal(results[0].get('name'), 'Bob');\n      }\n      done();\n    }, e => {\n      fail(JSON.stringify(e));\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"dontSelect query","suites":["Parse.Relation testing"],"line":570,"updatePoint":{"line":570,"column":22,"index":20855},"code":"  it('dontSelect query', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const OwnerObject = Parse.Object.extend('Owner');\n    const restaurants = [new RestaurantObject({\n      ratings: 5,\n      location: 'Djibouti'\n    }), new RestaurantObject({\n      ratings: 3,\n      location: 'Ouagadougou'\n    })];\n    const persons = [new PersonObject({\n      name: 'Bob',\n      hometown: 'Djibouti'\n    }), new PersonObject({\n      name: 'Tom',\n      hometown: 'Ouagadougou'\n    }), new PersonObject({\n      name: 'Billy',\n      hometown: 'Detroit'\n    })];\n    const owner = new OwnerObject({\n      name: 'Joe'\n    });\n    const allObjects = [owner].concat(restaurants).concat(persons);\n    expect(allObjects.length).toEqual(6);\n    Parse.Object.saveAll([owner].concat(restaurants).concat(persons)).then(function () {\n      owner.relation('restaurants').add(restaurants);\n      return owner.save();\n    }).then(async () => {\n      const unfetchedOwner = new OwnerObject();\n      unfetchedOwner.id = owner.id;\n      const query = unfetchedOwner.relation('restaurants').query();\n      query.greaterThan('ratings', 4);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.doesNotMatchKeyInQuery('hometown', 'location', query);\n      mainQuery.ascending('name');\n      const results = await mainQuery.find();\n      equal(results.length, 2);\n      if (results.length > 0) {\n        equal(results[0].get('name'), 'Billy');\n        equal(results[1].get('name'), 'Tom');\n      }\n      done();\n    }, e => {\n      fail(JSON.stringify(e));\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"relations are not bidirectional (regression test for #871)","suites":["Parse.Relation testing"],"line":619,"updatePoint":{"line":619,"column":64,"index":22559},"code":"  it('relations are not bidirectional (regression test for #871)', done => {\n    const PersonObject = Parse.Object.extend('Person');\n    const p1 = new PersonObject();\n    const p2 = new PersonObject();\n    Parse.Object.saveAll([p1, p2]).then(results => {\n      const p1 = results[0];\n      const p2 = results[1];\n      const relation = p1.relation('relation');\n      relation.add(p2);\n      p1.save().then(() => {\n        const query = new Parse.Query(PersonObject);\n        query.equalTo('relation', p1);\n        query.find().then(results => {\n          expect(results.length).toEqual(0);\n          const query = new Parse.Query(PersonObject);\n          query.equalTo('relation', p2);\n          query.find().then(results => {\n            expect(results.length).toEqual(1);\n            expect(results[0].objectId).toEqual(p1.objectId);\n            done();\n          });\n        });\n      });\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"can query roles in Cloud Code (regession test #1489)","suites":["Parse.Relation testing"],"line":644,"updatePoint":{"line":644,"column":58,"index":23460},"code":"  it('can query roles in Cloud Code (regession test #1489)', done => {\n    Parse.Cloud.define('isAdmin', request => {\n      const query = new Parse.Query(Parse.Role);\n      query.equalTo('name', 'admin');\n      return query.first({\n        useMasterKey: true\n      }).then(role => {\n        const relation = new Parse.Relation(role, 'users');\n        const admins = relation.query();\n        admins.equalTo('username', request.user.get('username'));\n        admins.first({\n          useMasterKey: true\n        }).then(user => {\n          if (user) {\n            done();\n          } else {\n            fail('Should have found admin user, found nothing instead');\n            done();\n          }\n        }, () => {\n          fail('User not admin');\n          done();\n        });\n      }, error => {\n        fail('Should have found admin user, errored instead');\n        fail(error);\n        done();\n      });\n    });\n    const adminUser = new Parse.User();\n    adminUser.set('username', 'name');\n    adminUser.set('password', 'pass');\n    adminUser.signUp().then(adminUser => {\n      const adminACL = new Parse.ACL();\n      adminACL.setPublicReadAccess(true);\n\n      // Create admin role\n      const adminRole = new Parse.Role('admin', adminACL);\n      adminRole.getUsers().add(adminUser);\n      adminRole.save().then(() => {\n        Parse.Cloud.run('isAdmin');\n      }, error => {\n        fail('failed to save role');\n        fail(error);\n        done();\n      });\n    }, error => {\n      fail('failed to sign up');\n      fail(error);\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"can be saved without error","suites":["Parse.Relation testing"],"line":696,"updatePoint":{"line":696,"column":32,"index":24996},"code":"  it('can be saved without error', done => {\n    const obj1 = new Parse.Object('PPAP');\n    obj1.save().then(() => {\n      const newRelation = obj1.relation('aRelation');\n      newRelation.add(obj1);\n      obj1.save().then(() => {\n        const relation = obj1.get('aRelation');\n        obj1.set('aRelation', relation);\n        obj1.save().then(() => {\n          done();\n        }, error => {\n          fail('failed to save ParseRelation object');\n          fail(error);\n          done();\n        });\n      }, error => {\n        fail('failed to create relation field');\n        fail(error);\n        done();\n      });\n    }, error => {\n      fail('failed to save obj');\n      fail(error);\n      done();\n    });\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"ensures beforeFind on relation doesnt side effect","suites":["Parse.Relation testing"],"line":722,"updatePoint":{"line":722,"column":55,"index":25735},"code":"  it('ensures beforeFind on relation doesnt side effect', done => {\n    const parent = new Parse.Object('Parent');\n    const child = new Parse.Object('Child');\n    child.save().then(() => {\n      parent.relation('children').add(child);\n      return parent.save();\n    }).then(() => {\n      // We need to use a new reference otherwise the JS SDK remembers the className for a relation\n      // After saves or finds\n      const otherParent = new Parse.Object('Parent');\n      otherParent.id = parent.id;\n      return otherParent.relation('children').query().find();\n    }).then(children => {\n      // Without an after find all is good, all results have been redirected with proper className\n      children.forEach(child => expect(child.className).toBe('Child'));\n      // Setup the afterFind\n      Parse.Cloud.afterFind('Child', req => {\n        return Promise.resolve(req.objects.map(child => {\n          child.set('afterFound', true);\n          return child;\n        }));\n      });\n      const otherParent = new Parse.Object('Parent');\n      otherParent.id = parent.id;\n      return otherParent.relation('children').query().find();\n    }).then(children => {\n      children.forEach(child => {\n        expect(child.className).toBe('Child');\n        expect(child.get('afterFound')).toBe(true);\n      });\n    }).then(done).catch(done.fail);\n  });","file":"ParseRelation.spec.js","skipped":false,"dir":"spec"},{"name":"Do a bunch of basic role testing","suites":["Parse Role testing"],"line":57,"updatePoint":{"line":57,"column":38,"index":1810},"code":"  it('Do a bunch of basic role testing', done => {\n    let user;\n    let role;\n    createTestUser().then(x => {\n      user = x;\n      const acl = new Parse.ACL();\n      acl.setPublicReadAccess(true);\n      acl.setPublicWriteAccess(false);\n      role = new Parse.Object('_Role');\n      role.set('name', 'Foos');\n      role.setACL(acl);\n      const users = role.relation('users');\n      users.add(user);\n      return role.save({}, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      const query = new Parse.Query('_Role');\n      return query.find({\n        useMasterKey: true\n      });\n    }).then(x => {\n      expect(x.length).toEqual(1);\n      const relation = x[0].relation('users').query();\n      return relation.first({\n        useMasterKey: true\n      });\n    }).then(x => {\n      expect(x.id).toEqual(user.id);\n      // Here we've got a valid role and a user assigned.\n      // Lets create an object only the role can read/write and test\n      // the different scenarios.\n      const obj = new Parse.Object('TestObject');\n      const acl = new Parse.ACL();\n      acl.setPublicReadAccess(false);\n      acl.setPublicWriteAccess(false);\n      acl.setRoleReadAccess('Foos', true);\n      acl.setRoleWriteAccess('Foos', true);\n      obj.setACL(acl);\n      return obj.save();\n    }).then(() => {\n      const query = new Parse.Query('TestObject');\n      return query.find({\n        sessionToken: user.getSessionToken()\n      });\n    }).then(x => {\n      expect(x.length).toEqual(1);\n      const objAgain = x[0];\n      objAgain.set('foo', 'bar');\n      // This should succeed:\n      return objAgain.save({}, {\n        sessionToken: user.getSessionToken()\n      });\n    }).then(x => {\n      x.set('foo', 'baz');\n      // This should fail:\n      return x.save({}, {\n        sessionToken: ''\n      });\n    }).then(() => {\n      fail('Should not have been able to save.');\n    }, e => {\n      expect(e.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    });\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"should not recursively load the same role multiple times","suites":["Parse Role testing"],"line":123,"updatePoint":{"line":123,"column":62,"index":3814},"code":"  it('should not recursively load the same role multiple times', done => {\n    const rootRole = 'RootRole';\n    const roleNames = ['FooRole', 'BarRole', 'BazRole'];\n    const allRoles = [rootRole].concat(roleNames);\n    const roleObjs = {};\n    const createAllRoles = function (user) {\n      const promises = allRoles.map(function (roleName) {\n        return createRole(roleName, null, user).then(function (roleObj) {\n          roleObjs[roleName] = roleObj;\n          return roleObj;\n        });\n      });\n      return Promise.all(promises);\n    };\n    const restExecute = spyOn(RestQuery.prototype, 'execute').and.callThrough();\n    let user, auth, getAllRolesSpy;\n    createTestUser().then(newUser => {\n      user = newUser;\n      return createAllRoles(user);\n    }).then(roles => {\n      const rootRoleObj = roleObjs[rootRole];\n      roles.forEach(function (role, i) {\n        // Add all roles to the RootRole\n        if (role.id !== rootRoleObj.id) {\n          role.relation('roles').add(rootRoleObj);\n        }\n        // Add all \"roleNames\" roles to the previous role\n        if (i > 0) {\n          role.relation('roles').add(roles[i - 1]);\n        }\n      });\n      return Parse.Object.saveAll(roles, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      auth = new Auth({\n        config: Config.get('test'),\n        isMaster: true,\n        user: user\n      });\n      getAllRolesSpy = spyOn(auth, '_getAllRolesNamesForRoleIds').and.callThrough();\n      return auth._loadRoles();\n    }).then(roles => {\n      expect(roles.length).toEqual(4);\n      allRoles.forEach(function (name) {\n        expect(roles.indexOf('role:' + name)).not.toBe(-1);\n      });\n\n      // 1 Query for the initial setup\n      // 1 query for the parent roles\n      expect(restExecute.calls.count()).toEqual(2);\n\n      // 1 call for the 1st layer of roles\n      // 1 call for the 2nd layer\n      expect(getAllRolesSpy.calls.count()).toEqual(2);\n      done();\n    }).catch(() => {\n      fail('should succeed');\n      done();\n    });\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"should recursively load roles","suites":["Parse Role testing"],"line":184,"updatePoint":{"line":184,"column":35,"index":5813},"code":"  it('should recursively load roles', done => {\n    testLoadRoles(Config.get('test'), done);\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"should recursively load roles without config","suites":["Parse Role testing"],"line":187,"updatePoint":{"line":187,"column":50,"index":5927},"code":"  it('should recursively load roles without config', done => {\n    testLoadRoles(undefined, done);\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"_Role object should not save without name.","suites":["Parse Role testing"],"line":190,"updatePoint":{"line":190,"column":48,"index":6030},"code":"  it('_Role object should not save without name.', done => {\n    const role = new Parse.Role();\n    role.save(null, {\n      useMasterKey: true\n    }).then(() => {\n      fail('_Role object should not save without name.');\n    }, error => {\n      expect(error.code).toEqual(111);\n      role.set('name', 'testRole');\n      role.save(null, {\n        useMasterKey: true\n      }).then(() => {\n        fail('_Role object should not save without ACL.');\n      }, error2 => {\n        expect(error2.code).toEqual(111);\n        done();\n      });\n    });\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"Different _Role objects cannot have the same name.","suites":["Parse Role testing"],"line":209,"updatePoint":{"line":209,"column":56,"index":6587},"code":"  it('Different _Role objects cannot have the same name.', async done => {\n    await reconfigureServer();\n    const roleName = 'MyRole';\n    let aUser;\n    createTestUser().then(user => {\n      aUser = user;\n      return createRole(roleName, null, aUser);\n    }).then(firstRole => {\n      expect(firstRole.getName()).toEqual(roleName);\n      return createRole(roleName, null, aUser);\n    }).then(() => {\n      fail('_Role cannot have the same name as another role');\n      done();\n    }, error => {\n      expect(error.code).toEqual(137);\n      done();\n    });\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"Should properly resolve roles","suites":["Parse Role testing"],"line":227,"updatePoint":{"line":227,"column":35,"index":7132},"code":"  it('Should properly resolve roles', done => {\n    const admin = new Parse.Role('Admin', new Parse.ACL());\n    const moderator = new Parse.Role('Moderator', new Parse.ACL());\n    const superModerator = new Parse.Role('SuperModerator', new Parse.ACL());\n    const contentManager = new Parse.Role('ContentManager', new Parse.ACL());\n    const superContentManager = new Parse.Role('SuperContentManager', new Parse.ACL());\n    Parse.Object.saveAll([admin, moderator, contentManager, superModerator, superContentManager], {\n      useMasterKey: true\n    }).then(() => {\n      contentManager.getRoles().add([moderator, superContentManager]);\n      moderator.getRoles().add([admin, superModerator]);\n      superContentManager.getRoles().add(superModerator);\n      return Parse.Object.saveAll([admin, moderator, contentManager, superModerator, superContentManager], {\n        useMasterKey: true\n      });\n    }).then(() => {\n      const auth = new Auth({\n        config: Config.get('test'),\n        isMaster: true\n      });\n      // For each role, fetch their sibling, what they inherit\n      // return with result and roleId for later comparison\n      const promises = [admin, moderator, contentManager, superModerator].map(role => {\n        return auth._getAllRolesNamesForRoleIds([role.id]).then(result => {\n          return Promise.resolve({\n            id: role.id,\n            name: role.get('name'),\n            roleNames: result\n          });\n        });\n      });\n      return Promise.all(promises);\n    }).then(results => {\n      results.forEach(result => {\n        const id = result.id;\n        const roleNames = result.roleNames;\n        if (id == admin.id) {\n          expect(roleNames.length).toBe(2);\n          expect(roleNames.indexOf('Moderator')).not.toBe(-1);\n          expect(roleNames.indexOf('ContentManager')).not.toBe(-1);\n        } else if (id == moderator.id) {\n          expect(roleNames.length).toBe(1);\n          expect(roleNames.indexOf('ContentManager')).toBe(0);\n        } else if (id == contentManager.id) {\n          expect(roleNames.length).toBe(0);\n        } else if (id == superModerator.id) {\n          expect(roleNames.length).toBe(3);\n          expect(roleNames.indexOf('Moderator')).not.toBe(-1);\n          expect(roleNames.indexOf('ContentManager')).not.toBe(-1);\n          expect(roleNames.indexOf('SuperContentManager')).not.toBe(-1);\n        }\n      });\n      done();\n    }).catch(() => {\n      done();\n    });\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"can create role and query empty users","suites":["Parse Role testing"],"line":284,"updatePoint":{"line":284,"column":43,"index":9594},"code":"  it('can create role and query empty users', done => {\n    const roleACL = new Parse.ACL();\n    roleACL.setPublicReadAccess(true);\n    const role = new Parse.Role('subscribers', roleACL);\n    role.save({}, {\n      useMasterKey: true\n    }).then(() => {\n      const query = role.relation('users').query();\n      query.find({\n        useMasterKey: true\n      }).then(() => {\n        done();\n      }, () => {\n        fail('should not have errors');\n        done();\n      });\n    }, () => {\n      fail('should not have errored');\n    });\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"should properly handle role permissions on objects","suites":["Parse Role testing"],"line":306,"updatePoint":{"line":306,"column":56,"index":10216},"code":"  it('should properly handle role permissions on objects', done => {\n    let user, user2, user3;\n    let role, role2, role3;\n    let obj, obj2;\n    const prACL = new Parse.ACL();\n    prACL.setPublicReadAccess(true);\n    let adminACL, superACL, customerACL;\n    createTestUser().then(x => {\n      user = x;\n      user2 = new Parse.User();\n      return user2.save({\n        username: 'user2',\n        password: 'omgbbq'\n      });\n    }).then(() => {\n      user3 = new Parse.User();\n      return user3.save({\n        username: 'user3',\n        password: 'omgbbq'\n      });\n    }).then(() => {\n      role = new Parse.Role('Admin', prACL);\n      role.getUsers().add(user);\n      return role.save({}, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      adminACL = new Parse.ACL();\n      adminACL.setRoleReadAccess('Admin', true);\n      adminACL.setRoleWriteAccess('Admin', true);\n      role2 = new Parse.Role('Super', prACL);\n      role2.getUsers().add(user2);\n      return role2.save({}, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      superACL = new Parse.ACL();\n      superACL.setRoleReadAccess('Super', true);\n      superACL.setRoleWriteAccess('Super', true);\n      role.getRoles().add(role2);\n      return role.save({}, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      role3 = new Parse.Role('Customer', prACL);\n      role3.getUsers().add(user3);\n      role3.getRoles().add(role);\n      return role3.save({}, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      customerACL = new Parse.ACL();\n      customerACL.setRoleReadAccess('Customer', true);\n      customerACL.setRoleWriteAccess('Customer', true);\n      const query = new Parse.Query('_Role');\n      return query.find({\n        useMasterKey: true\n      });\n    }).then(x => {\n      expect(x.length).toEqual(3);\n      obj = new Parse.Object('TestObjectRoles');\n      obj.set('ACL', customerACL);\n      return obj.save(null, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      // Above, the Admin role was added to the Customer role.\n      // An object secured by the Customer ACL should be able to be edited by the Admin user.\n      obj.set('changedByAdmin', true);\n      return obj.save(null, {\n        sessionToken: user.getSessionToken()\n      });\n    }).then(() => {\n      obj2 = new Parse.Object('TestObjectRoles');\n      obj2.set('ACL', adminACL);\n      return obj2.save(null, {\n        useMasterKey: true\n      });\n    }, () => {\n      fail('Admin user should have been able to save.');\n      done();\n    }).then(() => {\n      // An object secured by the Admin ACL should not be able to be edited by a Customer role user.\n      obj2.set('changedByCustomer', true);\n      return obj2.save(null, {\n        sessionToken: user3.getSessionToken()\n      });\n    }).then(() => {\n      fail('Customer user should not have been able to save.');\n      done();\n    }, e => {\n      if (e) {\n        expect(e.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n      } else {\n        fail('should return an error');\n      }\n      done();\n    });\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"should add multiple users to a role and remove users","suites":["Parse Role testing"],"line":405,"updatePoint":{"line":405,"column":58,"index":13282},"code":"  it('should add multiple users to a role and remove users', done => {\n    let user, user2, user3;\n    let role;\n    let obj;\n    const prACL = new Parse.ACL();\n    prACL.setPublicReadAccess(true);\n    prACL.setPublicWriteAccess(true);\n    createTestUser().then(x => {\n      user = x;\n      user2 = new Parse.User();\n      return user2.save({\n        username: 'user2',\n        password: 'omgbbq'\n      });\n    }).then(() => {\n      user3 = new Parse.User();\n      return user3.save({\n        username: 'user3',\n        password: 'omgbbq'\n      });\n    }).then(() => {\n      role = new Parse.Role('sharedRole', prACL);\n      const users = role.relation('users');\n      users.add(user);\n      users.add(user2);\n      users.add(user3);\n      return role.save({}, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      // query for saved role and get 3 users\n      const query = new Parse.Query('_Role');\n      query.equalTo('name', 'sharedRole');\n      return query.find({\n        useMasterKey: true\n      });\n    }).then(role => {\n      expect(role.length).toEqual(1);\n      const users = role[0].relation('users').query();\n      return users.find({\n        useMasterKey: true\n      });\n    }).then(users => {\n      expect(users.length).toEqual(3);\n      obj = new Parse.Object('TestObjectRoles');\n      obj.set('ACL', prACL);\n      return obj.save(null, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      // Above, the Admin role was added to the Customer role.\n      // An object secured by the Customer ACL should be able to be edited by the Admin user.\n      obj.set('changedByUsers', true);\n      return obj.save(null, {\n        sessionToken: user.getSessionToken()\n      });\n    }).then(() => {\n      // query for saved role and get 3 users\n      const query = new Parse.Query('_Role');\n      query.equalTo('name', 'sharedRole');\n      return query.find({\n        useMasterKey: true\n      });\n    }).then(role => {\n      expect(role.length).toEqual(1);\n      const users = role[0].relation('users');\n      users.remove(user);\n      users.remove(user3);\n      return role[0].save({}, {\n        useMasterKey: true\n      });\n    }).then(role => {\n      const users = role.relation('users').query();\n      return users.find({\n        useMasterKey: true\n      });\n    }).then(users => {\n      expect(users.length).toEqual(1);\n      expect(users[0].get('username')).toEqual('user2');\n      done();\n    });\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"should be secure (#3835)","suites":["Parse Role testing"],"line":487,"updatePoint":{"line":487,"column":30,"index":15689},"code":"  it('should be secure (#3835)', done => {\n    const acl = new Parse.ACL();\n    acl.getPublicReadAccess(true);\n    const role = new Parse.Role('admin', acl);\n    role.save().then(() => {\n      const user = new Parse.User();\n      return user.signUp({\n        username: 'hello',\n        password: 'world'\n      });\n    }).then(user => {\n      role.getUsers().add(user);\n      return role.save();\n    }).then(done.fail, () => {\n      const query = role.getUsers().query();\n      return query.find({\n        useMasterKey: true\n      });\n    }).then(results => {\n      expect(results.length).toBe(0);\n      done();\n    }).catch(done.fail);\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"should match when matching in users relation","suites":["Parse Role testing"],"line":510,"updatePoint":{"line":510,"column":50,"index":16351},"code":"  it('should match when matching in users relation', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'admin',\n      password: 'admin'\n    }).then(user => {\n      const aCL = new Parse.ACL();\n      aCL.setPublicReadAccess(true);\n      aCL.setPublicWriteAccess(true);\n      const role = new Parse.Role('admin', aCL);\n      const users = role.relation('users');\n      users.add(user);\n      role.save({}, {\n        useMasterKey: true\n      }).then(() => {\n        const query = new Parse.Query(Parse.Role);\n        query.equalTo('name', 'admin');\n        query.equalTo('users', user);\n        query.find().then(function (roles) {\n          expect(roles.length).toEqual(1);\n          done();\n        });\n      });\n    });\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"should not match any entry when not matching in users relation","suites":["Parse Role testing"],"line":535,"updatePoint":{"line":535,"column":68,"index":17122},"code":"  it('should not match any entry when not matching in users relation', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'admin',\n      password: 'admin'\n    }).then(user => {\n      const aCL = new Parse.ACL();\n      aCL.setPublicReadAccess(true);\n      aCL.setPublicWriteAccess(true);\n      const role = new Parse.Role('admin', aCL);\n      const users = role.relation('users');\n      users.add(user);\n      role.save({}, {\n        useMasterKey: true\n      }).then(() => {\n        const otherUser = new Parse.User();\n        otherUser.save({\n          username: 'otherUser',\n          password: 'otherUser'\n        }).then(otherUser => {\n          const query = new Parse.Query(Parse.Role);\n          query.equalTo('name', 'admin');\n          query.equalTo('users', otherUser);\n          query.find().then(function (roles) {\n            expect(roles.length).toEqual(0);\n            done();\n          });\n        });\n      });\n    });\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"should not match any entry when searching for null in users relation","suites":["Parse Role testing"],"line":566,"updatePoint":{"line":566,"column":74,"index":18095},"code":"  it('should not match any entry when searching for null in users relation', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'admin',\n      password: 'admin'\n    }).then(user => {\n      const aCL = new Parse.ACL();\n      aCL.setPublicReadAccess(true);\n      aCL.setPublicWriteAccess(true);\n      const role = new Parse.Role('admin', aCL);\n      const users = role.relation('users');\n      users.add(user);\n      role.save({}, {\n        useMasterKey: true\n      }).then(() => {\n        const query = new Parse.Query(Parse.Role);\n        query.equalTo('name', 'admin');\n        query.equalTo('users', null);\n        query.find().then(function (roles) {\n          expect(roles.length).toEqual(0);\n          done();\n        });\n      });\n    });\n  });","file":"ParseRole.spec.js","skipped":false,"dir":"spec"},{"name":"parses correctly with numberParser","suites":["parsers"],"line":11,"updatePoint":{"line":11,"column":40,"index":239},"code":"  it('parses correctly with numberParser', () => {\n    const parser = numberParser('key');\n    expect(parser(2)).toEqual(2);\n    expect(parser('2')).toEqual(2);\n    expect(() => {\n      parser('string');\n    }).toThrow();\n  });","file":"parsers.spec.js","skipped":false,"dir":"spec"},{"name":"parses correctly with numberOrBoolParser","suites":["parsers"],"line":19,"updatePoint":{"line":19,"column":46,"index":473},"code":"  it('parses correctly with numberOrBoolParser', () => {\n    const parser = numberOrBoolParser('key');\n    expect(parser(true)).toEqual(true);\n    expect(parser(false)).toEqual(false);\n    expect(parser('true')).toEqual(true);\n    expect(parser('false')).toEqual(false);\n    expect(parser(1)).toEqual(1);\n    expect(parser('1')).toEqual(1);\n  });","file":"parsers.spec.js","skipped":false,"dir":"spec"},{"name":"parses correctly with booleanParser","suites":["parsers"],"line":28,"updatePoint":{"line":28,"column":41,"index":815},"code":"  it('parses correctly with booleanParser', () => {\n    const parser = booleanParser;\n    expect(parser(true)).toEqual(true);\n    expect(parser(false)).toEqual(false);\n    expect(parser('true')).toEqual(true);\n    expect(parser('false')).toEqual(false);\n    expect(parser(1)).toEqual(true);\n    expect(parser(2)).toEqual(false);\n  });","file":"parsers.spec.js","skipped":false,"dir":"spec"},{"name":"parses correctly with objectParser","suites":["parsers"],"line":37,"updatePoint":{"line":37,"column":40,"index":1149},"code":"  it('parses correctly with objectParser', () => {\n    const parser = objectParser;\n    expect(parser({\n      hello: 'world'\n    })).toEqual({\n      hello: 'world'\n    });\n    expect(parser('{\"hello\": \"world\"}')).toEqual({\n      hello: 'world'\n    });\n    expect(() => {\n      parser('string');\n    }).toThrow();\n  });","file":"parsers.spec.js","skipped":false,"dir":"spec"},{"name":"parses correctly with moduleOrObjectParser","suites":["parsers"],"line":51,"updatePoint":{"line":51,"column":48,"index":1476},"code":"  it('parses correctly with moduleOrObjectParser', () => {\n    const parser = moduleOrObjectParser;\n    expect(parser({\n      hello: 'world'\n    })).toEqual({\n      hello: 'world'\n    });\n    expect(parser('{\"hello\": \"world\"}')).toEqual({\n      hello: 'world'\n    });\n    expect(parser('string')).toEqual('string');\n  });","file":"parsers.spec.js","skipped":false,"dir":"spec"},{"name":"parses correctly with arrayParser","suites":["parsers"],"line":63,"updatePoint":{"line":63,"column":39,"index":1789},"code":"  it('parses correctly with arrayParser', () => {\n    const parser = arrayParser;\n    expect(parser([1, 2, 3])).toEqual([1, 2, 3]);\n    expect(parser('{\"hello\": \"world\"}')).toEqual(['{\"hello\": \"world\"}']);\n    expect(parser('1,2,3')).toEqual(['1', '2', '3']);\n    expect(() => {\n      parser(1);\n    }).toThrow();\n  });","file":"parsers.spec.js","skipped":false,"dir":"spec"},{"name":"parses correctly with nullParser","suites":["parsers"],"line":72,"updatePoint":{"line":72,"column":38,"index":2108},"code":"  it('parses correctly with nullParser', () => {\n    const parser = nullParser;\n    expect(parser('null')).toEqual(null);\n    expect(parser(1)).toEqual(1);\n    expect(parser('blabla')).toEqual('blabla');\n  });","file":"parsers.spec.js","skipped":false,"dir":"spec"},{"name":"validate good server url","suites":["Server Url Checks"],"line":31,"updatePoint":{"line":31,"column":30,"index":877},"code":"  it('validate good server url', done => {\n    Parse.serverURL = 'http://localhost:13376';\n    ParseServer.verifyServerUrl(async result => {\n      if (!result) {\n        done.fail('Did not pass valid url');\n      }\n      await reconfigureServer();\n      done();\n    });\n  });","file":"ParseServer.spec.js","skipped":false,"dir":"spec"},{"name":"mark bad server url","suites":["Server Url Checks"],"line":41,"updatePoint":{"line":41,"column":25,"index":1148},"code":"  it('mark bad server url', done => {\n    spyOn(console, 'warn').and.callFake(() => {});\n    Parse.serverURL = 'notavalidurl';\n    ParseServer.verifyServerUrl(async result => {\n      if (result) {\n        done.fail('Did not mark invalid url');\n      }\n      await reconfigureServer();\n      done();\n    });\n  });","file":"ParseServer.spec.js","skipped":false,"dir":"spec"},{"name":"handleShutdown, close connection","suites":["Server Url Checks"],"line":52,"updatePoint":{"line":52,"column":39,"index":1475},"skipped":true,"code":"  xit('handleShutdown, close connection', done => {\n    const mongoURI = 'mongodb://localhost:27017/parseServerMongoAdapterTestDatabase';\n    const postgresURI = 'postgres://localhost:5432/parse_server_postgres_adapter_test_database';\n    let databaseAdapter;\n    if (process.env.PARSE_SERVER_TEST_DB === 'postgres') {\n      databaseAdapter = new PostgresStorageAdapter({\n        uri: process.env.PARSE_SERVER_TEST_DATABASE_URI || postgresURI,\n        collectionPrefix: 'test_'\n      });\n    } else {\n      databaseAdapter = new MongoStorageAdapter({\n        uri: mongoURI,\n        collectionPrefix: 'test_'\n      });\n    }\n    let close = false;\n    const newConfiguration = Object.assign({}, defaultConfiguration, {\n      databaseAdapter,\n      serverStartComplete: () => {\n        let promise = Promise.resolve();\n        if (process.env.PARSE_SERVER_TEST_DB !== 'postgres') {\n          promise = parseServer.config.filesController.adapter._connect();\n        }\n        promise.then(() => {\n          parseServer.handleShutdown();\n          parseServer.server.close(err => {\n            if (err) {\n              done.fail('Close Server Error');\n            }\n            reconfigureServer({}).then(() => {\n              expect(close).toBe(true);\n              done();\n            });\n          });\n        });\n      },\n      serverCloseComplete: () => {\n        close = true;\n      }\n    });\n    const parseServer = ParseServer.start(newConfiguration);\n  });","file":"ParseServer.spec.js","dir":"spec"},{"name":"does not have unhandled promise rejection in the case of load error","suites":["Server Url Checks"],"line":94,"updatePoint":{"line":94,"column":73,"index":2971},"code":"  it('does not have unhandled promise rejection in the case of load error', done => {\n    const parseServerProcess = spawn(path.resolve(__dirname, './support/FailingServer.js'));\n    let stdout;\n    let stderr;\n    parseServerProcess.stdout.on('data', data => {\n      stdout = data.toString();\n    });\n    parseServerProcess.stderr.on('data', data => {\n      stderr = data.toString();\n    });\n    parseServerProcess.on('close', async code => {\n      expect(code).toEqual(1);\n      expect(stdout).not.toContain('UnhandledPromiseRejectionWarning');\n      expect(stderr).toContain('MongoServerSelectionError');\n      await reconfigureServer();\n      done();\n    });\n  });","file":"ParseServer.spec.js","skipped":false,"dir":"spec"},{"name":"should handle a get request","suites":["ParseServerRESTController"],"line":13,"updatePoint":{"line":13,"column":33,"index":553},"code":"  it('should handle a get request', async () => {\n    const res = await RESTController.request('GET', '/classes/MyObject');\n    expect(res.results.length).toBe(0);\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"should handle a get request with full serverURL mount path","suites":["ParseServerRESTController"],"line":17,"updatePoint":{"line":17,"column":64,"index":754},"code":"  it('should handle a get request with full serverURL mount path', async () => {\n    const res = await RESTController.request('GET', '/1/classes/MyObject');\n    expect(res.results.length).toBe(0);\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"should handle a POST batch without transaction","suites":["ParseServerRESTController"],"line":21,"updatePoint":{"line":21,"column":52,"index":945},"code":"  it('should handle a POST batch without transaction', async () => {\n    const res = await RESTController.request('POST', 'batch', {\n      requests: [{\n        method: 'GET',\n        path: '/classes/MyObject'\n      }, {\n        method: 'POST',\n        path: '/classes/MyObject',\n        body: {\n          key: 'value'\n        }\n      }, {\n        method: 'GET',\n        path: '/classes/MyObject'\n      }]\n    });\n    expect(res.length).toBe(3);\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"should handle a POST batch with transaction=false","suites":["ParseServerRESTController"],"line":39,"updatePoint":{"line":39,"column":55,"index":1399},"code":"  it('should handle a POST batch with transaction=false', async () => {\n    const res = await RESTController.request('POST', 'batch', {\n      requests: [{\n        method: 'GET',\n        path: '/classes/MyObject'\n      }, {\n        method: 'POST',\n        path: '/classes/MyObject',\n        body: {\n          key: 'value'\n        }\n      }, {\n        method: 'GET',\n        path: '/classes/MyObject'\n      }],\n      transaction: false\n    });\n    expect(res.length).toBe(3);\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"should handle response status","suites":["ParseServerRESTController"],"line":58,"updatePoint":{"line":58,"column":35,"index":1859},"code":"  it('should handle response status', async () => {\n    const router = ParseServer.promiseRouter({\n      appId: Parse.applicationId\n    });\n    spyOn(router, 'tryRouteRequest').and.callThrough();\n    RESTController = ParseServerRESTController(Parse.applicationId, router);\n    const resp = await RESTController.request('POST', '/classes/MyObject');\n    const {\n      status,\n      response,\n      location\n    } = await router.tryRouteRequest.calls.all()[0].returnValue;\n    expect(status).toBe(201);\n    expect(response).toEqual(resp);\n    expect(location).toBe(`http://localhost:8378/1/classes/MyObject/${resp.objectId}`);\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"should handle response status in batch","suites":["ParseServerRESTController"],"line":74,"updatePoint":{"line":74,"column":44,"index":2499},"code":"  it('should handle response status in batch', async () => {\n    const router = ParseServer.promiseRouter({\n      appId: Parse.applicationId\n    });\n    spyOn(router, 'tryRouteRequest').and.callThrough();\n    RESTController = ParseServerRESTController(Parse.applicationId, router);\n    const resp = await RESTController.request('POST', 'batch', {\n      requests: [{\n        method: 'POST',\n        path: '/classes/MyObject'\n      }, {\n        method: 'POST',\n        path: '/classes/MyObject'\n      }]\n    }, {\n      returnStatus: true\n    });\n    expect(resp.length).toBe(2);\n    expect(resp[0]._status).toBe(201);\n    expect(resp[1]._status).toBe(201);\n    expect(resp[0].success).toBeDefined();\n    expect(resp[1].success).toBeDefined();\n    expect(router.tryRouteRequest.calls.all().length).toBe(2);\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"properly handle existed","suites":["ParseServerRESTController"],"line":98,"updatePoint":{"line":98,"column":29,"index":3294},"code":"  it('properly handle existed', async done => {\n    const restController = Parse.CoreManager.getRESTController();\n    Parse.CoreManager.setRESTController(RESTController);\n    Parse.Cloud.define('handleStatus', async () => {\n      const obj = new Parse.Object('TestObject');\n      expect(obj.existed()).toBe(false);\n      await obj.save();\n      expect(obj.existed()).toBe(false);\n      const query = new Parse.Query('TestObject');\n      const result = await query.get(obj.id);\n      expect(result.existed()).toBe(true);\n      Parse.CoreManager.setRESTController(restController);\n      done();\n    });\n    await Parse.Cloud.run('handleStatus');\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"should handle a batch request with transaction = true","suites":["ParseServerRESTController","transactions"],"line":127,"updatePoint":{"line":127,"column":63,"index":4775},"code":"      it('should handle a batch request with transaction = true', async () => {\n        const myObject = new Parse.Object('MyObject'); // This is important because transaction only works on pre-existing collections\n        await myObject.save();\n        await myObject.destroy();\n        spyOn(databaseAdapter, 'createObject').and.callThrough();\n        const response = await RESTController.request('POST', 'batch', {\n          requests: [{\n            method: 'POST',\n            path: '/1/classes/MyObject',\n            body: {\n              key: 'value1'\n            }\n          }, {\n            method: 'POST',\n            path: '/1/classes/MyObject',\n            body: {\n              key: 'value2'\n            }\n          }],\n          transaction: true\n        });\n        expect(response.length).toEqual(2);\n        expect(response[0].success.objectId).toBeDefined();\n        expect(response[0].success.createdAt).toBeDefined();\n        expect(response[1].success.objectId).toBeDefined();\n        expect(response[1].success.createdAt).toBeDefined();\n        const query = new Parse.Query('MyObject');\n        const results = await query.find();\n        expect(databaseAdapter.createObject.calls.count() % 2).toBe(0);\n        for (let i = 0; i + 1 < databaseAdapter.createObject.calls.length; i = i + 2) {\n          expect(databaseAdapter.createObject.calls.argsFor(i)[3]).toBe(databaseAdapter.createObject.calls.argsFor(i + 1)[3]);\n        }\n        expect(results.map(result => result.get('key')).sort()).toEqual(['value1', 'value2']);\n      });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"should not save anything when one operation fails in a transaction","suites":["ParseServerRESTController","transactions"],"line":161,"updatePoint":{"line":161,"column":76,"index":6344},"code":"      it('should not save anything when one operation fails in a transaction', async () => {\n        const myObject = new Parse.Object('MyObject'); // This is important because transaction only works on pre-existing collections\n        await myObject.save();\n        await myObject.destroy();\n        try {\n          await RESTController.request('POST', 'batch', {\n            requests: [{\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 10\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 10\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 10\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 10\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 10\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 10\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 10\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 10\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 'value1'\n              }\n            }, {\n              method: 'POST',\n              path: '/1/classes/MyObject',\n              body: {\n                key: 10\n              }\n            }],\n            transaction: true\n          });\n          fail();\n        } catch (error) {\n          expect(error).toBeDefined();\n          const query = new Parse.Query('MyObject');\n          const results = await query.find();\n          expect(results.length).toBe(0);\n        }\n      });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"should generate separate session for each call","suites":["ParseServerRESTController","transactions"],"line":286,"updatePoint":{"line":286,"column":56,"index":9791},"code":"      it('should generate separate session for each call', async () => {\n        await reconfigureServer();\n        const myObject = new Parse.Object('MyObject'); // This is important because transaction only works on pre-existing collections\n        await myObject.save();\n        await myObject.destroy();\n        const myObject2 = new Parse.Object('MyObject2'); // This is important because transaction only works on pre-existing collections\n        await myObject2.save();\n        await myObject2.destroy();\n        spyOn(databaseAdapter, 'createObject').and.callThrough();\n        let myObjectCalls = 0;\n        Parse.Cloud.beforeSave('MyObject', async () => {\n          myObjectCalls++;\n          if (myObjectCalls === 2) {\n            try {\n              await RESTController.request('POST', 'batch', {\n                requests: [{\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 'value1'\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 10\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 'value1'\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 10\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 'value1'\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 10\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 'value1'\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 10\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 'value1'\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 10\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 'value1'\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 10\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 'value1'\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 10\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 'value1'\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 10\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 'value1'\n                  }\n                }, {\n                  method: 'POST',\n                  path: '/1/classes/MyObject2',\n                  body: {\n                    key: 10\n                  }\n                }],\n                transaction: true\n              });\n              fail('should fail');\n            } catch (e) {\n              expect(e).toBeDefined();\n            }\n          }\n        });\n        const response = await RESTController.request('POST', 'batch', {\n          requests: [{\n            method: 'POST',\n            path: '/1/classes/MyObject',\n            body: {\n              key: 'value1'\n            }\n          }, {\n            method: 'POST',\n            path: '/1/classes/MyObject',\n            body: {\n              key: 'value2'\n            }\n          }],\n          transaction: true\n        });\n        expect(response.length).toEqual(2);\n        expect(response[0].success.objectId).toBeDefined();\n        expect(response[0].success.createdAt).toBeDefined();\n        expect(response[1].success.objectId).toBeDefined();\n        expect(response[1].success.createdAt).toBeDefined();\n        await RESTController.request('POST', 'batch', {\n          requests: [{\n            method: 'POST',\n            path: '/1/classes/MyObject3',\n            body: {\n              key: 'value1'\n            }\n          }, {\n            method: 'POST',\n            path: '/1/classes/MyObject3',\n            body: {\n              key: 'value2'\n            }\n          }]\n        });\n        const query = new Parse.Query('MyObject');\n        const results = await query.find();\n        expect(results.map(result => result.get('key')).sort()).toEqual(['value1', 'value2']);\n        const query2 = new Parse.Query('MyObject2');\n        const results2 = await query2.find();\n        expect(results2.length).toEqual(0);\n        const query3 = new Parse.Query('MyObject3');\n        const results3 = await query3.find();\n        expect(results3.map(result => result.get('key')).sort()).toEqual(['value1', 'value2']);\n        expect(databaseAdapter.createObject.calls.count() >= 13).toEqual(true);\n        let transactionalSession;\n        let transactionalSession2;\n        let myObjectDBCalls = 0;\n        let myObject2DBCalls = 0;\n        let myObject3DBCalls = 0;\n        for (let i = 0; i < databaseAdapter.createObject.calls.count(); i++) {\n          const args = databaseAdapter.createObject.calls.argsFor(i);\n          switch (args[0]) {\n            case 'MyObject':\n              myObjectDBCalls++;\n              if (!transactionalSession || (myObjectDBCalls - 1) % 2 === 0) {\n                transactionalSession = args[3];\n              } else {\n                expect(transactionalSession).toBe(args[3]);\n              }\n              if (transactionalSession2) {\n                expect(transactionalSession2).not.toBe(args[3]);\n              }\n              break;\n            case 'MyObject2':\n              myObject2DBCalls++;\n              if (!transactionalSession2 || (myObject2DBCalls - 1) % 9 === 0) {\n                transactionalSession2 = args[3];\n              } else {\n                expect(transactionalSession2).toBe(args[3]);\n              }\n              if (transactionalSession) {\n                expect(transactionalSession).not.toBe(args[3]);\n              }\n              break;\n            case 'MyObject3':\n              myObject3DBCalls++;\n              expect(args[3]).toEqual(null);\n              break;\n          }\n        }\n        expect(myObjectDBCalls % 2).toEqual(0);\n        expect(myObjectDBCalls > 0).toEqual(true);\n        expect(myObject2DBCalls % 9).toEqual(0);\n        expect(myObject2DBCalls > 0).toEqual(true);\n        expect(myObject3DBCalls % 2).toEqual(0);\n        expect(myObject3DBCalls > 0).toEqual(true);\n      });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"should handle a POST request","suites":["ParseServerRESTController","transactions"],"line":509,"updatePoint":{"line":509,"column":34,"index":17432},"code":"  it('should handle a POST request', async () => {\n    await RESTController.request('POST', '/classes/MyObject', {\n      key: 'value'\n    });\n    const res = await RESTController.request('GET', '/classes/MyObject');\n    expect(res.results.length).toBe(1);\n    expect(res.results[0].key).toEqual('value');\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"should handle a POST request with context","suites":["ParseServerRESTController","transactions"],"line":517,"updatePoint":{"line":517,"column":47,"index":17756},"code":"  it('should handle a POST request with context', async () => {\n    Parse.Cloud.beforeSave('MyObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    Parse.Cloud.afterSave('MyObject', req => {\n      expect(req.context.a).toEqual('a');\n    });\n    await RESTController.request('POST', '/classes/MyObject', {\n      key: 'value'\n    }, {\n      context: {\n        a: 'a'\n      }\n    });\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"ensures sessionTokens are properly handled","suites":["ParseServerRESTController","transactions"],"line":532,"updatePoint":{"line":532,"column":48,"index":18162},"code":"  it('ensures sessionTokens are properly handled', async () => {\n    const user = await Parse.User.signUp('user', 'pass');\n    const sessionToken = user.getSessionToken();\n    const res = await RESTController.request('GET', '/users/me', undefined, {\n      sessionToken\n    });\n    // Result is in JSON format\n    expect(res.objectId).toEqual(user.id);\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"ensures masterKey is properly handled","suites":["ParseServerRESTController","transactions"],"line":541,"updatePoint":{"line":541,"column":43,"index":18515},"code":"  it('ensures masterKey is properly handled', async () => {\n    const user = await Parse.User.signUp('user', 'pass');\n    const userId = user.id;\n    await Parse.User.logOut();\n    const res = await RESTController.request('GET', '/classes/_User', undefined, {\n      useMasterKey: true\n    });\n    expect(res.results.length).toBe(1);\n    expect(res.results[0].objectId).toEqual(userId);\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"ensures no user is created when passing an empty username","suites":["ParseServerRESTController","transactions"],"line":551,"updatePoint":{"line":551,"column":63,"index":18927},"code":"  it('ensures no user is created when passing an empty username', async () => {\n    try {\n      await RESTController.request('POST', '/classes/_User', {\n        username: '',\n        password: 'world'\n      });\n      fail('Success callback should not be called when passing an empty username.');\n    } catch (err) {\n      expect(err.code).toBe(Parse.Error.USERNAME_MISSING);\n      expect(err.message).toBe('bad or missing username');\n    }\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"ensures no user is created when passing an empty password","suites":["ParseServerRESTController","transactions"],"line":563,"updatePoint":{"line":563,"column":63,"index":19373},"code":"  it('ensures no user is created when passing an empty password', async () => {\n    try {\n      await RESTController.request('POST', '/classes/_User', {\n        username: 'hello',\n        password: ''\n      });\n      fail('Success callback should not be called when passing an empty password.');\n    } catch (err) {\n      expect(err.code).toBe(Parse.Error.PASSWORD_MISSING);\n      expect(err.message).toBe('password is required');\n    }\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"ensures no session token is created on creating users","suites":["ParseServerRESTController","transactions"],"line":575,"updatePoint":{"line":575,"column":59,"index":19812},"code":"  it('ensures no session token is created on creating users', async () => {\n    const user = await RESTController.request('POST', '/classes/_User', {\n      username: 'hello',\n      password: 'world'\n    });\n    expect(user.sessionToken).toBeUndefined();\n    const query = new Parse.Query('_Session');\n    const sessions = await query.find({\n      useMasterKey: true\n    });\n    expect(sessions.length).toBe(0);\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"ensures a session token is created when passing installationId != cloud","suites":["ParseServerRESTController","transactions"],"line":587,"updatePoint":{"line":587,"column":77,"index":20247},"code":"  it('ensures a session token is created when passing installationId != cloud', async () => {\n    const user = await RESTController.request('POST', '/classes/_User', {\n      username: 'hello',\n      password: 'world'\n    }, {\n      installationId: 'my-installation'\n    });\n    expect(user.sessionToken).not.toBeUndefined();\n    const query = new Parse.Query('_Session');\n    const sessions = await query.find({\n      useMasterKey: true\n    });\n    expect(sessions.length).toBe(1);\n    expect(sessions[0].get('installationId')).toBe('my-installation');\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"ensures logIn is saved with installationId","suites":["ParseServerRESTController","transactions"],"line":602,"updatePoint":{"line":602,"column":48,"index":20777},"code":"  it('ensures logIn is saved with installationId', async () => {\n    const installationId = 'installation123';\n    const user = await RESTController.request('POST', '/classes/_User', {\n      username: 'hello',\n      password: 'world'\n    }, {\n      installationId\n    });\n    expect(user.sessionToken).not.toBeUndefined();\n    const query = new Parse.Query('_Session');\n    let sessions = await query.find({\n      useMasterKey: true\n    });\n    expect(sessions.length).toBe(1);\n    expect(sessions[0].get('installationId')).toBe(installationId);\n    expect(sessions[0].get('sessionToken')).toBe(user.sessionToken);\n    const loggedUser = await RESTController.request('POST', '/login', {\n      username: 'hello',\n      password: 'world'\n    }, {\n      installationId\n    });\n    expect(loggedUser.sessionToken).not.toBeUndefined();\n    sessions = await query.find({\n      useMasterKey: true\n    });\n\n    // Should clean up old sessions with this installationId\n    expect(sessions.length).toBe(1);\n    expect(sessions[0].get('installationId')).toBe(installationId);\n    expect(sessions[0].get('sessionToken')).toBe(loggedUser.sessionToken);\n  });","file":"ParseServerRESTController.spec.js","skipped":false,"dir":"spec"},{"name":"should retain original sessionTokens with masterKey & sessionToken set","suites":["Parse.Session"],"line":26,"updatePoint":{"line":26,"column":76,"index":740},"code":"  it('should retain original sessionTokens with masterKey & sessionToken set', done => {\n    setupTestUsers().then(user => {\n      const query = new Parse.Query(Parse.Session);\n      return query.find({\n        useMasterKey: true,\n        sessionToken: user.get('sessionToken')\n      });\n    }).then(results => {\n      const foundKeys = [];\n      expect(results.length).toBe(3);\n      for (const key in results) {\n        const sessionToken = results[key].get('sessionToken');\n        if (foundKeys[sessionToken]) {\n          fail('Duplicate session token present in response');\n          break;\n        }\n        foundKeys[sessionToken] = 1;\n      }\n      done();\n    }).catch(err => {\n      fail(err);\n    });\n  });","file":"ParseSession.spec.js","skipped":false,"dir":"spec"},{"name":"should retain original sessionTokens with just sessionToken set","suites":["Parse.Session"],"line":51,"updatePoint":{"line":51,"column":69,"index":1509},"code":"  it('should retain original sessionTokens with just sessionToken set', done => {\n    let knownSessionToken;\n    setupTestUsers().then(user => {\n      knownSessionToken = user.get('sessionToken');\n      const query = new Parse.Query(Parse.Session);\n      return query.find({\n        sessionToken: knownSessionToken\n      });\n    }).then(results => {\n      expect(results.length).toBe(1);\n      const sessionToken = results[0].get('sessionToken');\n      expect(sessionToken).toBe(knownSessionToken);\n      done();\n    }).catch(err => {\n      fail(err);\n    });\n  });","file":"ParseSession.spec.js","skipped":false,"dir":"spec"},{"name":"token on users should retain original sessionTokens with masterKey & sessionToken set","suites":["Parse.Session"],"line":70,"updatePoint":{"line":70,"column":91,"index":2148},"code":"  it('token on users should retain original sessionTokens with masterKey & sessionToken set', done => {\n    setupTestUsers().then(user => {\n      const query = new Parse.Query(Parse.User);\n      return query.find({\n        useMasterKey: true,\n        sessionToken: user.get('sessionToken')\n      });\n    }).then(results => {\n      const foundKeys = [];\n      expect(results.length).toBe(3);\n      for (const key in results) {\n        const sessionToken = results[key].get('sessionToken');\n        if (foundKeys[sessionToken] && sessionToken !== undefined) {\n          fail('Duplicate session token present in response');\n          break;\n        }\n        foundKeys[sessionToken] = 1;\n      }\n      done();\n    }).catch(err => {\n      fail(err);\n    });\n  });","file":"ParseSession.spec.js","skipped":false,"dir":"spec"},{"name":"token on users should retain original sessionTokens with just sessionToken set","suites":["Parse.Session"],"line":95,"updatePoint":{"line":95,"column":84,"index":2945},"code":"  it('token on users should retain original sessionTokens with just sessionToken set', done => {\n    let knownSessionToken;\n    setupTestUsers().then(user => {\n      knownSessionToken = user.get('sessionToken');\n      const query = new Parse.Query(Parse.User);\n      return query.find({\n        sessionToken: knownSessionToken\n      });\n    }).then(results => {\n      const foundKeys = [];\n      expect(results.length).toBe(3);\n      for (const key in results) {\n        const sessionToken = results[key].get('sessionToken');\n        if (foundKeys[sessionToken] && sessionToken !== undefined) {\n          fail('Duplicate session token present in response');\n          break;\n        }\n        foundKeys[sessionToken] = 1;\n      }\n      done();\n    }).catch(err => {\n      fail(err);\n    });\n  });","file":"ParseSession.spec.js","skipped":false,"dir":"spec"},{"name":"cannot edit session with known ID","suites":["Parse.Session"],"line":119,"updatePoint":{"line":119,"column":39,"index":3697},"code":"  it('cannot edit session with known ID', async () => {\n    await setupTestUsers();\n    const [first, second] = await new Parse.Query(Parse.Session).find({\n      useMasterKey: true\n    });\n    const headers = {\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-Rest-API-Key': 'rest',\n      'X-Parse-Session-Token': second.get('sessionToken'),\n      'Content-Type': 'application/json'\n    };\n    const firstUser = first.get('user').id;\n    const secondUser = second.get('user').id;\n    const e = await request({\n      method: 'PUT',\n      headers,\n      url: `http://localhost:8378/1/sessions/${first.id}`,\n      body: JSON.stringify({\n        foo: 'bar',\n        user: {\n          __type: 'Pointer',\n          className: '_User',\n          objectId: secondUser\n        }\n      })\n    }).catch(e => e.data);\n    expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    expect(e.error).toBe('Object not found.');\n    await Parse.Object.fetchAll([first, second], {\n      useMasterKey: true\n    });\n    expect(first.get('user').id).toBe(firstUser);\n    expect(second.get('user').id).toBe(secondUser);\n  });","file":"ParseSession.spec.js","skipped":false,"dir":"spec"},{"name":"user sign up class method","suites":["Parse.User testing"],"line":16,"updatePoint":{"line":16,"column":31,"index":574},"code":"  it('user sign up class method', async done => {\n    const user = await Parse.User.signUp('asdf', 'zxcv');\n    ok(user.getSessionToken());\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user sign up instance method","suites":["Parse.User testing"],"line":21,"updatePoint":{"line":21,"column":34,"index":735},"code":"  it('user sign up instance method', async () => {\n    const user = new Parse.User();\n    user.setPassword('asdf');\n    user.setUsername('zxcv');\n    await user.signUp();\n    ok(user.getSessionToken());\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user login wrong username","suites":["Parse.User testing"],"line":28,"updatePoint":{"line":28,"column":31,"index":941},"code":"  it('user login wrong username', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    try {\n      await Parse.User.logIn('non_existent_user', 'asdf3');\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user login wrong password","suites":["Parse.User testing"],"line":38,"updatePoint":{"line":38,"column":31,"index":1226},"code":"  it('user login wrong password', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    try {\n      await Parse.User.logIn('asdf', 'asdfWrong');\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user login with non-string username with REST API","suites":["Parse.User testing"],"line":48,"updatePoint":{"line":48,"column":55,"index":1526},"code":"  it('user login with non-string username with REST API', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/login',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      body: {\n        _method: 'GET',\n        username: {\n          $regex: '^asd'\n        },\n        password: 'zxcv'\n      }\n    }).then(res => {\n      fail(`no request should succeed: ${JSON.stringify(res)}`);\n      done();\n    }).catch(err => {\n      expect(err.status).toBe(404);\n      expect(err.text).toMatch(`{\"code\":${Parse.Error.OBJECT_NOT_FOUND},\"error\":\"Invalid username/password.\"}`);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user login with non-string username with REST API (again)","suites":["Parse.User testing"],"line":74,"updatePoint":{"line":74,"column":63,"index":2323},"code":"  it('user login with non-string username with REST API (again)', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/login',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      body: {\n        _method: 'GET',\n        username: 'asdf',\n        password: {\n          $regex: '^zx'\n        }\n      }\n    }).then(res => {\n      fail(`no request should succeed: ${JSON.stringify(res)}`);\n      done();\n    }).catch(err => {\n      expect(err.status).toBe(404);\n      expect(err.text).toMatch(`{\"code\":${Parse.Error.OBJECT_NOT_FOUND},\"error\":\"Invalid username/password.\"}`);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user login using POST with REST API","suites":["Parse.User testing"],"line":100,"updatePoint":{"line":100,"column":41,"index":3097},"code":"  it('user login using POST with REST API', async done => {\n    await Parse.User.signUp('some_user', 'some_password');\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/login',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      body: {\n        username: 'some_user',\n        password: 'some_password'\n      }\n    }).then(res => {\n      expect(res.data.username).toBe('some_user');\n      done();\n    }).catch(err => {\n      fail(`no request should fail: ${JSON.stringify(err)}`);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user login","suites":["Parse.User testing"],"line":121,"updatePoint":{"line":121,"column":16,"index":3676},"code":"  it('user login', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    const user = await Parse.User.logIn('asdf', 'zxcv');\n    equal(user.get('username'), 'asdf');\n    const ACL = user.getACL();\n    expect(ACL.getReadAccess(user)).toBe(true);\n    expect(ACL.getWriteAccess(user)).toBe(true);\n    expect(ACL.getPublicReadAccess()).toBe(true);\n    expect(ACL.getPublicWriteAccess()).toBe(false);\n    const perms = ACL.permissionsById;\n    expect(Object.keys(perms).length).toBe(2);\n    expect(perms[user.id].read).toBe(true);\n    expect(perms[user.id].write).toBe(true);\n    expect(perms['*'].read).toBe(true);\n    expect(perms['*'].write).not.toBe(true);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should respect ACL without locking user out","suites":["Parse.User testing"],"line":138,"updatePoint":{"line":138,"column":49,"index":4395},"code":"  it('should respect ACL without locking user out', done => {\n    const user = new Parse.User();\n    const ACL = new Parse.ACL();\n    ACL.setPublicReadAccess(false);\n    ACL.setPublicWriteAccess(false);\n    user.setUsername('asdf');\n    user.setPassword('zxcv');\n    user.setACL(ACL);\n    user.signUp().then(() => {\n      return Parse.User.logIn('asdf', 'zxcv');\n    }).then(user => {\n      equal(user.get('username'), 'asdf');\n      const ACL = user.getACL();\n      expect(ACL.getReadAccess(user)).toBe(true);\n      expect(ACL.getWriteAccess(user)).toBe(true);\n      expect(ACL.getPublicReadAccess()).toBe(false);\n      expect(ACL.getPublicWriteAccess()).toBe(false);\n      const perms = ACL.permissionsById;\n      expect(Object.keys(perms).length).toBe(1);\n      expect(perms[user.id].read).toBe(true);\n      expect(perms[user.id].write).toBe(true);\n      expect(perms['*']).toBeUndefined();\n      // Try to lock out user\n      const newACL = new Parse.ACL();\n      newACL.setReadAccess(user.id, false);\n      newACL.setWriteAccess(user.id, false);\n      user.setACL(newACL);\n      return user.save();\n    }).then(() => {\n      return Parse.User.logIn('asdf', 'zxcv');\n    }).then(user => {\n      equal(user.get('username'), 'asdf');\n      const ACL = user.getACL();\n      expect(ACL.getReadAccess(user)).toBe(true);\n      expect(ACL.getWriteAccess(user)).toBe(true);\n      expect(ACL.getPublicReadAccess()).toBe(false);\n      expect(ACL.getPublicWriteAccess()).toBe(false);\n      const perms = ACL.permissionsById;\n      expect(Object.keys(perms).length).toBe(1);\n      expect(perms[user.id].read).toBe(true);\n      expect(perms[user.id].write).toBe(true);\n      expect(perms['*']).toBeUndefined();\n      done();\n    }).catch(() => {\n      fail('Should not fail');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should let masterKey lockout user","suites":["Parse.User testing"],"line":186,"updatePoint":{"line":186,"column":39,"index":6181},"code":"  it('should let masterKey lockout user', done => {\n    const user = new Parse.User();\n    const ACL = new Parse.ACL();\n    ACL.setPublicReadAccess(false);\n    ACL.setPublicWriteAccess(false);\n    user.setUsername('asdf');\n    user.setPassword('zxcv');\n    user.setACL(ACL);\n    user.signUp().then(() => {\n      return Parse.User.logIn('asdf', 'zxcv');\n    }).then(user => {\n      equal(user.get('username'), 'asdf');\n      // Lock the user down\n      const ACL = new Parse.ACL();\n      user.setACL(ACL);\n      return user.save(null, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      expect(user.getACL().getPublicReadAccess()).toBe(false);\n      return Parse.User.logIn('asdf', 'zxcv');\n    }).then(done.fail).catch(err => {\n      expect(err.message).toBe('Invalid username/password.');\n      expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should be let masterKey lock user out with authData","suites":["Parse.User testing"],"line":248,"updatePoint":{"line":248,"column":57,"index":8393},"code":"  it('should be let masterKey lock user out with authData', async () => {\n    const response = await request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      body: {\n        key: 'value',\n        authData: {\n          anonymous: {\n            id: '00000000-0000-0000-0000-000000000001'\n          }\n        }\n      }\n    });\n    const body = response.data;\n    const objectId = body.objectId;\n    const sessionToken = body.sessionToken;\n    expect(sessionToken).toBeDefined();\n    expect(objectId).toBeDefined();\n    const user = new Parse.User();\n    user.id = objectId;\n    const ACL = new Parse.ACL();\n    user.setACL(ACL);\n    await user.save(null, {\n      useMasterKey: true\n    });\n    // update the user\n    const options = {\n      method: 'POST',\n      url: `http://localhost:8378/1/classes/_User/`,\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      body: {\n        key: 'otherValue',\n        authData: {\n          anonymous: {\n            id: '00000000-0000-0000-0000-000000000001'\n          }\n        }\n      }\n    };\n    const res = await request(options);\n    expect(res.data.objectId).not.toEqual(objectId);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user login with files","suites":["Parse.User testing"],"line":299,"updatePoint":{"line":299,"column":27,"index":9806},"code":"  it('user login with files', done => {\n    const file = new Parse.File('yolo.txt', [1, 2, 3], 'text/plain');\n    file.save().then(file => {\n      return Parse.User.signUp('asdf', 'zxcv', {\n        file: file\n      });\n    }).then(() => {\n      return Parse.User.logIn('asdf', 'zxcv');\n    }).then(user => {\n      const fileAgain = user.get('file');\n      ok(fileAgain.name());\n      ok(fileAgain.url());\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"become sends token back","suites":["Parse.User testing"],"line":317,"updatePoint":{"line":317,"column":29,"index":10295},"code":"  it('become sends token back', done => {\n    let user = null;\n    let sessionToken = null;\n    Parse.User.signUp('Jason', 'Parse', {\n      code: 'red'\n    }).then(newUser => {\n      user = newUser;\n      expect(user.get('code'), 'red');\n      sessionToken = newUser.getSessionToken();\n      expect(sessionToken).toBeDefined();\n      return Parse.User.become(sessionToken);\n    }).then(newUser => {\n      expect(newUser.id).toEqual(user.id);\n      expect(newUser.get('username'), 'Jason');\n      expect(newUser.get('code'), 'red');\n      expect(newUser.getSessionToken()).toEqual(sessionToken);\n    }).then(() => {\n      done();\n    }, error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"become","suites":["Parse.User testing"],"line":340,"updatePoint":{"line":340,"column":12,"index":10973},"code":"  it('become', done => {\n    let user = null;\n    let sessionToken = null;\n    Promise.resolve().then(function () {\n      return Parse.User.signUp('Jason', 'Parse', {\n        code: 'red'\n      });\n    }).then(function (newUser) {\n      equal(Parse.User.current(), newUser);\n      user = newUser;\n      sessionToken = newUser.getSessionToken();\n      ok(sessionToken);\n      return Parse.User.logOut();\n    }).then(() => {\n      ok(!Parse.User.current());\n      return Parse.User.become(sessionToken);\n    }).then(function (newUser) {\n      equal(Parse.User.current(), newUser);\n      ok(newUser);\n      equal(newUser.id, user.id);\n      equal(newUser.get('username'), 'Jason');\n      equal(newUser.get('code'), 'red');\n      return Parse.User.logOut();\n    }).then(() => {\n      ok(!Parse.User.current());\n      return Parse.User.become('somegarbage');\n    }).then(function () {\n      // This should have failed actually.\n      ok(false, \"Shouldn't have been able to log in with garbage session token.\");\n    }, function (error) {\n      ok(error);\n      // Handle the error.\n      return Promise.resolve();\n    }).then(function () {\n      done();\n    }, function (error) {\n      ok(false, error);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not call beforeLogin with become","suites":["Parse.User testing"],"line":380,"updatePoint":{"line":380,"column":45,"index":12231},"code":"  it('should not call beforeLogin with become', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    let hit = 0;\n    Parse.Cloud.beforeLogin(() => {\n      hit++;\n    });\n    await Parse.User._logInWith('facebook');\n    const sessionToken = Parse.User.current().getSessionToken();\n    await Parse.User.become(sessionToken);\n    expect(hit).toBe(0);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"cannot save non-authed user","suites":["Parse.User testing"],"line":393,"updatePoint":{"line":393,"column":33,"index":12659},"code":"  it('cannot save non-authed user', async done => {\n    let user = new Parse.User();\n    user.set({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv'\n    });\n    let userAgain = await user.signUp();\n    equal(userAgain, user);\n    const query = new Parse.Query(Parse.User);\n    const userNotAuthed = await query.get(user.id);\n    user = new Parse.User();\n    user.set({\n      username: 'hacker',\n      password: 'password'\n    });\n    userAgain = await user.signUp();\n    equal(userAgain, user);\n    userNotAuthed.set('username', 'changed');\n    userNotAuthed.save().then(fail, err => {\n      expect(err.code).toEqual(Parse.Error.SESSION_MISSING);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"cannot delete non-authed user","suites":["Parse.User testing"],"line":417,"updatePoint":{"line":417,"column":35,"index":13367},"code":"  it('cannot delete non-authed user', async done => {\n    let user = new Parse.User();\n    await user.signUp({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv'\n    });\n    const query = new Parse.Query(Parse.User);\n    const userNotAuthed = await query.get(user.id);\n    user = new Parse.User();\n    const userAgain = await user.signUp({\n      username: 'hacker',\n      password: 'password'\n    });\n    equal(userAgain, user);\n    userNotAuthed.set('username', 'changed');\n    try {\n      await userNotAuthed.destroy();\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"cannot saveAll with non-authed user","suites":["Parse.User testing"],"line":441,"updatePoint":{"line":441,"column":41,"index":14043},"code":"  it('cannot saveAll with non-authed user', async done => {\n    let user = new Parse.User();\n    await user.signUp({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv'\n    });\n    const query = new Parse.Query(Parse.User);\n    const userNotAuthed = await query.get(user.id);\n    user = new Parse.User();\n    await user.signUp({\n      username: 'hacker',\n      password: 'password'\n    });\n    const userNotAuthedNotChanged = await query.get(user.id);\n    userNotAuthed.set('username', 'changed');\n    const object = new TestObject();\n    await object.save({\n      user: userNotAuthedNotChanged\n    });\n    const item1 = new TestObject();\n    await item1.save({\n      number: 0\n    });\n    item1.set('number', 1);\n    const item2 = new TestObject();\n    item2.set('number', 2);\n    try {\n      await Parse.Object.saveAll([item1, item2, userNotAuthed]);\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"never locks himself up","suites":["Parse.User testing"],"line":476,"updatePoint":{"line":476,"column":28,"index":15030},"code":"  it('never locks himself up', async () => {\n    const user = new Parse.User();\n    await user.signUp({\n      username: 'username',\n      password: 'password'\n    });\n    user.setACL(new Parse.ACL());\n    await user.save();\n    await user.fetch();\n    expect(user.getACL().getReadAccess(user)).toBe(true);\n    expect(user.getACL().getWriteAccess(user)).toBe(true);\n    const publicReadACL = new Parse.ACL();\n    publicReadACL.setPublicReadAccess(true);\n\n    // Create an administrator role with a single admin user\n    const role = new Parse.Role('admin', publicReadACL);\n    const admin = new Parse.User();\n    await admin.signUp({\n      username: 'admin',\n      password: 'admin'\n    });\n    role.getUsers().add(admin);\n    await role.save(null, {\n      useMasterKey: true\n    });\n\n    // Grant the admins write rights on the user\n    const acl = user.getACL();\n    acl.setRoleWriteAccess(role, true);\n    acl.setRoleReadAccess(role, true);\n\n    // Update with the masterKey just to be sure\n    await user.save({\n      ACL: acl\n    }, {\n      useMasterKey: true\n    });\n\n    // Try to update from admin... should all work fine\n    await user.save({\n      key: 'fromAdmin'\n    }, {\n      sessionToken: admin.getSessionToken()\n    });\n    await user.fetch();\n    expect(user.toJSON().key).toEqual('fromAdmin');\n\n    // Try to save when logged out (public)\n    let failed = false;\n    try {\n      // Ensure no session token is sent\n      await Parse.User.logOut();\n      await user.save({\n        key: 'fromPublic'\n      });\n    } catch (e) {\n      failed = true;\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n    expect({\n      failed\n    }).toEqual({\n      failed: true\n    });\n\n    // Try to save with a random user, should fail\n    failed = false;\n    const anyUser = new Parse.User();\n    await anyUser.signUp({\n      username: 'randomUser',\n      password: 'password'\n    });\n    try {\n      await user.save({\n        key: 'fromAnyUser'\n      });\n    } catch (e) {\n      failed = true;\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n    expect({\n      failed\n    }).toEqual({\n      failed: true\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"current user","suites":["Parse.User testing"],"line":562,"updatePoint":{"line":562,"column":18,"index":17165},"code":"  it('current user', done => {\n    const user = new Parse.User();\n    user.set('password', 'asdf');\n    user.set('email', 'asdf@example.com');\n    user.set('username', 'zxcv');\n    user.signUp().then(() => {\n      const currentUser = Parse.User.current();\n      equal(user.id, currentUser.id);\n      ok(user.getSessionToken());\n      const currentUserAgain = Parse.User.current();\n      // should be the same object\n      equal(currentUser, currentUserAgain);\n\n      // test logging out the current user\n      return Parse.User.logOut();\n    }).then(() => {\n      equal(Parse.User.current(), null);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user.isCurrent","suites":["Parse.User testing"],"line":582,"updatePoint":{"line":582,"column":20,"index":17794},"code":"  it('user.isCurrent', done => {\n    const user1 = new Parse.User();\n    const user2 = new Parse.User();\n    const user3 = new Parse.User();\n    user1.set('username', 'a');\n    user2.set('username', 'b');\n    user3.set('username', 'c');\n    user1.set('password', 'password');\n    user2.set('password', 'password');\n    user3.set('password', 'password');\n    user1.signUp().then(() => {\n      equal(user1.isCurrent(), true);\n      equal(user2.isCurrent(), false);\n      equal(user3.isCurrent(), false);\n      return user2.signUp();\n    }).then(() => {\n      equal(user1.isCurrent(), false);\n      equal(user2.isCurrent(), true);\n      equal(user3.isCurrent(), false);\n      return user3.signUp();\n    }).then(() => {\n      equal(user1.isCurrent(), false);\n      equal(user2.isCurrent(), false);\n      equal(user3.isCurrent(), true);\n      return Parse.User.logIn('a', 'password');\n    }).then(() => {\n      equal(user1.isCurrent(), true);\n      equal(user2.isCurrent(), false);\n      equal(user3.isCurrent(), false);\n      return Parse.User.logIn('b', 'password');\n    }).then(() => {\n      equal(user1.isCurrent(), false);\n      equal(user2.isCurrent(), true);\n      equal(user3.isCurrent(), false);\n      return Parse.User.logIn('b', 'password');\n    }).then(() => {\n      equal(user1.isCurrent(), false);\n      equal(user2.isCurrent(), true);\n      equal(user3.isCurrent(), false);\n      return Parse.User.logOut();\n    }).then(() => {\n      equal(user2.isCurrent(), false);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user associations","suites":["Parse.User testing"],"line":627,"updatePoint":{"line":627,"column":23,"index":19302},"code":"  it('user associations', async done => {\n    const child = new TestObject();\n    await child.save();\n    const user = new Parse.User();\n    user.set('password', 'asdf');\n    user.set('email', 'asdf@example.com');\n    user.set('username', 'zxcv');\n    user.set('child', child);\n    await user.signUp();\n    const object = new TestObject();\n    object.set('user', user);\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    const objectAgain = await query.get(object.id);\n    const userAgain = objectAgain.get('user');\n    await userAgain.fetch();\n    equal(user.id, userAgain.id);\n    equal(userAgain.get('child').id, child.id);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user queries","suites":["Parse.User testing"],"line":647,"updatePoint":{"line":647,"column":18,"index":19967},"code":"  it('user queries', async done => {\n    const user = new Parse.User();\n    user.set('password', 'asdf');\n    user.set('email', 'asdf@example.com');\n    user.set('username', 'zxcv');\n    await user.signUp();\n    const query = new Parse.Query(Parse.User);\n    const userAgain = await query.get(user.id);\n    equal(userAgain.id, user.id);\n    const users = await query.find();\n    equal(users.length, 1);\n    equal(users[0].id, user.id);\n    ok(userAgain.get('email'), 'asdf@example.com');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"contained in user array queries","suites":["Parse.User testing"],"line":674,"updatePoint":{"line":674,"column":37,"index":20811},"code":"  it('contained in user array queries', async done => {\n    const USERS = 4;\n    const MESSAGES = 5;\n\n    // Make a list of users.\n    const userList = range(USERS).map(function (i) {\n      const user = new Parse.User();\n      user.set('password', 'user_num_' + i);\n      user.set('email', 'user_num_' + i + '@example.com');\n      user.set('username', 'xinglblog_num_' + i);\n      return user;\n    });\n    signUpAll(userList, async function (users) {\n      // Make a list of messages.\n      if (!users || users.length != USERS) {\n        fail('signupAll failed');\n        done();\n        return;\n      }\n      const messageList = range(MESSAGES).map(function (i) {\n        const message = new TestObject();\n        message.set('to', users[(i + 1) % USERS]);\n        message.set('from', users[i % USERS]);\n        return message;\n      });\n\n      // Save all the messages.\n      await Parse.Object.saveAll(messageList);\n\n      // Assemble an \"in\" list.\n      const inList = [users[0], users[3], users[3]]; // Intentional dupe\n      const query = new Parse.Query(TestObject);\n      query.containedIn('from', inList);\n      const results = await query.find();\n      equal(results.length, 3);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"saving a user signs them up but doesn't log them in","suites":["Parse.User testing"],"line":712,"updatePoint":{"line":712,"column":57,"index":22048},"code":"  it(\"saving a user signs them up but doesn't log them in\", async done => {\n    const user = new Parse.User();\n    await user.save({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv'\n    });\n    equal(Parse.User.current(), null);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user updates","suites":["Parse.User testing"],"line":722,"updatePoint":{"line":722,"column":18,"index":22287},"code":"  it('user updates', async done => {\n    const user = new Parse.User();\n    await user.signUp({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv'\n    });\n    user.set('username', 'test');\n    await user.save();\n    equal(Object.keys(user.attributes).length, 5);\n    ok(user.attributes['username']);\n    ok(user.attributes['email']);\n    await user.destroy();\n    const query = new Parse.Query(Parse.User);\n    try {\n      await query.get(user.id);\n      done.fail();\n    } catch (error) {\n      // The user should no longer exist.\n      equal(error.code, Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"count users","suites":["Parse.User testing"],"line":745,"updatePoint":{"line":745,"column":17,"index":22928},"code":"  it('count users', async done => {\n    const james = new Parse.User();\n    james.set('username', 'james');\n    james.set('password', 'mypass');\n    await james.signUp();\n    const kevin = new Parse.User();\n    kevin.set('username', 'kevin');\n    kevin.set('password', 'mypass');\n    await kevin.signUp();\n    const query = new Parse.Query(Parse.User);\n    const count = await query.count();\n    equal(count, 2);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user sign up with container class","suites":["Parse.User testing"],"line":759,"updatePoint":{"line":759,"column":39,"index":23381},"code":"  it('user sign up with container class', async done => {\n    await Parse.User.signUp('ilya', 'mypass', {\n      array: ['hello']\n    });\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user modified while saving","suites":["Parse.User testing"],"line":765,"updatePoint":{"line":765,"column":32,"index":23529},"code":"  it('user modified while saving', async done => {\n    Parse.Object.disableSingleInstance();\n    await reconfigureServer();\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'password');\n    user.signUp().then(function (userAgain) {\n      equal(userAgain.get('username'), 'bob');\n      ok(userAgain.dirty('username'));\n      const query = new Parse.Query(Parse.User);\n      query.get(user.id).then(freshUser => {\n        equal(freshUser.id, user.id);\n        equal(freshUser.get('username'), 'alice');\n        done();\n      });\n    });\n    // Jump a frame so the signup call is properly sent\n    // This is due to the fact that now, we use real promises\n    process.nextTick(() => {\n      ok(user.set('username', 'bob'));\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user modified while saving with unsaved child","suites":["Parse.User testing"],"line":787,"updatePoint":{"line":787,"column":51,"index":24329},"code":"  it('user modified while saving with unsaved child', done => {\n    Parse.Object.disableSingleInstance();\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'password');\n    user.set('child', new TestObject());\n    user.signUp().then(userAgain => {\n      equal(userAgain.get('username'), 'bob');\n      // Should be dirty, but it depends on batch support.\n      // ok(userAgain.dirty(\"username\"));\n      const query = new Parse.Query(Parse.User);\n      query.get(user.id).then(freshUser => {\n        equal(freshUser.id, user.id);\n        // Should be alice, but it depends on batch support.\n        equal(freshUser.get('username'), 'bob');\n        done();\n      });\n    });\n    ok(user.set('username', 'bob'));\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user loaded from localStorage from signup","suites":["Parse.User testing"],"line":807,"updatePoint":{"line":807,"column":47,"index":25085},"code":"  it('user loaded from localStorage from signup', async done => {\n    const alice = await Parse.User.signUp('alice', 'password');\n    ok(alice.id, 'Alice should have an objectId');\n    ok(alice.getSessionToken(), 'Alice should have a session token');\n    equal(alice.get('password'), undefined, 'Alice should not have a password');\n\n    // Simulate the environment getting reset.\n    Parse.User._currentUser = null;\n    Parse.User._currentUserMatchesDisk = false;\n    const aliceAgain = Parse.User.current();\n    equal(aliceAgain.get('username'), 'alice');\n    equal(aliceAgain.id, alice.id, 'currentUser should have objectId');\n    ok(aliceAgain.getSessionToken(), 'currentUser should have a sessionToken');\n    equal(alice.get('password'), undefined, 'currentUser should not have password');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user loaded from localStorage from login","suites":["Parse.User testing"],"line":823,"updatePoint":{"line":823,"column":46,"index":25896},"code":"  it('user loaded from localStorage from login', done => {\n    let id;\n    Parse.User.signUp('alice', 'password').then(alice => {\n      id = alice.id;\n      return Parse.User.logOut();\n    }).then(() => {\n      return Parse.User.logIn('alice', 'password');\n    }).then(() => {\n      // Force the current user to read from disk\n      delete Parse.User._currentUser;\n      delete Parse.User._currentUserMatchesDisk;\n      const userFromDisk = Parse.User.current();\n      equal(userFromDisk.get('password'), undefined, 'password should not be in attributes');\n      equal(userFromDisk.id, id, 'id should be set');\n      ok(userFromDisk.getSessionToken(), 'currentUser should have a sessionToken');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"saving user after browser refresh","suites":["Parse.User testing"],"line":841,"updatePoint":{"line":841,"column":39,"index":26612},"code":"  it('saving user after browser refresh', done => {\n    let id;\n    Parse.User.signUp('alice', 'password', null).then(function (alice) {\n      id = alice.id;\n      return Parse.User.logOut();\n    }).then(() => {\n      return Parse.User.logIn('alice', 'password');\n    }).then(function () {\n      // Simulate browser refresh by force-reloading user from localStorage\n      Parse.User._clearCache();\n\n      // Test that this save works correctly\n      return Parse.User.current().save({\n        some_field: 1\n      });\n    }).then(function () {\n      // Check the user in memory just after save operation\n      const userInMemory = Parse.User.current();\n      equal(userInMemory.getUsername(), 'alice', 'saving user should not remove existing fields');\n      equal(userInMemory.get('some_field'), 1, 'saving user should save specified field');\n      equal(userInMemory.get('password'), undefined, 'password should not be in attributes after saving user');\n      equal(userInMemory.get('objectId'), undefined, 'objectId should not be in attributes after saving user');\n      equal(userInMemory.get('_id'), undefined, '_id should not be in attributes after saving user');\n      equal(userInMemory.id, id, 'id should be set');\n      expect(userInMemory.updatedAt instanceof Date).toBe(true);\n      ok(userInMemory.createdAt instanceof Date);\n      ok(userInMemory.getSessionToken(), 'user should have a sessionToken after saving');\n\n      // Force the current user to read from localStorage, and check again\n      delete Parse.User._currentUser;\n      delete Parse.User._currentUserMatchesDisk;\n      const userFromDisk = Parse.User.current();\n      equal(userFromDisk.getUsername(), 'alice', 'userFromDisk should have previously existing fields');\n      equal(userFromDisk.get('some_field'), 1, 'userFromDisk should have saved field');\n      equal(userFromDisk.get('password'), undefined, 'password should not be in attributes of userFromDisk');\n      equal(userFromDisk.get('objectId'), undefined, 'objectId should not be in attributes of userFromDisk');\n      equal(userFromDisk.get('_id'), undefined, '_id should not be in attributes of userFromDisk');\n      equal(userFromDisk.id, id, 'id should be set on userFromDisk');\n      ok(userFromDisk.updatedAt instanceof Date);\n      ok(userFromDisk.createdAt instanceof Date);\n      ok(userFromDisk.getSessionToken(), 'userFromDisk should have a sessionToken');\n      done();\n    }, function (error) {\n      ok(false, error);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user with missing username","suites":["Parse.User testing"],"line":888,"updatePoint":{"line":888,"column":32,"index":29104},"code":"  it('user with missing username', async done => {\n    const user = new Parse.User();\n    user.set('password', 'foo');\n    try {\n      await user.signUp();\n      done.fail();\n    } catch (error) {\n      equal(error.code, Parse.Error.OTHER_CAUSE);\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user with missing password","suites":["Parse.User testing"],"line":899,"updatePoint":{"line":899,"column":32,"index":29377},"code":"  it('user with missing password', async done => {\n    const user = new Parse.User();\n    user.set('username', 'foo');\n    try {\n      await user.signUp();\n      done.fail();\n    } catch (error) {\n      equal(error.code, Parse.Error.OTHER_CAUSE);\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user stupid subclassing","suites":["Parse.User testing"],"line":910,"updatePoint":{"line":910,"column":29,"index":29647},"code":"  it('user stupid subclassing', async done => {\n    const SuperUser = Parse.Object.extend('User');\n    const user = new SuperUser();\n    user.set('username', 'bob');\n    user.set('password', 'welcome');\n    ok(user instanceof Parse.User, 'Subclassing User should have worked');\n    await user.signUp();\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user signup class method uses subclassing","suites":["Parse.User testing"],"line":919,"updatePoint":{"line":919,"column":47,"index":29986},"code":"  it('user signup class method uses subclassing', async done => {\n    const SuperUser = Parse.User.extend({\n      secret: function () {\n        return 1337;\n      }\n    });\n    const user = await Parse.User.signUp('bob', 'welcome');\n    ok(user instanceof SuperUser, 'Subclassing User should have worked');\n    equal(user.secret(), 1337);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user on disk gets updated after save","suites":["Parse.User testing"],"line":930,"updatePoint":{"line":930,"column":42,"index":30338},"code":"  it('user on disk gets updated after save', async done => {\n    Parse.User.extend({\n      isSuper: function () {\n        return true;\n      }\n    });\n    const user = await Parse.User.signUp('bob', 'welcome');\n    await user.save('secret', 1337);\n    delete Parse.User._currentUser;\n    delete Parse.User._currentUserMatchesDisk;\n    const userFromDisk = Parse.User.current();\n    equal(userFromDisk.get('secret'), 1337);\n    ok(userFromDisk.isSuper(), 'The subclass should have been used');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"current user isn't dirty","suites":["Parse.User testing"],"line":945,"updatePoint":{"line":945,"column":30,"index":30837},"code":"  it(\"current user isn't dirty\", async done => {\n    const user = await Parse.User.signUp('andrew', 'oppa', {\n      style: 'gangnam'\n    });\n    ok(!user.dirty('style'), 'The user just signed up.');\n    Parse.User._currentUser = null;\n    Parse.User._currentUserMatchesDisk = false;\n    const userAgain = Parse.User.current();\n    ok(!userAgain.dirty('style'), 'The user was just read from disk.');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"log in with provider","suites":["Parse.User testing"],"line":1051,"updatePoint":{"line":1051,"column":26,"index":34081},"code":"  it('log in with provider', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"can not set authdata to null","suites":["Parse.User testing"],"line":1064,"updatePoint":{"line":1064,"column":34,"index":34796},"code":"  it('can not set authdata to null', async () => {\n    try {\n      const provider = getMockFacebookProvider();\n      Parse.User._registerAuthenticationProvider(provider);\n      const user = await Parse.User._logInWith('facebook');\n      user.set('authData', null);\n      await user.save();\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('This authentication method is unsupported.');\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"ignore setting authdata to undefined","suites":["Parse.User testing"],"line":1076,"updatePoint":{"line":1076,"column":42,"index":35214},"code":"  it('ignore setting authdata to undefined', async () => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = await Parse.User._logInWith('facebook');\n    user.set('authData', undefined);\n    await user.save();\n    let authData = user.get('authData');\n    expect(authData).toBe(undefined);\n    await user.fetch();\n    authData = user.get('authData');\n    expect(authData.facebook.id).toBeDefined();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user authData should be available in cloudcode (#2342)","suites":["Parse.User testing"],"line":1088,"updatePoint":{"line":1088,"column":60,"index":35709},"code":"  it('user authData should be available in cloudcode (#2342)', async done => {\n    Parse.Cloud.define('checkLogin', req => {\n      expect(req.user).not.toBeUndefined();\n      expect(Parse.FacebookUtils.isLinked(req.user)).toBe(true);\n      return 'ok';\n    });\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    Parse.Cloud.run('checkLogin').then(done, done);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"log in with provider and update token","suites":["Parse.User testing"],"line":1106,"updatePoint":{"line":1106,"column":43,"index":36655},"code":"  it('log in with provider and update token', async done => {\n    const provider = getMockFacebookProvider();\n    const secondProvider = getMockFacebookProviderWithIdToken('8675309', 'jenny_valid_token');\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    Parse.User._registerAuthenticationProvider(secondProvider);\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    expect(secondProvider.synchronizedAuthToken).toEqual('jenny_valid_token');\n    // Make sure we can login with the new token again\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"returns authData when authed and logged in with provider (regression test for #1498)","suites":["Parse.User testing"],"line":1120,"updatePoint":{"line":1120,"column":90,"index":37378},"code":"  it('returns authData when authed and logged in with provider (regression test for #1498)', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = await Parse.User._logInWith('facebook');\n    const userQuery = new Parse.Query(Parse.User);\n    userQuery.get(user.id).then(user => {\n      expect(user.get('authData')).not.toBeUndefined();\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"only creates a single session for an installation / user pair (#2885)","suites":["Parse.User testing"],"line":1130,"updatePoint":{"line":1130,"column":75,"index":37813},"code":"  it('only creates a single session for an installation / user pair (#2885)', async done => {\n    Parse.Object.disableSingleInstance();\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User.logInWith('facebook');\n    await Parse.User.logInWith('facebook');\n    const user = await Parse.User.logInWith('facebook');\n    const sessionToken = user.getSessionToken();\n    const query = new Parse.Query('_Session');\n    return query.find({\n      useMasterKey: true\n    }).then(results => {\n      expect(results.length).toBe(1);\n      expect(results[0].get('sessionToken')).toBe(sessionToken);\n      expect(results[0].get('createdWith')).toEqual({\n        action: 'login',\n        authProvider: 'facebook'\n      });\n      done();\n    }).catch(done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"log in with provider with files","suites":["Parse.User testing"],"line":1151,"updatePoint":{"line":1151,"column":37,"index":38602},"code":"  it('log in with provider with files', done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const file = new Parse.File('yolo.txt', [1, 2, 3], 'text/plain');\n    file.save().then(file => {\n      const user = new Parse.User();\n      user.set('file', file);\n      return user._linkWith('facebook', {});\n    }).then(user => {\n      expect(user._isLinked('facebook')).toBeTruthy();\n      return Parse.User._logInWith('facebook', {});\n    }).then(user => {\n      const fileAgain = user.get('file');\n      expect(fileAgain.name()).toMatch(/yolo.txt$/);\n      expect(fileAgain.url()).toMatch(/yolo.txt$/);\n    }).then(() => {\n      done();\n    }).catch(done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"log in with provider twice","suites":["Parse.User testing"],"line":1170,"updatePoint":{"line":1170,"column":32,"index":39329},"code":"  it('log in with provider twice', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    Parse.User.logOut().then(async () => {\n      ok(provider.loggedOut);\n      provider.loggedOut = false;\n      const innerModel = await Parse.User._logInWith('facebook');\n      ok(innerModel instanceof Parse.User, 'Model should be a Parse.User');\n      ok(innerModel === Parse.User.current(), 'Returned model should be the current user');\n      ok(provider.authData.id === provider.synchronizedUserId);\n      ok(provider.authData.access_token === provider.synchronizedAuthToken);\n      ok(innerModel._isLinked('facebook'), 'User should be linked to facebook');\n      ok(innerModel.existed(), 'User should not be newly-created');\n      done();\n    }, done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"log in with provider failed","suites":["Parse.User testing"],"line":1194,"updatePoint":{"line":1194,"column":33,"index":40699},"code":"  it('log in with provider failed', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldError = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    try {\n      await Parse.User._logInWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(error, 'Error should be non-null');\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"log in with provider cancelled","suites":["Parse.User testing"],"line":1206,"updatePoint":{"line":1206,"column":36,"index":41062},"code":"  it('log in with provider cancelled', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldCancel = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    try {\n      await Parse.User._logInWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(error === null, 'Error should be null');\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"login with provider should not call beforeSave trigger","suites":["Parse.User testing"],"line":1218,"updatePoint":{"line":1218,"column":60,"index":41455},"code":"  it('login with provider should not call beforeSave trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    Parse.User.logOut().then(async () => {\n      Parse.Cloud.beforeSave(Parse.User, function (req, res) {\n        res.error(\"Before save shouldn't be called on login\");\n      });\n      await Parse.User._logInWith('facebook');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"signup with provider should not call beforeLogin trigger","suites":["Parse.User testing"],"line":1230,"updatePoint":{"line":1230,"column":62,"index":41941},"code":"  it('signup with provider should not call beforeLogin trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    let hit = 0;\n    Parse.Cloud.beforeLogin(() => {\n      hit++;\n    });\n    await Parse.User._logInWith('facebook');\n    expect(hit).toBe(0);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"login with provider should call beforeLogin trigger","suites":["Parse.User testing"],"line":1241,"updatePoint":{"line":1241,"column":57,"index":42285},"code":"  it('login with provider should call beforeLogin trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      expect(req.object.get('authData')).toBeDefined();\n      expect(req.object.get('name')).toBe('tupac shakur');\n    });\n    await Parse.User._logInWith('facebook');\n    await Parse.User.current().save({\n      name: 'tupac shakur'\n    });\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    expect(hit).toBe(1);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"incorrect login with provider should not call beforeLogin trigger","suites":["Parse.User testing"],"line":1259,"updatePoint":{"line":1259,"column":71,"index":42908},"code":"  it('incorrect login with provider should not call beforeLogin trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    let hit = 0;\n    Parse.Cloud.beforeLogin(() => {\n      hit++;\n    });\n    await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    provider.shouldError = true;\n    try {\n      await Parse.User._logInWith('facebook');\n    } catch (e) {\n      expect(e).toBeDefined();\n    }\n    expect(hit).toBe(0);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"login with provider should be blockable by beforeLogin","suites":["Parse.User testing"],"line":1277,"updatePoint":{"line":1277,"column":60,"index":43431},"code":"  it('login with provider should be blockable by beforeLogin', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      if (req.object.get('isBanned')) {\n        throw new Error('banned account');\n      }\n    });\n    await Parse.User._logInWith('facebook');\n    await Parse.User.current().save({\n      isBanned: true\n    });\n    await Parse.User.logOut();\n    try {\n      await Parse.User._logInWith('facebook');\n      throw new Error('should not have continued login.');\n    } catch (e) {\n      expect(e.message).toBe('banned account');\n    }\n    expect(hit).toBe(1);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"login with provider should be blockable by beforeLogin even when the user has a attached file","suites":["Parse.User testing"],"line":1301,"updatePoint":{"line":1301,"column":99,"index":44195},"code":"  it('login with provider should be blockable by beforeLogin even when the user has a attached file', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      if (req.object.get('isBanned')) {\n        throw new Error('banned account');\n      }\n    });\n    const user = await Parse.User._logInWith('facebook');\n    const base64 = 'aHR0cHM6Ly9naXRodWIuY29tL2t2bmt1YW5n';\n    const file = new Parse.File('myfile.txt', {\n      base64\n    });\n    await file.save();\n    await user.save({\n      isBanned: true,\n      file\n    });\n    await Parse.User.logOut();\n    try {\n      await Parse.User._logInWith('facebook');\n      throw new Error('should not have continued login.');\n    } catch (e) {\n      expect(e.message).toBe('banned account');\n    }\n    expect(hit).toBe(1);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"logout with provider should call afterLogout trigger","suites":["Parse.User testing"],"line":1331,"updatePoint":{"line":1331,"column":58,"index":45078},"code":"  it('logout with provider should call afterLogout trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    let userId;\n    Parse.Cloud.afterLogout(req => {\n      expect(req.object.className).toEqual('_Session');\n      expect(req.object.id).toBeDefined();\n      const user = req.object.get('user');\n      expect(user).toBeDefined();\n      userId = user.id;\n    });\n    const user = await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    expect(user.id).toBe(userId);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"link with provider","suites":["Parse.User testing"],"line":1347,"updatePoint":{"line":1347,"column":24,"index":45629},"code":"  it('link with provider', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const model = await user._linkWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"link with provider for already linked user","suites":["Parse.User testing"],"line":1366,"updatePoint":{"line":1366,"column":48,"index":46528},"code":"  it('link with provider for already linked user', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProviderToAlreadyLinkedUser');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const model = await user._linkWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked.');\n    const user2 = new Parse.User();\n    user2.set('username', 'testLinkWithProviderToAlreadyLinkedUser2');\n    user2.set('password', 'mypass');\n    await user2.signUp();\n    try {\n      await user2._linkWith('facebook');\n      done.fail();\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.ACCOUNT_ALREADY_LINKED);\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"link with provider should return sessionToken","suites":["Parse.User testing"],"line":1392,"updatePoint":{"line":1392,"column":51,"index":47691},"code":"  it('link with provider should return sessionToken', async () => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const query = new Parse.Query(Parse.User);\n    const u2 = await query.get(user.id);\n    const model = await u2._linkWith('facebook', {}, {\n      useMasterKey: true\n    });\n    expect(u2.getSessionToken()).toBeDefined();\n    expect(model.getSessionToken()).toBeDefined();\n    expect(u2.getSessionToken()).toBe(model.getSessionToken());\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"link with provider via sessionToken should not create new sessionToken (Regression #5799)","suites":["Parse.User testing"],"line":1408,"updatePoint":{"line":1408,"column":95,"index":48400},"code":"  it('link with provider via sessionToken should not create new sessionToken (Regression #5799)', async () => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProviderNoOverride');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const sessionToken = user.getSessionToken();\n    await user._linkWith('facebook', {}, {\n      sessionToken\n    });\n    expect(sessionToken).toBe(user.getSessionToken());\n    expect(user._isLinked(provider)).toBe(true);\n    await user._unlinkFrom(provider, {\n      sessionToken\n    });\n    expect(user._isLinked(provider)).toBe(false);\n    const become = await Parse.User.become(sessionToken);\n    expect(sessionToken).toBe(become.getSessionToken());\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"link with provider failed","suites":["Parse.User testing"],"line":1428,"updatePoint":{"line":1428,"column":31,"index":49170},"code":"  it('link with provider failed', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldError = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    try {\n      await user._linkWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(error, 'Linking should fail');\n      ok(!user._isLinked('facebook'), 'User should not be linked to facebook');\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"link with provider cancelled","suites":["Parse.User testing"],"line":1445,"updatePoint":{"line":1445,"column":34,"index":49745},"code":"  it('link with provider cancelled', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldCancel = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    try {\n      await user._linkWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(!error, 'Linking should be cancelled');\n      ok(!user._isLinked('facebook'), 'User should not be linked to facebook');\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"unlink with provider","suites":["Parse.User testing"],"line":1462,"updatePoint":{"line":1462,"column":26,"index":50322},"code":"  it('unlink with provider', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User.');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook.');\n    await model._unlinkFrom('facebook');\n    ok(!model._isLinked('facebook'), 'User should not be linked.');\n    ok(!provider.synchronizedUserId, 'User id should be cleared.');\n    ok(!provider.synchronizedAuthToken, 'Auth token should be cleared.');\n    ok(!provider.synchronizedExpiration, 'Expiration should be cleared.');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"unlink and link","suites":["Parse.User testing"],"line":1480,"updatePoint":{"line":1480,"column":21,"index":51356},"code":"  it('unlink and link', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    await model._unlinkFrom('facebook');\n    ok(!model._isLinked('facebook'), 'User should not be linked to facebook');\n    ok(!provider.synchronizedUserId, 'User id should be cleared');\n    ok(!provider.synchronizedAuthToken, 'Auth token should be cleared');\n    ok(!provider.synchronizedExpiration, 'Expiration should be cleared');\n    await model._linkWith('facebook');\n    ok(provider.synchronizedUserId, 'User id should have a value');\n    ok(provider.synchronizedAuthToken, 'Auth token should have a value');\n    ok(provider.synchronizedExpiration, 'Expiration should have a value');\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"link multiple providers","suites":["Parse.User testing"],"line":1503,"updatePoint":{"line":1503,"column":29,"index":52734},"code":"  it('link multiple providers', async done => {\n    const provider = getMockFacebookProvider();\n    const mockProvider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    Parse.User._registerAuthenticationProvider(mockProvider);\n    const objectId = model.id;\n    await model._linkWith('myoauth');\n    expect(model.id).toEqual(objectId);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"link multiple providers and updates token","suites":["Parse.User testing"],"line":1523,"updatePoint":{"line":1523,"column":47,"index":53834},"code":"  it('link multiple providers and updates token', async done => {\n    const provider = getMockFacebookProvider();\n    const secondProvider = getMockFacebookProviderWithIdToken('8675309', 'jenny_valid_token');\n    const mockProvider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    Parse.User._registerAuthenticationProvider(mockProvider);\n    const objectId = model.id;\n    await model._linkWith('myoauth');\n    Parse.User._registerAuthenticationProvider(secondProvider);\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    const user = await Parse.User._logInWith('myoauth');\n    expect(user.id).toBe(objectId);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"link multiple providers and update token","suites":["Parse.User testing"],"line":1540,"updatePoint":{"line":1540,"column":46,"index":54623},"code":"  it('link multiple providers and update token', async done => {\n    const provider = getMockFacebookProvider();\n    const mockProvider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    Parse.User._registerAuthenticationProvider(mockProvider);\n    const objectId = model.id;\n    await model._linkWith('myoauth');\n    expect(model.id).toEqual(objectId);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n    await model._linkWith('facebook');\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should fail linking with existing","suites":["Parse.User testing"],"line":1563,"updatePoint":{"line":1563,"column":39,"index":55900},"code":"  it('should fail linking with existing', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    const user = new Parse.User();\n    user.setUsername('user');\n    user.setPassword('password');\n    await user.signUp();\n    // try to link here\n    try {\n      await user._linkWith('facebook');\n      done.fail();\n    } catch (e) {\n      done();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should fail linking with existing through REST","suites":["Parse.User testing"],"line":1580,"updatePoint":{"line":1580,"column":52,"index":56414},"code":"  it('should fail linking with existing through REST', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    const userId = model.id;\n    Parse.User.logOut().then(() => {\n      request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/_User',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json'\n        },\n        body: {\n          authData: {\n            facebook: provider.authData\n          }\n        }\n      }).then(response => {\n        const body = response.data;\n        // make sure the location header is properly set\n        expect(userId).not.toBeUndefined();\n        expect(body.objectId).toEqual(userId);\n        expect(response.headers.location).toEqual(Parse.serverURL + '/users/' + userId);\n        done();\n      });\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should allow login with old authData token","suites":["Parse.User testing"],"line":1609,"updatePoint":{"line":1609,"column":48,"index":57416},"code":"  it('should allow login with old authData token', done => {\n    const provider = {\n      authData: {\n        id: '12345',\n        access_token: 'token'\n      },\n      restoreAuthentication: function () {\n        return true;\n      },\n      deauthenticate: function () {\n        provider.authData = {};\n      },\n      authenticate: function (options) {\n        options.success(this, provider.authData);\n      },\n      getAuthType: function () {\n        return 'shortLivedAuth';\n      }\n    };\n    defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('token');\n    Parse.User._registerAuthenticationProvider(provider);\n    Parse.User._logInWith('shortLivedAuth', {}).then(() => {\n      // Simulate a remotely expired token (like a short lived one)\n      // In this case, we want success as it was valid once.\n      // If the client needs an updated one, do lock the user out\n      defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('otherToken');\n      return Parse.User._logInWith('shortLivedAuth', {});\n    }).then(() => {\n      done();\n    }, err => {\n      done.fail(err);\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should allow PUT request with stale auth Data","suites":["Parse.User testing"],"line":1642,"updatePoint":{"line":1642,"column":51,"index":58527},"code":"  it('should allow PUT request with stale auth Data', done => {\n    const provider = {\n      authData: {\n        id: '12345',\n        access_token: 'token'\n      },\n      restoreAuthentication: function () {\n        return true;\n      },\n      deauthenticate: function () {\n        provider.authData = {};\n      },\n      authenticate: function (options) {\n        options.success(this, provider.authData);\n      },\n      getAuthType: function () {\n        return 'shortLivedAuth';\n      }\n    };\n    defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('token');\n    Parse.User._registerAuthenticationProvider(provider);\n    Parse.User._logInWith('shortLivedAuth', {}).then(() => {\n      // Simulate a remotely expired token (like a short lived one)\n      // In this case, we want success as it was valid once.\n      // If the client needs an updated one, do lock the user out\n      defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('otherToken');\n      return request({\n        method: 'PUT',\n        url: Parse.serverURL + '/users/' + Parse.User.current().id,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'X-Parse-Session-Token': Parse.User.current().getSessionToken(),\n          'Content-Type': 'application/json'\n        },\n        body: {\n          key: 'value',\n          // update a key\n          authData: {\n            // pass the original auth data\n            shortLivedAuth: {\n              id: '12345',\n              access_token: 'token'\n            }\n          }\n        }\n      });\n    }).then(() => {\n      done();\n    }, err => {\n      done.fail(err);\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should properly error when password is missing","suites":["Parse.User testing"],"line":1695,"updatePoint":{"line":1695,"column":52,"index":60229},"code":"  it('should properly error when password is missing', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = await Parse.User._logInWith('facebook');\n    user.set('username', 'myUser');\n    user.set('email', 'foo@example.com');\n    user.save().then(() => {\n      return Parse.User.logOut();\n    }).then(() => {\n      return Parse.User.logIn('myUser', 'password');\n    }).then(() => {\n      fail('should not succeed');\n      done();\n    }, err => {\n      expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      expect(err.message).toEqual('Invalid username/password.');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should have authData in beforeSave and afterSave","suites":["Parse.User testing"],"line":1714,"updatePoint":{"line":1714,"column":54,"index":60916},"code":"  it('should have authData in beforeSave and afterSave', async done => {\n    Parse.Cloud.beforeSave('_User', request => {\n      const authData = request.object.get('authData');\n      expect(authData).not.toBeUndefined();\n      if (authData) {\n        expect(authData.facebook.id).toEqual('8675309');\n        expect(authData.facebook.access_token).toEqual('jenny');\n      } else {\n        fail('authData should be set');\n      }\n    });\n    Parse.Cloud.afterSave('_User', request => {\n      const authData = request.object.get('authData');\n      expect(authData).not.toBeUndefined();\n      if (authData) {\n        expect(authData.facebook.id).toEqual('8675309');\n        expect(authData.facebook.access_token).toEqual('jenny');\n      } else {\n        fail('authData should be set');\n      }\n    });\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"set password then change password","suites":["Parse.User testing"],"line":1740,"updatePoint":{"line":1740,"column":39,"index":61868},"code":"  it('set password then change password', done => {\n    Parse.User.signUp('bob', 'barker').then(bob => {\n      bob.setPassword('meower');\n      return bob.save();\n    }).then(() => {\n      return Parse.User.logIn('bob', 'meower');\n    }).then(bob => {\n      expect(bob.getUsername()).toEqual('bob');\n      done();\n    }, e => {\n      console.log(e);\n      fail();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"authenticated check","suites":["Parse.User testing"],"line":1754,"updatePoint":{"line":1754,"column":25,"index":62232},"code":"  it('authenticated check', async done => {\n    const user = new Parse.User();\n    user.set('username', 'darkhelmet');\n    user.set('password', 'onetwothreefour');\n    ok(!user.authenticated());\n    await user.signUp(null);\n    ok(user.authenticated());\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"log in with explicit facebook auth data","suites":["Parse.User testing"],"line":1763,"updatePoint":{"line":1763,"column":45,"index":62524},"code":"  it('log in with explicit facebook auth data', async done => {\n    await Parse.FacebookUtils.logIn({\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON()\n    });\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"log in async with explicit facebook auth data","suites":["Parse.User testing"],"line":1771,"updatePoint":{"line":1771,"column":51,"index":62751},"code":"  it('log in async with explicit facebook auth data', done => {\n    Parse.FacebookUtils.logIn({\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON()\n    }).then(function () {\n      done();\n    }, function (error) {\n      ok(false, error);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"link with explicit facebook auth data","suites":["Parse.User testing"],"line":1783,"updatePoint":{"line":1783,"column":43,"index":63050},"code":"  it('link with explicit facebook auth data', async done => {\n    const user = await Parse.User.signUp('mask', 'open sesame');\n    Parse.FacebookUtils.link(user, {\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON()\n    }).then(done, error => {\n      jfail(error);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"link async with explicit facebook auth data","suites":["Parse.User testing"],"line":1794,"updatePoint":{"line":1794,"column":49,"index":63390},"code":"  it('link async with explicit facebook auth data', async done => {\n    const user = await Parse.User.signUp('mask', 'open sesame');\n    Parse.FacebookUtils.link(user, {\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON()\n    }).then(function () {\n      done();\n    }, function (error) {\n      ok(false, error);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"async methods","suites":["Parse.User testing"],"line":1807,"updatePoint":{"line":1807,"column":19,"index":63741},"code":"  it('async methods', done => {\n    const data = {\n      foo: 'bar'\n    };\n    Parse.User.signUp('finn', 'human', data).then(function (user) {\n      equal(Parse.User.current(), user);\n      equal(user.get('foo'), 'bar');\n      return Parse.User.logOut();\n    }).then(function () {\n      return Parse.User.logIn('finn', 'human');\n    }).then(function (user) {\n      equal(user, Parse.User.current());\n      equal(user.get('foo'), 'bar');\n      return Parse.User.logOut();\n    }).then(function () {\n      const user = new Parse.User();\n      user.set('username', 'jake');\n      user.set('password', 'dog');\n      user.set('foo', 'baz');\n      return user.signUp();\n    }).then(function (user) {\n      equal(user, Parse.User.current());\n      equal(user.get('foo'), 'baz');\n      user = new Parse.User();\n      user.set('username', 'jake');\n      user.set('password', 'dog');\n      return user.logIn();\n    }).then(function (user) {\n      equal(user, Parse.User.current());\n      equal(user.get('foo'), 'baz');\n      const userAgain = new Parse.User();\n      userAgain.id = user.id;\n      return userAgain.fetch();\n    }).then(function (userAgain) {\n      equal(userAgain.get('foo'), 'baz');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"querying for users doesn't get session tokens","suites":["Parse.User testing"],"line":1845,"updatePoint":{"line":1845,"column":51,"index":64990},"code":"  it(\"querying for users doesn't get session tokens\", done => {\n    Parse.User.signUp('finn', 'human', {\n      foo: 'bar'\n    }).then(function () {\n      return Parse.User.logOut();\n    }).then(() => {\n      const user = new Parse.User();\n      user.set('username', 'jake');\n      user.set('password', 'dog');\n      user.set('foo', 'baz');\n      return user.signUp();\n    }).then(function () {\n      return Parse.User.logOut();\n    }).then(() => {\n      const query = new Parse.Query(Parse.User);\n      return query.find({\n        sessionToken: null\n      });\n    }).then(function (users) {\n      equal(users.length, 2);\n      users.forEach(user => {\n        expect(user.getSessionToken()).toBeUndefined();\n        ok(!user.getSessionToken(), 'user should not have a session token.');\n      });\n      done();\n    }, function (error) {\n      ok(false, error);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"querying for users only gets the expected fields","suites":["Parse.User testing"],"line":1875,"updatePoint":{"line":1875,"column":54,"index":65880},"code":"  it('querying for users only gets the expected fields', done => {\n    Parse.User.signUp('finn', 'human', {\n      foo: 'bar'\n    }).then(() => {\n      request({\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        url: 'http://localhost:8378/1/users'\n      }).then(response => {\n        const b = response.data;\n        expect(b.results.length).toEqual(1);\n        const user = b.results[0];\n        expect(Object.keys(user).length).toEqual(6);\n        done();\n      });\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"retrieve user data from fetch, make sure the session token hasn't changed","suites":["Parse.User testing"],"line":1894,"updatePoint":{"line":1894,"column":79,"index":66460},"code":"  it(\"retrieve user data from fetch, make sure the session token hasn't changed\", done => {\n    const user = new Parse.User();\n    user.setPassword('asdf');\n    user.setUsername('zxcv');\n    let currentSessionToken = '';\n    Promise.resolve().then(function () {\n      return user.signUp();\n    }).then(function () {\n      currentSessionToken = user.getSessionToken();\n      return user.fetch();\n    }).then(function (u) {\n      expect(currentSessionToken).toEqual(u.getSessionToken());\n      done();\n    }, function (error) {\n      ok(false, error);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user save should fail with invalid email","suites":["Parse.User testing"],"line":1912,"updatePoint":{"line":1912,"column":46,"index":67005},"code":"  it('user save should fail with invalid email', done => {\n    const user = new Parse.User();\n    user.set('username', 'teste');\n    user.set('password', 'test');\n    user.set('email', 'invalid');\n    user.signUp().then(() => {\n      fail('Should not have been able to save.');\n      done();\n    }, error => {\n      expect(error.code).toEqual(125);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user signup should error if email taken","suites":["Parse.User testing"],"line":1925,"updatePoint":{"line":1925,"column":45,"index":67381},"code":"  it('user signup should error if email taken', done => {\n    const user = new Parse.User();\n    user.set('username', 'test1');\n    user.set('password', 'test');\n    user.set('email', 'test@test.com');\n    user.signUp().then(() => {\n      const user2 = new Parse.User();\n      user2.set('username', 'test2');\n      user2.set('password', 'test');\n      user2.set('email', 'test@test.com');\n      return user2.signUp();\n    }).then(() => {\n      fail('Should not have been able to sign up.');\n      done();\n    }, () => {\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"signup should fail with duplicate case insensitive username with basic setter","suites":["Parse.User testing","case insensitive signup not allowed"],"line":1944,"updatePoint":{"line":1944,"column":85,"index":68027},"code":"    it('signup should fail with duplicate case insensitive username with basic setter', async () => {\n      const user = new Parse.User();\n      user.set('username', 'test1');\n      user.set('password', 'test');\n      await user.signUp();\n      const user2 = new Parse.User();\n      user2.set('username', 'Test1');\n      user2.set('password', 'test');\n      await expectAsync(user2.signUp()).toBeRejectedWith(new Parse.Error(Parse.Error.USERNAME_TAKEN, 'Account already exists for this username.'));\n    });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"signup should fail with duplicate case insensitive username with field specific setter","suites":["Parse.User testing","case insensitive signup not allowed"],"line":1954,"updatePoint":{"line":1954,"column":94,"index":68544},"code":"    it('signup should fail with duplicate case insensitive username with field specific setter', async () => {\n      const user = new Parse.User();\n      user.setUsername('test1');\n      user.setPassword('test');\n      await user.signUp();\n      const user2 = new Parse.User();\n      user2.setUsername('Test1');\n      user2.setPassword('test');\n      await expectAsync(user2.signUp()).toBeRejectedWith(new Parse.Error(Parse.Error.USERNAME_TAKEN, 'Account already exists for this username.'));\n    });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"signup should fail with duplicate case insensitive email","suites":["Parse.User testing","case insensitive signup not allowed"],"line":1964,"updatePoint":{"line":1964,"column":64,"index":69015},"code":"    it('signup should fail with duplicate case insensitive email', async () => {\n      const user = new Parse.User();\n      user.setUsername('test1');\n      user.setPassword('test');\n      user.setEmail('test@example.com');\n      await user.signUp();\n      const user2 = new Parse.User();\n      user2.setUsername('test2');\n      user2.setPassword('test');\n      user2.setEmail('Test@Example.Com');\n      await expectAsync(user2.signUp()).toBeRejectedWith(new Parse.Error(Parse.Error.EMAIL_TAKEN, 'Account already exists for this email address.'));\n    });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"edit should fail with duplicate case insensitive email","suites":["Parse.User testing","case insensitive signup not allowed"],"line":1976,"updatePoint":{"line":1976,"column":62,"index":69569},"code":"    it('edit should fail with duplicate case insensitive email', async () => {\n      const user = new Parse.User();\n      user.setUsername('test1');\n      user.setPassword('test');\n      user.setEmail('test@example.com');\n      await user.signUp();\n      const user2 = new Parse.User();\n      user2.setUsername('test2');\n      user2.setPassword('test');\n      user2.setEmail('Foo@Example.Com');\n      await user2.signUp();\n      user2.setEmail('Test@Example.Com');\n      await expectAsync(user2.save()).toBeRejectedWith(new Parse.Error(Parse.Error.EMAIL_TAKEN, 'Account already exists for this email address.'));\n    });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not fail on case insensitive matches","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":1997,"updatePoint":{"line":1997,"column":53,"index":70808},"code":"      it('should not fail on case insensitive matches', async () => {\n        const user1 = await Parse.AnonymousUtils.logIn();\n        const username1 = user1.get('username');\n        const user2 = await Parse.AnonymousUtils.logIn();\n        const username2 = user2.get('username');\n        expect(username1).not.toBeUndefined();\n        expect(username2).not.toBeUndefined();\n        expect(username1.toLowerCase()).toBe('abcdefghijklmnop');\n        expect(username2.toLowerCase()).toBe('abcdefghijklmnop');\n        expect(username2).not.toBe(username1);\n        expect(username2.toLowerCase()).toBe(username1.toLowerCase()); // this is redundant :).\n      });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user cannot update email to existing user","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2012,"updatePoint":{"line":2012,"column":47,"index":71480},"code":"  it('user cannot update email to existing user', done => {\n    const user = new Parse.User();\n    user.set('username', 'test1');\n    user.set('password', 'test');\n    user.set('email', 'test@test.com');\n    user.signUp().then(() => {\n      const user2 = new Parse.User();\n      user2.set('username', 'test2');\n      user2.set('password', 'test');\n      return user2.signUp();\n    }).then(user2 => {\n      user2.set('email', 'test@test.com');\n      return user2.save();\n    }).then(() => {\n      fail('Should not have been able to sign up.');\n      done();\n    }, () => {\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"unset user email","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2032,"updatePoint":{"line":2032,"column":22,"index":72055},"code":"  it('unset user email', done => {\n    const user = new Parse.User();\n    user.set('username', 'test');\n    user.set('password', 'test');\n    user.set('email', 'test@test.com');\n    user.signUp().then(() => {\n      user.unset('email');\n      return user.save();\n    }).then(() => {\n      return Parse.User.logIn('test', 'test');\n    }).then(user => {\n      expect(user.getEmail()).toBeUndefined();\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"create session from user","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2047,"updatePoint":{"line":2047,"column":30,"index":72489},"code":"  it('create session from user', done => {\n    Promise.resolve().then(() => {\n      return Parse.User.signUp('finn', 'human', {\n        foo: 'bar'\n      });\n    }).then(user => {\n      request({\n        method: 'POST',\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Session-Token': user.getSessionToken(),\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        url: 'http://localhost:8378/1/sessions'\n      }).then(response => {\n        const b = response.data;\n        expect(typeof b.sessionToken).toEqual('string');\n        expect(typeof b.createdWith).toEqual('object');\n        expect(b.createdWith.action).toEqual('create');\n        expect(typeof b.user).toEqual('object');\n        expect(b.user.objectId).toEqual(user.id);\n        done();\n      });\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user get session from token on signup","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2072,"updatePoint":{"line":2072,"column":43,"index":73312},"code":"  it('user get session from token on signup', async () => {\n    const user = await Parse.User.signUp('finn', 'human', {\n      foo: 'bar'\n    });\n    const response = await request({\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Session-Token': user.getSessionToken(),\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      url: 'http://localhost:8378/1/sessions/me'\n    });\n    const data = response.data;\n    expect(typeof data.sessionToken).toEqual('string');\n    expect(typeof data.createdWith).toEqual('object');\n    expect(data.createdWith.action).toEqual('signup');\n    expect(data.createdWith.authProvider).toEqual('password');\n    expect(typeof data.user).toEqual('object');\n    expect(data.user.objectId).toEqual(user.id);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user get session from token on username/password login","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2092,"updatePoint":{"line":2092,"column":60,"index":74096},"code":"  it('user get session from token on username/password login', async () => {\n    await Parse.User.signUp('finn', 'human', {\n      foo: 'bar'\n    });\n    await Parse.User.logOut();\n    const user = await Parse.User.logIn('finn', 'human');\n    const response = await request({\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Session-Token': user.getSessionToken(),\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      url: 'http://localhost:8378/1/sessions/me'\n    });\n    const data = response.data;\n    expect(typeof data.sessionToken).toEqual('string');\n    expect(typeof data.createdWith).toEqual('object');\n    expect(data.createdWith.action).toEqual('login');\n    expect(data.createdWith.authProvider).toEqual('password');\n    expect(typeof data.user).toEqual('object');\n    expect(data.user.objectId).toEqual(user.id);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user get session from token on anonymous login","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2114,"updatePoint":{"line":2114,"column":52,"index":74947},"code":"  it('user get session from token on anonymous login', async () => {\n    const user = await Parse.AnonymousUtils.logIn();\n    const response = await request({\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Session-Token': user.getSessionToken(),\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      url: 'http://localhost:8378/1/sessions/me'\n    });\n    const data = response.data;\n    expect(typeof data.sessionToken).toEqual('string');\n    expect(typeof data.createdWith).toEqual('object');\n    expect(data.createdWith.action).toEqual('login');\n    expect(data.createdWith.authProvider).toEqual('anonymous');\n    expect(typeof data.user).toEqual('object');\n    expect(data.user.objectId).toEqual(user.id);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user update session with other field","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2132,"updatePoint":{"line":2132,"column":42,"index":75681},"code":"  it('user update session with other field', done => {\n    Promise.resolve().then(() => {\n      return Parse.User.signUp('finn', 'human', {\n        foo: 'bar'\n      });\n    }).then(user => {\n      request({\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Session-Token': user.getSessionToken(),\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        url: 'http://localhost:8378/1/sessions/me'\n      }).then(response => {\n        const b = response.data;\n        request({\n          method: 'PUT',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest'\n          },\n          url: 'http://localhost:8378/1/sessions/' + b.objectId,\n          body: JSON.stringify({\n            foo: 'bar'\n          })\n        }).then(() => {\n          done();\n        });\n      });\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"cannot update session if invalid or no session token","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2164,"updatePoint":{"line":2164,"column":58,"index":76629},"code":"  it('cannot update session if invalid or no session token', done => {\n    Promise.resolve().then(() => {\n      return Parse.User.signUp('finn', 'human', {\n        foo: 'bar'\n      });\n    }).then(user => {\n      request({\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Session-Token': user.getSessionToken(),\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        url: 'http://localhost:8378/1/sessions/me'\n      }).then(response => {\n        const b = response.data;\n        request({\n          method: 'PUT',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': 'foo',\n            'X-Parse-REST-API-Key': 'rest',\n            'Content-Type': 'application/json'\n          },\n          url: 'http://localhost:8378/1/sessions/' + b.objectId,\n          body: JSON.stringify({\n            foo: 'bar'\n          })\n        }).then(fail, response => {\n          const b = response.data;\n          expect(b.error).toBe('Invalid session token');\n          request({\n            method: 'PUT',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest'\n            },\n            url: 'http://localhost:8378/1/sessions/' + b.objectId,\n            body: JSON.stringify({\n              foo: 'bar'\n            })\n          }).then(fail, response => {\n            const b = response.data;\n            expect(b.error).toBe('Session token required.');\n            done();\n          });\n        });\n      });\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"get session only for current user","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2213,"updatePoint":{"line":2213,"column":39,"index":78165},"code":"  it('get session only for current user', done => {\n    Promise.resolve().then(() => {\n      return Parse.User.signUp('test1', 'test', {\n        foo: 'bar'\n      });\n    }).then(() => {\n      return Parse.User.signUp('test2', 'test', {\n        foo: 'bar'\n      });\n    }).then(user => {\n      request({\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Session-Token': user.getSessionToken(),\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        url: 'http://localhost:8378/1/sessions'\n      }).then(response => {\n        const b = response.data;\n        expect(b.results.length).toEqual(1);\n        expect(typeof b.results[0].user).toEqual('object');\n        expect(b.results[0].user.objectId).toEqual(user.id);\n        done();\n      });\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"delete session by object","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2239,"updatePoint":{"line":2239,"column":30,"index":78948},"code":"  it('delete session by object', done => {\n    Promise.resolve().then(() => {\n      return Parse.User.signUp('test1', 'test', {\n        foo: 'bar'\n      });\n    }).then(() => {\n      return Parse.User.signUp('test2', 'test', {\n        foo: 'bar'\n      });\n    }).then(user => {\n      request({\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Session-Token': user.getSessionToken(),\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        url: 'http://localhost:8378/1/sessions'\n      }).then(response => {\n        const b = response.data;\n        let objId;\n        try {\n          expect(b.results.length).toEqual(1);\n          objId = b.results[0].objectId;\n        } catch (e) {\n          jfail(e);\n          done();\n          return;\n        }\n        request({\n          method: 'DELETE',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest'\n          },\n          url: 'http://localhost:8378/1/sessions/' + objId\n        }).then(() => {\n          request({\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-Session-Token': user.getSessionToken(),\n              'X-Parse-REST-API-Key': 'rest'\n            },\n            url: 'http://localhost:8378/1/sessions'\n          }).then(fail, response => {\n            const b = response.data;\n            expect(b.code).toEqual(209);\n            expect(b.error).toBe('Invalid session token');\n            done();\n          });\n        });\n      });\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"cannot delete session if no sessionToken","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2293,"updatePoint":{"line":2293,"column":46,"index":80574},"code":"  it('cannot delete session if no sessionToken', done => {\n    Promise.resolve().then(() => {\n      return Parse.User.signUp('test1', 'test', {\n        foo: 'bar'\n      });\n    }).then(() => {\n      return Parse.User.signUp('test2', 'test', {\n        foo: 'bar'\n      });\n    }).then(user => {\n      request({\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Session-Token': user.getSessionToken(),\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        url: 'http://localhost:8378/1/sessions'\n      }).then(response => {\n        const b = response.data;\n        expect(b.results.length).toEqual(1);\n        const objId = b.results[0].objectId;\n        request({\n          method: 'DELETE',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest'\n          },\n          url: 'http://localhost:8378/1/sessions/' + objId\n        }).then(fail, response => {\n          const b = response.data;\n          expect(b.code).toEqual(209);\n          expect(b.error).toBe('Invalid session token');\n          done();\n        });\n      });\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"password format matches hosted parse","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2330,"updatePoint":{"line":2330,"column":42,"index":81702},"code":"  it('password format matches hosted parse', done => {\n    const hashed = '$2a$10$8/wZJyEuiEaobBBqzTG.jeY.XSFJd0rzaN//ososvEI4yLqI.4aie';\n    passwordCrypto.compare('test', hashed).then(pass => {\n      expect(pass).toBe(true);\n      done();\n    }, () => {\n      fail('Password format did not match.');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"changing password clears sessions","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2340,"updatePoint":{"line":2340,"column":39,"index":82029},"code":"  it('changing password clears sessions', done => {\n    let sessionToken = null;\n    Promise.resolve().then(function () {\n      return Parse.User.signUp('fosco', 'parse');\n    }).then(function (newUser) {\n      equal(Parse.User.current(), newUser);\n      sessionToken = newUser.getSessionToken();\n      ok(sessionToken);\n      newUser.set('password', 'facebook');\n      return newUser.save();\n    }).then(function () {\n      return Parse.User.become(sessionToken);\n    }).then(function () {\n      fail('Session should have been invalidated');\n      done();\n    }, function (err) {\n      expect(err.code).toBe(Parse.Error.INVALID_SESSION_TOKEN);\n      expect(err.message).toBe('Invalid session token');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"test parse user become","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2361,"updatePoint":{"line":2361,"column":28,"index":82748},"code":"  it('test parse user become', done => {\n    let sessionToken = null;\n    Promise.resolve().then(function () {\n      return Parse.User.signUp('flessard', 'folo', {\n        foo: 1\n      });\n    }).then(function (newUser) {\n      equal(Parse.User.current(), newUser);\n      sessionToken = newUser.getSessionToken();\n      ok(sessionToken);\n      newUser.set('foo', 2);\n      return newUser.save();\n    }).then(function () {\n      return Parse.User.become(sessionToken);\n    }).then(function (newUser) {\n      equal(newUser.get('foo'), 2);\n      done();\n    }, function () {\n      fail('The session should still be valid');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"ensure logout works","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2383,"updatePoint":{"line":2383,"column":25,"index":83394},"code":"  it('ensure logout works', done => {\n    let user = null;\n    let sessionToken = null;\n    Promise.resolve().then(function () {\n      return Parse.User.signUp('log', 'out');\n    }).then(newUser => {\n      user = newUser;\n      sessionToken = user.getSessionToken();\n      return Parse.User.logOut();\n    }).then(() => {\n      user.set('foo', 'bar');\n      return user.save(null, {\n        sessionToken: sessionToken\n      });\n    }).then(() => {\n      fail('Save should have failed.');\n      done();\n    }, e => {\n      expect(e.code).toEqual(Parse.Error.INVALID_SESSION_TOKEN);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"support user/password signup with empty authData block","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2405,"updatePoint":{"line":2405,"column":60,"index":84037},"code":"  it('support user/password signup with empty authData block', done => {\n    // The android SDK can send an empty authData object along with username and password.\n    Parse.User.signUp('artof', 'thedeal', {\n      authData: {}\n    }).then(() => {\n      done();\n    }, () => {\n      fail('Signup should have succeeded.');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"session expiresAt correct format","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2416,"updatePoint":{"line":2416,"column":38,"index":84364},"code":"  it('session expiresAt correct format', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      url: 'http://localhost:8378/1/classes/_Session',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Master-Key': 'test'\n      }\n    }).then(response => {\n      const body = response.data;\n      expect(body.results[0].expiresAt.__type).toEqual('Date');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"Invalid session tokens are rejected","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2430,"updatePoint":{"line":2430,"column":41,"index":84794},"code":"  it('Invalid session tokens are rejected', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      url: 'http://localhost:8378/1/classes/AClass',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Rest-API-Key': 'rest',\n        'X-Parse-Session-Token': 'text'\n      }\n    }).then(fail, response => {\n      const body = response.data;\n      expect(body.code).toBe(209);\n      expect(body.error).toBe('Invalid session token');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should cleanup null authData keys ParseUser update (regression test for #1198, #2252)","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2490,"updatePoint":{"line":2490,"column":91,"index":86914},"code":"  it('should cleanup null authData keys ParseUser update (regression test for #1198, #2252)', done => {\n    Parse.Cloud.beforeSave('_User', req => {\n      req.object.set('foo', 'bar');\n    });\n    let originalSessionToken;\n    let originalUserId;\n    // Simulate anonymous user save\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      body: {\n        authData: {\n          anonymous: {\n            id: '00000000-0000-0000-0000-000000000001'\n          }\n        }\n      }\n    }).then(response => response.data).then(user => {\n      originalSessionToken = user.sessionToken;\n      originalUserId = user.objectId;\n      // Simulate registration\n      return request({\n        method: 'PUT',\n        url: 'http://localhost:8378/1/classes/_User/' + user.objectId,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Session-Token': user.sessionToken,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json'\n        },\n        body: {\n          authData: {\n            anonymous: null\n          },\n          username: 'user',\n          password: 'password'\n        }\n      }).then(response => {\n        return response.data;\n      });\n    }).then(user => {\n      expect(typeof user).toEqual('object');\n      expect(user.authData).toBeUndefined();\n      expect(user.sessionToken).not.toBeUndefined();\n      // Session token should have changed\n      expect(user.sessionToken).not.toEqual(originalSessionToken);\n      // test that the sessionToken is valid\n      return request({\n        url: 'http://localhost:8378/1/users/me',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Session-Token': user.sessionToken,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json'\n        }\n      }).then(response => {\n        const body = response.data;\n        expect(body.username).toEqual('user');\n        expect(body.objectId).toEqual(originalUserId);\n        done();\n      });\n    }).catch(err => {\n      fail('no request should fail: ' + JSON.stringify(err));\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should send email when upgrading from anon","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2561,"updatePoint":{"line":2561,"column":48,"index":89203},"code":"  it('should send email when upgrading from anon', async done => {\n    await reconfigureServer();\n    let emailCalled = false;\n    let emailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        emailOptions = options;\n        emailCalled = true;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    await reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    // Simulate anonymous user save\n    return request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      body: {\n        authData: {\n          anonymous: {\n            id: '00000000-0000-0000-0000-000000000001'\n          }\n        }\n      }\n    }).then(response => {\n      const user = response.data;\n      return request({\n        method: 'PUT',\n        url: 'http://localhost:8378/1/classes/_User/' + user.objectId,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Session-Token': user.sessionToken,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json'\n        },\n        body: {\n          authData: {\n            anonymous: null\n          },\n          username: 'user',\n          email: 'user@email.com',\n          password: 'password'\n        }\n      });\n    }).then(() => {\n      expect(emailCalled).toBe(true);\n      expect(emailOptions).not.toBeUndefined();\n      expect(emailOptions.user.get('email')).toEqual('user@email.com');\n      done();\n    }).catch(err => {\n      jfail(err);\n      fail('no request should fail: ' + JSON.stringify(err));\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not send email when email is not a string","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2626,"updatePoint":{"line":2626,"column":54,"index":91131},"code":"  it('should not send email when email is not a string', async done => {\n    let emailCalled = false;\n    let emailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        emailOptions = options;\n        emailCalled = true;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    await reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    const user = new Parse.User();\n    user.set('username', 'asdf@jkl.com');\n    user.set('password', 'zxcv');\n    user.set('email', 'asdf@jkl.com');\n    await user.signUp();\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/requestPasswordReset',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Session-Token': user.sessionToken,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      body: {\n        email: {\n          $regex: '^asd'\n        }\n      }\n    }).then(res => {\n      fail('no request should succeed: ' + JSON.stringify(res));\n      done();\n    }).catch(err => {\n      expect(emailCalled).toBeTruthy();\n      expect(emailOptions).toBeDefined();\n      expect(err.status).toBe(400);\n      expect(err.text).toMatch('{\"code\":125,\"error\":\"you must provide a valid email string\"}');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should aftersave with full object","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2673,"updatePoint":{"line":2673,"column":39,"index":92580},"code":"  it('should aftersave with full object', done => {\n    let hit = 0;\n    Parse.Cloud.afterSave('_User', (req, res) => {\n      hit++;\n      expect(req.object.get('username')).toEqual('User');\n      res.success();\n    });\n    const user = new Parse.User();\n    user.setUsername('User');\n    user.setPassword('pass');\n    user.signUp().then(() => {\n      user.set('hello', 'world');\n      return user.save();\n    }).then(() => {\n      expect(hit).toBe(2);\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"changes to a user should update the cache","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2691,"updatePoint":{"line":2691,"column":47,"index":93069},"code":"  it('changes to a user should update the cache', done => {\n    Parse.Cloud.define('testUpdatedUser', req => {\n      expect(req.user.get('han')).toEqual('solo');\n      return {};\n    });\n    const user = new Parse.User();\n    user.setUsername('harrison');\n    user.setPassword('ford');\n    user.signUp().then(() => {\n      user.set('han', 'solo');\n      return user.save();\n    }).then(() => {\n      return Parse.Cloud.run('testUpdatedUser');\n    }).then(() => {\n      done();\n    }, () => {\n      fail('Should not have failed.');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should fail to become user with expired token","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2711,"updatePoint":{"line":2711,"column":51,"index":93632},"code":"  it('should fail to become user with expired token', done => {\n    let token;\n    Parse.User.signUp('auser', 'somepass', null).then(() => request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/classes/_Session',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Master-Key': 'test'\n      }\n    })).then(response => {\n      const body = response.data;\n      const id = body.results[0].objectId;\n      const expiresAt = new Date(new Date().setYear(2015));\n      token = body.results[0].sessionToken;\n      return request({\n        method: 'PUT',\n        url: 'http://localhost:8378/1/classes/_Session/' + id,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Master-Key': 'test',\n          'Content-Type': 'application/json'\n        },\n        body: {\n          expiresAt: {\n            __type: 'Date',\n            iso: expiresAt.toISOString()\n          }\n        }\n      });\n    }).then(() => Parse.User.become(token)).then(() => {\n      fail('Should not have succeded');\n      done();\n    }, error => {\n      expect(error.code).toEqual(209);\n      expect(error.message).toEqual('Session token is expired.');\n      done();\n    }).catch(done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not create extraneous session tokens","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2749,"updatePoint":{"line":2749,"column":49,"index":94854},"code":"  it('should not create extraneous session tokens', done => {\n    const config = Config.get(Parse.applicationId);\n    config.database.loadSchema().then(s => {\n      // Lock down the _User class for creation\n      return s.addClassIfNotExists('_User', {}, {\n        create: {}\n      });\n    }).then(() => {\n      const user = new Parse.User();\n      return user.save({\n        username: 'user',\n        password: 'pass'\n      });\n    }).then(() => {\n      fail('should not be able to save the user');\n    }, () => {\n      return Promise.resolve();\n    }).then(() => {\n      const q = new Parse.Query('_Session');\n      return q.find({\n        useMasterKey: true\n      });\n    }).then(res => {\n      // We should have no session created\n      expect(res.length).toBe(0);\n      done();\n    }, () => {\n      fail('should not fail');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not overwrite username when unlinking facebook user (regression test for #1532)","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2780,"updatePoint":{"line":2780,"column":92,"index":95754},"code":"  it('should not overwrite username when unlinking facebook user (regression test for #1532)', async done => {\n    Parse.Object.disableSingleInstance();\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    let user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    await user._linkWith('facebook');\n    expect(user.get('username')).toEqual('testLinkWithProvider');\n    expect(Parse.FacebookUtils.isLinked(user)).toBeTruthy();\n    await user._unlinkFrom('facebook');\n    user = await user.fetch();\n    expect(user.get('username')).toEqual('testLinkWithProvider');\n    expect(Parse.FacebookUtils.isLinked(user)).toBeFalsy();\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should revoke sessions when converting anonymous user to \"normal\" user","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2797,"updatePoint":{"line":2797,"column":76,"index":96521},"code":"  it('should revoke sessions when converting anonymous user to \"normal\" user', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      body: {\n        authData: {\n          anonymous: {\n            id: '00000000-0000-0000-0000-000000000001'\n          }\n        }\n      }\n    }).then(response => {\n      const body = response.data;\n      Parse.User.become(body.sessionToken).then(user => {\n        const obj = new Parse.Object('TestObject');\n        obj.setACL(new Parse.ACL(user));\n        return obj.save().then(() => {\n          // Change password, revoking session\n          user.set('username', 'no longer anonymous');\n          user.set('password', 'password');\n          return user.save();\n        }).then(() => {\n          // Session token should have been recycled\n          expect(body.sessionToken).not.toEqual(user.getSessionToken());\n        }).then(() => obj.fetch()).then(() => {\n          done();\n        }).catch(() => {\n          fail('should not fail');\n          done();\n        });\n      });\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not revoke session tokens if the server is configures to not revoke session tokens","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2835,"updatePoint":{"line":2835,"column":95,"index":97779},"code":"  it('should not revoke session tokens if the server is configures to not revoke session tokens', done => {\n    reconfigureServer({\n      revokeSessionOnPasswordReset: false\n    }).then(() => {\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/_User',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json'\n        },\n        body: {\n          authData: {\n            anonymous: {\n              id: '00000000-0000-0000-0000-000000000001'\n            }\n          }\n        }\n      }).then(response => {\n        const body = response.data;\n        Parse.User.become(body.sessionToken).then(user => {\n          const obj = new Parse.Object('TestObject');\n          obj.setACL(new Parse.ACL(user));\n          return obj.save().then(() => {\n            // Change password, revoking session\n            user.set('username', 'no longer anonymous');\n            user.set('password', 'password');\n            return user.save();\n          }).then(() => obj.fetch())\n          // fetch should succeed as we still have our session token\n          .then(done, fail);\n        });\n      });\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not fail querying non existing relations","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2871,"updatePoint":{"line":2871,"column":53,"index":98972},"code":"  it('should not fail querying non existing relations', done => {\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world'\n    });\n    user.signUp().then(() => {\n      return Parse.User.current().relation('relation').query().find();\n    }).then(res => {\n      expect(res.length).toBe(0);\n      done();\n    }).catch(err => {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow updates to emailVerified","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2887,"updatePoint":{"line":2887,"column":47,"index":99393},"code":"  it('should not allow updates to emailVerified', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com'\n    });\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      return user.signUp();\n    }).then(() => {\n      return Parse.User.current().set('emailVerified', true).save();\n    }).then(() => {\n      fail('Should not be able to update emailVerified');\n      done();\n    }).catch(err => {\n      expect(err.message).toBe(\"Clients aren't allowed to manually update email verification.\");\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not retrieve hidden fields on GET users/me (#3432)","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2916,"updatePoint":{"line":2916,"column":63,"index":100313},"code":"  it('should not retrieve hidden fields on GET users/me (#3432)', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com'\n    });\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      return user.signUp();\n    }).then(() => request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/users/me',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Session-Token': Parse.User.current().getSessionToken(),\n        'X-Parse-REST-API-Key': 'rest'\n      }\n    })).then(response => {\n      const res = response.data;\n      expect(res.emailVerified).toBe(false);\n      expect(res._email_verify_token).toBeUndefined();\n      done();\n    }).catch(done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not retrieve hidden fields on GET users/id (#3432)","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2950,"updatePoint":{"line":2950,"column":63,"index":101398},"code":"  it('should not retrieve hidden fields on GET users/id (#3432)', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com'\n    });\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      return user.signUp();\n    }).then(() => request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/users/' + Parse.User.current().id,\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest'\n      }\n    })).then(response => {\n      const res = response.data;\n      expect(res.emailVerified).toBe(false);\n      expect(res._email_verify_token).toBeUndefined();\n      done();\n    }).catch(err => {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not retrieve hidden fields on login (#3432)","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":2986,"updatePoint":{"line":2986,"column":56,"index":102479},"code":"  it('should not retrieve hidden fields on login (#3432)', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com'\n    });\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      return user.signUp();\n    }).then(() => request({\n      url: 'http://localhost:8378/1/login?email=test@email.com&username=hello&password=world',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest'\n      }\n    })).then(response => {\n      const res = response.data;\n      expect(res.emailVerified).toBe(false);\n      expect(res._email_verify_token).toBeUndefined();\n      done();\n    }).catch(err => {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow updates to hidden fields","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3021,"updatePoint":{"line":3021,"column":47,"index":103554},"code":"  it('should not allow updates to hidden fields', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com'\n    });\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      return user.signUp();\n    }).then(() => {\n      return Parse.User.current().set('_email_verify_token', 'bad').save();\n    }).then(() => {\n      fail('Should not be able to update email verification token');\n      done();\n    }).catch(err => {\n      expect(err).toBeDefined();\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should revoke sessions when setting paswword with masterKey (#3289)","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3050,"updatePoint":{"line":3050,"column":73,"index":104438},"code":"  it('should revoke sessions when setting paswword with masterKey (#3289)', done => {\n    let user;\n    Parse.User.signUp('username', 'password').then(newUser => {\n      user = newUser;\n      user.set('password', 'newPassword');\n      return user.save(null, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      const query = new Parse.Query('_Session');\n      query.equalTo('user', user);\n      return query.find({\n        useMasterKey: true\n      });\n    }).then(results => {\n      expect(results.length).toBe(0);\n      done();\n    }, done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should not send a verification email if the user signed up using oauth","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3069,"updatePoint":{"line":3069,"column":77,"index":105008},"skipped":true,"code":"  xit('should not send a verification email if the user signed up using oauth', done => {\n    let emailCalledCount = 0;\n    const emailAdapter = {\n      sendVerificationEmail: () => {\n        emailCalledCount++;\n        return Promise.resolve();\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    const user = new Parse.User();\n    user.set('email', 'email1@host.com');\n    Parse.FacebookUtils.link(user, {\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON()\n    }).then(user => {\n      user.set('email', 'email2@host.com');\n      user.save().then(() => {\n        expect(emailCalledCount).toBe(0);\n        done();\n      });\n    });\n  }).pend('this test fails.  See: https://github.com/parse-community/parse-server/issues/5097');","file":"ParseUser.spec.js","dir":"spec"},{"name":"should be able to update user with authData passed","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3099,"updatePoint":{"line":3099,"column":56,"index":105991},"code":"  it('should be able to update user with authData passed', done => {\n    let objectId;\n    let sessionToken;\n    function validate(block) {\n      return request({\n        url: `http://localhost:8378/1/classes/_User/${objectId}`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'X-Parse-Session-Token': sessionToken\n        }\n      }).then(response => block(response.data));\n    }\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      body: {\n        key: 'value',\n        authData: {\n          anonymous: {\n            id: '00000000-0000-0000-0000-000000000001'\n          }\n        }\n      }\n    }).then(response => {\n      const body = response.data;\n      objectId = body.objectId;\n      sessionToken = body.sessionToken;\n      expect(sessionToken).toBeDefined();\n      expect(objectId).toBeDefined();\n      return validate(user => {\n        // validate that keys are set on creation\n        expect(user.key).toBe('value');\n      });\n    }).then(() => {\n      // update the user\n      const options = {\n        method: 'PUT',\n        url: `http://localhost:8378/1/classes/_User/${objectId}`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'X-Parse-Session-Token': sessionToken,\n          'Content-Type': 'application/json'\n        },\n        body: {\n          key: 'otherValue',\n          authData: {\n            anonymous: {\n              id: '00000000-0000-0000-0000-000000000001'\n            }\n          }\n        }\n      };\n      return request(options);\n    }).then(() => {\n      return validate(user => {\n        // validate that keys are set on update\n        expect(user.key).toBe('otherValue');\n      });\n    }).then(() => {\n      done();\n    }).then(done).catch(done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"can login with email","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3168,"updatePoint":{"line":3168,"column":26,"index":108018},"code":"  it('can login with email', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'yolo',\n      password: 'yolopass',\n      email: 'yo@lo.com'\n    }).then(() => {\n      const options = {\n        url: `http://localhost:8378/1/login`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        qs: {\n          email: 'yo@lo.com',\n          password: 'yolopass'\n        }\n      };\n      return request(options);\n    }).then(done).catch(done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"cannot login with email and invalid password","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3189,"updatePoint":{"line":3189,"column":50,"index":108594},"code":"  it('cannot login with email and invalid password', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'yolo',\n      password: 'yolopass',\n      email: 'yo@lo.com'\n    }).then(() => {\n      const options = {\n        method: 'POST',\n        url: `http://localhost:8378/1/login`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json'\n        },\n        body: {\n          email: 'yo@lo.com',\n          password: 'yolopass2'\n        }\n      };\n      return request(options);\n    }).then(done.fail).catch(() => done());\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"can login with email through query string","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3212,"updatePoint":{"line":3212,"column":47,"index":109248},"code":"  it('can login with email through query string', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'yolo',\n      password: 'yolopass',\n      email: 'yo@lo.com'\n    }).then(() => {\n      const options = {\n        url: `http://localhost:8378/1/login?email=yo@lo.com&password=yolopass`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        }\n      };\n      return request(options);\n    }).then(done).catch(done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"can login when both email and username are passed","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3229,"updatePoint":{"line":3229,"column":55,"index":109777},"code":"  it('can login when both email and username are passed', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'yolo',\n      password: 'yolopass',\n      email: 'yo@lo.com'\n    }).then(() => {\n      const options = {\n        url: `http://localhost:8378/1/login?email=yo@lo.com&username=yolo&password=yolopass`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        }\n      };\n      return request(options);\n    }).then(done).catch(done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"fails to login when username doesn't match email","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3246,"updatePoint":{"line":3246,"column":54,"index":110319},"code":"  it(\"fails to login when username doesn't match email\", done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'yolo',\n      password: 'yolopass',\n      email: 'yo@lo.com'\n    }).then(() => {\n      const options = {\n        url: `http://localhost:8378/1/login?email=yo@lo.com&username=yolo2&password=yolopass`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        }\n      };\n      return request(options);\n    }).then(done.fail).catch(err => {\n      expect(err.data.error).toEqual('Invalid username/password.');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"fails to login when email doesn't match username","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3266,"updatePoint":{"line":3266,"column":54,"index":110954},"code":"  it(\"fails to login when email doesn't match username\", done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'yolo',\n      password: 'yolopass',\n      email: 'yo@lo.com'\n    }).then(() => {\n      const options = {\n        url: `http://localhost:8378/1/login?email=yo@lo2.com&username=yolo&password=yolopass`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        }\n      };\n      return request(options);\n    }).then(done.fail).catch(err => {\n      expect(err.data.error).toEqual('Invalid username/password.');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"fails to login when email and username are not provided","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3286,"updatePoint":{"line":3286,"column":61,"index":111596},"code":"  it('fails to login when email and username are not provided', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'yolo',\n      password: 'yolopass',\n      email: 'yo@lo.com'\n    }).then(() => {\n      const options = {\n        url: `http://localhost:8378/1/login?password=yolopass`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        }\n      };\n      return request(options);\n    }).then(done.fail).catch(err => {\n      expect(err.data.error).toEqual('username/email is required.');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"allows login when providing email as username","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3306,"updatePoint":{"line":3306,"column":51,"index":112198},"code":"  it('allows login when providing email as username', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'yolo',\n      password: 'yolopass',\n      email: 'yo@lo.com'\n    }).then(() => {\n      return Parse.User.logIn('yo@lo.com', 'yolopass');\n    }).then(user => {\n      expect(user.get('username')).toBe('yolo');\n    }).then(done).catch(done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"handles properly when 2 users share username / email pairs","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3318,"updatePoint":{"line":3318,"column":64,"index":112592},"code":"  it('handles properly when 2 users share username / email pairs', done => {\n    const user = new Parse.User({\n      username: 'yo@loname.com',\n      password: 'yolopass',\n      email: 'yo@lo.com'\n    });\n    const user2 = new Parse.User({\n      username: 'yo@lo.com',\n      email: 'yo@loname.com',\n      password: 'yolopass2' // different passwords\n    });\n\n    Parse.Object.saveAll([user, user2]).then(() => {\n      return Parse.User.logIn('yo@loname.com', 'yolopass');\n    }).then(user => {\n      // the username takes precedence over the email,\n      // so we get the user with username as passed in\n      expect(user.get('username')).toBe('yo@loname.com');\n    }).then(done).catch(done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"handles properly when 2 users share username / email pairs, counterpart","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3338,"updatePoint":{"line":3338,"column":77,"index":113309},"code":"  it('handles properly when 2 users share username / email pairs, counterpart', done => {\n    const user = new Parse.User({\n      username: 'yo@loname.com',\n      password: 'yolopass',\n      email: 'yo@lo.com'\n    });\n    const user2 = new Parse.User({\n      username: 'yo@lo.com',\n      email: 'yo@loname.com',\n      password: 'yolopass2' // different passwords\n    });\n\n    Parse.Object.saveAll([user, user2]).then(() => {\n      return Parse.User.logIn('yo@loname.com', 'yolopass2');\n    }).then(done.fail).catch(err => {\n      expect(err.message).toEqual('Invalid username/password.');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"fails to login when password is not provided","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3357,"updatePoint":{"line":3357,"column":50,"index":113899},"code":"  it('fails to login when password is not provided', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'yolo',\n      password: 'yolopass',\n      email: 'yo@lo.com'\n    }).then(() => {\n      const options = {\n        url: `http://localhost:8378/1/login?username=yolo`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        }\n      };\n      return request(options);\n    }).then(done.fail).catch(err => {\n      expect(err.data.error).toEqual('password is required.');\n      done();\n    });\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"does not duplicate session when logging in multiple times #3451","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3377,"updatePoint":{"line":3377,"column":69,"index":114509},"code":"  it('does not duplicate session when logging in multiple times #3451', done => {\n    const user = new Parse.User();\n    user.signUp({\n      username: 'yolo',\n      password: 'yolo',\n      email: 'yo@lo.com'\n    }).then(() => {\n      const token = user.getSessionToken();\n      let promise = Promise.resolve();\n      let count = 0;\n      while (count < 5) {\n        promise = promise.then(() => {\n          return Parse.User.logIn('yolo', 'yolo').then(res => {\n            // ensure a new session token is generated at each login\n            expect(res.getSessionToken()).not.toBe(token);\n          });\n        });\n        count++;\n      }\n      return promise;\n    }).then(() => {\n      // wait because session destruction is not synchronous\n      return new Promise(resolve => {\n        setTimeout(resolve, 100);\n      });\n    }).then(() => {\n      const query = new Parse.Query('_Session');\n      return query.find({\n        useMasterKey: true\n      });\n    }).then(results => {\n      // only one session in the end\n      expect(results.length).toBe(1);\n    }).then(done, done.fail);\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should throw OBJECT_NOT_FOUND instead of SESSION_MISSING when using masterKey","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3412,"updatePoint":{"line":3412,"column":83,"index":115616},"code":"  it('should throw OBJECT_NOT_FOUND instead of SESSION_MISSING when using masterKey', async () => {\n    await reconfigureServer();\n    // create a fake user (just so we simulate an object not found)\n    const non_existent_user = Parse.User.createWithoutData('fake_id');\n    try {\n      await non_existent_user.destroy({\n        useMasterKey: true\n      });\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    try {\n      await non_existent_user.save({}, {\n        useMasterKey: true\n      });\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    try {\n      await non_existent_user.save();\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n    try {\n      await non_existent_user.destroy();\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when enforcePrivateUsers is invalid","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3445,"updatePoint":{"line":3445,"column":54,"index":116523},"code":"  it('should throw when enforcePrivateUsers is invalid', async () => {\n    const options = [[], 'a', 0, {}];\n    for (const option of options) {\n      await expectAsync(reconfigureServer({\n        enforcePrivateUsers: option\n      })).toBeRejected();\n    }\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"user login with enforcePrivateUsers","suites":["Parse.User testing","case insensitive signup not allowed","anonymous users"],"line":3453,"updatePoint":{"line":3453,"column":41,"index":116773},"code":"  it('user login with enforcePrivateUsers', async done => {\n    await reconfigureServer({\n      enforcePrivateUsers: true\n    });\n    await Parse.User.signUp('asdf', 'zxcv');\n    const user = await Parse.User.logIn('asdf', 'zxcv');\n    equal(user.get('username'), 'asdf');\n    const ACL = user.getACL();\n    expect(ACL.getReadAccess(user)).toBe(true);\n    expect(ACL.getWriteAccess(user)).toBe(true);\n    expect(ACL.getPublicReadAccess()).toBe(false);\n    expect(ACL.getPublicWriteAccess()).toBe(false);\n    const perms = ACL.permissionsById;\n    expect(Object.keys(perms).length).toBe(1);\n    expect(perms[user.id].read).toBe(true);\n    expect(perms[user.id].write).toBe(true);\n    expect(perms['*']).toBeUndefined();\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"should strip out authdata in LiveQuery","suites":["Parse.User testing","issue #4897"],"line":3504,"updatePoint":{"line":3504,"column":44,"index":119085},"code":"  it('should strip out authdata in LiveQuery', async () => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['_User']\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const query = new Parse.Query(Parse.User);\n    query.doesNotExist('foo');\n    const subscription = await query.subscribe();\n    const events = ['create', 'update', 'enter', 'leave', 'delete'];\n    const response = (obj, prev) => {\n      expect(obj.get('authData')).toBeUndefined();\n      expect(obj.authData).toBeUndefined();\n      expect(prev && prev.authData).toBeUndefined();\n      if (prev && prev.get) {\n        expect(prev.get('authData')).toBeUndefined();\n      }\n    };\n    const calls = {};\n    for (const key of events) {\n      calls[key] = response;\n      spyOn(calls, key).and.callThrough();\n      subscription.on(key, calls[key]);\n    }\n    const user = await Parse.User._logInWith('facebook');\n    user.set('foo', 'bar');\n    await user.save();\n    user.unset('foo');\n    await user.save();\n    user.set('yolo', 'bar');\n    await user.save();\n    await user.destroy();\n    await new Promise(resolve => setTimeout(resolve, 10));\n    for (const key of events) {\n      expect(calls[key]).toHaveBeenCalled();\n    }\n    subscription.unsubscribe();\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.close();\n    await new Promise(resolve => setTimeout(resolve, 10));\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"allows creating a session for another user with the master key","suites":["login as other user"],"line":3628,"updatePoint":{"line":3628,"column":68,"index":123208},"code":"  it('allows creating a session for another user with the master key', async done => {\n    await Parse.User.signUp('some_user', 'some_password');\n    const userId = Parse.User.current().id;\n    await Parse.User.logOut();\n    try {\n      const response = await request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/loginAs',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'X-Parse-Master-Key': 'test'\n        },\n        body: {\n          userId\n        }\n      });\n      expect(response.data.sessionToken).toBeDefined();\n    } catch (err) {\n      fail(`no request should fail: ${JSON.stringify(err)}`);\n      done();\n    }\n    const sessionsQuery = new Parse.Query(Parse.Session);\n    const sessionsAfterRequest = await sessionsQuery.find({\n      useMasterKey: true\n    });\n    expect(sessionsAfterRequest.length).toBe(1);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"rejects creating a session for another user if the user does not exist","suites":["login as other user"],"line":3657,"updatePoint":{"line":3657,"column":76,"index":124155},"code":"  it('rejects creating a session for another user if the user does not exist', async done => {\n    try {\n      await request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/loginAs',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'X-Parse-Master-Key': 'test'\n        },\n        body: {\n          userId: 'bogus-user'\n        }\n      });\n      fail('Request should fail without a valid user ID');\n      done();\n    } catch (err) {\n      expect(err.data.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      expect(err.data.error).toBe('user not found');\n    }\n    const sessionsQuery = new Parse.Query(Parse.Session);\n    const sessionsAfterRequest = await sessionsQuery.find({\n      useMasterKey: true\n    });\n    expect(sessionsAfterRequest.length).toBe(0);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"rejects creating a session for another user with invalid parameters","suites":["login as other user"],"line":3684,"updatePoint":{"line":3684,"column":73,"index":125020},"code":"  it('rejects creating a session for another user with invalid parameters', async done => {\n    const invalidUserIds = [undefined, null, ''];\n    for (const invalidUserId of invalidUserIds) {\n      try {\n        await request({\n          method: 'POST',\n          url: 'http://localhost:8378/1/loginAs',\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n            'X-Parse-Master-Key': 'test'\n          },\n          body: {\n            userId: invalidUserId\n          }\n        });\n        fail('Request should fail without a valid user ID');\n        done();\n      } catch (err) {\n        expect(err.data.code).toBe(Parse.Error.INVALID_VALUE);\n        expect(err.data.error).toBe('userId must not be empty, null, or undefined');\n      }\n      const sessionsQuery = new Parse.Query(Parse.Session);\n      const sessionsAfterRequest = await sessionsQuery.find({\n        useMasterKey: true\n      });\n      expect(sessionsAfterRequest.length).toBe(0);\n    }\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"rejects creating a session for another user without the master key","suites":["login as other user"],"line":3714,"updatePoint":{"line":3714,"column":72,"index":126066},"code":"  it('rejects creating a session for another user without the master key', async done => {\n    await Parse.User.signUp('some_user', 'some_password');\n    const userId = Parse.User.current().id;\n    await Parse.User.logOut();\n    try {\n      await request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/loginAs',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        body: {\n          userId\n        }\n      });\n      fail('Request should fail without the master key');\n      done();\n    } catch (err) {\n      expect(err.data.code).toBe(Parse.Error.OPERATION_FORBIDDEN);\n      expect(err.data.error).toBe('master key is required');\n    }\n    const sessionsQuery = new Parse.Query(Parse.Session);\n    const sessionsAfterRequest = await sessionsQuery.find({\n      useMasterKey: true\n    });\n    expect(sessionsAfterRequest.length).toBe(0);\n    done();\n  });","file":"ParseUser.spec.js","skipped":false,"dir":"spec"},{"name":"can be initialized","suites":["ParseWebSocket"],"line":3,"updatePoint":{"line":3,"column":24,"index":154},"code":"  it('can be initialized', function () {\n    const ws = {};\n    const parseWebSocket = new ParseWebSocket(ws);\n    expect(parseWebSocket.ws).toBe(ws);\n  });","file":"ParseWebSocket.spec.js","skipped":false,"dir":"spec"},{"name":"can handle disconnect event","suites":["ParseWebSocket"],"line":8,"updatePoint":{"line":8,"column":33,"index":320},"code":"  it('can handle disconnect event', function (done) {\n    const ws = {\n      onclose: () => {}\n    };\n    const parseWebSocket = new ParseWebSocket(ws);\n    parseWebSocket.on('disconnect', () => {\n      done();\n    });\n    ws.onclose();\n  });","file":"ParseWebSocket.spec.js","skipped":false,"dir":"spec"},{"name":"can handle message event","suites":["ParseWebSocket"],"line":18,"updatePoint":{"line":18,"column":30,"index":560},"code":"  it('can handle message event', function (done) {\n    const ws = {\n      onmessage: () => {}\n    };\n    const parseWebSocket = new ParseWebSocket(ws);\n    parseWebSocket.on('message', () => {\n      done();\n    });\n    ws.onmessage();\n  });","file":"ParseWebSocket.spec.js","skipped":false,"dir":"spec"},{"name":"can send a message","suites":["ParseWebSocket"],"line":28,"updatePoint":{"line":28,"column":24,"index":795},"code":"  it('can send a message', function () {\n    const ws = {\n      send: jasmine.createSpy('send')\n    };\n    const parseWebSocket = new ParseWebSocket(ws);\n    parseWebSocket.send('message');\n    expect(parseWebSocket.ws.send).toHaveBeenCalledWith('message');\n  });","file":"ParseWebSocket.spec.js","skipped":false,"dir":"spec"},{"name":"can handle connect event when ws is open","suites":["ParseWebSocketServer"],"line":15,"updatePoint":{"line":15,"column":46,"index":421},"code":"  it('can handle connect event when ws is open', function (done) {\n    const onConnectCallback = jasmine.createSpy('onConnectCallback');\n    const http = require('http');\n    const server = http.createServer();\n    const parseWebSocketServer = new ParseWebSocketServer(server, onConnectCallback, {\n      websocketTimeout: 5\n    }).server;\n    const ws = new EventEmitter();\n    ws.readyState = 0;\n    ws.OPEN = 0;\n    ws.ping = jasmine.createSpy('ping');\n    ws.terminate = () => {};\n    parseWebSocketServer.onConnection(ws);\n\n    // Make sure callback is called\n    expect(onConnectCallback).toHaveBeenCalled();\n    // Make sure we ping to the client\n    setTimeout(function () {\n      expect(ws.ping).toHaveBeenCalled();\n      server.close();\n      done();\n    }, 10);\n  });","file":"ParseWebSocketServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle error event","suites":["ParseWebSocketServer"],"line":38,"updatePoint":{"line":38,"column":28,"index":1181},"code":"  it('can handle error event', async () => {\n    jasmine.restoreLibrary('ws', 'Server');\n    const WebSocketServer = require('ws').Server;\n    let wssError;\n    class WSSAdapter {\n      constructor(options) {\n        this.options = options;\n      }\n      onListen() {}\n      onConnection() {}\n      onError() {}\n      start() {\n        const wss = new WebSocketServer({\n          server: this.options.server\n        });\n        wss.on('listening', this.onListen);\n        wss.on('connection', this.onConnection);\n        wss.on('error', error => {\n          wssError = error;\n          this.onError(error);\n        });\n        this.wss = wss;\n      }\n    }\n    const server = await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject']\n      },\n      liveQueryServerOptions: {\n        wssAdapter: WSSAdapter\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true\n    });\n    const wssAdapter = server.liveQueryServer.parseWebSocketServer.server;\n    wssAdapter.wss.emit('error', 'Invalid Packet');\n    expect(wssError).toBe('Invalid Packet');\n  });","file":"ParseWebSocketServer.spec.js","skipped":false,"dir":"spec"},{"name":"can handle ping/pong","suites":["ParseWebSocketServer"],"line":77,"updatePoint":{"line":77,"column":26,"index":2277},"code":"  it('can handle ping/pong', async () => {\n    const onConnectCallback = jasmine.createSpy('onConnectCallback');\n    const http = require('http');\n    const server = http.createServer();\n    const parseWebSocketServer = new ParseWebSocketServer(server, onConnectCallback, {\n      websocketTimeout: 10\n    }).server;\n    const ws = new EventEmitter();\n    ws.readyState = 0;\n    ws.OPEN = 0;\n    ws.ping = jasmine.createSpy('ping');\n    ws.terminate = jasmine.createSpy('terminate');\n    parseWebSocketServer.onConnection(ws);\n    expect(onConnectCallback).toHaveBeenCalled();\n    expect(ws.waitingForPong).toBe(false);\n    await new Promise(resolve => setTimeout(resolve, 10));\n    expect(ws.ping).toHaveBeenCalled();\n    expect(ws.waitingForPong).toBe(true);\n    ws.emit('pong');\n    expect(ws.waitingForPong).toBe(false);\n    await new Promise(resolve => setTimeout(resolve, 10));\n    expect(ws.waitingForPong).toBe(true);\n    expect(ws.terminate).not.toHaveBeenCalled();\n    server.close();\n  });","file":"ParseWebSocketServer.spec.js","skipped":false,"dir":"spec"},{"name":"closes interrupted connection","suites":["ParseWebSocketServer"],"line":102,"updatePoint":{"line":102,"column":35,"index":3286},"code":"  it('closes interrupted connection', async () => {\n    const onConnectCallback = jasmine.createSpy('onConnectCallback');\n    const http = require('http');\n    const server = http.createServer();\n    const parseWebSocketServer = new ParseWebSocketServer(server, onConnectCallback, {\n      websocketTimeout: 5\n    }).server;\n    const ws = new EventEmitter();\n    ws.readyState = 0;\n    ws.OPEN = 0;\n    ws.ping = jasmine.createSpy('ping');\n    ws.terminate = jasmine.createSpy('terminate');\n    parseWebSocketServer.onConnection(ws);\n\n    // Make sure callback is called\n    expect(onConnectCallback).toHaveBeenCalled();\n    expect(ws.waitingForPong).toBe(false);\n    await new Promise(resolve => setTimeout(resolve, 10));\n    expect(ws.ping).toHaveBeenCalled();\n    expect(ws.waitingForPong).toBe(true);\n    await new Promise(resolve => setTimeout(resolve, 10));\n    expect(ws.terminate).toHaveBeenCalled();\n    server.close();\n  });","file":"ParseWebSocketServer.spec.js","skipped":false,"dir":"spec"},{"name":"should show the invalid link page if the user clicks on the password reset link after the token expires","suites":["Password Policy: "],"line":5,"updatePoint":{"line":5,"column":109,"index":206},"code":"  it('should show the invalid link page if the user clicks on the password reset link after the token expires', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      emailAdapter: emailAdapter,\n      passwordPolicy: {\n        resetTokenValidityDuration: 0.5 // 0.5 second\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('testResetTokenValidity');\n      user.setPassword('original');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      Parse.User.requestPasswordReset('user@parse.com').catch(err => {\n        jfail(err);\n        fail('Reset password request should not fail');\n        done();\n      });\n    }).then(() => {\n      // wait for a bit more than the validity duration set\n      setTimeout(() => {\n        expect(sendEmailOptions).not.toBeUndefined();\n        request({\n          url: sendEmailOptions.link,\n          followRedirects: false,\n          simple: false,\n          resolveWithFullResponse: true\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/invalid_link.html');\n          done();\n        }).catch(error => {\n          fail(error);\n        });\n      }, 1000);\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should show the reset password page if the user clicks on the password reset link before the token expires","suites":["Password Policy: "],"line":56,"updatePoint":{"line":56,"column":112,"index":1861},"code":"  it('should show the reset password page if the user clicks on the password reset link before the token expires', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      emailAdapter: emailAdapter,\n      passwordPolicy: {\n        resetTokenValidityDuration: 5 // 5 seconds\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('testResetTokenValidity');\n      user.setPassword('original');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      Parse.User.requestPasswordReset('user@parse.com').catch(err => {\n        jfail(err);\n        fail('Reset password request should not fail');\n        done();\n      });\n    }).then(() => {\n      // wait for a bit but less than the validity duration\n      setTimeout(() => {\n        expect(sendEmailOptions).not.toBeUndefined();\n        request({\n          url: sendEmailOptions.link,\n          simple: false,\n          resolveWithFullResponse: true,\n          followRedirects: false\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=[a-zA-Z0-9]+\\&id=test\\&username=testResetTokenValidity/;\n          expect(response.text.match(re)).not.toBe(null);\n          done();\n        }).catch(error => {\n          fail(error);\n        });\n      }, 1000);\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should not keep reset token by default","suites":["Password Policy: "],"line":108,"updatePoint":{"line":108,"column":44,"index":3526},"code":"  it('should not keep reset token by default', async done => {\n    const sendEmailOptions = [];\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        sendEmailOptions.push(options);\n      },\n      sendMail: () => {}\n    };\n    await reconfigureServer({\n      appName: 'passwordPolicy',\n      emailAdapter: emailAdapter,\n      passwordPolicy: {\n        resetTokenValidityDuration: 5 * 60 // 5 minutes\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    const user = new Parse.User();\n    user.setUsername('testResetTokenValidity');\n    user.setPassword('original');\n    user.set('email', 'user@example.com');\n    await user.signUp();\n    await Parse.User.requestPasswordReset('user@example.com');\n    await Parse.User.requestPasswordReset('user@example.com');\n    expect(sendEmailOptions[0].link).not.toBe(sendEmailOptions[1].link);\n    done();\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should keep reset token with resetTokenReuseIfValid","suites":["Password Policy: "],"line":136,"updatePoint":{"line":136,"column":57,"index":4486},"code":"  it('should keep reset token with resetTokenReuseIfValid', async done => {\n    const sendEmailOptions = [];\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        sendEmailOptions.push(options);\n      },\n      sendMail: () => {}\n    };\n    await reconfigureServer({\n      appName: 'passwordPolicy',\n      emailAdapter: emailAdapter,\n      passwordPolicy: {\n        resetTokenValidityDuration: 5 * 60,\n        // 5 minutes\n        resetTokenReuseIfValid: true\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    const user = new Parse.User();\n    user.setUsername('testResetTokenValidity');\n    user.setPassword('original');\n    user.set('email', 'user@example.com');\n    await user.signUp();\n    await Parse.User.requestPasswordReset('user@example.com');\n    await Parse.User.requestPasswordReset('user@example.com');\n    expect(sendEmailOptions[0].link).toBe(sendEmailOptions[1].link);\n    done();\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should throw with invalid resetTokenReuseIfValid","suites":["Password Policy: "],"line":165,"updatePoint":{"line":165,"column":54,"index":5484},"code":"  it('should throw with invalid resetTokenReuseIfValid', async done => {\n    const sendEmailOptions = [];\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        sendEmailOptions.push(options);\n      },\n      sendMail: () => {}\n    };\n    try {\n      await reconfigureServer({\n        appName: 'passwordPolicy',\n        emailAdapter: emailAdapter,\n        passwordPolicy: {\n          resetTokenValidityDuration: 5 * 60,\n          // 5 minutes\n          resetTokenReuseIfValid: []\n        },\n        publicServerURL: 'http://localhost:8378/1'\n      });\n      fail('should have thrown.');\n    } catch (e) {\n      expect(e).toBe('resetTokenReuseIfValid must be a boolean value');\n    }\n    try {\n      await reconfigureServer({\n        appName: 'passwordPolicy',\n        emailAdapter: emailAdapter,\n        passwordPolicy: {\n          resetTokenReuseIfValid: true\n        },\n        publicServerURL: 'http://localhost:8378/1'\n      });\n      fail('should have thrown.');\n    } catch (e) {\n      expect(e).toBe('You cannot use resetTokenReuseIfValid without resetTokenValidityDuration');\n    }\n    done();\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if passwordPolicy.resetTokenValidityDuration is not a number","suites":["Password Policy: "],"line":204,"updatePoint":{"line":204,"column":78,"index":6692},"code":"  it('should fail if passwordPolicy.resetTokenValidityDuration is not a number', done => {\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        resetTokenValidityDuration: 'not a number'\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      fail('passwordPolicy.resetTokenValidityDuration \"not a number\" test failed');\n      done();\n    }).catch(err => {\n      expect(err).toEqual('passwordPolicy.resetTokenValidityDuration must be a positive number');\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if passwordPolicy.resetTokenValidityDuration is zero or a negative number","suites":["Password Policy: "],"line":219,"updatePoint":{"line":219,"column":91,"index":7252},"code":"  it('should fail if passwordPolicy.resetTokenValidityDuration is zero or a negative number', done => {\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        resetTokenValidityDuration: 0\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      fail('resetTokenValidityDuration negative number test failed');\n      done();\n    }).catch(err => {\n      expect(err).toEqual('passwordPolicy.resetTokenValidityDuration must be a positive number');\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if passwordPolicy.validatorPattern setting is invalid type","suites":["Password Policy: "],"line":234,"updatePoint":{"line":234,"column":76,"index":7770},"code":"  it('should fail if passwordPolicy.validatorPattern setting is invalid type', done => {\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorPattern: 1234 // number is not a valid setting\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      fail('passwordPolicy.validatorPattern type test failed');\n      done();\n    }).catch(err => {\n      expect(err).toEqual('passwordPolicy.validatorPattern must be a regex string or RegExp object.');\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if passwordPolicy.validatorCallback setting is invalid type","suites":["Password Policy: "],"line":250,"updatePoint":{"line":250,"column":77,"index":8315},"code":"  it('should fail if passwordPolicy.validatorCallback setting is invalid type', done => {\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorCallback: 'abc' // string is not a valid setting\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      fail('passwordPolicy.validatorCallback type test failed');\n      done();\n    }).catch(err => {\n      expect(err).toEqual('passwordPolicy.validatorCallback must be a function.');\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should fail if password does not conform to the policy enforced using validatorPattern","suites":["Password Policy: "],"line":266,"updatePoint":{"line":266,"column":99,"index":8865},"code":"  it('signup should fail if password does not conform to the policy enforced using validatorPattern', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorPattern: /[0-9]+/ // password should contain at least one digit\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('nodigit');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        fail('Should have failed as password does not conform to the policy.');\n        done();\n      }).catch(error => {\n        expect(error.code).toEqual(142);\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should fail if password does not conform to the policy enforced using validatorPattern string","suites":["Password Policy: "],"line":288,"updatePoint":{"line":288,"column":106,"index":9608},"code":"  it('signup should fail if password does not conform to the policy enforced using validatorPattern string', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorPattern: '^.{8,}' // password should contain at least 8 char\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('less');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        fail('Should have failed as password does not conform to the policy.');\n        done();\n      }).catch(error => {\n        expect(error.code).toEqual(142);\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should fail if password is empty","suites":["Password Policy: "],"line":310,"updatePoint":{"line":310,"column":45,"index":10284},"code":"  it('signup should fail if password is empty', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorPattern: '^.{8,}' // password should contain at least 8 char\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        fail('Should have failed as password does not conform to the policy.');\n        done();\n      }).catch(error => {\n        expect(error.message).toEqual('Cannot sign up user with an empty password.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should succeed if password conforms to the policy enforced using validatorPattern","suites":["Password Policy: "],"line":332,"updatePoint":{"line":332,"column":94,"index":11050},"code":"  it('signup should succeed if password conforms to the policy enforced using validatorPattern', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorPattern: /[0-9]+/ // password should contain at least one digit\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('1digit');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        Parse.User.logOut().then(() => {\n          Parse.User.logIn('user1', '1digit').then(function () {\n            done();\n          }).catch(err => {\n            jfail(err);\n            fail('Should be able to login');\n            done();\n          });\n        }).catch(error => {\n          jfail(error);\n          fail('logout should have succeeded');\n          done();\n        });\n      }).catch(error => {\n        jfail(error);\n        fail('Signup should have succeeded as password conforms to the policy.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should succeed if password conforms to the policy enforced using validatorPattern string","suites":["Password Policy: "],"line":366,"updatePoint":{"line":366,"column":101,"index":12141},"code":"  it('signup should succeed if password conforms to the policy enforced using validatorPattern string', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorPattern: '[!@#$]+' // password should contain at least one special char\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('p@sswrod');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        Parse.User.logOut().then(() => {\n          Parse.User.logIn('user1', 'p@sswrod').then(function () {\n            done();\n          }).catch(err => {\n            jfail(err);\n            fail('Should be able to login');\n            done();\n          });\n        }).catch(error => {\n          jfail(error);\n          fail('logout should have succeeded');\n          done();\n        });\n      }).catch(error => {\n        jfail(error);\n        fail('Signup should have succeeded as password conforms to the policy.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should fail if password does not conform to the policy enforced using validatorCallback","suites":["Password Policy: "],"line":400,"updatePoint":{"line":400,"column":100,"index":13243},"code":"  it('signup should fail if password does not conform to the policy enforced using validatorCallback', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorCallback: () => false // just fail\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('any');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        fail('Should have failed as password does not conform to the policy.');\n        done();\n      }).catch(error => {\n        expect(error.code).toEqual(142);\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should succeed if password conforms to the policy enforced using validatorCallback","suites":["Password Policy: "],"line":422,"updatePoint":{"line":422,"column":95,"index":13942},"code":"  it('signup should succeed if password conforms to the policy enforced using validatorCallback', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorCallback: () => true // never fail\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('oneUpper');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        Parse.User.logOut().then(() => {\n          Parse.User.logIn('user1', 'oneUpper').then(function () {\n            done();\n          }).catch(err => {\n            jfail(err);\n            fail('Should be able to login');\n            done();\n          });\n        }).catch(error => {\n          jfail(error);\n          fail('Logout should have succeeded');\n          done();\n        });\n      }).catch(error => {\n        jfail(error);\n        fail('Should have succeeded as password conforms to the policy.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should fail if password does not match validatorPattern but succeeds validatorCallback","suites":["Password Policy: "],"line":456,"updatePoint":{"line":456,"column":99,"index":14999},"code":"  it('signup should fail if password does not match validatorPattern but succeeds validatorCallback', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorPattern: /[A-Z]+/,\n        // password should contain at least one UPPER case letter\n        validatorCallback: () => true\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('all lower');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        fail('Should have failed as password does not conform to the policy.');\n        done();\n      }).catch(error => {\n        expect(error.code).toEqual(142);\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should fail if password matches validatorPattern but fails validatorCallback","suites":["Password Policy: "],"line":479,"updatePoint":{"line":479,"column":89,"index":15785},"code":"  it('signup should fail if password matches validatorPattern but fails validatorCallback', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorPattern: /[A-Z]+/,\n        // password should contain at least one UPPER case letter\n        validatorCallback: () => false\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('oneUpper');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        fail('Should have failed as password does not conform to the policy.');\n        done();\n      }).catch(error => {\n        expect(error.code).toEqual(142);\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should succeed if password conforms to both validatorPattern and validatorCallback","suites":["Password Policy: "],"line":502,"updatePoint":{"line":502,"column":95,"index":16577},"code":"  it('signup should succeed if password conforms to both validatorPattern and validatorCallback', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorPattern: /[A-Z]+/,\n        // password should contain at least one digit\n        validatorCallback: () => true\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('oneUpper');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        Parse.User.logOut().then(() => {\n          Parse.User.logIn('user1', 'oneUpper').then(function () {\n            done();\n          }).catch(err => {\n            jfail(err);\n            fail('Should be able to login');\n            done();\n          });\n        }).catch(error => {\n          jfail(error);\n          fail('logout should have succeeded');\n          done();\n        });\n      }).catch(error => {\n        jfail(error);\n        fail('Should have succeeded as password conforms to the policy.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should reset password if new password conforms to password policy","suites":["Password Policy: "],"line":537,"updatePoint":{"line":537,"column":71,"index":17681},"code":"  it('should reset password if new password conforms to password policy', done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        request({\n          url: options.link,\n          followRedirects: false,\n          simple: false,\n          resolveWithFullResponse: true\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=([a-zA-Z0-9]+)\\&id=test\\&username=user1/;\n          const match = response.text.match(re);\n          if (!match) {\n            fail('should have a token');\n            done();\n            return;\n          }\n          const token = match[1];\n          request({\n            method: 'POST',\n            url: 'http://localhost:8378/1/apps/test/request_password_reset',\n            body: `new_password=has2init&token=${token}&username=user1`,\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            followRedirects: false,\n            simple: false,\n            resolveWithFullResponse: true\n          }).then(response => {\n            expect(response.status).toEqual(302);\n            expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/password_reset_success.html?username=user1');\n            Parse.User.logIn('user1', 'has2init').then(function () {\n              done();\n            }).catch(err => {\n              jfail(err);\n              fail('should login with new password');\n              done();\n            });\n          }).catch(error => {\n            jfail(error);\n            fail('Failed to POST request password reset');\n            done();\n          });\n        }).catch(error => {\n          jfail(error);\n          fail('Failed to get the reset link');\n          done();\n        });\n      },\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      verifyUserEmails: false,\n      emailAdapter: emailAdapter,\n      passwordPolicy: {\n        validatorPattern: /[0-9]+/ // password should contain at least one digit\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('has 1 digit');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        Parse.User.requestPasswordReset('user1@parse.com').catch(err => {\n          jfail(err);\n          fail('Reset password request should not fail');\n          done();\n        });\n      }).catch(error => {\n        jfail(error);\n        fail('signUp should not fail');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail to reset password if the new password does not conform to password policy","suites":["Password Policy: "],"line":616,"updatePoint":{"line":616,"column":91,"index":20444},"code":"  it('should fail to reset password if the new password does not conform to password policy', done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        request({\n          url: options.link,\n          followRedirects: false,\n          simple: false,\n          resolveWithFullResponse: true\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=([a-zA-Z0-9]+)\\&id=test\\&username=user1/;\n          const match = response.text.match(re);\n          if (!match) {\n            fail('should have a token');\n            done();\n            return;\n          }\n          const token = match[1];\n          request({\n            method: 'POST',\n            url: 'http://localhost:8378/1/apps/test/request_password_reset',\n            body: `new_password=hasnodigit&token=${token}&username=user1`,\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            followRedirects: false,\n            simple: false,\n            resolveWithFullResponse: true\n          }).then(response => {\n            expect(response.status).toEqual(302);\n            expect(response.text).toEqual(`Found. Redirecting to http://localhost:8378/1/apps/choose_password?username=user1&token=${token}&id=test&error=Password%20should%20contain%20at%20least%20one%20digit.&app=passwordPolicy`);\n            Parse.User.logIn('user1', 'has 1 digit').then(function () {\n              done();\n            }).catch(err => {\n              jfail(err);\n              fail('should login with old password');\n              done();\n            });\n          }).catch(error => {\n            jfail(error);\n            fail('Failed to POST request password reset');\n            done();\n          });\n        }).catch(error => {\n          jfail(error);\n          fail('Failed to get the reset link');\n          done();\n        });\n      },\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      verifyUserEmails: false,\n      emailAdapter: emailAdapter,\n      passwordPolicy: {\n        validatorPattern: /[0-9]+/,\n        // password should contain at least one digit\n        validationError: 'Password should contain at least one digit.'\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('has 1 digit');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        Parse.User.requestPasswordReset('user1@parse.com').catch(err => {\n          jfail(err);\n          fail('Reset password request should not fail');\n          done();\n        });\n      }).catch(error => {\n        jfail(error);\n        fail('signUp should not fail');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if passwordPolicy.doNotAllowUsername is not a boolean value","suites":["Password Policy: "],"line":696,"updatePoint":{"line":696,"column":77,"index":23369},"code":"  it('should fail if passwordPolicy.doNotAllowUsername is not a boolean value', done => {\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        doNotAllowUsername: 'no'\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      fail('passwordPolicy.doNotAllowUsername type test failed');\n      done();\n    }).catch(err => {\n      expect(err).toEqual('passwordPolicy.doNotAllowUsername must be a boolean value.');\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should fail if password contains the username and is not allowed by policy","suites":["Password Policy: "],"line":711,"updatePoint":{"line":711,"column":87,"index":23880},"code":"  it('signup should fail if password contains the username and is not allowed by policy', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorPattern: /[0-9]+/,\n        doNotAllowUsername: true\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('@user11');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        fail('Should have failed as password contains username.');\n        done();\n      }).catch(error => {\n        expect(error.code).toEqual(142);\n        expect(error.message).toEqual('Password cannot contain your username.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should succeed if password does not contain the username and is not allowed by policy","suites":["Password Policy: "],"line":734,"updatePoint":{"line":734,"column":98,"index":24670},"code":"  it('signup should succeed if password does not contain the username and is not allowed by policy', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        doNotAllowUsername: true\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('r@nd0m');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        done();\n      }).catch(() => {\n        fail('Should have succeeded as password does not contain username.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"signup should succeed if password contains the username and it is allowed by policy","suites":["Password Policy: "],"line":754,"updatePoint":{"line":754,"column":89,"index":25300},"code":"  it('signup should succeed if password contains the username and it is allowed by policy', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        validatorPattern: /[0-9]+/\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('user1');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        done();\n      }).catch(() => {\n        fail('Should have succeeded as policy allows username in password.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail to reset password if the new password contains username and not allowed by password policy","suites":["Password Policy: "],"line":774,"updatePoint":{"line":774,"column":108,"index":25950},"code":"  it('should fail to reset password if the new password contains username and not allowed by password policy', done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        request({\n          url: options.link,\n          followRedirects: false,\n          simple: false,\n          resolveWithFullResponse: true\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=([a-zA-Z0-9]+)\\&id=test\\&username=user1/;\n          const match = response.text.match(re);\n          if (!match) {\n            fail('should have a token');\n            done();\n            return;\n          }\n          const token = match[1];\n          request({\n            method: 'POST',\n            url: 'http://localhost:8378/1/apps/test/request_password_reset',\n            body: `new_password=xuser12&token=${token}&username=user1`,\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            followRedirects: false,\n            simple: false,\n            resolveWithFullResponse: true\n          }).then(response => {\n            expect(response.status).toEqual(302);\n            expect(response.text).toEqual(`Found. Redirecting to http://localhost:8378/1/apps/choose_password?username=user1&token=${token}&id=test&error=Password%20cannot%20contain%20your%20username.&app=passwordPolicy`);\n            Parse.User.logIn('user1', 'r@nd0m').then(function () {\n              done();\n            }).catch(err => {\n              jfail(err);\n              fail('should login with old password');\n              done();\n            });\n          }).catch(error => {\n            jfail(error);\n            fail('Failed to POST request password reset');\n            done();\n          });\n        }).catch(error => {\n          jfail(error);\n          fail('Failed to get the reset link');\n          done();\n        });\n      },\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      verifyUserEmails: false,\n      emailAdapter: emailAdapter,\n      passwordPolicy: {\n        doNotAllowUsername: true\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('r@nd0m');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        Parse.User.requestPasswordReset('user1@parse.com').catch(err => {\n          jfail(err);\n          fail('Reset password request should not fail');\n          done();\n        });\n      }).catch(error => {\n        jfail(error);\n        fail('signUp should not fail');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"Should return error when password violates Password Policy and reset through ajax","suites":["Password Policy: "],"line":852,"updatePoint":{"line":852,"column":87,"index":28735},"code":"  it('Should return error when password violates Password Policy and reset through ajax', async done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: async options => {\n        const response = await request({\n          url: options.link,\n          followRedirects: false,\n          simple: false,\n          resolveWithFullResponse: true\n        });\n        expect(response.status).toEqual(302);\n        const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=([a-zA-Z0-9]+)\\&id=test\\&username=user1/;\n        const match = response.text.match(re);\n        if (!match) {\n          fail('should have a token');\n          return;\n        }\n        const token = match[1];\n        try {\n          await request({\n            method: 'POST',\n            url: 'http://localhost:8378/1/apps/test/request_password_reset',\n            body: `new_password=xuser12&token=${token}&username=user1`,\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded',\n              'X-Requested-With': 'XMLHttpRequest'\n            },\n            followRedirects: false\n          });\n        } catch (error) {\n          expect(error.status).not.toBe(302);\n          expect(error.text).toEqual('{\"code\":-1,\"error\":\"Password cannot contain your username.\"}');\n        }\n        await Parse.User.logIn('user1', 'r@nd0m');\n        done();\n      },\n      sendMail: () => {}\n    };\n    await reconfigureServer({\n      appName: 'passwordPolicy',\n      verifyUserEmails: false,\n      emailAdapter: emailAdapter,\n      passwordPolicy: {\n        doNotAllowUsername: true\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    user.setUsername('user1');\n    user.setPassword('r@nd0m');\n    user.set('email', 'user1@parse.com');\n    await user.signUp();\n    await Parse.User.requestPasswordReset('user1@parse.com');\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should reset password even if the new password contains user name while the policy allows","suites":["Password Policy: "],"line":906,"updatePoint":{"line":906,"column":95,"index":30691},"code":"  it('should reset password even if the new password contains user name while the policy allows', done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        request({\n          url: options.link,\n          followRedirects: false,\n          simple: false,\n          resolveWithFullResponse: true\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=([a-zA-Z0-9]+)\\&id=test\\&username=user1/;\n          const match = response.text.match(re);\n          if (!match) {\n            fail('should have a token');\n            done();\n            return;\n          }\n          const token = match[1];\n          request({\n            method: 'POST',\n            url: 'http://localhost:8378/1/apps/test/request_password_reset',\n            body: `new_password=uuser11&token=${token}&username=user1`,\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            followRedirects: false,\n            simple: false,\n            resolveWithFullResponse: true\n          }).then(response => {\n            expect(response.status).toEqual(302);\n            expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/password_reset_success.html?username=user1');\n            Parse.User.logIn('user1', 'uuser11').then(function () {\n              done();\n            }).catch(err => {\n              jfail(err);\n              fail('should login with new password');\n              done();\n            });\n          }).catch(error => {\n            jfail(error);\n            fail('Failed to POST request password reset');\n          });\n        }).catch(error => {\n          jfail(error);\n          fail('Failed to get the reset link');\n        });\n      },\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      verifyUserEmails: false,\n      emailAdapter: emailAdapter,\n      passwordPolicy: {\n        validatorPattern: /[0-9]+/,\n        doNotAllowUsername: false\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('has 1 digit');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        Parse.User.requestPasswordReset('user1@parse.com').catch(err => {\n          jfail(err);\n          fail('Reset password request should not fail');\n          done();\n        });\n      });\n    }).catch(error => {\n      jfail(error);\n      fail('signUp should not fail');\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if passwordPolicy.maxPasswordAge is not a number","suites":["Password Policy: "],"line":983,"updatePoint":{"line":983,"column":66,"index":33369},"code":"  it('should fail if passwordPolicy.maxPasswordAge is not a number', done => {\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        maxPasswordAge: 'not a number'\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      fail('passwordPolicy.maxPasswordAge \"not a number\" test failed');\n      done();\n    }).catch(err => {\n      expect(err).toEqual('passwordPolicy.maxPasswordAge must be a positive number');\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if passwordPolicy.maxPasswordAge is a negative number","suites":["Password Policy: "],"line":998,"updatePoint":{"line":998,"column":71,"index":33873},"code":"  it('should fail if passwordPolicy.maxPasswordAge is a negative number', done => {\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        maxPasswordAge: -100\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      fail('passwordPolicy.maxPasswordAge negative number test failed');\n      done();\n    }).catch(err => {\n      expect(err).toEqual('passwordPolicy.maxPasswordAge must be a positive number');\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed if logged in before password expires","suites":["Password Policy: "],"line":1013,"updatePoint":{"line":1013,"column":57,"index":34354},"code":"  it('should succeed if logged in before password expires', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        maxPasswordAge: 1 // 1 day\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('user1');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        Parse.User.logIn('user1', 'user1').then(() => {\n          done();\n        }).catch(error => {\n          jfail(error);\n          fail('Login should have succeeded before password expiry.');\n          done();\n        });\n      }).catch(error => {\n        jfail(error);\n        fail('Signup failed.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if logged in after password expires","suites":["Password Policy: "],"line":1041,"updatePoint":{"line":1041,"column":53,"index":35140},"code":"  it('should fail if logged in after password expires', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        maxPasswordAge: 0.5 / (24 * 60 * 60) // 0.5 sec\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('user1');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        // wait for a bit more than the validity duration set\n        setTimeout(() => {\n          Parse.User.logIn('user1', 'user1').then(() => {\n            fail('logIn should have failed');\n            done();\n          }).catch(error => {\n            expect(error.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n            expect(error.message).toEqual('Your password has expired. Please reset your password.');\n            done();\n          });\n        }, 1000);\n      }).catch(error => {\n        jfail(error);\n        fail('Signup failed.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should apply password expiry policy to existing user upon first login after policy is enabled","suites":["Password Policy: "],"line":1073,"updatePoint":{"line":1073,"column":99,"index":36232},"code":"  it('should apply password expiry policy to existing user upon first login after policy is enabled', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('user1');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        Parse.User.logOut().then(() => {\n          reconfigureServer({\n            appName: 'passwordPolicy',\n            passwordPolicy: {\n              maxPasswordAge: 0.5 / (24 * 60 * 60) // 0.5 sec\n            },\n\n            publicServerURL: 'http://localhost:8378/1'\n          }).then(() => {\n            Parse.User.logIn('user1', 'user1').then(() => {\n              Parse.User.logOut().then(() => {\n                // wait for a bit more than the validity duration set\n                setTimeout(() => {\n                  Parse.User.logIn('user1', 'user1').then(() => {\n                    fail('logIn should have failed');\n                    done();\n                  }).catch(error => {\n                    expect(error.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n                    expect(error.message).toEqual('Your password has expired. Please reset your password.');\n                    done();\n                  });\n                }, 2000);\n              }).catch(error => {\n                jfail(error);\n                fail('logout should have succeeded');\n                done();\n              });\n            }).catch(error => {\n              jfail(error);\n              fail('Login failed.');\n              done();\n            });\n          });\n        }).catch(error => {\n          jfail(error);\n          fail('logout should have succeeded');\n          done();\n        });\n      }).catch(error => {\n        jfail(error);\n        fail('Signup failed.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should reset password timestamp when password is reset","suites":["Password Policy: "],"line":1128,"updatePoint":{"line":1128,"column":60,"index":38128},"code":"  it('should reset password timestamp when password is reset', done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        request({\n          url: options.link,\n          followRedirects: false,\n          simple: false,\n          resolveWithFullResponse: true\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=([a-zA-Z0-9]+)\\&id=test\\&username=user1/;\n          const match = response.text.match(re);\n          if (!match) {\n            fail('should have a token');\n            done();\n            return;\n          }\n          const token = match[1];\n          request({\n            method: 'POST',\n            url: 'http://localhost:8378/1/apps/test/request_password_reset',\n            body: `new_password=uuser11&token=${token}&username=user1`,\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            followRedirects: false,\n            simple: false,\n            resolveWithFullResponse: true\n          }).then(response => {\n            expect(response.status).toEqual(302);\n            expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/password_reset_success.html?username=user1');\n            Parse.User.logIn('user1', 'uuser11').then(function () {\n              done();\n            }).catch(err => {\n              jfail(err);\n              fail('should login with new password');\n              done();\n            });\n          }).catch(error => {\n            jfail(error);\n            fail('Failed to POST request password reset');\n          });\n        }).catch(error => {\n          jfail(error);\n          fail('Failed to get the reset link');\n        });\n      },\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      emailAdapter: emailAdapter,\n      passwordPolicy: {\n        maxPasswordAge: 0.5 / (24 * 60 * 60) // 0.5 sec\n      },\n\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('user1');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        // wait for a bit more than the validity duration set\n        setTimeout(() => {\n          Parse.User.logIn('user1', 'user1').then(() => {\n            fail('logIn should have failed');\n            done();\n          }).catch(error => {\n            expect(error.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n            expect(error.message).toEqual('Your password has expired. Please reset your password.');\n            Parse.User.requestPasswordReset('user1@parse.com').catch(err => {\n              jfail(err);\n              fail('Reset password request should not fail');\n              done();\n            });\n          });\n        }, 1000);\n      }).catch(error => {\n        jfail(error);\n        fail('Signup failed.');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if passwordPolicy.maxPasswordHistory is not a number","suites":["Password Policy: "],"line":1214,"updatePoint":{"line":1214,"column":70,"index":41226},"code":"  it('should fail if passwordPolicy.maxPasswordHistory is not a number', done => {\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        maxPasswordHistory: 'not a number'\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      fail('passwordPolicy.maxPasswordHistory \"not a number\" test failed');\n      done();\n    }).catch(err => {\n      expect(err).toEqual('passwordPolicy.maxPasswordHistory must be an integer ranging 0 - 20');\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if passwordPolicy.maxPasswordHistory is a negative number","suites":["Password Policy: "],"line":1229,"updatePoint":{"line":1229,"column":75,"index":41754},"code":"  it('should fail if passwordPolicy.maxPasswordHistory is a negative number', done => {\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        maxPasswordHistory: -10\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      fail('passwordPolicy.maxPasswordHistory negative number test failed');\n      done();\n    }).catch(err => {\n      expect(err).toEqual('passwordPolicy.maxPasswordHistory must be an integer ranging 0 - 20');\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if passwordPolicy.maxPasswordHistory is greater than 20","suites":["Password Policy: "],"line":1244,"updatePoint":{"line":1244,"column":73,"index":42270},"code":"  it('should fail if passwordPolicy.maxPasswordHistory is greater than 20', done => {\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      passwordPolicy: {\n        maxPasswordHistory: 21\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      fail('passwordPolicy.maxPasswordHistory negative number test failed');\n      done();\n    }).catch(err => {\n      expect(err).toEqual('passwordPolicy.maxPasswordHistory must be an integer ranging 0 - 20');\n      done();\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail to reset if the new password is same as the last password","suites":["Password Policy: "],"line":1259,"updatePoint":{"line":1259,"column":75,"index":42787},"code":"  it('should fail to reset if the new password is same as the last password', done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        request({\n          url: options.link,\n          followRedirects: false\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=([a-zA-Z0-9]+)\\&id=test\\&username=user1/;\n          const match = response.text.match(re);\n          if (!match) {\n            fail('should have a token');\n            return Promise.reject('Invalid password link');\n          }\n          return Promise.resolve(match[1]); // token\n        }).then(token => {\n          return request({\n            method: 'POST',\n            url: 'http://localhost:8378/1/apps/test/request_password_reset',\n            body: `new_password=user1&token=${token}&username=user1`,\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            followRedirects: false,\n            simple: false,\n            resolveWithFullResponse: true\n          }).then(response => {\n            return [response, token];\n          });\n        }).then(data => {\n          const response = data[0];\n          const token = data[1];\n          expect(response.status).toEqual(302);\n          expect(response.text).toEqual(`Found. Redirecting to http://localhost:8378/1/apps/choose_password?username=user1&token=${token}&id=test&error=New%20password%20should%20not%20be%20the%20same%20as%20last%201%20passwords.&app=passwordPolicy`);\n          done();\n          return Promise.resolve();\n        }).catch(error => {\n          fail(error);\n          fail('Repeat password test failed');\n          done();\n        });\n      },\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      verifyUserEmails: false,\n      emailAdapter: emailAdapter,\n      passwordPolicy: {\n        maxPasswordHistory: 1\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('user1');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        return Parse.User.logOut();\n      }).then(() => {\n        return Parse.User.requestPasswordReset('user1@parse.com');\n      }).catch(error => {\n        jfail(error);\n        fail('SignUp or reset request failed');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if the new password is same as the previous one","suites":["Password Policy: "],"line":1328,"updatePoint":{"line":1328,"column":65,"index":45339},"code":"  it('should fail if the new password is same as the previous one', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      verifyUserEmails: false,\n      passwordPolicy: {\n        maxPasswordHistory: 5\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('user1');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        // try to set the same password as the previous one\n        user.setPassword('user1');\n        return user.save();\n      }).then(() => {\n        fail('should have failed because the new password is same as the old');\n        done();\n      }).catch(error => {\n        expect(error.message).toEqual('New password should not be the same as last 5 passwords.');\n        expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should fail if the new password is same as the 5th oldest one and policy does not allow the previous 5","suites":["Password Policy: "],"line":1355,"updatePoint":{"line":1355,"column":108,"index":46330},"code":"  it('should fail if the new password is same as the 5th oldest one and policy does not allow the previous 5', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      verifyUserEmails: false,\n      passwordPolicy: {\n        maxPasswordHistory: 5\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('user1');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        // build history\n        user.setPassword('user2');\n        return user.save();\n      }).then(() => {\n        user.setPassword('user3');\n        return user.save();\n      }).then(() => {\n        user.setPassword('user4');\n        return user.save();\n      }).then(() => {\n        user.setPassword('user5');\n        return user.save();\n      }).then(() => {\n        // set the same password as the initial one\n        user.setPassword('user1');\n        return user.save();\n      }).then(() => {\n        fail('should have failed because the new password is same as the old');\n        done();\n      }).catch(error => {\n        expect(error.message).toEqual('New password should not be the same as last 5 passwords.');\n        expect(error.code).toEqual(Parse.Error.VALIDATION_ERROR);\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed if the new password is same as the 6th oldest one and policy does not allow only previous 5","suites":["Password Policy: "],"line":1395,"updatePoint":{"line":1395,"column":112,"index":47682},"code":"  it('should succeed if the new password is same as the 6th oldest one and policy does not allow only previous 5', done => {\n    const user = new Parse.User();\n    reconfigureServer({\n      appName: 'passwordPolicy',\n      verifyUserEmails: false,\n      passwordPolicy: {\n        maxPasswordHistory: 5\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setUsername('user1');\n      user.setPassword('user1');\n      user.set('email', 'user1@parse.com');\n      user.signUp().then(() => {\n        // build history\n        user.setPassword('user2');\n        return user.save();\n      }).then(() => {\n        user.setPassword('user3');\n        return user.save();\n      }).then(() => {\n        user.setPassword('user4');\n        return user.save();\n      }).then(() => {\n        user.setPassword('user5');\n        return user.save();\n      }).then(() => {\n        user.setPassword('user6'); // this pushes initial password out of history\n        return user.save();\n      }).then(() => {\n        // set the same password as the initial one\n        user.setPassword('user1');\n        return user.save();\n      }).then(() => {\n        done();\n      }).catch(() => {\n        fail('should have succeeded because the new password is not in history');\n        done();\n      });\n    });\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should not infinitely loop if maxPasswordHistory is 1 (#4918)","suites":["Password Policy: "],"line":1436,"updatePoint":{"line":1436,"column":67,"index":48955},"code":"  it('should not infinitely loop if maxPasswordHistory is 1 (#4918)', async () => {\n    const user = new Parse.User();\n    const query = new Parse.Query(Parse.User);\n    await reconfigureServer({\n      appName: 'passwordPolicy',\n      verifyUserEmails: false,\n      passwordPolicy: {\n        maxPasswordHistory: 1\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    user.setUsername('user1');\n    user.setPassword('user1');\n    user.set('email', 'user1@parse.com');\n    await user.signUp();\n    user.setPassword('user2');\n    await user.save();\n    const result1 = await query.get(user.id, {\n      useMasterKey: true\n    });\n    expect(result1.get('_password_history').length).toBe(1);\n    user.setPassword('user3');\n    await user.save();\n    const result2 = await query.get(user.id, {\n      useMasterKey: true\n    });\n    expect(result2.get('_password_history').length).toBe(1);\n    expect(result1.get('_password_history')).not.toEqual(result2.get('_password_history'));\n  });","file":"PasswordPolicy.spec.js","skipped":false,"dir":"spec"},{"name":"should work with find","suites":["Pointer Permissions","using single user-pointers"],"line":9,"updatePoint":{"line":9,"column":29,"index":259},"code":"    it('should work with find', done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      const obj2 = new Parse.Object('AnObject');\n      Parse.Object.saveAll([user, user2]).then(() => {\n        obj.set('owner', user);\n        obj2.set('owner', user2);\n        return Parse.Object.saveAll([obj, obj2]);\n      }).then(() => {\n        return config.database.loadSchema().then(schema => {\n          return schema.updateClass('AnObject', {}, {\n            readUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        return Parse.User.logIn('user1', 'password');\n      }).then(() => {\n        const q = new Parse.Query('AnObject');\n        return q.find();\n      }).then(res => {\n        expect(res.length).toBe(1);\n        expect(res[0].id).toBe(obj.id);\n        done();\n      }).catch(error => {\n        fail(JSON.stringify(error));\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should work with write","suites":["Pointer Permissions","using single user-pointers"],"line":47,"updatePoint":{"line":47,"column":30,"index":1449},"code":"    it('should work with write', done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      const obj2 = new Parse.Object('AnObject');\n      Parse.Object.saveAll([user, user2]).then(() => {\n        obj.set('owner', user);\n        obj.set('reader', user2);\n        obj2.set('owner', user2);\n        obj2.set('reader', user);\n        return Parse.Object.saveAll([obj, obj2]);\n      }).then(() => {\n        return config.database.loadSchema().then(schema => {\n          return schema.updateClass('AnObject', {}, {\n            writeUserFields: ['owner'],\n            readUserFields: ['reader', 'owner']\n          });\n        });\n      }).then(() => {\n        return Parse.User.logIn('user1', 'password');\n      }).then(() => {\n        obj2.set('hello', 'world');\n        return obj2.save();\n      }).then(() => {\n        fail('User should not be able to update obj2');\n      }, err => {\n        // User 1 should not be able to update obj2\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        return Promise.resolve();\n      }).then(() => {\n        obj.set('hello', 'world');\n        return obj.save();\n      }).then(() => {\n        return Parse.User.logIn('user2', 'password');\n      }, () => {\n        fail('User should be able to update');\n        return Promise.resolve();\n      }).then(() => {\n        const q = new Parse.Query('AnObject');\n        return q.find();\n      }, () => {\n        fail('should login with user 2');\n      }).then(res => {\n        expect(res.length).toBe(2);\n        res.forEach(result => {\n          if (result.id == obj.id) {\n            expect(result.get('hello')).toBe('world');\n          } else {\n            expect(result.id).toBe(obj2.id);\n          }\n        });\n        done();\n      }, () => {\n        fail('failed');\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should let a proper user find","suites":["Pointer Permissions","using single user-pointers"],"line":113,"updatePoint":{"line":113,"column":37,"index":3560},"code":"    it('should let a proper user find', done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      const obj2 = new Parse.Object('AnObject');\n      user.signUp().then(() => {\n        return user2.signUp();\n      }).then(() => {\n        Parse.User.logOut();\n      }).then(() => {\n        obj.set('owner', user);\n        return Parse.Object.saveAll([obj, obj2]);\n      }).then(() => {\n        return config.database.loadSchema().then(schema => {\n          return schema.updateClass('AnObject', {}, {\n            find: {},\n            get: {},\n            readUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        const q = new Parse.Query('AnObject');\n        return q.find();\n      }).then(res => {\n        expect(res.length).toBe(0);\n      }).then(() => {\n        return Parse.User.logIn('user2', 'password');\n      }).then(() => {\n        const q = new Parse.Query('AnObject');\n        return q.find();\n      }).then(res => {\n        expect(res.length).toBe(0);\n        const q = new Parse.Query('AnObject');\n        return q.get(obj.id);\n      }).then(() => {\n        fail('User 2 should not get the obj1 object');\n      }, err => {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        expect(err.message).toBe('Object not found.');\n        return Promise.resolve();\n      }).then(() => {\n        return Parse.User.logIn('user1', 'password');\n      }).then(() => {\n        const q = new Parse.Query('AnObject');\n        return q.find();\n      }).then(res => {\n        expect(res.length).toBe(1);\n        done();\n      }).catch(err => {\n        jfail(err);\n        fail('should not fail');\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should query on pointer permission enabled column","suites":["Pointer Permissions","using single user-pointers"],"line":176,"updatePoint":{"line":176,"column":57,"index":5546},"code":"    it('should query on pointer permission enabled column', done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      const obj2 = new Parse.Object('AnObject');\n      user.signUp().then(() => {\n        return user2.signUp();\n      }).then(() => {\n        Parse.User.logOut();\n      }).then(() => {\n        obj.set('owner', user);\n        return Parse.Object.saveAll([obj, obj2]);\n      }).then(() => {\n        return config.database.loadSchema().then(schema => {\n          return schema.updateClass('AnObject', {}, {\n            find: {},\n            get: {},\n            readUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        return Parse.User.logIn('user1', 'password');\n      }).then(() => {\n        const q = new Parse.Query('AnObject');\n        q.equalTo('owner', user2);\n        return q.find();\n      }).then(res => {\n        expect(res.length).toBe(0);\n        done();\n      }).catch(err => {\n        jfail(err);\n        fail('should not fail');\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow creating objects","suites":["Pointer Permissions","using single user-pointers"],"line":220,"updatePoint":{"line":220,"column":41,"index":6847},"code":"    it('should not allow creating objects', done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      user.save().then(() => {\n        return config.database.loadSchema().then(schema => {\n          return schema.addClassIfNotExists('AnObject', {\n            owner: {\n              type: 'Pointer',\n              targetClass: '_User'\n            }\n          }, {\n            create: {},\n            writeUserFields: ['owner'],\n            readUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        return Parse.User.logIn('user1', 'password');\n      }).then(() => {\n        obj.set('owner', user);\n        return obj.save();\n      }).then(() => {\n        fail('should not succeed');\n        done();\n      }, err => {\n        expect(err.code).toBe(119);\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should handle multiple writeUserFields","suites":["Pointer Permissions","using single user-pointers"],"line":254,"updatePoint":{"line":254,"column":46,"index":7841},"code":"    it('should handle multiple writeUserFields', done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      Parse.Object.saveAll([user, user2]).then(() => {\n        obj.set('owner', user);\n        obj.set('otherOwner', user2);\n        return obj.save();\n      }).then(() => config.database.loadSchema()).then(schema => schema.updateClass('AnObject', {}, {\n        find: {\n          '*': true\n        },\n        writeUserFields: ['owner', 'otherOwner']\n      })).then(() => Parse.User.logIn('user1', 'password')).then(() => obj.save({\n        hello: 'fromUser1'\n      })).then(() => Parse.User.logIn('user2', 'password')).then(() => obj.save({\n        hello: 'fromUser2'\n      })).then(() => Parse.User.logOut()).then(() => {\n        const q = new Parse.Query('AnObject');\n        return q.first();\n      }).then(result => {\n        expect(result.get('hello')).toBe('fromUser2');\n        done();\n      }).catch(() => {\n        fail('should not fail');\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should prevent creating pointer permission on missing field","suites":["Pointer Permissions","using single user-pointers"],"line":291,"updatePoint":{"line":291,"column":67,"index":9148},"code":"    it('should prevent creating pointer permission on missing field', done => {\n      const config = Config.get(Parse.applicationId);\n      config.database.loadSchema().then(schema => {\n        return schema.addClassIfNotExists('AnObject', {}, {\n          create: {},\n          writeUserFields: ['owner'],\n          readUserFields: ['owner']\n        });\n      }).then(() => {\n        fail('should not succeed');\n      }).catch(err => {\n        expect(err.code).toBe(107);\n        expect(err.message).toBe(\"'owner' is not a valid column for class level pointer permissions writeUserFields\");\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should prevent creating pointer permission on bad field (of wrong type)","suites":["Pointer Permissions","using single user-pointers"],"line":307,"updatePoint":{"line":307,"column":79,"index":9785},"code":"    it('should prevent creating pointer permission on bad field (of wrong type)', done => {\n      const config = Config.get(Parse.applicationId);\n      config.database.loadSchema().then(schema => {\n        return schema.addClassIfNotExists('AnObject', {\n          owner: {\n            type: 'String'\n          }\n        }, {\n          create: {},\n          writeUserFields: ['owner'],\n          readUserFields: ['owner']\n        });\n      }).then(() => {\n        fail('should not succeed');\n      }).catch(err => {\n        expect(err.code).toBe(107);\n        expect(err.message).toBe(\"'owner' is not a valid column for class level pointer permissions writeUserFields\");\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should prevent creating pointer permission on bad field (non-user pointer)","suites":["Pointer Permissions","using single user-pointers"],"line":327,"updatePoint":{"line":327,"column":82,"index":10492},"code":"    it('should prevent creating pointer permission on bad field (non-user pointer)', done => {\n      const config = Config.get(Parse.applicationId);\n      config.database.loadSchema().then(schema => {\n        return schema.addClassIfNotExists('AnObject', {\n          owner: {\n            type: 'Pointer',\n            targetClass: '_Session'\n          }\n        }, {\n          create: {},\n          writeUserFields: ['owner'],\n          readUserFields: ['owner']\n        });\n      }).then(() => {\n        fail('should not succeed');\n      }).catch(err => {\n        expect(err.code).toBe(107);\n        expect(err.message).toBe(\"'owner' is not a valid column for class level pointer permissions writeUserFields\");\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should prevent creating pointer permission on bad field (non-existing)","suites":["Pointer Permissions","using single user-pointers"],"line":348,"updatePoint":{"line":348,"column":78,"index":11233},"code":"    it('should prevent creating pointer permission on bad field (non-existing)', done => {\n      const config = Config.get(Parse.applicationId);\n      const object = new Parse.Object('AnObject');\n      object.set('owner', 'value');\n      object.save().then(() => {\n        return config.database.loadSchema();\n      }).then(schema => {\n        return schema.updateClass('AnObject', {}, {\n          create: {},\n          writeUserFields: ['owner'],\n          readUserFields: ['owner']\n        });\n      }).then(() => {\n        fail('should not succeed');\n      }).catch(err => {\n        expect(err.code).toBe(107);\n        expect(err.message).toBe(\"'owner' is not a valid column for class level pointer permissions writeUserFields\");\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL write (PP Locked)","suites":["Pointer Permissions","using single user-pointers"],"line":368,"updatePoint":{"line":368,"column":57,"index":11979},"code":"    it('tests CLP / Pointer Perms / ACL write (PP Locked)', done => {\n      /*\n        tests:\n        CLP: update closed ({})\n        PointerPerm: \"owner\"\n        ACL: logged in user has access\n         The owner is another user than the ACL\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      Parse.Object.saveAll([user, user2]).then(() => {\n        const ACL = new Parse.ACL();\n        ACL.setReadAccess(user, true);\n        ACL.setWriteAccess(user, true);\n        obj.setACL(ACL);\n        obj.set('owner', user2);\n        return obj.save();\n      }).then(() => {\n        return config.database.loadSchema().then(schema => {\n          // Lock the update, and let only owner write\n          return schema.updateClass('AnObject', {}, {\n            update: {},\n            writeUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        return Parse.User.logIn('user1', 'password');\n      }).then(() => {\n        // user1 has ACL read/write but should be blocked by PP\n        return obj.save({\n          key: 'value'\n        });\n      }).then(() => {\n        fail('Should not succeed saving');\n        done();\n      }, err => {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL write (ACL Locked)","suites":["Pointer Permissions","using single user-pointers"],"line":418,"updatePoint":{"line":418,"column":58,"index":13530},"code":"    it('tests CLP / Pointer Perms / ACL write (ACL Locked)', done => {\n      /*\n        tests:\n        CLP: update closed ({})\n        PointerPerm: \"owner\"\n        ACL: logged in user has access\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      Parse.Object.saveAll([user, user2]).then(() => {\n        const ACL = new Parse.ACL();\n        ACL.setReadAccess(user, true);\n        ACL.setWriteAccess(user, true);\n        obj.setACL(ACL);\n        obj.set('owner', user2);\n        return obj.save();\n      }).then(() => {\n        return config.database.loadSchema().then(schema => {\n          // Lock the update, and let only owner write\n          return schema.updateClass('AnObject', {}, {\n            update: {},\n            writeUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        return Parse.User.logIn('user2', 'password');\n      }).then(() => {\n        // user1 has ACL read/write but should be blocked by ACL\n        return obj.save({\n          key: 'value'\n        });\n      }).then(() => {\n        fail('Should not succeed saving');\n        done();\n      }, err => {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL write (ACL/PP OK)","suites":["Pointer Permissions","using single user-pointers"],"line":467,"updatePoint":{"line":467,"column":57,"index":15033},"code":"    it('tests CLP / Pointer Perms / ACL write (ACL/PP OK)', done => {\n      /*\n        tests:\n        CLP: update closed ({})\n        PointerPerm: \"owner\"\n        ACL: logged in user has access\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      Parse.Object.saveAll([user, user2]).then(() => {\n        const ACL = new Parse.ACL();\n        ACL.setWriteAccess(user, true);\n        ACL.setWriteAccess(user2, true);\n        obj.setACL(ACL);\n        obj.set('owner', user2);\n        return obj.save();\n      }).then(() => {\n        return config.database.loadSchema().then(schema => {\n          // Lock the update, and let only owner write\n          return schema.updateClass('AnObject', {}, {\n            update: {},\n            writeUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        return Parse.User.logIn('user2', 'password');\n      }).then(() => {\n        // user1 has ACL read/write but should be blocked by ACL\n        return obj.save({\n          key: 'value'\n        });\n      }).then(objAgain => {\n        expect(objAgain.get('key')).toBe('value');\n        done();\n      }, () => {\n        fail('Should not fail saving');\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL read (PP locked)","suites":["Pointer Permissions","using single user-pointers"],"line":516,"updatePoint":{"line":516,"column":56,"index":16529},"code":"    it('tests CLP / Pointer Perms / ACL read (PP locked)', done => {\n      /*\n        tests:\n        CLP: find/get open ({})\n        PointerPerm: \"owner\" : read\n        ACL: logged in user has access\n         The owner is another user than the ACL\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      Parse.Object.saveAll([user, user2]).then(() => {\n        const ACL = new Parse.ACL();\n        ACL.setReadAccess(user, true);\n        ACL.setWriteAccess(user, true);\n        obj.setACL(ACL);\n        obj.set('owner', user2);\n        return obj.save();\n      }).then(() => {\n        return config.database.loadSchema().then(schema => {\n          // Lock the update, and let only owner write\n          return schema.updateClass('AnObject', {}, {\n            find: {},\n            get: {},\n            readUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        return Parse.User.logIn('user1', 'password');\n      }).then(() => {\n        // user1 has ACL read/write but should be block\n        return obj.fetch();\n      }).then(() => {\n        fail('Should not succeed saving');\n        done();\n      }, err => {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL read (PP/ACL OK)","suites":["Pointer Permissions","using single user-pointers"],"line":565,"updatePoint":{"line":565,"column":56,"index":18062},"code":"    it('tests CLP / Pointer Perms / ACL read (PP/ACL OK)', done => {\n      /*\n        tests:\n        CLP: find/get open ({\"*\": true})\n        PointerPerm: \"owner\" : read\n        ACL: logged in user has access\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      Parse.Object.saveAll([user, user2]).then(() => {\n        const ACL = new Parse.ACL();\n        ACL.setReadAccess(user, true);\n        ACL.setWriteAccess(user, true);\n        ACL.setReadAccess(user2, true);\n        ACL.setWriteAccess(user2, true);\n        obj.setACL(ACL);\n        obj.set('owner', user2);\n        return obj.save();\n      }).then(() => {\n        return config.database.loadSchema().then(schema => {\n          // Lock the update, and let only owner write\n          return schema.updateClass('AnObject', {}, {\n            find: {\n              '*': true\n            },\n            get: {\n              '*': true\n            },\n            readUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        return Parse.User.logIn('user2', 'password');\n      }).then(() => {\n        // user1 has ACL read/write but should be block\n        return obj.fetch();\n      }).then(objAgain => {\n        expect(objAgain.id).toBe(obj.id);\n        done();\n      }, () => {\n        fail('Should not fail fetching');\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL read (ACL locked)","suites":["Pointer Permissions","using single user-pointers"],"line":619,"updatePoint":{"line":619,"column":57,"index":19697},"code":"    it('tests CLP / Pointer Perms / ACL read (ACL locked)', done => {\n      /*\n        tests:\n        CLP: find/get open ({\"*\": true})\n        PointerPerm: \"owner\" : read // proper owner\n        ACL: logged in user has not access\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      Parse.Object.saveAll([user, user2]).then(() => {\n        const ACL = new Parse.ACL();\n        ACL.setReadAccess(user, true);\n        ACL.setWriteAccess(user, true);\n        obj.setACL(ACL);\n        obj.set('owner', user2);\n        return obj.save();\n      }).then(() => {\n        return config.database.loadSchema().then(schema => {\n          // Lock the update, and let only owner write\n          return schema.updateClass('AnObject', {}, {\n            find: {\n              '*': true\n            },\n            get: {\n              '*': true\n            },\n            readUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        return Parse.User.logIn('user2', 'password');\n      }).then(() => {\n        // user2 has ACL read/write but should be block by ACL\n        return obj.fetch();\n      }).then(() => {\n        fail('Should not succeed saving');\n        done();\n      }, err => {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should let master key find objects","suites":["Pointer Permissions","using single user-pointers"],"line":671,"updatePoint":{"line":671,"column":42,"index":21278},"code":"    it('should let master key find objects', done => {\n      const config = Config.get(Parse.applicationId);\n      const object = new Parse.Object('AnObject');\n      object.set('hello', 'world');\n      return object.save().then(() => {\n        return config.database.loadSchema().then(schema => {\n          // Lock the update, and let only owner write\n          return schema.updateClass('AnObject', {\n            owner: {\n              type: 'Pointer',\n              targetClass: '_User'\n            }\n          }, {\n            find: {},\n            get: {},\n            readUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        const q = new Parse.Query('AnObject');\n        return q.find();\n      }).then(() => {}, err => {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        return Promise.resolve();\n      }).then(() => {\n        const q = new Parse.Query('AnObject');\n        return q.find({\n          useMasterKey: true\n        });\n      }).then(objects => {\n        expect(objects.length).toBe(1);\n        done();\n      }, () => {\n        fail('master key should find the object');\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should let master key get objects","suites":["Pointer Permissions","using single user-pointers"],"line":708,"updatePoint":{"line":708,"column":41,"index":22443},"code":"    it('should let master key get objects', done => {\n      const config = Config.get(Parse.applicationId);\n      const object = new Parse.Object('AnObject');\n      object.set('hello', 'world');\n      return object.save().then(() => {\n        return config.database.loadSchema().then(schema => {\n          // Lock the update, and let only owner write\n          return schema.updateClass('AnObject', {\n            owner: {\n              type: 'Pointer',\n              targetClass: '_User'\n            }\n          }, {\n            find: {},\n            get: {},\n            readUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        const q = new Parse.Query('AnObject');\n        return q.get(object.id);\n      }).then(() => {}, err => {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        return Promise.resolve();\n      }).then(() => {\n        const q = new Parse.Query('AnObject');\n        return q.get(object.id, {\n          useMasterKey: true\n        });\n      }).then(objectAgain => {\n        expect(objectAgain).not.toBeUndefined();\n        expect(objectAgain.id).toBe(object.id);\n        done();\n      }, () => {\n        fail('master key should find the object');\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should let master key update objects","suites":["Pointer Permissions","using single user-pointers"],"line":746,"updatePoint":{"line":746,"column":44,"index":23690},"code":"    it('should let master key update objects', done => {\n      const config = Config.get(Parse.applicationId);\n      const object = new Parse.Object('AnObject');\n      object.set('hello', 'world');\n      return object.save().then(() => {\n        return config.database.loadSchema().then(schema => {\n          // Lock the update, and let only owner write\n          return schema.updateClass('AnObject', {\n            owner: {\n              type: 'Pointer',\n              targetClass: '_User'\n            }\n          }, {\n            update: {},\n            writeUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        return object.save({\n          hello: 'bar'\n        });\n      }).then(() => {}, err => {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        return Promise.resolve();\n      }).then(() => {\n        return object.save({\n          hello: 'baz'\n        }, {\n          useMasterKey: true\n        });\n      }).then(objectAgain => {\n        expect(objectAgain.get('hello')).toBe('baz');\n        done();\n      }, () => {\n        fail('master key should save the object');\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should let master key delete objects","suites":["Pointer Permissions","using single user-pointers"],"line":784,"updatePoint":{"line":784,"column":44,"index":24844},"code":"    it('should let master key delete objects', done => {\n      const config = Config.get(Parse.applicationId);\n      const object = new Parse.Object('AnObject');\n      object.set('hello', 'world');\n      return object.save().then(() => {\n        return config.database.loadSchema().then(schema => {\n          // Lock the update, and let only owner write\n          return schema.updateClass('AnObject', {\n            owner: {\n              type: 'Pointer',\n              targetClass: '_User'\n            }\n          }, {\n            delete: {},\n            writeUserFields: ['owner']\n          });\n        });\n      }).then(() => {\n        return object.destroy();\n      }).then(() => {\n        fail();\n      }, err => {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        return Promise.resolve();\n      }).then(() => {\n        return object.destroy({\n          useMasterKey: true\n        });\n      }).then(() => {\n        done();\n      }, () => {\n        fail('master key should destroy the object');\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should fail with invalid pointer perms (not array)","suites":["Pointer Permissions","using single user-pointers"],"line":819,"updatePoint":{"line":819,"column":58,"index":25911},"code":"    it('should fail with invalid pointer perms (not array)', done => {\n      const config = Config.get(Parse.applicationId);\n      config.database.loadSchema().then(schema => {\n        // Lock the update, and let only owner write\n        return schema.addClassIfNotExists('AnObject', {\n          owner: {\n            type: 'Pointer',\n            targetClass: '_User'\n          }\n        }, {\n          delete: {},\n          writeUserFields: 'owner'\n        });\n      }).catch(err => {\n        expect(err.code).toBe(Parse.Error.INVALID_JSON);\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should fail with invalid pointer perms (non-existing field)","suites":["Pointer Permissions","using single user-pointers"],"line":837,"updatePoint":{"line":837,"column":67,"index":26496},"code":"    it('should fail with invalid pointer perms (non-existing field)', done => {\n      const config = Config.get(Parse.applicationId);\n      config.database.loadSchema().then(schema => {\n        // Lock the update, and let only owner write\n        return schema.addClassIfNotExists('AnObject', {\n          owner: {\n            type: 'Pointer',\n            targetClass: '_User'\n          }\n        }, {\n          delete: {},\n          writeUserFields: ['owner', 'invalid']\n        });\n      }).catch(err => {\n        expect(err.code).toBe(Parse.Error.INVALID_JSON);\n        done();\n      });\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should work with find","suites":["Pointer Permissions","using arrays of user-pointers"],"line":857,"updatePoint":{"line":857,"column":29,"index":27114},"code":"    it('should work with find', async done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      const obj2 = new Parse.Object('AnObject');\n      await Parse.Object.saveAll([user, user2]);\n      obj.set('owners', [user]);\n      obj2.set('owners', [user2]);\n      await Parse.Object.saveAll([obj, obj2]);\n      const schema = await config.database.loadSchema();\n      await schema.updateClass('AnObject', {}, {\n        readUserFields: ['owners']\n      });\n      await Parse.User.logIn('user1', 'password');\n      try {\n        const q = new Parse.Query('AnObject');\n        const res = await q.find();\n        expect(res.length).toBe(1);\n        expect(res[0].id).toBe(obj.id);\n        done();\n      } catch (err) {\n        done.fail(JSON.stringify(err));\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should work with write","suites":["Pointer Permissions","using arrays of user-pointers"],"line":890,"updatePoint":{"line":890,"column":30,"index":28187},"code":"    it('should work with write', async done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      const obj2 = new Parse.Object('AnObject');\n      await Parse.Object.saveAll([user, user2]);\n      obj.set('owner', user);\n      obj.set('readers', [user2]);\n      obj2.set('owner', user2);\n      obj2.set('readers', [user]);\n      await Parse.Object.saveAll([obj, obj2]);\n      const schema = await config.database.loadSchema();\n      await schema.updateClass('AnObject', {}, {\n        writeUserFields: ['owner'],\n        readUserFields: ['readers', 'owner']\n      });\n      await Parse.User.logIn('user1', 'password');\n      obj2.set('hello', 'world');\n      try {\n        await obj2.save();\n        done.fail('User should not be able to update obj2');\n      } catch (err) {\n        // User 1 should not be able to update obj2\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      }\n      obj.set('hello', 'world');\n      try {\n        await obj.save();\n      } catch (err) {\n        done.fail('User should be able to update');\n      }\n      await Parse.User.logIn('user2', 'password');\n      try {\n        const q = new Parse.Query('AnObject');\n        const res = await q.find();\n        expect(res.length).toBe(2);\n        res.forEach(result => {\n          if (result.id == obj.id) {\n            expect(result.get('hello')).toBe('world');\n          } else {\n            expect(result.id).toBe(obj2.id);\n          }\n        });\n        done();\n      } catch (err) {\n        done.fail('failed');\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should let a proper user find","suites":["Pointer Permissions","using arrays of user-pointers"],"line":947,"updatePoint":{"line":947,"column":37,"index":30019},"code":"    it('should let a proper user find', async done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      const user3 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      user3.set({\n        username: 'user3',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      const obj2 = new Parse.Object('AnObject');\n      await user.signUp();\n      await user2.signUp();\n      await user3.signUp();\n      await Parse.User.logOut();\n      obj.set('owners', [user, user2]);\n      await Parse.Object.saveAll([obj, obj2]);\n      const schema = await config.database.loadSchema();\n      await schema.updateClass('AnObject', {}, {\n        find: {},\n        get: {},\n        readUserFields: ['owners']\n      });\n      let q = new Parse.Query('AnObject');\n      let result = await q.find();\n      expect(result.length).toBe(0);\n      Parse.User.logIn('user3', 'password');\n      q = new Parse.Query('AnObject');\n      result = await q.find();\n      expect(result.length).toBe(0);\n      q = new Parse.Query('AnObject');\n      try {\n        await q.get(obj.id);\n        done.fail('User 3 should not get the obj1 object');\n      } catch (err) {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        expect(err.message).toBe('Object not found.');\n      }\n      for (const owner of ['user1', 'user2']) {\n        await Parse.User.logIn(owner, 'password');\n        try {\n          const q = new Parse.Query('AnObject');\n          result = await q.find();\n          expect(result.length).toBe(1);\n        } catch (err) {\n          done.fail('should not fail');\n        }\n      }\n      done();\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should query on pointer permission enabled column","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1005,"updatePoint":{"line":1005,"column":57,"index":31894},"code":"    it('should query on pointer permission enabled column', async done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      const user3 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      user3.set({\n        username: 'user3',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      const obj2 = new Parse.Object('AnObject');\n      await user.signUp();\n      await user2.signUp();\n      await user3.signUp();\n      await Parse.User.logOut();\n      obj.set('owners', [user, user2]);\n      await Parse.Object.saveAll([obj, obj2]);\n      const schema = await config.database.loadSchema();\n      await schema.updateClass('AnObject', {}, {\n        find: {},\n        get: {},\n        readUserFields: ['owners']\n      });\n      for (const owner of ['user1', 'user2']) {\n        await Parse.User.logIn(owner, 'password');\n        try {\n          const q = new Parse.Query('AnObject');\n          q.equalTo('owners', user3);\n          const result = await q.find();\n          expect(result.length).toBe(0);\n        } catch (err) {\n          done.fail('should not fail');\n        }\n      }\n      done();\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not query using arrays on pointer permission enabled column","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1049,"updatePoint":{"line":1049,"column":74,"index":33277},"code":"    it('should not query using arrays on pointer permission enabled column', async done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      const user3 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      user3.set({\n        username: 'user3',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      const obj2 = new Parse.Object('AnObject');\n      await user.signUp();\n      await user2.signUp();\n      await user3.signUp();\n      await Parse.User.logOut();\n      obj.set('owners', [user, user2]);\n      await Parse.Object.saveAll([obj, obj2]);\n      const schema = await config.database.loadSchema();\n      await schema.updateClass('AnObject', {}, {\n        find: {},\n        get: {},\n        readUserFields: ['owners']\n      });\n      for (const owner of ['user1', 'user2']) {\n        try {\n          await Parse.User.logIn(owner, 'password');\n          // Since querying for arrays is not supported this should throw an error\n          const q = new Parse.Query('AnObject');\n          q.equalTo('owners', [user3]);\n          await q.find();\n          done.fail('should fail');\n          // eslint-disable-next-line no-empty\n        } catch (error) {}\n      }\n      done();\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow creating objects","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1093,"updatePoint":{"line":1093,"column":41,"index":34694},"code":"    it('should not allow creating objects', async done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      await Parse.Object.saveAll([user, user2]);\n      const schema = await config.database.loadSchema();\n      await schema.addClassIfNotExists('AnObject', {\n        owners: {\n          type: 'Array'\n        }\n      }, {\n        create: {},\n        writeUserFields: ['owners'],\n        readUserFields: ['owners']\n      });\n      for (const owner of ['user1', 'user2']) {\n        await Parse.User.logIn(owner, 'password');\n        try {\n          obj.set('owners', [user, user2]);\n          await obj.save();\n          done.fail('should not succeed');\n        } catch (err) {\n          expect(err.code).toBe(119);\n        }\n      }\n      done();\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should handle multiple writeUserFields","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1129,"updatePoint":{"line":1129,"column":46,"index":35757},"code":"    it('should handle multiple writeUserFields', async done => {\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      await Parse.Object.saveAll([user, user2]);\n      obj.set('owners', [user]);\n      obj.set('otherOwners', [user2]);\n      await obj.save();\n      const schema = await config.database.loadSchema();\n      await schema.updateClass('AnObject', {}, {\n        find: {\n          '*': true\n        },\n        writeUserFields: ['owners', 'otherOwners']\n      });\n      await Parse.User.logIn('user1', 'password');\n      await obj.save({\n        hello: 'fromUser1'\n      });\n      await Parse.User.logIn('user2', 'password');\n      await obj.save({\n        hello: 'fromUser2'\n      });\n      await Parse.User.logOut();\n      try {\n        const q = new Parse.Query('AnObject');\n        const result = await q.first();\n        expect(result.get('hello')).toBe('fromUser2');\n        done();\n      } catch (err) {\n        done.fail('should not fail');\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should prevent creating pointer permission on missing field","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1171,"updatePoint":{"line":1171,"column":67,"index":37047},"code":"    it('should prevent creating pointer permission on missing field', async done => {\n      const config = Config.get(Parse.applicationId);\n      const schema = await config.database.loadSchema();\n      try {\n        await schema.addClassIfNotExists('AnObject', {}, {\n          create: {},\n          writeUserFields: ['owners'],\n          readUserFields: ['owners']\n        });\n        done.fail('should not succeed');\n      } catch (err) {\n        expect(err.code).toBe(107);\n        expect(err.message).toBe(\"'owners' is not a valid column for class level pointer permissions writeUserFields\");\n        done();\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should prevent creating pointer permission on bad field (of wrong type)","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1187,"updatePoint":{"line":1187,"column":79,"index":37688},"code":"    it('should prevent creating pointer permission on bad field (of wrong type)', async done => {\n      const config = Config.get(Parse.applicationId);\n      const schema = await config.database.loadSchema();\n      try {\n        await schema.addClassIfNotExists('AnObject', {\n          owners: {\n            type: 'String'\n          }\n        }, {\n          create: {},\n          writeUserFields: ['owners'],\n          readUserFields: ['owners']\n        });\n        done.fail('should not succeed');\n      } catch (err) {\n        expect(err.code).toBe(107);\n        expect(err.message).toBe(\"'owners' is not a valid column for class level pointer permissions writeUserFields\");\n        done();\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should prevent creating pointer permission on bad field (non-existing)","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1207,"updatePoint":{"line":1207,"column":78,"index":38396},"code":"    it('should prevent creating pointer permission on bad field (non-existing)', async done => {\n      const config = Config.get(Parse.applicationId);\n      const object = new Parse.Object('AnObject');\n      object.set('owners', 'value');\n      await object.save();\n      const schema = await config.database.loadSchema();\n      try {\n        await schema.updateClass('AnObject', {}, {\n          create: {},\n          writeUserFields: ['owners'],\n          readUserFields: ['owners']\n        });\n        done.fail('should not succeed');\n      } catch (err) {\n        expect(err.code).toBe(107);\n        expect(err.message).toBe(\"'owners' is not a valid column for class level pointer permissions writeUserFields\");\n        done();\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should work with arrays containing valid & invalid elements","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1226,"updatePoint":{"line":1226,"column":67,"index":39132},"code":"    it('should work with arrays containing valid & invalid elements', async done => {\n      /* Since there is no way to check the validity of objects in arrays before querying invalid\n         elements in arrays should be ignored. */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      await Parse.Object.saveAll([user, user2]);\n      obj.set('owners', [user, '', -1, true, [], {\n        invalid: -1\n      }]);\n      await Parse.Object.saveAll([obj]);\n      const schema = await config.database.loadSchema();\n      await schema.updateClass('AnObject', {}, {\n        readUserFields: ['owners']\n      });\n      await Parse.User.logIn('user1', 'password');\n      try {\n        const q = new Parse.Query('AnObject');\n        const res = await q.find();\n        expect(res.length).toBe(1);\n        expect(res[0].id).toBe(obj.id);\n      } catch (err) {\n        done.fail(JSON.stringify(err));\n      }\n      await Parse.User.logOut();\n      await Parse.User.logIn('user2', 'password');\n      try {\n        const q = new Parse.Query('AnObject');\n        const res = await q.find();\n        expect(res.length).toBe(0);\n        done();\n      } catch (err) {\n        done.fail(JSON.stringify(err));\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL write (PP Locked)","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1270,"updatePoint":{"line":1270,"column":57,"index":40624},"code":"    it('tests CLP / Pointer Perms / ACL write (PP Locked)', async done => {\n      /*\n        tests:\n        CLP: update closed ({})\n        PointerPerm: \"owners\"\n        ACL: logged in user has access\n         The owner is another user than the ACL\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      const user3 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      user3.set({\n        username: 'user3',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      await Parse.Object.saveAll([user, user2, user3]);\n      const ACL = new Parse.ACL();\n      ACL.setReadAccess(user, true);\n      ACL.setWriteAccess(user, true);\n      obj.setACL(ACL);\n      obj.set('owners', [user2, user3]);\n      await obj.save();\n      const schema = await config.database.loadSchema();\n      // Lock the update, and let only owners write\n      await schema.updateClass('AnObject', {}, {\n        update: {},\n        writeUserFields: ['owners']\n      });\n      await Parse.User.logIn('user1', 'password');\n      try {\n        // user1 has ACL read/write but should be blocked by PP\n        await obj.save({\n          key: 'value'\n        });\n        done.fail('Should not succeed saving');\n      } catch (err) {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        done();\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL write (ACL Locked)","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1320,"updatePoint":{"line":1320,"column":58,"index":42178},"code":"    it('tests CLP / Pointer Perms / ACL write (ACL Locked)', async done => {\n      /*\n        tests:\n        CLP: update closed ({})\n        PointerPerm: \"owners\"\n        ACL: logged in user has access\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      const user3 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      user3.set({\n        username: 'user3',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      await Parse.Object.saveAll([user, user2, user3]);\n      const ACL = new Parse.ACL();\n      ACL.setReadAccess(user, true);\n      ACL.setWriteAccess(user, true);\n      obj.setACL(ACL);\n      obj.set('owners', [user2, user3]);\n      await obj.save();\n      const schema = await config.database.loadSchema();\n      // Lock the update, and let only owners write\n      await schema.updateClass('AnObject', {}, {\n        update: {},\n        writeUserFields: ['owners']\n      });\n      for (const owner of ['user2', 'user3']) {\n        await Parse.User.logIn(owner, 'password');\n        try {\n          await obj.save({\n            key: 'value'\n          });\n          done.fail('Should not succeed saving');\n        } catch (err) {\n          expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        }\n      }\n      done();\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL write (ACL/PP OK)","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1370,"updatePoint":{"line":1370,"column":57,"index":43689},"code":"    it('tests CLP / Pointer Perms / ACL write (ACL/PP OK)', async done => {\n      /*\n        tests:\n        CLP: update closed ({})\n        PointerPerm: \"owners\"\n        ACL: logged in user has access\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      const user3 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      user3.set({\n        username: 'user3',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      await Parse.Object.saveAll([user, user2, user3]);\n      const ACL = new Parse.ACL();\n      ACL.setWriteAccess(user, true);\n      ACL.setWriteAccess(user2, true);\n      ACL.setWriteAccess(user3, true);\n      obj.setACL(ACL);\n      obj.set('owners', [user2, user3]);\n      await obj.save();\n      const schema = await config.database.loadSchema();\n      // Lock the update, and let only owners write\n      await schema.updateClass('AnObject', {}, {\n        update: {},\n        writeUserFields: ['owners']\n      });\n      for (const owner of ['user2', 'user3']) {\n        await Parse.User.logIn(owner, 'password');\n        try {\n          const objectAgain = await obj.save({\n            key: 'value'\n          });\n          expect(objectAgain.get('key')).toBe('value');\n        } catch (err) {\n          done.fail('Should not fail saving');\n        }\n      }\n      done();\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL read (PP locked)","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1421,"updatePoint":{"line":1421,"column":56,"index":45250},"code":"    it('tests CLP / Pointer Perms / ACL read (PP locked)', async done => {\n      /*\n        tests:\n        CLP: find/get open ({})\n        PointerPerm: \"owners\" : read\n        ACL: logged in user has access\n         The owner is another user than the ACL\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      const user3 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      user3.set({\n        username: 'user3',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      await Parse.Object.saveAll([user, user2, user3]);\n      const ACL = new Parse.ACL();\n      ACL.setReadAccess(user, true);\n      ACL.setWriteAccess(user, true);\n      obj.setACL(ACL);\n      obj.set('owners', [user2, user3]);\n      await obj.save();\n      const schema = await config.database.loadSchema();\n      // Lock reading, and let only owners read\n      await schema.updateClass('AnObject', {}, {\n        find: {},\n        get: {},\n        readUserFields: ['owners']\n      });\n      await Parse.User.logIn('user1', 'password');\n      try {\n        // user1 has ACL read/write but should be blocked\n        await obj.fetch();\n        done.fail('Should not succeed fetching');\n      } catch (err) {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        done();\n      }\n      done();\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL read (PP/ACL OK)","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1471,"updatePoint":{"line":1471,"column":56,"index":46796},"code":"    it('tests CLP / Pointer Perms / ACL read (PP/ACL OK)', async done => {\n      /*\n        tests:\n        CLP: find/get open ({\"*\": true})\n        PointerPerm: \"owners\" : read\n        ACL: logged in user has access\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      const user3 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      user3.set({\n        username: 'user3',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      await Parse.Object.saveAll([user, user2, user3]);\n      const ACL = new Parse.ACL();\n      ACL.setReadAccess(user, true);\n      ACL.setWriteAccess(user, true);\n      ACL.setReadAccess(user2, true);\n      ACL.setWriteAccess(user2, true);\n      ACL.setReadAccess(user3, true);\n      ACL.setWriteAccess(user3, true);\n      obj.setACL(ACL);\n      obj.set('owners', [user2, user3]);\n      await obj.save();\n      const schema = await config.database.loadSchema();\n      // Allow public and owners read\n      await schema.updateClass('AnObject', {}, {\n        find: {\n          '*': true\n        },\n        get: {\n          '*': true\n        },\n        readUserFields: ['owners']\n      });\n      for (const owner of ['user2', 'user3']) {\n        await Parse.User.logIn(owner, 'password');\n        try {\n          const objectAgain = await obj.fetch();\n          expect(objectAgain.id).toBe(obj.id);\n        } catch (err) {\n          done.fail('Should not fail fetching');\n        }\n      }\n      done();\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"tests CLP / Pointer Perms / ACL read (ACL locked)","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1528,"updatePoint":{"line":1528,"column":57,"index":48501},"code":"    it('tests CLP / Pointer Perms / ACL read (ACL locked)', async done => {\n      /*\n        tests:\n        CLP: find/get open ({\"*\": true})\n        PointerPerm: \"owners\" : read // proper owner\n        ACL: logged in user has not access\n       */\n      const config = Config.get(Parse.applicationId);\n      const user = new Parse.User();\n      const user2 = new Parse.User();\n      const user3 = new Parse.User();\n      user.set({\n        username: 'user1',\n        password: 'password'\n      });\n      user2.set({\n        username: 'user2',\n        password: 'password'\n      });\n      user3.set({\n        username: 'user3',\n        password: 'password'\n      });\n      const obj = new Parse.Object('AnObject');\n      await Parse.Object.saveAll([user, user2, user3]);\n      const ACL = new Parse.ACL();\n      ACL.setReadAccess(user, true);\n      ACL.setWriteAccess(user, true);\n      obj.setACL(ACL);\n      obj.set('owners', [user2, user3]);\n      await obj.save();\n      const schema = await config.database.loadSchema();\n      // Allow public and owners read\n      await schema.updateClass('AnObject', {}, {\n        find: {\n          '*': true\n        },\n        get: {\n          '*': true\n        },\n        readUserFields: ['owners']\n      });\n      for (const owner of ['user2', 'user3']) {\n        await Parse.User.logIn(owner, 'password');\n        try {\n          await obj.fetch();\n          done.fail('Should not succeed fetching');\n        } catch (err) {\n          expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        }\n      }\n      done();\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should let master key find objects","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1581,"updatePoint":{"line":1581,"column":42,"index":50056},"code":"    it('should let master key find objects', async done => {\n      const config = Config.get(Parse.applicationId);\n      const object = new Parse.Object('AnObject');\n      object.set('hello', 'world');\n      await object.save();\n      const schema = await config.database.loadSchema();\n      // Lock the find/get, and let only owners read\n      await schema.updateClass('AnObject', {\n        owners: {\n          type: 'Array'\n        }\n      }, {\n        find: {},\n        get: {},\n        readUserFields: ['owners']\n      });\n      const q = new Parse.Query('AnObject');\n      const objects = await q.find();\n      expect(objects.length).toBe(0);\n      try {\n        const objects = await q.find({\n          useMasterKey: true\n        });\n        expect(objects.length).toBe(1);\n        done();\n      } catch (err) {\n        done.fail('master key should find the object');\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should let master key get objects","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1610,"updatePoint":{"line":1610,"column":41,"index":50945},"code":"    it('should let master key get objects', async done => {\n      const config = Config.get(Parse.applicationId);\n      const object = new Parse.Object('AnObject');\n      object.set('hello', 'world');\n      await object.save();\n      const schema = await config.database.loadSchema();\n      // Lock the find/get, and let only owners read\n      await schema.updateClass('AnObject', {\n        owners: {\n          type: 'Array'\n        }\n      }, {\n        find: {},\n        get: {},\n        readUserFields: ['owners']\n      });\n      const q = new Parse.Query('AnObject');\n      try {\n        await q.get(object.id);\n        done.fail();\n      } catch (err) {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      }\n      try {\n        const objectAgain = await q.get(object.id, {\n          useMasterKey: true\n        });\n        expect(objectAgain).not.toBeUndefined();\n        expect(objectAgain.id).toBe(object.id);\n        done();\n      } catch (err) {\n        done.fail('master key should get the object');\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should let master key update objects","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1644,"updatePoint":{"line":1644,"column":44,"index":51987},"code":"    it('should let master key update objects', async done => {\n      const config = Config.get(Parse.applicationId);\n      const object = new Parse.Object('AnObject');\n      object.set('hello', 'world');\n      await object.save();\n      const schema = await config.database.loadSchema();\n      // Lock the update, and let only owners write\n      await schema.updateClass('AnObject', {\n        owners: {\n          type: 'Array'\n        }\n      }, {\n        update: {},\n        writeUserFields: ['owners']\n      });\n      try {\n        await object.save({\n          hello: 'bar'\n        });\n        done.fail();\n      } catch (err) {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      }\n      try {\n        const objectAgain = await object.save({\n          hello: 'baz'\n        }, {\n          useMasterKey: true\n        });\n        expect(objectAgain.get('hello')).toBe('baz');\n        done();\n      } catch (err) {\n        done.fail('master key should save the object');\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should let master key delete objects","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1679,"updatePoint":{"line":1679,"column":44,"index":52989},"code":"    it('should let master key delete objects', async done => {\n      const config = Config.get(Parse.applicationId);\n      const object = new Parse.Object('AnObject');\n      object.set('hello', 'world');\n      await object.save();\n      const schema = await config.database.loadSchema();\n      // Lock the delete, and let only owners write\n      await schema.updateClass('AnObject', {\n        owners: {\n          type: 'Array'\n        }\n      }, {\n        delete: {},\n        writeUserFields: ['owners']\n      });\n      try {\n        await object.destroy();\n        done.fail();\n      } catch (err) {\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      }\n      try {\n        await object.destroy({\n          useMasterKey: true\n        });\n        done();\n      } catch (err) {\n        done.fail('master key should destroy the object');\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should fail with invalid pointer perms (not array)","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1709,"updatePoint":{"line":1709,"column":58,"index":53870},"code":"    it('should fail with invalid pointer perms (not array)', async done => {\n      const config = Config.get(Parse.applicationId);\n      const schema = await config.database.loadSchema();\n      try {\n        // Lock the delete, and let only owners write\n        await schema.addClassIfNotExists('AnObject', {\n          owners: {\n            type: 'Array'\n          }\n        }, {\n          delete: {},\n          writeUserFields: 'owners'\n        });\n      } catch (err) {\n        expect(err.code).toBe(Parse.Error.INVALID_JSON);\n        done();\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should fail with invalid pointer perms (non-existing field)","suites":["Pointer Permissions","using arrays of user-pointers"],"line":1727,"updatePoint":{"line":1727,"column":67,"index":54440},"code":"    it('should fail with invalid pointer perms (non-existing field)', async done => {\n      const config = Config.get(Parse.applicationId);\n      const schema = await config.database.loadSchema();\n      try {\n        // Lock the delete, and let only owners write\n        await schema.addClassIfNotExists('AnObject', {\n          owners: {\n            type: 'Array'\n          }\n        }, {\n          delete: {},\n          writeUserFields: ['owners', 'invalid']\n        });\n      } catch (err) {\n        expect(err.code).toBe(Parse.Error.INVALID_JSON);\n        done();\n      }\n    });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed","suites":["Pointer Permissions","Granular ","on single-pointer fields","get action"],"line":1811,"updatePoint":{"line":1811,"column":29,"index":57238},"code":"        it('should be allowed', async done => {\n          await updateCLP({\n            get: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          const result = await actionGet(obj1.id);\n          expect(result).toBeDefined();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should fail for user not listed","suites":["Pointer Permissions","Granular ","on single-pointer fields","get action"],"line":1822,"updatePoint":{"line":1822,"column":43,"index":57565},"code":"        it('should fail for user not listed', async done => {\n          await updateCLP({\n            get: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user2);\n          await expectAsync(actionGet(obj1.id)).toBeRejectedWith(OBJECT_NOT_FOUND);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow other actions","suites":["Pointer Permissions","Granular ","on single-pointer fields","get action"],"line":1832,"updatePoint":{"line":1832,"column":42,"index":57884},"code":"        it('should not allow other actions', async done => {\n          await updateCLP({\n            get: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          await Promise.all([actionFind(), actionCount(), actionCreate(), actionUpdate(obj1), actionAddFieldOnCreate(), actionDelete(obj1)].map(async p => {\n            await expectAsync(p).toBeRejectedWith(PERMISSION_DENIED);\n          }));\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed","suites":["Pointer Permissions","Granular ","on single-pointer fields","find action"],"line":1846,"updatePoint":{"line":1846,"column":29,"index":58396},"code":"        it('should be allowed', async done => {\n          await updateCLP({\n            find: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionFind()).toBeResolved();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be limited to objects where user is listed in field","suites":["Pointer Permissions","Granular ","on single-pointer fields","find action"],"line":1856,"updatePoint":{"line":1856,"column":70,"index":58718},"code":"        it('should be limited to objects where user is listed in field', async done => {\n          await updateCLP({\n            find: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user2);\n          const results = await actionFind();\n          expect(results.length).toBe(1);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow other actions","suites":["Pointer Permissions","Granular ","on single-pointer fields","find action"],"line":1867,"updatePoint":{"line":1867,"column":42,"index":59042},"code":"        it('should not allow other actions', async done => {\n          await updateCLP({\n            find: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          await Promise.all([actionGet(obj1.id), actionCount(), actionCreate(), actionUpdate(obj1), actionAddFieldOnCreate(), actionDelete(obj1)].map(async p => {\n            await expectAsync(p).toBeRejectedWith(PERMISSION_DENIED);\n          }));\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed","suites":["Pointer Permissions","Granular ","on single-pointer fields","count action"],"line":1881,"updatePoint":{"line":1881,"column":29,"index":59562},"code":"        it('should be allowed', async done => {\n          await updateCLP({\n            count: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          const count = await actionCount();\n          expect(count).toBe(1);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be limited to objects where user is listed in field","suites":["Pointer Permissions","Granular ","on single-pointer fields","count action"],"line":1892,"updatePoint":{"line":1892,"column":70,"index":59905},"code":"        it('should be limited to objects where user is listed in field', async done => {\n          await updateCLP({\n            count: {\n              pointerFields: ['owner']\n            }\n          });\n          const user3 = await createUser('user3');\n          await logIn(user3);\n          const p = await actionCount();\n          expect(p).toBe(0);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow other actions","suites":["Pointer Permissions","Granular ","on single-pointer fields","count action"],"line":1904,"updatePoint":{"line":1904,"column":42,"index":60263},"code":"        it('should not allow other actions', async done => {\n          await updateCLP({\n            count: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          await Promise.all([actionGet(obj1.id), actionFind(), actionCreate(), actionUpdate(obj1), actionAddFieldOnCreate(), actionDelete(obj1)].map(async p => {\n            await expectAsync(p).toBeRejectedWith(PERMISSION_DENIED);\n          }));\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed","suites":["Pointer Permissions","Granular ","on single-pointer fields","update action"],"line":1918,"updatePoint":{"line":1918,"column":29,"index":60784},"code":"        it('should be allowed', async done => {\n          await updateCLP({\n            update: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionUpdate(obj1)).toBeResolved();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should fail for user not listed","suites":["Pointer Permissions","Granular ","on single-pointer fields","update action"],"line":1928,"updatePoint":{"line":1928,"column":43,"index":61087},"code":"        it('should fail for user not listed', async done => {\n          await updateCLP({\n            update: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user2);\n          await expectAsync(actionUpdate(obj1)).toBeRejectedWith(OBJECT_NOT_FOUND);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow other actions","suites":["Pointer Permissions","Granular ","on single-pointer fields","update action"],"line":1938,"updatePoint":{"line":1938,"column":42,"index":61409},"code":"        it('should not allow other actions', async done => {\n          await updateCLP({\n            update: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          await Promise.all([actionGet(obj1.id), actionFind(), actionCount(), actionCreate(), actionAddFieldOnCreate(), actionDelete(obj1)].map(async p => {\n            await expectAsync(p).toBeRejectedWith(PERMISSION_DENIED);\n          }));\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed","suites":["Pointer Permissions","Granular ","on single-pointer fields","delete action"],"line":1952,"updatePoint":{"line":1952,"column":29,"index":61926},"code":"        it('should be allowed', async done => {\n          await updateCLP({\n            delete: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionDelete(obj1)).toBeResolved();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should fail for user not listed","suites":["Pointer Permissions","Granular ","on single-pointer fields","delete action"],"line":1962,"updatePoint":{"line":1962,"column":43,"index":62229},"code":"        it('should fail for user not listed', async done => {\n          await updateCLP({\n            delete: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user2);\n          await expectAsync(actionDelete(obj1)).toBeRejectedWith(OBJECT_NOT_FOUND);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow other actions","suites":["Pointer Permissions","Granular ","on single-pointer fields","delete action"],"line":1972,"updatePoint":{"line":1972,"column":42,"index":62551},"code":"        it('should not allow other actions', async done => {\n          await updateCLP({\n            delete: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          await Promise.all([actionGet(obj1.id), actionFind(), actionCount(), actionCreate(), actionUpdate(obj1), actionAddFieldOnCreate()].map(async p => {\n            await expectAsync(p).toBeRejectedWith(PERMISSION_DENIED);\n          }));\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be denied (writelock) when no other permissions on class","suites":["Pointer Permissions","Granular ","on single-pointer fields","create action"],"line":1988,"updatePoint":{"line":1988,"column":75,"index":63261},"code":"        it('should be denied (writelock) when no other permissions on class', async done => {\n          await updateCLP({\n            create: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionCreate()).toBeRejectedWith(PERMISSION_DENIED);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should have no effect when creating object (and allowed by explicit userid permission)","suites":["Pointer Permissions","Granular ","on single-pointer fields","addField action"],"line":2000,"updatePoint":{"line":2000,"column":99,"index":63689},"skipped":true,"code":"        xit('should have no effect when creating object (and allowed by explicit userid permission)', async done => {\n          await updateCLP({\n            create: {\n              '*': true\n            },\n            addField: {\n              [user1.id]: true,\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionAddFieldOnCreate()).toBeResolved();\n          done();\n        });","file":"PointerPermissions.spec.js","dir":"spec"},{"name":"should be denied when creating object (and no explicit permission)","suites":["Pointer Permissions","Granular ","on single-pointer fields","addField action"],"line":2014,"updatePoint":{"line":2014,"column":79,"index":64129},"skipped":true,"code":"        xit('should be denied when creating object (and no explicit permission)', async done => {\n          await updateCLP({\n            create: {\n              '*': true\n            },\n            addField: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          const newObject = new Parse.Object(className, {\n            owner: user1,\n            extra: 'field'\n          });\n          await expectAsync(newObject.save()).toBeRejectedWith(PERMISSION_DENIED);\n          done();\n        });","file":"PointerPermissions.spec.js","dir":"spec"},{"name":"should be allowed when updating object","suites":["Pointer Permissions","Granular ","on single-pointer fields","addField action"],"line":2031,"updatePoint":{"line":2031,"column":50,"index":64646},"code":"        it('should be allowed when updating object', async done => {\n          await updateCLP({\n            update: {\n              '*': true\n            },\n            addField: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionAddFieldOnUpdate(obj1)).toBeResolved();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be denied when updating object for user without addField permission","suites":["Pointer Permissions","Granular ","on single-pointer fields","addField action"],"line":2044,"updatePoint":{"line":2044,"column":86,"index":65065},"code":"        it('should be denied when updating object for user without addField permission', async done => {\n          await updateCLP({\n            update: {\n              '*': true\n            },\n            addField: {\n              pointerFields: ['owner']\n            }\n          });\n          await logIn(user2);\n          await expectAsync(actionAddFieldOnUpdate(obj1)).toBeRejectedWith(OBJECT_NOT_FOUND);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed (1 user in array)","suites":["Pointer Permissions","Granular ","on array of pointers","get action"],"line":2136,"updatePoint":{"line":2136,"column":47,"index":67341},"code":"        it('should be allowed (1 user in array)', async done => {\n          await updateCLP({\n            get: {\n              pointerFields: ['owners']\n            }\n          });\n          await logIn(user1);\n          const result = await actionGet(obj1.id);\n          expect(result).toBeDefined();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed (multiple users in array)","suites":["Pointer Permissions","Granular ","on array of pointers","get action"],"line":2147,"updatePoint":{"line":2147,"column":55,"index":67681},"code":"        it('should be allowed (multiple users in array)', async done => {\n          await updateCLP({\n            get: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user2);\n          const result = await actionGet(obj1.id);\n          expect(result).toBeDefined();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should fail for user not listed","suites":["Pointer Permissions","Granular ","on array of pointers","get action"],"line":2158,"updatePoint":{"line":2158,"column":43,"index":68013},"code":"        it('should fail for user not listed', async done => {\n          await updateCLP({\n            get: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionGet(obj3.id)).toBeRejectedWith(OBJECT_NOT_FOUND);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow other actions","suites":["Pointer Permissions","Granular ","on array of pointers","get action"],"line":2168,"updatePoint":{"line":2168,"column":42,"index":68337},"code":"        it('should not allow other actions', async done => {\n          await updateCLP({\n            get: {\n              pointerFields: ['owners']\n            }\n          });\n          await logIn(user1);\n          await Promise.all([actionFind(), actionCount(), actionCreate(), actionUpdate(obj2), actionAddFieldOnCreate(), actionAddFieldOnUpdate(obj2), actionDelete(obj2)].map(async p => {\n            await expectAsync(p).toBeRejectedWith(PERMISSION_DENIED);\n          }));\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed (1 user in array)","suites":["Pointer Permissions","Granular ","on array of pointers","find action"],"line":2182,"updatePoint":{"line":2182,"column":47,"index":68898},"code":"        it('should be allowed (1 user in array)', async done => {\n          await updateCLP({\n            find: {\n              pointerFields: ['owners']\n            }\n          });\n          await logIn(user1);\n          const results = await actionFind();\n          expect(results.length).toBe(1);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed (multiple users in array)","suites":["Pointer Permissions","Granular ","on array of pointers","find action"],"line":2193,"updatePoint":{"line":2193,"column":55,"index":69236},"code":"        it('should be allowed (multiple users in array)', async done => {\n          await updateCLP({\n            find: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user2);\n          const results = await actionFind();\n          expect(results.length).toBe(2);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be limited to objects where user is listed in field","suites":["Pointer Permissions","Granular ","on array of pointers","find action"],"line":2204,"updatePoint":{"line":2204,"column":70,"index":69593},"code":"        it('should be limited to objects where user is listed in field', async done => {\n          await updateCLP({\n            find: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user1);\n          const results = await actionFind();\n          expect(results.length).toBe(1);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow other actions","suites":["Pointer Permissions","Granular ","on array of pointers","find action"],"line":2215,"updatePoint":{"line":2215,"column":42,"index":69922},"code":"        it('should not allow other actions', async done => {\n          await updateCLP({\n            find: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user1);\n          await Promise.all([actionGet(obj1.id), actionCount(), actionCreate(), actionUpdate(obj1), actionAddFieldOnCreate(), actionAddFieldOnUpdate(obj1), actionDelete(obj1)].map(async p => {\n            await expectAsync(p).toBeRejectedWith(PERMISSION_DENIED);\n          }));\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed","suites":["Pointer Permissions","Granular ","on array of pointers","count action"],"line":2236,"updatePoint":{"line":2236,"column":29,"index":70643},"code":"        it('should be allowed', async done => {\n          await logIn(user1);\n          const count = await actionCount();\n          expect(count).toBe(1);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be limited to objects where user is listed in field","suites":["Pointer Permissions","Granular ","on array of pointers","count action"],"line":2242,"updatePoint":{"line":2242,"column":70,"index":70870},"code":"        it('should be limited to objects where user is listed in field', async done => {\n          await logIn(user2);\n          const count = await actionCount();\n          expect(count).toBe(2);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow other actions","suites":["Pointer Permissions","Granular ","on array of pointers","count action"],"line":2248,"updatePoint":{"line":2248,"column":42,"index":71069},"code":"        it('should not allow other actions', async done => {\n          await logIn(user1);\n          await Promise.all([actionGet(obj1.id), actionFind(), actionCreate(), actionUpdate(obj1), actionAddFieldOnCreate(), actionAddFieldOnUpdate(obj1), actionDelete(obj1)].map(async p => {\n            await expectAsync(p).toBeRejectedWith(PERMISSION_DENIED);\n          }));\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed (1 user in array)","suites":["Pointer Permissions","Granular ","on array of pointers","update action"],"line":2257,"updatePoint":{"line":2257,"column":47,"index":71522},"code":"        it('should be allowed (1 user in array)', async done => {\n          await updateCLP({\n            update: {\n              pointerFields: ['owners']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionUpdate(obj1)).toBeResolved();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed (multiple users in array)","suites":["Pointer Permissions","Granular ","on array of pointers","update action"],"line":2267,"updatePoint":{"line":2267,"column":55,"index":71838},"code":"        it('should be allowed (multiple users in array)', async done => {\n          await updateCLP({\n            update: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user2);\n          await expectAsync(actionUpdate(obj1)).toBeResolved();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should fail for user not listed","suites":["Pointer Permissions","Granular ","on array of pointers","update action"],"line":2277,"updatePoint":{"line":2277,"column":43,"index":72146},"code":"        it('should fail for user not listed', async done => {\n          await updateCLP({\n            update: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user2);\n          await expectAsync(actionUpdate(obj3)).toBeRejectedWith(OBJECT_NOT_FOUND);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow other actions","suites":["Pointer Permissions","Granular ","on array of pointers","update action"],"line":2287,"updatePoint":{"line":2287,"column":42,"index":72473},"code":"        it('should not allow other actions', async done => {\n          await updateCLP({\n            update: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user1);\n          await Promise.all([actionGet(obj1.id), actionFind(), actionCount(), actionCreate(), actionAddFieldOnCreate(), actionAddFieldOnUpdate(obj1), actionDelete(obj1)].map(async p => {\n            await expectAsync(p).toBeRejectedWith(PERMISSION_DENIED);\n          }));\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed (1 user in array)","suites":["Pointer Permissions","Granular ","on array of pointers","delete action"],"line":2301,"updatePoint":{"line":2301,"column":47,"index":73043},"code":"        it('should be allowed (1 user in array)', async done => {\n          await updateCLP({\n            delete: {\n              pointerFields: ['owners']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionDelete(obj1)).toBeResolved();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed (multiple users in array)","suites":["Pointer Permissions","Granular ","on array of pointers","delete action"],"line":2311,"updatePoint":{"line":2311,"column":55,"index":73359},"code":"        it('should be allowed (multiple users in array)', async done => {\n          await updateCLP({\n            delete: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user3);\n          await expectAsync(actionDelete(obj2)).toBeResolved();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should fail for user not listed","suites":["Pointer Permissions","Granular ","on array of pointers","delete action"],"line":2321,"updatePoint":{"line":2321,"column":43,"index":73667},"code":"        it('should fail for user not listed', async done => {\n          await updateCLP({\n            delete: {\n              pointerFields: ['owners']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionDelete(obj3)).toBeRejectedWith(OBJECT_NOT_FOUND);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow other actions","suites":["Pointer Permissions","Granular ","on array of pointers","delete action"],"line":2331,"updatePoint":{"line":2331,"column":42,"index":73990},"code":"        it('should not allow other actions', async done => {\n          await updateCLP({\n            delete: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user1);\n          await Promise.all([actionGet(obj1.id), actionFind(), actionCount(), actionCreate(), actionUpdate(obj1), actionAddFieldOnCreate(), actionAddFieldOnUpdate(obj1)].map(async p => {\n            await expectAsync(p).toBeRejectedWith(PERMISSION_DENIED);\n          }));\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be denied (writelock) when no other permissions on class","suites":["Pointer Permissions","Granular ","on array of pointers","create action"],"line":2347,"updatePoint":{"line":2347,"column":75,"index":74738},"code":"        it('should be denied (writelock) when no other permissions on class', async done => {\n          await updateCLP({\n            create: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionCreate()).toBeRejectedWith(PERMISSION_DENIED);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should have no effect on create (allowed by explicit userid)","suites":["Pointer Permissions","Granular ","on array of pointers","addField action"],"line":2359,"updatePoint":{"line":2359,"column":72,"index":75144},"code":"        it('should have no effect on create (allowed by explicit userid)', async done => {\n          await updateCLP({\n            create: {\n              '*': true\n            },\n            addField: {\n              [user1.id]: true,\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionAddFieldOnCreate()).toBeResolved();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be denied when creating object (and no explicit permission)","suites":["Pointer Permissions","Granular ","on array of pointers","addField action"],"line":2373,"updatePoint":{"line":2373,"column":78,"index":75588},"code":"        it('should be denied when creating object (and no explicit permission)', async done => {\n          await updateCLP({\n            create: {\n              '*': true\n            },\n            addField: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user1);\n          const newObject = new Parse.Object(className, {\n            moderators: user1,\n            extra: 'field'\n          });\n          await expectAsync(newObject.save()).toBeRejectedWith(PERMISSION_DENIED);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be allowed when updating object","suites":["Pointer Permissions","Granular ","on array of pointers","addField action"],"line":2390,"updatePoint":{"line":2390,"column":50,"index":76115},"code":"        it('should be allowed when updating object', async done => {\n          await updateCLP({\n            update: {\n              '*': true\n            },\n            addField: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user2);\n          await expectAsync(actionAddFieldOnUpdate(obj1)).toBeResolved();\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be restricted when updating object without addField permission","suites":["Pointer Permissions","Granular ","on array of pointers","addField action"],"line":2403,"updatePoint":{"line":2403,"column":81,"index":76534},"code":"        it('should be restricted when updating object without addField permission', async done => {\n          await updateCLP({\n            update: {\n              '*': true\n            },\n            addField: {\n              pointerFields: ['moderators']\n            }\n          });\n          await logIn(user1);\n          await expectAsync(actionAddFieldOnUpdate(obj2)).toBeRejectedWith(OBJECT_NOT_FOUND);\n          done();\n        });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not limit the scope of grouped read permissions","suites":["Pointer Permissions","Granular ","combined with grouped"],"line":2465,"updatePoint":{"line":2465,"column":64,"index":78116},"code":"      it('should not limit the scope of grouped read permissions', async done => {\n        await updateCLP({\n          get: {\n            pointerFields: ['owner']\n          },\n          readUserFields: ['moderators']\n        });\n        await logIn(user2);\n        await expectAsync(actionGet(obj1.id)).toBeResolved();\n        const found = await actionFind();\n        expect(found.length).toBe(2);\n        const counted = await actionCount();\n        expect(counted).toBe(2);\n        done();\n      });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not limit the scope of grouped write permissions","suites":["Pointer Permissions","Granular ","combined with grouped"],"line":2480,"updatePoint":{"line":2480,"column":65,"index":78620},"code":"      it('should not limit the scope of grouped write permissions', async done => {\n        await updateCLP({\n          update: {\n            pointerFields: ['owner']\n          },\n          writeUserFields: ['moderators']\n        });\n        await logIn(user2);\n        await expectAsync(actionUpdate(obj1)).toBeResolved();\n        await expectAsync(actionAddFieldOnUpdate(obj1)).toBeResolved();\n        await expectAsync(actionDelete(obj1)).toBeResolved();\n        // [create] and [addField on create] can't be enabled with pointer by design\n\n        done();\n      });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not inherit scope of grouped read permissions from another field","suites":["Pointer Permissions","Granular ","combined with grouped"],"line":2495,"updatePoint":{"line":2495,"column":81,"index":79206},"code":"      it('should not inherit scope of grouped read permissions from another field', async done => {\n        await updateCLP({\n          get: {\n            pointerFields: ['owner']\n          },\n          readUserFields: ['moderators']\n        });\n        await logIn(user1);\n        const found = await actionFind();\n        expect(found.length).toBe(1);\n        const counted = await actionCount();\n        expect(counted).toBe(1);\n        done();\n      });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should not inherit scope of grouped write permissions from another field","suites":["Pointer Permissions","Granular ","combined with grouped"],"line":2509,"updatePoint":{"line":2509,"column":82,"index":79665},"code":"      it('should not inherit scope of grouped write permissions from another field', async done => {\n        await updateCLP({\n          update: {\n            pointerFields: ['moderators']\n          },\n          writeUserFields: ['owner']\n        });\n        await logIn(user1);\n        await expectAsync(actionDelete(obj2)).toBeRejectedWith(OBJECT_NOT_FOUND);\n        done();\n      });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"should be enforced regardless of pointer-field being included in keys (select)","suites":["Pointer Permissions","Granular ","using pointer-fields and queries with keys projection"],"line":2549,"updatePoint":{"line":2549,"column":88,"index":80846},"code":"      it('should be enforced regardless of pointer-field being included in keys (select)', async done => {\n        await updateCLP({\n          get: {\n            '*': true\n          },\n          find: {\n            pointerFields: ['owner']\n          },\n          update: {\n            pointerFields: ['owner']\n          }\n        });\n        const query = new Parse.Query('AnObject');\n        query.select('field', 'test');\n        const [object] = await query.find({\n          objectId: obj.id\n        });\n        expect(object.get('field')).toBe('field');\n        expect(object.get('test')).toBe('test');\n        done();\n      });","file":"PointerPermissions.spec.js","skipped":false,"dir":"spec"},{"name":"creates a map from a query string","suites":["PostgresConfigParser.parseQueryParams"],"line":19,"updatePoint":{"line":19,"column":39,"index":417},"code":"  it('creates a map from a query string', () => {\n    for (const key in queryParamTests) {\n      const result = parser.parseQueryParams(key);\n      const testObj = queryParamTests[key];\n      expect(Object.keys(result).length).toEqual(Object.keys(testObj).length);\n      for (const k in result) {\n        expect(result[k]).toEqual(testObj[k]);\n      }\n    }\n  });","file":"PostgresConfigParser.spec.js","skipped":false,"dir":"spec"},{"name":"creates a db options map from a query string","suites":["PostgresConfigParser.getDatabaseOptionsFromURI"],"line":75,"updatePoint":{"line":75,"column":50,"index":2147},"code":"  it('creates a db options map from a query string', () => {\n    for (const key in dbOptionsTest) {\n      const result = parser.getDatabaseOptionsFromURI(key);\n      const testObj = dbOptionsTest[key];\n      for (const k in testObj) {\n        expect(result[k]).toEqual(testObj[k]);\n      }\n    }\n  });","file":"PostgresConfigParser.spec.js","skipped":false,"dir":"spec"},{"name":"sets the poolSize to 10 if the it is not a number","suites":["PostgresConfigParser.getDatabaseOptionsFromURI"],"line":84,"updatePoint":{"line":84,"column":55,"index":2454},"code":"  it('sets the poolSize to 10 if the it is not a number', () => {\n    const result = parser.getDatabaseOptionsFromURI(`${baseURI}?poolSize=sdf`);\n    expect(result.poolSize).toEqual(10);\n  });","file":"PostgresConfigParser.spec.js","skipped":false,"dir":"spec"},{"name":"should create server with public schema databaseOptions","suites":[],"line":22,"updatePoint":{"line":22,"column":61,"index":684},"code":"  it('should create server with public schema databaseOptions', async () => {\n    const adapter = new PostgresStorageAdapter({\n      uri: postgresURI,\n      collectionPrefix: 'test_',\n      databaseOptions: databaseOptions1\n    });\n    await reconfigureServer({\n      databaseAdapter: adapter\n    });\n    const score = new GameScore({\n      score: 1337,\n      playerName: 'Sean Plott',\n      cheatMode: false\n    });\n    await score.save();\n  });","file":"PostgresInitOptions.spec.js","skipped":false,"dir":"spec"},{"name":"should create server using postgresql uri with public schema databaseOptions","suites":[],"line":38,"updatePoint":{"line":38,"column":82,"index":1152},"code":"  it('should create server using postgresql uri with public schema databaseOptions', async () => {\n    const postgresURI2 = new URL(postgresURI);\n    postgresURI2.protocol = 'postgresql:';\n    const adapter = new PostgresStorageAdapter({\n      uri: postgresURI2.toString(),\n      collectionPrefix: 'test_',\n      databaseOptions: databaseOptions1\n    });\n    await reconfigureServer({\n      databaseAdapter: adapter\n    });\n    const score = new GameScore({\n      score: 1337,\n      playerName: 'Sean Plott',\n      cheatMode: false\n    });\n    await score.save();\n  });","file":"PostgresInitOptions.spec.js","skipped":false,"dir":"spec"},{"name":"should fail to create server if schema databaseOptions does not exist","suites":[],"line":56,"updatePoint":{"line":56,"column":75,"index":1715},"code":"  it('should fail to create server if schema databaseOptions does not exist', async () => {\n    const adapter = new PostgresStorageAdapter({\n      uri: postgresURI,\n      collectionPrefix: 'test_',\n      databaseOptions: databaseOptions2\n    });\n    try {\n      await reconfigureServer({\n        databaseAdapter: adapter\n      });\n      fail('Should have thrown error');\n    } catch (error) {\n      expect(error).toBeDefined();\n    }\n  });","file":"PostgresInitOptions.spec.js","skipped":false,"dir":"spec"},{"name":"schemaUpgrade, upgrade the database schema when schema changes","suites":[],"line":20,"updatePoint":{"line":20,"column":68,"index":871},"code":"  it('schemaUpgrade, upgrade the database schema when schema changes', async done => {\n    await adapter.deleteAllClasses();\n    const config = Config.get('test');\n    config.schemaCache.clear();\n    await adapter.performInitialization({\n      VolatileClassesSchemas: []\n    });\n    const client = adapter._client;\n    const className = '_PushStatus';\n    const schema = {\n      fields: {\n        pushTime: {\n          type: 'String'\n        },\n        source: {\n          type: 'String'\n        },\n        query: {\n          type: 'String'\n        }\n      }\n    };\n    adapter.createTable(className, schema).then(() => getColumns(client, className)).then(columns => {\n      expect(columns).toContain('pushTime');\n      expect(columns).toContain('source');\n      expect(columns).toContain('query');\n      expect(columns).not.toContain('expiration_interval');\n      schema.fields.expiration_interval = {\n        type: 'Number'\n      };\n      return adapter.schemaUpgrade(className, schema);\n    }).then(() => getColumns(client, className)).then(async columns => {\n      expect(columns).toContain('pushTime');\n      expect(columns).toContain('source');\n      expect(columns).toContain('query');\n      expect(columns).toContain('expiration_interval');\n      await reconfigureServer();\n      done();\n    }).catch(error => done.fail(error));\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"schemaUpgrade, maintain correct schema","suites":[],"line":60,"updatePoint":{"line":60,"column":44,"index":2190},"code":"  it('schemaUpgrade, maintain correct schema', done => {\n    const client = adapter._client;\n    const className = 'Table';\n    const schema = {\n      fields: {\n        columnA: {\n          type: 'String'\n        },\n        columnB: {\n          type: 'String'\n        },\n        columnC: {\n          type: 'String'\n        }\n      }\n    };\n    adapter.createTable(className, schema).then(() => getColumns(client, className)).then(columns => {\n      expect(columns).toContain('columnA');\n      expect(columns).toContain('columnB');\n      expect(columns).toContain('columnC');\n      return adapter.schemaUpgrade(className, schema);\n    }).then(() => getColumns(client, className)).then(columns => {\n      expect(columns.length).toEqual(3);\n      expect(columns).toContain('columnA');\n      expect(columns).toContain('columnB');\n      expect(columns).toContain('columnC');\n      done();\n    }).catch(error => done.fail(error));\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"Create a table without columns and upgrade with columns","suites":[],"line":89,"updatePoint":{"line":89,"column":61,"index":3138},"code":"  it('Create a table without columns and upgrade with columns', done => {\n    const client = adapter._client;\n    const className = 'EmptyTable';\n    dropTable(client, className).then(() => adapter.createTable(className, {})).then(() => getColumns(client, className)).then(columns => {\n      expect(columns.length).toBe(0);\n      const newSchema = {\n        fields: {\n          columnA: {\n            type: 'String'\n          },\n          columnB: {\n            type: 'String'\n          }\n        }\n      };\n      return adapter.schemaUpgrade(className, newSchema);\n    }).then(() => getColumns(client, className)).then(columns => {\n      expect(columns.length).toEqual(2);\n      expect(columns).toContain('columnA');\n      expect(columns).toContain('columnB');\n      done();\n    }).catch(done);\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"getClass if exists","suites":[],"line":112,"updatePoint":{"line":112,"column":24,"index":3903},"code":"  it('getClass if exists', async () => {\n    const schema = {\n      fields: {\n        array: {\n          type: 'Array'\n        },\n        object: {\n          type: 'Object'\n        },\n        date: {\n          type: 'Date'\n        }\n      }\n    };\n    await adapter.createClass('MyClass', schema);\n    const myClassSchema = await adapter.getClass('MyClass');\n    expect(myClassSchema).toBeDefined();\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"getClass if not exists","suites":[],"line":130,"updatePoint":{"line":130,"column":28,"index":4313},"code":"  it('getClass if not exists', async () => {\n    const schema = {\n      fields: {\n        array: {\n          type: 'Array'\n        },\n        object: {\n          type: 'Object'\n        },\n        date: {\n          type: 'Date'\n        }\n      }\n    };\n    await adapter.createClass('MyClass', schema);\n    await expectAsync(adapter.getClass('UnknownClass')).toBeRejectedWith(undefined);\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"$relativeTime should error on $eq","suites":[],"line":147,"updatePoint":{"line":147,"column":39,"index":4717},"code":"  it('$relativeTime should error on $eq', async () => {\n    const tableName = '_User';\n    const schema = {\n      fields: {\n        objectId: {\n          type: 'String'\n        },\n        username: {\n          type: 'String'\n        },\n        email: {\n          type: 'String'\n        },\n        emailVerified: {\n          type: 'Boolean'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        authData: {\n          type: 'Object'\n        }\n      }\n    };\n    const client = adapter._client;\n    await adapter.createTable(tableName, schema);\n    await client.none('INSERT INTO $1:name ($2:name, $3:name) VALUES ($4, $5)', [tableName, 'objectId', 'username', 'Bugs', 'Bunny']);\n    const database = Config.get(Parse.applicationId).database;\n    await database.loadSchema({\n      clearCache: true\n    });\n    try {\n      await database.find(tableName, {\n        createdAt: {\n          $eq: {\n            $relativeTime: '12 days ago'\n          }\n        }\n      }, {});\n      fail('Should have thrown error');\n    } catch (error) {\n      expect(error.code).toBe(Parse.Error.INVALID_JSON);\n    }\n    await dropTable(client, tableName);\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"$relativeTime should error on $ne","suites":[],"line":195,"updatePoint":{"line":195,"column":39,"index":5930},"code":"  it('$relativeTime should error on $ne', async () => {\n    const tableName = '_User';\n    const schema = {\n      fields: {\n        objectId: {\n          type: 'String'\n        },\n        username: {\n          type: 'String'\n        },\n        email: {\n          type: 'String'\n        },\n        emailVerified: {\n          type: 'Boolean'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        authData: {\n          type: 'Object'\n        }\n      }\n    };\n    const client = adapter._client;\n    await adapter.createTable(tableName, schema);\n    await client.none('INSERT INTO $1:name ($2:name, $3:name) VALUES ($4, $5)', [tableName, 'objectId', 'username', 'Bugs', 'Bunny']);\n    const database = Config.get(Parse.applicationId).database;\n    await database.loadSchema({\n      clearCache: true\n    });\n    try {\n      await database.find(tableName, {\n        createdAt: {\n          $ne: {\n            $relativeTime: '12 days ago'\n          }\n        }\n      }, {});\n      fail('Should have thrown error');\n    } catch (error) {\n      expect(error.code).toBe(Parse.Error.INVALID_JSON);\n    }\n    await dropTable(client, tableName);\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"$relativeTime should error on $exists","suites":[],"line":243,"updatePoint":{"line":243,"column":43,"index":7147},"code":"  it('$relativeTime should error on $exists', async () => {\n    const tableName = '_User';\n    const schema = {\n      fields: {\n        objectId: {\n          type: 'String'\n        },\n        username: {\n          type: 'String'\n        },\n        email: {\n          type: 'String'\n        },\n        emailVerified: {\n          type: 'Boolean'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        authData: {\n          type: 'Object'\n        }\n      }\n    };\n    const client = adapter._client;\n    await adapter.createTable(tableName, schema);\n    await client.none('INSERT INTO $1:name ($2:name, $3:name) VALUES ($4, $5)', [tableName, 'objectId', 'username', 'Bugs', 'Bunny']);\n    const database = Config.get(Parse.applicationId).database;\n    await database.loadSchema({\n      clearCache: true\n    });\n    try {\n      await database.find(tableName, {\n        createdAt: {\n          $exists: {\n            $relativeTime: '12 days ago'\n          }\n        }\n      }, {});\n      fail('Should have thrown error');\n    } catch (error) {\n      expect(error.code).toBe(Parse.Error.INVALID_JSON);\n    }\n    await dropTable(client, tableName);\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should use index for caseInsensitive query using Postgres","suites":[],"line":291,"updatePoint":{"line":291,"column":63,"index":8388},"code":"  it('should use index for caseInsensitive query using Postgres', async () => {\n    const tableName = '_User';\n    const schema = {\n      fields: {\n        objectId: {\n          type: 'String'\n        },\n        username: {\n          type: 'String'\n        },\n        email: {\n          type: 'String'\n        },\n        emailVerified: {\n          type: 'Boolean'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        authData: {\n          type: 'Object'\n        }\n      }\n    };\n    const client = adapter._client;\n    await adapter.createTable(tableName, schema);\n    await client.none('INSERT INTO $1:name ($2:name, $3:name) VALUES ($4, $5)', [tableName, 'objectId', 'username', 'Bugs', 'Bunny']);\n    //Postgres won't take advantage of the index until it has a lot of records because sequential is faster for small db's\n    await client.none('INSERT INTO $1:name ($2:name, $3:name) SELECT gen_random_uuid(), gen_random_uuid() FROM generate_series(1,5000)', [tableName, 'objectId', 'username']);\n    const caseInsensitiveData = 'bugs';\n    const originalQuery = 'SELECT * FROM $1:name WHERE lower($2:name)=lower($3)';\n    const analyzedExplainQuery = adapter.createExplainableQuery(originalQuery, true);\n    const preIndexPlan = await client.one(analyzedExplainQuery, [tableName, 'objectId', caseInsensitiveData]);\n    preIndexPlan['QUERY PLAN'].forEach(element => {\n      //Make sure search returned with only 1 result\n      expect(element.Plan['Actual Rows']).toBe(1);\n      expect(element.Plan['Node Type']).toBe('Seq Scan');\n    });\n    const indexName = 'test_case_insensitive_column';\n    await adapter.ensureIndex(tableName, schema, ['objectId'], indexName, true);\n    const postIndexPlan = await client.one(analyzedExplainQuery, [tableName, 'objectId', caseInsensitiveData]);\n    postIndexPlan['QUERY PLAN'].forEach(element => {\n      //Make sure search returned with only 1 result\n      expect(element.Plan['Actual Rows']).toBe(1);\n      //Should not be a sequential scan\n      expect(element.Plan['Node Type']).not.toContain('Seq Scan');\n\n      //Should be using the index created for this\n      element.Plan.Plans.forEach(innerElement => {\n        expect(innerElement['Index Name']).toBe(indexName);\n      });\n    });\n\n    //These are the same query so should be the same size\n    for (let i = 0; i < preIndexPlan['QUERY PLAN'].length; i++) {\n      //Sequential should take more time to execute than indexed\n      expect(preIndexPlan['QUERY PLAN'][i]['Execution Time']).toBeGreaterThan(postIndexPlan['QUERY PLAN'][i]['Execution Time']);\n    }\n    //Test explaining without analyzing\n    const basicExplainQuery = adapter.createExplainableQuery(originalQuery);\n    const explained = await client.one(basicExplainQuery, [tableName, 'objectId', caseInsensitiveData]);\n    explained['QUERY PLAN'].forEach(element => {\n      //Check that basic query plans isn't a sequential scan\n      expect(element.Plan['Node Type']).not.toContain('Seq Scan');\n\n      //Basic query plans shouldn't have an execution time\n      expect(element['Execution Time']).toBeUndefined();\n    });\n    await dropTable(client, tableName);\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should use index for caseInsensitive query","suites":[],"line":364,"updatePoint":{"line":364,"column":48,"index":11575},"code":"  it('should use index for caseInsensitive query', async () => {\n    await adapter.deleteAllClasses();\n    const config = Config.get('test');\n    config.schemaCache.clear();\n    await adapter.performInitialization({\n      VolatileClassesSchemas: []\n    });\n    const database = Config.get(Parse.applicationId).database;\n    await database.loadSchema({\n      clearCache: true\n    });\n    const tableName = '_User';\n    const user = new Parse.User();\n    user.set('username', 'Elmer');\n    user.set('password', 'Fudd');\n    await user.signUp();\n\n    //Postgres won't take advantage of the index until it has a lot of records because sequential is faster for small db's\n    const client = adapter._client;\n    await client.none('INSERT INTO $1:name ($2:name, $3:name) SELECT gen_random_uuid(), gen_random_uuid() FROM generate_series(1,5000)', [tableName, 'objectId', 'username']);\n    const caseInsensitiveData = 'elmer';\n    const fieldToSearch = 'username';\n    //Check using find method for Parse\n    const preIndexPlan = await database.find(tableName, {\n      username: caseInsensitiveData\n    }, {\n      caseInsensitive: true,\n      explain: true\n    });\n    preIndexPlan.forEach(element => {\n      element['QUERY PLAN'].forEach(innerElement => {\n        //Check that basic query plans isn't a sequential scan, be careful as find uses \"any\" to query\n        expect(innerElement.Plan['Node Type']).toBe('Seq Scan');\n        //Basic query plans shouldn't have an execution time\n        expect(innerElement['Execution Time']).toBeUndefined();\n      });\n    });\n    const indexName = 'test_case_insensitive_column';\n    const schema = await new Parse.Schema('_User').get();\n    await adapter.ensureIndex(tableName, schema, [fieldToSearch], indexName, true);\n\n    //Check using find method for Parse\n    const postIndexPlan = await database.find(tableName, {\n      username: caseInsensitiveData\n    }, {\n      caseInsensitive: true,\n      explain: true\n    });\n    postIndexPlan.forEach(element => {\n      element['QUERY PLAN'].forEach(innerElement => {\n        //Check that basic query plans isn't a sequential scan\n        expect(innerElement.Plan['Node Type']).not.toContain('Seq Scan');\n\n        //Basic query plans shouldn't have an execution time\n        expect(innerElement['Execution Time']).toBeUndefined();\n      });\n    });\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should use index for caseInsensitive query using default indexname","suites":[],"line":422,"updatePoint":{"line":422,"column":72,"index":13937},"code":"  it('should use index for caseInsensitive query using default indexname', async () => {\n    await adapter.deleteAllClasses();\n    const config = Config.get('test');\n    config.schemaCache.clear();\n    await adapter.performInitialization({\n      VolatileClassesSchemas: []\n    });\n    const database = Config.get(Parse.applicationId).database;\n    await database.loadSchema({\n      clearCache: true\n    });\n    const tableName = '_User';\n    const user = new Parse.User();\n    user.set('username', 'Tweety');\n    user.set('password', 'Bird');\n    await user.signUp();\n    const fieldToSearch = 'username';\n    //Create index before data is inserted\n    const schema = await new Parse.Schema('_User').get();\n    await adapter.ensureIndex(tableName, schema, [fieldToSearch], null, true);\n\n    //Postgres won't take advantage of the index until it has a lot of records because sequential is faster for small db's\n    const client = adapter._client;\n    await client.none('INSERT INTO $1:name ($2:name, $3:name) SELECT gen_random_uuid(), gen_random_uuid() FROM generate_series(1,5000)', [tableName, 'objectId', 'username']);\n    const caseInsensitiveData = 'tweeTy';\n    //Check using find method for Parse\n    const indexPlan = await database.find(tableName, {\n      username: caseInsensitiveData\n    }, {\n      caseInsensitive: true,\n      explain: true\n    });\n    indexPlan.forEach(element => {\n      element['QUERY PLAN'].forEach(innerElement => {\n        expect(innerElement.Plan['Node Type']).not.toContain('Seq Scan');\n        expect(innerElement.Plan['Index Name']).toContain('parse_default');\n      });\n    });\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should allow multiple unique indexes for same field name and different class","suites":[],"line":461,"updatePoint":{"line":461,"column":82,"index":15570},"code":"  it('should allow multiple unique indexes for same field name and different class', async () => {\n    const firstTableName = 'Test1';\n    const firstTableSchema = new Parse.Schema(firstTableName);\n    const uniqueField = 'uuid';\n    firstTableSchema.addString(uniqueField);\n    await firstTableSchema.save();\n    await firstTableSchema.get();\n    const secondTableName = 'Test2';\n    const secondTableSchema = new Parse.Schema(secondTableName);\n    secondTableSchema.addString(uniqueField);\n    await secondTableSchema.save();\n    await secondTableSchema.get();\n    const database = Config.get(Parse.applicationId).database;\n\n    //Create index before data is inserted\n    await adapter.ensureUniqueness(firstTableName, firstTableSchema, [uniqueField]);\n    await adapter.ensureUniqueness(secondTableName, secondTableSchema, [uniqueField]);\n\n    //Postgres won't take advantage of the index until it has a lot of records because sequential is faster for small db's\n    const client = adapter._client;\n    await client.none('INSERT INTO $1:name ($2:name, $3:name) SELECT gen_random_uuid(), gen_random_uuid() FROM generate_series(1,5000)', [firstTableName, 'objectId', uniqueField]);\n    await client.none('INSERT INTO $1:name ($2:name, $3:name) SELECT gen_random_uuid(), gen_random_uuid() FROM generate_series(1,5000)', [secondTableName, 'objectId', uniqueField]);\n\n    //Check using find method for Parse\n    const indexPlan = await database.find(firstTableName, {\n      uuid: '1234'\n    }, {\n      caseInsensitive: false,\n      explain: true\n    });\n    indexPlan.forEach(element => {\n      element['QUERY PLAN'].forEach(innerElement => {\n        expect(innerElement.Plan['Node Type']).not.toContain('Seq Scan');\n        expect(innerElement.Plan['Index Name']).toContain(uniqueField);\n      });\n    });\n    const indexPlan2 = await database.find(secondTableName, {\n      uuid: '1234'\n    }, {\n      caseInsensitive: false,\n      explain: true\n    });\n    indexPlan2.forEach(element => {\n      element['QUERY PLAN'].forEach(innerElement => {\n        expect(innerElement.Plan['Node Type']).not.toContain('Seq Scan');\n        expect(innerElement.Plan['Index Name']).toContain(uniqueField);\n      });\n    });\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should watch _SCHEMA changes","suites":[],"line":510,"updatePoint":{"line":510,"column":34,"index":17735},"code":"  it('should watch _SCHEMA changes', async () => {\n    const enableSchemaHooks = true;\n    await reconfigureServer({\n      databaseAdapter: undefined,\n      databaseURI,\n      collectionPrefix: '',\n      databaseOptions: {\n        enableSchemaHooks\n      }\n    });\n    const {\n      database\n    } = Config.get(Parse.applicationId);\n    const {\n      adapter\n    } = database;\n    expect(adapter.enableSchemaHooks).toBe(enableSchemaHooks);\n    spyOn(adapter, '_onchange');\n    enableSchemaHooks;\n    const otherInstance = new PostgresStorageAdapter({\n      uri: databaseURI,\n      collectionPrefix: '',\n      databaseOptions: {\n        enableSchemaHooks\n      }\n    });\n    expect(otherInstance.enableSchemaHooks).toBe(enableSchemaHooks);\n    otherInstance._listenToSchema();\n    await otherInstance.createClass('Stuff', {\n      className: 'Stuff',\n      fields: {\n        objectId: {\n          type: 'String'\n        },\n        createdAt: {\n          type: 'Date'\n        },\n        updatedAt: {\n          type: 'Date'\n        },\n        _rperm: {\n          type: 'Array'\n        },\n        _wperm: {\n          type: 'Array'\n        }\n      },\n      classLevelPermissions: undefined\n    });\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    expect(adapter._onchange).toHaveBeenCalled();\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"Idempotency class should have function","suites":[],"line":562,"updatePoint":{"line":562,"column":44,"index":19054},"code":"  it('Idempotency class should have function', async () => {\n    await reconfigureServer();\n    const adapter = Config.get('test').database.adapter;\n    const client = adapter._client;\n    const qs = \"SELECT format('%I.%I(%s)', ns.nspname, p.proname, oidvectortypes(p.proargtypes)) FROM pg_proc p INNER JOIN pg_namespace ns ON (p.pronamespace = ns.oid) WHERE p.proname = 'idempotency_delete_expired_records'\";\n    const foundFunction = await client.one(qs);\n    expect(foundFunction.format).toBe('public.idempotency_delete_expired_records()');\n    await adapter.deleteIdempotencyFunction();\n    await client.none(qs);\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"handleShutdown, close connection","suites":[],"line":574,"updatePoint":{"line":574,"column":38,"index":19748},"code":"  it('handleShutdown, close connection', () => {\n    const adapter = new PostgresStorageAdapter({\n      uri: databaseURI\n    });\n    expect(adapter._client.$pool.ending).toEqual(false);\n    adapter.handleShutdown();\n    expect(adapter._client.$pool.ending).toEqual(true);\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"handleShutdown, close connection of postgresql uri","suites":[],"line":582,"updatePoint":{"line":582,"column":56,"index":20044},"code":"  it('handleShutdown, close connection of postgresql uri', () => {\n    const databaseURI2 = new URL(databaseURI);\n    databaseURI2.protocol = 'postgresql:';\n    const adapter = new PostgresStorageAdapter({\n      uri: databaseURI2.toString()\n    });\n    expect(adapter._client.$pool.ending).toEqual(false);\n    adapter.handleShutdown();\n    expect(adapter._client.$pool.ending).toEqual(true);\n  });","file":"PostgresStorageAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should properly handle rejects","suites":["PromiseRouter"],"line":3,"updatePoint":{"line":3,"column":36,"index":134},"code":"  it('should properly handle rejects', done => {\n    const router = new PromiseRouter();\n    router.route('GET', '/dummy', () => {\n      return Promise.reject({\n        error: 'an error',\n        code: -1\n      });\n    }, () => {\n      fail('this should not be called');\n    });\n    router.routes[0].handler({}).then(result => {\n      jfail(result);\n      fail('this should not be called');\n      done();\n    }, error => {\n      expect(error.error).toEqual('an error');\n      expect(error.code).toEqual(-1);\n      done();\n    });\n  });","file":"PromiseRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should handle and empty protectedFields","suites":["ProtectedFields"],"line":12,"updatePoint":{"line":12,"column":45,"index":309},"code":"  it('should handle and empty protectedFields', async function () {\n    const protectedFields = {};\n    await reconfigureServer({\n      protectedFields\n    });\n    const user = new Parse.User();\n    user.setUsername('Alice');\n    user.setPassword('sekrit');\n    user.set('email', 'alice@aol.com');\n    user.set('favoriteColor', 'yellow');\n    await user.save();\n    const fetched = await new Parse.Query(Parse.User).get(user.id);\n    expect(fetched.has('email')).toBeFalsy();\n    expect(fetched.has('favoriteColor')).toBeTruthy();\n  });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should fall back on sensitive fields if protected fields are not configured","suites":["ProtectedFields","interaction with legacy userSensitiveFields"],"line":28,"updatePoint":{"line":28,"column":83,"index":956},"code":"    it('should fall back on sensitive fields if protected fields are not configured', async function () {\n      const userSensitiveFields = ['phoneNumber', 'timeZone'];\n      const protectedFields = {\n        _User: {\n          '*': ['email']\n        }\n      };\n      await reconfigureServer({\n        userSensitiveFields,\n        protectedFields\n      });\n      const user = new Parse.User();\n      user.setUsername('Alice');\n      user.setPassword('sekrit');\n      user.set('email', 'alice@aol.com');\n      user.set('phoneNumber', 8675309);\n      user.set('timeZone', 'America/Los_Angeles');\n      user.set('favoriteColor', 'yellow');\n      user.set('favoriteFood', 'pizza');\n      await user.save();\n      const fetched = await new Parse.Query(Parse.User).get(user.id);\n      expect(fetched.has('email')).toBeFalsy();\n      expect(fetched.has('phoneNumber')).toBeFalsy();\n      expect(fetched.has('favoriteColor')).toBeTruthy();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should merge protected and sensitive for extra safety","suites":["ProtectedFields","interaction with legacy userSensitiveFields"],"line":53,"updatePoint":{"line":53,"column":61,"index":1874},"code":"    it('should merge protected and sensitive for extra safety', async function () {\n      const userSensitiveFields = ['phoneNumber', 'timeZone'];\n      const protectedFields = {\n        _User: {\n          '*': ['email', 'favoriteFood']\n        }\n      };\n      await reconfigureServer({\n        userSensitiveFields,\n        protectedFields\n      });\n      const user = new Parse.User();\n      user.setUsername('Alice');\n      user.setPassword('sekrit');\n      user.set('email', 'alice@aol.com');\n      user.set('phoneNumber', 8675309);\n      user.set('timeZone', 'America/Los_Angeles');\n      user.set('favoriteColor', 'yellow');\n      user.set('favoriteFood', 'pizza');\n      await user.save();\n      const fetched = await new Parse.Query(Parse.User).get(user.id);\n      expect(fetched.has('email')).toBeFalsy();\n      expect(fetched.has('phoneNumber')).toBeFalsy();\n      expect(fetched.has('favoriteFood')).toBeFalsy();\n      expect(fetched.has('favoriteColor')).toBeTruthy();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should hide fields in a non user class","suites":["ProtectedFields","non user class"],"line":81,"updatePoint":{"line":81,"column":46,"index":2897},"code":"    it('should hide fields in a non user class', async function () {\n      const protectedFields = {\n        ClassA: {\n          '*': ['foo']\n        },\n        ClassB: {\n          '*': ['bar']\n        }\n      };\n      await reconfigureServer({\n        protectedFields\n      });\n      const objA = await new Parse.Object('ClassA').set('foo', 'zzz').set('bar', 'yyy').save();\n      const objB = await new Parse.Object('ClassB').set('foo', 'zzz').set('bar', 'yyy').save();\n      const [fetchedA, fetchedB] = await Promise.all([new Parse.Query('ClassA').get(objA.id), new Parse.Query('ClassB').get(objB.id)]);\n      expect(fetchedA.has('foo')).toBeFalsy();\n      expect(fetchedA.has('bar')).toBeTruthy();\n      expect(fetchedB.has('foo')).toBeTruthy();\n      expect(fetchedB.has('bar')).toBeFalsy();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should hide fields in non user class and non standard user field at same time","suites":["ProtectedFields","non user class"],"line":101,"updatePoint":{"line":101,"column":85,"index":3741},"code":"    it('should hide fields in non user class and non standard user field at same time', async function () {\n      const protectedFields = {\n        _User: {\n          '*': ['phoneNumber']\n        },\n        ClassA: {\n          '*': ['foo']\n        },\n        ClassB: {\n          '*': ['bar']\n        }\n      };\n      await reconfigureServer({\n        protectedFields\n      });\n      const user = new Parse.User();\n      user.setUsername('Alice');\n      user.setPassword('sekrit');\n      user.set('email', 'alice@aol.com');\n      user.set('phoneNumber', 8675309);\n      user.set('timeZone', 'America/Los_Angeles');\n      user.set('favoriteColor', 'yellow');\n      user.set('favoriteFood', 'pizza');\n      await user.save();\n      const objA = await new Parse.Object('ClassA').set('foo', 'zzz').set('bar', 'yyy').save();\n      const objB = await new Parse.Object('ClassB').set('foo', 'zzz').set('bar', 'yyy').save();\n      const [fetchedUser, fetchedA, fetchedB] = await Promise.all([new Parse.Query(Parse.User).get(user.id), new Parse.Query('ClassA').get(objA.id), new Parse.Query('ClassB').get(objB.id)]);\n      expect(fetchedA.has('foo')).toBeFalsy();\n      expect(fetchedA.has('bar')).toBeTruthy();\n      expect(fetchedB.has('foo')).toBeTruthy();\n      expect(fetchedB.has('bar')).toBeFalsy();\n      expect(fetchedUser.has('email')).toBeFalsy();\n      expect(fetchedUser.has('phoneNumber')).toBeFalsy();\n      expect(fetchedUser.has('favoriteColor')).toBeTruthy();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should allow access using single user pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and get/fetch"],"line":146,"updatePoint":{"line":146,"column":67,"index":5572},"code":"      it('should allow access using single user pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        obj.set('owner', user1);\n        obj.set('test', 'test');\n        await obj.save();\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owner'],\n            'userField:owner': []\n          }\n        });\n        await Parse.User.logIn('user1', 'password');\n        const objectAgain = await obj.fetch();\n        expect(objectAgain.get('owner').id).toBe(user1.id);\n        expect(objectAgain.get('test')).toBe('test');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should deny access to other users using single user pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and get/fetch"],"line":171,"updatePoint":{"line":171,"column":81,"index":6440},"code":"      it('should deny access to other users using single user pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        obj.set('owner', user1);\n        obj.set('test', 'test');\n        await obj.save();\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owner'],\n            'userField:owner': []\n          }\n        });\n        await Parse.User.logIn('user2', 'password');\n        const objectAgain = await obj.fetch();\n        expect(objectAgain.get('owner')).toBe(undefined);\n        expect(objectAgain.get('test')).toBe('test');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should deny access to public using single user pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and get/fetch"],"line":196,"updatePoint":{"line":196,"column":76,"index":7301},"code":"      it('should deny access to public using single user pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        obj.set('owner', user1);\n        obj.set('test', 'test');\n        await obj.save();\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owner'],\n            'userField:owner': []\n          }\n        });\n        const objectAgain = await obj.fetch();\n        expect(objectAgain.get('owner')).toBe(undefined);\n        expect(objectAgain.get('test')).toBe('test');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should allow access using user array pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and get/fetch"],"line":220,"updatePoint":{"line":220,"column":66,"index":8099},"code":"      it('should allow access using user array pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        obj.set('owners', [user1, user2]);\n        obj.set('test', 'test');\n        await obj.save();\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owners'],\n            'userField:owners': []\n          }\n        });\n        await Parse.User.logIn('user1', 'password');\n        let objectAgain = await obj.fetch();\n        expect(objectAgain.get('owners')[0].id).toBe(user1.id);\n        expect(objectAgain.get('test')).toBe('test');\n        await Parse.User.logIn('user2', 'password');\n        objectAgain = await obj.fetch();\n        expect(objectAgain.get('owners')[1].id).toBe(user2.id);\n        expect(objectAgain.get('test')).toBe('test');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should deny access to other users using user array pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and get/fetch"],"line":249,"updatePoint":{"line":249,"column":80,"index":9192},"code":"      it('should deny access to other users using user array pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        obj.set('owners', [user1]);\n        obj.set('test', 'test');\n        await obj.save();\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owners'],\n            'userField:owners': []\n          }\n        });\n        await Parse.User.logIn('user2', 'password');\n        const objectAgain = await obj.fetch();\n        expect(objectAgain.get('owners')).toBe(undefined);\n        expect(objectAgain.get('test')).toBe('test');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should deny access to public using user array pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and get/fetch"],"line":274,"updatePoint":{"line":274,"column":75,"index":10058},"code":"      it('should deny access to public using user array pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        obj.set('owners', [user1, user2]);\n        obj.set('test', 'test');\n        await obj.save();\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owners'],\n            'userField:owners': []\n          }\n        });\n        const objectAgain = await obj.fetch();\n        expect(objectAgain.get('owners')).toBe(undefined);\n        expect(objectAgain.get('test')).toBe('test');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should intersect protected fields when using multiple pointer-permission fields","suites":["ProtectedFields","using the pointer-permission variant","and get/fetch"],"line":298,"updatePoint":{"line":298,"column":89,"index":10892},"code":"      it('should intersect protected fields when using multiple pointer-permission fields', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        obj.set('owners', [user1]);\n        obj.set('owner', user1);\n        obj.set('test', 'test');\n        await obj.save();\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owners', 'owner', 'test'],\n            'userField:owners': ['owners', 'owner'],\n            'userField:owner': ['owner']\n          }\n        });\n\n        // Check if protectFields from pointer-permissions got combined\n        await Parse.User.logIn('user1', 'password');\n        const objectAgain = await obj.fetch();\n        expect(objectAgain.get('owners').length).toBe(1);\n        expect(objectAgain.get('owner')).toBe(undefined);\n        expect(objectAgain.get('test')).toBe('test');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should ignore pointer-permission fields not present in object","suites":["ProtectedFields","using the pointer-permission variant","and get/fetch"],"line":328,"updatePoint":{"line":328,"column":71,"index":11993},"code":"      it('should ignore pointer-permission fields not present in object', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        obj.set('owners', [user1]);\n        obj.set('owner', user1);\n        obj.set('test', 'test');\n        await obj.save();\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': [],\n            'userField:idontexist': ['owner'],\n            'userField:idontexist2': ['owners']\n          }\n        });\n        await Parse.User.logIn('user1', 'password');\n        const objectAgain = await obj.fetch();\n        expect(objectAgain.get('owners')).not.toBe(undefined);\n        expect(objectAgain.get('owner')).not.toBe(undefined);\n        expect(objectAgain.get('test')).toBe('test');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should allow access using single user pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and find"],"line":358,"updatePoint":{"line":358,"column":67,"index":13043},"code":"      it('should allow access using single user pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        const obj2 = new Parse.Object('AnObject');\n        obj.set('owner', user1);\n        obj.set('test', 'test');\n        obj2.set('owner', user1);\n        obj2.set('test', 'test2');\n        await Parse.Object.saveAll([obj, obj2]);\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owner'],\n            'userField:owner': []\n          }\n        });\n        await Parse.User.logIn('user1', 'password');\n        const q = new Parse.Query('AnObject');\n        const results = await q.find();\n        // sort for checking in correct order\n        results.sort((a, b) => a.get('test').localeCompare(b.get('test')));\n        expect(results.length).toBe(2);\n        expect(results[0].get('owner').id).toBe(user1.id);\n        expect(results[0].get('test')).toBe('test');\n        expect(results[1].get('owner').id).toBe(user1.id);\n        expect(results[1].get('test')).toBe('test2');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should deny access to other users using single user pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and find"],"line":392,"updatePoint":{"line":392,"column":81,"index":14367},"code":"      it('should deny access to other users using single user pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        const obj2 = new Parse.Object('AnObject');\n        obj.set('owner', user1);\n        obj.set('test', 'test');\n        obj2.set('owner', user1);\n        obj2.set('test', 'test2');\n        await Parse.Object.saveAll([obj, obj2]);\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owner'],\n            'userField:owner': []\n          }\n        });\n        await Parse.User.logIn('user2', 'password');\n        const q = new Parse.Query('AnObject');\n        const results = await q.find();\n        // sort for checking in correct order\n        results.sort((a, b) => a.get('test').localeCompare(b.get('test')));\n        expect(results.length).toBe(2);\n        expect(results[0].get('owner')).toBe(undefined);\n        expect(results[0].get('test')).toBe('test');\n        expect(results[1].get('owner')).toBe(undefined);\n        expect(results[1].get('test')).toBe('test2');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should deny access to public using single user pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and find"],"line":426,"updatePoint":{"line":426,"column":76,"index":15682},"code":"      it('should deny access to public using single user pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        const obj2 = new Parse.Object('AnObject');\n        obj.set('owner', user1);\n        obj.set('test', 'test');\n        obj2.set('owner', user1);\n        obj2.set('test', 'test2');\n        await Parse.Object.saveAll([obj, obj2]);\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owner'],\n            'userField:owner': []\n          }\n        });\n        const q = new Parse.Query('AnObject');\n        const results = await q.find();\n        // sort for checking in correct order\n        results.sort((a, b) => a.get('test').localeCompare(b.get('test')));\n        expect(results.length).toBe(2);\n        expect(results[0].get('owner')).toBe(undefined);\n        expect(results[0].get('test')).toBe('test');\n        expect(results[1].get('owner')).toBe(undefined);\n        expect(results[1].get('test')).toBe('test2');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should allow access using user array pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and find"],"line":459,"updatePoint":{"line":459,"column":66,"index":16934},"code":"      it('should allow access using user array pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        const obj2 = new Parse.Object('AnObject');\n        obj.set('owners', [user1, user2]);\n        obj.set('test', 'test');\n        obj2.set('owners', [user1, user2]);\n        obj2.set('test', 'test2');\n        await Parse.Object.saveAll([obj, obj2]);\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owners'],\n            'userField:owners': []\n          }\n        });\n        const q = new Parse.Query('AnObject');\n        let results;\n        await Parse.User.logIn('user1', 'password');\n        results = await q.find();\n        // sort for checking in correct order\n        results.sort((a, b) => a.get('test').localeCompare(b.get('test')));\n        expect(results.length).toBe(2);\n        expect(results[0].get('owners')[0].id).toBe(user1.id);\n        expect(results[0].get('test')).toBe('test');\n        expect(results[1].get('owners')[0].id).toBe(user1.id);\n        expect(results[1].get('test')).toBe('test2');\n        await Parse.User.logIn('user2', 'password');\n        results = await q.find();\n        // sort for checking in correct order\n        results.sort((a, b) => a.get('test').localeCompare(b.get('test')));\n        expect(results.length).toBe(2);\n        expect(results[0].get('owners')[1].id).toBe(user2.id);\n        expect(results[0].get('test')).toBe('test');\n        expect(results[1].get('owners')[1].id).toBe(user2.id);\n        expect(results[1].get('test')).toBe('test2');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should deny access to other users using user array pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and find"],"line":503,"updatePoint":{"line":503,"column":80,"index":18784},"code":"      it('should deny access to other users using user array pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        const obj2 = new Parse.Object('AnObject');\n        obj.set('owners', [user1]);\n        obj.set('test', 'test');\n        obj2.set('owners', [user1]);\n        obj2.set('test', 'test2');\n        await Parse.Object.saveAll([obj, obj2]);\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owners'],\n            'userField:owners': []\n          }\n        });\n        await Parse.User.logIn('user2', 'password');\n        const q = new Parse.Query('AnObject');\n        const results = await q.find();\n        // sort for checking in correct order\n        results.sort((a, b) => a.get('test').localeCompare(b.get('test')));\n        expect(results.length).toBe(2);\n        expect(results[0].get('owners')).toBe(undefined);\n        expect(results[0].get('test')).toBe('test');\n        expect(results[1].get('owners')).toBe(undefined);\n        expect(results[1].get('test')).toBe('test2');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should deny access to public using user array pointer-permissions","suites":["ProtectedFields","using the pointer-permission variant","and find"],"line":537,"updatePoint":{"line":537,"column":75,"index":20108},"code":"      it('should deny access to public using user array pointer-permissions', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        const obj2 = new Parse.Object('AnObject');\n        obj.set('owners', [user1, user2]);\n        obj.set('test', 'test');\n        obj2.set('owners', [user1, user2]);\n        obj2.set('test', 'test2');\n        await Parse.Object.saveAll([obj, obj2]);\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owners'],\n            'userField:owners': []\n          }\n        });\n        const q = new Parse.Query('AnObject');\n        const results = await q.find();\n        // sort for checking in correct order\n        results.sort((a, b) => a.get('test').localeCompare(b.get('test')));\n        expect(results.length).toBe(2);\n        expect(results[0].get('owners')).toBe(undefined);\n        expect(results[0].get('test')).toBe('test');\n        expect(results[1].get('owners')).toBe(undefined);\n        expect(results[1].get('test')).toBe('test2');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should intersect protected fields when using multiple pointer-permission fields","suites":["ProtectedFields","using the pointer-permission variant","and find"],"line":570,"updatePoint":{"line":570,"column":89,"index":21407},"code":"      it('should intersect protected fields when using multiple pointer-permission fields', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        const obj2 = new Parse.Object('AnObject');\n        obj.set('owners', [user1]);\n        obj.set('owner', user1);\n        obj.set('test', 'test');\n        obj2.set('owners', [user1]);\n        obj2.set('test', 'test2');\n        await Parse.Object.saveAll([obj, obj2]);\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owners', 'owner', 'test'],\n            'userField:owners': ['owners', 'owner'],\n            'userField:owner': ['owner']\n          }\n        });\n\n        // Check if protectFields from pointer-permissions got combined\n        await Parse.User.logIn('user1', 'password');\n        const q = new Parse.Query('AnObject');\n        const results = await q.find();\n        // sort for checking in correct order\n        results.sort((a, b) => a.get('test').localeCompare(b.get('test')));\n        expect(results.length).toBe(2);\n        expect(results[0].get('owners').length).toBe(1);\n        expect(results[0].get('owner')).toBe(undefined);\n        expect(results[0].get('test')).toBe('test');\n        expect(results[1].get('owners')).toBe(undefined);\n        expect(results[1].get('owner')).toBe(undefined);\n        expect(results[1].get('test')).toBe('test2');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should ignore pointer-permission fields not present in object","suites":["ProtectedFields","using the pointer-permission variant","and find"],"line":610,"updatePoint":{"line":610,"column":71,"index":23022},"code":"      it('should ignore pointer-permission fields not present in object', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        const obj2 = new Parse.Object('AnObject');\n        obj.set('owners', [user1]);\n        obj.set('owner', user1);\n        obj.set('test', 'test');\n        obj2.set('owners', [user1]);\n        obj2.set('owner', user1);\n        obj2.set('test', 'test2');\n        await Parse.Object.saveAll([obj, obj2]);\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': [],\n            'userField:idontexist': ['owner'],\n            'userField:idontexist2': ['owners']\n          }\n        });\n        await Parse.User.logIn('user1', 'password');\n        const q = new Parse.Query('AnObject');\n        const results = await q.find();\n        // sort for checking in correct order\n        results.sort((a, b) => a.get('test').localeCompare(b.get('test')));\n        expect(results.length).toBe(2);\n        expect(results[0].get('owners')).not.toBe(undefined);\n        expect(results[0].get('owner')).not.toBe(undefined);\n        expect(results[0].get('test')).toBe('test');\n        expect(results[1].get('owners')).not.toBe(undefined);\n        expect(results[1].get('owner')).not.toBe(undefined);\n        expect(results[1].get('test')).toBe('test2');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should filter only fields from objects not owned by the user","suites":["ProtectedFields","using the pointer-permission variant","and find"],"line":649,"updatePoint":{"line":649,"column":70,"index":24590},"code":"      it('should filter only fields from objects not owned by the user', async done => {\n        const config = Config.get(Parse.applicationId);\n        const obj = new Parse.Object('AnObject');\n        const obj2 = new Parse.Object('AnObject');\n        const obj3 = new Parse.Object('AnObject');\n        obj.set('owner', user1);\n        obj.set('test', 'test');\n        obj2.set('owner', user2);\n        obj2.set('test', 'test2');\n        obj3.set('owner', user2);\n        obj3.set('test', 'test3');\n        await Parse.Object.saveAll([obj, obj2, obj3]);\n        const schema = await config.database.loadSchema();\n        await schema.updateClass('AnObject', {}, {\n          get: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          protectedFields: {\n            '*': ['owner'],\n            'userField:owner': []\n          }\n        });\n        const q = new Parse.Query('AnObject');\n        let results;\n        await Parse.User.logIn('user1', 'password');\n        results = await q.find();\n        // sort for checking in correct order\n        results.sort((a, b) => a.get('test').localeCompare(b.get('test')));\n        expect(results.length).toBe(3);\n        expect(results[0].get('owner')).not.toBe(undefined);\n        expect(results[0].get('test')).toBe('test');\n        expect(results[1].get('owner')).toBe(undefined);\n        expect(results[1].get('test')).toBe('test2');\n        expect(results[2].get('owner')).toBe(undefined);\n        expect(results[2].get('test')).toBe('test3');\n        await Parse.User.logIn('user2', 'password');\n        results = await q.find();\n        // sort for checking in correct order\n        results.sort((a, b) => a.get('test').localeCompare(b.get('test')));\n        expect(results.length).toBe(3);\n        expect(results[0].get('owner')).toBe(undefined);\n        expect(results[0].get('test')).toBe('test');\n        expect(results[1].get('owner')).not.toBe(undefined);\n        expect(results[1].get('test')).toBe('test2');\n        expect(results[2].get('owner')).not.toBe(undefined);\n        expect(results[2].get('test')).toBe('test3');\n        done();\n      });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should fail setting non-existing protected field","suites":["ProtectedFields","schema setup"],"line":716,"updatePoint":{"line":716,"column":56,"index":27143},"code":"    it('should fail setting non-existing protected field', async done => {\n      const field = 'non-existing';\n      const entity = '*';\n      await expectAsync(updateCLP({\n        protectedFields: {\n          [entity]: [field]\n        }\n      })).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_JSON, `Field '${field}' in protectedFields:${entity} does not exist`));\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should allow setting authenticated","suites":["ProtectedFields","schema setup"],"line":726,"updatePoint":{"line":726,"column":42,"index":27524},"code":"    it('should allow setting authenticated', async () => {\n      await expectAsync(updateCLP({\n        protectedFields: {\n          authenticated: ['test']\n        }\n      })).toBeResolved();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should not allow protecting default fields","suites":["ProtectedFields","schema setup"],"line":733,"updatePoint":{"line":733,"column":50,"index":27732},"code":"    it('should not allow protecting default fields', async () => {\n      const defaultFields = ['objectId', 'createdAt', 'updatedAt', 'ACL'];\n      for (const field of defaultFields) {\n        await expectAsync(updateCLP({\n          protectedFields: {\n            '*': [field]\n          }\n        })).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_JSON, `Default field '${field}' can not be protected`));\n      }\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should hide field","suites":["ProtectedFields","targeting public access"],"line":759,"updatePoint":{"line":759,"column":25,"index":28567},"code":"    it('should hide field', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          '*': ['foo']\n        }\n      });\n\n      // unauthenticated\n      const object = await obj1.fetch();\n      expect(object.get('foo')).toBe(undefined);\n      expect(object.get('bar')).toBeDefined();\n      expect(object.get('qux')).toBeDefined();\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should hide mutiple fields","suites":["ProtectedFields","targeting public access"],"line":779,"updatePoint":{"line":779,"column":34,"index":29039},"code":"    it('should hide mutiple fields', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          '*': ['foo', 'bar']\n        }\n      });\n\n      // unauthenticated\n      const object = await obj1.fetch();\n      expect(object.get('foo')).toBe(undefined);\n      expect(object.get('bar')).toBe(undefined);\n      expect(object.get('qux')).toBeDefined();\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should not hide any fields when set as empty array","suites":["ProtectedFields","targeting public access"],"line":799,"updatePoint":{"line":799,"column":58,"index":29544},"code":"    it('should not hide any fields when set as empty array', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          '*': []\n        }\n      });\n\n      // unauthenticated\n      const object = await obj1.fetch();\n      expect(object.get('foo')).toBeDefined();\n      expect(object.get('bar')).toBeDefined();\n      expect(object.get('qux')).toBeDefined();\n      expect(object.id).toBeDefined();\n      expect(object.createdAt).toBeDefined();\n      expect(object.updatedAt).toBeDefined();\n      expect(object.getACL()).toBeDefined();\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should not hide any fields when set as empty array","suites":["ProtectedFields","targeting authenticated"],"line":871,"updatePoint":{"line":871,"column":58,"index":31341},"code":"    it('should not hide any fields when set as empty array', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          authenticated: []\n        }\n      });\n\n      // authenticated\n      await logIn(user1);\n      const object = await obj1.fetch();\n      expect(object.get('owner')).toBeDefined();\n      expect(object.get('testers')).toBeDefined();\n      expect(object.get('test')).toBeDefined();\n      expect(object.id).toBeDefined();\n      expect(object.createdAt).toBeDefined();\n      expect(object.updatedAt).toBeDefined();\n      expect(object.getACL()).toBeDefined();\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should hide fields for authenticated users only (* not set)","suites":["ProtectedFields","targeting authenticated"],"line":896,"updatePoint":{"line":896,"column":67,"index":32056},"code":"    it('should hide fields for authenticated users only (* not set)', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          authenticated: ['test']\n        }\n      });\n\n      // not authenticated\n      const objectNonAuth = await obj1.fetch();\n      expect(objectNonAuth.get('test')).toBeDefined();\n\n      // authenticated\n      await logIn(user1);\n      const object = await obj1.fetch();\n      expect(object.get('test')).toBe(undefined);\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should intersect public and auth for authenticated user","suites":["ProtectedFields","targeting authenticated"],"line":919,"updatePoint":{"line":919,"column":63,"index":32630},"code":"    it('should intersect public and auth for authenticated user', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          '*': ['owner', 'testers'],\n          authenticated: ['testers']\n        }\n      });\n\n      // authenticated\n      await logIn(user1);\n      const objectAuth = await obj1.fetch();\n\n      // ( {A,B} intersect {B} ) == {B}\n\n      expect(objectAuth.get('testers')).not.toBeDefined('Should not be visible - protected for * and authenticated');\n      expect(objectAuth.get('test')).toBeDefined('Should be visible - not protected for everyone (* and authenticated)');\n      expect(objectAuth.get('owner')).toBeDefined('Should be visible - not protected for authenticated');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should have higher prio than public for logged in users (intersect)","suites":["ProtectedFields","targeting authenticated"],"line":944,"updatePoint":{"line":944,"column":75,"index":33467},"code":"    it('should have higher prio than public for logged in users (intersect)', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          '*': ['test'],\n          authenticated: []\n        }\n      });\n      // authenticated, permitted\n      await logIn(user1);\n      const object = await obj1.fetch();\n      expect(object.get('test')).toBe('test');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should have no effect on unauthenticated users (public not set)","suites":["ProtectedFields","targeting authenticated"],"line":963,"updatePoint":{"line":963,"column":71,"index":33944},"code":"    it('should have no effect on unauthenticated users (public not set)', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          authenticated: ['test']\n        }\n      });\n\n      // unauthenticated, protected\n      const objectNonAuth = await obj1.fetch();\n      expect(objectNonAuth.get('test')).toBe('test');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should protect multiple fields for authenticated users","suites":["ProtectedFields","targeting authenticated"],"line":981,"updatePoint":{"line":981,"column":62,"index":34384},"code":"    it('should protect multiple fields for authenticated users', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          authenticated: ['test', 'owner']\n        }\n      });\n\n      // authenticated\n      await logIn(user1);\n      const object = await obj1.fetch();\n      expect(object.get('test')).toBe(undefined);\n      expect(object.get('owner')).toBe(undefined);\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should not be affected by rules not applicable to user (smoke)","suites":["ProtectedFields","targeting authenticated"],"line":1001,"updatePoint":{"line":1001,"column":70,"index":34894},"code":"    it('should not be affected by rules not applicable to user (smoke)', async done => {\n      const role = await createRole({\n        users: user1\n      });\n      const roleName = role.get('name');\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          authenticated: ['owner', 'testers'],\n          [`role:${roleName}`]: ['test'],\n          'userField:owner': [],\n          [user1.id]: []\n        }\n      });\n\n      // authenticated, non-owner, no role\n      await logIn(user2);\n      const objectNotOwned = await obj1.fetch();\n      expect(objectNotOwned.get('owner')).toBe(undefined);\n      expect(objectNotOwned.get('testers')).toBe(undefined);\n      expect(objectNotOwned.get('test')).toBeDefined();\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should hide field when user belongs to a role","suites":["ProtectedFields","targeting roles"],"line":1064,"updatePoint":{"line":1064,"column":53,"index":36571},"code":"    it('should hide field when user belongs to a role', async done => {\n      const role = await createRole({\n        users: user1\n      });\n      const roleName = role.get('name');\n      await updateCLP({\n        protectedFields: {\n          [`role:${roleName}`]: ['test']\n        },\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        }\n      });\n\n      // user has role\n      await logIn(user1);\n      const object = await obj1.fetch();\n      expect(object.get('test')).toBe(undefined); //  field protected\n      expect(object.get('owner')).toBeDefined();\n      expect(object.get('testers')).toBeDefined();\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should not hide any fields when set as empty array","suites":["ProtectedFields","targeting roles"],"line":1089,"updatePoint":{"line":1089,"column":58,"index":37246},"code":"    it('should not hide any fields when set as empty array', async done => {\n      const role = await createRole({\n        users: user1\n      });\n      const roleName = role.get('name');\n      await updateCLP({\n        protectedFields: {\n          [`role:${roleName}`]: []\n        },\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        }\n      });\n\n      // user has role\n      await logIn(user1);\n      const object = await obj1.fetch();\n      expect(object.get('owner')).toBeDefined();\n      expect(object.get('testers')).toBeDefined();\n      expect(object.get('test')).toBeDefined();\n      expect(object.id).toBeDefined();\n      expect(object.createdAt).toBeDefined();\n      expect(object.updatedAt).toBeDefined();\n      expect(object.getACL()).toBeDefined();\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should hide multiple fields when user belongs to a role","suites":["ProtectedFields","targeting roles"],"line":1118,"updatePoint":{"line":1118,"column":63,"index":38074},"code":"    it('should hide multiple fields when user belongs to a role', async done => {\n      const role = await createRole({\n        users: user1\n      });\n      const roleName = role.get('name');\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          [`role:${roleName}`]: ['test', 'owner']\n        }\n      });\n\n      // user has role\n      await logIn(user1);\n      const object = await obj1.fetch();\n      expect(object.get('test')).toBe(undefined, 'Field should not be visible - protected by role');\n      expect(object.get('owner')).toBe(undefined, 'Field should not be visible - protected by role');\n      expect(object.get('testers')).toBeDefined();\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should not protect when user does not belong to a role","suites":["ProtectedFields","targeting roles"],"line":1143,"updatePoint":{"line":1143,"column":62,"index":38846},"code":"    it('should not protect when user does not belong to a role', async done => {\n      const role = await createRole({\n        users: user1\n      });\n      const roleName = role.get('name');\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          [`role:${roleName}`]: ['test', 'owner']\n        }\n      });\n\n      // user doesn't have role\n      await logIn(user2);\n      const object = await obj1.fetch();\n      expect(object.get('test')).toBeDefined();\n      expect(object.get('owner')).toBeDefined();\n      expect(object.get('testers')).toBeDefined();\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should intersect protected fields when user belongs to multiple roles","suites":["ProtectedFields","targeting roles"],"line":1168,"updatePoint":{"line":1168,"column":77,"index":39536},"code":"    it('should intersect protected fields when user belongs to multiple roles', async done => {\n      const role1 = await createRole({\n        users: user1\n      });\n      const role2 = await createRole({\n        users: user1\n      });\n      const role1name = role1.get('name');\n      const role2name = role2.get('name');\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          [`role:${role1name}`]: ['owner'],\n          [`role:${role2name}`]: ['test', 'owner']\n        }\n      });\n\n      // user has both roles\n      await logIn(user1);\n      const object = await obj1.fetch();\n\n      // \"owner\" is a result of intersection\n      expect(object.get('owner')).toBe(undefined, 'Must not be visible - protected for all roles the user belongs to');\n      expect(object.get('test')).toBeDefined('Has to be visible - is not protected for users with role1');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should intersect protected fields when user belongs to multiple roles hierarchy","suites":["ProtectedFields","targeting roles"],"line":1199,"updatePoint":{"line":1199,"column":87,"index":40519},"code":"    it('should intersect protected fields when user belongs to multiple roles hierarchy', async done => {\n      const admin = await createRole({\n        users: user1,\n        roleName: 'admin'\n      });\n      const moder = await createRole({\n        users: [user1, user2],\n        roleName: 'moder'\n      });\n      const tester = await createRole({\n        roleName: 'tester'\n      });\n\n      // admin supersets moder role\n      moder.relation('roles').add(admin);\n      await moder.save(null, {\n        useMasterKey: true\n      });\n      tester.relation('roles').add(moder);\n      await tester.save(null, {\n        useMasterKey: true\n      });\n      const roleAdmin = `role:${admin.get('name')}`;\n      const roleModer = `role:${moder.get('name')}`;\n      const roleTester = `role:${tester.get('name')}`;\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          [roleAdmin]: [],\n          [roleModer]: ['owner'],\n          [roleTester]: ['test', 'owner']\n        }\n      });\n\n      // user1 has admin & moder & tester roles, (moder includes tester).\n      await logIn(user1);\n      const object = await obj1.fetch();\n\n      // being admin makes all fields visible\n      expect(object.get('test')).toBeDefined('Should be visible - admin role explicitly removes protection for all fields ( [] )');\n      expect(object.get('owner')).toBeDefined('Should be visible - admin role explicitly removes protection for all fields ( [] )');\n\n      // user2 has moder & tester role, moder includes tester.\n      await logIn(user2);\n      const objectAgain = await obj1.fetch();\n\n      // being moder allows \"test\" field\n      expect(objectAgain.get('owner')).toBe(undefined, '\"owner\" should not be visible - protected for each role user belongs to');\n      expect(objectAgain.get('test')).toBeDefined('Should be visible - moder role does not protect \"test\" field');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to clear protected fields for role (protected for authenticated)","suites":["ProtectedFields","targeting roles"],"line":1255,"updatePoint":{"line":1255,"column":87,"index":42492},"code":"    it('should be able to clear protected fields for role (protected for authenticated)', async done => {\n      const role = await createRole({\n        users: user1\n      });\n      const roleName = role.get('name');\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          authenticated: ['test'],\n          [`role:${roleName}`]: []\n        }\n      });\n\n      // user has role, test field visible\n      await logIn(user1);\n      const object = await obj1.fetch();\n      expect(object.get('test')).toBe('test');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should determine protectedFields as intersection of field sets for public and role","suites":["ProtectedFields","targeting roles"],"line":1279,"updatePoint":{"line":1279,"column":90,"index":43125},"code":"    it('should determine protectedFields as intersection of field sets for public and role', async done => {\n      const role = await createRole({\n        users: user1\n      });\n      const roleName = role.get('name');\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          '*': ['test', 'owner'],\n          [`role:${roleName}`]: ['owner', 'testers']\n        }\n      });\n\n      // user has role\n      await logIn(user1);\n      const object = await obj1.fetch();\n      expect(object.get('test')).toBeDefined('Should be visible - \"test\" is not protected for role user belongs to');\n      expect(object.get('testers')).toBeDefined('Should be visible - \"testers\" is allowed for everyone (*)');\n      expect(object.get('owner')).toBe(undefined, 'Should not be visible - \"test\" is not allowed for both public(*) and role');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should be determined as an intersection of protecedFields for authenticated and role","suites":["ProtectedFields","targeting roles"],"line":1305,"updatePoint":{"line":1305,"column":92,"index":44066},"code":"    it('should be determined as an intersection of protecedFields for authenticated and role', async done => {\n      const role = await createRole({\n        users: user1\n      });\n      const roleName = role.get('name');\n\n      // this is an example of misunderstood configuration.\n      // If you allow (== do not restrict) some field for broader audience\n      // (having a role implies user inheres to 'authenticated' group)\n      // it's not possible to narrow by protecting field for a role.\n      // You'd have to protect it for 'authenticated' as well.\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          authenticated: ['test'],\n          [`role:${roleName}`]: ['owner']\n        }\n      });\n\n      // user has role\n      await logIn(user1);\n      const object = await obj1.fetch();\n\n      //\n      expect(object.get('test')).toBeDefined(\"Being both auhenticated and having a role leads to clearing protection on 'test' (by role rules)\");\n      expect(object.get('owner')).toBeDefined('All authenticated users allowed to see \"owner\"');\n      expect(object.get('testers')).toBeDefined();\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should not hide fields when user does not belong to a role protectedFields set for","suites":["ProtectedFields","targeting roles"],"line":1339,"updatePoint":{"line":1339,"column":90,"index":45282},"code":"    it('should not hide fields when user does not belong to a role protectedFields set for', async done => {\n      const role = await createRole({\n        users: user2\n      });\n      const roleName = role.get('name');\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          [`role:${roleName}`]: ['test']\n        }\n      });\n\n      // relate user1 to some role, no protectedFields for it\n      await createRole({\n        users: user1\n      });\n      await logIn(user1);\n      const object = await obj1.fetch();\n      expect(object.get('test')).toBeDefined('Field should be visible - user belongs to a role that has no protectedFields set');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should be enforced regardless of pointer-field being included in keys (select)","suites":["ProtectedFields","using pointer-fields and queries with keys projection"],"line":1410,"updatePoint":{"line":1410,"column":86,"index":47407},"code":"    it('should be enforced regardless of pointer-field being included in keys (select)', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          '*': ['field', 'test'],\n          'userField:owner': []\n        }\n      });\n      const query = new Parse.Query('AnObject');\n      query.select('field', 'test');\n      const object = await query.get(obj.id);\n      expect(object.get('field')).toBe('field');\n      expect(object.get('test')).toBe('test');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should protect fields for query where pointer field is not included via keys (REST GET)","suites":["ProtectedFields","using pointer-fields and queries with keys projection"],"line":1430,"updatePoint":{"line":1430,"column":95,"index":48001},"code":"    it('should protect fields for query where pointer field is not included via keys (REST GET)', async done => {\n      const obj = new Parse.Object(className);\n      obj.set('owner', user1);\n      obj.set('field', 'field');\n      obj.set('test', 'test');\n      await Parse.Object.saveAll([obj], {\n        useMasterKey: true\n      });\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          '*': ['field', 'test'],\n          'userField:owner': ['test']\n        }\n      });\n      const {\n        data: object\n      } = await request({\n        url: `${Parse.serverURL}/classes/${className}/${obj.id}`,\n        qs: {\n          keys: 'field,test'\n        },\n        headers: headers\n      });\n      expect(object.field).toBe('field', 'Should BE in response - not protected by \"userField:owner\"');\n      expect(object.test).toBe(undefined, 'Should NOT be in response - protected by \"userField:owner\"');\n      expect(object.owner).toBe(undefined, 'Should not be in response - not included in \"keys\"');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should protect fields for query where pointer field is not included via keys (REST FIND)","suites":["ProtectedFields","using pointer-fields and queries with keys projection"],"line":1464,"updatePoint":{"line":1464,"column":96,"index":49118},"code":"    it('should protect fields for query where pointer field is not included via keys (REST FIND)', async done => {\n      const obj = new Parse.Object(className);\n      obj.set('owner', user1);\n      obj.set('field', 'field');\n      obj.set('test', 'test');\n      await Parse.Object.saveAll([obj], {\n        useMasterKey: true\n      });\n      await obj.fetch();\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          '*': ['field', 'test'],\n          'userField:owner': ['test']\n        }\n      });\n      const {\n        data\n      } = await request({\n        url: `${Parse.serverURL}/classes/${className}`,\n        qs: {\n          keys: 'field,test',\n          where: JSON.stringify({\n            objectId: obj.id\n          })\n        },\n        headers\n      });\n      const object = data.results[0];\n      expect(object.field).toBe('field', 'Should be in response - not protected by \"userField:owner\"');\n      expect(object.test).toBe(undefined, 'Should not be in response - protected by \"userField:owner\"');\n      expect(object.owner).toBe(undefined, 'Should not be in response - not included in \"keys\"');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should protect fields for query where pointer field is in excludeKeys (REST GET)","suites":["ProtectedFields","using pointer-fields and queries with keys projection"],"line":1503,"updatePoint":{"line":1503,"column":88,"index":50340},"code":"    it('should protect fields for query where pointer field is in excludeKeys (REST GET)', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          '*': ['field', 'test'],\n          'userField:owner': ['test']\n        }\n      });\n      const {\n        data: object\n      } = await request({\n        qs: {\n          excludeKeys: 'owner'\n        },\n        headers,\n        url: `${Parse.serverURL}/classes/${className}/${obj.id}`\n      });\n      expect(object.field).toBe('field', 'Should be in response - not protected by \"userField:owner\"');\n      expect(object['test']).toBe(undefined, 'Should not be in response - protected by \"userField:owner\"');\n      expect(object['owner']).toBe(undefined, 'Should not be in response - not included in \"keys\"');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"should protect fields for query where pointer field is in excludedKeys (REST FIND)","suites":["ProtectedFields","using pointer-fields and queries with keys projection"],"line":1530,"updatePoint":{"line":1530,"column":90,"index":51229},"code":"    it('should protect fields for query where pointer field is in excludedKeys (REST FIND)', async done => {\n      await updateCLP({\n        protectedFields: {\n          '*': ['field', 'test'],\n          'userField:owner': ['test']\n        },\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        }\n      });\n      const {\n        data\n      } = await request({\n        qs: {\n          excludeKeys: 'owner',\n          where: JSON.stringify({\n            objectId: obj.id\n          })\n        },\n        headers,\n        url: `${Parse.serverURL}/classes/${className}`\n      });\n      const object = data.results[0];\n      expect(object.field).toBe('field', 'Should be in response - not protected by \"userField:owner\"');\n      expect(object.test).toBe(undefined, 'Should not be in response - protected by \"userField:owner\"');\n      expect(object.owner).toBe(undefined, 'Should not be in response - not included in \"keys\"');\n      done();\n    });","file":"ProtectedFields.spec.js","skipped":false,"dir":"spec"},{"name":"todo: should be enforced regardless of pointer-field being excluded","suites":["ProtectedFields","using pointer-fields and queries with keys projection"],"line":1561,"updatePoint":{"line":1561,"column":76,"index":52195},"skipped":true,"code":"    xit('todo: should be enforced regardless of pointer-field being excluded', async done => {\n      await updateCLP({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        protectedFields: {\n          '*': ['field', 'test'],\n          'userField:owner': []\n        }\n      });\n      const query = new Parse.Query('AnObject');\n\n      /* TODO: this has some caching problems on JS-SDK (2.11.) side */\n      // query.exclude('owner')\n\n      const object = await query.get(obj.id);\n      expect(object.get('field')).toBe('field');\n      expect(object.get('test')).toBe('test');\n      expect(object.get('owner')).toBe(undefined);\n      done();\n    });","file":"ProtectedFields.spec.js","dir":"spec"},{"name":"should return missing username error on ajax request without username provided","suites":["public API"],"line":8,"updatePoint":{"line":8,"column":84,"index":300},"code":"  it('should return missing username error on ajax request without username provided', async () => {\n    await reconfigureServer({\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    try {\n      await req({\n        method: 'POST',\n        url: 'http://localhost:8378/1/apps/test/request_password_reset',\n        body: `new_password=user1&token=43634643&username=`,\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'X-Requested-With': 'XMLHttpRequest'\n        },\n        followRedirects: false\n      });\n    } catch (error) {\n      expect(error.status).not.toBe(302);\n      expect(error.text).toEqual('{\"code\":200,\"error\":\"Missing username\"}');\n    }\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should return missing token error on ajax request without token provided","suites":["public API"],"line":28,"updatePoint":{"line":28,"column":78,"index":1002},"code":"  it('should return missing token error on ajax request without token provided', async () => {\n    await reconfigureServer({\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    try {\n      await req({\n        method: 'POST',\n        url: 'http://localhost:8378/1/apps/test/request_password_reset',\n        body: `new_password=user1&token=&username=Johnny`,\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'X-Requested-With': 'XMLHttpRequest'\n        },\n        followRedirects: false\n      });\n    } catch (error) {\n      expect(error.status).not.toBe(302);\n      expect(error.text).toEqual('{\"code\":-1,\"error\":\"Missing token\"}');\n    }\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should return missing password error on ajax request without password provided","suites":["public API"],"line":48,"updatePoint":{"line":48,"column":84,"index":1704},"code":"  it('should return missing password error on ajax request without password provided', async () => {\n    await reconfigureServer({\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    try {\n      await req({\n        method: 'POST',\n        url: 'http://localhost:8378/1/apps/test/request_password_reset',\n        body: `new_password=&token=132414&username=Johnny`,\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'X-Requested-With': 'XMLHttpRequest'\n        },\n        followRedirects: false\n      });\n    } catch (error) {\n      expect(error.status).not.toBe(302);\n      expect(error.text).toEqual('{\"code\":201,\"error\":\"Missing password\"}');\n    }\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get invalid_link.html","suites":["public API"],"line":68,"updatePoint":{"line":68,"column":34,"index":2361},"code":"  it('should get invalid_link.html', done => {\n    request('http://localhost:8378/1/apps/invalid_link.html', (err, httpResponse) => {\n      expect(httpResponse.status).toBe(200);\n      done();\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get choose_password","suites":["public API"],"line":74,"updatePoint":{"line":74,"column":32,"index":2566},"code":"  it('should get choose_password', done => {\n    reconfigureServer({\n      appName: 'unused',\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      request('http://localhost:8378/1/apps/choose_password?id=test', (err, httpResponse) => {\n        expect(httpResponse.status).toBe(200);\n        done();\n      });\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get verify_email_success.html","suites":["public API"],"line":85,"updatePoint":{"line":85,"column":42,"index":2921},"code":"  it('should get verify_email_success.html', done => {\n    request('http://localhost:8378/1/apps/verify_email_success.html', (err, httpResponse) => {\n      expect(httpResponse.status).toBe(200);\n      done();\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get password_reset_success.html","suites":["public API"],"line":91,"updatePoint":{"line":91,"column":44,"index":3146},"code":"  it('should get password_reset_success.html', done => {\n    request('http://localhost:8378/1/apps/password_reset_success.html', (err, httpResponse) => {\n      expect(httpResponse.status).toBe(200);\n      done();\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get 404 on verify_email","suites":["public API without publicServerURL"],"line":104,"updatePoint":{"line":104,"column":36,"index":3526},"code":"  it('should get 404 on verify_email', done => {\n    request('http://localhost:8378/1/apps/test/verify_email', (err, httpResponse) => {\n      expect(httpResponse.status).toBe(404);\n      done();\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get 404 choose_password","suites":["public API without publicServerURL"],"line":110,"updatePoint":{"line":110,"column":36,"index":3735},"code":"  it('should get 404 choose_password', done => {\n    request('http://localhost:8378/1/apps/choose_password?id=test', (err, httpResponse) => {\n      expect(httpResponse.status).toBe(404);\n      done();\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get 404 on request_password_reset","suites":["public API without publicServerURL"],"line":116,"updatePoint":{"line":116,"column":46,"index":3960},"code":"  it('should get 404 on request_password_reset', done => {\n    request('http://localhost:8378/1/apps/test/request_password_reset', (err, httpResponse) => {\n      expect(httpResponse.status).toBe(404);\n      done();\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get 403 on verify_email","suites":["public API supplied with invalid application id"],"line":129,"updatePoint":{"line":129,"column":36,"index":4353},"code":"  it('should get 403 on verify_email', done => {\n    request('http://localhost:8378/1/apps/invalid/verify_email', (err, httpResponse) => {\n      expect(httpResponse.status).toBe(403);\n      done();\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get 403 choose_password","suites":["public API supplied with invalid application id"],"line":135,"updatePoint":{"line":135,"column":36,"index":4565},"code":"  it('should get 403 choose_password', done => {\n    request('http://localhost:8378/1/apps/choose_password?id=invalid', (err, httpResponse) => {\n      expect(httpResponse.status).toBe(403);\n      done();\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get 403 on get of request_password_reset","suites":["public API supplied with invalid application id"],"line":141,"updatePoint":{"line":141,"column":53,"index":4800},"code":"  it('should get 403 on get of request_password_reset', done => {\n    request('http://localhost:8378/1/apps/invalid/request_password_reset', (err, httpResponse) => {\n      expect(httpResponse.status).toBe(403);\n      done();\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get 403 on post of request_password_reset","suites":["public API supplied with invalid application id"],"line":147,"updatePoint":{"line":147,"column":54,"index":5040},"code":"  it('should get 403 on post of request_password_reset', done => {\n    req({\n      url: 'http://localhost:8378/1/apps/invalid/request_password_reset',\n      method: 'POST'\n    }).then(done.fail, httpResponse => {\n      expect(httpResponse.status).toBe(403);\n      done();\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should get 403 on resendVerificationEmail","suites":["public API supplied with invalid application id"],"line":156,"updatePoint":{"line":156,"column":47,"index":5319},"code":"  it('should get 403 on resendVerificationEmail', done => {\n    request('http://localhost:8378/1/apps/invalid/resend_verification_email', (err, httpResponse) => {\n      expect(httpResponse.status).toBe(403);\n      done();\n    });\n  });","file":"PublicAPI.spec.js","skipped":false,"dir":"spec"},{"name":"should bypass appstore validation","suites":["test validate_receipt endpoint"],"line":28,"updatePoint":{"line":28,"column":39,"index":731},"code":"  it('should bypass appstore validation', async () => {\n    const httpResponse = await request({\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      method: 'POST',\n      url: 'http://localhost:8378/1/validate_purchase',\n      body: {\n        productIdentifier: 'a-product',\n        receipt: {\n          __type: 'Bytes',\n          base64: new Buffer('receipt', 'utf-8').toString('base64')\n        },\n        bypassAppStoreValidation: true\n      }\n    });\n    const body = httpResponse.data;\n    if (typeof body != 'object') {\n      fail('Body is not an object');\n    } else {\n      expect(body.__type).toEqual('File');\n      const url = body.url;\n      const otherResponse = await request({\n        url: url\n      });\n      expect(otherResponse.text).toBe('download_file');\n    }\n  });","file":"PurchaseValidation.spec.js","skipped":false,"dir":"spec"},{"name":"should fail for missing receipt","suites":["test validate_receipt endpoint"],"line":58,"updatePoint":{"line":58,"column":37,"index":1620},"code":"  it('should fail for missing receipt', async () => {\n    const response = await request({\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      url: 'http://localhost:8378/1/validate_purchase',\n      method: 'POST',\n      body: {\n        productIdentifier: 'a-product',\n        bypassAppStoreValidation: true\n      }\n    }).then(fail, res => res);\n    const body = response.data;\n    expect(body.code).toEqual(Parse.Error.INVALID_JSON);\n  });","file":"PurchaseValidation.spec.js","skipped":false,"dir":"spec"},{"name":"should fail for missing product identifier","suites":["test validate_receipt endpoint"],"line":75,"updatePoint":{"line":75,"column":48,"index":2178},"code":"  it('should fail for missing product identifier', async () => {\n    const response = await request({\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      url: 'http://localhost:8378/1/validate_purchase',\n      method: 'POST',\n      body: {\n        receipt: {\n          __type: 'Bytes',\n          base64: new Buffer('receipt', 'utf-8').toString('base64')\n        },\n        bypassAppStoreValidation: true\n      }\n    }).then(fail, res => res);\n    const body = response.data;\n    expect(body.code).toEqual(Parse.Error.INVALID_JSON);\n  });","file":"PurchaseValidation.spec.js","skipped":false,"dir":"spec"},{"name":"should bypass appstore validation and not find product","suites":["test validate_receipt endpoint"],"line":95,"updatePoint":{"line":95,"column":60,"index":2833},"code":"  it('should bypass appstore validation and not find product', async () => {\n    const response = await request({\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      url: 'http://localhost:8378/1/validate_purchase',\n      method: 'POST',\n      body: {\n        productIdentifier: 'another-product',\n        receipt: {\n          __type: 'Bytes',\n          base64: new Buffer('receipt', 'utf8').toString('base64')\n        },\n        bypassAppStoreValidation: true\n      }\n    }).catch(error => error);\n    const body = response.data;\n    if (typeof body != 'object') {\n      fail('Body is not an object');\n    } else {\n      expect(body.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n      expect(body.error).toEqual('Object not found.');\n    }\n  });","file":"PurchaseValidation.spec.js","skipped":false,"dir":"spec"},{"name":"should fail at appstore validation","suites":["test validate_receipt endpoint"],"line":121,"updatePoint":{"line":121,"column":40,"index":3664},"code":"  it('should fail at appstore validation', async () => {\n    const response = await request({\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json'\n      },\n      url: 'http://localhost:8378/1/validate_purchase',\n      method: 'POST',\n      body: {\n        productIdentifier: 'a-product',\n        receipt: {\n          __type: 'Bytes',\n          base64: new Buffer('receipt', 'utf-8').toString('base64')\n        }\n      }\n    });\n    const body = response.data;\n    if (typeof body != 'object') {\n      fail('Body is not an object');\n    } else {\n      expect(body.status).toBe(21002);\n      expect(body.error).toBe('The data in the receipt-data property was malformed or missing.');\n    }\n  });","file":"PurchaseValidation.spec.js","skipped":false,"dir":"spec"},{"name":"should not create a _Product","suites":["test validate_receipt endpoint"],"line":146,"updatePoint":{"line":146,"column":34,"index":4441},"code":"  it('should not create a _Product', done => {\n    const product = new Parse.Object('_Product');\n    product.save().then(function () {\n      fail('Should not be able to save');\n      done();\n    }, function (err) {\n      expect(err.code).toEqual(Parse.Error.INCORRECT_TYPE);\n      done();\n    });\n  });","file":"PurchaseValidation.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to update a _Product","suites":["test validate_receipt endpoint"],"line":156,"updatePoint":{"line":156,"column":41,"index":4751},"code":"  it('should be able to update a _Product', done => {\n    const query = new Parse.Query('_Product');\n    query.first().then(function (product) {\n      if (!product) {\n        return Promise.reject(new Error('Product should be found'));\n      }\n      product.set('title', 'a new title');\n      return product.save();\n    }).then(function (productAgain) {\n      expect(productAgain.get('downloadName')).toEqual(productAgain.get('download').name());\n      expect(productAgain.get('title')).toEqual('a new title');\n      done();\n    }).catch(function (err) {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"PurchaseValidation.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to remove a require key in a _Product","suites":["test validate_receipt endpoint"],"line":173,"updatePoint":{"line":173,"column":62,"index":5388},"code":"  it('should not be able to remove a require key in a _Product', done => {\n    const query = new Parse.Query('_Product');\n    query.first().then(function (product) {\n      if (!product) {\n        return Promise.reject(new Error('Product should be found'));\n      }\n      product.unset('title');\n      return product.save();\n    }).then(function () {\n      fail('Should not succeed');\n      done();\n    }).catch(function (err) {\n      expect(err.code).toEqual(Parse.Error.INCORRECT_TYPE);\n      expect(err.message).toEqual('title is required.');\n      done();\n    });\n  });","file":"PurchaseValidation.spec.js","skipped":false,"dir":"spec"},{"name":"can validate device type when no device type is set","suites":["PushController"],"line":46,"updatePoint":{"line":46,"column":57,"index":1502},"code":"  it('can validate device type when no device type is set', done => {\n    // Make query condition\n    const where = {};\n    const validPushTypes = ['ios', 'android'];\n    expect(function () {\n      validatePushType(where, validPushTypes);\n    }).not.toThrow();\n    done();\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"can validate device type when single valid device type is set","suites":["PushController"],"line":55,"updatePoint":{"line":55,"column":67,"index":1791},"code":"  it('can validate device type when single valid device type is set', done => {\n    // Make query condition\n    const where = {\n      deviceType: 'ios'\n    };\n    const validPushTypes = ['ios', 'android'];\n    expect(function () {\n      validatePushType(where, validPushTypes);\n    }).not.toThrow();\n    done();\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"can validate device type when multiple valid device types are set","suites":["PushController"],"line":66,"updatePoint":{"line":66,"column":71,"index":2113},"code":"  it('can validate device type when multiple valid device types are set', done => {\n    // Make query condition\n    const where = {\n      deviceType: {\n        $in: ['android', 'ios']\n      }\n    };\n    const validPushTypes = ['ios', 'android'];\n    expect(function () {\n      validatePushType(where, validPushTypes);\n    }).not.toThrow();\n    done();\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"can throw on validateDeviceType when single invalid device type is set","suites":["PushController"],"line":79,"updatePoint":{"line":79,"column":76,"index":2476},"code":"  it('can throw on validateDeviceType when single invalid device type is set', done => {\n    // Make query condition\n    const where = {\n      deviceType: 'osx'\n    };\n    const validPushTypes = ['ios', 'android'];\n    expect(function () {\n      validatePushType(where, validPushTypes);\n    }).toThrow();\n    done();\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"can get expiration time in string format","suites":["PushController"],"line":90,"updatePoint":{"line":90,"column":46,"index":2769},"code":"  it('can get expiration time in string format', done => {\n    // Make mock request\n    const timeStr = '2015-03-19T22:05:08Z';\n    const body = {\n      expiration_time: timeStr\n    };\n    const time = PushController.getExpirationTime(body);\n    expect(time).toEqual(new Date(timeStr).valueOf());\n    done();\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"can get expiration time in number format","suites":["PushController"],"line":100,"updatePoint":{"line":100,"column":46,"index":3084},"code":"  it('can get expiration time in number format', done => {\n    // Make mock request\n    const timeNumber = 1426802708;\n    const body = {\n      expiration_time: timeNumber\n    };\n    const time = PushController.getExpirationTime(body);\n    expect(time).toEqual(timeNumber * 1000);\n    done();\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"can throw on getExpirationTime in invalid format","suites":["PushController"],"line":110,"updatePoint":{"line":110,"column":54,"index":3391},"code":"  it('can throw on getExpirationTime in invalid format', done => {\n    // Make mock request\n    const body = {\n      expiration_time: 'abcd'\n    };\n    expect(function () {\n      PushController.getExpirationTime(body);\n    }).toThrow();\n    done();\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"can get push time in string format","suites":["PushController"],"line":120,"updatePoint":{"line":120,"column":40,"index":3632},"code":"  it('can get push time in string format', done => {\n    // Make mock request\n    const timeStr = '2015-03-19T22:05:08Z';\n    const body = {\n      push_time: timeStr\n    };\n    const {\n      date\n    } = PushController.getPushTime(body);\n    expect(date).toEqual(new Date(timeStr));\n    done();\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"can get push time in number format","suites":["PushController"],"line":132,"updatePoint":{"line":132,"column":40,"index":3933},"code":"  it('can get push time in number format', done => {\n    // Make mock request\n    const timeNumber = 1426802708;\n    const body = {\n      push_time: timeNumber\n    };\n    const {\n      date\n    } = PushController.getPushTime(body);\n    expect(date.valueOf()).toEqual(timeNumber * 1000);\n    done();\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"can throw on getPushTime in invalid format","suites":["PushController"],"line":144,"updatePoint":{"line":144,"column":48,"index":4246},"code":"  it('can throw on getPushTime in invalid format', done => {\n    // Make mock request\n    const body = {\n      push_time: 'abcd'\n    };\n    expect(function () {\n      PushController.getPushTime(body);\n    }).toThrow();\n    done();\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"properly increment badges","suites":["PushController"],"line":154,"updatePoint":{"line":154,"column":31,"index":4466},"code":"  it('properly increment badges', async () => {\n    const pushAdapter = {\n      send: function (body, installations) {\n        const badge = body.data.badge;\n        installations.forEach(installation => {\n          expect(installation.badge).toEqual(badge);\n          expect(installation.originalBadge + 1).toEqual(installation.badge);\n        });\n        return successfulTransmissions(body, installations);\n      },\n      getValidPushTypes: function () {\n        return ['ios', 'android'];\n      }\n    };\n    const payload = {\n      data: {\n        alert: 'Hello World!',\n        badge: 'Increment'\n      }\n    };\n    const installations = [];\n    while (installations.length != 10) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    while (installations.length != 15) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'android');\n      installations.push(installation);\n    }\n    const config = Config.get(Parse.applicationId);\n    const auth = {\n      isMaster: true\n    };\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await sendPush(payload, {}, config, auth);\n    await pushCompleted(pushStatusId);\n\n    // Check we actually sent 15 pushes.\n    const pushStatus = await Parse.Push.getPushStatus(pushStatusId);\n    expect(pushStatus.get('numSent')).toBe(15);\n\n    // Check that the installations were actually updated.\n    const query = new Parse.Query('_Installation');\n    const results = await query.find({\n      useMasterKey: true\n    });\n    expect(results.length).toBe(15);\n    for (let i = 0; i < 15; i++) {\n      const installation = results[i];\n      expect(installation.get('badge')).toBe(parseInt(installation.get('originalBadge')) + 1);\n    }\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"properly increment badges by more than 1","suites":["PushController"],"line":221,"updatePoint":{"line":221,"column":46,"index":6981},"code":"  it('properly increment badges by more than 1', async () => {\n    const pushAdapter = {\n      send: function (body, installations) {\n        const badge = body.data.badge;\n        installations.forEach(installation => {\n          expect(installation.badge).toEqual(badge);\n          expect(installation.originalBadge + 3).toEqual(installation.badge);\n        });\n        return successfulTransmissions(body, installations);\n      },\n      getValidPushTypes: function () {\n        return ['ios', 'android'];\n      }\n    };\n    const payload = {\n      data: {\n        alert: 'Hello World!',\n        badge: {\n          __op: 'Increment',\n          amount: 3\n        }\n      }\n    };\n    const installations = [];\n    while (installations.length != 10) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    while (installations.length != 15) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'android');\n      installations.push(installation);\n    }\n    const config = Config.get(Parse.applicationId);\n    const auth = {\n      isMaster: true\n    };\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await sendPush(payload, {}, config, auth);\n    await pushCompleted(pushStatusId);\n    const pushStatus = await Parse.Push.getPushStatus(pushStatusId);\n    expect(pushStatus.get('numSent')).toBe(15);\n    // Check that the installations were actually updated.\n    const query = new Parse.Query('_Installation');\n    const results = await query.find({\n      useMasterKey: true\n    });\n    expect(results.length).toBe(15);\n    for (let i = 0; i < 15; i++) {\n      const installation = results[i];\n      expect(installation.get('badge')).toBe(parseInt(installation.get('originalBadge')) + 3);\n    }\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"properly set badges to 1","suites":["PushController"],"line":288,"updatePoint":{"line":288,"column":30,"index":9486},"code":"  it('properly set badges to 1', async () => {\n    const pushAdapter = {\n      send: function (body, installations) {\n        const badge = body.data.badge;\n        installations.forEach(installation => {\n          expect(installation.badge).toEqual(badge);\n          expect(1).toEqual(installation.badge);\n        });\n        return successfulTransmissions(body, installations);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const payload = {\n      data: {\n        alert: 'Hello World!',\n        badge: 1\n      }\n    };\n    const installations = [];\n    while (installations.length != 10) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    const config = Config.get(Parse.applicationId);\n    const auth = {\n      isMaster: true\n    };\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await sendPush(payload, {}, config, auth);\n    await pushCompleted(pushStatusId);\n    const pushStatus = await Parse.Push.getPushStatus(pushStatusId);\n    expect(pushStatus.get('numSent')).toBe(10);\n\n    // Check that the installations were actually updated.\n    const query = new Parse.Query('_Installation');\n    const results = await query.find({\n      useMasterKey: true\n    });\n    expect(results.length).toBe(10);\n    for (let i = 0; i < 10; i++) {\n      const installation = results[i];\n      expect(installation.get('badge')).toBe(1);\n    }\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"properly set badges to 1 with complex query #2903 #3022","suites":["PushController"],"line":344,"updatePoint":{"line":344,"column":61,"index":11401},"code":"  it('properly set badges to 1 with complex query #2903 #3022', async () => {\n    const payload = {\n      data: {\n        alert: 'Hello World!',\n        badge: 1\n      }\n    };\n    const installations = [];\n    while (installations.length != 10) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    let matchedInstallationsCount = 0;\n    const pushAdapter = {\n      send: function (body, installations) {\n        matchedInstallationsCount += installations.length;\n        const badge = body.data.badge;\n        installations.forEach(installation => {\n          expect(installation.badge).toEqual(badge);\n          expect(1).toEqual(installation.badge);\n        });\n        return successfulTransmissions(body, installations);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const config = Config.get(Parse.applicationId);\n    const auth = {\n      isMaster: true\n    };\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    await Parse.Object.saveAll(installations);\n    const objectIds = installations.map(installation => {\n      return installation.id;\n    });\n    const where = {\n      objectId: {\n        $in: objectIds.slice(0, 5)\n      }\n    };\n    const pushStatusId = await sendPush(payload, where, config, auth);\n    await pushCompleted(pushStatusId);\n    expect(matchedInstallationsCount).toBe(5);\n    const query = new Parse.Query(Parse.Installation);\n    query.equalTo('badge', 1);\n    const results = await query.find({\n      useMasterKey: true\n    });\n    expect(results.length).toBe(5);\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"properly creates _PushStatus","suites":["PushController"],"line":404,"updatePoint":{"line":404,"column":34,"index":13348},"code":"  it('properly creates _PushStatus', async () => {\n    const pushStatusAfterSave = {\n      handler: function () {}\n    };\n    const spy = spyOn(pushStatusAfterSave, 'handler').and.callThrough();\n    Parse.Cloud.afterSave('_PushStatus', pushStatusAfterSave.handler);\n    const installations = [];\n    while (installations.length != 10) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    while (installations.length != 15) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('deviceType', 'android');\n      installations.push(installation);\n    }\n    const payload = {\n      data: {\n        alert: 'Hello World!',\n        badge: 1\n      }\n    };\n    const pushAdapter = {\n      send: function (body, installations) {\n        return successfulIOS(body, installations);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const config = Config.get(Parse.applicationId);\n    const auth = {\n      isMaster: true\n    };\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await sendPush(payload, {}, config, auth);\n    await pushCompleted(pushStatusId);\n    const result = await Parse.Push.getPushStatus(pushStatusId);\n    expect(result.createdAt instanceof Date).toBe(true);\n    expect(result.updatedAt instanceof Date).toBe(true);\n    expect(result.id.length).toBe(10);\n    expect(result.get('source')).toEqual('rest');\n    expect(result.get('query')).toEqual(JSON.stringify({}));\n    expect(typeof result.get('payload')).toEqual('string');\n    expect(JSON.parse(result.get('payload'))).toEqual(payload.data);\n    expect(result.get('status')).toEqual('succeeded');\n    expect(result.get('numSent')).toEqual(10);\n    expect(result.get('sentPerType')).toEqual({\n      ios: 10 // 10 ios\n    });\n\n    expect(result.get('numFailed')).toEqual(5);\n    expect(result.get('failedPerType')).toEqual({\n      android: 5 // android\n    });\n\n    try {\n      // Try to get it without masterKey\n      const query = new Parse.Query('_PushStatus');\n      await query.find();\n      fail();\n    } catch (error) {\n      expect(error.code).toBe(119);\n    }\n    function getPushStatus(callIndex) {\n      return spy.calls.all()[callIndex].args[0].object;\n    }\n    expect(spy).toHaveBeenCalled();\n    expect(spy.calls.count()).toBe(4);\n    const allCalls = spy.calls.all();\n    let pendingCount = 0;\n    let runningCount = 0;\n    let succeedCount = 0;\n    allCalls.forEach((call, index) => {\n      expect(call.args.length).toBe(1);\n      const object = call.args[0].object;\n      expect(object instanceof Parse.Object).toBe(true);\n      const pushStatus = getPushStatus(index);\n      if (pushStatus.get('status') === 'pending') {\n        pendingCount += 1;\n      }\n      if (pushStatus.get('status') === 'running') {\n        runningCount += 1;\n      }\n      if (pushStatus.get('status') === 'succeeded') {\n        succeedCount += 1;\n      }\n      if (pushStatus.get('status') === 'running' && pushStatus.get('numSent') > 0) {\n        expect(pushStatus.get('numSent')).toBe(10);\n        expect(pushStatus.get('numFailed')).toBe(5);\n        expect(pushStatus.get('failedPerType')).toEqual({\n          android: 5\n        });\n        expect(pushStatus.get('sentPerType')).toEqual({\n          ios: 10\n        });\n      }\n    });\n    expect(pendingCount).toBe(1);\n    expect(runningCount).toBe(2);\n    expect(succeedCount).toBe(1);\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"properly creates _PushStatus without serverURL","suites":["PushController"],"line":518,"updatePoint":{"line":518,"column":52,"index":17400},"code":"  it('properly creates _PushStatus without serverURL', async () => {\n    const pushStatusAfterSave = {\n      handler: function () {}\n    };\n    Parse.Cloud.afterSave('_PushStatus', pushStatusAfterSave.handler);\n    const installation = new Parse.Object('_Installation');\n    installation.set('installationId', 'installation');\n    installation.set('deviceToken', 'device_token');\n    installation.set('badge', 0);\n    installation.set('originalBadge', 0);\n    installation.set('deviceType', 'ios');\n    const payload = {\n      data: {\n        alert: 'Hello World!',\n        badge: 1\n      }\n    };\n    const pushAdapter = {\n      send: function (body, installations) {\n        return successfulIOS(body, installations);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const config = Config.get(Parse.applicationId);\n    const auth = {\n      isMaster: true\n    };\n    await installation.save();\n    await reconfigureServer({\n      serverURL: 'http://localhost:8378/',\n      // server with borked URL\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    const pushStatusId = await sendPush(payload, {}, config, auth);\n    // it is enqueued so it can take time\n    await sleep(1000);\n    Parse.serverURL = 'http://localhost:8378/1'; // GOOD url\n    const result = await Parse.Push.getPushStatus(pushStatusId);\n    expect(result).toBeDefined();\n    await pushCompleted(pushStatusId);\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should properly report failures in _PushStatus","suites":["PushController"],"line":563,"updatePoint":{"line":563,"column":52,"index":18839},"code":"  it('should properly report failures in _PushStatus', async () => {\n    const pushAdapter = {\n      send: function (body, installations) {\n        return installations.map(installation => {\n          return Promise.resolve({\n            deviceType: installation.deviceType\n          });\n        });\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    // $ins is invalid query\n    const where = {\n      channels: {\n        $ins: ['Giants', 'Mets']\n      }\n    };\n    const payload = {\n      data: {\n        alert: 'Hello World!',\n        badge: 1\n      }\n    };\n    const auth = {\n      isMaster: true\n    };\n    const pushController = new PushController();\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    const config = Config.get(Parse.applicationId);\n    try {\n      await pushController.sendPush(payload, where, config, auth);\n      fail();\n    } catch (e) {\n      const query = new Parse.Query('_PushStatus');\n      let results = await query.find({\n        useMasterKey: true\n      });\n      while (results.length === 0) {\n        results = await query.find({\n          useMasterKey: true\n        });\n      }\n      expect(results.length).toBe(1);\n      const pushStatus = results[0];\n      expect(pushStatus.get('status')).toBe('failed');\n    }\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should support full RESTQuery for increment","suites":["PushController"],"line":616,"updatePoint":{"line":616,"column":49,"index":20176},"code":"  it('should support full RESTQuery for increment', async () => {\n    const payload = {\n      data: {\n        alert: 'Hello World!',\n        badge: 'Increment'\n      }\n    };\n    const pushAdapter = {\n      send: function (body, installations) {\n        return successfulTransmissions(body, installations);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const config = Config.get(Parse.applicationId);\n    const auth = {\n      isMaster: true\n    };\n    const where = {\n      deviceToken: {\n        $in: ['device_token_0', 'device_token_1', 'device_token_2']\n      }\n    };\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    const installations = [];\n    while (installations.length != 5) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await sendPush(payload, where, config, auth);\n    await pushCompleted(pushStatusId);\n    const pushStatus = await Parse.Push.getPushStatus(pushStatusId);\n    expect(pushStatus.get('numSent')).toBe(3);\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should support object type for alert","suites":["PushController"],"line":661,"updatePoint":{"line":661,"column":42,"index":21656},"code":"  it('should support object type for alert', async () => {\n    const payload = {\n      data: {\n        alert: {\n          'loc-key': 'hello_world'\n        }\n      }\n    };\n    const pushAdapter = {\n      send: function (body, installations) {\n        return successfulTransmissions(body, installations);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const config = Config.get(Parse.applicationId);\n    const auth = {\n      isMaster: true\n    };\n    const where = {\n      deviceType: 'ios'\n    };\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    const installations = [];\n    while (installations.length != 5) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await sendPush(payload, where, config, auth);\n    await pushCompleted(pushStatusId);\n    const pushStatus = await Parse.Push.getPushStatus(pushStatusId);\n    expect(pushStatus.get('numSent')).toBe(5);\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should flatten","suites":["PushController"],"line":705,"updatePoint":{"line":705,"column":20,"index":23045},"code":"  it('should flatten', () => {\n    const res = StatusHandler.flatten([1, [2], [[3, 4], 5], [[[6]]]]);\n    expect(res).toEqual([1, 2, 3, 4, 5, 6]);\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"properly transforms push time","suites":["PushController"],"line":709,"updatePoint":{"line":709,"column":35,"index":23213},"code":"  it('properly transforms push time', () => {\n    expect(PushController.getPushTime()).toBe(undefined);\n    expect(PushController.getPushTime({\n      push_time: 1000\n    }).date).toEqual(new Date(1000 * 1000));\n    expect(PushController.getPushTime({\n      push_time: '2017-01-01'\n    }).date).toEqual(new Date('2017-01-01'));\n    expect(() => {\n      PushController.getPushTime({\n        push_time: 'gibberish-time'\n      });\n    }).toThrow();\n    expect(() => {\n      PushController.getPushTime({\n        push_time: Number.NaN\n      });\n    }).toThrow();\n    expect(PushController.getPushTime({\n      push_time: '2017-09-06T13:42:48.369Z'\n    })).toEqual({\n      date: new Date('2017-09-06T13:42:48.369Z'),\n      isLocalTime: false\n    });\n    expect(PushController.getPushTime({\n      push_time: '2007-04-05T12:30-02:00'\n    })).toEqual({\n      date: new Date('2007-04-05T12:30-02:00'),\n      isLocalTime: false\n    });\n    expect(PushController.getPushTime({\n      push_time: '2007-04-05T12:30'\n    })).toEqual({\n      date: new Date('2007-04-05T12:30'),\n      isLocalTime: true\n    });\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should not schedule push when not configured","suites":["PushController"],"line":746,"updatePoint":{"line":746,"column":50,"index":24325},"code":"  it('should not schedule push when not configured', async () => {\n    const config = Config.get(Parse.applicationId);\n    const auth = {\n      isMaster: true\n    };\n    const pushAdapter = {\n      send: function (body, installations) {\n        return successfulTransmissions(body, installations);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const pushController = new PushController();\n    const payload = {\n      data: {\n        alert: 'hello'\n      },\n      push_time: new Date().getTime()\n    };\n    const installations = [];\n    while (installations.length != 10) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    await Parse.Object.saveAll(installations);\n    await pushController.sendPush(payload, {}, config, auth);\n    await sleep(1000);\n    const query = new Parse.Query('_PushStatus');\n    const results = await query.find({\n      useMasterKey: true\n    });\n    expect(results.length).toBe(1);\n    const pushStatus = results[0];\n    expect(pushStatus.get('status')).not.toBe('scheduled');\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should schedule push when configured","suites":["PushController"],"line":792,"updatePoint":{"line":792,"column":42,"index":25847},"code":"  it('should schedule push when configured', async () => {\n    const auth = {\n      isMaster: true\n    };\n    const pushAdapter = {\n      send: function (body, installations) {\n        const promises = installations.map(device => {\n          if (!device.deviceToken) {\n            // Simulate error when device token is not set\n            return Promise.reject();\n          }\n          return Promise.resolve({\n            transmitted: true,\n            device: device\n          });\n        });\n        return Promise.all(promises);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const pushController = new PushController();\n    const payload = {\n      data: {\n        alert: 'hello'\n      },\n      push_time: new Date().getTime() / 1000\n    };\n    const installations = [];\n    while (installations.length != 10) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      },\n      scheduledPush: true\n    });\n    const config = Config.get(Parse.applicationId);\n    await Parse.Object.saveAll(installations);\n    await pushController.sendPush(payload, {}, config, auth);\n    await sleep(1000);\n    const query = new Parse.Query('_PushStatus');\n    const results = await query.find({\n      useMasterKey: true\n    });\n    expect(results.length).toBe(1);\n    const pushStatus = results[0];\n    expect(pushStatus.get('status')).toBe('scheduled');\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should not enqueue push when device token is not set","suites":["PushController"],"line":849,"updatePoint":{"line":849,"column":58,"index":27711},"code":"  it('should not enqueue push when device token is not set', async () => {\n    const auth = {\n      isMaster: true\n    };\n    const pushAdapter = {\n      send: function (body, installations) {\n        const promises = installations.map(device => {\n          if (!device.deviceToken) {\n            // Simulate error when device token is not set\n            return Promise.reject();\n          }\n          return Promise.resolve({\n            transmitted: true,\n            device: device\n          });\n        });\n        return Promise.all(promises);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const payload = {\n      data: {\n        alert: 'hello'\n      },\n      push_time: new Date().getTime() / 1000\n    };\n    const installations = [];\n    while (installations.length != 5) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    while (installations.length != 15) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    const config = Config.get(Parse.applicationId);\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await sendPush(payload, {}, config, auth);\n    await pushCompleted(pushStatusId);\n    const pushStatus = await Parse.Push.getPushStatus(pushStatusId);\n    expect(pushStatus.get('numSent')).toBe(5);\n    expect(pushStatus.get('status')).toBe('succeeded');\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should not mark the _PushStatus as failed when audience has no deviceToken","suites":["PushController"],"line":908,"updatePoint":{"line":908,"column":80,"index":29859},"code":"  it('should not mark the _PushStatus as failed when audience has no deviceToken', async () => {\n    const auth = {\n      isMaster: true\n    };\n    const pushAdapter = {\n      send: function (body, installations) {\n        const promises = installations.map(device => {\n          if (!device.deviceToken) {\n            // Simulate error when device token is not set\n            return Promise.reject();\n          }\n          return Promise.resolve({\n            transmitted: true,\n            device: device\n          });\n        });\n        return Promise.all(promises);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const payload = {\n      data: {\n        alert: 'hello'\n      },\n      push_time: new Date().getTime() / 1000\n    };\n    const installations = [];\n    while (installations.length != 5) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    const config = Config.get(Parse.applicationId);\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await sendPush(payload, {}, config, auth);\n    await pushCompleted(pushStatusId);\n    const pushStatus = await Parse.Push.getPushStatus(pushStatusId);\n    expect(pushStatus.get('status')).toBe('succeeded');\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should support localized payload data","suites":["PushController"],"line":957,"updatePoint":{"line":957,"column":43,"index":31450},"code":"  it('should support localized payload data', async () => {\n    const payload = {\n      data: {\n        alert: 'Hello!',\n        'alert-fr': 'Bonjour',\n        'alert-es': 'Ola'\n      }\n    };\n    const pushAdapter = {\n      send: function (body, installations) {\n        return successfulTransmissions(body, installations);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const config = Config.get(Parse.applicationId);\n    const auth = {\n      isMaster: true\n    };\n    const where = {\n      deviceType: 'ios'\n    };\n    const installations = [];\n    while (installations.length != 5) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    installations[0].set('localeIdentifier', 'fr-CA');\n    installations[1].set('localeIdentifier', 'fr-FR');\n    installations[2].set('localeIdentifier', 'en-US');\n    spyOn(pushAdapter, 'send').and.callThrough();\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    await Parse.Object.saveAll(installations);\n    const pushStatusId = await sendPush(payload, where, config, auth);\n    await pushCompleted(pushStatusId);\n    expect(pushAdapter.send.calls.count()).toBe(2);\n    const firstCall = pushAdapter.send.calls.first();\n    expect(firstCall.args[0].data).toEqual({\n      alert: 'Hello!'\n    });\n    expect(firstCall.args[1].length).toBe(3); // 3 installations\n\n    const lastCall = pushAdapter.send.calls.mostRecent();\n    expect(lastCall.args[0].data).toEqual({\n      alert: 'Bonjour'\n    });\n    expect(lastCall.args[1].length).toBe(2); // 2 installations\n    // No installation is in es so only 1 call for fr, and another for default\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should update audiences","suites":["PushController"],"line":1017,"updatePoint":{"line":1017,"column":29,"index":33491},"code":"  it('should update audiences', async () => {\n    const pushAdapter = {\n      send: function (body, installations) {\n        return successfulTransmissions(body, installations);\n      },\n      getValidPushTypes: function () {\n        return ['ios'];\n      }\n    };\n    const config = Config.get(Parse.applicationId);\n    const auth = {\n      isMaster: true\n    };\n    let audienceId = null;\n    const now = new Date();\n    let timesUsed = 0;\n    const where = {\n      deviceType: 'ios'\n    };\n    const installations = [];\n    while (installations.length != 5) {\n      const installation = new Parse.Object('_Installation');\n      installation.set('installationId', 'installation_' + installations.length);\n      installation.set('deviceToken', 'device_token_' + installations.length);\n      installation.set('badge', installations.length);\n      installation.set('originalBadge', installations.length);\n      installation.set('deviceType', 'ios');\n      installations.push(installation);\n    }\n    spyOn(pushAdapter, 'send').and.callThrough();\n    await reconfigureServer({\n      push: {\n        adapter: pushAdapter\n      }\n    });\n    await Parse.Object.saveAll(installations);\n\n    // Create an audience\n    const query = new Parse.Query('_Audience');\n    query.descending('createdAt');\n    query.equalTo('query', JSON.stringify(where));\n    const parseResults = results => {\n      if (results.length > 0) {\n        audienceId = results[0].id;\n        timesUsed = results[0].get('timesUsed');\n        if (!isFinite(timesUsed)) {\n          timesUsed = 0;\n        }\n      }\n    };\n    const audience = new Parse.Object('_Audience');\n    audience.set('name', 'testAudience');\n    audience.set('query', JSON.stringify(where));\n    await Parse.Object.saveAll(audience);\n    await query.find({\n      useMasterKey: true\n    }).then(parseResults);\n    const body = {\n      data: {\n        alert: 'hello'\n      },\n      audience_id: audienceId\n    };\n    const pushStatusId = await sendPush(body, where, config, auth);\n    await pushCompleted(pushStatusId);\n    expect(pushAdapter.send.calls.count()).toBe(1);\n    const firstCall = pushAdapter.send.calls.first();\n    expect(firstCall.args[0].data).toEqual({\n      alert: 'hello'\n    });\n    expect(firstCall.args[1].length).toBe(5);\n\n    // Get the audience we used above.\n    const audienceQuery = new Parse.Query('_Audience');\n    audienceQuery.equalTo('objectId', audienceId);\n    const results = await audienceQuery.find({\n      useMasterKey: true\n    });\n    expect(results[0].get('query')).toBe(JSON.stringify(where));\n    expect(results[0].get('timesUsed')).toBe(timesUsed + 1);\n    expect(results[0].get('lastUsed')).not.toBeLessThan(now);\n  });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should be accurate","suites":["PushController","pushTimeHasTimezoneComponent"],"line":1100,"updatePoint":{"line":1100,"column":26,"index":36239},"code":"    it('should be accurate', () => {\n      expect(PushController.pushTimeHasTimezoneComponent('2017-09-06T17:14:01.048Z')).toBe(true, 'UTC time');\n      expect(PushController.pushTimeHasTimezoneComponent('2007-04-05T12:30-02:00')).toBe(true, 'Timezone offset');\n      expect(PushController.pushTimeHasTimezoneComponent('2007-04-05T12:30:00.000Z-02:00')).toBe(true, 'Seconds + Milliseconds + Timezone offset');\n      expect(PushController.pushTimeHasTimezoneComponent('2017-09-06T17:14:01.048')).toBe(false, 'No timezone');\n      expect(PushController.pushTimeHasTimezoneComponent('2017-09-06')).toBe(false, 'YY-MM-DD');\n    });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should format as ISO string","suites":["PushController","formatPushTime"],"line":1109,"updatePoint":{"line":1109,"column":35,"index":36919},"code":"    it('should format as ISO string', () => {\n      expect(PushController.formatPushTime({\n        date: new Date('2017-09-06T17:14:01.048Z'),\n        isLocalTime: false\n      })).toBe('2017-09-06T17:14:01.048Z', 'UTC time');\n      expect(PushController.formatPushTime({\n        date: new Date('2007-04-05T12:30-02:00'),\n        isLocalTime: false\n      })).toBe('2007-04-05T14:30:00.000Z', 'Timezone offset');\n      const noTimezone = new Date('2017-09-06T17:14:01.048');\n      let expectedHour = 17 + noTimezone.getTimezoneOffset() / 60;\n      let day = '06';\n      if (expectedHour >= 24) {\n        expectedHour = expectedHour - 24;\n        day = '07';\n      }\n      expect(PushController.formatPushTime({\n        date: noTimezone,\n        isLocalTime: true\n      })).toBe(`2017-09-${day}T${expectedHour.toString().padStart(2, '0')}:14:01.048`, 'No timezone');\n      expect(PushController.formatPushTime({\n        date: new Date('2017-09-06'),\n        isLocalTime: true\n      })).toBe('2017-09-06T00:00:00.000', 'YY-MM-DD');\n    });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should preserve the push time","suites":["PushController","Scheduling pushes in local time"],"line":1136,"updatePoint":{"line":1136,"column":37,"index":38017},"code":"    it('should preserve the push time', async () => {\n      const auth = {\n        isMaster: true\n      };\n      const pushAdapter = {\n        send(body, installations) {\n          return successfulTransmissions(body, installations);\n        },\n        getValidPushTypes() {\n          return ['ios'];\n        }\n      };\n      const pushTime = '2017-09-06T17:14:01.048';\n      let expectedHour = 17 + new Date(pushTime).getTimezoneOffset() / 60;\n      let day = '06';\n      if (expectedHour >= 24) {\n        expectedHour = expectedHour - 24;\n        day = '07';\n      }\n      const payload = {\n        data: {\n          alert: 'Hello World!',\n          badge: 'Increment'\n        },\n        push_time: pushTime\n      };\n      await reconfigureServer({\n        push: {\n          adapter: pushAdapter\n        },\n        scheduledPush: true\n      });\n      const config = Config.get(Parse.applicationId);\n      const pushStatusId = await sendPush(payload, {}, config, auth);\n      const pushStatus = await Parse.Push.getPushStatus(pushStatusId);\n      expect(pushStatus.get('status')).toBe('scheduled');\n      expect(pushStatus.get('pushTime')).toBe(`2017-09-${day}T${expectedHour.toString().padStart(2, '0')}:14:01.048`);\n    });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if both expiration_time and expiration_interval are set","suites":["PushController","With expiration defined"],"line":1200,"updatePoint":{"line":1200,"column":76,"index":39914},"code":"    it('should throw if both expiration_time and expiration_interval are set', () => {\n      expect(() => pushController.sendPush({\n        expiration_time: '2017-09-25T13:21:20.841Z',\n        expiration_interval: 1000\n      }, {}, config, auth)).toThrow();\n    });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should throw on invalid expiration_interval","suites":["PushController","With expiration defined"],"line":1206,"updatePoint":{"line":1206,"column":51,"index":40155},"code":"    it('should throw on invalid expiration_interval', () => {\n      expect(() => pushController.sendPush({\n        expiration_interval: -1\n      }, {}, config, auth)).toThrow();\n      expect(() => pushController.sendPush({\n        expiration_interval: ''\n      }, {}, config, auth)).toThrow();\n      expect(() => pushController.sendPush({\n        expiration_time: {}\n      }, {}, config, auth)).toThrow();\n    });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should transform the expiration_interval into an absolute time","suites":["PushController","With expiration defined","For immediate pushes"],"line":1218,"updatePoint":{"line":1218,"column":72,"index":40635},"code":"      it('should transform the expiration_interval into an absolute time', async () => {\n        const now = new Date('2017-09-25T13:30:10.452Z');\n        const payload = {\n          data: {\n            alert: 'immediate push'\n          },\n          expiration_interval: 20 * 60 // twenty minutes\n        };\n\n        await reconfigureServer({\n          push: {\n            adapter: pushAdapter\n          }\n        });\n        const pushStatusId = await sendPush(payload, {}, Config.get(Parse.applicationId), auth, now);\n        const pushStatus = await Parse.Push.getPushStatus(pushStatusId);\n        expect(pushStatus.get('expiry')).toBeDefined('expiry must be set');\n        expect(pushStatus.get('expiry')).toEqual(new Date('2017-09-25T13:50:10.452Z').valueOf());\n        expect(pushStatus.get('expiration_interval')).toBeDefined('expiration_interval must be defined');\n        expect(pushStatus.get('expiration_interval')).toBe(20 * 60);\n      });","file":"PushController.spec.js","skipped":false,"dir":"spec"},{"name":"should be propagated to the PushWorker and PushQueue","suites":["PushQueue","With a defined channel"],"line":7,"updatePoint":{"line":7,"column":60,"index":235},"code":"    it('should be propagated to the PushWorker and PushQueue', done => {\n      reconfigureServer({\n        push: {\n          queueOptions: {\n            disablePushWorker: false,\n            channel: 'my-specific-channel'\n          },\n          adapter: {\n            send() {\n              return Promise.resolve();\n            },\n            getValidPushTypes() {\n              return [];\n            }\n          }\n        }\n      }).then(() => {\n        const config = Config.get(Parse.applicationId);\n        expect(config.pushWorker.channel).toEqual('my-specific-channel', 'pushWorker.channel');\n        expect(config.pushControllerQueue.channel).toEqual('my-specific-channel', 'pushWorker.channel');\n      }).then(done, done.fail);\n    });","file":"PushQueue.spec.js","skipped":false,"dir":"spec"},{"name":"should be prefixed with the applicationId","suites":["PushQueue","Default channel"],"line":31,"updatePoint":{"line":31,"column":49,"index":1014},"code":"    it('should be prefixed with the applicationId', done => {\n      reconfigureServer({\n        push: {\n          queueOptions: {\n            disablePushWorker: false\n          },\n          adapter: {\n            send() {\n              return Promise.resolve();\n            },\n            getValidPushTypes() {\n              return [];\n            }\n          }\n        }\n      }).then(() => {\n        const config = Config.get(Parse.applicationId);\n        expect(PushQueue.defaultPushChannel()).toEqual('test-parse-server-push');\n        expect(config.pushWorker.channel).toEqual('test-parse-server-push');\n        expect(config.pushControllerQueue.channel).toEqual('test-parse-server-push');\n      }).then(done, done.fail);\n    });","file":"PushQueue.spec.js","skipped":false,"dir":"spec"},{"name":"can get query condition when channels is set","suites":["PushRouter"],"line":4,"updatePoint":{"line":4,"column":50,"index":193},"code":"  it('can get query condition when channels is set', done => {\n    // Make mock request\n    const request = {\n      body: {\n        channels: ['Giants', 'Mets']\n      }\n    };\n    const where = PushRouter.getQueryCondition(request);\n    expect(where).toEqual({\n      channels: {\n        $in: ['Giants', 'Mets']\n      }\n    });\n    done();\n  });","file":"PushRouter.spec.js","skipped":false,"dir":"spec"},{"name":"can get query condition when where is set","suites":["PushRouter"],"line":19,"updatePoint":{"line":19,"column":47,"index":535},"code":"  it('can get query condition when where is set', done => {\n    // Make mock request\n    const request = {\n      body: {\n        where: {\n          injuryReports: true\n        }\n      }\n    };\n    const where = PushRouter.getQueryCondition(request);\n    expect(where).toEqual({\n      injuryReports: true\n    });\n    done();\n  });","file":"PushRouter.spec.js","skipped":false,"dir":"spec"},{"name":"can get query condition when nothing is set","suites":["PushRouter"],"line":34,"updatePoint":{"line":34,"column":49,"index":867},"code":"  it('can get query condition when nothing is set', done => {\n    // Make mock request\n    const request = {\n      body: {}\n    };\n    expect(function () {\n      PushRouter.getQueryCondition(request);\n    }).toThrow();\n    done();\n  });","file":"PushRouter.spec.js","skipped":false,"dir":"spec"},{"name":"can throw on getQueryCondition when channels and where are set","suites":["PushRouter"],"line":44,"updatePoint":{"line":44,"column":68,"index":1123},"code":"  it('can throw on getQueryCondition when channels and where are set', done => {\n    // Make mock request\n    const request = {\n      body: {\n        channels: {\n          $in: ['Giants', 'Mets']\n        },\n        where: {\n          injuryReports: true\n        }\n      }\n    };\n    expect(function () {\n      PushRouter.getQueryCondition(request);\n    }).toThrow();\n    done();\n  });","file":"PushRouter.spec.js","skipped":false,"dir":"spec"},{"name":"sends a push through REST","suites":["PushRouter"],"line":61,"updatePoint":{"line":61,"column":31,"index":1471},"code":"  it('sends a push through REST', done => {\n    request({\n      method: 'POST',\n      url: Parse.serverURL + '/push',\n      body: {\n        channels: {\n          $in: ['Giants', 'Mets']\n        }\n      },\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': Parse.masterKey,\n        'Content-Type': 'application/json'\n      }\n    }).then(res => {\n      expect(res.headers['x-parse-push-status-id']).not.toBe(undefined);\n      expect(res.headers['x-parse-push-status-id'].length).toBe(10);\n      expect(res.data.result).toBe(true);\n      done();\n    });\n  });","file":"PushRouter.spec.js","skipped":false,"dir":"spec"},{"name":"should run with small batch","suites":["PushWorker"],"line":9,"updatePoint":{"line":9,"column":33,"index":305},"code":"  it('should run with small batch', done => {\n    const batchSize = 3;\n    let sendCount = 0;\n    reconfigureServer({\n      push: {\n        queueOptions: {\n          disablePushWorker: true,\n          batchSize\n        }\n      }\n    }).then(() => {\n      expect(Config.get('test').pushWorker).toBeUndefined();\n      new PushWorker({\n        send: (body, installations) => {\n          expect(installations.length <= batchSize).toBe(true);\n          sendCount += installations.length;\n          return Promise.resolve();\n        },\n        getValidPushTypes: function () {\n          return ['ios', 'android'];\n        }\n      });\n      const installations = [];\n      while (installations.length != 10) {\n        const installation = new Parse.Object('_Installation');\n        installation.set('installationId', 'installation_' + installations.length);\n        installation.set('deviceToken', 'device_token_' + installations.length);\n        installation.set('badge', 1);\n        installation.set('deviceType', 'ios');\n        installations.push(installation);\n      }\n      return Parse.Object.saveAll(installations);\n    }).then(() => {\n      return Parse.Push.send({\n        where: {\n          deviceType: 'ios'\n        },\n        data: {\n          alert: 'Hello world!'\n        }\n      }, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      return new Promise(resolve => {\n        setTimeout(resolve, 500);\n      });\n    }).then(() => {\n      expect(sendCount).toBe(10);\n      done();\n    }).catch(err => {\n      jfail(err);\n    });\n  });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"should return locales","suites":["PushWorker","localized push"],"line":64,"updatePoint":{"line":64,"column":29,"index":1892},"code":"    it('should return locales', () => {\n      const locales = PushUtils.getLocalesFromPush({\n        data: {\n          'alert-fr': 'french',\n          alert: 'Yo!',\n          'alert-en-US': 'English'\n        }\n      });\n      expect(locales).toEqual(['fr', 'en-US']);\n    });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"should return and empty array if no locale is set","suites":["PushWorker","localized push"],"line":74,"updatePoint":{"line":74,"column":57,"index":2196},"code":"    it('should return and empty array if no locale is set', () => {\n      const locales = PushUtils.getLocalesFromPush({\n        data: {\n          alert: 'Yo!'\n        }\n      });\n      expect(locales).toEqual([]);\n    });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"should deduplicate locales","suites":["PushWorker","localized push"],"line":82,"updatePoint":{"line":82,"column":34,"index":2396},"code":"    it('should deduplicate locales', () => {\n      const locales = PushUtils.getLocalesFromPush({\n        data: {\n          alert: 'Yo!',\n          'alert-fr': 'french',\n          'title-fr': 'french'\n        }\n      });\n      expect(locales).toEqual(['fr']);\n    });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"should handle empty body data","suites":["PushWorker","localized push"],"line":92,"updatePoint":{"line":92,"column":37,"index":2667},"code":"    it('should handle empty body data', () => {\n      expect(PushUtils.getLocalesFromPush({})).toEqual([]);\n    });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"transforms body appropriately","suites":["PushWorker","localized push"],"line":95,"updatePoint":{"line":95,"column":37,"index":2783},"code":"    it('transforms body appropriately', () => {\n      const cleanBody = PushUtils.transformPushBodyForLocale({\n        data: {\n          alert: 'Yo!',\n          'alert-fr': 'frenchy!',\n          'alert-en': 'english'\n        }\n      }, 'fr');\n      expect(cleanBody).toEqual({\n        data: {\n          alert: 'frenchy!'\n        }\n      });\n    });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"transforms body appropriately","suites":["PushWorker","localized push"],"line":109,"updatePoint":{"line":109,"column":37,"index":3132},"code":"    it('transforms body appropriately', () => {\n      const cleanBody = PushUtils.transformPushBodyForLocale({\n        data: {\n          alert: 'Yo!',\n          'alert-fr': 'frenchy!',\n          'alert-en': 'english',\n          'title-fr': 'french title'\n        }\n      }, 'fr');\n      expect(cleanBody).toEqual({\n        data: {\n          alert: 'frenchy!',\n          title: 'french title'\n        }\n      });\n    });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"maps body on all provided locales","suites":["PushWorker","localized push"],"line":125,"updatePoint":{"line":125,"column":41,"index":3556},"code":"    it('maps body on all provided locales', () => {\n      const bodies = PushUtils.bodiesPerLocales({\n        data: {\n          alert: 'Yo!',\n          'alert-fr': 'frenchy!',\n          'alert-en': 'english',\n          'title-fr': 'french title'\n        }\n      }, ['fr', 'en']);\n      expect(bodies).toEqual({\n        fr: {\n          data: {\n            alert: 'frenchy!',\n            title: 'french title'\n          }\n        },\n        en: {\n          data: {\n            alert: 'english'\n          }\n        },\n        default: {\n          data: {\n            alert: 'Yo!'\n          }\n        }\n      });\n    });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"should properly handle default cases","suites":["PushWorker","localized push"],"line":153,"updatePoint":{"line":153,"column":44,"index":4176},"code":"    it('should properly handle default cases', () => {\n      expect(PushUtils.transformPushBodyForLocale({})).toEqual({});\n      expect(PushUtils.stripLocalesFromBody({})).toEqual({});\n      expect(PushUtils.bodiesPerLocales({\n        where: {}\n      })).toEqual({\n        default: {\n          where: {}\n        }\n      });\n      expect(PushUtils.groupByLocaleIdentifier([])).toEqual({\n        default: []\n      });\n    });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"should remove invalid installations","suites":["PushWorker","pushStatus"],"line":169,"updatePoint":{"line":169,"column":43,"index":4638},"code":"    it('should remove invalid installations', done => {\n      const config = Config.get('test');\n      const handler = pushStatusHandler(config);\n      const spy = spyOn(config.database, 'update').and.callFake(() => {\n        return Promise.resolve({});\n      });\n      const toAwait = handler.trackSent([{\n        transmitted: false,\n        device: {\n          deviceToken: 1,\n          deviceType: 'ios'\n        },\n        response: {\n          error: 'Unregistered'\n        }\n      }, {\n        transmitted: true,\n        device: {\n          deviceToken: 10,\n          deviceType: 'ios'\n        }\n      }, {\n        transmitted: false,\n        device: {\n          deviceToken: 2,\n          deviceType: 'ios'\n        },\n        response: {\n          error: 'NotRegistered'\n        }\n      }, {\n        transmitted: false,\n        device: {\n          deviceToken: 3,\n          deviceType: 'ios'\n        },\n        response: {\n          error: 'InvalidRegistration'\n        }\n      }, {\n        transmitted: true,\n        device: {\n          deviceToken: 11,\n          deviceType: 'ios'\n        }\n      }, {\n        transmitted: false,\n        device: {\n          deviceToken: 4,\n          deviceType: 'ios'\n        },\n        response: {\n          error: 'InvalidRegistration'\n        }\n      }, {\n        transmitted: false,\n        device: {\n          deviceToken: 5,\n          deviceType: 'ios'\n        },\n        response: {\n          error: 'InvalidRegistration'\n        }\n      }, {\n        // should not be deleted\n        transmitted: false,\n        device: {\n          deviceToken: Parse.Error.OBJECT_NOT_FOUND,\n          deviceType: 'ios'\n        },\n        response: {\n          error: 'invalid error...'\n        }\n      }], undefined, true);\n      expect(spy).toHaveBeenCalled();\n      expect(spy.calls.count()).toBe(1);\n      const lastCall = spy.calls.mostRecent();\n      expect(lastCall.args[0]).toBe('_Installation');\n      expect(lastCall.args[1]).toEqual({\n        deviceToken: {\n          $in: [1, 2, 3, 4, 5]\n        }\n      });\n      expect(lastCall.args[2]).toEqual({\n        deviceToken: {\n          __op: 'Delete'\n        }\n      });\n      toAwait.then(done).catch(done);\n    });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"tracks push status per UTC offsets","suites":["PushWorker","pushStatus"],"line":259,"updatePoint":{"line":259,"column":42,"index":6843},"code":"    it('tracks push status per UTC offsets', done => {\n      const config = Config.get('test');\n      const handler = pushStatusHandler(config);\n      const spy = spyOn(rest, 'update').and.callThrough();\n      const UTCOffset = 1;\n      handler.setInitial().then(() => {\n        return handler.trackSent([{\n          transmitted: false,\n          device: {\n            deviceToken: 1,\n            deviceType: 'ios'\n          }\n        }, {\n          transmitted: true,\n          device: {\n            deviceToken: 1,\n            deviceType: 'ios'\n          }\n        }], UTCOffset);\n      }).then(() => {\n        expect(spy).toHaveBeenCalled();\n        const lastCall = spy.calls.mostRecent();\n        expect(lastCall.args[2]).toBe(`_PushStatus`);\n        expect(lastCall.args[4]).toEqual({\n          numSent: {\n            __op: 'Increment',\n            amount: 1\n          },\n          numFailed: {\n            __op: 'Increment',\n            amount: 1\n          },\n          'sentPerType.ios': {\n            __op: 'Increment',\n            amount: 1\n          },\n          'failedPerType.ios': {\n            __op: 'Increment',\n            amount: 1\n          },\n          [`sentPerUTCOffset.${UTCOffset}`]: {\n            __op: 'Increment',\n            amount: 1\n          },\n          [`failedPerUTCOffset.${UTCOffset}`]: {\n            __op: 'Increment',\n            amount: 1\n          },\n          count: {\n            __op: 'Increment',\n            amount: -1\n          },\n          status: 'running'\n        });\n        const query = new Parse.Query('_PushStatus');\n        return query.get(handler.objectId, {\n          useMasterKey: true\n        });\n      }).then(pushStatus => {\n        const sentPerUTCOffset = pushStatus.get('sentPerUTCOffset');\n        expect(sentPerUTCOffset['1']).toBe(1);\n        const failedPerUTCOffset = pushStatus.get('failedPerUTCOffset');\n        expect(failedPerUTCOffset['1']).toBe(1);\n        return handler.trackSent([{\n          transmitted: false,\n          device: {\n            deviceToken: 1,\n            deviceType: 'ios'\n          }\n        }, {\n          transmitted: true,\n          device: {\n            deviceToken: 1,\n            deviceType: 'ios'\n          }\n        }, {\n          transmitted: true,\n          device: {\n            deviceToken: 1,\n            deviceType: 'ios'\n          }\n        }], UTCOffset);\n      }).then(() => {\n        const query = new Parse.Query('_PushStatus');\n        return query.get(handler.objectId, {\n          useMasterKey: true\n        });\n      }).then(pushStatus => {\n        const sentPerUTCOffset = pushStatus.get('sentPerUTCOffset');\n        expect(sentPerUTCOffset['1']).toBe(3);\n        const failedPerUTCOffset = pushStatus.get('failedPerUTCOffset');\n        expect(failedPerUTCOffset['1']).toBe(2);\n      }).then(done).catch(done.fail);\n    });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"tracks push status per UTC offsets with negative offsets","suites":["PushWorker","pushStatus"],"line":353,"updatePoint":{"line":353,"column":64,"index":9710},"code":"    it('tracks push status per UTC offsets with negative offsets', done => {\n      const config = Config.get('test');\n      const handler = pushStatusHandler(config);\n      const spy = spyOn(rest, 'update').and.callThrough();\n      const UTCOffset = -6;\n      handler.setInitial().then(() => {\n        return handler.trackSent([{\n          transmitted: false,\n          device: {\n            deviceToken: 1,\n            deviceType: 'ios'\n          },\n          response: {\n            error: 'Unregistered'\n          }\n        }, {\n          transmitted: true,\n          device: {\n            deviceToken: 1,\n            deviceType: 'ios'\n          },\n          response: {\n            error: 'Unregistered'\n          }\n        }], UTCOffset);\n      }).then(() => {\n        expect(spy).toHaveBeenCalled();\n        const lastCall = spy.calls.mostRecent();\n        expect(lastCall.args[2]).toBe('_PushStatus');\n        expect(lastCall.args[4]).toEqual({\n          numSent: {\n            __op: 'Increment',\n            amount: 1\n          },\n          numFailed: {\n            __op: 'Increment',\n            amount: 1\n          },\n          'sentPerType.ios': {\n            __op: 'Increment',\n            amount: 1\n          },\n          'failedPerType.ios': {\n            __op: 'Increment',\n            amount: 1\n          },\n          [`sentPerUTCOffset.${UTCOffset}`]: {\n            __op: 'Increment',\n            amount: 1\n          },\n          [`failedPerUTCOffset.${UTCOffset}`]: {\n            __op: 'Increment',\n            amount: 1\n          },\n          count: {\n            __op: 'Increment',\n            amount: -1\n          },\n          status: 'running'\n        });\n        done();\n      });\n    });","file":"PushWorker.spec.js","skipped":false,"dir":"spec"},{"name":"should always hash a query to the same string","suites":["queryHash"],"line":8,"updatePoint":{"line":8,"column":51,"index":355},"code":"  it('should always hash a query to the same string', function () {\n    const q = new Parse.Query(Item);\n    q.equalTo('field', 'value');\n    q.exists('name');\n    q.ascending('createdAt');\n    q.limit(10);\n    const firstHash = queryHash(q);\n    const secondHash = queryHash(q);\n    expect(firstHash).toBe(secondHash);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"should return equivalent hashes for equivalent queries","suites":["queryHash"],"line":18,"updatePoint":{"line":18,"column":60,"index":690},"code":"  it('should return equivalent hashes for equivalent queries', function () {\n    let q1 = new Parse.Query(Item);\n    q1.equalTo('field', 'value');\n    q1.exists('name');\n    q1.lessThan('age', 30);\n    q1.greaterThan('age', 3);\n    q1.ascending('createdAt');\n    q1.include(['name', 'age']);\n    q1.limit(10);\n    let q2 = new Parse.Query(Item);\n    q2.limit(10);\n    q2.greaterThan('age', 3);\n    q2.lessThan('age', 30);\n    q2.include(['name', 'age']);\n    q2.ascending('createdAt');\n    q2.exists('name');\n    q2.equalTo('field', 'value');\n    let firstHash = queryHash(q1);\n    let secondHash = queryHash(q2);\n    expect(firstHash).toBe(secondHash);\n    q1.containedIn('fruit', ['apple', 'banana', 'cherry']);\n    firstHash = queryHash(q1);\n    expect(firstHash).not.toBe(secondHash);\n    q2.containedIn('fruit', ['banana', 'cherry', 'apple']);\n    secondHash = queryHash(q2);\n    expect(secondHash).toBe(firstHash);\n    q1.containedIn('fruit', ['coconut']);\n    firstHash = queryHash(q1);\n    expect(firstHash).not.toBe(secondHash);\n    q1 = new Parse.Query(Item);\n    q1.equalTo('field', 'value');\n    q1.lessThan('age', 30);\n    q1.exists('name');\n    q2 = new Parse.Query(Item);\n    q2.equalTo('name', 'person');\n    q2.equalTo('field', 'other');\n    firstHash = queryHash(Parse.Query.or(q1, q2));\n    secondHash = queryHash(Parse.Query.or(q2, q1));\n    expect(firstHash).toBe(secondHash);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"should not let fields of different types appear similar","suites":["queryHash"],"line":58,"updatePoint":{"line":58,"column":61,"index":2095},"code":"  it('should not let fields of different types appear similar', function () {\n    let q1 = new Parse.Query(Item);\n    q1.lessThan('age', 30);\n    const q2 = new Parse.Query(Item);\n    q2.equalTo('age', '{$lt:30}');\n    expect(queryHash(q1)).not.toBe(queryHash(q2));\n    q1 = new Parse.Query(Item);\n    q1.equalTo('age', 15);\n    q2.equalTo('age', '15');\n    expect(queryHash(q1)).not.toBe(queryHash(q2));\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches blanket queries","suites":["matchesQuery"],"line":71,"updatePoint":{"line":71,"column":29,"index":2517},"code":"  it('matches blanket queries', function () {\n    const obj = {\n      id: new Id('Klass', 'O1'),\n      value: 12\n    };\n    const q = new Parse.Query('Klass');\n    expect(matchesQuery(obj, q)).toBe(true);\n    obj.id = new Id('Other', 'O1');\n    expect(matchesQuery(obj, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches existence queries","suites":["matchesQuery"],"line":81,"updatePoint":{"line":81,"column":31,"index":2812},"code":"  it('matches existence queries', function () {\n    const obj = {\n      id: new Id('Item', 'O1'),\n      count: 15\n    };\n    const q = new Parse.Query('Item');\n    q.exists('count');\n    expect(matchesQuery(obj, q)).toBe(true);\n    q.exists('name');\n    expect(matchesQuery(obj, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches queries with doesNotExist constraint","suites":["matchesQuery"],"line":92,"updatePoint":{"line":92,"column":50,"index":3133},"code":"  it('matches queries with doesNotExist constraint', function () {\n    const obj = {\n      id: new Id('Item', 'O1'),\n      count: 15\n    };\n    let q = new Parse.Query('Item');\n    q.doesNotExist('name');\n    expect(matchesQuery(obj, q)).toBe(true);\n    q = new Parse.Query('Item');\n    q.doesNotExist('count');\n    expect(matchesQuery(obj, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches on equality queries","suites":["matchesQuery"],"line":104,"updatePoint":{"line":104,"column":33,"index":3480},"code":"  it('matches on equality queries', function () {\n    const day = new Date();\n    const location = new Parse.GeoPoint({\n      latitude: 37.484815,\n      longitude: -122.148377\n    });\n    const obj = {\n      id: new Id('Person', 'O1'),\n      score: 12,\n      name: 'Bill',\n      birthday: day,\n      lastLocation: location\n    };\n    let q = new Parse.Query('Person');\n    q.equalTo('score', 12);\n    expect(matchesQuery(obj, q)).toBe(true);\n    q = new Parse.Query('Person');\n    q.equalTo('name', 'Bill');\n    expect(matchesQuery(obj, q)).toBe(true);\n    q.equalTo('name', 'Jeff');\n    expect(matchesQuery(obj, q)).toBe(false);\n    q = new Parse.Query('Person');\n    q.containedIn('name', ['Adam', 'Ben', 'Charles']);\n    expect(matchesQuery(obj, q)).toBe(false);\n    q.containedIn('name', ['Adam', 'Bill', 'Charles']);\n    expect(matchesQuery(obj, q)).toBe(true);\n    q = new Parse.Query('Person');\n    q.notContainedIn('name', ['Adam', 'Bill', 'Charles']);\n    expect(matchesQuery(obj, q)).toBe(false);\n    q.notContainedIn('name', ['Adam', 'Ben', 'Charles']);\n    expect(matchesQuery(obj, q)).toBe(true);\n    q = new Parse.Query('Person');\n    q.equalTo('birthday', day);\n    expect(matchesQuery(obj, q)).toBe(true);\n    q.equalTo('birthday', new Date(1990, 1));\n    expect(matchesQuery(obj, q)).toBe(false);\n    q = new Parse.Query('Person');\n    q.equalTo('lastLocation', new Parse.GeoPoint({\n      latitude: 37.484815,\n      longitude: -122.148377\n    }));\n    expect(matchesQuery(obj, q)).toBe(true);\n    q.equalTo('lastLocation', new Parse.GeoPoint({\n      latitude: 37.4848,\n      longitude: -122.1483\n    }));\n    expect(matchesQuery(obj, q)).toBe(false);\n    q.equalTo('lastLocation', new Parse.GeoPoint({\n      latitude: 37.484815,\n      longitude: -122.148377\n    }));\n    q.equalTo('score', 12);\n    q.equalTo('name', 'Bill');\n    q.equalTo('birthday', day);\n    expect(matchesQuery(obj, q)).toBe(true);\n    q.equalTo('name', 'bill');\n    expect(matchesQuery(obj, q)).toBe(false);\n    let img = {\n      id: new Id('Image', 'I1'),\n      tags: ['nofilter', 'latergram', 'tbt']\n    };\n    q = new Parse.Query('Image');\n    q.equalTo('tags', 'selfie');\n    expect(matchesQuery(img, q)).toBe(false);\n    q.equalTo('tags', 'tbt');\n    expect(matchesQuery(img, q)).toBe(true);\n    const q2 = new Parse.Query('Image');\n    q2.containsAll('tags', ['latergram', 'nofilter']);\n    expect(matchesQuery(img, q2)).toBe(true);\n    q2.containsAll('tags', ['latergram', 'selfie']);\n    expect(matchesQuery(img, q2)).toBe(false);\n    const u = new Parse.User();\n    u.id = 'U2';\n    q = new Parse.Query('Image');\n    q.equalTo('owner', u);\n    img = {\n      className: 'Image',\n      objectId: 'I1',\n      owner: {\n        className: '_User',\n        objectId: 'U2'\n      }\n    };\n    expect(matchesQuery(img, q)).toBe(true);\n    img.owner.objectId = 'U3';\n    expect(matchesQuery(img, q)).toBe(false);\n\n    // pointers in arrays\n    q = new Parse.Query('Image');\n    q.equalTo('owners', u);\n    img = {\n      className: 'Image',\n      objectId: 'I1',\n      owners: [{\n        className: '_User',\n        objectId: 'U2'\n      }]\n    };\n    expect(matchesQuery(img, q)).toBe(true);\n    img.owners[0].objectId = 'U3';\n    expect(matchesQuery(img, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches on inequalities","suites":["matchesQuery"],"line":206,"updatePoint":{"line":206,"column":29,"index":6742},"code":"  it('matches on inequalities', function () {\n    const player = {\n      id: new Id('Person', 'O1'),\n      score: 12,\n      name: 'Bill',\n      birthday: new Date(1980, 2, 4)\n    };\n    let q = new Parse.Query('Person');\n    q.lessThan('score', 15);\n    expect(matchesQuery(player, q)).toBe(true);\n    q.lessThan('score', 10);\n    expect(matchesQuery(player, q)).toBe(false);\n    q = new Parse.Query('Person');\n    q.lessThanOrEqualTo('score', 15);\n    expect(matchesQuery(player, q)).toBe(true);\n    q.lessThanOrEqualTo('score', 12);\n    expect(matchesQuery(player, q)).toBe(true);\n    q.lessThanOrEqualTo('score', 10);\n    expect(matchesQuery(player, q)).toBe(false);\n    q = new Parse.Query('Person');\n    q.greaterThan('score', 15);\n    expect(matchesQuery(player, q)).toBe(false);\n    q.greaterThan('score', 10);\n    expect(matchesQuery(player, q)).toBe(true);\n    q = new Parse.Query('Person');\n    q.greaterThanOrEqualTo('score', 15);\n    expect(matchesQuery(player, q)).toBe(false);\n    q.greaterThanOrEqualTo('score', 12);\n    expect(matchesQuery(player, q)).toBe(true);\n    q.greaterThanOrEqualTo('score', 10);\n    expect(matchesQuery(player, q)).toBe(true);\n    q = new Parse.Query('Person');\n    q.notEqualTo('score', 12);\n    expect(matchesQuery(player, q)).toBe(false);\n    q.notEqualTo('score', 40);\n    expect(matchesQuery(player, q)).toBe(true);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches an $or query","suites":["matchesQuery"],"line":243,"updatePoint":{"line":243,"column":26,"index":8108},"code":"  it('matches an $or query', function () {\n    const player = {\n      id: new Id('Player', 'P1'),\n      name: 'Player 1',\n      score: 12\n    };\n    const q = new Parse.Query('Player');\n    q.equalTo('name', 'Player 1');\n    const q2 = new Parse.Query('Player');\n    q2.equalTo('name', 'Player 2');\n    const orQuery = Parse.Query.or(q, q2);\n    expect(matchesQuery(player, q)).toBe(true);\n    expect(matchesQuery(player, q2)).toBe(false);\n    expect(matchesQuery(player, orQuery)).toBe(true);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"does not match $all query when value is missing","suites":["matchesQuery"],"line":258,"updatePoint":{"line":258,"column":53,"index":8635},"code":"  it('does not match $all query when value is missing', () => {\n    const player = {\n      id: new Id('Player', 'P1'),\n      name: 'Player 1',\n      score: 12\n    };\n    const q = {\n      missing: {\n        $all: [1, 2, 3]\n      }\n    };\n    expect(matchesQuery(player, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches an $and query","suites":["matchesQuery"],"line":271,"updatePoint":{"line":271,"column":27,"index":8902},"code":"  it('matches an $and query', () => {\n    const player = {\n      id: new Id('Player', 'P1'),\n      name: 'Player 1',\n      score: 12\n    };\n    const q = new Parse.Query('Player');\n    q.equalTo('name', 'Player 1');\n    const q2 = new Parse.Query('Player');\n    q2.equalTo('score', 12);\n    const q3 = new Parse.Query('Player');\n    q3.equalTo('score', 100);\n    const andQuery1 = Parse.Query.and(q, q2);\n    const andQuery2 = Parse.Query.and(q, q3);\n    expect(matchesQuery(player, q)).toBe(true);\n    expect(matchesQuery(player, q2)).toBe(true);\n    expect(matchesQuery(player, andQuery1)).toBe(true);\n    expect(matchesQuery(player, andQuery2)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches an $nor query","suites":["matchesQuery"],"line":290,"updatePoint":{"line":290,"column":27,"index":9569},"code":"  it('matches an $nor query', () => {\n    const player = {\n      id: new Id('Player', 'P1'),\n      name: 'Player 1',\n      score: 12\n    };\n    const q = new Parse.Query('Player');\n    q.equalTo('name', 'Player 1');\n    const q2 = new Parse.Query('Player');\n    q2.equalTo('name', 'Player 2');\n    const q3 = new Parse.Query('Player');\n    q3.equalTo('name', 'Player 3');\n    const norQuery1 = Parse.Query.nor(q, q2);\n    const norQuery2 = Parse.Query.nor(q2, q3);\n    expect(matchesQuery(player, q)).toBe(true);\n    expect(matchesQuery(player, q2)).toBe(false);\n    expect(matchesQuery(player, q3)).toBe(false);\n    expect(matchesQuery(player, norQuery1)).toBe(false);\n    expect(matchesQuery(player, norQuery2)).toBe(true);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches $regex queries","suites":["matchesQuery"],"line":310,"updatePoint":{"line":310,"column":28,"index":10302},"code":"  it('matches $regex queries', function () {\n    const player = {\n      id: new Id('Player', 'P1'),\n      name: 'Player 1',\n      score: 12\n    };\n    let q = new Parse.Query('Player');\n    q.startsWith('name', 'Play');\n    expect(matchesQuery(player, q)).toBe(true);\n    q.startsWith('name', 'Ploy');\n    expect(matchesQuery(player, q)).toBe(false);\n    q = new Parse.Query('Player');\n    q.endsWith('name', ' 1');\n    expect(matchesQuery(player, q)).toBe(true);\n    q.endsWith('name', ' 2');\n    expect(matchesQuery(player, q)).toBe(false);\n\n    // Check that special characters are escaped\n    player.name = 'Android-7';\n    q = new Parse.Query('Player');\n    q.contains('name', 'd-7');\n    expect(matchesQuery(player, q)).toBe(true);\n    q = new Parse.Query('Player');\n    q.matches('name', /A.d/);\n    expect(matchesQuery(player, q)).toBe(true);\n    q.matches('name', /A[^n]d/);\n    expect(matchesQuery(player, q)).toBe(false);\n\n    // Check that the string \\\\E is returned to normal\n    player.name = 'Slash \\\\E';\n    q = new Parse.Query('Player');\n    q.endsWith('name', 'h \\\\E');\n    expect(matchesQuery(player, q)).toBe(true);\n    q.endsWith('name', 'h \\\\Ee');\n    expect(matchesQuery(player, q)).toBe(false);\n    player.name = 'Slash \\\\Q and more';\n    q = new Parse.Query('Player');\n    q.contains('name', 'h \\\\Q and');\n    expect(matchesQuery(player, q)).toBe(true);\n    q.contains('name', 'h \\\\Q or');\n    expect(matchesQuery(player, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches $nearSphere queries","suites":["matchesQuery"],"line":352,"updatePoint":{"line":352,"column":33,"index":11777},"code":"  it('matches $nearSphere queries', function () {\n    let q = new Parse.Query('Checkin');\n    q.near('location', new Parse.GeoPoint(20, 20));\n    // With no max distance, any GeoPoint is 'near'\n    const pt = {\n      id: new Id('Checkin', 'C1'),\n      location: new Parse.GeoPoint(40, 40)\n    };\n    const ptUndefined = {\n      id: new Id('Checkin', 'C1')\n    };\n    const ptNull = {\n      id: new Id('Checkin', 'C1'),\n      location: null\n    };\n    expect(matchesQuery(pt, q)).toBe(true);\n    expect(matchesQuery(ptUndefined, q)).toBe(false);\n    expect(matchesQuery(ptNull, q)).toBe(false);\n    q = new Parse.Query('Checkin');\n    pt.location = new Parse.GeoPoint(40, 40);\n    q.withinRadians('location', new Parse.GeoPoint(30, 30), 0.3);\n    expect(matchesQuery(pt, q)).toBe(true);\n    q.withinRadians('location', new Parse.GeoPoint(30, 30), 0.2);\n    expect(matchesQuery(pt, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches $within queries","suites":["matchesQuery"],"line":377,"updatePoint":{"line":377,"column":29,"index":12676},"code":"  it('matches $within queries', function () {\n    const caltrainStation = {\n      id: new Id('Checkin', 'C1'),\n      location: new Parse.GeoPoint(37.776346, -122.394218),\n      name: 'Caltrain'\n    };\n    const santaClara = {\n      id: new Id('Checkin', 'C2'),\n      location: new Parse.GeoPoint(37.325635, -121.945753),\n      name: 'Santa Clara'\n    };\n    const noLocation = {\n      id: new Id('Checkin', 'C2'),\n      name: 'Santa Clara'\n    };\n    const nullLocation = {\n      id: new Id('Checkin', 'C2'),\n      location: null,\n      name: 'Santa Clara'\n    };\n    let q = new Parse.Query('Checkin').withinGeoBox('location', new Parse.GeoPoint(37.708813, -122.526398), new Parse.GeoPoint(37.822802, -122.373962));\n    expect(matchesQuery(caltrainStation, q)).toBe(true);\n    expect(matchesQuery(santaClara, q)).toBe(false);\n    expect(matchesQuery(noLocation, q)).toBe(false);\n    expect(matchesQuery(nullLocation, q)).toBe(false);\n    // Invalid rectangles\n    q = new Parse.Query('Checkin').withinGeoBox('location', new Parse.GeoPoint(37.822802, -122.373962), new Parse.GeoPoint(37.708813, -122.526398));\n    expect(matchesQuery(caltrainStation, q)).toBe(false);\n    expect(matchesQuery(santaClara, q)).toBe(false);\n    q = new Parse.Query('Checkin').withinGeoBox('location', new Parse.GeoPoint(37.708813, -122.373962), new Parse.GeoPoint(37.822802, -122.526398));\n    expect(matchesQuery(caltrainStation, q)).toBe(false);\n    expect(matchesQuery(santaClara, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches on subobjects with dot notation","suites":["matchesQuery"],"line":410,"updatePoint":{"line":410,"column":45,"index":14179},"code":"  it('matches on subobjects with dot notation', function () {\n    const message = {\n      id: new Id('Message', 'O1'),\n      text: 'content',\n      status: {\n        x: 'read',\n        y: 'delivered'\n      }\n    };\n    let q = new Parse.Query('Message');\n    q.equalTo('status.x', 'read');\n    expect(matchesQuery(message, q)).toBe(true);\n    q = new Parse.Query('Message');\n    q.equalTo('status.z', 'read');\n    expect(matchesQuery(message, q)).toBe(false);\n    q = new Parse.Query('Message');\n    q.equalTo('status.x', 'delivered');\n    expect(matchesQuery(message, q)).toBe(false);\n    q = new Parse.Query('Message');\n    q.notEqualTo('status.x', 'read');\n    expect(matchesQuery(message, q)).toBe(false);\n    q = new Parse.Query('Message');\n    q.notEqualTo('status.z', 'read');\n    expect(matchesQuery(message, q)).toBe(true);\n    q = new Parse.Query('Message');\n    q.notEqualTo('status.x', 'delivered');\n    expect(matchesQuery(message, q)).toBe(true);\n    q = new Parse.Query('Message');\n    q.exists('status.x');\n    expect(matchesQuery(message, q)).toBe(true);\n    q = new Parse.Query('Message');\n    q.exists('status.z');\n    expect(matchesQuery(message, q)).toBe(false);\n    q = new Parse.Query('Message');\n    q.exists('nonexistent.x');\n    expect(matchesQuery(message, q)).toBe(false);\n    q = new Parse.Query('Message');\n    q.doesNotExist('status.x');\n    expect(matchesQuery(message, q)).toBe(false);\n    q = new Parse.Query('Message');\n    q.doesNotExist('status.z');\n    expect(matchesQuery(message, q)).toBe(true);\n    q = new Parse.Query('Message');\n    q.doesNotExist('nonexistent.z');\n    expect(matchesQuery(message, q)).toBe(true);\n    q = new Parse.Query('Message');\n    q.equalTo('status.x', 'read');\n    q.doesNotExist('status.y');\n    expect(matchesQuery(message, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"should support containedIn with pointers","suites":["matchesQuery"],"line":467,"updatePoint":{"line":467,"column":46,"index":16120},"code":"  it('should support containedIn with pointers', () => {\n    const message = {\n      id: new Id('Message', 'O1'),\n      profile: pointer('Profile', 'abc')\n    };\n    let q = new Parse.Query('Message');\n    q.containedIn('profile', [Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'abc'\n    }), Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'def'\n    })]);\n    expect(matchesQuery(message, q)).toBe(true);\n    q = new Parse.Query('Message');\n    q.containedIn('profile', [Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'ghi'\n    }), Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'def'\n    })]);\n    expect(matchesQuery(message, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"should support containedIn with array of pointers","suites":["matchesQuery"],"line":491,"updatePoint":{"line":491,"column":55,"index":16864},"code":"  it('should support containedIn with array of pointers', () => {\n    const message = {\n      id: new Id('Message', 'O2'),\n      profiles: [pointer('Profile', 'yeahaw'), pointer('Profile', 'yes')]\n    };\n    let q = new Parse.Query('Message');\n    q.containedIn('profiles', [Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'no'\n    }), Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'yes'\n    })]);\n    expect(matchesQuery(message, q)).toBe(true);\n    q = new Parse.Query('Message');\n    q.containedIn('profiles', [Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'no'\n    }), Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'nope'\n    })]);\n    expect(matchesQuery(message, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"should support notContainedIn with pointers","suites":["matchesQuery"],"line":515,"updatePoint":{"line":515,"column":49,"index":17636},"code":"  it('should support notContainedIn with pointers', () => {\n    let message = {\n      id: new Id('Message', 'O1'),\n      profile: pointer('Profile', 'abc')\n    };\n    let q = new Parse.Query('Message');\n    q.notContainedIn('profile', [Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'def'\n    }), Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'ghi'\n    })]);\n    expect(matchesQuery(message, q)).toBe(true);\n    message = {\n      id: new Id('Message', 'O1'),\n      profile: pointer('Profile', 'def')\n    };\n    q = new Parse.Query('Message');\n    q.notContainedIn('profile', [Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'ghi'\n    }), Parse.Object.fromJSON({\n      className: 'Profile',\n      objectId: 'def'\n    })]);\n    expect(matchesQuery(message, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"should support containedIn queries with [objectId]","suites":["matchesQuery"],"line":543,"updatePoint":{"line":543,"column":56,"index":18484},"code":"  it('should support containedIn queries with [objectId]', () => {\n    let message = {\n      id: new Id('Message', 'O1'),\n      profile: pointer('Profile', 'abc')\n    };\n    let q = new Parse.Query('Message');\n    q.containedIn('profile', ['abc', 'def']);\n    expect(matchesQuery(message, q)).toBe(true);\n    message = {\n      id: new Id('Message', 'O1'),\n      profile: pointer('Profile', 'ghi')\n    };\n    q = new Parse.Query('Message');\n    q.containedIn('profile', ['abc', 'def']);\n    expect(matchesQuery(message, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"should support notContainedIn queries with [objectId]","suites":["matchesQuery"],"line":559,"updatePoint":{"line":559,"column":59,"index":19029},"code":"  it('should support notContainedIn queries with [objectId]', () => {\n    let message = {\n      id: new Id('Message', 'O1'),\n      profile: pointer('Profile', 'ghi')\n    };\n    let q = new Parse.Query('Message');\n    q.notContainedIn('profile', ['abc', 'def']);\n    expect(matchesQuery(message, q)).toBe(true);\n    message = {\n      id: new Id('Message', 'O1'),\n      profile: pointer('Profile', 'ghi')\n    };\n    q = new Parse.Query('Message');\n    q.notContainedIn('profile', ['abc', 'def', 'ghi']);\n    expect(matchesQuery(message, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"matches on Date","suites":["matchesQuery"],"line":575,"updatePoint":{"line":575,"column":21,"index":19549},"code":"  it('matches on Date', () => {\n    // given\n    const now = new Date();\n    const obj = {\n      id: new Id('Person', '01'),\n      dateObject: now,\n      dateJSON: {\n        __type: 'Date',\n        iso: now.toISOString()\n      }\n    };\n\n    // when, then: Equal\n    let q = new Parse.Query('Person');\n    q.equalTo('dateObject', now);\n    q.equalTo('dateJSON', now);\n    expect(matchesQuery(Object.assign({}, obj), q)).toBe(true);\n\n    // when, then: lessThan\n    const future = Date(now.getTime() + 1000);\n    q = new Parse.Query('Person');\n    q.lessThan('dateObject', future);\n    q.lessThan('dateJSON', future);\n    expect(matchesQuery(Object.assign({}, obj), q)).toBe(true);\n\n    // when, then: lessThanOrEqualTo\n    q = new Parse.Query('Person');\n    q.lessThanOrEqualTo('dateObject', now);\n    q.lessThanOrEqualTo('dateJSON', now);\n    expect(matchesQuery(Object.assign({}, obj), q)).toBe(true);\n\n    // when, then: greaterThan\n    const past = Date(now.getTime() - 1000);\n    q = new Parse.Query('Person');\n    q.greaterThan('dateObject', past);\n    q.greaterThan('dateJSON', past);\n    expect(matchesQuery(Object.assign({}, obj), q)).toBe(true);\n\n    // when, then: greaterThanOrEqualTo\n    q = new Parse.Query('Person');\n    q.greaterThanOrEqualTo('dateObject', now);\n    q.greaterThanOrEqualTo('dateJSON', now);\n    expect(matchesQuery(Object.assign({}, obj), q)).toBe(true);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"should support containedBy query","suites":["matchesQuery"],"line":619,"updatePoint":{"line":619,"column":38,"index":20959},"code":"  it('should support containedBy query', () => {\n    const obj1 = {\n      id: new Id('Numbers', 'N1'),\n      numbers: [0, 1, 2]\n    };\n    const obj2 = {\n      id: new Id('Numbers', 'N2'),\n      numbers: [2, 0]\n    };\n    const obj3 = {\n      id: new Id('Numbers', 'N3'),\n      numbers: [1, 2, 3, 4]\n    };\n    const q = new Parse.Query('Numbers');\n    q.containedBy('numbers', [1, 2, 3, 4, 5]);\n    expect(matchesQuery(obj1, q)).toBe(false);\n    expect(matchesQuery(obj2, q)).toBe(false);\n    expect(matchesQuery(obj3, q)).toBe(true);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"should support withinPolygon query","suites":["matchesQuery"],"line":638,"updatePoint":{"line":638,"column":40,"index":21503},"code":"  it('should support withinPolygon query', () => {\n    const sacramento = {\n      id: new Id('Location', 'L1'),\n      location: new Parse.GeoPoint(38.52, -121.5),\n      name: 'Sacramento'\n    };\n    const honolulu = {\n      id: new Id('Location', 'L2'),\n      location: new Parse.GeoPoint(21.35, -157.93),\n      name: 'Honolulu'\n    };\n    const sf = {\n      id: new Id('Location', 'L3'),\n      location: new Parse.GeoPoint(37.75, -122.68),\n      name: 'San Francisco'\n    };\n    const points = [new Parse.GeoPoint(37.85, -122.33), new Parse.GeoPoint(37.85, -122.9), new Parse.GeoPoint(37.68, -122.9), new Parse.GeoPoint(37.68, -122.33)];\n    const q = new Parse.Query('Location');\n    q.withinPolygon('location', points);\n    expect(matchesQuery(sacramento, q)).toBe(false);\n    expect(matchesQuery(honolulu, q)).toBe(false);\n    expect(matchesQuery(sf, q)).toBe(true);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"should support polygonContains query","suites":["matchesQuery"],"line":661,"updatePoint":{"line":661,"column":42,"index":22382},"code":"  it('should support polygonContains query', () => {\n    const p1 = [[0, 0], [0, 1], [1, 1], [1, 0]];\n    const p2 = [[0, 0], [0, 2], [2, 2], [2, 0]];\n    const p3 = [[10, 10], [10, 15], [15, 15], [15, 10], [10, 10]];\n    const obj1 = {\n      id: new Id('Bounds', 'B1'),\n      polygon: new Parse.Polygon(p1)\n    };\n    const obj2 = {\n      id: new Id('Bounds', 'B2'),\n      polygon: new Parse.Polygon(p2)\n    };\n    const obj3 = {\n      id: new Id('Bounds', 'B3'),\n      polygon: new Parse.Polygon(p3)\n    };\n    const point = new Parse.GeoPoint(0.5, 0.5);\n    const q = new Parse.Query('Bounds');\n    q.polygonContains('polygon', point);\n    expect(matchesQuery(obj1, q)).toBe(true);\n    expect(matchesQuery(obj2, q)).toBe(true);\n    expect(matchesQuery(obj3, q)).toBe(false);\n  });","file":"QueryTools.spec.js","skipped":false,"dir":"spec"},{"name":"should find in primary by default","suites":[],"line":15,"updatePoint":{"line":15,"column":39,"index":371},"code":"  it('should find in primary by default', done => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    Parse.Object.saveAll([obj0, obj1]).then(() => {\n      spyOn(Collection.prototype, 'find').and.callThrough();\n      const query = new Parse.Query('MyObject');\n      query.equalTo('boolKey', false);\n      return query.find().then(results => {\n        expect(results.length).toBe(1);\n        expect(results[0].get('boolKey')).toBe(false);\n        let myObjectReadPreference = null;\n        Collection.prototype.find.calls.all().forEach(call => {\n          if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n            myObjectReadPreference = true;\n            expect(call.object.s.readPreference.mode).toBe(ReadPreference.PRIMARY);\n          }\n        });\n        expect(myObjectReadPreference).toBe(true);\n        done();\n      });\n    }).catch(done.fail);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should preserve the read preference set (#4831)","suites":[],"line":39,"updatePoint":{"line":39,"column":54,"index":1378},"skipped":true,"code":"  xit('should preserve the read preference set (#4831)', async () => {\n    const {\n      MongoStorageAdapter\n    } = require('../lib/Adapters/Storage/Mongo/MongoStorageAdapter');\n    const adapterOptions = {\n      uri: 'mongodb://localhost:27017/parseServerMongoAdapterTestDatabase',\n      mongoOptions: {\n        readPreference: ReadPreference.NEAREST\n      }\n    };\n    await reconfigureServer({\n      databaseAdapter: new MongoStorageAdapter(adapterOptions)\n    });\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    const query = new Parse.Query('MyObject');\n    query.equalTo('boolKey', false);\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(false);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = true;\n        expect(call.args[1].readPreference).toBe(ReadPreference.NEAREST);\n      }\n    });\n    expect(myObjectReadPreference).toBe(true);\n  });","file":"ReadPreferenceOption.spec.js","dir":"spec"},{"name":"should change read preference in the beforeFind trigger","suites":[],"line":72,"updatePoint":{"line":72,"column":61,"index":2681},"code":"  it('should change read preference in the beforeFind trigger', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n    const query = new Parse.Query('MyObject');\n    query.equalTo('boolKey', false);\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(false);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should check read preference as case insensitive","suites":[],"line":96,"updatePoint":{"line":96,"column":54,"index":3679},"code":"  it('should check read preference as case insensitive', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'sEcOnDarY';\n    });\n    await waitForReplication();\n    const query = new Parse.Query('MyObject');\n    query.equalTo('boolKey', false);\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(false);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference in the beforeFind trigger even changing query","suites":[],"line":120,"updatePoint":{"line":120,"column":81,"index":4704},"code":"  it('should change read preference in the beforeFind trigger even changing query', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.query.equalTo('boolKey', true);\n      req.readPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n    const query = new Parse.Query('MyObject');\n    query.equalTo('boolKey', false);\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(true);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference in the beforeFind trigger even returning query","suites":[],"line":145,"updatePoint":{"line":145,"column":82,"index":5771},"code":"  it('should change read preference in the beforeFind trigger even returning query', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'SECONDARY';\n      const otherQuery = new Parse.Query('MyObject');\n      otherQuery.equalTo('boolKey', true);\n      return otherQuery;\n    });\n    await waitForReplication();\n    const query = new Parse.Query('MyObject');\n    query.equalTo('boolKey', false);\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(true);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference in the beforeFind trigger even returning promise","suites":[],"line":172,"updatePoint":{"line":172,"column":84,"index":6920},"code":"  it('should change read preference in the beforeFind trigger even returning promise', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'SECONDARY';\n      const otherQuery = new Parse.Query('MyObject');\n      otherQuery.equalTo('boolKey', true);\n      return Promise.resolve(otherQuery);\n    });\n    await waitForReplication();\n    const query = new Parse.Query('MyObject');\n    query.equalTo('boolKey', false);\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(true);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference to PRIMARY_PREFERRED","suites":[],"line":199,"updatePoint":{"line":199,"column":56,"index":8058},"code":"  it('should change read preference to PRIMARY_PREFERRED', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'PRIMARY_PREFERRED';\n    });\n    await waitForReplication();\n    const query = new Parse.Query('MyObject');\n    query.equalTo('boolKey', false);\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(false);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.PRIMARY_PREFERRED);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference to SECONDARY_PREFERRED","suites":[],"line":223,"updatePoint":{"line":223,"column":58,"index":9076},"code":"  it('should change read preference to SECONDARY_PREFERRED', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'SECONDARY_PREFERRED';\n    });\n    await waitForReplication();\n    const query = new Parse.Query('MyObject');\n    query.equalTo('boolKey', false);\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(false);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY_PREFERRED);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference to NEAREST","suites":[],"line":247,"updatePoint":{"line":247,"column":46,"index":10086},"code":"  it('should change read preference to NEAREST', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'NEAREST';\n    });\n    await waitForReplication();\n    const query = new Parse.Query('MyObject');\n    query.equalTo('boolKey', false);\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(false);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.NEAREST);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference for GET","suites":[],"line":271,"updatePoint":{"line":271,"column":43,"index":11069},"code":"  it('should change read preference for GET', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n    const query = new Parse.Query('MyObject');\n    const result = await query.get(obj0.id);\n    expect(result.get('boolKey')).toBe(false);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference for GET using API","suites":[],"line":293,"updatePoint":{"line":293,"column":53,"index":11994},"code":"  it('should change read preference for GET using API', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n    const response = await request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/classes/MyObject/' + obj0.id,\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      json: true\n    });\n    const body = response.data;\n    expect(body.boolKey).toBe(false);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference for GET directly from API","suites":[],"line":323,"updatePoint":{"line":323,"column":61,"index":13114},"code":"  it('should change read preference for GET directly from API', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    await waitForReplication();\n    const response = await request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/classes/MyObject/' + obj0.id + '?readPreference=SECONDARY',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      json: true\n    });\n    expect(response.data.boolKey).toBe(false);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference for GET using API through the beforeFind overriding API option","suites":[],"line":349,"updatePoint":{"line":349,"column":98,"index":14182},"code":"  it('should change read preference for GET using API through the beforeFind overriding API option', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'SECONDARY_PREFERRED';\n    });\n    await waitForReplication();\n    const response = await request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/classes/MyObject/' + obj0.id + '?readPreference=SECONDARY',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      json: true\n    });\n    expect(response.data.boolKey).toBe(false);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY_PREFERRED);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference for FIND using API through beforeFind trigger","suites":[],"line":378,"updatePoint":{"line":378,"column":81,"index":15349},"code":"  it('should change read preference for FIND using API through beforeFind trigger', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n    const response = await request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/classes/MyObject/',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      json: true\n    });\n    expect(response.data.results.length).toEqual(2);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference for FIND directly from API","suites":[],"line":407,"updatePoint":{"line":407,"column":62,"index":16443},"code":"  it('should change read preference for FIND directly from API', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    await waitForReplication();\n    const response = await request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/classes/MyObject?readPreference=SECONDARY',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      json: true\n    });\n    expect(response.data.results.length).toEqual(2);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference for FIND using API through the beforeFind overriding API option","suites":[],"line":433,"updatePoint":{"line":433,"column":99,"index":17502},"code":"  it('should change read preference for FIND using API through the beforeFind overriding API option', async () => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'SECONDARY_PREFERRED';\n    });\n    await waitForReplication();\n    const response = await request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/classes/MyObject/?readPreference=SECONDARY',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      json: true\n    });\n    expect(response.data.results.length).toEqual(2);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY_PREFERRED);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference for count","suites":[],"line":462,"updatePoint":{"line":462,"column":46,"index":18625},"skipped":true,"code":"  xit('should change read preference for count', done => {\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    Parse.Object.saveAll([obj0, obj1]).then(() => {\n      spyOn(Collection.prototype, 'find').and.callThrough();\n      Parse.Cloud.beforeFind('MyObject', req => {\n        req.readPreference = 'SECONDARY';\n      });\n      const query = new Parse.Query('MyObject');\n      query.equalTo('boolKey', false);\n      query.count().then(result => {\n        expect(result).toBe(1);\n        let myObjectReadPreference = null;\n        Collection.prototype.find.calls.all().forEach(call => {\n          if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n            myObjectReadPreference = call.args[1].readPreference;\n          }\n        });\n        expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n        done();\n      }).catch(done.fail);\n    });\n  });","file":"ReadPreferenceOption.spec.js","dir":"spec"},{"name":"should change read preference for `aggregate` using `beforeFind`","suites":[],"line":487,"updatePoint":{"line":487,"column":70,"index":19642},"code":"  it('should change read preference for `aggregate` using `beforeFind`', async () => {\n    // Save objects\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    // Add trigger\n    Parse.Cloud.beforeFind('MyObject', req => {\n      req.readPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n\n    // Spy on DB adapter\n    spyOn(Collection.prototype, 'aggregate').and.callThrough();\n    // Query\n    const query = new Parse.Query('MyObject');\n    const results = await query.aggregate([{\n      match: {\n        boolKey: false\n      }\n    }]);\n    // Validate\n    expect(results.length).toBe(1);\n    let readPreference = null;\n    Collection.prototype.aggregate.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') > -1) {\n        readPreference = call.args[1].readPreference;\n      }\n    });\n    expect(readPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference for `find` using query option","suites":[],"line":519,"updatePoint":{"line":519,"column":65,"index":20703},"code":"  it('should change read preference for `find` using query option', async () => {\n    // Save objects\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    await waitForReplication();\n\n    // Spy on DB adapter\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    // Query\n    const query = new Parse.Query('MyObject');\n    query.equalTo('boolKey', false);\n    query.readPreference('SECONDARY');\n    const results = await query.find();\n    // Validate\n    expect(results.length).toBe(1);\n    let myObjectReadPreference = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') >= 0) {\n        myObjectReadPreference = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change read preference for `aggregate` using query option","suites":[],"line":545,"updatePoint":{"line":545,"column":70,"index":21684},"code":"  it('should change read preference for `aggregate` using query option', async () => {\n    // Save objects\n    const obj0 = new Parse.Object('MyObject');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject');\n    obj1.set('boolKey', true);\n    await Parse.Object.saveAll([obj0, obj1]);\n    await waitForReplication();\n\n    // Spy on DB adapter\n    spyOn(Collection.prototype, 'aggregate').and.callThrough();\n    // Query\n    const query = new Parse.Query('MyObject');\n    query.readPreference('SECONDARY');\n    const results = await query.aggregate([{\n      match: {\n        boolKey: false\n      }\n    }]);\n    // Validate\n    expect(results.length).toBe(1);\n    let readPreference = null;\n    Collection.prototype.aggregate.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject') > -1) {\n        readPreference = call.args[1].readPreference;\n      }\n    });\n    expect(readPreference).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should find includes in same replica of readPreference by default","suites":[],"line":574,"updatePoint":{"line":574,"column":71,"index":22675},"code":"  it('should find includes in same replica of readPreference by default', async () => {\n    const obj0 = new Parse.Object('MyObject0');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject1');\n    obj1.set('boolKey', true);\n    obj1.set('myObject0', obj0);\n    const obj2 = new Parse.Object('MyObject2');\n    obj2.set('boolKey', false);\n    obj2.set('myObject1', obj1);\n    await Parse.Object.saveAll([obj0, obj1, obj2]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject2', req => {\n      req.readPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n    const query = new Parse.Query('MyObject2');\n    query.equalTo('boolKey', false);\n    query.include('myObject1');\n    query.include('myObject1.myObject0');\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    const firstResult = results[0];\n    expect(firstResult.get('boolKey')).toBe(false);\n    expect(firstResult.get('myObject1').get('boolKey')).toBe(true);\n    expect(firstResult.get('myObject1').get('myObject0').get('boolKey')).toBe(false);\n    let myObjectReadPreference0 = null;\n    let myObjectReadPreference1 = null;\n    let myObjectReadPreference2 = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject0') >= 0) {\n        myObjectReadPreference0 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject1') >= 0) {\n        myObjectReadPreference1 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject2') >= 0) {\n        myObjectReadPreference2 = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference0).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference1).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference2).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change includes read preference","suites":[],"line":617,"updatePoint":{"line":617,"column":44,"index":24600},"code":"  it('should change includes read preference', async () => {\n    const obj0 = new Parse.Object('MyObject0');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject1');\n    obj1.set('boolKey', true);\n    obj1.set('myObject0', obj0);\n    const obj2 = new Parse.Object('MyObject2');\n    obj2.set('boolKey', false);\n    obj2.set('myObject1', obj1);\n    await Parse.Object.saveAll([obj0, obj1, obj2]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject2', req => {\n      req.readPreference = 'SECONDARY_PREFERRED';\n      req.includeReadPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n    const query = new Parse.Query('MyObject2');\n    query.equalTo('boolKey', false);\n    query.include('myObject1');\n    query.include('myObject1.myObject0');\n    const results = await query.find();\n    expect(results.length).toBe(1);\n    const firstResult = results[0];\n    expect(firstResult.get('boolKey')).toBe(false);\n    expect(firstResult.get('myObject1').get('boolKey')).toBe(true);\n    expect(firstResult.get('myObject1').get('myObject0').get('boolKey')).toBe(false);\n    let myObjectReadPreference0 = null;\n    let myObjectReadPreference1 = null;\n    let myObjectReadPreference2 = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject0') >= 0) {\n        myObjectReadPreference0 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject1') >= 0) {\n        myObjectReadPreference1 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject2') >= 0) {\n        myObjectReadPreference2 = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference0).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference1).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference2).toEqual(ReadPreference.SECONDARY_PREFERRED);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change includes read preference when finding through API","suites":[],"line":661,"updatePoint":{"line":661,"column":69,"index":26617},"code":"  it('should change includes read preference when finding through API', async () => {\n    const obj0 = new Parse.Object('MyObject0');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject1');\n    obj1.set('boolKey', true);\n    obj1.set('myObject0', obj0);\n    const obj2 = new Parse.Object('MyObject2');\n    obj2.set('boolKey', false);\n    obj2.set('myObject1', obj1);\n    await Parse.Object.saveAll([obj0, obj1, obj2]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    await waitForReplication();\n    const response = await request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/classes/MyObject2/' + obj2.id + '?include=' + JSON.stringify(['myObject1', 'myObject1.myObject0']) + '&readPreference=SECONDARY_PREFERRED&includeReadPreference=SECONDARY',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      json: true\n    });\n    const firstResult = response.data;\n    expect(firstResult.boolKey).toBe(false);\n    expect(firstResult.myObject1.boolKey).toBe(true);\n    expect(firstResult.myObject1.myObject0.boolKey).toBe(false);\n    let myObjectReadPreference0 = null;\n    let myObjectReadPreference1 = null;\n    let myObjectReadPreference2 = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject0') >= 0) {\n        myObjectReadPreference0 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject1') >= 0) {\n        myObjectReadPreference1 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject2') >= 0) {\n        myObjectReadPreference2 = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference0).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference1).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference2).toEqual(ReadPreference.SECONDARY_PREFERRED);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change includes read preference when getting through API","suites":[],"line":704,"updatePoint":{"line":704,"column":69,"index":28604},"code":"  it('should change includes read preference when getting through API', async () => {\n    const obj0 = new Parse.Object('MyObject0');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject1');\n    obj1.set('boolKey', true);\n    obj1.set('myObject0', obj0);\n    const obj2 = new Parse.Object('MyObject2');\n    obj2.set('boolKey', false);\n    obj2.set('myObject1', obj1);\n    await Parse.Object.saveAll([obj0, obj1, obj2]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    await waitForReplication();\n    const response = await request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/classes/MyObject2?where=' + JSON.stringify({\n        boolKey: false\n      }) + '&include=' + JSON.stringify(['myObject1', 'myObject1.myObject0']) + '&readPreference=SECONDARY_PREFERRED&includeReadPreference=SECONDARY',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      json: true\n    });\n    expect(response.data.results.length).toBe(1);\n    const firstResult = response.data.results[0];\n    expect(firstResult.boolKey).toBe(false);\n    expect(firstResult.myObject1.boolKey).toBe(true);\n    expect(firstResult.myObject1.myObject0.boolKey).toBe(false);\n    let myObjectReadPreference0 = null;\n    let myObjectReadPreference1 = null;\n    let myObjectReadPreference2 = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject0') >= 0) {\n        myObjectReadPreference0 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject1') >= 0) {\n        myObjectReadPreference1 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject2') >= 0) {\n        myObjectReadPreference2 = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference0).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference1).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference2).toEqual(ReadPreference.SECONDARY_PREFERRED);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should find subqueries in same replica of readPreference by default","suites":[],"line":750,"updatePoint":{"line":750,"column":73,"index":30703},"code":"  it('should find subqueries in same replica of readPreference by default', async () => {\n    const obj0 = new Parse.Object('MyObject0');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject1');\n    obj1.set('boolKey', true);\n    obj1.set('myObject0', obj0);\n    const obj2 = new Parse.Object('MyObject2');\n    obj2.set('boolKey', false);\n    obj2.set('myObject1', obj1);\n    await Parse.Object.saveAll([obj0, obj1, obj2]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject2', req => {\n      req.readPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n    const query0 = new Parse.Query('MyObject0');\n    query0.equalTo('boolKey', false);\n    const query1 = new Parse.Query('MyObject1');\n    query1.matchesQuery('myObject0', query0);\n    const query2 = new Parse.Query('MyObject2');\n    query2.matchesQuery('myObject1', query1);\n    const results = await query2.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(false);\n    let myObjectReadPreference0 = null;\n    let myObjectReadPreference1 = null;\n    let myObjectReadPreference2 = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject0') >= 0) {\n        myObjectReadPreference0 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject1') >= 0) {\n        myObjectReadPreference1 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject2') >= 0) {\n        myObjectReadPreference2 = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference0).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference1).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference2).toEqual(ReadPreference.SECONDARY);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change subqueries read preference when using matchesQuery","suites":[],"line":792,"updatePoint":{"line":792,"column":70,"index":32582},"code":"  it('should change subqueries read preference when using matchesQuery', async () => {\n    const obj0 = new Parse.Object('MyObject0');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject1');\n    obj1.set('boolKey', true);\n    obj1.set('myObject0', obj0);\n    const obj2 = new Parse.Object('MyObject2');\n    obj2.set('boolKey', false);\n    obj2.set('myObject1', obj1);\n    await Parse.Object.saveAll([obj0, obj1, obj2]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject2', req => {\n      req.readPreference = 'SECONDARY_PREFERRED';\n      req.subqueryReadPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n    const query0 = new Parse.Query('MyObject0');\n    query0.equalTo('boolKey', false);\n    const query1 = new Parse.Query('MyObject1');\n    query1.matchesQuery('myObject0', query0);\n    const query2 = new Parse.Query('MyObject2');\n    query2.matchesQuery('myObject1', query1);\n    const results = await query2.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(false);\n    let myObjectReadPreference0 = null;\n    let myObjectReadPreference1 = null;\n    let myObjectReadPreference2 = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject0') >= 0) {\n        myObjectReadPreference0 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject1') >= 0) {\n        myObjectReadPreference1 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject2') >= 0) {\n        myObjectReadPreference2 = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference0).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference1).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference2).toEqual(ReadPreference.SECONDARY_PREFERRED);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change subqueries read preference when using doesNotMatchQuery","suites":[],"line":835,"updatePoint":{"line":835,"column":75,"index":34534},"code":"  it('should change subqueries read preference when using doesNotMatchQuery', async () => {\n    const obj0 = new Parse.Object('MyObject0');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject1');\n    obj1.set('boolKey', true);\n    obj1.set('myObject0', obj0);\n    const obj2 = new Parse.Object('MyObject2');\n    obj2.set('boolKey', false);\n    obj2.set('myObject1', obj1);\n    await Parse.Object.saveAll([obj0, obj1, obj2]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject2', req => {\n      req.readPreference = 'SECONDARY_PREFERRED';\n      req.subqueryReadPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n    const query0 = new Parse.Query('MyObject0');\n    query0.equalTo('boolKey', false);\n    const query1 = new Parse.Query('MyObject1');\n    query1.doesNotMatchQuery('myObject0', query0);\n    const query2 = new Parse.Query('MyObject2');\n    query2.doesNotMatchQuery('myObject1', query1);\n    const results = await query2.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(false);\n    let myObjectReadPreference0 = null;\n    let myObjectReadPreference1 = null;\n    let myObjectReadPreference2 = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject0') >= 0) {\n        myObjectReadPreference0 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject1') >= 0) {\n        myObjectReadPreference1 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject2') >= 0) {\n        myObjectReadPreference2 = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference0).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference1).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference2).toEqual(ReadPreference.SECONDARY_PREFERRED);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change subqueries read preference when using matchesKeyInQuery and doesNotMatchKeyInQuery","suites":[],"line":878,"updatePoint":{"line":878,"column":102,"index":36523},"code":"  it('should change subqueries read preference when using matchesKeyInQuery and doesNotMatchKeyInQuery', async () => {\n    const obj0 = new Parse.Object('MyObject0');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject1');\n    obj1.set('boolKey', true);\n    obj1.set('myObject0', obj0);\n    const obj2 = new Parse.Object('MyObject2');\n    obj2.set('boolKey', false);\n    obj2.set('myObject1', obj1);\n    await Parse.Object.saveAll([obj0, obj1, obj2]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    Parse.Cloud.beforeFind('MyObject2', req => {\n      req.readPreference = 'SECONDARY_PREFERRED';\n      req.subqueryReadPreference = 'SECONDARY';\n    });\n    await waitForReplication();\n    const query0 = new Parse.Query('MyObject0');\n    query0.equalTo('boolKey', false);\n    const query1 = new Parse.Query('MyObject1');\n    query1.equalTo('boolKey', true);\n    const query2 = new Parse.Query('MyObject2');\n    query2.matchesKeyInQuery('boolKey', 'boolKey', query0);\n    query2.doesNotMatchKeyInQuery('boolKey', 'boolKey', query1);\n    const results = await query2.find();\n    expect(results.length).toBe(1);\n    expect(results[0].get('boolKey')).toBe(false);\n    let myObjectReadPreference0 = null;\n    let myObjectReadPreference1 = null;\n    let myObjectReadPreference2 = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject0') >= 0) {\n        myObjectReadPreference0 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject1') >= 0) {\n        myObjectReadPreference1 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject2') >= 0) {\n        myObjectReadPreference2 = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference0).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference1).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference2).toEqual(ReadPreference.SECONDARY_PREFERRED);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should change subqueries read preference when using matchesKeyInQuery and doesNotMatchKeyInQuery to find through API","suites":[],"line":922,"updatePoint":{"line":922,"column":122,"index":38592},"code":"  it('should change subqueries read preference when using matchesKeyInQuery and doesNotMatchKeyInQuery to find through API', async () => {\n    const obj0 = new Parse.Object('MyObject0');\n    obj0.set('boolKey', false);\n    const obj1 = new Parse.Object('MyObject1');\n    obj1.set('boolKey', true);\n    obj1.set('myObject0', obj0);\n    const obj2 = new Parse.Object('MyObject2');\n    obj2.set('boolKey', false);\n    obj2.set('myObject1', obj1);\n    await Parse.Object.saveAll([obj0, obj1, obj2]);\n    spyOn(Collection.prototype, 'find').and.callThrough();\n    await waitForReplication();\n    const whereString = JSON.stringify({\n      boolKey: {\n        $select: {\n          query: {\n            className: 'MyObject0',\n            where: {\n              boolKey: false\n            }\n          },\n          key: 'boolKey'\n        },\n        $dontSelect: {\n          query: {\n            className: 'MyObject1',\n            where: {\n              boolKey: true\n            }\n          },\n          key: 'boolKey'\n        }\n      }\n    });\n    const response = await request({\n      method: 'GET',\n      url: 'http://localhost:8378/1/classes/MyObject2/?where=' + whereString + '&readPreference=SECONDARY_PREFERRED&subqueryReadPreference=SECONDARY',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      },\n      json: true\n    });\n    expect(response.data.results.length).toBe(1);\n    expect(response.data.results[0].boolKey).toBe(false);\n    let myObjectReadPreference0 = null;\n    let myObjectReadPreference1 = null;\n    let myObjectReadPreference2 = null;\n    Collection.prototype.find.calls.all().forEach(call => {\n      if (call.object.s.namespace.collection.indexOf('MyObject0') >= 0) {\n        myObjectReadPreference0 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject1') >= 0) {\n        myObjectReadPreference1 = call.args[1].readPreference;\n      }\n      if (call.object.s.namespace.collection.indexOf('MyObject2') >= 0) {\n        myObjectReadPreference2 = call.args[1].readPreference;\n      }\n    });\n    expect(myObjectReadPreference0).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference1).toEqual(ReadPreference.SECONDARY);\n    expect(myObjectReadPreference2).toEqual(ReadPreference.SECONDARY_PREFERRED);\n  });","file":"ReadPreferenceOption.spec.js","skipped":false,"dir":"spec"},{"name":"should get/set/clear","suites":[],"line":22,"updatePoint":{"line":22,"column":26,"index":650},"code":"  it('should get/set/clear', done => {\n    const cacheNaN = new RedisCacheAdapter({\n      ttl: NaN\n    });\n    cacheNaN.put(KEY, VALUE).then(() => cacheNaN.get(KEY)).then(value => expect(value).toEqual(VALUE)).then(() => cacheNaN.clear()).then(() => cacheNaN.get(KEY)).then(value => expect(value).toEqual(null)).then(() => cacheNaN.clear()).then(done);\n  });","file":"RedisCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should expire after ttl","suites":[],"line":28,"updatePoint":{"line":28,"column":29,"index":1012},"code":"  it('should expire after ttl', done => {\n    cache.put(KEY, VALUE).then(() => cache.get(KEY)).then(value => expect(value).toEqual(VALUE)).then(wait.bind(null, 102)).then(() => cache.get(KEY)).then(value => expect(value).toEqual(null)).then(done);\n  });","file":"RedisCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should not store value for ttl=0","suites":[],"line":31,"updatePoint":{"line":31,"column":38,"index":1275},"code":"  it('should not store value for ttl=0', done => {\n    cache.put(KEY, VALUE, 0).then(() => cache.get(KEY)).then(value => expect(value).toEqual(null)).then(done);\n  });","file":"RedisCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should not expire when ttl=Infinity","suites":[],"line":34,"updatePoint":{"line":34,"column":41,"index":1446},"code":"  it('should not expire when ttl=Infinity', done => {\n    cache.put(KEY, VALUE, Infinity).then(() => cache.get(KEY)).then(value => expect(value).toEqual(VALUE)).then(wait.bind(null, 102)).then(() => cache.get(KEY)).then(value => expect(value).toEqual(VALUE)).then(done);\n  });","file":"RedisCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should fallback to default ttl","suites":[],"line":37,"updatePoint":{"line":37,"column":36,"index":1718},"code":"  it('should fallback to default ttl', done => {\n    let promise = Promise.resolve();\n    [-100, null, undefined, 'not number', true].forEach(ttl => {\n      promise = promise.then(() => cache.put(KEY, VALUE, ttl).then(() => cache.get(KEY)).then(value => expect(value).toEqual(VALUE)).then(wait.bind(null, 102)).then(() => cache.get(KEY)).then(value => expect(value).toEqual(null)));\n    });\n    promise.then(done);\n  });","file":"RedisCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"should find un-expired records","suites":[],"line":44,"updatePoint":{"line":44,"column":36,"index":2139},"code":"  it('should find un-expired records', done => {\n    cache.put(KEY, VALUE).then(() => cache.get(KEY)).then(value => expect(value).toEqual(VALUE)).then(wait.bind(null, 1)).then(() => cache.get(KEY)).then(value => expect(value).not.toEqual(null)).then(done);\n  });","file":"RedisCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"handleShutdown, close connection","suites":[],"line":47,"updatePoint":{"line":47,"column":38,"index":2404},"code":"  it('handleShutdown, close connection', async () => {\n    await cache.handleShutdown();\n    setTimeout(() => {\n      expect(cache.client.connected).toBe(false);\n    }, 0);\n  });","file":"RedisCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"it should clear completed operations from queue","suites":[],"line":70,"updatePoint":{"line":70,"column":53,"index":3060},"code":"  it('it should clear completed operations from queue', done => {\n    const cache = new RedisCacheAdapter({\n      ttl: NaN\n    });\n\n    // execute a bunch of operations in sequence\n    let promise = Promise.resolve();\n    for (let index = 1; index < 100; index++) {\n      promise = promise.then(() => {\n        const key = `${index}`;\n        return cache.put(key, VALUE).then(() => expect(getQueueCount(cache)).toEqual(0)).then(() => cache.get(key)).then(() => expect(getQueueCount(cache)).toEqual(0)).then(() => cache.clear()).then(() => expect(getQueueCount(cache)).toEqual(0));\n      });\n    }\n\n    // at the end the queue should be empty\n    promise.then(() => expect(getQueueCount(cache)).toEqual(0)).then(done);\n  });","file":"RedisCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"it should count per key chained operations correctly","suites":[],"line":87,"updatePoint":{"line":87,"column":58,"index":3790},"code":"  it('it should count per key chained operations correctly', done => {\n    const cache = new RedisCacheAdapter({\n      ttl: NaN\n    });\n    let key1Promise = Promise.resolve();\n    let key2Promise = Promise.resolve();\n    for (let index = 1; index < 100; index++) {\n      key1Promise = cache.put(KEY1, VALUE);\n      key2Promise = cache.put(KEY2, VALUE);\n      // per key chain should be equal to index, which is the\n      // total number of operations on that key\n      expect(getQueueCountForKey(cache, KEY1)).toEqual(index);\n      expect(getQueueCountForKey(cache, KEY2)).toEqual(index);\n      // the total keys counts should be equal to the different keys\n      // we have currently being processed.\n      expect(getQueueCount(cache)).toEqual(2);\n    }\n\n    // at the end the queue should be empty\n    Promise.all([key1Promise, key2Promise]).then(() => expect(getQueueCount(cache)).toEqual(0)).then(done);\n  });","file":"RedisCacheAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"can create publisher","suites":["RedisPubSub"],"line":9,"updatePoint":{"line":9,"column":26,"index":335},"code":"  it('can create publisher', function () {\n    RedisPubSub.createPublisher({\n      redisURL: 'redisAddress',\n      redisOptions: {\n        socket_keepalive: true\n      }\n    });\n    const redis = require('redis');\n    expect(redis.createClient).toHaveBeenCalledWith('redisAddress', {\n      socket_keepalive: true,\n      no_ready_check: true\n    });\n  });","file":"RedisPubSub.spec.js","skipped":false,"dir":"spec"},{"name":"can create subscriber","suites":["RedisPubSub"],"line":22,"updatePoint":{"line":22,"column":27,"index":691},"code":"  it('can create subscriber', function () {\n    RedisPubSub.createSubscriber({\n      redisURL: 'redisAddress',\n      redisOptions: {\n        socket_keepalive: true\n      }\n    });\n    const redis = require('redis');\n    expect(redis.createClient).toHaveBeenCalledWith('redisAddress', {\n      socket_keepalive: true,\n      no_ready_check: true\n    });\n  });","file":"RedisPubSub.spec.js","skipped":false,"dir":"spec"},{"name":"should not work with regex","suites":["Regex Vulnerabilities","on session token"],"line":42,"updatePoint":{"line":42,"column":34,"index":1223},"code":"    it('should not work with regex', async function () {\n      try {\n        await request({\n          url: `${serverURL}/users/me`,\n          method: 'POST',\n          headers,\n          body: JSON.stringify({\n            ...keys,\n            _SessionToken: {\n              $regex: this.partialSessionToken\n            },\n            _method: 'GET'\n          })\n        });\n        fail('should not work');\n      } catch (e) {\n        expect(e.data.code).toEqual(209);\n        expect(e.data.error).toEqual('Invalid session token');\n      }\n    });","file":"RegexVulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"should work with plain token","suites":["Regex Vulnerabilities","on session token"],"line":62,"updatePoint":{"line":62,"column":36,"index":1774},"code":"    it('should work with plain token', async function () {\n      const meResponse = await request({\n        url: `${serverURL}/users/me`,\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n          ...keys,\n          _SessionToken: this.sessionToken,\n          _method: 'GET'\n        })\n      });\n      expect(meResponse.data.objectId).toEqual(this.objectId);\n      expect(meResponse.data.sessionToken).toEqual(this.sessionToken);\n    });","file":"RegexVulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"should not work with regex","suites":["Regex Vulnerabilities","on verify e-mail"],"line":84,"updatePoint":{"line":84,"column":34,"index":2472},"code":"    it('should not work with regex', async function () {\n      expect(this.user.get('emailVerified')).toEqual(false);\n      await request({\n        url: `${serverURL}/apps/test/verify_email?username=someemail@somedomain.com&token[$regex]=`,\n        method: 'GET'\n      });\n      await this.user.fetch({\n        useMasterKey: true\n      });\n      expect(this.user.get('emailVerified')).toEqual(false);\n    });","file":"RegexVulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"should work with plain token","suites":["Regex Vulnerabilities","on verify e-mail"],"line":95,"updatePoint":{"line":95,"column":36,"index":2883},"code":"    it('should work with plain token', async function () {\n      expect(this.user.get('emailVerified')).toEqual(false);\n      // It should work\n      await request({\n        url: `${serverURL}/apps/test/verify_email?username=someemail@somedomain.com&token=${this.user.get('_email_verify_token')}`,\n        method: 'GET'\n      });\n      await this.user.fetch({\n        useMasterKey: true\n      });\n      expect(this.user.get('emailVerified')).toEqual(true);\n    });","file":"RegexVulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"should not work with regex","suites":["Regex Vulnerabilities","on password reset"],"line":112,"updatePoint":{"line":112,"column":34,"index":3527},"code":"    it('should not work with regex', async function () {\n      expect(this.user.id).toEqual(this.objectId);\n      await request({\n        url: `${serverURL}/requestPasswordReset`,\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n          ...keys,\n          _method: 'POST',\n          email: 'someemail@somedomain.com'\n        })\n      });\n      await this.user.fetch({\n        useMasterKey: true\n      });\n      const passwordResetResponse = await request({\n        url: `${serverURL}/apps/test/request_password_reset?username=someemail@somedomain.com&token[$regex]=`,\n        method: 'GET'\n      });\n      expect(passwordResetResponse.status).toEqual(302);\n      expect(passwordResetResponse.headers.location).toMatch(`\\\\/invalid\\\\_link\\\\.html`);\n      await request({\n        url: `${serverURL}/apps/test/request_password_reset`,\n        method: 'POST',\n        body: {\n          token: {\n            $regex: ''\n          },\n          username: 'someemail@somedomain.com',\n          new_password: 'newpassword'\n        }\n      });\n      try {\n        await Parse.User.logIn('someemail@somedomain.com', 'newpassword');\n        fail('should not work');\n      } catch (e) {\n        expect(e.code).toEqual(Parse.Error.OBJECT_NOT_FOUND);\n        expect(e.message).toEqual('Invalid username/password.');\n      }\n    });","file":"RegexVulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"should work with plain token","suites":["Regex Vulnerabilities","on password reset"],"line":152,"updatePoint":{"line":152,"column":36,"index":4869},"code":"    it('should work with plain token', async function () {\n      expect(this.user.id).toEqual(this.objectId);\n      await request({\n        url: `${serverURL}/requestPasswordReset`,\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n          ...keys,\n          _method: 'POST',\n          email: 'someemail@somedomain.com'\n        })\n      });\n      await this.user.fetch({\n        useMasterKey: true\n      });\n      const token = this.user.get('_perishable_token');\n      const passwordResetResponse = await request({\n        url: `${serverURL}/apps/test/request_password_reset?username=someemail@somedomain.com&token=${token}`,\n        method: 'GET'\n      });\n      expect(passwordResetResponse.status).toEqual(302);\n      expect(passwordResetResponse.headers.location).toMatch(`\\\\/choose\\\\_password\\\\?token\\\\=${token}\\\\&`);\n      await request({\n        url: `${serverURL}/apps/test/request_password_reset`,\n        method: 'POST',\n        body: {\n          token,\n          username: 'someemail@somedomain.com',\n          new_password: 'newpassword'\n        }\n      });\n      const userAgain = await Parse.User.logIn('someemail@somedomain.com', 'newpassword');\n      expect(userAgain.id).toEqual(this.objectId);\n    });","file":"RegexVulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"handles _id","suites":["rest create"],"line":17,"updatePoint":{"line":17,"column":17,"index":507},"code":"  it('handles _id', done => {\n    rest.create(config, auth.nobody(config), 'Foo', {}).then(() => database.adapter.find('Foo', {\n      fields: {}\n    }, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const obj = results[0];\n      expect(typeof obj.objectId).toEqual('string');\n      expect(obj.objectId.length).toEqual(10);\n      expect(obj._id).toBeUndefined();\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"can use custom _id size","suites":["rest create"],"line":29,"updatePoint":{"line":29,"column":29,"index":936},"code":"  it('can use custom _id size', done => {\n    config.objectIdSize = 20;\n    rest.create(config, auth.nobody(config), 'Foo', {}).then(() => database.adapter.find('Foo', {\n      fields: {}\n    }, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const obj = results[0];\n      expect(typeof obj.objectId).toEqual('string');\n      expect(obj.objectId.length).toEqual(20);\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"should use objectId from client when allowCustomObjectId true","suites":["rest create"],"line":41,"updatePoint":{"line":41,"column":67,"index":1394},"code":"  it('should use objectId from client when allowCustomObjectId true', async () => {\n    config.allowCustomObjectId = true;\n\n    // use time as unique custom id for test reusability\n    const customId = `${Date.now()}`;\n    const obj = {\n      objectId: customId\n    };\n    const {\n      status,\n      response: {\n        objectId\n      }\n    } = await rest.create(config, auth.nobody(config), 'MyClass', obj);\n    expect(status).toEqual(201);\n    expect(objectId).toEqual(customId);\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"should throw on invalid objectId when allowCustomObjectId true","suites":["rest create"],"line":58,"updatePoint":{"line":58,"column":68,"index":1884},"code":"  it('should throw on invalid objectId when allowCustomObjectId true', () => {\n    config.allowCustomObjectId = true;\n    const objIdNull = {\n      objectId: null\n    };\n    const objIdUndef = {\n      objectId: undefined\n    };\n    const objIdEmpty = {\n      objectId: ''\n    };\n    const err = 'objectId must not be empty, null or undefined';\n    expect(() => rest.create(config, auth.nobody(config), 'MyClass', objIdEmpty)).toThrowError(err);\n    expect(() => rest.create(config, auth.nobody(config), 'MyClass', objIdNull)).toThrowError(err);\n    expect(() => rest.create(config, auth.nobody(config), 'MyClass', objIdUndef)).toThrowError(err);\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"should generate objectId when not set by client with allowCustomObjectId true","suites":["rest create"],"line":74,"updatePoint":{"line":74,"column":83,"index":2551},"code":"  it('should generate objectId when not set by client with allowCustomObjectId true', async () => {\n    config.allowCustomObjectId = true;\n    const {\n      status,\n      response: {\n        objectId\n      }\n    } = await rest.create(config, auth.nobody(config), 'MyClass', {});\n    expect(status).toEqual(201);\n    expect(objectId).toBeDefined();\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"is backwards compatible when _id size changes","suites":["rest create"],"line":85,"updatePoint":{"line":85,"column":51,"index":2873},"code":"  it('is backwards compatible when _id size changes', done => {\n    rest.create(config, auth.nobody(config), 'Foo', {\n      size: 10\n    }).then(() => {\n      config.objectIdSize = 20;\n      return rest.find(config, auth.nobody(config), 'Foo', {\n        size: 10\n      });\n    }).then(response => {\n      expect(response.results.length).toEqual(1);\n      expect(response.results[0].objectId.length).toEqual(10);\n      return rest.update(config, auth.nobody(config), 'Foo', {\n        objectId: response.results[0].objectId\n      }, {\n        update: 20\n      });\n    }).then(() => {\n      return rest.find(config, auth.nobody(config), 'Foo', {\n        size: 10\n      });\n    }).then(response => {\n      expect(response.results.length).toEqual(1);\n      expect(response.results[0].objectId.length).toEqual(10);\n      expect(response.results[0].update).toEqual(20);\n      return rest.create(config, auth.nobody(config), 'Foo', {\n        size: 20\n      });\n    }).then(() => {\n      config.objectIdSize = 10;\n      return rest.find(config, auth.nobody(config), 'Foo', {\n        size: 20\n      });\n    }).then(response => {\n      expect(response.results.length).toEqual(1);\n      expect(response.results[0].objectId.length).toEqual(20);\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"handles array, object, date","suites":["rest create"],"line":123,"updatePoint":{"line":123,"column":33,"index":4115},"code":"  it('handles array, object, date', done => {\n    const now = new Date();\n    const obj = {\n      array: [1, 2, 3],\n      object: {\n        foo: 'bar'\n      },\n      date: Parse._encode(now)\n    };\n    rest.create(config, auth.nobody(config), 'MyClass', obj).then(() => database.adapter.find('MyClass', {\n      fields: {\n        array: {\n          type: 'Array'\n        },\n        object: {\n          type: 'Object'\n        },\n        date: {\n          type: 'Date'\n        }\n      }\n    }, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const mob = results[0];\n      expect(mob.array instanceof Array).toBe(true);\n      expect(typeof mob.object).toBe('object');\n      expect(mob.date.__type).toBe('Date');\n      expect(new Date(mob.date.iso).getTime()).toBe(now.getTime());\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"handles object and subdocument","suites":["rest create"],"line":154,"updatePoint":{"line":154,"column":36,"index":4948},"code":"  it('handles object and subdocument', done => {\n    const obj = {\n      subdoc: {\n        foo: 'bar',\n        wu: 'tan'\n      }\n    };\n    Parse.Cloud.beforeSave('MyClass', function () {\n      // this beforeSave trigger should do nothing but can mess with the object\n    });\n    rest.create(config, auth.nobody(config), 'MyClass', obj).then(() => database.adapter.find('MyClass', {\n      fields: {}\n    }, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const mob = results[0];\n      expect(typeof mob.subdoc).toBe('object');\n      expect(mob.subdoc.foo).toBe('bar');\n      expect(mob.subdoc.wu).toBe('tan');\n      expect(typeof mob.objectId).toEqual('string');\n      const obj = {\n        'subdoc.wu': 'clan'\n      };\n      return rest.update(config, auth.nobody(config), 'MyClass', {\n        objectId: mob.objectId\n      }, obj);\n    }).then(() => database.adapter.find('MyClass', {\n      fields: {}\n    }, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const mob = results[0];\n      expect(typeof mob.subdoc).toBe('object');\n      expect(mob.subdoc.foo).toBe('bar');\n      expect(mob.subdoc.wu).toBe('clan');\n      done();\n    }).catch(done.fail);\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"handles create on non-existent class when disabled client class creation","suites":["rest create"],"line":190,"updatePoint":{"line":190,"column":78,"index":6201},"code":"  it('handles create on non-existent class when disabled client class creation', done => {\n    const customConfig = Object.assign({}, config, {\n      allowClientClassCreation: false\n    });\n    rest.create(customConfig, auth.nobody(customConfig), 'ClientClassCreation', {}).then(() => {\n      fail('Should throw an error');\n      done();\n    }, err => {\n      expect(err.code).toEqual(Parse.Error.OPERATION_FORBIDDEN);\n      expect(err.message).toEqual('This user is not allowed to access ' + 'non-existent class: ClientClassCreation');\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"handles create on existent class when disabled client class creation","suites":["rest create"],"line":203,"updatePoint":{"line":203,"column":74,"index":6762},"code":"  it('handles create on existent class when disabled client class creation', async () => {\n    const customConfig = Object.assign({}, config, {\n      allowClientClassCreation: false\n    });\n    const schema = await config.database.loadSchema();\n    const actualSchema = await schema.addClassIfNotExists('ClientClassCreation', {});\n    expect(actualSchema.className).toEqual('ClientClassCreation');\n    await schema.reloadData({\n      clearCache: true\n    });\n    // Should not throw\n    await rest.create(customConfig, auth.nobody(customConfig), 'ClientClassCreation', {});\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"handles user signup","suites":["rest create"],"line":216,"updatePoint":{"line":216,"column":25,"index":7293},"code":"  it('handles user signup', done => {\n    const user = {\n      username: 'asdf',\n      password: 'zxcv',\n      foo: 'bar'\n    };\n    rest.create(config, auth.nobody(config), '_User', user).then(r => {\n      expect(Object.keys(r.response).length).toEqual(3);\n      expect(typeof r.response.objectId).toEqual('string');\n      expect(typeof r.response.createdAt).toEqual('string');\n      expect(typeof r.response.sessionToken).toEqual('string');\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"handles anonymous user signup","suites":["rest create"],"line":230,"updatePoint":{"line":230,"column":35,"index":7774},"code":"  it('handles anonymous user signup', done => {\n    const data1 = {\n      authData: {\n        anonymous: {\n          id: '00000000-0000-0000-0000-000000000001'\n        }\n      }\n    };\n    const data2 = {\n      authData: {\n        anonymous: {\n          id: '00000000-0000-0000-0000-000000000002'\n        }\n      }\n    };\n    let username1;\n    rest.create(config, auth.nobody(config), '_User', data1).then(r => {\n      expect(typeof r.response.objectId).toEqual('string');\n      expect(typeof r.response.createdAt).toEqual('string');\n      expect(typeof r.response.sessionToken).toEqual('string');\n      expect(typeof r.response.username).toEqual('string');\n      return rest.create(config, auth.nobody(config), '_User', data1);\n    }).then(r => {\n      expect(typeof r.response.objectId).toEqual('string');\n      expect(typeof r.response.createdAt).toEqual('string');\n      expect(typeof r.response.username).toEqual('string');\n      expect(typeof r.response.updatedAt).toEqual('string');\n      username1 = r.response.username;\n      return rest.create(config, auth.nobody(config), '_User', data2);\n    }).then(r => {\n      expect(typeof r.response.objectId).toEqual('string');\n      expect(typeof r.response.createdAt).toEqual('string');\n      expect(typeof r.response.sessionToken).toEqual('string');\n      return rest.create(config, auth.nobody(config), '_User', data2);\n    }).then(r => {\n      expect(typeof r.response.objectId).toEqual('string');\n      expect(typeof r.response.createdAt).toEqual('string');\n      expect(typeof r.response.username).toEqual('string');\n      expect(typeof r.response.updatedAt).toEqual('string');\n      expect(r.response.username).not.toEqual(username1);\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"handles anonymous user signup and upgrade to new user","suites":["rest create"],"line":273,"updatePoint":{"line":273,"column":59,"index":9521},"code":"  it('handles anonymous user signup and upgrade to new user', done => {\n    const data1 = {\n      authData: {\n        anonymous: {\n          id: '00000000-0000-0000-0000-000000000001'\n        }\n      }\n    };\n    const updatedData = {\n      authData: {\n        anonymous: null\n      },\n      username: 'hello',\n      password: 'world'\n    };\n    let objectId;\n    rest.create(config, auth.nobody(config), '_User', data1).then(r => {\n      expect(typeof r.response.objectId).toEqual('string');\n      expect(typeof r.response.createdAt).toEqual('string');\n      expect(typeof r.response.sessionToken).toEqual('string');\n      objectId = r.response.objectId;\n      return auth.getAuthForSessionToken({\n        config,\n        sessionToken: r.response.sessionToken\n      });\n    }).then(sessionAuth => {\n      return rest.update(config, sessionAuth, '_User', {\n        objectId\n      }, updatedData);\n    }).then(() => {\n      return Parse.User.logOut().then(() => {\n        return Parse.User.logIn('hello', 'world');\n      });\n    }).then(r => {\n      expect(r.id).toEqual(objectId);\n      expect(r.get('username')).toEqual('hello');\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"handles no anonymous users config","suites":["rest create"],"line":315,"updatePoint":{"line":315,"column":39,"index":10714},"code":"  it('handles no anonymous users config', done => {\n    const NoAnnonConfig = Object.assign({}, config);\n    NoAnnonConfig.authDataManager.setEnableAnonymousUsers(false);\n    const data1 = {\n      authData: {\n        anonymous: {\n          id: '00000000-0000-0000-0000-000000000001'\n        }\n      }\n    };\n    rest.create(NoAnnonConfig, auth.nobody(NoAnnonConfig), '_User', data1).then(() => {\n      fail('Should throw an error');\n      done();\n    }, err => {\n      expect(err.code).toEqual(Parse.Error.UNSUPPORTED_SERVICE);\n      expect(err.message).toEqual('This authentication method is unsupported.');\n      NoAnnonConfig.authDataManager.setEnableAnonymousUsers(true);\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"test facebook signup and login","suites":["rest create"],"line":335,"updatePoint":{"line":335,"column":36,"index":11415},"code":"  it('test facebook signup and login', done => {\n    const data = {\n      authData: {\n        facebook: {\n          id: '8675309',\n          access_token: 'jenny'\n        }\n      }\n    };\n    let newUserSignedUpByFacebookObjectId;\n    rest.create(config, auth.nobody(config), '_User', data).then(r => {\n      expect(typeof r.response.objectId).toEqual('string');\n      expect(typeof r.response.createdAt).toEqual('string');\n      expect(typeof r.response.sessionToken).toEqual('string');\n      newUserSignedUpByFacebookObjectId = r.response.objectId;\n      return rest.create(config, auth.nobody(config), '_User', data);\n    }).then(r => {\n      expect(typeof r.response.objectId).toEqual('string');\n      expect(typeof r.response.createdAt).toEqual('string');\n      expect(typeof r.response.username).toEqual('string');\n      expect(typeof r.response.updatedAt).toEqual('string');\n      expect(r.response.objectId).toEqual(newUserSignedUpByFacebookObjectId);\n      return rest.find(config, auth.master(config), '_Session', {\n        sessionToken: r.response.sessionToken\n      });\n    }).then(response => {\n      expect(response.results.length).toEqual(1);\n      const output = response.results[0];\n      expect(output.user.objectId).toEqual(newUserSignedUpByFacebookObjectId);\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"stores pointers","suites":["rest create"],"line":370,"updatePoint":{"line":370,"column":21,"index":12761},"code":"  it('stores pointers', done => {\n    const obj = {\n      foo: 'bar',\n      aPointer: {\n        __type: 'Pointer',\n        className: 'JustThePointer',\n        objectId: 'qwerty1234' // make it 10 chars to match PG storage\n      }\n    };\n\n    rest.create(config, auth.nobody(config), 'APointerDarkly', obj).then(() => database.adapter.find('APointerDarkly', {\n      fields: {\n        foo: {\n          type: 'String'\n        },\n        aPointer: {\n          type: 'Pointer',\n          targetClass: 'JustThePointer'\n        }\n      }\n    }, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const output = results[0];\n      expect(typeof output.foo).toEqual('string');\n      expect(typeof output._p_aPointer).toEqual('undefined');\n      expect(output._p_aPointer).toBeUndefined();\n      expect(output.aPointer).toEqual({\n        __type: 'Pointer',\n        className: 'JustThePointer',\n        objectId: 'qwerty1234'\n      });\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"stores pointers to objectIds larger than 10 characters","suites":["rest create"],"line":404,"updatePoint":{"line":404,"column":60,"index":13776},"code":"  it('stores pointers to objectIds larger than 10 characters', done => {\n    const obj = {\n      foo: 'bar',\n      aPointer: {\n        __type: 'Pointer',\n        className: 'JustThePointer',\n        objectId: '49F62F92-9B56-46E7-A3D4-BBD14C52F666'\n      }\n    };\n    rest.create(config, auth.nobody(config), 'APointerDarkly', obj).then(() => database.adapter.find('APointerDarkly', {\n      fields: {\n        foo: {\n          type: 'String'\n        },\n        aPointer: {\n          type: 'Pointer',\n          targetClass: 'JustThePointer'\n        }\n      }\n    }, {}, {})).then(results => {\n      expect(results.length).toEqual(1);\n      const output = results[0];\n      expect(typeof output.foo).toEqual('string');\n      expect(typeof output._p_aPointer).toEqual('undefined');\n      expect(output._p_aPointer).toBeUndefined();\n      expect(output.aPointer).toEqual({\n        __type: 'Pointer',\n        className: 'JustThePointer',\n        objectId: '49F62F92-9B56-46E7-A3D4-BBD14C52F666'\n      });\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"cannot set objectId","suites":["rest create"],"line":437,"updatePoint":{"line":437,"column":25,"index":14767},"code":"  it('cannot set objectId', done => {\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest'\n    };\n    request({\n      headers: headers,\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/TestObject',\n      body: JSON.stringify({\n        foo: 'bar',\n        objectId: 'hello'\n      })\n    }).then(fail, response => {\n      const b = response.data;\n      expect(b.code).toEqual(105);\n      expect(b.error).toEqual('objectId is an invalid field name.');\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"cannot set id","suites":["rest create"],"line":458,"updatePoint":{"line":458,"column":19,"index":15343},"code":"  it('cannot set id', done => {\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-Parse-Application-Id': 'test',\n      'X-Parse-REST-API-Key': 'rest'\n    };\n    request({\n      headers: headers,\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/TestObject',\n      body: JSON.stringify({\n        foo: 'bar',\n        id: 'hello'\n      })\n    }).then(fail, response => {\n      const b = response.data;\n      expect(b.code).toEqual(105);\n      expect(b.error).toEqual('id is an invalid field name.');\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"test default session length","suites":["rest create"],"line":479,"updatePoint":{"line":479,"column":33,"index":15921},"code":"  it('test default session length', done => {\n    const user = {\n      username: 'asdf',\n      password: 'zxcv',\n      foo: 'bar'\n    };\n    const now = new Date();\n    rest.create(config, auth.nobody(config), '_User', user).then(r => {\n      expect(Object.keys(r.response).length).toEqual(3);\n      expect(typeof r.response.objectId).toEqual('string');\n      expect(typeof r.response.createdAt).toEqual('string');\n      expect(typeof r.response.sessionToken).toEqual('string');\n      return rest.find(config, auth.master(config), '_Session', {\n        sessionToken: r.response.sessionToken\n      });\n    }).then(r => {\n      expect(r.results.length).toEqual(1);\n      const session = r.results[0];\n      const actual = new Date(session.expiresAt.iso);\n      const expected = new Date(now.getTime() + 1000 * 3600 * 24 * 365);\n      expect(Math.abs(actual - expected) <= jasmine.DEFAULT_TIMEOUT_INTERVAL).toEqual(true);\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"test specified session length","suites":["rest create"],"line":503,"updatePoint":{"line":503,"column":35,"index":16870},"code":"  it('test specified session length', done => {\n    const user = {\n      username: 'asdf',\n      password: 'zxcv',\n      foo: 'bar'\n    };\n    const sessionLength = 3600,\n      // 1 Hour ahead\n      now = new Date(); // For reference later\n    config.sessionLength = sessionLength;\n    rest.create(config, auth.nobody(config), '_User', user).then(r => {\n      expect(Object.keys(r.response).length).toEqual(3);\n      expect(typeof r.response.objectId).toEqual('string');\n      expect(typeof r.response.createdAt).toEqual('string');\n      expect(typeof r.response.sessionToken).toEqual('string');\n      return rest.find(config, auth.master(config), '_Session', {\n        sessionToken: r.response.sessionToken\n      });\n    }).then(r => {\n      expect(r.results.length).toEqual(1);\n      const session = r.results[0];\n      const actual = new Date(session.expiresAt.iso);\n      const expected = new Date(now.getTime() + sessionLength * 1000);\n      expect(Math.abs(actual - expected) <= jasmine.DEFAULT_TIMEOUT_INTERVAL).toEqual(true);\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"can create a session with no expiration","suites":["rest create"],"line":533,"updatePoint":{"line":533,"column":45,"index":17996},"code":"  it('can create a session with no expiration', done => {\n    const user = {\n      username: 'asdf',\n      password: 'zxcv',\n      foo: 'bar'\n    };\n    config.expireInactiveSessions = false;\n    rest.create(config, auth.nobody(config), '_User', user).then(r => {\n      expect(Object.keys(r.response).length).toEqual(3);\n      expect(typeof r.response.objectId).toEqual('string');\n      expect(typeof r.response.createdAt).toEqual('string');\n      expect(typeof r.response.sessionToken).toEqual('string');\n      return rest.find(config, auth.master(config), '_Session', {\n        sessionToken: r.response.sessionToken\n      });\n    }).then(r => {\n      expect(r.results.length).toEqual(1);\n      const session = r.results[0];\n      expect(session.expiresAt).toBeUndefined();\n      done();\n    }).catch(err => {\n      console.error(err);\n      fail(err);\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"can create object in volatileClasses if masterKey","suites":["rest create"],"line":559,"updatePoint":{"line":559,"column":55,"index":18888},"code":"  it('can create object in volatileClasses if masterKey', done => {\n    rest.create(config, auth.master(config), '_PushStatus', {}).then(r => {\n      expect(r.response.objectId.length).toBe(10);\n    }).then(() => {\n      rest.create(config, auth.master(config), '_JobStatus', {}).then(r => {\n        expect(r.response.objectId.length).toBe(10);\n        done();\n      });\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"cannot create object in volatileClasses if not masterKey","suites":["rest create"],"line":569,"updatePoint":{"line":569,"column":62,"index":19280},"code":"  it('cannot create object in volatileClasses if not masterKey', done => {\n    Promise.resolve().then(() => {\n      return rest.create(config, auth.nobody(config), '_PushStatus', {});\n    }).catch(error => {\n      expect(error.code).toEqual(119);\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"locks down session","suites":["rest create"],"line":577,"updatePoint":{"line":577,"column":24,"index":19517},"code":"  it('locks down session', done => {\n    let currentUser;\n    Parse.User.signUp('foo', 'bar').then(user => {\n      currentUser = user;\n      const sessionToken = user.getSessionToken();\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Session-Token': sessionToken\n      };\n      let sessionId;\n      return request({\n        headers: headers,\n        url: 'http://localhost:8378/1/sessions/me'\n      }).then(response => {\n        sessionId = response.data.objectId;\n        return request({\n          headers,\n          method: 'PUT',\n          url: 'http://localhost:8378/1/sessions/' + sessionId,\n          body: {\n            installationId: 'yolo'\n          }\n        });\n      }).then(done.fail, res => {\n        expect(res.status).toBe(400);\n        expect(res.data.code).toBe(105);\n        return request({\n          headers,\n          method: 'PUT',\n          url: 'http://localhost:8378/1/sessions/' + sessionId,\n          body: {\n            sessionToken: 'yolo'\n          }\n        });\n      }).then(done.fail, res => {\n        expect(res.status).toBe(400);\n        expect(res.data.code).toBe(105);\n        return Parse.User.signUp('other', 'user');\n      }).then(otherUser => {\n        const user = new Parse.User();\n        user.id = otherUser.id;\n        return request({\n          headers,\n          method: 'PUT',\n          url: 'http://localhost:8378/1/sessions/' + sessionId,\n          body: {\n            user: Parse._encode(user)\n          }\n        });\n      }).then(done.fail, res => {\n        expect(res.status).toBe(400);\n        expect(res.data.code).toBe(105);\n        const user = new Parse.User();\n        user.id = currentUser.id;\n        return request({\n          headers,\n          method: 'PUT',\n          url: 'http://localhost:8378/1/sessions/' + sessionId,\n          body: {\n            user: Parse._encode(user)\n          }\n        });\n      }).then(done).catch(done.fail);\n    }).catch(done.fail);\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"sets current user in new sessions","suites":["rest create"],"line":644,"updatePoint":{"line":644,"column":39,"index":21592},"code":"  it('sets current user in new sessions', done => {\n    let currentUser;\n    Parse.User.signUp('foo', 'bar').then(user => {\n      currentUser = user;\n      const sessionToken = user.getSessionToken();\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Session-Token': sessionToken,\n        'Content-Type': 'application/json'\n      };\n      return request({\n        headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/sessions',\n        body: {\n          user: {\n            __type: 'Pointer',\n            className: '_User',\n            objectId: 'fakeId'\n          }\n        }\n      });\n    }).then(response => {\n      if (response.data.user.objectId === currentUser.id) {\n        return done();\n      } else {\n        return done.fail();\n      }\n    }).catch(done.fail);\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"ignores createdAt","suites":["rest update"],"line":677,"updatePoint":{"line":677,"column":23,"index":22482},"code":"  it('ignores createdAt', done => {\n    const config = Config.get('test');\n    const nobody = auth.nobody(config);\n    const className = 'Foo';\n    const newCreatedAt = new Date('1970-01-01T00:00:00.000Z');\n    rest.create(config, nobody, className, {}).then(res => {\n      const objectId = res.response.objectId;\n      const restObject = {\n        createdAt: {\n          __type: 'Date',\n          iso: newCreatedAt\n        } // should be ignored\n      };\n\n      return rest.update(config, nobody, className, {\n        objectId\n      }, restObject).then(() => {\n        const restWhere = {\n          objectId: objectId\n        };\n        return rest.find(config, nobody, className, restWhere, {});\n      });\n    }).then(res2 => {\n      const updatedObject = res2.results[0];\n      expect(new Date(updatedObject.createdAt)).not.toEqual(newCreatedAt);\n      done();\n    }).then(done).catch(done.fail);\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"properly throws on rest.create, rest.update and rest.del","suites":["read-only masterKey"],"line":707,"updatePoint":{"line":707,"column":62,"index":23471},"code":"  it('properly throws on rest.create, rest.update and rest.del', () => {\n    const config = Config.get('test');\n    const readOnly = auth.readOnly(config);\n    expect(() => {\n      rest.create(config, readOnly, 'AnObject', {});\n    }).toThrow(new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, `read-only masterKey isn't allowed to perform the create operation.`));\n    expect(() => {\n      rest.update(config, readOnly, 'AnObject', {});\n    }).toThrow();\n    expect(() => {\n      rest.del(config, readOnly, 'AnObject', {});\n    }).toThrow();\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"properly blocks writes","suites":["read-only masterKey"],"line":720,"updatePoint":{"line":720,"column":28,"index":23984},"code":"  it('properly blocks writes', async () => {\n    await reconfigureServer({\n      readOnlyMasterKey: 'yolo-read-only'\n    });\n    try {\n      await request({\n        url: `${Parse.serverURL}/classes/MyYolo`,\n        method: 'POST',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Master-Key': 'yolo-read-only',\n          'Content-Type': 'application/json'\n        },\n        body: {\n          foo: 'bar'\n        }\n      });\n      fail();\n    } catch (res) {\n      expect(res.data.code).toBe(Parse.Error.OPERATION_FORBIDDEN);\n      expect(res.data.error).toBe(\"read-only masterKey isn't allowed to perform the create operation.\");\n    }\n    await reconfigureServer();\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when masterKey and readOnlyMasterKey are the same","suites":["read-only masterKey"],"line":744,"updatePoint":{"line":744,"column":68,"index":24743},"code":"  it('should throw when masterKey and readOnlyMasterKey are the same', async () => {\n    try {\n      await reconfigureServer({\n        masterKey: 'yolo',\n        readOnlyMasterKey: 'yolo'\n      });\n      fail();\n    } catch (err) {\n      expect(err).toEqual(new Error('masterKey and readOnlyMasterKey should be different'));\n    }\n    await reconfigureServer();\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when trying to create RestWrite","suites":["read-only masterKey"],"line":756,"updatePoint":{"line":756,"column":50,"index":25093},"code":"  it('should throw when trying to create RestWrite', () => {\n    const config = Config.get('test');\n    expect(() => {\n      new RestWrite(config, auth.readOnly(config));\n    }).toThrow(new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Cannot perform a write operation when using readOnlyMasterKey'));\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when trying to create schema","suites":["read-only masterKey"],"line":762,"updatePoint":{"line":762,"column":47,"index":25398},"code":"  it('should throw when trying to create schema', done => {\n    request({\n      method: 'POST',\n      url: `${Parse.serverURL}/schemas`,\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': 'read-only-test',\n        'Content-Type': 'application/json'\n      },\n      json: {}\n    }).then(done.fail).catch(res => {\n      expect(res.data.code).toBe(Parse.Error.OPERATION_FORBIDDEN);\n      expect(res.data.error).toBe(\"read-only masterKey isn't allowed to create a schema.\");\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when trying to create schema with a name","suites":["read-only masterKey"],"line":778,"updatePoint":{"line":778,"column":59,"index":25959},"code":"  it('should throw when trying to create schema with a name', done => {\n    request({\n      url: `${Parse.serverURL}/schemas/MyClass`,\n      method: 'POST',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': 'read-only-test',\n        'Content-Type': 'application/json'\n      },\n      json: {}\n    }).then(done.fail).catch(res => {\n      expect(res.data.code).toBe(Parse.Error.OPERATION_FORBIDDEN);\n      expect(res.data.error).toBe(\"read-only masterKey isn't allowed to create a schema.\");\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when trying to update schema","suites":["read-only masterKey"],"line":794,"updatePoint":{"line":794,"column":47,"index":26516},"code":"  it('should throw when trying to update schema', done => {\n    request({\n      url: `${Parse.serverURL}/schemas/MyClass`,\n      method: 'PUT',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': 'read-only-test',\n        'Content-Type': 'application/json'\n      },\n      json: {}\n    }).then(done.fail).catch(res => {\n      expect(res.data.code).toBe(Parse.Error.OPERATION_FORBIDDEN);\n      expect(res.data.error).toBe(\"read-only masterKey isn't allowed to update a schema.\");\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when trying to delete schema","suites":["read-only masterKey"],"line":810,"updatePoint":{"line":810,"column":47,"index":27072},"code":"  it('should throw when trying to delete schema', done => {\n    request({\n      url: `${Parse.serverURL}/schemas/MyClass`,\n      method: 'DELETE',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': 'read-only-test',\n        'Content-Type': 'application/json'\n      },\n      json: {}\n    }).then(done.fail).catch(res => {\n      expect(res.data.code).toBe(Parse.Error.OPERATION_FORBIDDEN);\n      expect(res.data.error).toBe(\"read-only masterKey isn't allowed to delete a schema.\");\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when trying to update the global config","suites":["read-only masterKey"],"line":826,"updatePoint":{"line":826,"column":58,"index":27642},"code":"  it('should throw when trying to update the global config', done => {\n    request({\n      url: `${Parse.serverURL}/config`,\n      method: 'PUT',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': 'read-only-test',\n        'Content-Type': 'application/json'\n      },\n      json: {}\n    }).then(done.fail).catch(res => {\n      expect(res.data.code).toBe(Parse.Error.OPERATION_FORBIDDEN);\n      expect(res.data.error).toBe(\"read-only masterKey isn't allowed to update the config.\");\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when trying to send push","suites":["read-only masterKey"],"line":842,"updatePoint":{"line":842,"column":43,"index":28187},"code":"  it('should throw when trying to send push', done => {\n    request({\n      url: `${Parse.serverURL}/push`,\n      method: 'POST',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Master-Key': 'read-only-test',\n        'Content-Type': 'application/json'\n      },\n      json: {}\n    }).then(done.fail).catch(res => {\n      expect(res.data.code).toBe(Parse.Error.OPERATION_FORBIDDEN);\n      expect(res.data.error).toBe(\"read-only masterKey isn't allowed to send push notifications.\");\n      done();\n    });\n  });","file":"rest.spec.js","skipped":false,"dir":"spec"},{"name":"basic query","suites":["rest query"],"line":18,"updatePoint":{"line":18,"column":17,"index":530},"code":"  it('basic query', done => {\n    rest.create(config, nobody, 'TestObject', {}).then(() => {\n      return rest.find(config, nobody, 'TestObject', {});\n    }).then(response => {\n      expect(response.results.length).toEqual(1);\n      done();\n    });\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query with limit","suites":["rest query"],"line":26,"updatePoint":{"line":26,"column":22,"index":790},"code":"  it('query with limit', done => {\n    rest.create(config, nobody, 'TestObject', {\n      foo: 'baz'\n    }).then(() => {\n      return rest.create(config, nobody, 'TestObject', {\n        foo: 'qux'\n      });\n    }).then(() => {\n      return rest.find(config, nobody, 'TestObject', {}, {\n        limit: 1\n      });\n    }).then(response => {\n      expect(response.results.length).toEqual(1);\n      expect(response.results[0].foo).toBeTruthy();\n      done();\n    });\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query non-existent class when disabled client class creation","suites":["rest query"],"line":131,"updatePoint":{"line":131,"column":66,"index":4010},"code":"  it('query non-existent class when disabled client class creation', done => {\n    const customConfig = Object.assign({}, config, {\n      allowClientClassCreation: false\n    });\n    rest.find(customConfig, auth.nobody(customConfig), 'ClientClassCreation', {}).then(() => {\n      fail('Should throw an error');\n      done();\n    }, err => {\n      expect(err.code).toEqual(Parse.Error.OPERATION_FORBIDDEN);\n      expect(err.message).toEqual('This user is not allowed to access ' + 'non-existent class: ClientClassCreation');\n      done();\n    });\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query existent class when disabled client class creation","suites":["rest query"],"line":144,"updatePoint":{"line":144,"column":62,"index":4557},"code":"  it('query existent class when disabled client class creation', async () => {\n    const customConfig = Object.assign({}, config, {\n      allowClientClassCreation: false\n    });\n    const schema = await config.database.loadSchema();\n    const actualSchema = await schema.addClassIfNotExists('ClientClassCreation', {});\n    expect(actualSchema.className).toEqual('ClientClassCreation');\n    await schema.reloadData({\n      clearCache: true\n    });\n    // Should not throw\n    const result = await rest.find(customConfig, auth.nobody(customConfig), 'ClientClassCreation', {});\n    expect(result.results.length).toEqual(0);\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query internal field","suites":["rest query"],"line":158,"updatePoint":{"line":158,"column":26,"index":5148},"code":"  it('query internal field', async () => {\n    const internalFields = ['_email_verify_token', '_perishable_token', '_tombstone', '_email_verify_token_expires_at', '_failed_login_count', '_account_lockout_expires_at', '_password_changed_at', '_password_history'];\n    await Promise.all([...internalFields.map(field => expectAsync(new Parse.Query(Parse.User).exists(field).find()).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid key name: ${field}`))), ...internalFields.map(field => new Parse.Query(Parse.User).exists(field).find({\n      useMasterKey: true\n    }))]);\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query protected field","suites":["rest query"],"line":164,"updatePoint":{"line":164,"column":27,"index":5746},"code":"  it('query protected field', async () => {\n    const user = new Parse.User();\n    user.setUsername('username1');\n    user.setPassword('password');\n    await user.signUp();\n    const config = Config.get(Parse.applicationId);\n    const obj = new Parse.Object('Test');\n    obj.set('owner', user);\n    obj.set('test', 'test');\n    obj.set('zip', 1234);\n    await obj.save();\n    const schema = await config.database.loadSchema();\n    await schema.updateClass('Test', {}, {\n      get: {\n        '*': true\n      },\n      find: {\n        '*': true\n      },\n      protectedFields: {\n        [user.id]: ['zip']\n      }\n    });\n    await Promise.all([new Parse.Query('Test').exists('test').find(), expectAsync(new Parse.Query('Test').exists('zip').find()).toBeRejectedWith(new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'This user is not allowed to query zip on class Test'))]);\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query protected field with matchesQuery","suites":["rest query"],"line":189,"updatePoint":{"line":189,"column":45,"index":6642},"code":"  it('query protected field with matchesQuery', async () => {\n    const user = new Parse.User();\n    user.setUsername('username1');\n    user.setPassword('password');\n    await user.signUp();\n    const test = new Parse.Object('TestObject', {\n      user\n    });\n    await test.save();\n    const subQuery = new Parse.Query(Parse.User);\n    subQuery.exists('_perishable_token');\n    await expectAsync(new Parse.Query('TestObject').matchesQuery('user', subQuery).find()).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'Invalid key name: _perishable_token'));\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query with wrongly encoded parameter","suites":["rest query"],"line":202,"updatePoint":{"line":202,"column":42,"index":7215},"code":"  it('query with wrongly encoded parameter', done => {\n    rest.create(config, nobody, 'TestParameterEncode', {\n      foo: 'bar'\n    }).then(() => {\n      return rest.create(config, nobody, 'TestParameterEncode', {\n        foo: 'baz'\n      });\n    }).then(() => {\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const p0 = request({\n        headers: headers,\n        url: 'http://localhost:8378/1/classes/TestParameterEncode?' + querystring.stringify({\n          where: '{\"foo\":{\"$ne\": \"baz\"}}',\n          limit: 1\n        }).replace('=', '%3D')\n      }).then(fail, response => {\n        const error = response.data;\n        expect(error.code).toEqual(Parse.Error.INVALID_QUERY);\n      });\n      const p1 = request({\n        headers: headers,\n        url: 'http://localhost:8378/1/classes/TestParameterEncode?' + querystring.stringify({\n          limit: 1\n        }).replace('=', '%3D')\n      }).then(fail, response => {\n        const error = response.data;\n        expect(error.code).toEqual(Parse.Error.INVALID_QUERY);\n      });\n      return Promise.all([p0, p1]);\n    }).then(done).catch(err => {\n      jfail(err);\n      fail('should not fail');\n      done();\n    });\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query with limit = 0","suites":["rest query"],"line":240,"updatePoint":{"line":240,"column":26,"index":8448},"code":"  it('query with limit = 0', done => {\n    rest.create(config, nobody, 'TestObject', {\n      foo: 'baz'\n    }).then(() => {\n      return rest.create(config, nobody, 'TestObject', {\n        foo: 'qux'\n      });\n    }).then(() => {\n      return rest.find(config, nobody, 'TestObject', {}, {\n        limit: 0\n      });\n    }).then(response => {\n      expect(response.results.length).toEqual(0);\n      done();\n    });\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"query with limit = 0 and count = 1","suites":["rest query"],"line":256,"updatePoint":{"line":256,"column":40,"index":8882},"code":"  it('query with limit = 0 and count = 1', done => {\n    rest.create(config, nobody, 'TestObject', {\n      foo: 'baz'\n    }).then(() => {\n      return rest.create(config, nobody, 'TestObject', {\n        foo: 'qux'\n      });\n    }).then(() => {\n      return rest.find(config, nobody, 'TestObject', {}, {\n        limit: 0,\n        count: 1\n      });\n    }).then(response => {\n      expect(response.results.length).toEqual(0);\n      expect(response.count).toEqual(2);\n      done();\n    });\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"makes sure null pointers are handed correctly #2189","suites":["rest query"],"line":274,"updatePoint":{"line":274,"column":57,"index":9392},"code":"  it('makes sure null pointers are handed correctly #2189', done => {\n    const object = new Parse.Object('AnObject');\n    const anotherObject = new Parse.Object('AnotherObject');\n    anotherObject.save().then(() => {\n      object.set('values', [null, null, anotherObject]);\n      return object.save();\n    }).then(() => {\n      const query = new Parse.Query('AnObject');\n      query.include('values');\n      return query.first();\n    }).then(result => {\n      const values = result.get('values');\n      expect(values.length).toBe(3);\n      let anotherObjectFound = false;\n      let nullCounts = 0;\n      for (const value of values) {\n        if (value === null) {\n          nullCounts++;\n        } else if (value instanceof Parse.Object) {\n          anotherObjectFound = true;\n        }\n      }\n      expect(nullCounts).toBe(2);\n      expect(anotherObjectFound).toBeTruthy();\n      done();\n    }, err => {\n      console.error(err);\n      fail(err);\n      done();\n    });\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should run each","suites":["RestQuery.each"],"line":310,"updatePoint":{"line":310,"column":21,"index":10433},"code":"  it('should run each', async () => {\n    const objects = [];\n    while (objects.length != 10) {\n      objects.push(new Parse.Object('Object', {\n        value: objects.length\n      }));\n    }\n    const config = Config.get('test');\n    await Parse.Object.saveAll(objects);\n    const query = new RestQuery(config, auth.master(config), 'Object', {\n      value: {\n        $gt: 2\n      }\n    }, {\n      limit: 2\n    });\n    const spy = spyOn(query, 'execute').and.callThrough();\n    const classSpy = spyOn(RestQuery.prototype, 'execute').and.callThrough();\n    const results = [];\n    await query.each(result => {\n      expect(result.value).toBeGreaterThan(2);\n      results.push(result);\n    });\n    expect(spy.calls.count()).toBe(0);\n    expect(classSpy.calls.count()).toBe(4);\n    expect(results.length).toBe(7);\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should work with query on relations","suites":["RestQuery.each"],"line":337,"updatePoint":{"line":337,"column":41,"index":11270},"code":"  it('should work with query on relations', async () => {\n    const objectA = new Parse.Object('Letter', {\n      value: 'A'\n    });\n    const objectB = new Parse.Object('Letter', {\n      value: 'B'\n    });\n    const object1 = new Parse.Object('Number', {\n      value: '1'\n    });\n    const object2 = new Parse.Object('Number', {\n      value: '2'\n    });\n    const object3 = new Parse.Object('Number', {\n      value: '3'\n    });\n    const object4 = new Parse.Object('Number', {\n      value: '4'\n    });\n    await Parse.Object.saveAll([object1, object2, object3, object4]);\n    objectA.relation('numbers').add(object1);\n    objectB.relation('numbers').add(object2);\n    await Parse.Object.saveAll([objectA, objectB]);\n    const config = Config.get('test');\n\n    /**\n     * Two queries needed since objectId are sorted and we can't know which one\n     * going to be the first and then skip by the $gt added by each\n     */\n    const queryOne = new RestQuery(config, auth.master(config), 'Letter', {\n      numbers: {\n        __type: 'Pointer',\n        className: 'Number',\n        objectId: object1.id\n      }\n    }, {\n      limit: 1\n    });\n    const queryTwo = new RestQuery(config, auth.master(config), 'Letter', {\n      numbers: {\n        __type: 'Pointer',\n        className: 'Number',\n        objectId: object2.id\n      }\n    }, {\n      limit: 1\n    });\n    const classSpy = spyOn(RestQuery.prototype, 'execute').and.callThrough();\n    const resultsOne = [];\n    const resultsTwo = [];\n    await queryOne.each(result => {\n      resultsOne.push(result);\n    });\n    await queryTwo.each(result => {\n      resultsTwo.push(result);\n    });\n    expect(classSpy.calls.count()).toBe(4);\n    expect(resultsOne.length).toBe(1);\n    expect(resultsTwo.length).toBe(1);\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"test afterSave response object is return","suites":["RestQuery.each"],"line":397,"updatePoint":{"line":397,"column":46,"index":13041},"code":"  it('test afterSave response object is return', done => {\n    Parse.Cloud.beforeSave('TestObject2', function (req) {\n      req.object.set('tobeaddbefore', true);\n      req.object.set('tobeaddbeforeandremoveafter', true);\n    });\n    Parse.Cloud.afterSave('TestObject2', function (req) {\n      const jsonObject = req.object.toJSON();\n      delete jsonObject.todelete;\n      delete jsonObject.tobeaddbeforeandremoveafter;\n      jsonObject.toadd = true;\n      return jsonObject;\n    });\n    rest.create(config, nobody, 'TestObject2', {\n      todelete: true,\n      tokeep: true\n    }).then(response => {\n      expect(response.response.toadd).toBeTruthy();\n      expect(response.response.tokeep).toBeTruthy();\n      expect(response.response.tobeaddbefore).toBeTruthy();\n      expect(response.response.tobeaddbeforeandremoveafter).toBeUndefined();\n      expect(response.response.todelete).toBeUndefined();\n      done();\n    });\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"test afterSave should not affect save response","suites":["RestQuery.each"],"line":421,"updatePoint":{"line":421,"column":52,"index":13976},"code":"  it('test afterSave should not affect save response', async () => {\n    Parse.Cloud.beforeSave('TestObject2', ({\n      object\n    }) => {\n      object.set('addedBeforeSave', true);\n    });\n    Parse.Cloud.afterSave('TestObject2', ({\n      object\n    }) => {\n      object.set('addedAfterSave', true);\n      object.unset('initialToRemove');\n    });\n    const {\n      response\n    } = await rest.create(config, nobody, 'TestObject2', {\n      initialSave: true,\n      initialToRemove: true\n    });\n    expect(Object.keys(response).sort()).toEqual(['addedAfterSave', 'addedBeforeSave', 'createdAt', 'initialToRemove', 'objectId']);\n  });","file":"RestQuery.spec.js","skipped":false,"dir":"spec"},{"name":"should upgrade legacy session token","suites":[],"line":20,"updatePoint":{"line":20,"column":41,"index":609},"code":"  it('should upgrade legacy session token', done => {\n    const user = Parse.Object.fromJSON({\n      className: '_User',\n      objectId: '1234567890',\n      sessionToken: sessionToken\n    });\n    user._upgradeToRevocableSession().then(res => {\n      expect(res.getSessionToken().indexOf('r:')).toBe(0);\n      const config = Config.get(Parse.applicationId);\n      // use direct access to the DB to make sure we're not\n      // getting the session token stripped\n      return config.database.loadSchema().then(schemaController => {\n        return schemaController.getOneSchema('_User', true);\n      }).then(schema => {\n        return config.database.adapter.find('_User', schema, {\n          objectId: '1234567890'\n        }, {});\n      }).then(results => {\n        expect(results.length).toBe(1);\n        expect(results[0].sessionToken).toBeUndefined();\n      });\n    }).then(() => {\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"RevocableSessionsUpgrade.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to become with revocable session token","suites":[],"line":48,"updatePoint":{"line":48,"column":59,"index":1586},"code":"  it('should be able to become with revocable session token', done => {\n    const user = Parse.Object.fromJSON({\n      className: '_User',\n      objectId: '1234567890',\n      sessionToken: sessionToken\n    });\n    user._upgradeToRevocableSession().then(res => {\n      expect(res.getSessionToken().indexOf('r:')).toBe(0);\n      return Parse.User.logOut().then(() => {\n        return Parse.User.become(res.getSessionToken());\n      }).then(user => {\n        expect(user.id).toEqual('1234567890');\n      });\n    }).then(() => {\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"RevocableSessionsUpgrade.spec.js","skipped":false,"dir":"spec"},{"name":"should not upgrade bad legacy session token","suites":[],"line":68,"updatePoint":{"line":68,"column":49,"index":2177},"code":"  it('should not upgrade bad legacy session token', done => {\n    request({\n      method: 'POST',\n      url: Parse.serverURL + '/upgradeToRevocableSession',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Rest-API-Key': 'rest',\n        'X-Parse-Session-Token': 'badSessionToken'\n      }\n    }).then(() => {\n      fail('should not be able to upgrade a bad token');\n    }, response => {\n      expect(response.status).toBe(400);\n      expect(response.data).not.toBeUndefined();\n      expect(response.data.code).toBe(Parse.Error.INVALID_SESSION_TOKEN);\n      expect(response.data.error).toEqual('invalid legacy session token');\n    }).then(() => {\n      done();\n    });\n  });","file":"RevocableSessionsUpgrade.spec.js","skipped":false,"dir":"spec"},{"name":"should not crash without session token #2720","suites":[],"line":88,"updatePoint":{"line":88,"column":50,"index":2891},"code":"  it('should not crash without session token #2720', done => {\n    request({\n      method: 'POST',\n      url: Parse.serverURL + '/upgradeToRevocableSession',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Rest-API-Key': 'rest'\n      }\n    }).then(() => {\n      fail('should not be able to upgrade a bad token');\n    }, response => {\n      expect(response.status).toBe(404);\n      expect(response.data).not.toBeUndefined();\n      expect(response.data.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      expect(response.data.error).toEqual('invalid session');\n    }).then(() => {\n      done();\n    });\n  });","file":"RevocableSessionsUpgrade.spec.js","skipped":false,"dir":"spec"},{"name":"can validate one object","suites":["SchemaController"],"line":32,"updatePoint":{"line":32,"column":29,"index":812},"code":"  it('can validate one object', done => {\n    config.database.loadSchema().then(schema => {\n      return schema.validateObject('TestObject', {\n        a: 1,\n        b: 'yo',\n        c: false\n      });\n    }).then(() => {\n      done();\n    }, error => {\n      jfail(error);\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can validate one object with dot notation","suites":["SchemaController"],"line":46,"updatePoint":{"line":46,"column":47,"index":1131},"code":"  it('can validate one object with dot notation', done => {\n    config.database.loadSchema().then(schema => {\n      return schema.validateObject('TestObjectWithSubDoc', {\n        x: false,\n        y: 'YY',\n        z: 1,\n        'aObject.k1': 'newValue'\n      });\n    }).then(() => {\n      done();\n    }, error => {\n      jfail(error);\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can validate two objects in a row","suites":["SchemaController"],"line":61,"updatePoint":{"line":61,"column":39,"index":1486},"code":"  it('can validate two objects in a row', done => {\n    config.database.loadSchema().then(schema => {\n      return schema.validateObject('Foo', {\n        x: true,\n        y: 'yyy',\n        z: 0\n      });\n    }).then(schema => {\n      return schema.validateObject('Foo', {\n        x: false,\n        y: 'YY',\n        z: 1\n      });\n    }).then(() => {\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can validate Relation object","suites":["SchemaController"],"line":78,"updatePoint":{"line":78,"column":34,"index":1859},"code":"  it('can validate Relation object', done => {\n    config.database.loadSchema().then(schema => {\n      return schema.validateObject('Stuff', {\n        aRelation: {\n          __type: 'Relation',\n          className: 'Stuff'\n        }\n      });\n    }).then(schema => {\n      return schema.validateObject('Stuff', {\n        aRelation: {\n          __type: 'Pointer',\n          className: 'Stuff'\n        }\n      }).then(() => {\n        done.fail('expected invalidity');\n      }, () => done());\n    }, done.fail);\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"rejects inconsistent types","suites":["SchemaController"],"line":97,"updatePoint":{"line":97,"column":32,"index":2372},"code":"  it('rejects inconsistent types', done => {\n    config.database.loadSchema().then(schema => {\n      return schema.validateObject('Stuff', {\n        bacon: 7\n      });\n    }).then(schema => {\n      return schema.validateObject('Stuff', {\n        bacon: 'z'\n      });\n    }).then(() => {\n      fail('expected invalidity');\n      done();\n    }, () => done());\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"updates when new fields are added","suites":["SchemaController"],"line":111,"updatePoint":{"line":111,"column":39,"index":2743},"code":"  it('updates when new fields are added', done => {\n    config.database.loadSchema().then(schema => {\n      return schema.validateObject('Stuff', {\n        bacon: 7\n      });\n    }).then(schema => {\n      return schema.validateObject('Stuff', {\n        sausage: 8\n      });\n    }).then(schema => {\n      return schema.validateObject('Stuff', {\n        sausage: 'ate'\n      });\n    }).then(() => {\n      fail('expected invalidity');\n      done();\n    }, () => done());\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"class-level permissions test find","suites":["SchemaController"],"line":129,"updatePoint":{"line":129,"column":39,"index":3217},"code":"  it('class-level permissions test find', done => {\n    config.database.loadSchema().then(schema => {\n      // Just to create a valid class\n      return schema.validateObject('Stuff', {\n        foo: 'bar'\n      });\n    }).then(schema => {\n      return schema.setPermissions('Stuff', {\n        find: {}\n      });\n    }).then(() => {\n      const query = new Parse.Query('Stuff');\n      return query.find();\n    }).then(() => {\n      fail('Class permissions should have rejected this query.');\n      done();\n    }, () => {\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"class-level permissions test user","suites":["SchemaController"],"line":149,"updatePoint":{"line":149,"column":39,"index":3765},"code":"  it('class-level permissions test user', done => {\n    let user;\n    createTestUser().then(u => {\n      user = u;\n      return config.database.loadSchema();\n    }).then(schema => {\n      // Just to create a valid class\n      return schema.validateObject('Stuff', {\n        foo: 'bar'\n      });\n    }).then(schema => {\n      const find = {};\n      find[user.id] = true;\n      return schema.setPermissions('Stuff', {\n        find: find\n      });\n    }).then(() => {\n      const query = new Parse.Query('Stuff');\n      return query.find();\n    }).then(() => {\n      done();\n    }, () => {\n      fail('Class permissions should have allowed this query.');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"class-level permissions test get","suites":["SchemaController"],"line":175,"updatePoint":{"line":175,"column":38,"index":4444},"code":"  it('class-level permissions test get', done => {\n    let obj;\n    createTestUser().then(user => {\n      return config.database.loadSchema()\n      // Create a valid class\n      .then(schema => schema.validateObject('Stuff', {\n        foo: 'bar'\n      })).then(schema => {\n        const find = {};\n        const get = {};\n        get[user.id] = true;\n        return schema.setPermissions('Stuff', {\n          create: {\n            '*': true\n          },\n          find: find,\n          get: get\n        });\n      }).then(() => {\n        obj = new Parse.Object('Stuff');\n        obj.set('foo', 'bar');\n        return obj.save();\n      }).then(o => {\n        obj = o;\n        const query = new Parse.Query('Stuff');\n        return query.find();\n      }).then(() => {\n        fail('Class permissions should have rejected this query.');\n        done();\n      }, () => {\n        const query = new Parse.Query('Stuff');\n        return query.get(obj.id).then(() => {\n          done();\n        }, () => {\n          fail('Class permissions should have allowed this get query');\n          done();\n        });\n      });\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"class-level permissions test count","suites":["SchemaController"],"line":215,"updatePoint":{"line":215,"column":40,"index":5569},"code":"  it('class-level permissions test count', done => {\n    let obj;\n    return config.database.loadSchema()\n    // Create a valid class\n    .then(schema => schema.validateObject('Stuff', {\n      foo: 'bar'\n    })).then(schema => {\n      const count = {};\n      return schema.setPermissions('Stuff', {\n        create: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        count: count\n      });\n    }).then(() => {\n      obj = new Parse.Object('Stuff');\n      obj.set('foo', 'bar');\n      return obj.save();\n    }).then(o => {\n      obj = o;\n      const query = new Parse.Query('Stuff');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(1);\n      const query = new Parse.Query('Stuff');\n      return query.count();\n    }).then(() => {\n      fail('Class permissions should have rejected this query.');\n    }, err => {\n      expect(err.message).toEqual('Permission denied for action count on class Stuff.');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can add classes without needing an object","suites":["SchemaController"],"line":251,"updatePoint":{"line":251,"column":47,"index":6578},"code":"  it('can add classes without needing an object', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      foo: {\n        type: 'String'\n      }\n    })).then(actualSchema => {\n      const expectedSchema = {\n        className: 'NewClass',\n        fields: {\n          objectId: {\n            type: 'String'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          ACL: {\n            type: 'ACL'\n          },\n          foo: {\n            type: 'String'\n          }\n        },\n        classLevelPermissions: {\n          find: {\n            '*': true\n          },\n          get: {\n            '*': true\n          },\n          count: {\n            '*': true\n          },\n          create: {\n            '*': true\n          },\n          update: {\n            '*': true\n          },\n          delete: {\n            '*': true\n          },\n          addField: {\n            '*': true\n          },\n          protectedFields: {\n            '*': []\n          }\n        }\n      };\n      expect(dd(actualSchema, expectedSchema)).toEqual(undefined);\n      done();\n    }).catch(error => {\n      fail('Error creating class: ' + JSON.stringify(error));\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can update classes without needing an object","suites":["SchemaController"],"line":309,"updatePoint":{"line":309,"column":50,"index":7865},"code":"  it('can update classes without needing an object', done => {\n    const levelPermissions = {\n      find: {\n        '*': true\n      },\n      get: {\n        '*': true\n      },\n      count: {\n        '*': true\n      },\n      create: {\n        '*': true\n      },\n      update: {\n        '*': true\n      },\n      delete: {\n        '*': true\n      },\n      addField: {\n        '*': true\n      },\n      protectedFields: {\n        '*': []\n      }\n    };\n    config.database.loadSchema().then(schema => {\n      schema.validateObject('NewClass', {\n        foo: 2\n      }).then(() => schema.reloadData()).then(() => schema.updateClass('NewClass', {\n        fooOne: {\n          type: 'Number'\n        },\n        fooTwo: {\n          type: 'Array'\n        },\n        fooThree: {\n          type: 'Date'\n        },\n        fooFour: {\n          type: 'Object'\n        },\n        fooFive: {\n          type: 'Relation',\n          targetClass: '_User'\n        },\n        fooSix: {\n          type: 'String'\n        },\n        fooSeven: {\n          type: 'Object'\n        },\n        fooEight: {\n          type: 'String'\n        },\n        fooNine: {\n          type: 'String'\n        },\n        fooTeen: {\n          type: 'Number'\n        },\n        fooEleven: {\n          type: 'String'\n        },\n        fooTwelve: {\n          type: 'String'\n        },\n        fooThirteen: {\n          type: 'String'\n        },\n        fooFourteen: {\n          type: 'String'\n        },\n        fooFifteen: {\n          type: 'String'\n        },\n        fooSixteen: {\n          type: 'String'\n        },\n        fooEighteen: {\n          type: 'String'\n        },\n        fooNineteen: {\n          type: 'String'\n        }\n      }, levelPermissions, {}, config.database)).then(actualSchema => {\n        const expectedSchema = {\n          className: 'NewClass',\n          fields: {\n            objectId: {\n              type: 'String'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            ACL: {\n              type: 'ACL'\n            },\n            foo: {\n              type: 'Number'\n            },\n            fooOne: {\n              type: 'Number'\n            },\n            fooTwo: {\n              type: 'Array'\n            },\n            fooThree: {\n              type: 'Date'\n            },\n            fooFour: {\n              type: 'Object'\n            },\n            fooFive: {\n              type: 'Relation',\n              targetClass: '_User'\n            },\n            fooSix: {\n              type: 'String'\n            },\n            fooSeven: {\n              type: 'Object'\n            },\n            fooEight: {\n              type: 'String'\n            },\n            fooNine: {\n              type: 'String'\n            },\n            fooTeen: {\n              type: 'Number'\n            },\n            fooEleven: {\n              type: 'String'\n            },\n            fooTwelve: {\n              type: 'String'\n            },\n            fooThirteen: {\n              type: 'String'\n            },\n            fooFourteen: {\n              type: 'String'\n            },\n            fooFifteen: {\n              type: 'String'\n            },\n            fooSixteen: {\n              type: 'String'\n            },\n            fooEighteen: {\n              type: 'String'\n            },\n            fooNineteen: {\n              type: 'String'\n            }\n          },\n          classLevelPermissions: {\n            ...levelPermissions\n          },\n          indexes: {\n            _id_: {\n              _id: 1\n            }\n          }\n        };\n        expect(dd(actualSchema, expectedSchema)).toEqual(undefined);\n        done();\n      }).catch(error => {\n        console.trace(error);\n        done();\n        fail('Error creating class: ' + JSON.stringify(error));\n      });\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can update class level permission","suites":["SchemaController"],"line":488,"updatePoint":{"line":488,"column":39,"index":11725},"code":"  it('can update class level permission', done => {\n    const newLevelPermissions = {\n      find: {},\n      get: {\n        '*': true\n      },\n      count: {},\n      create: {\n        '*': true\n      },\n      update: {},\n      delete: {\n        '*': true\n      },\n      addField: {},\n      protectedFields: {\n        '*': []\n      }\n    };\n    config.database.loadSchema().then(schema => {\n      schema.validateObject('NewClass', {\n        foo: 2\n      }).then(() => schema.reloadData()).then(() => schema.updateClass('NewClass', {}, newLevelPermissions, {}, config.database)).then(actualSchema => {\n        expect(dd(actualSchema.classLevelPermissions, newLevelPermissions)).toEqual(undefined);\n        done();\n      }).catch(error => {\n        console.trace(error);\n        done();\n        fail('Error creating class: ' + JSON.stringify(error));\n      });\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"will fail to create a class if that class was already created by an object","suites":["SchemaController"],"line":520,"updatePoint":{"line":520,"column":80,"index":12637},"code":"  it('will fail to create a class if that class was already created by an object', done => {\n    config.database.loadSchema().then(schema => {\n      schema.validateObject('NewClass', {\n        foo: 7\n      }).then(() => schema.reloadData()).then(() => schema.addClassIfNotExists('NewClass', {\n        foo: {\n          type: 'String'\n        }\n      })).catch(error => {\n        expect(error.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n        expect(error.message).toEqual('Class NewClass already exists.');\n        done();\n      });\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"will resolve class creation races appropriately","suites":["SchemaController"],"line":535,"updatePoint":{"line":535,"column":53,"index":13161},"code":"  it('will resolve class creation races appropriately', done => {\n    // If two callers race to create the same schema, the response to the\n    // race loser should be the same as if they hadn't been racing.\n    config.database.loadSchema().then(schema => {\n      const p1 = schema.addClassIfNotExists('NewClass', {\n        foo: {\n          type: 'String'\n        }\n      }).then(validateSchema).catch(validateError);\n      const p2 = schema.addClassIfNotExists('NewClass', {\n        foo: {\n          type: 'String'\n        }\n      }).then(validateSchema).catch(validateError);\n      let schemaValidated = false;\n      function validateSchema(actualSchema) {\n        const expectedSchema = {\n          className: 'NewClass',\n          fields: {\n            objectId: {\n              type: 'String'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            ACL: {\n              type: 'ACL'\n            },\n            foo: {\n              type: 'String'\n            }\n          },\n          classLevelPermissions: {\n            find: {\n              '*': true\n            },\n            get: {\n              '*': true\n            },\n            count: {\n              '*': true\n            },\n            create: {\n              '*': true\n            },\n            update: {\n              '*': true\n            },\n            delete: {\n              '*': true\n            },\n            addField: {\n              '*': true\n            },\n            protectedFields: {\n              '*': []\n            }\n          }\n        };\n        expect(dd(actualSchema, expectedSchema)).toEqual(undefined);\n        schemaValidated = true;\n      }\n      let errorValidated = false;\n      function validateError(error) {\n        expect(error.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n        expect(error.message).toEqual('Class NewClass already exists.');\n        errorValidated = true;\n      }\n      Promise.all([p1, p2]).then(() => {\n        expect(schemaValidated).toEqual(true);\n        expect(errorValidated).toEqual(true);\n        done();\n      });\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to create classes with invalid names","suites":["SchemaController"],"line":613,"updatePoint":{"line":613,"column":50,"index":15323},"code":"  it('refuses to create classes with invalid names', done => {\n    config.database.loadSchema().then(schema => {\n      schema.addClassIfNotExists('_InvalidName', {\n        foo: {\n          type: 'String'\n        }\n      }).catch(error => {\n        expect(error.message).toEqual('Invalid classname: _InvalidName, classnames can only have alphanumeric characters and _, and must start with an alpha character ');\n        done();\n      });\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add fields with invalid names","suites":["SchemaController"],"line":625,"updatePoint":{"line":625,"column":46,"index":15770},"code":"  it('refuses to add fields with invalid names', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      '0InvalidName': {\n        type: 'String'\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_KEY_NAME);\n      expect(error.message).toEqual('invalid field name: 0InvalidName');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to explicitly create the default fields for custom classes","suites":["SchemaController"],"line":636,"updatePoint":{"line":636,"column":72,"index":16189},"code":"  it('refuses to explicitly create the default fields for custom classes', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      objectId: {\n        type: 'String'\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(136);\n      expect(error.message).toEqual('field objectId cannot be added');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to explicitly create the default fields for non-custom classes","suites":["SchemaController"],"line":647,"updatePoint":{"line":647,"column":76,"index":16579},"code":"  it('refuses to explicitly create the default fields for non-custom classes', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('_Installation', {\n      localeIdentifier: {\n        type: 'String'\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(136);\n      expect(error.message).toEqual('field localeIdentifier cannot be added');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add fields with invalid types","suites":["SchemaController"],"line":658,"updatePoint":{"line":658,"column":46,"index":16960},"code":"  it('refuses to add fields with invalid types', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      foo: {\n        type: 7\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_JSON);\n      expect(error.message).toEqual('invalid JSON');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add fields with invalid pointer types","suites":["SchemaController"],"line":669,"updatePoint":{"line":669,"column":54,"index":17319},"code":"  it('refuses to add fields with invalid pointer types', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      foo: {\n        type: 'Pointer'\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(135);\n      expect(error.message).toEqual('type Pointer needs a class name');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add fields with invalid pointer target","suites":["SchemaController"],"line":680,"updatePoint":{"line":680,"column":55,"index":17685},"code":"  it('refuses to add fields with invalid pointer target', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      foo: {\n        type: 'Pointer',\n        targetClass: 7\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_JSON);\n      expect(error.message).toEqual('invalid JSON');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add fields with invalid Relation type","suites":["SchemaController"],"line":692,"updatePoint":{"line":692,"column":54,"index":18076},"code":"  it('refuses to add fields with invalid Relation type', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      foo: {\n        type: 'Relation',\n        uselessKey: 7\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(135);\n      expect(error.message).toEqual('type Relation needs a class name');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add fields with invalid relation target","suites":["SchemaController"],"line":704,"updatePoint":{"line":704,"column":56,"index":18468},"code":"  it('refuses to add fields with invalid relation target', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      foo: {\n        type: 'Relation',\n        targetClass: 7\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_JSON);\n      expect(error.message).toEqual('invalid JSON');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add fields with uncreatable pointer target class","suites":["SchemaController"],"line":716,"updatePoint":{"line":716,"column":65,"index":18871},"code":"  it('refuses to add fields with uncreatable pointer target class', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      foo: {\n        type: 'Pointer',\n        targetClass: 'not a valid class name'\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n      expect(error.message).toEqual('Invalid classname: not a valid class name, classnames can only have alphanumeric characters and _, and must start with an alpha character ');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add fields with uncreatable relation target class","suites":["SchemaController"],"line":728,"updatePoint":{"line":728,"column":66,"index":19429},"code":"  it('refuses to add fields with uncreatable relation target class', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      foo: {\n        type: 'Relation',\n        targetClass: 'not a valid class name'\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n      expect(error.message).toEqual('Invalid classname: not a valid class name, classnames can only have alphanumeric characters and _, and must start with an alpha character ');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add fields with unknown types","suites":["SchemaController"],"line":740,"updatePoint":{"line":740,"column":46,"index":19968},"code":"  it('refuses to add fields with unknown types', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      foo: {\n        type: 'Unknown'\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(Parse.Error.INCORRECT_TYPE);\n      expect(error.message).toEqual('invalid field type: Unknown');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add CLP with incorrect find","suites":["SchemaController"],"line":751,"updatePoint":{"line":751,"column":44,"index":20342},"code":"  it('refuses to add CLP with incorrect find', done => {\n    const levelPermissions = {\n      find: {\n        '*': false\n      },\n      get: {\n        '*': true\n      },\n      create: {\n        '*': true\n      },\n      update: {\n        '*': true\n      },\n      delete: {\n        '*': true\n      },\n      addField: {\n        '*': true\n      },\n      protectedFields: {\n        '*': ['email']\n      }\n    };\n    config.database.loadSchema().then(schema => {\n      schema.validateObject('NewClass', {}).then(() => schema.reloadData()).then(() => schema.updateClass('NewClass', {}, levelPermissions, {}, config.database)).then(done.fail).catch(error => {\n        expect(error.code).toEqual(Parse.Error.INVALID_JSON);\n        done();\n      });\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add CLP when incorrectly sending a string to protectedFields object value instead of an array","suites":["SchemaController"],"line":782,"updatePoint":{"line":782,"column":110,"index":21162},"code":"  it('refuses to add CLP when incorrectly sending a string to protectedFields object value instead of an array', done => {\n    const levelPermissions = {\n      find: {\n        '*': true\n      },\n      get: {\n        '*': true\n      },\n      create: {\n        '*': true\n      },\n      update: {\n        '*': true\n      },\n      delete: {\n        '*': true\n      },\n      addField: {\n        '*': true\n      },\n      protectedFields: {\n        '*': 'email'\n      }\n    };\n    config.database.loadSchema().then(schema => {\n      schema.validateObject('NewClass', {}).then(() => schema.reloadData()).then(() => schema.updateClass('NewClass', {}, levelPermissions, {}, config.database)).then(done.fail).catch(error => {\n        expect(error.code).toEqual(Parse.Error.INVALID_JSON);\n        done();\n      });\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"will create classes","suites":["SchemaController"],"line":813,"updatePoint":{"line":813,"column":25,"index":21894},"code":"  it('will create classes', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      aNumber: {\n        type: 'Number'\n      },\n      aString: {\n        type: 'String'\n      },\n      aBool: {\n        type: 'Boolean'\n      },\n      aDate: {\n        type: 'Date'\n      },\n      aObject: {\n        type: 'Object'\n      },\n      aArray: {\n        type: 'Array'\n      },\n      aGeoPoint: {\n        type: 'GeoPoint'\n      },\n      aFile: {\n        type: 'File'\n      },\n      aPointer: {\n        type: 'Pointer',\n        targetClass: 'ThisClassDoesNotExistYet'\n      },\n      aRelation: {\n        type: 'Relation',\n        targetClass: 'NewClass'\n      },\n      aBytes: {\n        type: 'Bytes'\n      },\n      aPolygon: {\n        type: 'Polygon'\n      }\n    })).then(actualSchema => {\n      const expectedSchema = {\n        className: 'NewClass',\n        fields: {\n          objectId: {\n            type: 'String'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          ACL: {\n            type: 'ACL'\n          },\n          aString: {\n            type: 'String'\n          },\n          aNumber: {\n            type: 'Number'\n          },\n          aBool: {\n            type: 'Boolean'\n          },\n          aDate: {\n            type: 'Date'\n          },\n          aObject: {\n            type: 'Object'\n          },\n          aArray: {\n            type: 'Array'\n          },\n          aGeoPoint: {\n            type: 'GeoPoint'\n          },\n          aFile: {\n            type: 'File'\n          },\n          aPointer: {\n            type: 'Pointer',\n            targetClass: 'ThisClassDoesNotExistYet'\n          },\n          aRelation: {\n            type: 'Relation',\n            targetClass: 'NewClass'\n          },\n          aBytes: {\n            type: 'Bytes'\n          },\n          aPolygon: {\n            type: 'Polygon'\n          }\n        },\n        classLevelPermissions: {\n          find: {\n            '*': true\n          },\n          get: {\n            '*': true\n          },\n          count: {\n            '*': true\n          },\n          create: {\n            '*': true\n          },\n          update: {\n            '*': true\n          },\n          delete: {\n            '*': true\n          },\n          addField: {\n            '*': true\n          },\n          protectedFields: {\n            '*': []\n          }\n        }\n      };\n      expect(dd(actualSchema, expectedSchema)).toEqual(undefined);\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"creates the default fields for non-custom classes","suites":["SchemaController"],"line":939,"updatePoint":{"line":939,"column":55,"index":24488},"code":"  it('creates the default fields for non-custom classes', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('_Installation', {\n      foo: {\n        type: 'Number'\n      }\n    })).then(actualSchema => {\n      const expectedSchema = {\n        className: '_Installation',\n        fields: {\n          objectId: {\n            type: 'String'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          ACL: {\n            type: 'ACL'\n          },\n          foo: {\n            type: 'Number'\n          },\n          installationId: {\n            type: 'String'\n          },\n          deviceToken: {\n            type: 'String'\n          },\n          channels: {\n            type: 'Array'\n          },\n          deviceType: {\n            type: 'String'\n          },\n          pushType: {\n            type: 'String'\n          },\n          GCMSenderId: {\n            type: 'String'\n          },\n          timeZone: {\n            type: 'String'\n          },\n          localeIdentifier: {\n            type: 'String'\n          },\n          badge: {\n            type: 'Number'\n          },\n          appVersion: {\n            type: 'String'\n          },\n          appName: {\n            type: 'String'\n          },\n          appIdentifier: {\n            type: 'String'\n          },\n          parseVersion: {\n            type: 'String'\n          }\n        },\n        classLevelPermissions: {\n          find: {\n            '*': true\n          },\n          get: {\n            '*': true\n          },\n          count: {\n            '*': true\n          },\n          create: {\n            '*': true\n          },\n          update: {\n            '*': true\n          },\n          delete: {\n            '*': true\n          },\n          addField: {\n            '*': true\n          },\n          protectedFields: {\n            '*': []\n          }\n        }\n      };\n      expect(dd(actualSchema, expectedSchema)).toEqual(undefined);\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"creates non-custom classes which include relation field","suites":["SchemaController"],"line":1034,"updatePoint":{"line":1034,"column":61,"index":26544},"code":"  it('creates non-custom classes which include relation field', async done => {\n    await reconfigureServer();\n    config.database.loadSchema()\n    //as `_Role` is always created by default, we only get it here\n    .then(schema => schema.getOneSchema('_Role')).then(actualSchema => {\n      const expectedSchema = {\n        className: '_Role',\n        fields: {\n          objectId: {\n            type: 'String'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          ACL: {\n            type: 'ACL'\n          },\n          name: {\n            type: 'String'\n          },\n          users: {\n            type: 'Relation',\n            targetClass: '_User'\n          },\n          roles: {\n            type: 'Relation',\n            targetClass: '_Role'\n          }\n        },\n        classLevelPermissions: {\n          find: {\n            '*': true\n          },\n          get: {\n            '*': true\n          },\n          count: {\n            '*': true\n          },\n          create: {\n            '*': true\n          },\n          update: {\n            '*': true\n          },\n          delete: {\n            '*': true\n          },\n          addField: {\n            '*': true\n          },\n          protectedFields: {\n            '*': []\n          }\n        }\n      };\n      expect(dd(actualSchema, expectedSchema)).toEqual(undefined);\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"creates non-custom classes which include pointer field","suites":["SchemaController"],"line":1097,"updatePoint":{"line":1097,"column":60,"index":27989},"code":"  it('creates non-custom classes which include pointer field', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('_Session', {})).then(actualSchema => {\n      const expectedSchema = {\n        className: '_Session',\n        fields: {\n          objectId: {\n            type: 'String'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          user: {\n            type: 'Pointer',\n            targetClass: '_User'\n          },\n          installationId: {\n            type: 'String'\n          },\n          sessionToken: {\n            type: 'String'\n          },\n          expiresAt: {\n            type: 'Date'\n          },\n          createdWith: {\n            type: 'Object'\n          },\n          ACL: {\n            type: 'ACL'\n          }\n        },\n        classLevelPermissions: {\n          find: {\n            '*': true\n          },\n          get: {\n            '*': true\n          },\n          count: {\n            '*': true\n          },\n          create: {\n            '*': true\n          },\n          update: {\n            '*': true\n          },\n          delete: {\n            '*': true\n          },\n          addField: {\n            '*': true\n          },\n          protectedFields: {\n            '*': []\n          }\n        }\n      };\n      expect(dd(actualSchema, expectedSchema)).toEqual(undefined);\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to create two geopoints","suites":["SchemaController"],"line":1162,"updatePoint":{"line":1162,"column":37,"index":29424},"code":"  it('refuses to create two geopoints', done => {\n    config.database.loadSchema().then(schema => schema.addClassIfNotExists('NewClass', {\n      geo1: {\n        type: 'GeoPoint'\n      },\n      geo2: {\n        type: 'GeoPoint'\n      }\n    })).catch(error => {\n      expect(error.code).toEqual(Parse.Error.INCORRECT_TYPE);\n      expect(error.message).toEqual('currently, only one GeoPoint field may exist in an object. Adding geo2 when geo1 already exists.');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can check if a class exists","suites":["SchemaController"],"line":1176,"updatePoint":{"line":1176,"column":33,"index":29906},"code":"  it('can check if a class exists', done => {\n    config.database.loadSchema().then(schema => {\n      return schema.addClassIfNotExists('NewClass', {}).then(() => schema.reloadData({\n        clearCache: true\n      })).then(() => {\n        schema.hasClass('NewClass').then(hasClass => {\n          expect(hasClass).toEqual(true);\n          done();\n        }).catch(fail);\n        schema.hasClass('NonexistantClass').then(hasClass => {\n          expect(hasClass).toEqual(false);\n          done();\n        }).catch(fail);\n      }).catch(error => {\n        fail(\"Couldn't create class\");\n        jfail(error);\n      });\n    }).catch(() => fail(\"Couldn't load schema\"));\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to delete fields from invalid class names","suites":["SchemaController"],"line":1195,"updatePoint":{"line":1195,"column":55,"index":30599},"code":"  it('refuses to delete fields from invalid class names', done => {\n    config.database.loadSchema().then(schema => schema.deleteField('fieldName', 'invalid class name')).catch(error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to delete invalid fields","suites":["SchemaController"],"line":1201,"updatePoint":{"line":1201,"column":38,"index":30864},"code":"  it('refuses to delete invalid fields', done => {\n    config.database.loadSchema().then(schema => schema.deleteField('invalid field name', 'ValidClassName')).catch(error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_KEY_NAME);\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to delete the default fields","suites":["SchemaController"],"line":1207,"updatePoint":{"line":1207,"column":42,"index":31136},"code":"  it('refuses to delete the default fields', done => {\n    config.database.loadSchema().then(schema => schema.deleteField('installationId', '_Installation')).catch(error => {\n      expect(error.code).toEqual(136);\n      expect(error.message).toEqual('field installationId cannot be changed');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to delete fields from nonexistant classes","suites":["SchemaController"],"line":1214,"updatePoint":{"line":1214,"column":55,"index":31470},"code":"  it('refuses to delete fields from nonexistant classes', done => {\n    config.database.loadSchema().then(schema => schema.deleteField('field', 'NoClass')).catch(error => {\n      expect(error.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n      expect(error.message).toEqual('Class NoClass does not exist.');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to delete fields that dont exist","suites":["SchemaController"],"line":1221,"updatePoint":{"line":1221,"column":46,"index":31798},"code":"  it('refuses to delete fields that dont exist', done => {\n    hasAllPODobject().save().then(() => config.database.loadSchema()).then(schema => schema.deleteField('missingField', 'HasAllPOD')).catch(error => {\n      expect(error.code).toEqual(255);\n      expect(error.message).toEqual('Field missingField does not exist, cannot delete.');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"drops related collection when deleting relation field","suites":["SchemaController"],"line":1228,"updatePoint":{"line":1228,"column":59,"index":32178},"code":"  it('drops related collection when deleting relation field', done => {\n    const obj1 = hasAllPODobject();\n    obj1.save().then(savedObj1 => {\n      const obj2 = new Parse.Object('HasPointersAndRelations');\n      obj2.set('aPointer', savedObj1);\n      const relation = obj2.relation('aRelation');\n      relation.add(obj1);\n      return obj2.save();\n    }).then(() => config.database.collectionExists('_Join:aRelation:HasPointersAndRelations')).then(exists => {\n      if (!exists) {\n        fail('Relation collection ' + 'should exist after save.');\n      }\n    }).then(() => config.database.loadSchema()).then(schema => schema.deleteField('aRelation', 'HasPointersAndRelations', config.database)).then(() => config.database.collectionExists('_Join:aRelation:HasPointersAndRelations')).then(exists => {\n      if (exists) {\n        fail('Relation collection should not exist after deleting relation field.');\n      }\n      done();\n    }, error => {\n      jfail(error);\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can delete relation field when related _Join collection not exist","suites":["SchemaController"],"line":1250,"updatePoint":{"line":1250,"column":71,"index":33186},"code":"  it('can delete relation field when related _Join collection not exist', done => {\n    config.database.loadSchema().then(schema => {\n      schema.addClassIfNotExists('NewClass', {\n        relationField: {\n          type: 'Relation',\n          targetClass: '_User'\n        }\n      }).then(actualSchema => {\n        const expectedSchema = {\n          className: 'NewClass',\n          fields: {\n            objectId: {\n              type: 'String'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            ACL: {\n              type: 'ACL'\n            },\n            relationField: {\n              type: 'Relation',\n              targetClass: '_User'\n            }\n          },\n          classLevelPermissions: {\n            find: {\n              '*': true\n            },\n            get: {\n              '*': true\n            },\n            count: {\n              '*': true\n            },\n            create: {\n              '*': true\n            },\n            update: {\n              '*': true\n            },\n            delete: {\n              '*': true\n            },\n            addField: {\n              '*': true\n            },\n            protectedFields: {\n              '*': []\n            }\n          }\n        };\n        expect(dd(actualSchema, expectedSchema)).toEqual(undefined);\n      }).then(() => config.database.collectionExists('_Join:relationField:NewClass')).then(exist => {\n        on_db('postgres', () => {\n          // We create the table when creating the column\n          expect(exist).toEqual(true);\n        }, () => {\n          expect(exist).toEqual(false);\n        });\n      }).then(() => schema.deleteField('relationField', 'NewClass', config.database)).then(() => schema.reloadData()).then(() => {\n        const expectedSchema = {\n          objectId: {\n            type: 'String'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          ACL: {\n            type: 'ACL'\n          }\n        };\n        expect(dd(schema.schemaData.NewClass.fields, expectedSchema)).toEqual(undefined);\n      }).then(done).catch(done.fail);\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can delete string fields and resave as number field","suites":["SchemaController"],"line":1332,"updatePoint":{"line":1332,"column":57,"index":35425},"code":"  it('can delete string fields and resave as number field', done => {\n    Parse.Object.disableSingleInstance();\n    const obj1 = hasAllPODobject();\n    const obj2 = hasAllPODobject();\n    Parse.Object.saveAll([obj1, obj2]).then(() => config.database.loadSchema()).then(schema => schema.deleteField('aString', 'HasAllPOD', config.database)).then(() => new Parse.Query('HasAllPOD').get(obj1.id)).then(obj1Reloaded => {\n      expect(obj1Reloaded.get('aString')).toEqual(undefined);\n      obj1Reloaded.set('aString', ['not a string', 'this time']);\n      obj1Reloaded.save().then(obj1reloadedAgain => {\n        expect(obj1reloadedAgain.get('aString')).toEqual(['not a string', 'this time']);\n        return new Parse.Query('HasAllPOD').get(obj2.id);\n      }).then(obj2reloaded => {\n        expect(obj2reloaded.get('aString')).toEqual(undefined);\n        done();\n      });\n    }).catch(error => {\n      jfail(error);\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can delete pointer fields and resave as string","suites":["SchemaController"],"line":1351,"updatePoint":{"line":1351,"column":52,"index":36360},"code":"  it('can delete pointer fields and resave as string', done => {\n    Parse.Object.disableSingleInstance();\n    const obj1 = new Parse.Object('NewClass');\n    obj1.save().then(() => {\n      obj1.set('aPointer', obj1);\n      return obj1.save();\n    }).then(obj1 => {\n      expect(obj1.get('aPointer').id).toEqual(obj1.id);\n    }).then(() => config.database.loadSchema()).then(schema => schema.deleteField('aPointer', 'NewClass', config.database)).then(() => new Parse.Query('NewClass').get(obj1.id)).then(obj1 => {\n      expect(obj1.get('aPointer')).toEqual(undefined);\n      obj1.set('aPointer', 'Now a string');\n      return obj1.save();\n    }).then(obj1 => {\n      expect(obj1.get('aPointer')).toEqual('Now a string');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can merge schemas","suites":["SchemaController"],"line":1368,"updatePoint":{"line":1368,"column":23,"index":37079},"code":"  it('can merge schemas', done => {\n    expect(SchemaController.buildMergedSchemaObject({\n      _id: 'SomeClass',\n      someType: {\n        type: 'Number'\n      }\n    }, {\n      newType: {\n        type: 'Number'\n      }\n    })).toEqual({\n      someType: {\n        type: 'Number'\n      },\n      newType: {\n        type: 'Number'\n      }\n    });\n    done();\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"can merge deletions","suites":["SchemaController"],"line":1388,"updatePoint":{"line":1388,"column":25,"index":37443},"code":"  it('can merge deletions', done => {\n    expect(SchemaController.buildMergedSchemaObject({\n      _id: 'SomeClass',\n      someType: {\n        type: 'Number'\n      },\n      outDatedType: {\n        type: 'String'\n      }\n    }, {\n      newType: {\n        type: 'GeoPoint'\n      },\n      outDatedType: {\n        __op: 'Delete'\n      }\n    })).toEqual({\n      someType: {\n        type: 'Number'\n      },\n      newType: {\n        type: 'GeoPoint'\n      }\n    });\n    done();\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"ignore default field when merge with system class","suites":["SchemaController"],"line":1414,"updatePoint":{"line":1414,"column":55,"index":37949},"code":"  it('ignore default field when merge with system class', done => {\n    expect(SchemaController.buildMergedSchemaObject({\n      _id: '_User',\n      username: {\n        type: 'String'\n      },\n      password: {\n        type: 'String'\n      },\n      email: {\n        type: 'String'\n      },\n      emailVerified: {\n        type: 'Boolean'\n      }\n    }, {\n      emailVerified: {\n        type: 'String'\n      },\n      customField: {\n        type: 'String'\n      }\n    })).toEqual({\n      customField: {\n        type: 'String'\n      }\n    });\n    done();\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"yields a proper schema mismatch error (#2661)","suites":["SchemaController"],"line":1443,"updatePoint":{"line":1443,"column":51,"index":38501},"code":"  it('yields a proper schema mismatch error (#2661)', done => {\n    const anObject = new Parse.Object('AnObject');\n    const anotherObject = new Parse.Object('AnotherObject');\n    const someObject = new Parse.Object('SomeObject');\n    Parse.Object.saveAll([anObject, anotherObject, someObject]).then(() => {\n      anObject.set('pointer', anotherObject);\n      return anObject.save();\n    }).then(() => {\n      anObject.set('pointer', someObject);\n      return anObject.save();\n    }).then(() => {\n      fail('shoud not save correctly');\n      done();\n    }, err => {\n      expect(err instanceof Parse.Error).toBeTruthy();\n      expect(err.message).toEqual('schema mismatch for AnObject.pointer; expected Pointer<AnotherObject> but got Pointer<SomeObject>');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"yields a proper schema mismatch error bis (#2661)","suites":["SchemaController"],"line":1462,"updatePoint":{"line":1462,"column":55,"index":39291},"code":"  it('yields a proper schema mismatch error bis (#2661)', done => {\n    const anObject = new Parse.Object('AnObject');\n    const someObject = new Parse.Object('SomeObject');\n    Parse.Object.saveAll([anObject, someObject]).then(() => {\n      anObject.set('number', 1);\n      return anObject.save();\n    }).then(() => {\n      anObject.set('number', someObject);\n      return anObject.save();\n    }).then(() => {\n      fail('shoud not save correctly');\n      done();\n    }, err => {\n      expect(err instanceof Parse.Error).toBeTruthy();\n      expect(err.message).toEqual('schema mismatch for AnObject.number; expected Number but got Pointer<SomeObject>');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"yields a proper schema mismatch error ter (#2661)","suites":["SchemaController"],"line":1480,"updatePoint":{"line":1480,"column":55,"index":39974},"code":"  it('yields a proper schema mismatch error ter (#2661)', done => {\n    const anObject = new Parse.Object('AnObject');\n    const someObject = new Parse.Object('SomeObject');\n    Parse.Object.saveAll([anObject, someObject]).then(() => {\n      anObject.set('pointer', someObject);\n      return anObject.save();\n    }).then(() => {\n      anObject.set('pointer', 1);\n      return anObject.save();\n    }).then(() => {\n      fail('shoud not save correctly');\n      done();\n    }, err => {\n      expect(err instanceof Parse.Error).toBeTruthy();\n      expect(err.message).toEqual('schema mismatch for AnObject.pointer; expected Pointer<SomeObject> but got Number');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"properly handles volatile _Schemas","suites":["SchemaController"],"line":1498,"updatePoint":{"line":1498,"column":40,"index":40645},"code":"  it('properly handles volatile _Schemas', async done => {\n    await reconfigureServer();\n    function validateSchemaStructure(schema) {\n      expect(Object.prototype.hasOwnProperty.call(schema, 'className')).toBe(true);\n      expect(Object.prototype.hasOwnProperty.call(schema, 'fields')).toBe(true);\n      expect(Object.prototype.hasOwnProperty.call(schema, 'classLevelPermissions')).toBe(true);\n    }\n    function validateSchemaDataStructure(schemaData) {\n      Object.keys(schemaData).forEach(className => {\n        const schema = schemaData[className];\n        // Hooks has className...\n        if (className != '_Hooks') {\n          expect(Object.prototype.hasOwnProperty.call(schema, 'className')).toBe(false);\n        }\n        expect(Object.prototype.hasOwnProperty.call(schema, 'fields')).toBe(false);\n        expect(Object.prototype.hasOwnProperty.call(schema, 'classLevelPermissions')).toBe(false);\n      });\n    }\n    let schema;\n    config.database.loadSchema().then(s => {\n      schema = s;\n      return schema.getOneSchema('_User', false);\n    }).then(userSchema => {\n      validateSchemaStructure(userSchema);\n      validateSchemaDataStructure(schema.schemaData);\n      return schema.getOneSchema('_PushStatus', true);\n    }).then(pushStatusSchema => {\n      validateSchemaStructure(pushStatusSchema);\n      validateSchemaDataStructure(schema.schemaData);\n    }).then(done).catch(done.fail);\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"should not throw on null field types","suites":["SchemaController"],"line":1529,"updatePoint":{"line":1529,"column":42,"index":42062},"code":"  it('should not throw on null field types', async () => {\n    const schema = await config.database.loadSchema();\n    const result = await schema.enforceFieldExists('NewClass', 'fieldName', null);\n    expect(result).toBeUndefined();\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"ensureFields should throw when schema is not set","suites":["SchemaController"],"line":1534,"updatePoint":{"line":1534,"column":54,"index":42313},"code":"  it('ensureFields should throw when schema is not set', async () => {\n    const schema = await config.database.loadSchema();\n    try {\n      schema.ensureFields([{\n        className: 'NewClass',\n        fieldName: 'fieldName',\n        type: 'String'\n      }]);\n    } catch (e) {\n      expect(e.message).toBe('Could not add field fieldName');\n    }\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"required auth test find","suites":["Class Level Permissions for requiredAuth"],"line":1557,"updatePoint":{"line":1557,"column":29,"index":42933},"code":"  it('required auth test find', done => {\n    config.database.loadSchema().then(schema => {\n      // Just to create a valid class\n      return schema.validateObject('Stuff', {\n        foo: 'bar'\n      });\n    }).then(schema => {\n      return schema.setPermissions('Stuff', {\n        find: {\n          requiresAuthentication: true\n        }\n      });\n    }).then(() => {\n      const query = new Parse.Query('Stuff');\n      return query.find();\n    }).then(() => {\n      fail('Class permissions should have rejected this query.');\n      done();\n    }, e => {\n      expect(e.message).toEqual('Permission denied, user needs to be authenticated.');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"required auth test find authenticated","suites":["Class Level Permissions for requiredAuth"],"line":1580,"updatePoint":{"line":1580,"column":43,"index":43619},"code":"  it('required auth test find authenticated', done => {\n    config.database.loadSchema().then(schema => {\n      // Just to create a valid class\n      return schema.validateObject('Stuff', {\n        foo: 'bar'\n      });\n    }).then(schema => {\n      return schema.setPermissions('Stuff', {\n        find: {\n          requiresAuthentication: true\n        }\n      });\n    }).then(() => {\n      return createUser();\n    }).then(() => {\n      const query = new Parse.Query('Stuff');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toEqual(0);\n      done();\n    }, e => {\n      console.error(e);\n      fail('Should not have failed');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"required auth should allow create authenticated","suites":["Class Level Permissions for requiredAuth"],"line":1606,"updatePoint":{"line":1606,"column":53,"index":44317},"code":"  it('required auth should allow create authenticated', done => {\n    config.database.loadSchema().then(schema => {\n      // Just to create a valid class\n      return schema.validateObject('Stuff', {\n        foo: 'bar'\n      });\n    }).then(schema => {\n      return schema.setPermissions('Stuff', {\n        create: {\n          requiresAuthentication: true\n        }\n      });\n    }).then(() => {\n      return createUser();\n    }).then(() => {\n      const stuff = new Parse.Object('Stuff');\n      stuff.set('foo', 'bar');\n      return stuff.save();\n    }).then(() => {\n      done();\n    }, e => {\n      console.error(e);\n      fail('Should not have failed');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"required auth should reject create when not authenticated","suites":["Class Level Permissions for requiredAuth"],"line":1632,"updatePoint":{"line":1632,"column":63,"index":45013},"code":"  it('required auth should reject create when not authenticated', done => {\n    config.database.loadSchema().then(schema => {\n      // Just to create a valid class\n      return schema.validateObject('Stuff', {\n        foo: 'bar'\n      });\n    }).then(schema => {\n      return schema.setPermissions('Stuff', {\n        create: {\n          requiresAuthentication: true\n        }\n      });\n    }).then(() => {\n      const stuff = new Parse.Object('Stuff');\n      stuff.set('foo', 'bar');\n      return stuff.save();\n    }).then(() => {\n      fail('Class permissions should have rejected this query.');\n      done();\n    }, e => {\n      expect(e.message).toEqual('Permission denied, user needs to be authenticated.');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"required auth test create/get/update/delete authenticated","suites":["Class Level Permissions for requiredAuth"],"line":1656,"updatePoint":{"line":1656,"column":63,"index":45753},"code":"  it('required auth test create/get/update/delete authenticated', done => {\n    config.database.loadSchema().then(schema => {\n      // Just to create a valid class\n      return schema.validateObject('Stuff', {\n        foo: 'bar'\n      });\n    }).then(schema => {\n      return schema.setPermissions('Stuff', {\n        create: {\n          requiresAuthentication: true\n        },\n        get: {\n          requiresAuthentication: true\n        },\n        delete: {\n          requiresAuthentication: true\n        },\n        update: {\n          requiresAuthentication: true\n        }\n      });\n    }).then(() => {\n      return createUser();\n    }).then(() => {\n      const stuff = new Parse.Object('Stuff');\n      stuff.set('foo', 'bar');\n      return stuff.save().then(() => {\n        const query = new Parse.Query('Stuff');\n        return query.get(stuff.id);\n      });\n    }).then(gotStuff => {\n      return gotStuff.save({\n        foo: 'baz'\n      }).then(() => {\n        return gotStuff.destroy();\n      });\n    }).then(() => {\n      done();\n    }, e => {\n      console.error(e);\n      fail('Should not have failed');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"required auth test get not authenticated","suites":["Class Level Permissions for requiredAuth"],"line":1700,"updatePoint":{"line":1700,"column":46,"index":46880},"code":"  it('required auth test get not authenticated', done => {\n    config.database.loadSchema().then(schema => {\n      // Just to create a valid class\n      return schema.validateObject('Stuff', {\n        foo: 'bar'\n      });\n    }).then(schema => {\n      return schema.setPermissions('Stuff', {\n        get: {\n          requiresAuthentication: true\n        },\n        create: {\n          '*': true\n        }\n      });\n    }).then(() => {\n      const stuff = new Parse.Object('Stuff');\n      stuff.set('foo', 'bar');\n      return stuff.save().then(() => {\n        const query = new Parse.Query('Stuff');\n        return query.get(stuff.id);\n      });\n    }).then(() => {\n      fail('Should not succeed!');\n      done();\n    }, e => {\n      expect(e.message).toEqual('Permission denied, user needs to be authenticated.');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"required auth test find not authenticated","suites":["Class Level Permissions for requiredAuth"],"line":1730,"updatePoint":{"line":1730,"column":47,"index":47725},"code":"  it('required auth test find not authenticated', done => {\n    config.database.loadSchema().then(schema => {\n      // Just to create a valid class\n      return schema.validateObject('Stuff', {\n        foo: 'bar'\n      });\n    }).then(schema => {\n      return schema.setPermissions('Stuff', {\n        find: {\n          requiresAuthentication: true\n        },\n        create: {\n          '*': true\n        },\n        get: {\n          '*': true\n        }\n      });\n    }).then(() => {\n      const stuff = new Parse.Object('Stuff');\n      stuff.set('foo', 'bar');\n      return stuff.save().then(() => {\n        const query = new Parse.Query('Stuff');\n        return query.get(stuff.id);\n      });\n    }).then(result => {\n      expect(result.get('foo')).toEqual('bar');\n      const query = new Parse.Query('Stuff');\n      return query.find();\n    }).then(() => {\n      fail('Should not succeed!');\n      done();\n    }, e => {\n      expect(e.message).toEqual('Permission denied, user needs to be authenticated.');\n      done();\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"required auth test create/get/update/delete with roles (#3753)","suites":["Class Level Permissions for requiredAuth"],"line":1767,"updatePoint":{"line":1767,"column":68,"index":48783},"code":"  it('required auth test create/get/update/delete with roles (#3753)', done => {\n    let user;\n    config.database.loadSchema().then(schema => {\n      // Just to create a valid class\n      return schema.validateObject('Stuff', {\n        foo: 'bar'\n      });\n    }).then(schema => {\n      return schema.setPermissions('Stuff', {\n        find: {\n          requiresAuthentication: true,\n          'role:admin': true\n        },\n        create: {\n          'role:admin': true\n        },\n        update: {\n          'role:admin': true\n        },\n        delete: {\n          'role:admin': true\n        },\n        get: {\n          requiresAuthentication: true,\n          'role:admin': true\n        }\n      });\n    }).then(() => {\n      const stuff = new Parse.Object('Stuff');\n      stuff.set('foo', 'bar');\n      return stuff.save(null, {\n        useMasterKey: true\n      }).then(() => {\n        const query = new Parse.Query('Stuff');\n        return query.get(stuff.id).then(() => {\n          done.fail('should not succeed');\n        }, () => {\n          return new Parse.Query('Stuff').find();\n        }).then(() => {\n          done.fail('should not succeed');\n        }, () => {\n          return Promise.resolve();\n        });\n      }).then(() => {\n        return Parse.User.signUp('user', 'password').then(signedUpUser => {\n          user = signedUpUser;\n          const query = new Parse.Query('Stuff');\n          return query.get(stuff.id, {\n            sessionToken: user.getSessionToken()\n          });\n        });\n      });\n    }).then(result => {\n      expect(result.get('foo')).toEqual('bar');\n      const query = new Parse.Query('Stuff');\n      return query.find({\n        sessionToken: user.getSessionToken()\n      });\n    }).then(results => {\n      expect(results.length).toBe(1);\n      done();\n    }, e => {\n      console.error(e);\n      done.fail(e);\n    });\n  });","file":"Schema.spec.js","skipped":false,"dir":"spec"},{"name":"test new object","suites":["Schema Performance"],"line":14,"updatePoint":{"line":14,"column":21,"index":425},"code":"  it('test new object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n    expect(getAllSpy.calls.count()).toBe(2);\n  });","file":"SchemaPerformance.spec.js","skipped":false,"dir":"spec"},{"name":"test new object multiple fields","suites":["Schema Performance"],"line":20,"updatePoint":{"line":20,"column":37,"index":622},"code":"  it('test new object multiple fields', async () => {\n    const container = new Container({\n      dateField: new Date(),\n      arrayField: [],\n      numberField: 1,\n      stringField: 'hello',\n      booleanField: true\n    });\n    await container.save();\n    expect(getAllSpy.calls.count()).toBe(2);\n  });","file":"SchemaPerformance.spec.js","skipped":false,"dir":"spec"},{"name":"test update existing fields","suites":["Schema Performance"],"line":31,"updatePoint":{"line":31,"column":33,"index":923},"code":"  it('test update existing fields', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n    getAllSpy.calls.reset();\n    object.set('foo', 'barz');\n    await object.save();\n    expect(getAllSpy.calls.count()).toBe(0);\n  });","file":"SchemaPerformance.spec.js","skipped":false,"dir":"spec"},{"name":"test saveAll / destroyAll","suites":["Schema Performance"],"line":40,"updatePoint":{"line":40,"column":32,"index":1200},"skipped":true,"code":"  xit('test saveAll / destroyAll', async () => {\n    // This test can be flaky due to the nature of /batch requests\n    // Used for performance\n    const object = new TestObject();\n    await object.save();\n    getAllSpy.calls.reset();\n    const objects = [];\n    for (let i = 0; i < 10; i++) {\n      const object = new TestObject();\n      object.set('number', i);\n      objects.push(object);\n    }\n    await Parse.Object.saveAll(objects);\n    expect(getAllSpy.calls.count()).toBe(0);\n    getAllSpy.calls.reset();\n    const query = new Parse.Query(TestObject);\n    await query.find();\n    expect(getAllSpy.calls.count()).toBe(0);\n    getAllSpy.calls.reset();\n    await Parse.Object.destroyAll(objects);\n    expect(getAllSpy.calls.count()).toBe(0);\n  });","file":"SchemaPerformance.spec.js","dir":"spec"},{"name":"test add new field to existing object","suites":["Schema Performance"],"line":62,"updatePoint":{"line":62,"column":43,"index":1964},"code":"  it('test add new field to existing object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n    getAllSpy.calls.reset();\n    object.set('new', 'barz');\n    await object.save();\n    expect(getAllSpy.calls.count()).toBe(1);\n  });","file":"SchemaPerformance.spec.js","skipped":false,"dir":"spec"},{"name":"test add multiple fields to existing object","suites":["Schema Performance"],"line":71,"updatePoint":{"line":71,"column":49,"index":2258},"code":"  it('test add multiple fields to existing object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n    getAllSpy.calls.reset();\n    object.set({\n      dateField: new Date(),\n      arrayField: [],\n      numberField: 1,\n      stringField: 'hello',\n      booleanField: true\n    });\n    await object.save();\n    expect(getAllSpy.calls.count()).toBe(1);\n  });","file":"SchemaPerformance.spec.js","skipped":false,"dir":"spec"},{"name":"test user","suites":["Schema Performance"],"line":86,"updatePoint":{"line":86,"column":15,"index":2638},"code":"  it('test user', async () => {\n    const user = new Parse.User();\n    user.setUsername('testing');\n    user.setPassword('testing');\n    await user.signUp();\n    expect(getAllSpy.calls.count()).toBe(1);\n  });","file":"SchemaPerformance.spec.js","skipped":false,"dir":"spec"},{"name":"test query include","suites":["Schema Performance"],"line":93,"updatePoint":{"line":93,"column":24,"index":2856},"code":"  it('test query include', async () => {\n    const child = new TestObject();\n    await child.save();\n    const object = new TestObject();\n    object.set('child', child);\n    await object.save();\n    getAllSpy.calls.reset();\n    const query = new Parse.Query(TestObject);\n    query.include('child');\n    await query.get(object.id);\n    expect(getAllSpy.calls.count()).toBe(0);\n  });","file":"SchemaPerformance.spec.js","skipped":false,"dir":"spec"},{"name":"query relation without schema","suites":["Schema Performance"],"line":105,"updatePoint":{"line":105,"column":35,"index":3249},"code":"  it('query relation without schema', async () => {\n    const child = new Parse.Object('ChildObject');\n    await child.save();\n    const parent = new Parse.Object('ParentObject');\n    const relation = parent.relation('child');\n    relation.add(child);\n    await parent.save();\n    getAllSpy.calls.reset();\n    const objects = await relation.query().find();\n    expect(objects.length).toBe(1);\n    expect(objects[0].id).toBe(child.id);\n    expect(getAllSpy.calls.count()).toBe(0);\n  });","file":"SchemaPerformance.spec.js","skipped":false,"dir":"spec"},{"name":"test delete object","suites":["Schema Performance"],"line":118,"updatePoint":{"line":118,"column":24,"index":3724},"code":"  it('test delete object', async () => {\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n    getAllSpy.calls.reset();\n    await object.destroy();\n    expect(getAllSpy.calls.count()).toBe(0);\n  });","file":"SchemaPerformance.spec.js","skipped":false,"dir":"spec"},{"name":"test schema update class","suites":["Schema Performance"],"line":126,"updatePoint":{"line":126,"column":30,"index":3971},"code":"  it('test schema update class', async () => {\n    const container = new Container();\n    await container.save();\n    getAllSpy.calls.reset();\n    const schema = await config.database.loadSchema();\n    await schema.reloadData();\n    const levelPermissions = {\n      find: {\n        '*': true\n      },\n      get: {\n        '*': true\n      },\n      create: {\n        '*': true\n      },\n      update: {\n        '*': true\n      },\n      delete: {\n        '*': true\n      },\n      addField: {\n        '*': true\n      },\n      protectedFields: {\n        '*': []\n      }\n    };\n    await schema.updateClass('Container', {\n      fooOne: {\n        type: 'Number'\n      },\n      fooTwo: {\n        type: 'Array'\n      },\n      fooThree: {\n        type: 'Date'\n      },\n      fooFour: {\n        type: 'Object'\n      },\n      fooFive: {\n        type: 'Relation',\n        targetClass: '_User'\n      },\n      fooSix: {\n        type: 'String'\n      },\n      fooSeven: {\n        type: 'Object'\n      },\n      fooEight: {\n        type: 'String'\n      },\n      fooNine: {\n        type: 'String'\n      },\n      fooTeen: {\n        type: 'Number'\n      },\n      fooEleven: {\n        type: 'String'\n      },\n      fooTwelve: {\n        type: 'String'\n      },\n      fooThirteen: {\n        type: 'String'\n      },\n      fooFourteen: {\n        type: 'String'\n      },\n      fooFifteen: {\n        type: 'String'\n      },\n      fooSixteen: {\n        type: 'String'\n      },\n      fooEighteen: {\n        type: 'String'\n      },\n      fooNineteen: {\n        type: 'String'\n      }\n    }, levelPermissions, {}, config.database);\n    expect(getAllSpy.calls.count()).toBe(2);\n  });","file":"SchemaPerformance.spec.js","skipped":false,"dir":"spec"},{"name":"requires the master key to get all schemas","suites":["schemas"],"line":212,"updatePoint":{"line":212,"column":48,"index":3881},"code":"  it('requires the master key to get all schemas', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas',\n      json: true,\n      headers: noAuthHeaders\n    }).then(fail, response => {\n      //api.parse.com uses status code 401, but due to the lack of keys\n      //being necessary in parse-server, 403 makes more sense\n      expect(response.status).toEqual(403);\n      expect(response.data.error).toEqual('unauthorized');\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"requires the master key to get one schema","suites":["schemas"],"line":225,"updatePoint":{"line":225,"column":47,"index":4345},"code":"  it('requires the master key to get one schema', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/SomeSchema',\n      json: true,\n      headers: restKeyHeaders\n    }).then(fail, response => {\n      expect(response.status).toEqual(403);\n      expect(response.data.error).toEqual('unauthorized: master key is required');\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"asks for the master key if you use the rest key","suites":["schemas"],"line":236,"updatePoint":{"line":236,"column":53,"index":4717},"code":"  it('asks for the master key if you use the rest key', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas',\n      json: true,\n      headers: restKeyHeaders\n    }).then(fail, response => {\n      expect(response.status).toEqual(403);\n      expect(response.data.error).toEqual('unauthorized: master key is required');\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"creates _User schema when server starts","suites":["schemas"],"line":247,"updatePoint":{"line":247,"column":45,"index":5070},"code":"  it('creates _User schema when server starts', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas',\n      json: true,\n      headers: masterKeyHeaders\n    }).then(response => {\n      const expected = {\n        results: [userSchema, roleSchema]\n      };\n      expect(response.data.results.sort((s1, s2) => s1.className.localeCompare(s2.className)).map(s => {\n        const withoutIndexes = Object.assign({}, s);\n        delete withoutIndexes.indexes;\n        return withoutIndexes;\n      })).toEqual(expected.results.sort((s1, s2) => s1.className.localeCompare(s2.className)));\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"responds with a list of schemas after creating objects","suites":["schemas"],"line":264,"updatePoint":{"line":264,"column":60,"index":5707},"code":"  it('responds with a list of schemas after creating objects', done => {\n    const obj1 = hasAllPODobject();\n    obj1.save().then(savedObj1 => {\n      const obj2 = new Parse.Object('HasPointersAndRelations');\n      obj2.set('aPointer', savedObj1);\n      const relation = obj2.relation('aRelation');\n      relation.add(obj1);\n      return obj2.save();\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas',\n        json: true,\n        headers: masterKeyHeaders\n      }).then(response => {\n        const expected = {\n          results: [userSchema, roleSchema, plainOldDataSchema, pointersAndRelationsSchema]\n        };\n        expect(response.data.results.sort((s1, s2) => s1.className.localeCompare(s2.className)).map(s => {\n          const withoutIndexes = Object.assign({}, s);\n          delete withoutIndexes.indexes;\n          return withoutIndexes;\n        })).toEqual(expected.results.sort((s1, s2) => s1.className.localeCompare(s2.className)));\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"ensure refresh cache after creating a class","suites":["schemas"],"line":290,"updatePoint":{"line":290,"column":49,"index":6717},"code":"  it('ensure refresh cache after creating a class', async done => {\n    spyOn(SchemaController.prototype, 'reloadData').and.callFake(() => Promise.resolve());\n    await request({\n      url: 'http://localhost:8378/1/schemas',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'A'\n      }\n    });\n    const response = await request({\n      url: 'http://localhost:8378/1/schemas',\n      method: 'GET',\n      headers: masterKeyHeaders,\n      json: true\n    });\n    const expected = {\n      results: [userSchema, roleSchema, {\n        className: 'A',\n        fields: {\n          //Default fields\n          ACL: {\n            type: 'ACL'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          objectId: {\n            type: 'String'\n          }\n        },\n        classLevelPermissions: defaultClassLevelPermissions\n      }]\n    };\n    expect(response.data.results.sort((s1, s2) => s1.className.localeCompare(s2.className)).map(s => {\n      const withoutIndexes = Object.assign({}, s);\n      delete withoutIndexes.indexes;\n      return withoutIndexes;\n    })).toEqual(expected.results.sort((s1, s2) => s1.className.localeCompare(s2.className)));\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"responds with a single schema","suites":["schemas"],"line":335,"updatePoint":{"line":335,"column":35,"index":8006},"code":"  it('responds with a single schema', done => {\n    const obj = hasAllPODobject();\n    obj.save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/HasAllPOD',\n        json: true,\n        headers: masterKeyHeaders\n      }).then(response => {\n        expect(response.data).toEqual(plainOldDataSchema);\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"treats class names case sensitively","suites":["schemas"],"line":348,"updatePoint":{"line":348,"column":41,"index":8378},"code":"  it('treats class names case sensitively', done => {\n    const obj = hasAllPODobject();\n    obj.save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/HASALLPOD',\n        json: true,\n        headers: masterKeyHeaders\n      }).then(fail, response => {\n        expect(response.status).toEqual(400);\n        expect(response.data).toEqual({\n          code: 103,\n          error: 'Class HASALLPOD does not exist.'\n        });\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"requires the master key to create a schema","suites":["schemas"],"line":365,"updatePoint":{"line":365,"column":48,"index":8874},"code":"  it('requires the master key to create a schema', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas',\n      method: 'POST',\n      json: true,\n      headers: noAuthHeaders,\n      body: {\n        className: 'MyClass'\n      }\n    }).then(fail, response => {\n      expect(response.status).toEqual(403);\n      expect(response.data.error).toEqual('unauthorized');\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"sends an error if you use mismatching class names","suites":["schemas"],"line":380,"updatePoint":{"line":380,"column":55,"index":9286},"code":"  it('sends an error if you use mismatching class names', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/A',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'B'\n      }\n    }).then(fail, response => {\n      expect(response.status).toEqual(400);\n      expect(response.data).toEqual({\n        code: Parse.Error.INVALID_CLASS_NAME,\n        error: 'Class name mismatch between B and A.'\n      });\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"sends an error if you use no class name","suites":["schemas"],"line":398,"updatePoint":{"line":398,"column":45,"index":9776},"code":"  it('sends an error if you use no class name', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {}\n    }).then(fail, response => {\n      expect(response.status).toEqual(400);\n      expect(response.data).toEqual({\n        code: 135,\n        error: 'POST /schemas needs a class name.'\n      });\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"sends an error if you try to create the same class twice","suites":["schemas"],"line":414,"updatePoint":{"line":414,"column":62,"index":10221},"code":"  it('sends an error if you try to create the same class twice', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'A'\n      }\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          className: 'A'\n        }\n      }).then(fail, response => {\n        expect(response.status).toEqual(400);\n        expect(response.data).toEqual({\n          code: Parse.Error.INVALID_CLASS_NAME,\n          error: 'Class A already exists.'\n        });\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"responds with all fields when you create a class","suites":["schemas"],"line":442,"updatePoint":{"line":442,"column":54,"index":10943},"code":"  it('responds with all fields when you create a class', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'NewClass',\n        fields: {\n          foo: {\n            type: 'Number'\n          },\n          ptr: {\n            type: 'Pointer',\n            targetClass: 'SomeClass'\n          }\n        }\n      }\n    }).then(response => {\n      expect(response.data).toEqual({\n        className: 'NewClass',\n        fields: {\n          ACL: {\n            type: 'ACL'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          objectId: {\n            type: 'String'\n          },\n          foo: {\n            type: 'Number'\n          },\n          ptr: {\n            type: 'Pointer',\n            targetClass: 'SomeClass'\n          }\n        },\n        classLevelPermissions: defaultClassLevelPermissions\n      });\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"responds with all fields and options when you create a class with field options","suites":["schemas"],"line":489,"updatePoint":{"line":489,"column":85,"index":12019},"code":"  it('responds with all fields and options when you create a class with field options', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'NewClassWithOptions',\n        fields: {\n          foo1: {\n            type: 'Number'\n          },\n          foo2: {\n            type: 'Number',\n            required: true,\n            defaultValue: 10\n          },\n          foo3: {\n            type: 'String',\n            required: false,\n            defaultValue: 'some string'\n          },\n          foo4: {\n            type: 'Date',\n            required: true\n          },\n          foo5: {\n            type: 'Number',\n            defaultValue: 5\n          },\n          ptr: {\n            type: 'Pointer',\n            targetClass: 'SomeClass',\n            required: false\n          },\n          defaultFalse: {\n            type: 'Boolean',\n            required: true,\n            defaultValue: false\n          },\n          defaultZero: {\n            type: 'Number',\n            defaultValue: 0\n          },\n          relation: {\n            type: 'Relation',\n            targetClass: 'SomeClass'\n          }\n        }\n      }\n    }).then(async response => {\n      expect(response.data).toEqual({\n        className: 'NewClassWithOptions',\n        fields: {\n          ACL: {\n            type: 'ACL'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          objectId: {\n            type: 'String'\n          },\n          foo1: {\n            type: 'Number'\n          },\n          foo2: {\n            type: 'Number',\n            required: true,\n            defaultValue: 10\n          },\n          foo3: {\n            type: 'String',\n            required: false,\n            defaultValue: 'some string'\n          },\n          foo4: {\n            type: 'Date',\n            required: true\n          },\n          foo5: {\n            type: 'Number',\n            defaultValue: 5\n          },\n          ptr: {\n            type: 'Pointer',\n            targetClass: 'SomeClass',\n            required: false\n          },\n          defaultFalse: {\n            type: 'Boolean',\n            required: true,\n            defaultValue: false\n          },\n          defaultZero: {\n            type: 'Number',\n            defaultValue: 0\n          },\n          relation: {\n            type: 'Relation',\n            targetClass: 'SomeClass'\n          }\n        },\n        classLevelPermissions: defaultClassLevelPermissions\n      });\n      const obj = new Parse.Object('NewClassWithOptions');\n      try {\n        await obj.save();\n        fail('should fail');\n      } catch (e) {\n        expect(e.code).toEqual(142);\n      }\n      const date = new Date();\n      obj.set('foo4', date);\n      await obj.save();\n      expect(obj.get('foo1')).toBeUndefined();\n      expect(obj.get('foo2')).toEqual(10);\n      expect(obj.get('foo3')).toEqual('some string');\n      expect(obj.get('foo4')).toEqual(date);\n      expect(obj.get('foo5')).toEqual(5);\n      expect(obj.get('ptr')).toBeUndefined();\n      expect(obj.get('defaultFalse')).toEqual(false);\n      expect(obj.get('defaultZero')).toEqual(0);\n      expect(obj.get('ptr')).toBeUndefined();\n      expect(obj.get('relation')).toBeUndefined();\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"try to set a relation field as a required field","suites":["schemas"],"line":620,"updatePoint":{"line":620,"column":53,"index":15381},"code":"  it('try to set a relation field as a required field', async done => {\n    try {\n      await request({\n        url: 'http://localhost:8378/1/schemas',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          className: 'NewClassWithRelationRequired',\n          fields: {\n            foo: {\n              type: 'String'\n            },\n            relation: {\n              type: 'Relation',\n              targetClass: 'SomeClass',\n              required: true\n            }\n          }\n        }\n      });\n      fail('should fail');\n    } catch (e) {\n      expect(e.data.code).toEqual(111);\n    }\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"try to set a relation field with a default value","suites":["schemas"],"line":647,"updatePoint":{"line":647,"column":54,"index":16045},"code":"  it('try to set a relation field with a default value', async done => {\n    try {\n      await request({\n        url: 'http://localhost:8378/1/schemas',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          className: 'NewClassRelationWithOptions',\n          fields: {\n            foo: {\n              type: 'String'\n            },\n            relation: {\n              type: 'Relation',\n              targetClass: 'SomeClass',\n              defaultValue: {\n                __type: 'Relation',\n                className: '_User'\n              }\n            }\n          }\n        }\n      });\n      fail('should fail');\n    } catch (e) {\n      expect(e.data.code).toEqual(111);\n    }\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"try to update schemas with a relation field with options","suites":["schemas"],"line":677,"updatePoint":{"line":677,"column":62,"index":16804},"code":"  it('try to update schemas with a relation field with options', async done => {\n    await request({\n      url: 'http://localhost:8378/1/schemas',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'NewClassRelationWithOptions',\n        fields: {\n          foo: {\n            type: 'String'\n          }\n        }\n      }\n    });\n    try {\n      await request({\n        url: 'http://localhost:8378/1/schemas/NewClassRelationWithOptions',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          className: 'NewClassRelationWithOptions',\n          fields: {\n            relation: {\n              type: 'Relation',\n              targetClass: 'SomeClass',\n              required: true\n            }\n          },\n          _method: 'PUT'\n        }\n      });\n      fail('should fail');\n    } catch (e) {\n      expect(e.data.code).toEqual(111);\n    }\n    try {\n      await request({\n        url: 'http://localhost:8378/1/schemas/NewClassRelationWithOptions',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          className: 'NewClassRelationWithOptions',\n          fields: {\n            relation: {\n              type: 'Relation',\n              targetClass: 'SomeClass',\n              defaultValue: {\n                __type: 'Relation',\n                className: '_User'\n              }\n            }\n          },\n          _method: 'PUT'\n        }\n      });\n      fail('should fail');\n    } catch (e) {\n      expect(e.data.code).toEqual(111);\n    }\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"validated the data type of default values when creating a new class","suites":["schemas"],"line":741,"updatePoint":{"line":741,"column":73,"index":18431},"code":"  it('validated the data type of default values when creating a new class', async () => {\n    try {\n      await request({\n        url: 'http://localhost:8378/1/schemas',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          className: 'NewClassWithValidation',\n          fields: {\n            foo: {\n              type: 'String',\n              defaultValue: 10\n            }\n          }\n        }\n      });\n      fail('should fail');\n    } catch (e) {\n      expect(e.data.error).toEqual('schema mismatch for NewClassWithValidation.foo default value; expected String but got Number');\n    }\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"validated the data type of default values when adding new fields","suites":["schemas"],"line":763,"updatePoint":{"line":763,"column":70,"index":19075},"code":"  it('validated the data type of default values when adding new fields', async () => {\n    try {\n      await request({\n        url: 'http://localhost:8378/1/schemas',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          className: 'NewClassWithValidation',\n          fields: {\n            foo: {\n              type: 'String',\n              defaultValue: 'some value'\n            }\n          }\n        }\n      });\n      await request({\n        url: 'http://localhost:8378/1/schemas/NewClassWithValidation',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          className: 'NewClassWithValidation',\n          fields: {\n            foo2: {\n              type: 'String',\n              defaultValue: 10\n            }\n          }\n        }\n      });\n      fail('should fail');\n    } catch (e) {\n      expect(e.data.error).toEqual('schema mismatch for NewClassWithValidation.foo2 default value; expected String but got Number');\n    }\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"responds with all fields when getting incomplete schema","suites":["schemas"],"line":800,"updatePoint":{"line":800,"column":61,"index":20102},"code":"  it('responds with all fields when getting incomplete schema', done => {\n    config.database.loadSchema().then(schemaController => schemaController.addClassIfNotExists('_Installation', {}, defaultClassLevelPermissions)).then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/_Installation',\n        headers: masterKeyHeaders,\n        json: true\n      }).then(response => {\n        expect(dd(response.data, {\n          className: '_Installation',\n          fields: {\n            objectId: {\n              type: 'String'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            installationId: {\n              type: 'String'\n            },\n            deviceToken: {\n              type: 'String'\n            },\n            channels: {\n              type: 'Array'\n            },\n            deviceType: {\n              type: 'String'\n            },\n            pushType: {\n              type: 'String'\n            },\n            GCMSenderId: {\n              type: 'String'\n            },\n            timeZone: {\n              type: 'String'\n            },\n            badge: {\n              type: 'Number'\n            },\n            appIdentifier: {\n              type: 'String'\n            },\n            localeIdentifier: {\n              type: 'String'\n            },\n            appVersion: {\n              type: 'String'\n            },\n            appName: {\n              type: 'String'\n            },\n            parseVersion: {\n              type: 'String'\n            },\n            ACL: {\n              type: 'ACL'\n            }\n          },\n          classLevelPermissions: defaultClassLevelPermissions\n        })).toBeUndefined();\n        done();\n      });\n    }).catch(error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"lets you specify class name in both places","suites":["schemas"],"line":871,"updatePoint":{"line":871,"column":48,"index":21966},"code":"  it('lets you specify class name in both places', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/NewClass',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'NewClass'\n      }\n    }).then(response => {\n      expect(response.data).toEqual({\n        className: 'NewClass',\n        fields: {\n          ACL: {\n            type: 'ACL'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          objectId: {\n            type: 'String'\n          }\n        },\n        classLevelPermissions: defaultClassLevelPermissions\n      });\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"requires the master key to modify schemas","suites":["schemas"],"line":902,"updatePoint":{"line":902,"column":47,"index":22679},"code":"  it('requires the master key to modify schemas', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/NewClass',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {}\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'PUT',\n        headers: noAuthHeaders,\n        json: true,\n        body: {}\n      }).then(fail, response => {\n        expect(response.status).toEqual(403);\n        expect(response.data.error).toEqual('unauthorized');\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"rejects class name mis-matches in put","suites":["schemas"],"line":923,"updatePoint":{"line":923,"column":43,"index":23258},"code":"  it('rejects class name mis-matches in put', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/NewClass',\n      method: 'PUT',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'WrongClassName'\n      }\n    }).then(fail, response => {\n      expect(response.status).toEqual(400);\n      expect(response.data.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n      expect(response.data.error).toEqual('Class name mismatch between WrongClassName and NewClass.');\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add fields to non-existent classes","suites":["schemas"],"line":939,"updatePoint":{"line":939,"column":51,"index":23802},"code":"  it('refuses to add fields to non-existent classes', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/NoClass',\n      method: 'PUT',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        fields: {\n          newField: {\n            type: 'String'\n          }\n        }\n      }\n    }).then(fail, response => {\n      expect(response.status).toEqual(400);\n      expect(response.data.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n      expect(response.data.error).toEqual('Class NoClass does not exist.');\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to put to existing fields with different type, even if it would not be a change","suites":["schemas"],"line":959,"updatePoint":{"line":959,"column":93,"index":24413},"code":"  it('refuses to put to existing fields with different type, even if it would not be a change', done => {\n    const obj = hasAllPODobject();\n    obj.save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/HasAllPOD',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            aString: {\n              type: 'Number'\n            }\n          }\n        }\n      }).then(fail, response => {\n        expect(response.status).toEqual(400);\n        expect(response.data.code).toEqual(255);\n        expect(response.data.error).toEqual('Field aString exists, cannot update.');\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to delete non-existent fields","suites":["schemas"],"line":982,"updatePoint":{"line":982,"column":43,"index":25062},"code":"  it('refuses to delete non-existent fields', done => {\n    const obj = hasAllPODobject();\n    obj.save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/HasAllPOD',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            nonExistentKey: {\n              __op: 'Delete'\n            }\n          }\n        }\n      }).then(fail, response => {\n        expect(response.status).toEqual(400);\n        expect(response.data.code).toEqual(255);\n        expect(response.data.error).toEqual('Field nonExistentKey does not exist, cannot delete.');\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add a geopoint to a class that already has one","suites":["schemas"],"line":1005,"updatePoint":{"line":1005,"column":63,"index":25753},"code":"  it('refuses to add a geopoint to a class that already has one', done => {\n    const obj = hasAllPODobject();\n    obj.save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/HasAllPOD',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            newGeo: {\n              type: 'GeoPoint'\n            }\n          }\n        }\n      }).then(fail, response => {\n        expect(response.status).toEqual(400);\n        expect(response.data.code).toEqual(Parse.Error.INCORRECT_TYPE);\n        expect(response.data.error).toEqual('currently, only one GeoPoint field may exist in an object. Adding newGeo when aGeoPoint already exists.');\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to add two geopoints","suites":["schemas"],"line":1028,"updatePoint":{"line":1028,"column":34,"index":26484},"code":"  it('refuses to add two geopoints', done => {\n    const obj = new Parse.Object('NewClass');\n    obj.set('aString', 'aString');\n    obj.save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            newGeo1: {\n              type: 'GeoPoint'\n            },\n            newGeo2: {\n              type: 'GeoPoint'\n            }\n          }\n        }\n      }).then(fail, response => {\n        expect(response.status).toEqual(400);\n        expect(response.data.code).toEqual(Parse.Error.INCORRECT_TYPE);\n        expect(response.data.error).toEqual('currently, only one GeoPoint field may exist in an object. Adding newGeo2 when newGeo1 already exists.');\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"allows you to delete and add a geopoint in the same request","suites":["schemas"],"line":1055,"updatePoint":{"line":1055,"column":65,"index":27360},"code":"  it('allows you to delete and add a geopoint in the same request', done => {\n    const obj = new Parse.Object('NewClass');\n    obj.set('geo1', new Parse.GeoPoint({\n      latitude: 0,\n      longitude: 0\n    }));\n    obj.save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            geo2: {\n              type: 'GeoPoint'\n            },\n            geo1: {\n              __op: 'Delete'\n            }\n          }\n        }\n      }).then(response => {\n        expect(dd(response.data, {\n          className: 'NewClass',\n          fields: {\n            ACL: {\n              type: 'ACL'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            objectId: {\n              type: 'String'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            geo2: {\n              type: 'GeoPoint'\n            }\n          },\n          classLevelPermissions: defaultClassLevelPermissions\n        })).toEqual(undefined);\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"put with no modifications returns all fields","suites":["schemas"],"line":1103,"updatePoint":{"line":1103,"column":50,"index":28513},"code":"  it('put with no modifications returns all fields', done => {\n    const obj = hasAllPODobject();\n    obj.save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/HasAllPOD',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {}\n      }).then(response => {\n        expect(response.data).toEqual(plainOldDataSchema);\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"lets you add fields","suites":["schemas"],"line":1118,"updatePoint":{"line":1118,"column":25,"index":28910},"code":"  it('lets you add fields', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/NewClass',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {}\n    }).then(() => {\n      request({\n        method: 'PUT',\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            newField: {\n              type: 'String'\n            }\n          }\n        }\n      }).then(response => {\n        expect(dd(response.data, {\n          className: 'NewClass',\n          fields: {\n            ACL: {\n              type: 'ACL'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            objectId: {\n              type: 'String'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            newField: {\n              type: 'String'\n            }\n          },\n          classLevelPermissions: defaultClassLevelPermissions\n        })).toEqual(undefined);\n        request({\n          url: 'http://localhost:8378/1/schemas/NewClass',\n          headers: masterKeyHeaders,\n          json: true\n        }).then(response => {\n          expect(response.data).toEqual({\n            className: 'NewClass',\n            fields: {\n              ACL: {\n                type: 'ACL'\n              },\n              createdAt: {\n                type: 'Date'\n              },\n              updatedAt: {\n                type: 'Date'\n              },\n              objectId: {\n                type: 'String'\n              },\n              newField: {\n                type: 'String'\n              }\n            },\n            classLevelPermissions: defaultClassLevelPermissions\n          });\n          done();\n        });\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"lets you add fields with options","suites":["schemas"],"line":1191,"updatePoint":{"line":1191,"column":38,"index":30736},"code":"  it('lets you add fields with options', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/NewClass',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {}\n    }).then(() => {\n      request({\n        method: 'PUT',\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            newField: {\n              type: 'String',\n              required: true,\n              defaultValue: 'some value'\n            }\n          }\n        }\n      }).then(response => {\n        expect(dd(response.data, {\n          className: 'NewClass',\n          fields: {\n            ACL: {\n              type: 'ACL'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            objectId: {\n              type: 'String'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            newField: {\n              type: 'String',\n              required: true,\n              defaultValue: 'some value'\n            }\n          },\n          classLevelPermissions: defaultClassLevelPermissions\n        })).toEqual(undefined);\n        request({\n          url: 'http://localhost:8378/1/schemas/NewClass',\n          headers: masterKeyHeaders,\n          json: true\n        }).then(response => {\n          expect(response.data).toEqual({\n            className: 'NewClass',\n            fields: {\n              ACL: {\n                type: 'ACL'\n              },\n              createdAt: {\n                type: 'Date'\n              },\n              updatedAt: {\n                type: 'Date'\n              },\n              objectId: {\n                type: 'String'\n              },\n              newField: {\n                type: 'String',\n                required: true,\n                defaultValue: 'some value'\n              }\n            },\n            classLevelPermissions: defaultClassLevelPermissions\n          });\n          done();\n        });\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should validate required fields","suites":["schemas"],"line":1270,"updatePoint":{"line":1270,"column":37,"index":32781},"code":"  it('should validate required fields', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/NewClass',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {}\n    }).then(() => {\n      request({\n        method: 'PUT',\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            newRequiredField: {\n              type: 'String',\n              required: true\n            },\n            newRequiredFieldWithDefaultValue: {\n              type: 'String',\n              required: true,\n              defaultValue: 'some value'\n            },\n            newNotRequiredField: {\n              type: 'String',\n              required: false\n            },\n            newNotRequiredFieldWithDefaultValue: {\n              type: 'String',\n              required: false,\n              defaultValue: 'some value'\n            },\n            newRegularFieldWithDefaultValue: {\n              type: 'String',\n              defaultValue: 'some value'\n            },\n            newRegularField: {\n              type: 'String'\n            }\n          }\n        }\n      }).then(async () => {\n        let obj = new Parse.Object('NewClass');\n        try {\n          await obj.save();\n          fail('Should fail');\n        } catch (e) {\n          expect(e.code).toEqual(142);\n          expect(e.message).toEqual('newRequiredField is required');\n        }\n        obj.set('newRequiredField', 'some value');\n        await obj.save();\n        expect(obj.get('newRequiredField')).toEqual('some value');\n        expect(obj.get('newRequiredFieldWithDefaultValue')).toEqual('some value');\n        expect(obj.get('newNotRequiredField')).toEqual(undefined);\n        expect(obj.get('newNotRequiredFieldWithDefaultValue')).toEqual('some value');\n        expect(obj.get('newRegularField')).toEqual(undefined);\n        obj.set('newRequiredField', null);\n        try {\n          await obj.save();\n          fail('Should fail');\n        } catch (e) {\n          expect(e.code).toEqual(142);\n          expect(e.message).toEqual('newRequiredField is required');\n        }\n        obj.unset('newRequiredField');\n        try {\n          await obj.save();\n          fail('Should fail');\n        } catch (e) {\n          expect(e.code).toEqual(142);\n          expect(e.message).toEqual('newRequiredField is required');\n        }\n        obj.set('newRequiredField', 'some value2');\n        await obj.save();\n        expect(obj.get('newRequiredField')).toEqual('some value2');\n        expect(obj.get('newRequiredFieldWithDefaultValue')).toEqual('some value');\n        expect(obj.get('newNotRequiredField')).toEqual(undefined);\n        expect(obj.get('newNotRequiredFieldWithDefaultValue')).toEqual('some value');\n        expect(obj.get('newRegularField')).toEqual(undefined);\n        obj.unset('newRequiredFieldWithDefaultValue');\n        try {\n          await obj.save();\n          fail('Should fail');\n        } catch (e) {\n          expect(e.code).toEqual(142);\n          expect(e.message).toEqual('newRequiredFieldWithDefaultValue is required');\n        }\n        obj.set('newRequiredFieldWithDefaultValue', '');\n        try {\n          await obj.save();\n          fail('Should fail');\n        } catch (e) {\n          expect(e.code).toEqual(142);\n          expect(e.message).toEqual('newRequiredFieldWithDefaultValue is required');\n        }\n        obj.set('newRequiredFieldWithDefaultValue', 'some value2');\n        obj.set('newNotRequiredField', '');\n        obj.set('newNotRequiredFieldWithDefaultValue', null);\n        obj.unset('newRegularField');\n        await obj.save();\n        expect(obj.get('newRequiredField')).toEqual('some value2');\n        expect(obj.get('newRequiredFieldWithDefaultValue')).toEqual('some value2');\n        expect(obj.get('newNotRequiredField')).toEqual('');\n        expect(obj.get('newNotRequiredFieldWithDefaultValue')).toEqual(null);\n        expect(obj.get('newRegularField')).toEqual(undefined);\n        obj = new Parse.Object('NewClass');\n        obj.set('newRequiredField', 'some value3');\n        obj.set('newRequiredFieldWithDefaultValue', 'some value3');\n        obj.set('newNotRequiredField', 'some value3');\n        obj.set('newNotRequiredFieldWithDefaultValue', 'some value3');\n        obj.set('newRegularField', 'some value3');\n        await obj.save();\n        expect(obj.get('newRequiredField')).toEqual('some value3');\n        expect(obj.get('newRequiredFieldWithDefaultValue')).toEqual('some value3');\n        expect(obj.get('newNotRequiredField')).toEqual('some value3');\n        expect(obj.get('newNotRequiredFieldWithDefaultValue')).toEqual('some value3');\n        expect(obj.get('newRegularField')).toEqual('some value3');\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should validate required fields and set default values after before save trigger","suites":["schemas"],"line":1393,"updatePoint":{"line":1393,"column":86,"index":37651},"code":"  it('should validate required fields and set default values after before save trigger', async () => {\n    await request({\n      url: 'http://localhost:8378/1/schemas',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'NewClassForBeforeSaveTest',\n        fields: {\n          foo1: {\n            type: 'String'\n          },\n          foo2: {\n            type: 'String',\n            required: true\n          },\n          foo3: {\n            type: 'String',\n            required: true,\n            defaultValue: 'some default value 3'\n          },\n          foo4: {\n            type: 'String',\n            defaultValue: 'some default value 4'\n          }\n        }\n      }\n    });\n    Parse.Cloud.beforeSave('NewClassForBeforeSaveTest', req => {\n      req.object.set('foo1', 'some value 1');\n      req.object.set('foo2', 'some value 2');\n      req.object.set('foo3', 'some value 3');\n      req.object.set('foo4', 'some value 4');\n    });\n    let obj = new Parse.Object('NewClassForBeforeSaveTest');\n    await obj.save();\n    expect(obj.get('foo1')).toEqual('some value 1');\n    expect(obj.get('foo2')).toEqual('some value 2');\n    expect(obj.get('foo3')).toEqual('some value 3');\n    expect(obj.get('foo4')).toEqual('some value 4');\n    Parse.Cloud.beforeSave('NewClassForBeforeSaveTest', req => {\n      req.object.set('foo1', 'some value 1');\n      req.object.set('foo2', 'some value 2');\n    });\n    obj = new Parse.Object('NewClassForBeforeSaveTest');\n    await obj.save();\n    expect(obj.get('foo1')).toEqual('some value 1');\n    expect(obj.get('foo2')).toEqual('some value 2');\n    expect(obj.get('foo3')).toEqual('some default value 3');\n    expect(obj.get('foo4')).toEqual('some default value 4');\n    Parse.Cloud.beforeSave('NewClassForBeforeSaveTest', req => {\n      req.object.set('foo1', 'some value 1');\n      req.object.set('foo2', 'some value 2');\n      req.object.set('foo3', undefined);\n      req.object.unset('foo4');\n    });\n    obj = new Parse.Object('NewClassForBeforeSaveTest');\n    obj.set('foo3', 'some value 3');\n    obj.set('foo4', 'some value 4');\n    await obj.save();\n    expect(obj.get('foo1')).toEqual('some value 1');\n    expect(obj.get('foo2')).toEqual('some value 2');\n    expect(obj.get('foo3')).toEqual('some default value 3');\n    expect(obj.get('foo4')).toEqual('some default value 4');\n    Parse.Cloud.beforeSave('NewClassForBeforeSaveTest', req => {\n      req.object.set('foo1', 'some value 1');\n      req.object.set('foo2', undefined);\n      req.object.set('foo3', undefined);\n      req.object.unset('foo4');\n    });\n    obj = new Parse.Object('NewClassForBeforeSaveTest');\n    obj.set('foo2', 'some value 2');\n    obj.set('foo3', 'some value 3');\n    obj.set('foo4', 'some value 4');\n    try {\n      await obj.save();\n      fail('should fail');\n    } catch (e) {\n      expect(e.message).toEqual('foo2 is required');\n    }\n    Parse.Cloud.beforeSave('NewClassForBeforeSaveTest', req => {\n      req.object.set('foo1', 'some value 1');\n      req.object.unset('foo2');\n      req.object.set('foo3', undefined);\n      req.object.unset('foo4');\n    });\n    obj = new Parse.Object('NewClassForBeforeSaveTest');\n    obj.set('foo2', 'some value 2');\n    obj.set('foo3', 'some value 3');\n    obj.set('foo4', 'some value 4');\n    try {\n      await obj.save();\n      fail('should fail');\n    } catch (e) {\n      expect(e.message).toEqual('foo2 is required');\n    }\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"lets you add fields to system schema","suites":["schemas"],"line":1490,"updatePoint":{"line":1490,"column":42,"index":41060},"code":"  it('lets you add fields to system schema', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/_User',\n      headers: masterKeyHeaders,\n      json: true\n    }).then(fail, () => {\n      request({\n        url: 'http://localhost:8378/1/schemas/_User',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            newField: {\n              type: 'String'\n            }\n          }\n        }\n      }).then(response => {\n        delete response.data.indexes;\n        expect(dd(response.data, {\n          className: '_User',\n          fields: {\n            objectId: {\n              type: 'String'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            username: {\n              type: 'String'\n            },\n            password: {\n              type: 'String'\n            },\n            email: {\n              type: 'String'\n            },\n            emailVerified: {\n              type: 'Boolean'\n            },\n            authData: {\n              type: 'Object'\n            },\n            newField: {\n              type: 'String'\n            },\n            ACL: {\n              type: 'ACL'\n            }\n          },\n          classLevelPermissions: {\n            ...defaultClassLevelPermissions,\n            protectedFields: {\n              '*': ['email']\n            }\n          }\n        })).toBeUndefined();\n        request({\n          url: 'http://localhost:8378/1/schemas/_User',\n          headers: masterKeyHeaders,\n          json: true\n        }).then(response => {\n          delete response.data.indexes;\n          expect(dd(response.data, {\n            className: '_User',\n            fields: {\n              objectId: {\n                type: 'String'\n              },\n              updatedAt: {\n                type: 'Date'\n              },\n              createdAt: {\n                type: 'Date'\n              },\n              username: {\n                type: 'String'\n              },\n              password: {\n                type: 'String'\n              },\n              email: {\n                type: 'String'\n              },\n              emailVerified: {\n                type: 'Boolean'\n              },\n              authData: {\n                type: 'Object'\n              },\n              newField: {\n                type: 'String'\n              },\n              ACL: {\n                type: 'ACL'\n              }\n            },\n            classLevelPermissions: defaultClassLevelPermissions\n          })).toBeUndefined();\n          done();\n        });\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"lets you delete multiple fields and check schema","suites":["schemas"],"line":1599,"updatePoint":{"line":1599,"column":54,"index":43784},"code":"  it('lets you delete multiple fields and check schema', done => {\n    const simpleOneObject = () => {\n      const obj = new Parse.Object('SimpleOne');\n      obj.set('aNumber', 5);\n      obj.set('aString', 'string');\n      obj.set('aBool', true);\n      return obj;\n    };\n    simpleOneObject().save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/SimpleOne',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            aString: {\n              __op: 'Delete'\n            },\n            aNumber: {\n              __op: 'Delete'\n            }\n          }\n        }\n      }).then(response => {\n        expect(response.data).toEqual({\n          className: 'SimpleOne',\n          fields: {\n            //Default fields\n            ACL: {\n              type: 'ACL'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            objectId: {\n              type: 'String'\n            },\n            //Custom fields\n            aBool: {\n              type: 'Boolean'\n            }\n          },\n          classLevelPermissions: defaultClassLevelPermissions\n        });\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"lets you delete multiple fields and add fields","suites":["schemas"],"line":1651,"updatePoint":{"line":1651,"column":52,"index":45072},"code":"  it('lets you delete multiple fields and add fields', done => {\n    const obj1 = hasAllPODobject();\n    obj1.save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/HasAllPOD',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            aString: {\n              __op: 'Delete'\n            },\n            aNumber: {\n              __op: 'Delete'\n            },\n            aNewString: {\n              type: 'String'\n            },\n            aNewNumber: {\n              type: 'Number'\n            },\n            aNewRelation: {\n              type: 'Relation',\n              targetClass: 'HasAllPOD'\n            },\n            aNewPointer: {\n              type: 'Pointer',\n              targetClass: 'HasAllPOD'\n            }\n          }\n        }\n      }).then(response => {\n        expect(response.data).toEqual({\n          className: 'HasAllPOD',\n          fields: {\n            //Default fields\n            ACL: {\n              type: 'ACL'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            objectId: {\n              type: 'String'\n            },\n            //Custom fields\n            aBool: {\n              type: 'Boolean'\n            },\n            aDate: {\n              type: 'Date'\n            },\n            aObject: {\n              type: 'Object'\n            },\n            aArray: {\n              type: 'Array'\n            },\n            aGeoPoint: {\n              type: 'GeoPoint'\n            },\n            aFile: {\n              type: 'File'\n            },\n            aNewNumber: {\n              type: 'Number'\n            },\n            aNewString: {\n              type: 'String'\n            },\n            aNewPointer: {\n              type: 'Pointer',\n              targetClass: 'HasAllPOD'\n            },\n            aNewRelation: {\n              type: 'Relation',\n              targetClass: 'HasAllPOD'\n            }\n          },\n          classLevelPermissions: defaultClassLevelPermissions\n        });\n        const obj2 = new Parse.Object('HasAllPOD');\n        obj2.set('aNewPointer', obj1);\n        const relation = obj2.relation('aNewRelation');\n        relation.add(obj1);\n        obj2.save().then(done); //Just need to make sure saving works on the new object.\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"will not delete any fields if the additions are invalid","suites":["schemas"],"line":1745,"updatePoint":{"line":1745,"column":61,"index":47497},"code":"  it('will not delete any fields if the additions are invalid', done => {\n    const obj = hasAllPODobject();\n    obj.save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/HasAllPOD',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            fakeNewField: {\n              type: 'fake type'\n            },\n            aString: {\n              __op: 'Delete'\n            }\n          }\n        }\n      }).then(fail, response => {\n        expect(response.data.code).toEqual(Parse.Error.INCORRECT_TYPE);\n        expect(response.data.error).toEqual('invalid field type: fake type');\n        request({\n          method: 'PUT',\n          url: 'http://localhost:8378/1/schemas/HasAllPOD',\n          headers: masterKeyHeaders,\n          json: true\n        }).then(response => {\n          expect(response.data).toEqual(plainOldDataSchema);\n          done();\n        });\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"requires the master key to delete schemas","suites":["schemas"],"line":1778,"updatePoint":{"line":1778,"column":47,"index":48461},"code":"  it('requires the master key to delete schemas', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/DoesntMatter',\n      method: 'DELETE',\n      headers: noAuthHeaders,\n      json: true\n    }).then(fail, response => {\n      expect(response.status).toEqual(403);\n      expect(response.data.error).toEqual('unauthorized');\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"refuses to delete non-empty collection","suites":["schemas"],"line":1790,"updatePoint":{"line":1790,"column":44,"index":48825},"code":"  it('refuses to delete non-empty collection', done => {\n    const obj = hasAllPODobject();\n    obj.save().then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/HasAllPOD',\n        method: 'DELETE',\n        headers: masterKeyHeaders,\n        json: true\n      }).then(fail, response => {\n        expect(response.status).toEqual(400);\n        expect(response.data.code).toEqual(255);\n        expect(response.data.error).toMatch(/HasAllPOD/);\n        expect(response.data.error).toMatch(/contains 1/);\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"fails when deleting collections with invalid class names","suites":["schemas"],"line":1807,"updatePoint":{"line":1807,"column":62,"index":49403},"code":"  it('fails when deleting collections with invalid class names', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/_GlobalConfig',\n      method: 'DELETE',\n      headers: masterKeyHeaders,\n      json: true\n    }).then(fail, response => {\n      expect(response.status).toEqual(400);\n      expect(response.data.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n      expect(response.data.error).toEqual('Invalid classname: _GlobalConfig, classnames can only have alphanumeric characters and _, and must start with an alpha character ');\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"does not fail when deleting nonexistant collections","suites":["schemas"],"line":1820,"updatePoint":{"line":1820,"column":57,"index":49975},"code":"  it('does not fail when deleting nonexistant collections', done => {\n    request({\n      url: 'http://localhost:8378/1/schemas/Missing',\n      method: 'DELETE',\n      headers: masterKeyHeaders,\n      json: true\n    }).then(response => {\n      expect(response.status).toEqual(200);\n      expect(response.data).toEqual({});\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"ensure refresh cache after deleting a class","suites":["schemas"],"line":1832,"updatePoint":{"line":1832,"column":49,"index":50318},"code":"  it('ensure refresh cache after deleting a class', async done => {\n    config = Config.get('test');\n    spyOn(config.schemaCache, 'del').and.callFake(() => {});\n    spyOn(SchemaController.prototype, 'reloadData').and.callFake(() => Promise.resolve());\n    await request({\n      url: 'http://localhost:8378/1/schemas',\n      method: 'POST',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'A'\n      }\n    });\n    await request({\n      method: 'DELETE',\n      url: 'http://localhost:8378/1/schemas/A',\n      headers: masterKeyHeaders,\n      json: true\n    });\n    const response = await request({\n      url: 'http://localhost:8378/1/schemas',\n      method: 'GET',\n      headers: masterKeyHeaders,\n      json: true\n    });\n    const expected = {\n      results: [userSchema, roleSchema]\n    };\n    expect(response.data.results.sort((s1, s2) => s1.className.localeCompare(s2.className)).map(s => {\n      const withoutIndexes = Object.assign({}, s);\n      delete withoutIndexes.indexes;\n      return withoutIndexes;\n    })).toEqual(expected.results.sort((s1, s2) => s1.className.localeCompare(s2.className)));\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"deletes collections including join tables","suites":["schemas"],"line":1867,"updatePoint":{"line":1867,"column":47,"index":51475},"code":"  it('deletes collections including join tables', done => {\n    const obj = new Parse.Object('MyClass');\n    obj.set('data', 'data');\n    obj.save().then(() => {\n      const obj2 = new Parse.Object('MyOtherClass');\n      const relation = obj2.relation('aRelation');\n      relation.add(obj);\n      return obj2.save();\n    }).then(obj2 => obj2.destroy()).then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/MyOtherClass',\n        method: 'DELETE',\n        headers: masterKeyHeaders,\n        json: true\n      }).then(response => {\n        expect(response.status).toEqual(200);\n        expect(response.data).toEqual({});\n        config.database.collectionExists('_Join:aRelation:MyOtherClass').then(exists => {\n          if (exists) {\n            fail('Relation collection should be deleted.');\n            done();\n          }\n          return config.database.collectionExists('MyOtherClass');\n        }).then(exists => {\n          if (exists) {\n            fail('Class collection should be deleted.');\n            done();\n          }\n        }).then(() => {\n          request({\n            url: 'http://localhost:8378/1/schemas/MyOtherClass',\n            headers: masterKeyHeaders,\n            json: true\n          }).then(fail, response => {\n            //Expect _SCHEMA entry to be gone.\n            expect(response.status).toEqual(400);\n            expect(response.data.code).toEqual(Parse.Error.INVALID_CLASS_NAME);\n            expect(response.data.error).toEqual('Class MyOtherClass does not exist.');\n            done();\n          });\n        });\n      });\n    }).then(() => {}, error => {\n      fail(error);\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"deletes schema when actual collection does not exist","suites":["schemas"],"line":1914,"updatePoint":{"line":1914,"column":58,"index":53149},"code":"  it('deletes schema when actual collection does not exist', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/NewClassForDelete',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'NewClassForDelete'\n      }\n    }).then(response => {\n      expect(response.data.className).toEqual('NewClassForDelete');\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClassForDelete',\n        method: 'DELETE',\n        headers: masterKeyHeaders,\n        json: true\n      }).then(response => {\n        expect(response.status).toEqual(200);\n        expect(response.data).toEqual({});\n        config.database.loadSchema().then(schema => {\n          schema.hasClass('NewClassForDelete').then(exist => {\n            expect(exist).toEqual(false);\n            done();\n          });\n        });\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"deletes schema when actual collection exists","suites":["schemas"],"line":1942,"updatePoint":{"line":1942,"column":50,"index":54026},"code":"  it('deletes schema when actual collection exists', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/NewClassForDelete',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        className: 'NewClassForDelete'\n      }\n    }).then(response => {\n      expect(response.data.className).toEqual('NewClassForDelete');\n      request({\n        url: 'http://localhost:8378/1/classes/NewClassForDelete',\n        method: 'POST',\n        headers: restKeyHeaders,\n        json: true\n      }).then(response => {\n        expect(typeof response.data.objectId).toEqual('string');\n        request({\n          method: 'DELETE',\n          url: 'http://localhost:8378/1/classes/NewClassForDelete/' + response.data.objectId,\n          headers: restKeyHeaders,\n          json: true\n        }).then(() => {\n          request({\n            method: 'DELETE',\n            url: 'http://localhost:8378/1/schemas/NewClassForDelete',\n            headers: masterKeyHeaders,\n            json: true\n          }).then(response => {\n            expect(response.status).toEqual(200);\n            expect(response.data).toEqual({});\n            config.database.loadSchema().then(schema => {\n              schema.hasClass('NewClassForDelete').then(exist => {\n                expect(exist).toEqual(false);\n                done();\n              });\n            });\n          });\n        });\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should set/get schema permissions","suites":["schemas"],"line":1985,"updatePoint":{"line":1985,"column":39,"index":55445},"code":"  it('should set/get schema permissions', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/AClass',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        classLevelPermissions: {\n          find: {\n            '*': true\n          },\n          create: {\n            'role:admin': true\n          }\n        }\n      }\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/schemas/AClass',\n        headers: masterKeyHeaders,\n        json: true\n      }).then(response => {\n        expect(response.status).toEqual(200);\n        expect(response.data.classLevelPermissions).toEqual({\n          find: {\n            '*': true\n          },\n          create: {\n            'role:admin': true\n          },\n          get: {},\n          count: {},\n          update: {},\n          delete: {},\n          addField: {},\n          protectedFields: {}\n        });\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should fail setting schema permissions with invalid key","suites":["schemas"],"line":2026,"updatePoint":{"line":2026,"column":61,"index":56428},"code":"  it('should fail setting schema permissions with invalid key', done => {\n    const object = new Parse.Object('AClass');\n    object.save().then(() => {\n      request({\n        method: 'PUT',\n        url: 'http://localhost:8378/1/schemas/AClass',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          classLevelPermissions: {\n            find: {\n              '*': true\n            },\n            create: {\n              'role:admin': true\n            },\n            dummy: {\n              some: true\n            }\n          }\n        }\n      }).then(fail, response => {\n        expect(response.data.code).toEqual(107);\n        expect(response.data.error).toEqual('dummy is not a valid operation for class level permissions');\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to add a field","suites":["schemas"],"line":2054,"updatePoint":{"line":2054,"column":39,"index":57199},"code":"  it('should not be able to add a field', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/AClass',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        classLevelPermissions: {\n          create: {\n            '*': true\n          },\n          find: {\n            '*': true\n          },\n          addField: {\n            'role:admin': true\n          }\n        }\n      }\n    }).then(() => {\n      const object = new Parse.Object('AClass');\n      object.set('hello', 'world');\n      return object.save().then(() => {\n        fail('should not be able to add a field');\n        done();\n      }, err => {\n        expect(err.message).toEqual('Permission denied for action addField on class AClass.');\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to add a field","suites":["schemas"],"line":2085,"updatePoint":{"line":2085,"column":35,"index":57990},"code":"  it('should be able to add a field', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/AClass',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        classLevelPermissions: {\n          create: {\n            '*': true\n          },\n          addField: {\n            '*': true\n          }\n        }\n      }\n    }).then(() => {\n      const object = new Parse.Object('AClass');\n      object.set('hello', 'world');\n      return object.save().then(() => {\n        done();\n      }, () => {\n        fail('should be able to add a field');\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"addField permission not required for adding a nested property","suites":["schemas","Nested documents"],"line":2127,"updatePoint":{"line":2127,"column":69,"index":59007},"code":"    it('addField permission not required for adding a nested property', async () => {\n      const obj = new Parse.Object('test_7371');\n      obj.set('a', {});\n      await obj.save();\n      obj.set('a.b', 2);\n      await obj.save();\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"addField permission not required for modifying a nested property","suites":["schemas","Nested documents"],"line":2134,"updatePoint":{"line":2134,"column":72,"index":59250},"code":"    it('addField permission not required for modifying a nested property', async () => {\n      const obj = new Parse.Object('test_7371');\n      obj.set('a', {\n        b: 1\n      });\n      await obj.save();\n      obj.set('a.b', 2);\n      await obj.save();\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should aceept class-level permission with userid of any length","suites":["schemas","Nested documents"],"line":2144,"updatePoint":{"line":2144,"column":68,"index":59515},"code":"  it('should aceept class-level permission with userid of any length', async done => {\n    await global.reconfigureServer({\n      customIdSize: 11\n    });\n    const id = 'e1evenChars';\n    const {\n      data\n    } = await request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/AClass',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        classLevelPermissions: {\n          find: {\n            [id]: true\n          }\n        }\n      }\n    });\n    expect(data.classLevelPermissions.find[id]).toBe(true);\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should allow set class-level permission for custom userid of any length and chars","suites":["schemas","Nested documents"],"line":2167,"updatePoint":{"line":2167,"column":87,"index":60096},"code":"  it('should allow set class-level permission for custom userid of any length and chars', async done => {\n    await global.reconfigureServer({\n      allowCustomObjectId: true\n    });\n    const symbolsId = 'set:ID+symbol$=@llowed';\n    const shortId = '1';\n    const {\n      data\n    } = await request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/AClass',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        classLevelPermissions: {\n          find: {\n            [symbolsId]: true,\n            [shortId]: true\n          }\n        }\n      }\n    });\n    expect(data.classLevelPermissions.find[symbolsId]).toBe(true);\n    expect(data.classLevelPermissions.find[shortId]).toBe(true);\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should allow set ACL for custom userid","suites":["schemas","Nested documents"],"line":2193,"updatePoint":{"line":2193,"column":44,"index":60794},"code":"  it('should allow set ACL for custom userid', async done => {\n    await global.reconfigureServer({\n      allowCustomObjectId: true\n    });\n    const symbolsId = 'symbols:id@allowed=';\n    const shortId = '1';\n    const normalId = 'tensymbols';\n    const {\n      data\n    } = await request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/AClass',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        ACL: {\n          [symbolsId]: {\n            read: true,\n            write: true\n          },\n          [shortId]: {\n            read: true,\n            write: true\n          },\n          [normalId]: {\n            read: true,\n            write: true\n          }\n        }\n      }\n    });\n    const {\n      data: created\n    } = await request({\n      method: 'GET',\n      url: `http://localhost:8378/1/classes/AClass/${data.objectId}`,\n      headers: masterKeyHeaders,\n      json: true\n    });\n    expect(created.ACL[normalId].write).toBe(true);\n    expect(created.ACL[symbolsId].write).toBe(true);\n    expect(created.ACL[shortId].write).toBe(true);\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should throw with invalid userId (invalid char)","suites":["schemas","Nested documents"],"line":2237,"updatePoint":{"line":2237,"column":53,"index":61909},"code":"  it('should throw with invalid userId (invalid char)', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/AClass',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        classLevelPermissions: {\n          find: {\n            '12345_6789': true\n          }\n        }\n      }\n    }).then(fail, response => {\n      expect(response.data.error).toEqual(\"'12345_6789' is not a valid key for class level permissions\");\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should throw with invalid * (spaces before)","suites":["schemas","Nested documents"],"line":2255,"updatePoint":{"line":2255,"column":49,"index":62403},"code":"  it('should throw with invalid * (spaces before)', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/AClass',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        classLevelPermissions: {\n          find: {\n            ' *': true\n          }\n        }\n      }\n    }).then(fail, response => {\n      expect(response.data.error).toEqual(\"' *' is not a valid key for class level permissions\");\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should throw with invalid * (spaces after)","suites":["schemas","Nested documents"],"line":2273,"updatePoint":{"line":2273,"column":48,"index":62880},"code":"  it('should throw with invalid * (spaces after)', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/AClass',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        classLevelPermissions: {\n          find: {\n            '* ': true\n          }\n        }\n      }\n    }).then(fail, response => {\n      expect(response.data.error).toEqual(\"'* ' is not a valid key for class level permissions\");\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if permission is number","suites":["schemas","Nested documents"],"line":2291,"updatePoint":{"line":2291,"column":42,"index":63351},"code":"  it('should throw if permission is number', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/AClass',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        classLevelPermissions: {\n          find: {\n            '*': 1\n          }\n        }\n      }\n    }).then(fail, response => {\n      expect(response.data.error).toEqual(\"'1' is not a valid value for class level permissions find:*:1\");\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should throw if permission is empty string","suites":["schemas","Nested documents"],"line":2309,"updatePoint":{"line":2309,"column":48,"index":63834},"code":"  it('should throw if permission is empty string', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/schemas/AClass',\n      headers: masterKeyHeaders,\n      json: true,\n      body: {\n        classLevelPermissions: {\n          find: {\n            '*': ''\n          }\n        }\n      }\n    }).then(fail, response => {\n      expect(response.data.error).toEqual(\"'' is not a valid value for class level permissions find:*:\");\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"validate CLP 1","suites":["schemas","Nested documents"],"line":2343,"updatePoint":{"line":2343,"column":20,"index":64724},"code":"  it('validate CLP 1', done => {\n    const user = new Parse.User();\n    user.setUsername('user');\n    user.setPassword('user');\n    const admin = new Parse.User();\n    admin.setUsername('admin');\n    admin.setPassword('admin');\n    const role = new Parse.Role('admin', new Parse.ACL());\n    setPermissionsOnClass('AClass', {\n      find: {\n        'role:admin': true\n      }\n    }).then(() => {\n      return Parse.Object.saveAll([user, admin, role], {\n        useMasterKey: true\n      });\n    }).then(() => {\n      role.relation('users').add(admin);\n      return role.save(null, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      return Parse.User.logIn('user', 'user').then(() => {\n        const obj = new Parse.Object('AClass');\n        return obj.save(null, {\n          useMasterKey: true\n        });\n      });\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find().then(() => {\n        fail('Use should hot be able to find!');\n      }, err => {\n        expect(err.message).toEqual('Permission denied for action find on class AClass.');\n        return Promise.resolve();\n      });\n    }).then(() => {\n      return Parse.User.logIn('admin', 'admin');\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(1);\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"validate CLP 2","suites":["schemas","Nested documents"],"line":2392,"updatePoint":{"line":2392,"column":20,"index":66167},"code":"  it('validate CLP 2', done => {\n    const user = new Parse.User();\n    user.setUsername('user');\n    user.setPassword('user');\n    const admin = new Parse.User();\n    admin.setUsername('admin');\n    admin.setPassword('admin');\n    const role = new Parse.Role('admin', new Parse.ACL());\n    setPermissionsOnClass('AClass', {\n      find: {\n        'role:admin': true\n      }\n    }).then(() => {\n      return Parse.Object.saveAll([user, admin, role], {\n        useMasterKey: true\n      });\n    }).then(() => {\n      role.relation('users').add(admin);\n      return role.save(null, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      return Parse.User.logIn('user', 'user').then(() => {\n        const obj = new Parse.Object('AClass');\n        return obj.save(null, {\n          useMasterKey: true\n        });\n      });\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find().then(() => {\n        fail('User should not be able to find!');\n      }, err => {\n        expect(err.message).toEqual('Permission denied for action find on class AClass.');\n        return Promise.resolve();\n      });\n    }).then(() => {\n      // let everyone see it now\n      return setPermissionsOnClass('AClass', {\n        find: {\n          'role:admin': true,\n          '*': true\n        }\n      }, true);\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find().then(result => {\n        expect(result.length).toBe(1);\n      }, () => {\n        fail('User should be able to find!');\n        done();\n      });\n    }).then(() => {\n      return Parse.User.logIn('admin', 'admin');\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(1);\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"validate CLP 3","suites":["schemas","Nested documents"],"line":2457,"updatePoint":{"line":2457,"column":20,"index":68041},"code":"  it('validate CLP 3', done => {\n    const user = new Parse.User();\n    user.setUsername('user');\n    user.setPassword('user');\n    const admin = new Parse.User();\n    admin.setUsername('admin');\n    admin.setPassword('admin');\n    const role = new Parse.Role('admin', new Parse.ACL());\n    setPermissionsOnClass('AClass', {\n      find: {\n        'role:admin': true\n      }\n    }).then(() => {\n      return Parse.Object.saveAll([user, admin, role], {\n        useMasterKey: true\n      });\n    }).then(() => {\n      role.relation('users').add(admin);\n      return role.save(null, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      return Parse.User.logIn('user', 'user').then(() => {\n        const obj = new Parse.Object('AClass');\n        return obj.save(null, {\n          useMasterKey: true\n        });\n      });\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find().then(() => {\n        fail('User should not be able to find!');\n      }, err => {\n        expect(err.message).toEqual('Permission denied for action find on class AClass.');\n        return Promise.resolve();\n      });\n    }).then(() => {\n      // delete all CLP\n      return setPermissionsOnClass('AClass', null, true);\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find().then(result => {\n        expect(result.length).toBe(1);\n      }, () => {\n        fail('User should be able to find!');\n        done();\n      });\n    }).then(() => {\n      return Parse.User.logIn('admin', 'admin');\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(1);\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"validate CLP 4","suites":["schemas","Nested documents"],"line":2517,"updatePoint":{"line":2517,"column":20,"index":69825},"code":"  it('validate CLP 4', done => {\n    const user = new Parse.User();\n    user.setUsername('user');\n    user.setPassword('user');\n    const admin = new Parse.User();\n    admin.setUsername('admin');\n    admin.setPassword('admin');\n    const role = new Parse.Role('admin', new Parse.ACL());\n    setPermissionsOnClass('AClass', {\n      find: {\n        'role:admin': true\n      }\n    }).then(() => {\n      return Parse.Object.saveAll([user, admin, role], {\n        useMasterKey: true\n      });\n    }).then(() => {\n      role.relation('users').add(admin);\n      return role.save(null, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      return Parse.User.logIn('user', 'user').then(() => {\n        const obj = new Parse.Object('AClass');\n        return obj.save(null, {\n          useMasterKey: true\n        });\n      });\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find().then(() => {\n        fail('User should not be able to find!');\n      }, err => {\n        expect(err.message).toEqual('Permission denied for action find on class AClass.');\n        return Promise.resolve();\n      });\n    }).then(() => {\n      // borked CLP should not affec security\n      return setPermissionsOnClass('AClass', {\n        found: {\n          'role:admin': true\n        }\n      }, true).then(() => {\n        fail('Should not be able to save a borked CLP');\n      }, () => {\n        return Promise.resolve();\n      });\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find().then(() => {\n        fail('User should not be able to find!');\n      }, err => {\n        expect(err.message).toEqual('Permission denied for action find on class AClass.');\n        return Promise.resolve();\n      });\n    }).then(() => {\n      return Parse.User.logIn('admin', 'admin');\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(1);\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"validate CLP 5","suites":["schemas","Nested documents"],"line":2585,"updatePoint":{"line":2585,"column":20,"index":71893},"code":"  it('validate CLP 5', done => {\n    const user = new Parse.User();\n    user.setUsername('user');\n    user.setPassword('user');\n    const user2 = new Parse.User();\n    user2.setUsername('user2');\n    user2.setPassword('user2');\n    const admin = new Parse.User();\n    admin.setUsername('admin');\n    admin.setPassword('admin');\n    const role = new Parse.Role('admin', new Parse.ACL());\n    Promise.resolve().then(() => {\n      return Parse.Object.saveAll([user, user2, admin, role], {\n        useMasterKey: true\n      });\n    }).then(() => {\n      role.relation('users').add(admin);\n      return role.save(null, {\n        useMasterKey: true\n      }).then(() => {\n        const perm = {\n          find: {}\n        };\n        // let the user find\n        perm['find'][user.id] = true;\n        return setPermissionsOnClass('AClass', perm);\n      });\n    }).then(() => {\n      return Parse.User.logIn('user', 'user').then(() => {\n        const obj = new Parse.Object('AClass');\n        return obj.save();\n      });\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find().then(res => {\n        expect(res.length).toEqual(1);\n      }, () => {\n        fail('User should be able to find!');\n        return Promise.resolve();\n      });\n    }).then(() => {\n      return Parse.User.logIn('admin', 'admin');\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find();\n    }).then(() => {\n      fail('should not be able to read!');\n      return Promise.resolve();\n    }, err => {\n      expect(err.message).toEqual('Permission denied for action create on class AClass.');\n      return Promise.resolve();\n    }).then(() => {\n      return Parse.User.logIn('user2', 'user2');\n    }).then(() => {\n      const query = new Parse.Query('AClass');\n      return query.find();\n    }).then(() => {\n      fail('should not be able to read!');\n      return Promise.resolve();\n    }, err => {\n      expect(err.message).toEqual('Permission denied for action find on class AClass.');\n      return Promise.resolve();\n    }).then(() => {\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"can query with include and CLP (issue #2005)","suites":["schemas","Nested documents"],"line":2651,"updatePoint":{"line":2651,"column":50,"index":74028},"code":"  it('can query with include and CLP (issue #2005)', done => {\n    setPermissionsOnClass('AnotherObject', {\n      get: {\n        '*': true\n      },\n      find: {},\n      create: {\n        '*': true\n      },\n      update: {\n        '*': true\n      },\n      delete: {\n        '*': true\n      },\n      addField: {\n        '*': true\n      }\n    }).then(() => {\n      const obj = new Parse.Object('AnObject');\n      const anotherObject = new Parse.Object('AnotherObject');\n      return obj.save({\n        anotherObject\n      });\n    }).then(() => {\n      const query = new Parse.Query('AnObject');\n      query.include('anotherObject');\n      return query.find();\n    }).then(res => {\n      expect(res.length).toBe(1);\n      expect(res[0].get('anotherObject')).not.toBeUndefined();\n      done();\n    }).catch(err => {\n      jfail(err);\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"can add field as master (issue #1257)","suites":["schemas","Nested documents"],"line":2688,"updatePoint":{"line":2688,"column":43,"index":74879},"code":"  it('can add field as master (issue #1257)', done => {\n    setPermissionsOnClass('AClass', {\n      addField: {}\n    }).then(() => {\n      const obj = new Parse.Object('AClass');\n      obj.set('key', 'value');\n      return obj.save(null, {\n        useMasterKey: true\n      });\n    }).then(obj => {\n      expect(obj.get('key')).toEqual('value');\n      done();\n    }, () => {\n      fail('should not fail');\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"can login when addFields is false (issue #1355)","suites":["schemas","Nested documents"],"line":2705,"updatePoint":{"line":2705,"column":53,"index":75322},"code":"  it('can login when addFields is false (issue #1355)', done => {\n    setPermissionsOnClass('_User', {\n      create: {\n        '*': true\n      },\n      addField: {}\n    }, true).then(() => {\n      return Parse.User.signUp('foo', 'bar');\n    }).then(user => {\n      expect(user.getUsername()).toBe('foo');\n      done();\n    }, error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"unset field in beforeSave should not stop object creation","suites":["schemas","Nested documents"],"line":2721,"updatePoint":{"line":2721,"column":63,"index":75732},"code":"  it('unset field in beforeSave should not stop object creation', done => {\n    const hook = {\n      method: function (req) {\n        if (req.object.get('undesiredField')) {\n          req.object.unset('undesiredField');\n        }\n      }\n    };\n    spyOn(hook, 'method').and.callThrough();\n    Parse.Cloud.beforeSave('AnObject', hook.method);\n    setPermissionsOnClass('AnObject', {\n      get: {\n        '*': true\n      },\n      find: {\n        '*': true\n      },\n      create: {\n        '*': true\n      },\n      update: {\n        '*': true\n      },\n      delete: {\n        '*': true\n      },\n      addField: {}\n    }).then(() => {\n      const obj = new Parse.Object('AnObject');\n      obj.set('desiredField', 'createMe');\n      return obj.save(null, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      const obj = new Parse.Object('AnObject');\n      obj.set('desiredField', 'This value should be kept');\n      obj.set('undesiredField', 'This value should be IGNORED');\n      return obj.save();\n    }).then(() => {\n      const query = new Parse.Query('AnObject');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(2);\n      expect(results[0].has('desiredField')).toBe(true);\n      expect(results[1].has('desiredField')).toBe(true);\n      expect(results[0].has('undesiredField')).toBe(false);\n      expect(results[1].has('undesiredField')).toBe(false);\n      expect(hook.method).toHaveBeenCalled();\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"gives correct response when deleting a schema with CLPs (regression test #1919)","suites":["schemas","Nested documents"],"line":2772,"updatePoint":{"line":2772,"column":85,"index":77229},"code":"  it('gives correct response when deleting a schema with CLPs (regression test #1919)', done => {\n    new Parse.Object('MyClass').save({\n      data: 'foo'\n    }).then(obj => obj.destroy()).then(() => setPermissionsOnClass('MyClass', {\n      find: {},\n      get: {}\n    }, true)).then(() => {\n      request({\n        method: 'DELETE',\n        url: 'http://localhost:8378/1/schemas/MyClass',\n        headers: masterKeyHeaders,\n        json: true\n      }).then(response => {\n        expect(response.status).toEqual(200);\n        expect(response.data).toEqual({});\n        done();\n      });\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"regression test for #1991","suites":["schemas","Nested documents"],"line":2791,"updatePoint":{"line":2791,"column":31,"index":77776},"code":"  it('regression test for #1991', done => {\n    const user = new Parse.User();\n    user.setUsername('user');\n    user.setPassword('user');\n    const role = new Parse.Role('admin', new Parse.ACL());\n    const obj = new Parse.Object('AnObject');\n    Parse.Object.saveAll([user, role]).then(() => {\n      role.relation('users').add(user);\n      return role.save(null, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      return setPermissionsOnClass('AnObject', {\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        create: {\n          '*': true\n        },\n        update: {\n          'role:admin': true\n        },\n        delete: {\n          'role:admin': true\n        }\n      });\n    }).then(() => {\n      return obj.save();\n    }).then(() => {\n      return Parse.User.logIn('user', 'user');\n    }).then(() => {\n      return obj.destroy();\n    }).then(() => {\n      const query = new Parse.Query('AnObject');\n      return query.find();\n    }).then(results => {\n      expect(results.length).toBe(0);\n      done();\n    }).catch(err => {\n      fail('should not fail');\n      jfail(err);\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"regression test for #4409 (indexes override the clp)","suites":["schemas","Nested documents"],"line":2838,"updatePoint":{"line":2838,"column":58,"index":78975},"code":"  it('regression test for #4409 (indexes override the clp)', done => {\n    setPermissionsOnClass('_Role', {\n      get: {\n        '*': true\n      },\n      find: {\n        '*': true\n      },\n      count: {\n        '*': true\n      },\n      create: {\n        '*': true\n      }\n    }, true).then(() => {\n      const config = Config.get('test');\n      return config.database.adapter.updateSchemaWithIndexes();\n    }).then(() => {\n      return request({\n        url: 'http://localhost:8378/1/schemas/_Role',\n        headers: masterKeyHeaders,\n        json: true\n      });\n    }).then(res => {\n      expect(res.data.classLevelPermissions).toEqual({\n        get: {\n          '*': true\n        },\n        find: {\n          '*': true\n        },\n        count: {\n          '*': true\n        },\n        create: {\n          '*': true\n        },\n        update: {},\n        delete: {},\n        addField: {},\n        protectedFields: {}\n      });\n    }).then(done).catch(done.fail);\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"regression test for #5177","suites":["schemas","Nested documents"],"line":2882,"updatePoint":{"line":2882,"column":31,"index":79921},"code":"  it('regression test for #5177', async () => {\n    Parse.Object.disableSingleInstance();\n    Parse.Cloud.beforeSave('AClass', () => {});\n    await setPermissionsOnClass('AClass', {\n      update: {\n        '*': true\n      }\n    }, false);\n    const obj = new Parse.Object('AClass');\n    await obj.save({\n      key: 1\n    }, {\n      useMasterKey: true\n    });\n    obj.increment('key', 10);\n    const objectAgain = await obj.save();\n    expect(objectAgain.get('key')).toBe(11);\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"regression test for #2246","suites":["schemas","Nested documents"],"line":2900,"updatePoint":{"line":2900,"column":31,"index":80403},"code":"  it('regression test for #2246', done => {\n    const profile = new Parse.Object('UserProfile');\n    const user = new Parse.User();\n    function initialize() {\n      return user.save({\n        username: 'user',\n        password: 'password'\n      }).then(() => {\n        return profile.save({\n          user\n        }).then(() => {\n          return user.save({\n            userProfile: profile\n          }, {\n            useMasterKey: true\n          });\n        });\n      });\n    }\n    initialize().then(() => {\n      return setPermissionsOnClass('UserProfile', {\n        readUserFields: ['user'],\n        writeUserFields: ['user']\n      }, true);\n    }).then(() => {\n      return Parse.User.logIn('user', 'password');\n    }).then(() => {\n      const query = new Parse.Query('_User');\n      query.include('userProfile');\n      return query.get(user.id);\n    }).then(user => {\n      expect(user.get('userProfile')).not.toBeUndefined();\n      done();\n    }, err => {\n      jfail(err);\n      done();\n    });\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should reject creating class schema with field with invalid key","suites":["schemas","Nested documents"],"line":2938,"updatePoint":{"line":2938,"column":69,"index":81451},"code":"  it('should reject creating class schema with field with invalid key', async done => {\n    const config = Config.get(Parse.applicationId);\n    const schemaController = await config.database.loadSchema();\n    const fieldName = '1invalid';\n    const schemaCreation = () => schemaController.addClassIfNotExists('AnObject', {\n      [fieldName]: {\n        __type: 'String'\n      }\n    });\n    await expectAsync(schemaCreation()).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_KEY_NAME, `invalid field name: ${fieldName}`));\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should reject creating invalid field name","suites":["schemas","Nested documents"],"line":2950,"updatePoint":{"line":2950,"column":47,"index":81973},"code":"  it('should reject creating invalid field name', async done => {\n    const object = new Parse.Object('AnObject');\n    await expectAsync(object.save({\n      '!12field': 'field'\n    })).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_KEY_NAME));\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should be rejected if CLP operation is not an object","suites":["schemas","Nested documents"],"line":2957,"updatePoint":{"line":2957,"column":58,"index":82252},"code":"  it('should be rejected if CLP operation is not an object', async done => {\n    const config = Config.get(Parse.applicationId);\n    const schemaController = await config.database.loadSchema();\n    const operationKey = 'get';\n    const operation = true;\n    const schemaSetup = async () => await schemaController.addClassIfNotExists('AnObject', {}, {\n      [operationKey]: operation\n    });\n    await expectAsync(schemaSetup()).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_JSON, `'${operation}' is not a valid value for class level permissions ${operationKey} - must be an object`));\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should be rejected if CLP protectedFields is not an object","suites":["schemas","Nested documents"],"line":2968,"updatePoint":{"line":2968,"column":64,"index":82868},"code":"  it('should be rejected if CLP protectedFields is not an object', async done => {\n    const config = Config.get(Parse.applicationId);\n    const schemaController = await config.database.loadSchema();\n    const operationKey = 'get';\n    const operation = 'wrongtype';\n    const schemaSetup = async () => await schemaController.addClassIfNotExists('AnObject', {}, {\n      [operationKey]: operation\n    });\n    await expectAsync(schemaSetup()).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_JSON, `'${operation}' is not a valid value for class level permissions ${operationKey} - must be an object`));\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should be rejected if CLP read/writeUserFields is not an array","suites":["schemas","Nested documents"],"line":2979,"updatePoint":{"line":2979,"column":68,"index":83495},"code":"  it('should be rejected if CLP read/writeUserFields is not an array', async done => {\n    const config = Config.get(Parse.applicationId);\n    const schemaController = await config.database.loadSchema();\n    const operationKey = 'readUserFields';\n    const operation = true;\n    const schemaSetup = async () => await schemaController.addClassIfNotExists('AnObject', {}, {\n      [operationKey]: operation\n    });\n    await expectAsync(schemaSetup()).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_JSON, `'${operation}' is not a valid value for class level permissions ${operationKey} - must be an array`));\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"should be rejected if CLP pointerFields is not an array","suites":["schemas","Nested documents"],"line":2990,"updatePoint":{"line":2990,"column":61,"index":84118},"code":"  it('should be rejected if CLP pointerFields is not an array', async done => {\n    const config = Config.get(Parse.applicationId);\n    const schemaController = await config.database.loadSchema();\n    const operationKey = 'get';\n    const entity = 'pointerFields';\n    const value = {};\n    const schemaSetup = async () => await schemaController.addClassIfNotExists('AnObject', {}, {\n      [operationKey]: {\n        [entity]: value\n      }\n    });\n    await expectAsync(schemaSetup()).toBeRejectedWith(new Parse.Error(Parse.Error.INVALID_JSON, `'${value}' is not a valid value for ${operationKey}[${entity}] - expected an array.`));\n    done();\n  });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"cannot create index if field does not exist","suites":["schemas","index management"],"line":3011,"updatePoint":{"line":3011,"column":51,"index":84996},"code":"    it('cannot create index if field does not exist', done => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {}\n      }).then(() => {\n        request({\n          url: 'http://localhost:8378/1/schemas/NewClass',\n          method: 'PUT',\n          headers: masterKeyHeaders,\n          json: true,\n          body: {\n            indexes: {\n              name1: {\n                aString: 1\n              }\n            }\n          }\n        }).then(fail, response => {\n          expect(response.data.code).toBe(Parse.Error.INVALID_QUERY);\n          expect(response.data.error).toBe('Field aString does not exist, cannot add index.');\n          done();\n        });\n      });\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"can create index on default field","suites":["schemas","index management"],"line":3038,"updatePoint":{"line":3038,"column":41,"index":85784},"code":"    it('can create index on default field', done => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {}\n      }).then(() => {\n        request({\n          url: 'http://localhost:8378/1/schemas/NewClass',\n          method: 'PUT',\n          headers: masterKeyHeaders,\n          json: true,\n          body: {\n            indexes: {\n              name1: {\n                createdAt: 1\n              }\n            }\n          }\n        }).then(response => {\n          expect(response.data.indexes.name1).toEqual({\n            createdAt: 1\n          });\n          done();\n        });\n      });\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"cannot create compound index if field does not exist","suites":["schemas","index management"],"line":3066,"updatePoint":{"line":3066,"column":60,"index":86517},"code":"    it('cannot create compound index if field does not exist', done => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {}\n      }).then(() => {\n        request({\n          url: 'http://localhost:8378/1/schemas/NewClass',\n          method: 'PUT',\n          headers: masterKeyHeaders,\n          json: true,\n          body: {\n            fields: {\n              aString: {\n                type: 'String'\n              }\n            },\n            indexes: {\n              name1: {\n                aString: 1,\n                bString: 1\n              }\n            }\n          }\n        }).then(fail, response => {\n          expect(response.data.code).toBe(Parse.Error.INVALID_QUERY);\n          expect(response.data.error).toBe('Field bString does not exist, cannot add index.');\n          done();\n        });\n      });\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"allows add index when you create a class","suites":["schemas","index management"],"line":3099,"updatePoint":{"line":3099,"column":48,"index":87449},"code":"    it('allows add index when you create a class', done => {\n      request({\n        url: 'http://localhost:8378/1/schemas',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          className: 'NewClass',\n          fields: {\n            aString: {\n              type: 'String'\n            }\n          },\n          indexes: {\n            name1: {\n              aString: 1\n            }\n          }\n        }\n      }).then(response => {\n        expect(response.data).toEqual({\n          className: 'NewClass',\n          fields: {\n            ACL: {\n              type: 'ACL'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            objectId: {\n              type: 'String'\n            },\n            aString: {\n              type: 'String'\n            }\n          },\n          classLevelPermissions: defaultClassLevelPermissions,\n          indexes: {\n            name1: {\n              aString: 1\n            }\n          }\n        });\n        config.database.adapter.getIndexes('NewClass').then(indexes => {\n          expect(indexes.length).toBe(2);\n          done();\n        });\n      });\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"empty index returns nothing","suites":["schemas","index management"],"line":3151,"updatePoint":{"line":3151,"column":35,"index":88684},"code":"    it('empty index returns nothing', done => {\n      request({\n        url: 'http://localhost:8378/1/schemas',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          className: 'NewClass',\n          fields: {\n            aString: {\n              type: 'String'\n            }\n          },\n          indexes: {}\n        }\n      }).then(response => {\n        expect(response.data).toEqual({\n          className: 'NewClass',\n          fields: {\n            ACL: {\n              type: 'ACL'\n            },\n            createdAt: {\n              type: 'Date'\n            },\n            updatedAt: {\n              type: 'Date'\n            },\n            objectId: {\n              type: 'String'\n            },\n            aString: {\n              type: 'String'\n            }\n          },\n          classLevelPermissions: defaultClassLevelPermissions\n        });\n        done();\n      });\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"lets you add indexes","suites":["schemas","index management"],"line":3191,"updatePoint":{"line":3191,"column":28,"index":89618},"code":"    it('lets you add indexes', done => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {}\n      }).then(() => {\n        request({\n          url: 'http://localhost:8378/1/schemas/NewClass',\n          method: 'PUT',\n          headers: masterKeyHeaders,\n          json: true,\n          body: {\n            fields: {\n              aString: {\n                type: 'String'\n              }\n            },\n            indexes: {\n              name1: {\n                aString: 1\n              }\n            }\n          }\n        }).then(response => {\n          expect(dd(response.data, {\n            className: 'NewClass',\n            fields: {\n              ACL: {\n                type: 'ACL'\n              },\n              createdAt: {\n                type: 'Date'\n              },\n              updatedAt: {\n                type: 'Date'\n              },\n              objectId: {\n                type: 'String'\n              },\n              aString: {\n                type: 'String'\n              }\n            },\n            classLevelPermissions: defaultClassLevelPermissions,\n            indexes: {\n              _id_: {\n                _id: 1\n              },\n              name1: {\n                aString: 1\n              }\n            }\n          })).toEqual(undefined);\n          request({\n            url: 'http://localhost:8378/1/schemas/NewClass',\n            headers: masterKeyHeaders,\n            json: true\n          }).then(response => {\n            expect(response.data).toEqual({\n              className: 'NewClass',\n              fields: {\n                ACL: {\n                  type: 'ACL'\n                },\n                createdAt: {\n                  type: 'Date'\n                },\n                updatedAt: {\n                  type: 'Date'\n                },\n                objectId: {\n                  type: 'String'\n                },\n                aString: {\n                  type: 'String'\n                }\n              },\n              classLevelPermissions: defaultClassLevelPermissions,\n              indexes: {\n                _id_: {\n                  _id: 1\n                },\n                name1: {\n                  aString: 1\n                }\n              }\n            });\n            config.database.adapter.getIndexes('NewClass').then(indexes => {\n              expect(indexes.length).toEqual(2);\n              done();\n            });\n          });\n        });\n      });\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"lets you add multiple indexes","suites":["schemas","index management"],"line":3388,"updatePoint":{"line":3388,"column":37,"index":94930},"code":"    it('lets you add multiple indexes', done => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {}\n      }).then(() => {\n        request({\n          url: 'http://localhost:8378/1/schemas/NewClass',\n          method: 'PUT',\n          headers: masterKeyHeaders,\n          json: true,\n          body: {\n            fields: {\n              aString: {\n                type: 'String'\n              },\n              bString: {\n                type: 'String'\n              },\n              cString: {\n                type: 'String'\n              },\n              dString: {\n                type: 'String'\n              }\n            },\n            indexes: {\n              name1: {\n                aString: 1\n              },\n              name2: {\n                bString: 1\n              },\n              name3: {\n                cString: 1,\n                dString: 1\n              }\n            }\n          }\n        }).then(response => {\n          expect(dd(response.data, {\n            className: 'NewClass',\n            fields: {\n              ACL: {\n                type: 'ACL'\n              },\n              createdAt: {\n                type: 'Date'\n              },\n              updatedAt: {\n                type: 'Date'\n              },\n              objectId: {\n                type: 'String'\n              },\n              aString: {\n                type: 'String'\n              },\n              bString: {\n                type: 'String'\n              },\n              cString: {\n                type: 'String'\n              },\n              dString: {\n                type: 'String'\n              }\n            },\n            classLevelPermissions: defaultClassLevelPermissions,\n            indexes: {\n              _id_: {\n                _id: 1\n              },\n              name1: {\n                aString: 1\n              },\n              name2: {\n                bString: 1\n              },\n              name3: {\n                cString: 1,\n                dString: 1\n              }\n            }\n          })).toEqual(undefined);\n          request({\n            url: 'http://localhost:8378/1/schemas/NewClass',\n            headers: masterKeyHeaders,\n            json: true\n          }).then(response => {\n            expect(response.data).toEqual({\n              className: 'NewClass',\n              fields: {\n                ACL: {\n                  type: 'ACL'\n                },\n                createdAt: {\n                  type: 'Date'\n                },\n                updatedAt: {\n                  type: 'Date'\n                },\n                objectId: {\n                  type: 'String'\n                },\n                aString: {\n                  type: 'String'\n                },\n                bString: {\n                  type: 'String'\n                },\n                cString: {\n                  type: 'String'\n                },\n                dString: {\n                  type: 'String'\n                }\n              },\n              classLevelPermissions: defaultClassLevelPermissions,\n              indexes: {\n                _id_: {\n                  _id: 1\n                },\n                name1: {\n                  aString: 1\n                },\n                name2: {\n                  bString: 1\n                },\n                name3: {\n                  cString: 1,\n                  dString: 1\n                }\n              }\n            });\n            config.database.adapter.getIndexes('NewClass').then(indexes => {\n              expect(indexes.length).toEqual(4);\n              done();\n            });\n          });\n        });\n      });\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"lets you delete indexes","suites":["schemas","index management"],"line":3533,"updatePoint":{"line":3533,"column":31,"index":98661},"code":"    it('lets you delete indexes', done => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {}\n      }).then(() => {\n        request({\n          url: 'http://localhost:8378/1/schemas/NewClass',\n          method: 'PUT',\n          headers: masterKeyHeaders,\n          json: true,\n          body: {\n            fields: {\n              aString: {\n                type: 'String'\n              }\n            },\n            indexes: {\n              name1: {\n                aString: 1\n              }\n            }\n          }\n        }).then(response => {\n          expect(dd(response.data, {\n            className: 'NewClass',\n            fields: {\n              ACL: {\n                type: 'ACL'\n              },\n              createdAt: {\n                type: 'Date'\n              },\n              updatedAt: {\n                type: 'Date'\n              },\n              objectId: {\n                type: 'String'\n              },\n              aString: {\n                type: 'String'\n              }\n            },\n            classLevelPermissions: defaultClassLevelPermissions,\n            indexes: {\n              _id_: {\n                _id: 1\n              },\n              name1: {\n                aString: 1\n              }\n            }\n          })).toEqual(undefined);\n          request({\n            url: 'http://localhost:8378/1/schemas/NewClass',\n            method: 'PUT',\n            headers: masterKeyHeaders,\n            json: true,\n            body: {\n              indexes: {\n                name1: {\n                  __op: 'Delete'\n                }\n              }\n            }\n          }).then(response => {\n            expect(response.data).toEqual({\n              className: 'NewClass',\n              fields: {\n                ACL: {\n                  type: 'ACL'\n                },\n                createdAt: {\n                  type: 'Date'\n                },\n                updatedAt: {\n                  type: 'Date'\n                },\n                objectId: {\n                  type: 'String'\n                },\n                aString: {\n                  type: 'String'\n                }\n              },\n              classLevelPermissions: defaultClassLevelPermissions,\n              indexes: {\n                _id_: {\n                  _id: 1\n                }\n              }\n            });\n            config.database.adapter.getIndexes('NewClass').then(indexes => {\n              expect(indexes.length).toEqual(1);\n              done();\n            });\n          });\n        });\n      });\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"lets you delete multiple indexes","suites":["schemas","index management"],"line":3635,"updatePoint":{"line":3635,"column":40,"index":101332},"code":"    it('lets you delete multiple indexes', done => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {}\n      }).then(() => {\n        request({\n          url: 'http://localhost:8378/1/schemas/NewClass',\n          method: 'PUT',\n          headers: masterKeyHeaders,\n          json: true,\n          body: {\n            fields: {\n              aString: {\n                type: 'String'\n              },\n              bString: {\n                type: 'String'\n              },\n              cString: {\n                type: 'String'\n              }\n            },\n            indexes: {\n              name1: {\n                aString: 1\n              },\n              name2: {\n                bString: 1\n              },\n              name3: {\n                cString: 1\n              }\n            }\n          }\n        }).then(response => {\n          expect(dd(response.data, {\n            className: 'NewClass',\n            fields: {\n              ACL: {\n                type: 'ACL'\n              },\n              createdAt: {\n                type: 'Date'\n              },\n              updatedAt: {\n                type: 'Date'\n              },\n              objectId: {\n                type: 'String'\n              },\n              aString: {\n                type: 'String'\n              },\n              bString: {\n                type: 'String'\n              },\n              cString: {\n                type: 'String'\n              }\n            },\n            classLevelPermissions: defaultClassLevelPermissions,\n            indexes: {\n              _id_: {\n                _id: 1\n              },\n              name1: {\n                aString: 1\n              },\n              name2: {\n                bString: 1\n              },\n              name3: {\n                cString: 1\n              }\n            }\n          })).toEqual(undefined);\n          request({\n            url: 'http://localhost:8378/1/schemas/NewClass',\n            method: 'PUT',\n            headers: masterKeyHeaders,\n            json: true,\n            body: {\n              indexes: {\n                name1: {\n                  __op: 'Delete'\n                },\n                name2: {\n                  __op: 'Delete'\n                }\n              }\n            }\n          }).then(response => {\n            expect(response.data).toEqual({\n              className: 'NewClass',\n              fields: {\n                ACL: {\n                  type: 'ACL'\n                },\n                createdAt: {\n                  type: 'Date'\n                },\n                updatedAt: {\n                  type: 'Date'\n                },\n                objectId: {\n                  type: 'String'\n                },\n                aString: {\n                  type: 'String'\n                },\n                bString: {\n                  type: 'String'\n                },\n                cString: {\n                  type: 'String'\n                }\n              },\n              classLevelPermissions: defaultClassLevelPermissions,\n              indexes: {\n                _id_: {\n                  _id: 1\n                },\n                name3: {\n                  cString: 1\n                }\n              }\n            });\n            config.database.adapter.getIndexes('NewClass').then(indexes => {\n              expect(indexes.length).toEqual(2);\n              done();\n            });\n          });\n        });\n      });\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"lets you add and delete indexes","suites":["schemas","index management"],"line":3773,"updatePoint":{"line":3773,"column":39,"index":104870},"code":"    it('lets you add and delete indexes', async () => {\n      // Wait due to index building in MongoDB on background process with collection lock\n      const waitForIndexBuild = new Promise(r => setTimeout(r, 500));\n      await request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {}\n      });\n      let response = await request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          fields: {\n            aString: {\n              type: 'String'\n            },\n            bString: {\n              type: 'String'\n            },\n            cString: {\n              type: 'String'\n            },\n            dString: {\n              type: 'String'\n            }\n          },\n          indexes: {\n            name1: {\n              aString: 1\n            },\n            name2: {\n              bString: 1\n            },\n            name3: {\n              cString: 1\n            }\n          }\n        }\n      });\n      expect(dd(response.data, {\n        className: 'NewClass',\n        fields: {\n          ACL: {\n            type: 'ACL'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          objectId: {\n            type: 'String'\n          },\n          aString: {\n            type: 'String'\n          },\n          bString: {\n            type: 'String'\n          },\n          cString: {\n            type: 'String'\n          },\n          dString: {\n            type: 'String'\n          }\n        },\n        classLevelPermissions: defaultClassLevelPermissions,\n        indexes: {\n          _id_: {\n            _id: 1\n          },\n          name1: {\n            aString: 1\n          },\n          name2: {\n            bString: 1\n          },\n          name3: {\n            cString: 1\n          }\n        }\n      })).toEqual(undefined);\n      await waitForIndexBuild;\n      response = await request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          indexes: {\n            name1: {\n              __op: 'Delete'\n            },\n            name2: {\n              __op: 'Delete'\n            }\n          }\n        }\n      });\n      expect(response.data).toEqual({\n        className: 'NewClass',\n        fields: {\n          ACL: {\n            type: 'ACL'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          objectId: {\n            type: 'String'\n          },\n          aString: {\n            type: 'String'\n          },\n          bString: {\n            type: 'String'\n          },\n          cString: {\n            type: 'String'\n          },\n          dString: {\n            type: 'String'\n          }\n        },\n        classLevelPermissions: defaultClassLevelPermissions,\n        indexes: {\n          _id_: {\n            _id: 1\n          },\n          name3: {\n            cString: 1\n          }\n        }\n      });\n      await waitForIndexBuild;\n      response = await request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'PUT',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {\n          indexes: {\n            name4: {\n              dString: 1\n            }\n          }\n        }\n      });\n      expect(response.data).toEqual({\n        className: 'NewClass',\n        fields: {\n          ACL: {\n            type: 'ACL'\n          },\n          createdAt: {\n            type: 'Date'\n          },\n          updatedAt: {\n            type: 'Date'\n          },\n          objectId: {\n            type: 'String'\n          },\n          aString: {\n            type: 'String'\n          },\n          bString: {\n            type: 'String'\n          },\n          cString: {\n            type: 'String'\n          },\n          dString: {\n            type: 'String'\n          }\n        },\n        classLevelPermissions: defaultClassLevelPermissions,\n        indexes: {\n          _id_: {\n            _id: 1\n          },\n          name3: {\n            cString: 1\n          },\n          name4: {\n            dString: 1\n          }\n        }\n      });\n      await waitForIndexBuild;\n      const indexes = await config.database.adapter.getIndexes('NewClass');\n      expect(indexes.length).toEqual(3);\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"cannot delete index that does not exist","suites":["schemas","index management"],"line":3974,"updatePoint":{"line":3974,"column":47,"index":109412},"code":"    it('cannot delete index that does not exist', done => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {}\n      }).then(() => {\n        request({\n          url: 'http://localhost:8378/1/schemas/NewClass',\n          method: 'PUT',\n          headers: masterKeyHeaders,\n          json: true,\n          body: {\n            indexes: {\n              unknownIndex: {\n                __op: 'Delete'\n              }\n            }\n          }\n        }).then(fail, response => {\n          expect(response.data.code).toBe(Parse.Error.INVALID_QUERY);\n          expect(response.data.error).toBe('Index unknownIndex does not exist, cannot delete.');\n          done();\n        });\n      });\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"cannot update index that exist","suites":["schemas","index management"],"line":4001,"updatePoint":{"line":4001,"column":38,"index":110210},"code":"    it('cannot update index that exist', done => {\n      request({\n        url: 'http://localhost:8378/1/schemas/NewClass',\n        method: 'POST',\n        headers: masterKeyHeaders,\n        json: true,\n        body: {}\n      }).then(() => {\n        request({\n          url: 'http://localhost:8378/1/schemas/NewClass',\n          method: 'PUT',\n          headers: masterKeyHeaders,\n          json: true,\n          body: {\n            fields: {\n              aString: {\n                type: 'String'\n              }\n            },\n            indexes: {\n              name1: {\n                aString: 1\n              }\n            }\n          }\n        }).then(() => {\n          request({\n            url: 'http://localhost:8378/1/schemas/NewClass',\n            method: 'PUT',\n            headers: masterKeyHeaders,\n            json: true,\n            body: {\n              indexes: {\n                name1: {\n                  field2: 1\n                }\n              }\n            }\n          }).then(fail, response => {\n            expect(response.data.code).toBe(Parse.Error.INVALID_QUERY);\n            expect(response.data.error).toBe('Index name1 exists, cannot update.');\n            done();\n          });\n        });\n      });\n    });","file":"schemas.spec.js","skipped":false,"dir":"spec"},{"name":"uses default configuration when none is set","suites":["Security Check","server options"],"line":74,"updatePoint":{"line":74,"column":51,"index":2041},"code":"    it('uses default configuration when none is set', async () => {\n      await reconfigureServerWithSecurityConfig({});\n      expect(Config.get(Parse.applicationId).security.enableCheck).toBe(Definitions.SecurityOptions.enableCheck.default);\n      expect(Config.get(Parse.applicationId).security.enableCheckLog).toBe(Definitions.SecurityOptions.enableCheckLog.default);\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"throws on invalid configuration","suites":["Security Check","server options"],"line":79,"updatePoint":{"line":79,"column":39,"index":2408},"code":"    it('throws on invalid configuration', async () => {\n      const options = [[], 'a', 0, true, {\n        enableCheck: 'a'\n      }, {\n        enableCheck: 0\n      }, {\n        enableCheck: {}\n      }, {\n        enableCheck: []\n      }, {\n        enableCheckLog: 'a'\n      }, {\n        enableCheckLog: 0\n      }, {\n        enableCheckLog: {}\n      }, {\n        enableCheckLog: []\n      }];\n      for (const option of options) {\n        await expectAsync(reconfigureServerWithSecurityConfig(option)).toBeRejected();\n      }\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"runs security checks on server start if enabled","suites":["Security Check","auto-run"],"line":103,"updatePoint":{"line":103,"column":55,"index":2992},"code":"    it('runs security checks on server start if enabled', async () => {\n      const runnerSpy = spyOn(CheckRunner.prototype, 'run').and.callThrough();\n      await reconfigureServerWithSecurityConfig({\n        enableCheck: true,\n        enableCheckLog: true\n      });\n      expect(runnerSpy).toHaveBeenCalledTimes(1);\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"does not run security checks on server start if disabled","suites":["Security Check","auto-run"],"line":111,"updatePoint":{"line":111,"column":64,"index":3326},"code":"    it('does not run security checks on server start if disabled', async () => {\n      const runnerSpy = spyOn(CheckRunner.prototype, 'run').and.callThrough();\n      const configs = [{\n        enableCheck: true,\n        enableCheckLog: false\n      }, {\n        enableCheck: false,\n        enableCheckLog: false\n      }, {\n        enableCheck: false\n      }, {}];\n      for (const config of configs) {\n        await reconfigureServerWithSecurityConfig(config);\n        expect(runnerSpy).not.toHaveBeenCalled();\n      }\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"responds with 403 without masterkey","suites":["Security Check","security endpoint accessibility"],"line":129,"updatePoint":{"line":129,"column":43,"index":3891},"code":"    it('responds with 403 without masterkey', async () => {\n      const response = await securityRequest({\n        headers: {}\n      });\n      expect(response.status).toBe(403);\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"responds with 409 with masterkey and security check disabled","suites":["Security Check","security endpoint accessibility"],"line":135,"updatePoint":{"line":135,"column":68,"index":4102},"code":"    it('responds with 409 with masterkey and security check disabled', async () => {\n      await reconfigureServerWithSecurityConfig({});\n      const response = await securityRequest();\n      expect(response.status).toBe(409);\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"responds with 200 with masterkey and security check enabled","suites":["Security Check","security endpoint accessibility"],"line":140,"updatePoint":{"line":140,"column":67,"index":4336},"code":"    it('responds with 200 with masterkey and security check enabled', async () => {\n      const response = await securityRequest();\n      expect(response.status).toBe(200);\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"instantiates check with valid parameters","suites":["Security Check","check"],"line":147,"updatePoint":{"line":147,"column":48,"index":4602},"code":"    it('instantiates check with valid parameters', async () => {\n      const configs = [{\n        group: 'string',\n        title: 'string',\n        warning: 'string',\n        solution: 'string',\n        check: () => {}\n      }, {\n        group: 'string',\n        title: 'string',\n        warning: 'string',\n        solution: 'string',\n        check: async () => {}\n      }];\n      for (const config of configs) {\n        expect(initCheck(config)).not.toThrow();\n      }\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"throws instantiating check with invalid parameters","suites":["Security Check","check"],"line":165,"updatePoint":{"line":165,"column":58,"index":5090},"code":"    it('throws instantiating check with invalid parameters', async () => {\n      const configDefinition = {\n        group: [false, true, 0, 1, [], {}, () => {}],\n        title: [false, true, 0, 1, [], {}, () => {}],\n        warning: [false, true, 0, 1, [], {}, () => {}],\n        solution: [false, true, 0, 1, [], {}, () => {}],\n        check: [false, true, 0, 1, [], {}, 'string']\n      };\n      const configs = Utils.getObjectKeyPermutations(configDefinition);\n      for (const config of configs) {\n        expect(initCheck(config)).toThrow();\n      }\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"sets correct states for check success","suites":["Security Check","check"],"line":178,"updatePoint":{"line":178,"column":45,"index":5639},"code":"    it('sets correct states for check success', async () => {\n      const check = new Check({\n        group: 'string',\n        title: 'string',\n        warning: 'string',\n        solution: 'string',\n        check: () => {}\n      });\n      expect(check._checkState == CheckState.none);\n      check.run();\n      expect(check._checkState == CheckState.success);\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"sets correct states for check fail","suites":["Security Check","check"],"line":190,"updatePoint":{"line":190,"column":42,"index":6003},"code":"    it('sets correct states for check fail', async () => {\n      const check = new Check({\n        group: 'string',\n        title: 'string',\n        warning: 'string',\n        solution: 'string',\n        check: () => {\n          throw 'error';\n        }\n      });\n      expect(check._checkState == CheckState.none);\n      check.run();\n      expect(check._checkState == CheckState.fail);\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"returns properties if subclassed correctly","suites":["Security Check","check group"],"line":206,"updatePoint":{"line":206,"column":50,"index":6446},"code":"    it('returns properties if subclassed correctly', async () => {\n      const group = new Group();\n      expect(group.name()).toBe(groupName);\n      expect(group.checks().length).toBe(2);\n      expect(group.checks()[0]).toEqual(checkSuccess);\n      expect(group.checks()[1]).toEqual(checkFail);\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"throws if subclassed incorrectly","suites":["Security Check","check group"],"line":213,"updatePoint":{"line":213,"column":40,"index":6740},"code":"    it('throws if subclassed incorrectly', async () => {\n      class InvalidGroup1 extends CheckGroup {}\n      expect((() => new InvalidGroup1()).bind()).toThrow('Check group has no name.');\n      class InvalidGroup2 extends CheckGroup {\n        setName() {\n          return groupName;\n        }\n      }\n      expect((() => new InvalidGroup2()).bind()).toThrow('Check group has no checks.');\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"runs checks","suites":["Security Check","check group"],"line":223,"updatePoint":{"line":223,"column":19,"index":7119},"code":"    it('runs checks', async () => {\n      const group = new Group();\n      expect(group.checks()[0].checkState()).toBe(CheckState.none);\n      expect(group.checks()[1].checkState()).toBe(CheckState.none);\n      expect((() => group.run()).bind(null)).not.toThrow();\n      expect(group.checks()[0].checkState()).toBe(CheckState.success);\n      expect(group.checks()[1].checkState()).toBe(CheckState.fail);\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"instantiates runner with valid parameters","suites":["Security Check","check runner"],"line":234,"updatePoint":{"line":234,"column":49,"index":7679},"code":"    it('instantiates runner with valid parameters', async () => {\n      const configDefinition = {\n        enableCheck: [false, true, undefined],\n        enableCheckLog: [false, true, undefined],\n        checkGroups: [[], undefined]\n      };\n      const configs = Utils.getObjectKeyPermutations(configDefinition);\n      for (const config of configs) {\n        expect(initRunner(config)).not.toThrow();\n      }\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"throws instantiating runner with invalid parameters","suites":["Security Check","check runner"],"line":245,"updatePoint":{"line":245,"column":59,"index":8107},"code":"    it('throws instantiating runner with invalid parameters', async () => {\n      const configDefinition = {\n        enableCheck: [0, 1, [], {}, () => {}],\n        enableCheckLog: [0, 1, [], {}, () => {}],\n        checkGroups: [false, true, 0, 1, {}, () => {}]\n      };\n      const configs = Utils.getObjectKeyPermutations(configDefinition);\n      for (const config of configs) {\n        expect(initRunner(config)).toThrow();\n      }\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"instantiates runner with default parameters","suites":["Security Check","check runner"],"line":256,"updatePoint":{"line":256,"column":51,"index":8541},"code":"    it('instantiates runner with default parameters', async () => {\n      const runner = new CheckRunner();\n      expect(runner.enableCheck).toBeFalse();\n      expect(runner.enableCheckLog).toBeFalse();\n      expect(runner.checkGroups).toBe(CheckGroups);\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"runs all checks of all groups","suites":["Security Check","check runner"],"line":262,"updatePoint":{"line":262,"column":37,"index":8790},"code":"    it('runs all checks of all groups', async () => {\n      const checkGroups = [Group, Group];\n      const runner = new CheckRunner({\n        checkGroups\n      });\n      const report = await runner.run();\n      expect(report.report.groups[0].checks[0].state).toBe(CheckState.success);\n      expect(report.report.groups[0].checks[1].state).toBe(CheckState.fail);\n      expect(report.report.groups[1].checks[0].state).toBe(CheckState.success);\n      expect(report.report.groups[1].checks[1].state).toBe(CheckState.fail);\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"reports correct default syntax version 1.0.0","suites":["Security Check","check runner"],"line":273,"updatePoint":{"line":273,"column":52,"index":9333},"code":"    it('reports correct default syntax version 1.0.0', async () => {\n      const checkGroups = [Group];\n      const runner = new CheckRunner({\n        checkGroups,\n        enableCheckLog: true\n      });\n      const report = await runner.run();\n      expect(report).toEqual({\n        report: {\n          version: '1.0.0',\n          state: 'fail',\n          groups: [{\n            name: 'Example Group Name',\n            state: 'fail',\n            checks: [{\n              title: 'TestTitleSuccess',\n              state: 'success'\n            }, {\n              title: 'TestTitleFail',\n              state: 'fail',\n              warning: 'TestWarning',\n              solution: 'TestSolution'\n            }]\n          }]\n        }\n      });\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"logs report","suites":["Security Check","check runner"],"line":300,"updatePoint":{"line":300,"column":19,"index":10046},"code":"    it('logs report', async () => {\n      const logger = require('../lib/logger').logger;\n      const logSpy = spyOn(logger, 'warn').and.callThrough();\n      const checkGroups = [Group];\n      const runner = new CheckRunner({\n        checkGroups,\n        enableCheckLog: true\n      });\n      const report = await runner.run();\n      const titles = report.report.groups.flatMap(group => group.checks.map(check => check.title));\n      expect(titles.length).toBe(2);\n      for (const title of titles) {\n        expect(logSpy.calls.all()[0].args[0]).toContain(title);\n      }\n    });","file":"SecurityCheck.spec.js","skipped":false,"dir":"spec"},{"name":"is subclassed correctly","suites":["Security Check Groups","CheckGroupServerConfig"],"line":24,"updatePoint":{"line":24,"column":31,"index":707},"code":"    it('is subclassed correctly', async () => {\n      const group = new CheckGroupServerConfig();\n      expect(group.name()).toBeDefined();\n      expect(group.checks().length).toBeGreaterThan(0);\n    });","file":"SecurityCheckGroups.spec.js","skipped":false,"dir":"spec"},{"name":"checks succeed correctly","suites":["Security Check Groups","CheckGroupServerConfig"],"line":29,"updatePoint":{"line":29,"column":32,"index":912},"code":"    it('checks succeed correctly', async () => {\n      config.masterKey = 'aMoreSecur3Passwor7!';\n      config.security.enableCheckLog = false;\n      config.allowClientClassCreation = false;\n      await reconfigureServer(config);\n      const group = new CheckGroupServerConfig();\n      await group.run();\n      expect(group.checks()[0].checkState()).toBe(CheckState.success);\n      expect(group.checks()[1].checkState()).toBe(CheckState.success);\n      expect(group.checks()[2].checkState()).toBe(CheckState.success);\n    });","file":"SecurityCheckGroups.spec.js","skipped":false,"dir":"spec"},{"name":"checks fail correctly","suites":["Security Check Groups","CheckGroupServerConfig"],"line":40,"updatePoint":{"line":40,"column":29,"index":1435},"code":"    it('checks fail correctly', async () => {\n      config.masterKey = 'insecure';\n      config.security.enableCheckLog = true;\n      config.allowClientClassCreation = true;\n      await reconfigureServer(config);\n      const group = new CheckGroupServerConfig();\n      await group.run();\n      expect(group.checks()[0].checkState()).toBe(CheckState.fail);\n      expect(group.checks()[1].checkState()).toBe(CheckState.fail);\n      expect(group.checks()[2].checkState()).toBe(CheckState.fail);\n    });","file":"SecurityCheckGroups.spec.js","skipped":false,"dir":"spec"},{"name":"is subclassed correctly","suites":["Security Check Groups","CheckGroupDatabase"],"line":53,"updatePoint":{"line":53,"column":31,"index":1984},"code":"    it('is subclassed correctly', async () => {\n      const group = new CheckGroupDatabase();\n      expect(group.name()).toBeDefined();\n      expect(group.checks().length).toBeGreaterThan(0);\n    });","file":"SecurityCheckGroups.spec.js","skipped":false,"dir":"spec"},{"name":"checks succeed correctly","suites":["Security Check Groups","CheckGroupDatabase"],"line":58,"updatePoint":{"line":58,"column":32,"index":2185},"code":"    it('checks succeed correctly', async () => {\n      const config = Config.get(Parse.applicationId);\n      config.database.adapter._uri = 'protocol://user:aMoreSecur3Passwor7!@example.com';\n      const group = new CheckGroupDatabase();\n      await group.run();\n      expect(group.checks()[0].checkState()).toBe(CheckState.success);\n    });","file":"SecurityCheckGroups.spec.js","skipped":false,"dir":"spec"},{"name":"checks fail correctly","suites":["Security Check Groups","CheckGroupDatabase"],"line":65,"updatePoint":{"line":65,"column":29,"index":2524},"code":"    it('checks fail correctly', async () => {\n      const config = Config.get(Parse.applicationId);\n      config.database.adapter._uri = 'protocol://user:insecure@example.com';\n      const group = new CheckGroupDatabase();\n      await group.run();\n      expect(group.checks()[0].checkState()).toBe(CheckState.fail);\n    });","file":"SecurityCheckGroups.spec.js","skipped":false,"dir":"spec"},{"name":"can get undefined userId","suites":["SessionTokenCache"],"line":15,"updatePoint":{"line":15,"column":30,"index":518},"code":"  it('can get undefined userId', function (done) {\n    const sessionTokenCache = new SessionTokenCache();\n    sessionTokenCache.getUserId(undefined).then(() => {}, error => {\n      expect(error).not.toBeNull();\n      done();\n    });\n  });","file":"SessionTokenCache.spec.js","skipped":false,"dir":"spec"},{"name":"can get existing userId","suites":["SessionTokenCache"],"line":22,"updatePoint":{"line":22,"column":29,"index":756},"code":"  it('can get existing userId', function (done) {\n    const sessionTokenCache = new SessionTokenCache();\n    const sessionToken = 'sessionToken';\n    const userId = 'userId';\n    sessionTokenCache.cache.set(sessionToken, userId);\n    sessionTokenCache.getUserId(sessionToken).then(userIdFromCache => {\n      expect(userIdFromCache).toBe(userId);\n      done();\n    });\n  });","file":"SessionTokenCache.spec.js","skipped":false,"dir":"spec"},{"name":"can get new userId","suites":["SessionTokenCache"],"line":32,"updatePoint":{"line":32,"column":24,"index":1125},"code":"  it('can get new userId', function (done) {\n    const sessionTokenCache = new SessionTokenCache();\n    sessionTokenCache.getUserId('sessionToken').then(userIdFromCache => {\n      expect(userIdFromCache).toBe('userId');\n      expect(sessionTokenCache.cache.length).toBe(1);\n      done();\n    });\n  });","file":"SessionTokenCache.spec.js","skipped":false,"dir":"spec"},{"name":"can be initialized","suites":["Subscription"],"line":8,"updatePoint":{"line":8,"column":24,"index":277},"code":"  it('can be initialized', function () {\n    const subscription = new Subscription('className', {\n      key: 'value'\n    }, 'hash');\n    expect(subscription.className).toBe('className');\n    expect(subscription.query).toEqual({\n      key: 'value'\n    });\n    expect(subscription.hash).toBe('hash');\n    expect(subscription.clientRequestIds.size).toBe(0);\n  });","file":"Subscription.spec.js","skipped":false,"dir":"spec"},{"name":"can check it has subscribing clients","suites":["Subscription"],"line":19,"updatePoint":{"line":19,"column":42,"index":656},"code":"  it('can check it has subscribing clients', function () {\n    const subscription = new Subscription('className', {\n      key: 'value'\n    }, 'hash');\n    expect(subscription.hasSubscribingClient()).toBe(false);\n  });","file":"Subscription.spec.js","skipped":false,"dir":"spec"},{"name":"can check it does not have subscribing clients","suites":["Subscription"],"line":25,"updatePoint":{"line":25,"column":52,"index":884},"code":"  it('can check it does not have subscribing clients', function () {\n    const subscription = new Subscription('className', {\n      key: 'value'\n    }, 'hash');\n    subscription.addClientSubscription(1, 1);\n    expect(subscription.hasSubscribingClient()).toBe(true);\n  });","file":"Subscription.spec.js","skipped":false,"dir":"spec"},{"name":"can add one request for one client","suites":["Subscription"],"line":32,"updatePoint":{"line":32,"column":40,"index":1145},"code":"  it('can add one request for one client', function () {\n    const subscription = new Subscription('className', {\n      key: 'value'\n    }, 'hash');\n    subscription.addClientSubscription(1, 1);\n    expect(subscription.clientRequestIds.size).toBe(1);\n    expect(subscription.clientRequestIds.get(1)).toEqual([1]);\n  });","file":"Subscription.spec.js","skipped":false,"dir":"spec"},{"name":"can add requests for one client","suites":["Subscription"],"line":40,"updatePoint":{"line":40,"column":37,"index":1462},"code":"  it('can add requests for one client', function () {\n    const subscription = new Subscription('className', {\n      key: 'value'\n    }, 'hash');\n    subscription.addClientSubscription(1, 1);\n    subscription.addClientSubscription(1, 2);\n    expect(subscription.clientRequestIds.size).toBe(1);\n    expect(subscription.clientRequestIds.get(1)).toEqual([1, 2]);\n  });","file":"Subscription.spec.js","skipped":false,"dir":"spec"},{"name":"can add requests for clients","suites":["Subscription"],"line":49,"updatePoint":{"line":49,"column":34,"index":1825},"code":"  it('can add requests for clients', function () {\n    const subscription = new Subscription('className', {\n      key: 'value'\n    }, 'hash');\n    subscription.addClientSubscription(1, 1);\n    subscription.addClientSubscription(1, 2);\n    subscription.addClientSubscription(2, 2);\n    subscription.addClientSubscription(2, 3);\n    expect(subscription.clientRequestIds.size).toBe(2);\n    expect(subscription.clientRequestIds.get(1)).toEqual([1, 2]);\n    expect(subscription.clientRequestIds.get(2)).toEqual([2, 3]);\n  });","file":"Subscription.spec.js","skipped":false,"dir":"spec"},{"name":"can delete requests for nonexistent client","suites":["Subscription"],"line":61,"updatePoint":{"line":61,"column":48,"index":2360},"code":"  it('can delete requests for nonexistent client', function () {\n    const subscription = new Subscription('className', {\n      key: 'value'\n    }, 'hash');\n    subscription.deleteClientSubscription(1, 1);\n    expect(logger.error).toHaveBeenCalled();\n  });","file":"Subscription.spec.js","skipped":false,"dir":"spec"},{"name":"can delete nonexistent request for one client","suites":["Subscription"],"line":68,"updatePoint":{"line":68,"column":51,"index":2620},"code":"  it('can delete nonexistent request for one client', function () {\n    const subscription = new Subscription('className', {\n      key: 'value'\n    }, 'hash');\n    subscription.addClientSubscription(1, 1);\n    subscription.deleteClientSubscription(1, 2);\n    expect(logger.error).toHaveBeenCalled();\n    expect(subscription.clientRequestIds.size).toBe(1);\n    expect(subscription.clientRequestIds.get(1)).toEqual([1]);\n  });","file":"Subscription.spec.js","skipped":false,"dir":"spec"},{"name":"can delete some requests for one client","suites":["Subscription"],"line":78,"updatePoint":{"line":78,"column":45,"index":3039},"code":"  it('can delete some requests for one client', function () {\n    const subscription = new Subscription('className', {\n      key: 'value'\n    }, 'hash');\n    subscription.addClientSubscription(1, 1);\n    subscription.addClientSubscription(1, 2);\n    subscription.deleteClientSubscription(1, 2);\n    expect(logger.error).not.toHaveBeenCalled();\n    expect(subscription.clientRequestIds.size).toBe(1);\n    expect(subscription.clientRequestIds.get(1)).toEqual([1]);\n  });","file":"Subscription.spec.js","skipped":false,"dir":"spec"},{"name":"can delete all requests for one client","suites":["Subscription"],"line":89,"updatePoint":{"line":89,"column":44,"index":3507},"code":"  it('can delete all requests for one client', function () {\n    const subscription = new Subscription('className', {\n      key: 'value'\n    }, 'hash');\n    subscription.addClientSubscription(1, 1);\n    subscription.addClientSubscription(1, 2);\n    subscription.deleteClientSubscription(1, 1);\n    subscription.deleteClientSubscription(1, 2);\n    expect(logger.error).not.toHaveBeenCalled();\n    expect(subscription.clientRequestIds.size).toBe(0);\n  });","file":"Subscription.spec.js","skipped":false,"dir":"spec"},{"name":"can delete requests for multiple clients","suites":["Subscription"],"line":100,"updatePoint":{"line":100,"column":46,"index":3963},"code":"  it('can delete requests for multiple clients', function () {\n    const subscription = new Subscription('className', {\n      key: 'value'\n    }, 'hash');\n    subscription.addClientSubscription(1, 1);\n    subscription.addClientSubscription(1, 2);\n    subscription.addClientSubscription(2, 1);\n    subscription.addClientSubscription(2, 2);\n    subscription.deleteClientSubscription(1, 2);\n    subscription.deleteClientSubscription(2, 1);\n    subscription.deleteClientSubscription(2, 2);\n    expect(logger.error).not.toHaveBeenCalled();\n    expect(subscription.clientRequestIds.size).toBe(1);\n    expect(subscription.clientRequestIds.get(1)).toEqual([1]);\n  });","file":"Subscription.spec.js","skipped":false,"dir":"spec"},{"name":"should use the proper configuration","suites":["Twitter Auth"],"line":3,"updatePoint":{"line":3,"column":41,"index":132},"code":"  it('should use the proper configuration', () => {\n    // Multiple options, consumer_key found\n    expect(twitter.handleMultipleConfigurations({\n      consumer_key: 'hello'\n    }, [{\n      consumer_key: 'hello'\n    }, {\n      consumer_key: 'world'\n    }]).consumer_key).toEqual('hello');\n\n    // Multiple options, consumer_key not found\n    expect(function () {\n      twitter.handleMultipleConfigurations({\n        consumer_key: 'some'\n      }, [{\n        consumer_key: 'hello'\n      }, {\n        consumer_key: 'world'\n      }]);\n    }).toThrow();\n\n    // Multiple options, consumer_key not found\n    expect(function () {\n      twitter.handleMultipleConfigurations({\n        auth_token: 'token'\n      }, [{\n        consumer_key: 'hello'\n      }, {\n        consumer_key: 'world'\n      }]);\n    }).toThrow();\n\n    // Single configuration and consumer_key set\n    expect(twitter.handleMultipleConfigurations({\n      consumer_key: 'hello'\n    }, {\n      consumer_key: 'hello'\n    }).consumer_key).toEqual('hello');\n\n    // General case, only 1 config, no consumer_key set\n    expect(twitter.handleMultipleConfigurations({\n      auth_token: 'token'\n    }, {\n      consumer_key: 'hello'\n    }).consumer_key).toEqual('hello');\n  });","file":"TwitterAuth.spec.js","skipped":false,"dir":"spec"},{"name":"Should fail with missing options","suites":["Twitter Auth"],"line":49,"updatePoint":{"line":49,"column":38,"index":1356},"code":"  it('Should fail with missing options', done => {\n    try {\n      twitter.validateAuthData({\n        consumer_key: 'key',\n        consumer_secret: 'secret',\n        auth_token: 'token',\n        auth_token_secret: 'secret'\n      }, undefined);\n    } catch (error) {\n      jequal(error.message, 'Twitter auth configuration missing');\n      done();\n    }\n  });","file":"TwitterAuth.spec.js","skipped":false,"dir":"spec"},{"name":"fail when create duplicate value in unique field","suites":["Uniqueness"],"line":6,"updatePoint":{"line":6,"column":54,"index":185},"code":"  it('fail when create duplicate value in unique field', done => {\n    const obj = new Parse.Object('UniqueField');\n    obj.set('unique', 'value');\n    obj.save().then(() => {\n      expect(obj.id).not.toBeUndefined();\n      const config = Config.get('test');\n      return config.database.adapter.ensureUniqueness('UniqueField', {\n        fields: {\n          unique: {\n            __type: 'String'\n          }\n        }\n      }, ['unique']);\n    }).then(() => {\n      const obj = new Parse.Object('UniqueField');\n      obj.set('unique', 'value');\n      return obj.save();\n    }).then(() => {\n      fail('Saving duplicate field should have failed');\n      done();\n    }, error => {\n      expect(error.code).toEqual(Parse.Error.DUPLICATE_VALUE);\n      done();\n    });\n  });","file":"Uniqueness.spec.js","skipped":false,"dir":"spec"},{"name":"unique indexing works on pointer fields","suites":["Uniqueness"],"line":31,"updatePoint":{"line":31,"column":45,"index":947},"code":"  it('unique indexing works on pointer fields', done => {\n    const obj = new Parse.Object('UniquePointer');\n    obj.save({\n      string: 'who cares'\n    }).then(() => obj.save({\n      ptr: obj\n    })).then(() => {\n      const config = Config.get('test');\n      return config.database.adapter.ensureUniqueness('UniquePointer', {\n        fields: {\n          string: {\n            __type: 'String'\n          },\n          ptr: {\n            __type: 'Pointer',\n            targetClass: 'UniquePointer'\n          }\n        }\n      }, ['ptr']);\n    }).then(() => {\n      const newObj = new Parse.Object('UniquePointer');\n      newObj.set('ptr', obj);\n      return newObj.save();\n    }).then(() => {\n      fail('save should have failed due to duplicate value');\n      done();\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.DUPLICATE_VALUE);\n      done();\n    });\n  });","file":"Uniqueness.spec.js","skipped":false,"dir":"spec"},{"name":"fails when attempting to ensure uniqueness of fields that are not currently unique","suites":["Uniqueness"],"line":62,"updatePoint":{"line":62,"column":88,"index":1874},"code":"  it('fails when attempting to ensure uniqueness of fields that are not currently unique', done => {\n    const o1 = new Parse.Object('UniqueFail');\n    o1.set('key', 'val');\n    const o2 = new Parse.Object('UniqueFail');\n    o2.set('key', 'val');\n    Parse.Object.saveAll([o1, o2]).then(() => {\n      const config = Config.get('test');\n      return config.database.adapter.ensureUniqueness('UniqueFail', {\n        fields: {\n          key: {\n            __type: 'String'\n          }\n        }\n      }, ['key']);\n    }).catch(error => {\n      expect(error.code).toEqual(Parse.Error.DUPLICATE_VALUE);\n      done();\n    });\n  });","file":"Uniqueness.spec.js","skipped":false,"dir":"spec"},{"name":"uses publicServerURL","suites":["UserController","sendVerificationEmail","parseFrameURL not provided"],"line":11,"updatePoint":{"line":11,"column":30,"index":421},"code":"      it('uses publicServerURL', async done => {\n        await reconfigureServer({\n          publicServerURL: 'http://www.example.com',\n          customPages: {\n            parseFrameURL: undefined\n          }\n        });\n        emailAdapter.sendVerificationEmail = options => {\n          expect(options.link).toEqual('http://www.example.com/apps/test/verify_email?token=testToken&username=testUser');\n          emailAdapter.sendVerificationEmail = () => Promise.resolve();\n          done();\n        };\n        const userController = new UserController(emailAdapter, 'test', {\n          verifyUserEmails: true\n        });\n        userController.sendVerificationEmail(user);\n      });","file":"UserController.spec.js","skipped":false,"dir":"spec"},{"name":"uses parseFrameURL and includes the destination in the link parameter","suites":["UserController","sendVerificationEmail","parseFrameURL provided"],"line":30,"updatePoint":{"line":30,"column":79,"index":1210},"code":"      it('uses parseFrameURL and includes the destination in the link parameter', async done => {\n        await reconfigureServer({\n          publicServerURL: 'http://www.example.com',\n          customPages: {\n            parseFrameURL: 'http://someother.example.com/handle-parse-iframe'\n          }\n        });\n        emailAdapter.sendVerificationEmail = options => {\n          expect(options.link).toEqual('http://someother.example.com/handle-parse-iframe?link=%2Fapps%2Ftest%2Fverify_email&token=testToken&username=testUser');\n          emailAdapter.sendVerificationEmail = () => Promise.resolve();\n          done();\n        };\n        const userController = new UserController(emailAdapter, 'test', {\n          verifyUserEmails: true\n        });\n        userController.sendVerificationEmail(user);\n      });","file":"UserController.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get own PII via API with object","suites":["Personally Identifiable Information"],"line":20,"updatePoint":{"line":20,"column":55,"index":612},"code":"  it('should be able to get own PII via API with object', done => {\n    const userObj = new (Parse.Object.extend(Parse.User))();\n    userObj.id = user.id;\n    return userObj.fetch().then(fetchedUser => {\n      expect(fetchedUser.get('email')).toBe(EMAIL);\n    }).then(done).catch(done.fail);\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get PII via API with object","suites":["Personally Identifiable Information"],"line":27,"updatePoint":{"line":27,"column":55,"index":910},"code":"  it('should not be able to get PII via API with object', done => {\n    return Parse.User.logOut().then(() => {\n      const userObj = new (Parse.Object.extend(Parse.User))();\n      userObj.id = user.id;\n      userObj.fetch().then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(undefined);\n        done();\n      }).catch(e => {\n        done.fail(JSON.stringify(e));\n      }).then(done).catch(done.fail);\n    });\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get PII via API with object using master key","suites":["Personally Identifiable Information"],"line":39,"updatePoint":{"line":39,"column":68,"index":1356},"code":"  it('should be able to get PII via API with object using master key', done => {\n    return Parse.User.logOut().then(() => {\n      const userObj = new (Parse.Object.extend(Parse.User))();\n      userObj.id = user.id;\n      userObj.fetch({\n        useMasterKey: true\n      }).then(fetchedUser => expect(fetchedUser.get('email')).toBe(EMAIL)).then(done).catch(done.fail);\n    });\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get own PII via API with Find","suites":["Personally Identifiable Information"],"line":48,"updatePoint":{"line":48,"column":53,"index":1724},"code":"  it('should be able to get own PII via API with Find', done => {\n    return new Parse.Query(Parse.User).first().then(fetchedUser => {\n      expect(fetchedUser.get('email')).toBe(EMAIL);\n      expect(fetchedUser.get('zip')).toBe(ZIP);\n      expect(fetchedUser.get('ssn')).toBe(SSN);\n      done();\n    });\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via API with Find","suites":["Personally Identifiable Information"],"line":56,"updatePoint":{"line":56,"column":42,"index":2024},"code":"  it('should not get PII via API with Find', done => {\n    return Parse.User.logOut().then(() => new Parse.Query(Parse.User).first().then(fetchedUser => {\n      expect(fetchedUser.get('email')).toBe(undefined);\n      expect(fetchedUser.get('zip')).toBe(ZIP);\n      expect(fetchedUser.get('ssn')).toBe(SSN);\n      done();\n    }));\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via API with Find using master key","suites":["Personally Identifiable Information"],"line":64,"updatePoint":{"line":64,"column":55,"index":2373},"code":"  it('should get PII via API with Find using master key', done => {\n    return Parse.User.logOut().then(() => new Parse.Query(Parse.User).first({\n      useMasterKey: true\n    }).then(fetchedUser => {\n      expect(fetchedUser.get('email')).toBe(EMAIL);\n      expect(fetchedUser.get('zip')).toBe(ZIP);\n      expect(fetchedUser.get('ssn')).toBe(SSN);\n      done();\n    }));\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get own PII via API with Get","suites":["Personally Identifiable Information"],"line":74,"updatePoint":{"line":74,"column":52,"index":2747},"code":"  it('should be able to get own PII via API with Get', done => {\n    return new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n      expect(fetchedUser.get('email')).toBe(EMAIL);\n      expect(fetchedUser.get('zip')).toBe(ZIP);\n      expect(fetchedUser.get('ssn')).toBe(SSN);\n      done();\n    });\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via API with Get","suites":["Personally Identifiable Information"],"line":82,"updatePoint":{"line":82,"column":41,"index":3051},"code":"  it('should not get PII via API with Get', done => {\n    return Parse.User.logOut().then(() => new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n      expect(fetchedUser.get('email')).toBe(undefined);\n      expect(fetchedUser.get('zip')).toBe(ZIP);\n      expect(fetchedUser.get('ssn')).toBe(SSN);\n      done();\n    }));\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via API with Get using master key","suites":["Personally Identifiable Information"],"line":90,"updatePoint":{"line":90,"column":54,"index":3404},"code":"  it('should get PII via API with Get using master key', done => {\n    return Parse.User.logOut().then(() => new Parse.Query(Parse.User).get(user.id, {\n      useMasterKey: true\n    }).then(fetchedUser => {\n      expect(fetchedUser.get('email')).toBe(EMAIL);\n      expect(fetchedUser.get('zip')).toBe(ZIP);\n      expect(fetchedUser.get('ssn')).toBe(SSN);\n      done();\n    }));\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via REST","suites":["Personally Identifiable Information"],"line":100,"updatePoint":{"line":100,"column":33,"index":3766},"code":"  it('should not get PII via REST', done => {\n    return request({\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Javascript-Key': 'test'\n      }\n    }).then(response => {\n      const result = response.data;\n      const fetchedUser = result.results[0];\n      expect(fetchedUser.zip).toBe(ZIP);\n      return expect(fetchedUser.email).toBe(undefined);\n    }).then(done).catch(done.fail);\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST with self credentials","suites":["Personally Identifiable Information"],"line":114,"updatePoint":{"line":114,"column":51,"index":4257},"code":"  it('should get PII via REST with self credentials', done => {\n    return request({\n      url: 'http://localhost:8378/1/classes/_User',\n      json: true,\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Javascript-Key': 'test',\n        'X-Parse-Session-Token': user.getSessionToken()\n      }\n    }).then(response => {\n      const result = response.data;\n      const fetchedUser = result.results[0];\n      expect(fetchedUser.zip).toBe(ZIP);\n      return expect(fetchedUser.email).toBe(EMAIL);\n    }).then(done).catch(done.fail);\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST using master key","suites":["Personally Identifiable Information"],"line":130,"updatePoint":{"line":130,"column":46,"index":4814},"code":"  it('should get PII via REST using master key', done => {\n    request({\n      url: 'http://localhost:8378/1/classes/_User',\n      json: true,\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Master-Key': 'test'\n      }\n    }).then(response => {\n      const result = response.data;\n      const fetchedUser = result.results[0];\n      expect(fetchedUser.zip).toBe(ZIP);\n      return expect(fetchedUser.email).toBe(EMAIL);\n    }).then(done).catch(done.fail);\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via REST by ID","suites":["Personally Identifiable Information"],"line":145,"updatePoint":{"line":145,"column":39,"index":5296},"code":"  it('should not get PII via REST by ID', done => {\n    request({\n      url: `http://localhost:8378/1/classes/_User/${user.id}`,\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Javascript-Key': 'test'\n      }\n    }).then(response => {\n      const fetchedUser = response.data;\n      expect(fetchedUser.zip).toBe(ZIP);\n      expect(fetchedUser.email).toBe(undefined);\n    }, e => done.fail(e)).then(() => done());\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST by ID  with self credentials","suites":["Personally Identifiable Information"],"line":158,"updatePoint":{"line":158,"column":58,"index":5761},"code":"  it('should get PII via REST by ID  with self credentials', done => {\n    request({\n      url: `http://localhost:8378/1/classes/_User/${user.id}`,\n      json: true,\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Javascript-Key': 'test',\n        'X-Parse-Session-Token': user.getSessionToken()\n      }\n    }).then(response => {\n      const result = response.data;\n      const fetchedUser = result;\n      expect(fetchedUser.zip).toBe(ZIP);\n      return expect(fetchedUser.email).toBe(EMAIL);\n    }).then(done).catch(done.fail);\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST by ID  with master key","suites":["Personally Identifiable Information"],"line":174,"updatePoint":{"line":174,"column":52,"index":6317},"code":"  it('should get PII via REST by ID  with master key', done => {\n    request({\n      url: `http://localhost:8378/1/classes/_User/${user.id}`,\n      json: true,\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Javascript-Key': 'test',\n        'X-Parse-Master-Key': 'test'\n      }\n    }).then(response => {\n      const result = response.data;\n      const fetchedUser = result;\n      expect(fetchedUser.zip).toBe(ZIP);\n      expect(fetchedUser.email).toBe(EMAIL);\n    }).then(done).catch(done.fail);\n  });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get own PII via API with object","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":196,"updatePoint":{"line":196,"column":57,"index":7049},"code":"    it('should be able to get own PII via API with object', done => {\n      const userObj = new (Parse.Object.extend(Parse.User))();\n      userObj.id = user.id;\n      return userObj.fetch().then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(EMAIL);\n        expect(fetchedUser.get('zip')).toBe(ZIP);\n        expect(fetchedUser.get('ssn')).toBe(SSN);\n        done();\n      }).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get PII via API with object","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":206,"updatePoint":{"line":206,"column":57,"index":7466},"code":"    it('should not be able to get PII via API with object', done => {\n      Parse.User.logOut().then(() => {\n        const userObj = new (Parse.Object.extend(Parse.User))();\n        userObj.id = user.id;\n        userObj.fetch().then(fetchedUser => {\n          expect(fetchedUser.get('email')).toBe(undefined);\n          expect(fetchedUser.get('zip')).toBe(undefined);\n          expect(fetchedUser.get('ssn')).toBe(undefined);\n        }).then(done).catch(done.fail);\n      });\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get PII via API with object using master key","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":217,"updatePoint":{"line":217,"column":70,"index":7963},"code":"    it('should be able to get PII via API with object using master key', done => {\n      Parse.User.logOut().then(() => {\n        const userObj = new (Parse.Object.extend(Parse.User))();\n        userObj.id = user.id;\n        userObj.fetch({\n          useMasterKey: true\n        }).then(fetchedUser => {\n          expect(fetchedUser.get('email')).toBe(EMAIL);\n          expect(fetchedUser.get('zip')).toBe(ZIP);\n          expect(fetchedUser.get('ssn')).toBe(SSN);\n        }, done.fail).then(done).catch(done.fail);\n      });\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get own PII via API with Find","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":230,"updatePoint":{"line":230,"column":55,"index":8480},"code":"    it('should be able to get own PII via API with Find', done => {\n      new Parse.Query(Parse.User).first().then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(EMAIL);\n        expect(fetchedUser.get('zip')).toBe(ZIP);\n        expect(fetchedUser.get('ssn')).toBe(SSN);\n        done();\n      });\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via API with Find","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":238,"updatePoint":{"line":238,"column":44,"index":8789},"code":"    it('should not get PII via API with Find', done => {\n      Parse.User.logOut().then(() => new Parse.Query(Parse.User).first().then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(undefined);\n        expect(fetchedUser.get('zip')).toBe(undefined);\n        expect(fetchedUser.get('ssn')).toBe(undefined);\n        done();\n      }));\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via API with Find using master key","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":246,"updatePoint":{"line":246,"column":57,"index":9159},"code":"    it('should get PII via API with Find using master key', done => {\n      Parse.User.logOut().then(() => new Parse.Query(Parse.User).first({\n        useMasterKey: true\n      }).then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(EMAIL);\n        expect(fetchedUser.get('zip')).toBe(ZIP);\n        expect(fetchedUser.get('ssn')).toBe(SSN);\n        done();\n      }));\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get own PII via API with Get","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":256,"updatePoint":{"line":256,"column":54,"index":9546},"code":"    it('should be able to get own PII via API with Get', done => {\n      new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(EMAIL);\n        expect(fetchedUser.get('zip')).toBe(ZIP);\n        expect(fetchedUser.get('ssn')).toBe(SSN);\n        done();\n      });\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via API with Get","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":264,"updatePoint":{"line":264,"column":43,"index":9859},"code":"    it('should not get PII via API with Get', done => {\n      Parse.User.logOut().then(() => new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(undefined);\n        expect(fetchedUser.get('zip')).toBe(undefined);\n        expect(fetchedUser.get('ssn')).toBe(undefined);\n        done();\n      }));\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via API with Get using master key","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":272,"updatePoint":{"line":272,"column":56,"index":10233},"code":"    it('should get PII via API with Get using master key', done => {\n      Parse.User.logOut().then(() => new Parse.Query(Parse.User).get(user.id, {\n        useMasterKey: true\n      }).then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(EMAIL);\n        expect(fetchedUser.get('zip')).toBe(ZIP);\n        expect(fetchedUser.get('ssn')).toBe(SSN);\n        done();\n      }));\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via REST","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":282,"updatePoint":{"line":282,"column":35,"index":10608},"code":"    it('should not get PII via REST', done => {\n      request({\n        url: 'http://localhost:8378/1/classes/_User',\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Javascript-Key': 'test'\n        }\n      }).then(response => {\n        const result = response.data;\n        const fetchedUser = result.results[0];\n        expect(fetchedUser.zip).toBe(undefined);\n        expect(fetchedUser.ssn).toBe(undefined);\n        expect(fetchedUser.email).toBe(undefined);\n      }, done.fail).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST with self credentials","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":297,"updatePoint":{"line":297,"column":53,"index":11179},"code":"    it('should get PII via REST with self credentials', done => {\n      request({\n        url: 'http://localhost:8378/1/classes/_User',\n        json: true,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Javascript-Key': 'test',\n          'X-Parse-Session-Token': user.getSessionToken()\n        }\n      }).then(response => {\n        const result = response.data;\n        const fetchedUser = result.results[0];\n        expect(fetchedUser.zip).toBe(ZIP);\n        expect(fetchedUser.email).toBe(EMAIL);\n        return expect(fetchedUser.ssn).toBe(SSN);\n      }).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST using master key","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":314,"updatePoint":{"line":314,"column":48,"index":11804},"code":"    it('should get PII via REST using master key', done => {\n      request({\n        url: 'http://localhost:8378/1/classes/_User',\n        json: true,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Master-Key': 'test'\n        }\n      }).then(response => {\n        const result = response.data;\n        const fetchedUser = result.results[0];\n        expect(fetchedUser.zip).toBe(ZIP);\n        expect(fetchedUser.email).toBe(EMAIL);\n        expect(fetchedUser.ssn).toBe(SSN);\n      }, e => done.fail(e.data)).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via REST by ID","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":330,"updatePoint":{"line":330,"column":41,"index":12376},"code":"    it('should not get PII via REST by ID', done => {\n      request({\n        url: `http://localhost:8378/1/classes/_User/${user.id}`,\n        json: true,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Javascript-Key': 'test'\n        }\n      }).then(response => {\n        const fetchedUser = response.data;\n        expect(fetchedUser.zip).toBe(undefined);\n        expect(fetchedUser.email).toBe(undefined);\n      }, e => done.fail(e.data)).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST by ID  with self credentials","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":344,"updatePoint":{"line":344,"column":60,"index":12907},"code":"    it('should get PII via REST by ID  with self credentials', done => {\n      request({\n        url: `http://localhost:8378/1/classes/_User/${user.id}`,\n        json: true,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Javascript-Key': 'test',\n          'X-Parse-Session-Token': user.getSessionToken()\n        }\n      }).then(response => {\n        const fetchedUser = response.data;\n        expect(fetchedUser.zip).toBe(ZIP);\n        expect(fetchedUser.email).toBe(EMAIL);\n      }, () => {}).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST by ID  with master key","suites":["Personally Identifiable Information","with deprecated configured sensitive fields"],"line":359,"updatePoint":{"line":359,"column":54,"index":13467},"code":"    it('should get PII via REST by ID  with master key', done => {\n      request({\n        url: `http://localhost:8378/1/classes/_User/${user.id}`,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Javascript-Key': 'test',\n          'X-Parse-Master-Key': 'test'\n        }\n      }).then(response => {\n        const result = response.data;\n        const fetchedUser = result;\n        expect(fetchedUser.zip).toBe(ZIP);\n        expect(fetchedUser.email).toBe(EMAIL);\n      }, e => done.fail(e.data)).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"privileged user should not be able to get user PII via API with object","suites":["Personally Identifiable Information","with deprecated configured sensitive fields","with privileged user no CLP"],"line":399,"updatePoint":{"line":399,"column":80,"index":15064},"code":"      it('privileged user should not be able to get user PII via API with object', done => {\n        const userObj = new (Parse.Object.extend(Parse.User))();\n        userObj.id = user.id;\n        userObj.fetch().then(fetchedUser => {\n          expect(fetchedUser.get('email')).toBe(undefined);\n        }).then(done).catch(done.fail);\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"privileged user should not be able to get user PII via API with Find","suites":["Personally Identifiable Information","with deprecated configured sensitive fields","with privileged user no CLP"],"line":406,"updatePoint":{"line":406,"column":78,"index":15406},"code":"      it('privileged user should not be able to get user PII via API with Find', done => {\n        new Parse.Query(Parse.User).equalTo('objectId', user.id).find().then(fetchedUser => {\n          fetchedUser = fetchedUser[0];\n          expect(fetchedUser.get('email')).toBe(undefined);\n          expect(fetchedUser.get('zip')).toBe(undefined);\n          expect(fetchedUser.get('ssn')).toBe(undefined);\n          done();\n        }).catch(done.fail);\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"privileged user should not be able to get user PII via API with Get","suites":["Personally Identifiable Information","with deprecated configured sensitive fields","with privileged user no CLP"],"line":415,"updatePoint":{"line":415,"column":77,"index":15863},"code":"      it('privileged user should not be able to get user PII via API with Get', done => {\n        new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n          expect(fetchedUser.get('email')).toBe(undefined);\n          expect(fetchedUser.get('zip')).toBe(undefined);\n          expect(fetchedUser.get('ssn')).toBe(undefined);\n          done();\n        }).catch(done.fail);\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"privileged user should not get user PII via REST by ID","suites":["Personally Identifiable Information","with deprecated configured sensitive fields","with privileged user no CLP"],"line":423,"updatePoint":{"line":423,"column":64,"index":16244},"code":"      it('privileged user should not get user PII via REST by ID', done => {\n        request({\n          url: `http://localhost:8378/1/classes/_User/${user.id}`,\n          json: true,\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Javascript-Key': 'test',\n            'X-Parse-Session-Token': adminUser.getSessionToken()\n          }\n        }).then(response => {\n          const result = response.data;\n          const fetchedUser = result;\n          expect(fetchedUser.zip).toBe(undefined);\n          expect(fetchedUser.email).toBe(undefined);\n        }).then(() => done()).catch(done.fail);\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with object","suites":["Personally Identifiable Information","with deprecated configured sensitive fields","with public read ACL"],"line":451,"updatePoint":{"line":451,"column":64,"index":17240},"code":"      it('should not be able to get user PII via API with object', done => {\n        Parse.User.logOut().then(() => {\n          const userObj = new (Parse.Object.extend(Parse.User))();\n          userObj.id = user.id;\n          userObj.fetch().then(fetchedUser => {\n            expect(fetchedUser.get('email')).toBe(undefined);\n          }).then(done).catch(done.fail);\n        });\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with Find","suites":["Personally Identifiable Information","with deprecated configured sensitive fields","with public read ACL"],"line":460,"updatePoint":{"line":460,"column":62,"index":17629},"code":"      it('should not be able to get user PII via API with Find', done => {\n        Parse.User.logOut().then(() => new Parse.Query(Parse.User).equalTo('objectId', user.id).find().then(fetchedUser => {\n          fetchedUser = fetchedUser[0];\n          expect(fetchedUser.get('email')).toBe(undefined);\n          expect(fetchedUser.get('zip')).toBe(undefined);\n          expect(fetchedUser.get('ssn')).toBe(undefined);\n          done();\n        }).catch(done.fail));\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with Get","suites":["Personally Identifiable Information","with deprecated configured sensitive fields","with public read ACL"],"line":469,"updatePoint":{"line":469,"column":61,"index":18102},"code":"      it('should not be able to get user PII via API with Get', done => {\n        Parse.User.logOut().then(() => new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n          expect(fetchedUser.get('email')).toBe(undefined);\n          expect(fetchedUser.get('zip')).toBe(undefined);\n          expect(fetchedUser.get('ssn')).toBe(undefined);\n          done();\n        }).catch(done.fail));\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get user PII via REST by ID","suites":["Personally Identifiable Information","with deprecated configured sensitive fields","with public read ACL"],"line":477,"updatePoint":{"line":477,"column":48,"index":18499},"code":"      it('should not get user PII via REST by ID', done => {\n        request({\n          url: `http://localhost:8378/1/classes/_User/${user.id}`,\n          json: true,\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Javascript-Key': 'test'\n          }\n        }).then(response => {\n          const result = response.data;\n          const fetchedUser = result;\n          expect(fetchedUser.zip).toBe(undefined);\n          expect(fetchedUser.email).toBe(undefined);\n        }).then(() => done()).catch(done.fail);\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with object","suites":["Personally Identifiable Information","with deprecated configured sensitive fields","with public read ACL","with another authenticated user"],"line":499,"updatePoint":{"line":499,"column":66,"index":19491},"code":"        it('should not be able to get user PII via API with object', done => {\n          const userObj = new (Parse.Object.extend(Parse.User))();\n          userObj.id = user.id;\n          userObj.fetch().then(fetchedUser => {\n            expect(fetchedUser.get('email')).toBe(undefined);\n          }).then(done).catch(done.fail);\n        });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with Find","suites":["Personally Identifiable Information","with deprecated configured sensitive fields","with public read ACL","with another authenticated user"],"line":506,"updatePoint":{"line":506,"column":64,"index":19831},"code":"        it('should not be able to get user PII via API with Find', done => {\n          new Parse.Query(Parse.User).equalTo('objectId', user.id).find().then(fetchedUser => {\n            fetchedUser = fetchedUser[0];\n            expect(fetchedUser.get('email')).toBe(undefined);\n            expect(fetchedUser.get('zip')).toBe(undefined);\n            expect(fetchedUser.get('ssn')).toBe(undefined);\n            done();\n          }).catch(done.fail);\n        });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with Get","suites":["Personally Identifiable Information","with deprecated configured sensitive fields","with public read ACL","with another authenticated user"],"line":515,"updatePoint":{"line":515,"column":63,"index":20290},"code":"        it('should not be able to get user PII via API with Get', done => {\n          new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n            expect(fetchedUser.get('email')).toBe(undefined);\n            expect(fetchedUser.get('zip')).toBe(undefined);\n            expect(fetchedUser.get('ssn')).toBe(undefined);\n            done();\n          }).catch(done.fail);\n        });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get own PII via API with object","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":537,"updatePoint":{"line":537,"column":57,"index":20983},"code":"    it('should be able to get own PII via API with object', done => {\n      const userObj = new (Parse.Object.extend(Parse.User))();\n      userObj.id = user.id;\n      userObj.fetch().then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(EMAIL);\n        expect(fetchedUser.get('zip')).toBe(ZIP);\n        expect(fetchedUser.get('ssn')).toBe(SSN);\n        done();\n      }, done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get PII via API with object","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":547,"updatePoint":{"line":547,"column":57,"index":21387},"code":"    it('should not be able to get PII via API with object', done => {\n      Parse.User.logOut().then(() => {\n        const userObj = new (Parse.Object.extend(Parse.User))();\n        userObj.id = user.id;\n        userObj.fetch().then(fetchedUser => {\n          expect(fetchedUser.get('email')).toBe(undefined);\n          expect(fetchedUser.get('zip')).toBe(undefined);\n          expect(fetchedUser.get('ssn')).toBe(undefined);\n        }).then(done).catch(done.fail);\n      });\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get PII via API with object using master key","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":558,"updatePoint":{"line":558,"column":70,"index":21884},"code":"    it('should be able to get PII via API with object using master key', done => {\n      Parse.User.logOut().then(() => {\n        const userObj = new (Parse.Object.extend(Parse.User))();\n        userObj.id = user.id;\n        userObj.fetch({\n          useMasterKey: true\n        }).then(fetchedUser => {\n          expect(fetchedUser.get('email')).toBe(EMAIL);\n          expect(fetchedUser.get('zip')).toBe(ZIP);\n          expect(fetchedUser.get('ssn')).toBe(SSN);\n        }, done.fail).then(done).catch(done.fail);\n      });\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get own PII via API with Find","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":571,"updatePoint":{"line":571,"column":55,"index":22401},"code":"    it('should be able to get own PII via API with Find', done => {\n      new Parse.Query(Parse.User).first().then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(EMAIL);\n        expect(fetchedUser.get('zip')).toBe(ZIP);\n        expect(fetchedUser.get('ssn')).toBe(SSN);\n        done();\n      });\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via API with Find","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":579,"updatePoint":{"line":579,"column":44,"index":22710},"code":"    it('should not get PII via API with Find', done => {\n      Parse.User.logOut().then(() => new Parse.Query(Parse.User).first().then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(undefined);\n        expect(fetchedUser.get('zip')).toBe(undefined);\n        expect(fetchedUser.get('ssn')).toBe(undefined);\n        done();\n      }));\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via API with Find using master key","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":587,"updatePoint":{"line":587,"column":57,"index":23080},"code":"    it('should get PII via API with Find using master key', done => {\n      Parse.User.logOut().then(() => new Parse.Query(Parse.User).first({\n        useMasterKey: true\n      }).then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(EMAIL);\n        expect(fetchedUser.get('zip')).toBe(ZIP);\n        expect(fetchedUser.get('ssn')).toBe(SSN);\n        done();\n      }));\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get own PII via API with Get","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":597,"updatePoint":{"line":597,"column":54,"index":23467},"code":"    it('should be able to get own PII via API with Get', done => {\n      new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(EMAIL);\n        expect(fetchedUser.get('zip')).toBe(ZIP);\n        expect(fetchedUser.get('ssn')).toBe(SSN);\n        done();\n      });\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via API with Get","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":605,"updatePoint":{"line":605,"column":43,"index":23780},"code":"    it('should not get PII via API with Get', done => {\n      Parse.User.logOut().then(() => new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(undefined);\n        expect(fetchedUser.get('zip')).toBe(undefined);\n        expect(fetchedUser.get('ssn')).toBe(undefined);\n        done();\n      }));\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via API with Get using master key","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":613,"updatePoint":{"line":613,"column":56,"index":24154},"code":"    it('should get PII via API with Get using master key', done => {\n      Parse.User.logOut().then(() => new Parse.Query(Parse.User).get(user.id, {\n        useMasterKey: true\n      }).then(fetchedUser => {\n        expect(fetchedUser.get('email')).toBe(EMAIL);\n        expect(fetchedUser.get('zip')).toBe(ZIP);\n        expect(fetchedUser.get('ssn')).toBe(SSN);\n        done();\n      }));\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via REST","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":623,"updatePoint":{"line":623,"column":35,"index":24529},"code":"    it('should not get PII via REST', done => {\n      request({\n        url: 'http://localhost:8378/1/classes/_User',\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Javascript-Key': 'test'\n        }\n      }).then(response => {\n        const result = response.data;\n        const fetchedUser = result.results[0];\n        expect(fetchedUser.zip).toBe(undefined);\n        expect(fetchedUser.ssn).toBe(undefined);\n        expect(fetchedUser.email).toBe(undefined);\n      }, done.fail).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST with self credentials","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":638,"updatePoint":{"line":638,"column":53,"index":25100},"code":"    it('should get PII via REST with self credentials', done => {\n      request({\n        url: 'http://localhost:8378/1/classes/_User',\n        json: true,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Javascript-Key': 'test',\n          'X-Parse-Session-Token': user.getSessionToken()\n        }\n      }).then(response => {\n        const result = response.data;\n        const fetchedUser = result.results[0];\n        expect(fetchedUser.zip).toBe(ZIP);\n        expect(fetchedUser.email).toBe(EMAIL);\n        expect(fetchedUser.ssn).toBe(SSN);\n      }, () => {}).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST using master key","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":655,"updatePoint":{"line":655,"column":48,"index":25728},"code":"    it('should get PII via REST using master key', done => {\n      request({\n        url: 'http://localhost:8378/1/classes/_User',\n        json: true,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Master-Key': 'test'\n        }\n      }).then(response => {\n        const result = response.data;\n        const fetchedUser = result.results[0];\n        expect(fetchedUser.zip).toBe(ZIP);\n        expect(fetchedUser.email).toBe(EMAIL);\n        expect(fetchedUser.ssn).toBe(SSN);\n      }, e => done.fail(e.data)).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get PII via REST by ID","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":671,"updatePoint":{"line":671,"column":41,"index":26300},"code":"    it('should not get PII via REST by ID', done => {\n      request({\n        url: `http://localhost:8378/1/classes/_User/${user.id}`,\n        json: true,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Javascript-Key': 'test'\n        }\n      }).then(response => {\n        const fetchedUser = response.data;\n        expect(fetchedUser.zip).toBe(undefined);\n        expect(fetchedUser.email).toBe(undefined);\n      }, e => done.fail(e.data)).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST by ID  with self credentials","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":685,"updatePoint":{"line":685,"column":60,"index":26831},"code":"    it('should get PII via REST by ID  with self credentials', done => {\n      request({\n        url: `http://localhost:8378/1/classes/_User/${user.id}`,\n        json: true,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Javascript-Key': 'test',\n          'X-Parse-Session-Token': user.getSessionToken()\n        }\n      }).then(response => {\n        const fetchedUser = response.data;\n        expect(fetchedUser.zip).toBe(ZIP);\n        expect(fetchedUser.email).toBe(EMAIL);\n      }, () => {}).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should get PII via REST by ID  with master key","suites":["Personally Identifiable Information","with configured sensitive fields via CLP"],"line":700,"updatePoint":{"line":700,"column":54,"index":27391},"code":"    it('should get PII via REST by ID  with master key', done => {\n      request({\n        url: `http://localhost:8378/1/classes/_User/${user.id}`,\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-Javascript-Key': 'test',\n          'X-Parse-Master-Key': 'test'\n        }\n      }).then(response => {\n        const result = response.data;\n        const fetchedUser = result;\n        expect(fetchedUser.zip).toBe(ZIP);\n        expect(fetchedUser.email).toBe(EMAIL);\n      }, e => done.fail(e.data)).then(done).catch(done.fail);\n    });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"privileged user should be able to get user PII via API with object","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with privileged user CLP"],"line":740,"updatePoint":{"line":740,"column":76,"index":28981},"code":"      it('privileged user should be able to get user PII via API with object', done => {\n        const userObj = new (Parse.Object.extend(Parse.User))();\n        userObj.id = user.id;\n        userObj.fetch().then(fetchedUser => {\n          expect(fetchedUser.get('email')).toBe(EMAIL);\n        }).then(done).catch(done.fail);\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"privileged user should be able to get user PII via API with Find","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with privileged user CLP"],"line":747,"updatePoint":{"line":747,"column":74,"index":29315},"code":"      it('privileged user should be able to get user PII via API with Find', done => {\n        new Parse.Query(Parse.User).equalTo('objectId', user.id).find().then(fetchedUser => {\n          fetchedUser = fetchedUser[0];\n          expect(fetchedUser.get('email')).toBe(EMAIL);\n          expect(fetchedUser.get('zip')).toBe(ZIP);\n          expect(fetchedUser.get('ssn')).toBe(SSN);\n          done();\n        }).catch(done.fail);\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"privileged user should be able to get user PII via API with Get","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with privileged user CLP"],"line":756,"updatePoint":{"line":756,"column":73,"index":29752},"code":"      it('privileged user should be able to get user PII via API with Get', done => {\n        new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n          expect(fetchedUser.get('email')).toBe(EMAIL);\n          expect(fetchedUser.get('zip')).toBe(ZIP);\n          expect(fetchedUser.get('ssn')).toBe(SSN);\n          done();\n        }).catch(done.fail);\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"privileged user should get user PII via REST by ID","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with privileged user CLP"],"line":764,"updatePoint":{"line":764,"column":60,"index":30113},"code":"      it('privileged user should get user PII via REST by ID', done => {\n        request({\n          url: `http://localhost:8378/1/classes/_User/${user.id}`,\n          json: true,\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Javascript-Key': 'test',\n            'X-Parse-Session-Token': adminUser.getSessionToken()\n          }\n        }).then(response => {\n          const result = response.data;\n          const fetchedUser = result;\n          expect(fetchedUser.zip).toBe(ZIP);\n          expect(fetchedUser.email).toBe(EMAIL);\n        }).then(done).catch(done.fail);\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with object","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with public read ACL"],"line":792,"updatePoint":{"line":792,"column":64,"index":31091},"code":"      it('should not be able to get user PII via API with object', done => {\n        Parse.User.logOut().then(() => {\n          const userObj = new (Parse.Object.extend(Parse.User))();\n          userObj.id = user.id;\n          userObj.fetch().then(fetchedUser => {\n            expect(fetchedUser.get('email')).toBe(undefined);\n          }).then(done).catch(done.fail);\n        });\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with Find","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with public read ACL"],"line":801,"updatePoint":{"line":801,"column":62,"index":31480},"code":"      it('should not be able to get user PII via API with Find', done => {\n        Parse.User.logOut().then(() => new Parse.Query(Parse.User).equalTo('objectId', user.id).find().then(fetchedUser => {\n          fetchedUser = fetchedUser[0];\n          expect(fetchedUser.get('email')).toBe(undefined);\n          expect(fetchedUser.get('zip')).toBe(undefined);\n          expect(fetchedUser.get('ssn')).toBe(undefined);\n          done();\n        }).catch(done.fail));\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with Get","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with public read ACL"],"line":810,"updatePoint":{"line":810,"column":61,"index":31953},"code":"      it('should not be able to get user PII via API with Get', done => {\n        Parse.User.logOut().then(() => new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n          expect(fetchedUser.get('email')).toBe(undefined);\n          expect(fetchedUser.get('zip')).toBe(undefined);\n          expect(fetchedUser.get('ssn')).toBe(undefined);\n          done();\n        }).catch(done.fail));\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not get user PII via REST by ID","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with public read ACL"],"line":818,"updatePoint":{"line":818,"column":48,"index":32350},"code":"      it('should not get user PII via REST by ID', done => {\n        request({\n          url: `http://localhost:8378/1/classes/_User/${user.id}`,\n          json: true,\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Javascript-Key': 'test'\n          }\n        }).then(response => {\n          const result = response.data;\n          const fetchedUser = result;\n          expect(fetchedUser.zip).toBe(undefined);\n          expect(fetchedUser.email).toBe(undefined);\n        }).then(() => done()).catch(done.fail);\n      });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with object","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with public read ACL","with another authenticated user"],"line":841,"updatePoint":{"line":841,"column":66,"index":33482},"code":"        it('should not be able to get user PII via API with object', done => {\n          const userObj = new (Parse.Object.extend(Parse.User))();\n          userObj.id = user.id;\n          userObj.fetch().then(fetchedUser => {\n            expect(fetchedUser.get('email')).toBe(undefined);\n          }).then(done).catch(done.fail);\n        });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with Find","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with public read ACL","with another authenticated user"],"line":848,"updatePoint":{"line":848,"column":64,"index":33822},"code":"        it('should not be able to get user PII via API with Find', done => {\n          new Parse.Query(Parse.User).equalTo('objectId', user.id).find().then(fetchedUser => {\n            fetchedUser = fetchedUser[0];\n            expect(fetchedUser.get('email')).toBe(undefined);\n            expect(fetchedUser.get('zip')).toBe(undefined);\n            expect(fetchedUser.get('ssn')).toBe(undefined);\n            done();\n          }).catch(done.fail);\n        });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with Find without constraints","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with public read ACL","with another authenticated user"],"line":857,"updatePoint":{"line":857,"column":84,"index":34302},"code":"        it('should not be able to get user PII via API with Find without constraints', done => {\n          new Parse.Query(Parse.User).find().then(fetchedUsers => {\n            const notCurrentUser = fetchedUsers.find(u => u.id !== anotherUser.id);\n            expect(notCurrentUser.get('email')).toBe(undefined);\n            expect(notCurrentUser.get('zip')).toBe(undefined);\n            expect(notCurrentUser.get('ssn')).toBe(undefined);\n            done();\n          }).catch(done.fail);\n        });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should be able to get own PII via API with Find without constraints","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with public read ACL","with another authenticated user"],"line":866,"updatePoint":{"line":866,"column":79,"index":34800},"code":"        it('should be able to get own PII via API with Find without constraints', done => {\n          new Parse.Query(Parse.User).find().then(fetchedUsers => {\n            const currentUser = fetchedUsers.find(u => u.id === anotherUser.id);\n            expect(currentUser.get('email')).toBe(ANOTHER_EMAIL);\n            expect(currentUser.get('zip')).toBe(ZIP);\n            expect(currentUser.get('ssn')).toBe(SSN);\n            done();\n          }).catch(done.fail);\n        });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should not be able to get user PII via API with Get","suites":["Personally Identifiable Information","with configured sensitive fields via CLP","with public read ACL","with another authenticated user"],"line":875,"updatePoint":{"line":875,"column":63,"index":35262},"code":"        it('should not be able to get user PII via API with Get', done => {\n          new Parse.Query(Parse.User).get(user.id).then(fetchedUser => {\n            expect(fetchedUser.get('email')).toBe(undefined);\n            expect(fetchedUser.get('zip')).toBe(undefined);\n            expect(fetchedUser.get('ssn')).toBe(undefined);\n            done();\n          }).catch(done.fail);\n        });","file":"UserPII.spec.js","skipped":false,"dir":"spec"},{"name":"should set the custom pages","suites":["Custom Pages, Email Verification, Password Reset"],"line":7,"updatePoint":{"line":7,"column":33,"index":288},"code":"  it('should set the custom pages', done => {\n    reconfigureServer({\n      appName: 'unused',\n      customPages: {\n        invalidLink: 'myInvalidLink',\n        verifyEmailSuccess: 'myVerifyEmailSuccess',\n        choosePassword: 'myChoosePassword',\n        passwordResetSuccess: 'myPasswordResetSuccess',\n        parseFrameURL: 'http://example.com/handle-parse-iframe'\n      },\n      publicServerURL: 'https://my.public.server.com/1'\n    }).then(() => {\n      const config = Config.get('test');\n      expect(config.invalidLinkURL).toEqual('myInvalidLink');\n      expect(config.verifyEmailSuccessURL).toEqual('myVerifyEmailSuccess');\n      expect(config.choosePasswordURL).toEqual('myChoosePassword');\n      expect(config.passwordResetSuccessURL).toEqual('myPasswordResetSuccess');\n      expect(config.parseFrameURL).toEqual('http://example.com/handle-parse-iframe');\n      expect(config.verifyEmailURL).toEqual('https://my.public.server.com/1/apps/test/verify_email');\n      expect(config.requestResetPasswordURL).toEqual('https://my.public.server.com/1/apps/test/request_password_reset');\n      done();\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"sends verification email if email verification is enabled","suites":["Custom Pages, Email Verification, Password Reset"],"line":30,"updatePoint":{"line":30,"column":63,"index":1437},"code":"  it('sends verification email if email verification is enabled', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(async () => {\n      spyOn(emailAdapter, 'sendVerificationEmail');\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.setEmail('testIfEnabled@parse.com');\n      await user.signUp();\n      expect(emailAdapter.sendVerificationEmail).toHaveBeenCalled();\n      user.fetch().then(() => {\n        expect(user.get('emailVerified')).toEqual(false);\n        done();\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"does not send verification email when verification is enabled and email is not set","suites":["Custom Pages, Email Verification, Password Reset"],"line":55,"updatePoint":{"line":55,"column":88,"index":2336},"code":"  it('does not send verification email when verification is enabled and email is not set', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(async () => {\n      spyOn(emailAdapter, 'sendVerificationEmail');\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      await user.signUp();\n      expect(emailAdapter.sendVerificationEmail).not.toHaveBeenCalled();\n      user.fetch().then(() => {\n        expect(user.get('emailVerified')).toEqual(undefined);\n        done();\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"does send a validation email when updating the email","suites":["Custom Pages, Email Verification, Password Reset"],"line":79,"updatePoint":{"line":79,"column":58,"index":3165},"code":"  it('does send a validation email when updating the email', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(async () => {\n      spyOn(emailAdapter, 'sendVerificationEmail');\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      await user.signUp();\n      expect(emailAdapter.sendVerificationEmail).not.toHaveBeenCalled();\n      user.fetch().then(user => {\n        user.set('email', 'testWhenUpdating@parse.com');\n        return user.save();\n      }).then(user => {\n        return user.fetch();\n      }).then(() => {\n        expect(user.get('emailVerified')).toEqual(false);\n        // Wait as on update email, we need to fetch the username\n        setTimeout(function () {\n          expect(emailAdapter.sendVerificationEmail).toHaveBeenCalled();\n          done();\n        }, 200);\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"does send a validation email with valid verification link when updating the email","suites":["Custom Pages, Email Verification, Password Reset"],"line":112,"updatePoint":{"line":112,"column":87,"index":4372},"code":"  it('does send a validation email with valid verification link when updating the email', async done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    await reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    spyOn(emailAdapter, 'sendVerificationEmail').and.callFake(options => {\n      expect(options.link).not.toBeNull();\n      expect(options.link).not.toMatch(/token=undefined/);\n      Promise.resolve();\n    });\n    const user = new Parse.User();\n    user.setPassword('asdf');\n    user.setUsername('zxcv');\n    await user.signUp();\n    expect(emailAdapter.sendVerificationEmail).not.toHaveBeenCalled();\n    await user.fetch();\n    user.set('email', 'testValidLinkWhenUpdating@parse.com');\n    await user.save();\n    await user.fetch();\n    expect(user.get('emailVerified')).toEqual(false);\n    // Wait as on update email, we need to fetch the username\n    setTimeout(function () {\n      expect(emailAdapter.sendVerificationEmail).toHaveBeenCalled();\n      done();\n    }, 200);\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"does send with a simple adapter","suites":["Custom Pages, Email Verification, Password Reset"],"line":145,"updatePoint":{"line":145,"column":37,"index":5568},"code":"  it('does send with a simple adapter', done => {\n    let calls = 0;\n    const emailAdapter = {\n      sendMail: function (options) {\n        expect(options.to).toBe('testSendSimpleAdapter@parse.com');\n        if (calls == 0) {\n          expect(options.subject).toEqual('Please verify your e-mail for My Cool App');\n          expect(options.text.match(/verify_email/)).not.toBe(null);\n        } else if (calls == 1) {\n          expect(options.subject).toEqual('Password Reset for My Cool App');\n          expect(options.text.match(/request_password_reset/)).not.toBe(null);\n        }\n        calls++;\n        return Promise.resolve();\n      }\n    };\n    reconfigureServer({\n      appName: 'My Cool App',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(async () => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.set('email', 'testSendSimpleAdapter@parse.com');\n      await user.signUp();\n      expect(calls).toBe(1);\n      user.fetch().then(user => {\n        return user.save();\n      }).then(() => {\n        return Parse.User.requestPasswordReset('testSendSimpleAdapter@parse.com').catch(() => {\n          fail('Should not fail requesting a password');\n          done();\n        });\n      }).then(() => {\n        expect(calls).toBe(2);\n        done();\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"prevents user from login if email is not verified but preventLoginWithUnverifiedEmail is set to true","suites":["Custom Pages, Email Verification, Password Reset"],"line":186,"updatePoint":{"line":186,"column":106,"index":7056},"code":"  it('prevents user from login if email is not verified but preventLoginWithUnverifiedEmail is set to true', done => {\n    reconfigureServer({\n      appName: 'test',\n      publicServerURL: 'http://localhost:1337/1',\n      verifyUserEmails: true,\n      preventLoginWithUnverifiedEmail: true,\n      emailAdapter: MockEmailAdapterWithOptions({\n        fromAddress: 'parse@example.com',\n        apiKey: 'k',\n        domain: 'd'\n      })\n    }).then(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.set('email', 'testInvalidConfig@parse.com');\n      user.signUp(null).then(user => {\n        expect(user.getSessionToken()).toBe(undefined);\n        return Parse.User.logIn('zxcv', 'asdf');\n      }).then(() => {\n        fail('login should have failed');\n        done();\n      }, error => {\n        expect(error.message).toEqual('User email is not verified.');\n        done();\n      });\n    }).catch(error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"allows user to login only after user clicks on the link to confirm email address if preventLoginWithUnverifiedEmail is set to true","suites":["Custom Pages, Email Verification, Password Reset"],"line":217,"updatePoint":{"line":217,"column":136,"index":8123},"code":"  it('allows user to login only after user clicks on the link to confirm email address if preventLoginWithUnverifiedEmail is set to true', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      preventLoginWithUnverifiedEmail: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setPassword('other-password');\n      user.setUsername('user');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      expect(sendEmailOptions).not.toBeUndefined();\n      request({\n        url: sendEmailOptions.link,\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/verify_email_success.html?username=user');\n        user.fetch().then(() => {\n          expect(user.get('emailVerified')).toEqual(true);\n          Parse.User.logIn('user', 'other-password').then(user => {\n            expect(typeof user).toBe('object');\n            expect(user.get('emailVerified')).toBe(true);\n            done();\n          }, () => {\n            fail('login should have succeeded');\n            done();\n          });\n        }, err => {\n          jfail(err);\n          fail('this should not fail');\n          done();\n        }).catch(err => {\n          jfail(err);\n          done();\n        });\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"allows user to login if email is not verified but preventLoginWithUnverifiedEmail is set to false","suites":["Custom Pages, Email Verification, Password Reset"],"line":267,"updatePoint":{"line":267,"column":103,"index":9834},"code":"  it('allows user to login if email is not verified but preventLoginWithUnverifiedEmail is set to false', done => {\n    reconfigureServer({\n      appName: 'test',\n      publicServerURL: 'http://localhost:1337/1',\n      verifyUserEmails: true,\n      preventLoginWithUnverifiedEmail: false,\n      emailAdapter: MockEmailAdapterWithOptions({\n        fromAddress: 'parse@example.com',\n        apiKey: 'k',\n        domain: 'd'\n      })\n    }).then(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.set('email', 'testInvalidConfig@parse.com');\n      user.signUp(null).then(() => Parse.User.logIn('zxcv', 'asdf')).then(user => {\n        expect(typeof user).toBe('object');\n        expect(user.get('emailVerified')).toBe(false);\n        done();\n      }, () => {\n        fail('login should have succeeded');\n        done();\n      });\n    }).catch(error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"fails if you include an emailAdapter, set a publicServerURL, but have no appName and send a password reset email","suites":["Custom Pages, Email Verification, Password Reset"],"line":296,"updatePoint":{"line":296,"column":118,"index":10831},"code":"  it('fails if you include an emailAdapter, set a publicServerURL, but have no appName and send a password reset email', done => {\n    reconfigureServer({\n      appName: undefined,\n      publicServerURL: 'http://localhost:1337/1',\n      emailAdapter: MockEmailAdapterWithOptions({\n        fromAddress: 'parse@example.com',\n        apiKey: 'k',\n        domain: 'd'\n      })\n    }).then(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.set('email', 'testInvalidConfig@parse.com');\n      user.signUp(null).then(() => Parse.User.requestPasswordReset('testInvalidConfig@parse.com')).then(() => {\n        fail('sending password reset email should not have succeeded');\n        done();\n      }, error => {\n        expect(error.message).toEqual('An appName, publicServerURL, and emailAdapter are required for password reset and email verification functionality.');\n        done();\n      });\n    }).catch(error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"fails if you include an emailAdapter, have an appName, but have no publicServerURL and send a password reset email","suites":["Custom Pages, Email Verification, Password Reset"],"line":322,"updatePoint":{"line":322,"column":120,"index":11874},"code":"  it('fails if you include an emailAdapter, have an appName, but have no publicServerURL and send a password reset email', done => {\n    reconfigureServer({\n      appName: undefined,\n      emailAdapter: MockEmailAdapterWithOptions({\n        fromAddress: 'parse@example.com',\n        apiKey: 'k',\n        domain: 'd'\n      })\n    }).then(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.set('email', 'testInvalidConfig@parse.com');\n      user.signUp(null).then(() => Parse.User.requestPasswordReset('testInvalidConfig@parse.com')).then(() => {\n        fail('sending password reset email should not have succeeded');\n        done();\n      }, error => {\n        expect(error.message).toEqual('An appName, publicServerURL, and emailAdapter are required for password reset and email verification functionality.');\n        done();\n      });\n    }).catch(error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"fails if you set a publicServerURL, have an appName, but no emailAdapter and send a password reset email","suites":["Custom Pages, Email Verification, Password Reset"],"line":347,"updatePoint":{"line":347,"column":110,"index":12857},"code":"  it('fails if you set a publicServerURL, have an appName, but no emailAdapter and send a password reset email', done => {\n    reconfigureServer({\n      appName: 'unused',\n      publicServerURL: 'http://localhost:1337/1',\n      emailAdapter: undefined\n    }).then(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.set('email', 'testInvalidConfig@parse.com');\n      user.signUp(null).then(() => Parse.User.requestPasswordReset('testInvalidConfig@parse.com')).then(() => {\n        fail('sending password reset email should not have succeeded');\n        done();\n      }, error => {\n        expect(error.message).toEqual('An appName, publicServerURL, and emailAdapter are required for password reset and email verification functionality.');\n        done();\n      });\n    }).catch(error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"succeeds sending a password reset email if appName, publicServerURL, and email adapter are provided","suites":["Custom Pages, Email Verification, Password Reset"],"line":369,"updatePoint":{"line":369,"column":105,"index":13772},"code":"  it('succeeds sending a password reset email if appName, publicServerURL, and email adapter are provided', done => {\n    reconfigureServer({\n      appName: 'coolapp',\n      publicServerURL: 'http://localhost:1337/1',\n      emailAdapter: MockEmailAdapterWithOptions({\n        fromAddress: 'parse@example.com',\n        apiKey: 'k',\n        domain: 'd'\n      })\n    }).then(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.set('email', 'testInvalidConfig@parse.com');\n      user.signUp(null).then(() => Parse.User.requestPasswordReset('testInvalidConfig@parse.com')).then(() => {\n        done();\n      }, error => {\n        done(error);\n      });\n    }).catch(error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"succeeds sending a password reset username if appName, publicServerURL, and email adapter are provided","suites":["Custom Pages, Email Verification, Password Reset"],"line":393,"updatePoint":{"line":393,"column":108,"index":14578},"code":"  it('succeeds sending a password reset username if appName, publicServerURL, and email adapter are provided', done => {\n    const adapter = MockEmailAdapterWithOptions({\n      fromAddress: 'parse@example.com',\n      apiKey: 'k',\n      domain: 'd',\n      sendMail: function (options) {\n        expect(options.to).toEqual('testValidConfig@parse.com');\n        return Promise.resolve();\n      }\n    });\n\n    // delete that handler to force using the default\n    delete adapter.sendPasswordResetEmail;\n    spyOn(adapter, 'sendMail').and.callThrough();\n    reconfigureServer({\n      appName: 'coolapp',\n      publicServerURL: 'http://localhost:1337/1',\n      emailAdapter: adapter\n    }).then(() => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('testValidConfig@parse.com');\n      user.signUp(null).then(() => Parse.User.requestPasswordReset('testValidConfig@parse.com')).then(() => {\n        expect(adapter.sendMail).toHaveBeenCalled();\n        done();\n      }, error => {\n        done(error);\n      });\n    }).catch(error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"does not send verification email if email verification is disabled","suites":["Custom Pages, Email Verification, Password Reset"],"line":426,"updatePoint":{"line":426,"column":72,"index":15678},"code":"  it('does not send verification email if email verification is disabled', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve()\n    };\n    reconfigureServer({\n      appName: 'unused',\n      publicServerURL: 'http://localhost:1337/1',\n      verifyUserEmails: false,\n      emailAdapter: emailAdapter\n    }).then(async () => {\n      spyOn(emailAdapter, 'sendVerificationEmail');\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      await user.signUp();\n      await user.fetch();\n      expect(emailAdapter.sendVerificationEmail.calls.count()).toEqual(0);\n      expect(user.get('emailVerified')).toEqual(undefined);\n      done();\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"receives the app name and user in the adapter","suites":["Custom Pages, Email Verification, Password Reset"],"line":449,"updatePoint":{"line":449,"column":51,"index":16483},"code":"  it('receives the app name and user in the adapter', done => {\n    let emailSent = false;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        expect(options.appName).toEqual('emailing app');\n        expect(options.user.get('email')).toEqual('user@parse.com');\n        emailSent = true;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(async () => {\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.set('email', 'user@parse.com');\n      await user.signUp();\n      expect(emailSent).toBe(true);\n      done();\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"when you click the link in the email it sets emailVerified to true and redirects you","suites":["Custom Pages, Email Verification, Password Reset"],"line":475,"updatePoint":{"line":475,"column":90,"index":17359},"code":"  it('when you click the link in the email it sets emailVerified to true and redirects you', done => {\n    const user = new Parse.User();\n    let sendEmailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        sendEmailOptions = options;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setPassword('other-password');\n      user.setUsername('user');\n      user.set('email', 'user@parse.com');\n      return user.signUp();\n    }).then(() => {\n      expect(sendEmailOptions).not.toBeUndefined();\n      request({\n        url: sendEmailOptions.link,\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/verify_email_success.html?username=user');\n        user.fetch().then(() => {\n          expect(user.get('emailVerified')).toEqual(true);\n          done();\n        }, err => {\n          jfail(err);\n          fail('this should not fail');\n          done();\n        }).catch(err => {\n          jfail(err);\n          done();\n        });\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"redirects you to invalid link if you try to verify email incorrectly","suites":["Custom Pages, Email Verification, Password Reset"],"line":517,"updatePoint":{"line":517,"column":74,"index":18716},"code":"  it('redirects you to invalid link if you try to verify email incorrectly', done => {\n    reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      emailAdapter: {\n        sendVerificationEmail: () => Promise.resolve(),\n        sendPasswordResetEmail: () => Promise.resolve(),\n        sendMail: () => {}\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/apps/test/verify_email',\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/invalid_link.html');\n        done();\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"redirects you to invalid verification link page if you try to validate a nonexistant users email","suites":["Custom Pages, Email Verification, Password Reset"],"line":538,"updatePoint":{"line":538,"column":102,"index":19491},"code":"  it('redirects you to invalid verification link page if you try to validate a nonexistant users email', done => {\n    reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      emailAdapter: {\n        sendVerificationEmail: () => Promise.resolve(),\n        sendPasswordResetEmail: () => Promise.resolve(),\n        sendMail: () => {}\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/apps/test/verify_email?token=asdfasdf&username=sadfasga',\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/invalid_verification_link.html?username=sadfasga&appId=test');\n        done();\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"redirects you to link send fail page if you try to resend a link for a nonexistant user","suites":["Custom Pages, Email Verification, Password Reset"],"line":559,"updatePoint":{"line":559,"column":93,"index":20332},"code":"  it('redirects you to link send fail page if you try to resend a link for a nonexistant user', done => {\n    reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      emailAdapter: {\n        sendVerificationEmail: () => Promise.resolve(),\n        sendPasswordResetEmail: () => Promise.resolve(),\n        sendMail: () => {}\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/apps/test/resend_verification_email',\n        method: 'POST',\n        followRedirects: false,\n        body: {\n          username: 'sadfasga'\n        }\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/link_send_fail.html');\n        done();\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"does not update email verified if you use an invalid token","suites":["Custom Pages, Email Verification, Password Reset"],"line":584,"updatePoint":{"line":584,"column":64,"index":21166},"code":"  it('does not update email verified if you use an invalid token', done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => {\n        request({\n          url: 'http://localhost:8378/1/apps/test/verify_email?token=invalid&username=zxcv',\n          followRedirects: false\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/invalid_verification_link.html?username=zxcv&appId=test');\n          user.fetch().then(() => {\n            expect(user.get('emailVerified')).toEqual(false);\n            done();\n          });\n        });\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.set('email', 'user@parse.com');\n      user.signUp(null, {\n        success: () => {},\n        error: function () {\n          fail('Failed to save user');\n          done();\n        }\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"should send a password reset link","suites":["Custom Pages, Email Verification, Password Reset"],"line":621,"updatePoint":{"line":621,"column":39,"index":22398},"code":"  it('should send a password reset link', done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        request({\n          url: options.link,\n          followRedirects: false\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=[a-zA-Z0-9]+\\&id=test\\&username=zxcv%2Bzxcv/;\n          expect(response.text.match(re)).not.toBe(null);\n          done();\n        });\n      },\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setPassword('asdf');\n      user.setUsername('zxcv+zxcv');\n      user.set('email', 'user@parse.com');\n      user.signUp().then(() => {\n        Parse.User.requestPasswordReset('user@parse.com', {\n          error: err => {\n            jfail(err);\n            fail('Should not fail requesting a password');\n            done();\n          }\n        });\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"redirects you to invalid link if you try to request password for a nonexistant users email","suites":["Custom Pages, Email Verification, Password Reset"],"line":658,"updatePoint":{"line":658,"column":96,"index":23648},"code":"  it('redirects you to invalid link if you try to request password for a nonexistant users email', done => {\n    reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      emailAdapter: {\n        sendVerificationEmail: () => Promise.resolve(),\n        sendPasswordResetEmail: () => Promise.resolve(),\n        sendMail: () => {}\n      },\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      request({\n        url: 'http://localhost:8378/1/apps/test/request_password_reset?token=asdfasdf&username=sadfasga',\n        followRedirects: false\n      }).then(response => {\n        expect(response.status).toEqual(302);\n        expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/invalid_link.html');\n        done();\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"should programmatically reset password","suites":["Custom Pages, Email Verification, Password Reset"],"line":679,"updatePoint":{"line":679,"column":44,"index":24408},"code":"  it('should programmatically reset password', done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        request({\n          url: options.link,\n          followRedirects: false\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=([a-zA-Z0-9]+)\\&id=test\\&username=zxcv/;\n          const match = response.text.match(re);\n          if (!match) {\n            fail('should have a token');\n            done();\n            return;\n          }\n          const token = match[1];\n          request({\n            url: 'http://localhost:8378/1/apps/test/request_password_reset',\n            method: 'POST',\n            body: {\n              new_password: 'hello',\n              token,\n              username: 'zxcv'\n            },\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            followRedirects: false\n          }).then(response => {\n            expect(response.status).toEqual(302);\n            expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/password_reset_success.html?username=zxcv');\n            Parse.User.logIn('zxcv', 'hello').then(function () {\n              const config = Config.get('test');\n              config.database.adapter.find('_User', {\n                fields: {}\n              }, {\n                username: 'zxcv'\n              }, {\n                limit: 1\n              }).then(results => {\n                // _perishable_token should be unset after reset password\n                expect(results.length).toEqual(1);\n                expect(results[0]['_perishable_token']).toEqual(undefined);\n                done();\n              });\n            }, err => {\n              jfail(err);\n              fail('should login with new password');\n              done();\n            });\n          });\n        });\n      },\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.set('email', 'user@parse.com');\n      user.signUp().then(() => {\n        Parse.User.requestPasswordReset('user@parse.com', {\n          error: err => {\n            jfail(err);\n            fail('Should not fail');\n            done();\n          }\n        });\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"should redirect with username encoded on success page","suites":["Custom Pages, Email Verification, Password Reset"],"line":756,"updatePoint":{"line":756,"column":59,"index":27047},"code":"  it('should redirect with username encoded on success page', done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: options => {\n        request({\n          url: options.link,\n          followRedirects: false\n        }).then(response => {\n          expect(response.status).toEqual(302);\n          const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=([a-zA-Z0-9]+)\\&id=test\\&username=zxcv%2B1/;\n          const match = response.text.match(re);\n          if (!match) {\n            fail('should have a token');\n            done();\n            return;\n          }\n          const token = match[1];\n          request({\n            url: 'http://localhost:8378/1/apps/test/request_password_reset',\n            method: 'POST',\n            body: {\n              new_password: 'hello',\n              token,\n              username: 'zxcv+1'\n            },\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            followRedirects: false\n          }).then(response => {\n            expect(response.status).toEqual(302);\n            expect(response.text).toEqual('Found. Redirecting to http://localhost:8378/1/apps/password_reset_success.html?username=zxcv%2B1');\n            done();\n          });\n        });\n      },\n      sendMail: () => {}\n    };\n    reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    }).then(() => {\n      user.setPassword('asdf');\n      user.setUsername('zxcv+1');\n      user.set('email', 'user@parse.com');\n      user.signUp().then(() => {\n        Parse.User.requestPasswordReset('user@parse.com', {\n          error: err => {\n            jfail(err);\n            fail('Should not fail');\n            done();\n          }\n        });\n      });\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"should programmatically reset password on ajax request","suites":["Custom Pages, Email Verification, Password Reset"],"line":815,"updatePoint":{"line":815,"column":60,"index":29008},"code":"  it('should programmatically reset password on ajax request', async done => {\n    const user = new Parse.User();\n    const emailAdapter = {\n      sendVerificationEmail: () => Promise.resolve(),\n      sendPasswordResetEmail: async options => {\n        const response = await request({\n          url: options.link,\n          followRedirects: false\n        });\n        expect(response.status).toEqual(302);\n        const re = /http:\\/\\/localhost:8378\\/1\\/apps\\/choose_password\\?token=([a-zA-Z0-9]+)\\&id=test\\&username=zxcv/;\n        const match = response.text.match(re);\n        if (!match) {\n          fail('should have a token');\n          return;\n        }\n        const token = match[1];\n        const resetResponse = await request({\n          url: 'http://localhost:8378/1/apps/test/request_password_reset',\n          method: 'POST',\n          body: {\n            new_password: 'hello',\n            token,\n            username: 'zxcv'\n          },\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'X-Requested-With': 'XMLHttpRequest'\n          },\n          followRedirects: false\n        });\n        expect(resetResponse.status).toEqual(200);\n        expect(resetResponse.text).toEqual('\"Password successfully reset\"');\n        await Parse.User.logIn('zxcv', 'hello');\n        const config = Config.get('test');\n        const results = await config.database.adapter.find('_User', {\n          fields: {}\n        }, {\n          username: 'zxcv'\n        }, {\n          limit: 1\n        });\n        // _perishable_token should be unset after reset password\n        expect(results.length).toEqual(1);\n        expect(results[0]['_perishable_token']).toEqual(undefined);\n        done();\n      },\n      sendMail: () => {}\n    };\n    await reconfigureServer({\n      appName: 'emailing app',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    user.setPassword('asdf');\n    user.setUsername('zxcv');\n    user.set('email', 'user@parse.com');\n    await user.signUp();\n    await Parse.User.requestPasswordReset('user@parse.com');\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"should return ajax failure error on ajax request with wrong data provided","suites":["Custom Pages, Email Verification, Password Reset"],"line":876,"updatePoint":{"line":876,"column":79,"index":31176},"code":"  it('should return ajax failure error on ajax request with wrong data provided', async () => {\n    await reconfigureServer({\n      publicServerURL: 'http://localhost:8378/1'\n    });\n    try {\n      await request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/apps/test/request_password_reset',\n        body: `new_password=user1&token=12345&username=Johnny`,\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'X-Requested-With': 'XMLHttpRequest'\n        },\n        followRedirects: false\n      });\n    } catch (error) {\n      expect(error.status).not.toBe(302);\n      expect(error.text).toEqual('{\"code\":-1,\"error\":\"Failed to reset password: username / email / token is invalid\"}');\n    }\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"deletes password reset token on email address change","suites":["Custom Pages, Email Verification, Password Reset"],"line":896,"updatePoint":{"line":896,"column":58,"index":31909},"code":"  it('deletes password reset token on email address change', done => {\n    reconfigureServer({\n      appName: 'coolapp',\n      publicServerURL: 'http://localhost:1337/1',\n      emailAdapter: MockEmailAdapterWithOptions({\n        fromAddress: 'parse@example.com',\n        apiKey: 'k',\n        domain: 'd'\n      })\n    }).then(() => {\n      const config = Config.get('test');\n      const user = new Parse.User();\n      user.setPassword('asdf');\n      user.setUsername('zxcv');\n      user.set('email', 'test@parse.com');\n      return user.signUp(null).then(() => Parse.User.requestPasswordReset('test@parse.com')).then(() => config.database.adapter.find('_User', {\n        fields: {}\n      }, {\n        username: 'zxcv'\n      }, {\n        limit: 1\n      })).then(results => {\n        // validate that there is a token\n        expect(results.length).toEqual(1);\n        expect(results[0]['_perishable_token']).not.toBeNull();\n        user.set('email', 'test2@parse.com');\n        return user.save();\n      }).then(() => config.database.adapter.find('_User', {\n        fields: {}\n      }, {\n        username: 'zxcv'\n      }, {\n        limit: 1\n      })).then(results => {\n        expect(results.length).toEqual(1);\n        expect(results[0]['_perishable_token']).toBeUndefined();\n        done();\n      });\n    }).catch(error => {\n      fail(JSON.stringify(error));\n      done();\n    });\n  });","file":"ValidationAndPasswordsReset.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when masterKey has locked out user","suites":["Verify User Password"],"line":36,"updatePoint":{"line":36,"column":65,"index":1167},"code":"  it('fails to verify password when masterKey has locked out user', done => {\n    const user = new Parse.User();\n    const ACL = new Parse.ACL();\n    ACL.setPublicReadAccess(false);\n    ACL.setPublicWriteAccess(false);\n    user.setUsername('testuser');\n    user.setPassword('mypass');\n    user.setACL(ACL);\n    user.signUp().then(() => {\n      return Parse.User.logIn('testuser', 'mypass');\n    }).then(user => {\n      equal(user.get('username'), 'testuser');\n      // Lock the user down\n      const ACL = new Parse.ACL();\n      user.setACL(ACL);\n      return user.save(null, {\n        useMasterKey: true\n      });\n    }).then(() => {\n      expect(user.getACL().getPublicReadAccess()).toBe(false);\n      return request({\n        url: Parse.serverURL + '/verifyPassword',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        qs: {\n          username: 'testuser',\n          password: 'mypass'\n        }\n      });\n    }).then(res => {\n      fail(res);\n      done();\n    }).catch(err => {\n      expect(err.status).toBe(404);\n      expect(err.text).toMatch(`{\"code\":${Parse.Error.OBJECT_NOT_FOUND},\"error\":\"Invalid username/password.\"}`);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when username is not provided in query string REST API","suites":["Verify User Password"],"line":76,"updatePoint":{"line":76,"column":85,"index":2432},"code":"  it('fails to verify password when username is not provided in query string REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return request({\n        url: Parse.serverURL + '/verifyPassword',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        qs: {\n          username: '',\n          password: 'mypass'\n        }\n      });\n    }).then(res => {\n      fail(res);\n      done();\n    }).catch(err => {\n      expect(err.status).toBe(400);\n      expect(err.text).toMatch('{\"code\":200,\"error\":\"username/email is required.\"}');\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when email is not provided in query string REST API","suites":["Verify User Password"],"line":103,"updatePoint":{"line":103,"column":82,"index":3191},"code":"  it('fails to verify password when email is not provided in query string REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return request({\n        url: Parse.serverURL + '/verifyPassword',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        qs: {\n          email: '',\n          password: 'mypass'\n        }\n      });\n    }).then(res => {\n      fail(res);\n      done();\n    }).catch(err => {\n      expect(err.status).toBe(400);\n      expect(err.text).toMatch('{\"code\":200,\"error\":\"username/email is required.\"}');\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when username is not provided with json payload REST API","suites":["Verify User Password"],"line":130,"updatePoint":{"line":130,"column":87,"index":3952},"code":"  it('fails to verify password when username is not provided with json payload REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return verifyPassword('', 'mypass');\n    }).then(res => {\n      expect(res.status).toBe(400);\n      expect(res.text).toMatch('{\"code\":200,\"error\":\"username/email is required.\"}');\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when email is not provided with json payload REST API","suites":["Verify User Password"],"line":147,"updatePoint":{"line":147,"column":84,"index":4468},"code":"  it('fails to verify password when email is not provided with json payload REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return verifyPassword('', 'mypass', true);\n    }).then(res => {\n      expect(res.status).toBe(400);\n      expect(res.text).toMatch('{\"code\":200,\"error\":\"username/email is required.\"}');\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when password is not provided with json payload REST API","suites":["Verify User Password"],"line":164,"updatePoint":{"line":164,"column":87,"index":4993},"code":"  it('fails to verify password when password is not provided with json payload REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return verifyPassword('testuser', '');\n    }).then(res => {\n      expect(res.status).toBe(400);\n      expect(res.text).toMatch('{\"code\":201,\"error\":\"password is required.\"}');\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when username matches but password does not match hash with json payload REST API","suites":["Verify User Password"],"line":181,"updatePoint":{"line":181,"column":112,"index":5533},"code":"  it('fails to verify password when username matches but password does not match hash with json payload REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return verifyPassword('testuser', 'wrong password');\n    }).then(res => {\n      expect(res.status).toBe(404);\n      expect(res.text).toMatch(`{\"code\":${Parse.Error.OBJECT_NOT_FOUND},\"error\":\"Invalid username/password.\"}`);\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when email matches but password does not match hash with json payload REST API","suites":["Verify User Password"],"line":198,"updatePoint":{"line":198,"column":109,"index":6117},"code":"  it('fails to verify password when email matches but password does not match hash with json payload REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return verifyPassword('my@user.com', 'wrong password', true);\n    }).then(res => {\n      expect(res.status).toBe(404);\n      expect(res.text).toMatch(`{\"code\":${Parse.Error.OBJECT_NOT_FOUND},\"error\":\"Invalid username/password.\"}`);\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when typeof username does not equal string REST API","suites":["Verify User Password"],"line":215,"updatePoint":{"line":215,"column":82,"index":6683},"code":"  it('fails to verify password when typeof username does not equal string REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return verifyPassword(123, 'mypass');\n    }).then(res => {\n      expect(res.status).toBe(404);\n      expect(res.text).toMatch(`{\"code\":${Parse.Error.OBJECT_NOT_FOUND},\"error\":\"Invalid username/password.\"}`);\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when typeof email does not equal string REST API","suites":["Verify User Password"],"line":232,"updatePoint":{"line":232,"column":79,"index":7222},"code":"  it('fails to verify password when typeof email does not equal string REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return verifyPassword(123, 'mypass', true);\n    }).then(res => {\n      expect(res.status).toBe(404);\n      expect(res.text).toMatch(`{\"code\":${Parse.Error.OBJECT_NOT_FOUND},\"error\":\"Invalid username/password.\"}`);\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when typeof password does not equal string REST API","suites":["Verify User Password"],"line":249,"updatePoint":{"line":249,"column":82,"index":7770},"code":"  it('fails to verify password when typeof password does not equal string REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return verifyPassword('my@user.com', 123, true);\n    }).then(res => {\n      expect(res.status).toBe(404);\n      expect(res.text).toMatch(`{\"code\":${Parse.Error.OBJECT_NOT_FOUND},\"error\":\"Invalid username/password.\"}`);\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when username cannot be found REST API","suites":["Verify User Password"],"line":266,"updatePoint":{"line":266,"column":69,"index":8310},"code":"  it('fails to verify password when username cannot be found REST API', done => {\n    verifyPassword('mytestuser', 'mypass').then(res => {\n      expect(res.status).toBe(404);\n      expect(res.text).toMatch(`{\"code\":${Parse.Error.OBJECT_NOT_FOUND},\"error\":\"Invalid username/password.\"}`);\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when email cannot be found REST API","suites":["Verify User Password"],"line":276,"updatePoint":{"line":276,"column":66,"index":8676},"code":"  it('fails to verify password when email cannot be found REST API', done => {\n    verifyPassword('my@user.com', 'mypass', true).then(res => {\n      expect(res.status).toBe(404);\n      expect(res.text).toMatch(`{\"code\":${Parse.Error.OBJECT_NOT_FOUND},\"error\":\"Invalid username/password.\"}`);\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"fails to verify password when preventLoginWithUnverifiedEmail is set to true REST API","suites":["Verify User Password"],"line":286,"updatePoint":{"line":286,"column":91,"index":9074},"code":"  it('fails to verify password when preventLoginWithUnverifiedEmail is set to true REST API', done => {\n    reconfigureServer({\n      publicServerURL: 'http://localhost:8378/',\n      appName: 'emailVerify',\n      verifyUserEmails: true,\n      preventLoginWithUnverifiedEmail: true,\n      emailAdapter: MockEmailAdapterWithOptions({\n        fromAddress: 'parse@example.com',\n        apiKey: 'k',\n        domain: 'd'\n      })\n    }).then(() => {\n      const user = new Parse.User();\n      return user.save({\n        username: 'unverified-user',\n        password: 'mypass',\n        email: 'unverified-email@user.com'\n      });\n    }).then(() => {\n      return verifyPassword('unverified-email@user.com', 'mypass', true);\n    }).then(res => {\n      expect(res.status).toBe(400);\n      expect(res.text).toMatch('{\"code\":205,\"error\":\"User email is not verified.\"}');\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"verify password lock account if failed verify password attempts are above threshold","suites":["Verify User Password"],"line":315,"updatePoint":{"line":315,"column":89,"index":10014},"code":"  it('verify password lock account if failed verify password attempts are above threshold', done => {\n    reconfigureServer({\n      appName: 'lockout threshold',\n      accountLockout: {\n        duration: 1,\n        threshold: 2\n      },\n      publicServerURL: 'http://localhost:8378/'\n    }).then(() => {\n      const user = new Parse.User();\n      return user.save({\n        username: 'testuser',\n        password: 'mypass',\n        email: 'my@user.com'\n      });\n    }).then(() => {\n      return verifyPassword('testuser', 'wrong password');\n    }).then(() => {\n      return verifyPassword('testuser', 'wrong password');\n    }).then(() => {\n      return verifyPassword('testuser', 'wrong password');\n    }).then(() => {\n      return isAccountLockoutError('testuser', 'wrong password', 1, 1);\n    }).then(() => {\n      done();\n    }).catch(err => {\n      fail('lock account after failed login attempts test failed: ' + JSON.stringify(err));\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"succeed in verifying password when username and email are provided and password matches hash with json payload REST API","suites":["Verify User Password"],"line":345,"updatePoint":{"line":345,"column":125,"index":11019},"code":"  it('succeed in verifying password when username and email are provided and password matches hash with json payload REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return request({\n        url: Parse.serverURL + '/verifyPassword',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        qs: {\n          username: 'testuser',\n          email: 'my@user.com',\n          password: 'mypass'\n        },\n        json: true\n      }).then(res => res).catch(err => err);\n    }).then(response => {\n      const res = response.data;\n      expect(typeof res).toBe('object');\n      expect(typeof res['objectId']).toEqual('string');\n      expect(Object.prototype.hasOwnProperty.call(res, 'sessionToken')).toEqual(false);\n      expect(Object.prototype.hasOwnProperty.call(res, 'password')).toEqual(false);\n      done();\n    }).catch(err => {\n      fail(err);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"succeed in verifying password when username and password matches hash with json payload REST API","suites":["Verify User Password"],"line":377,"updatePoint":{"line":377,"column":102,"index":12078},"code":"  it('succeed in verifying password when username and password matches hash with json payload REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return verifyPassword('testuser', 'mypass');\n    }).then(response => {\n      const res = response.data;\n      expect(typeof res).toBe('object');\n      expect(typeof res['objectId']).toEqual('string');\n      expect(Object.prototype.hasOwnProperty.call(res, 'sessionToken')).toEqual(false);\n      expect(Object.prototype.hasOwnProperty.call(res, 'password')).toEqual(false);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"succeed in verifying password when email and password matches hash with json payload REST API","suites":["Verify User Password"],"line":394,"updatePoint":{"line":394,"column":99,"index":12749},"code":"  it('succeed in verifying password when email and password matches hash with json payload REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return verifyPassword('my@user.com', 'mypass', true);\n    }).then(response => {\n      const res = response.data;\n      expect(typeof res).toBe('object');\n      expect(typeof res['objectId']).toEqual('string');\n      expect(Object.prototype.hasOwnProperty.call(res, 'sessionToken')).toEqual(false);\n      expect(Object.prototype.hasOwnProperty.call(res, 'password')).toEqual(false);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"succeed to verify password when username and password provided in query string REST API","suites":["Verify User Password"],"line":411,"updatePoint":{"line":411,"column":93,"index":13423},"code":"  it('succeed to verify password when username and password provided in query string REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return request({\n        url: Parse.serverURL + '/verifyPassword',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        qs: {\n          username: 'testuser',\n          password: 'mypass'\n        }\n      });\n    }).then(response => {\n      const res = response.text;\n      expect(typeof res).toBe('string');\n      const body = JSON.parse(res);\n      expect(typeof body['objectId']).toEqual('string');\n      expect(Object.prototype.hasOwnProperty.call(body, 'sessionToken')).toEqual(false);\n      expect(Object.prototype.hasOwnProperty.call(body, 'password')).toEqual(false);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"succeed to verify password when email and password provided in query string REST API","suites":["Verify User Password"],"line":439,"updatePoint":{"line":439,"column":90,"index":14369},"code":"  it('succeed to verify password when email and password provided in query string REST API', done => {\n    const user = new Parse.User();\n    user.save({\n      username: 'testuser',\n      password: 'mypass',\n      email: 'my@user.com'\n    }).then(() => {\n      return request({\n        url: Parse.serverURL + '/verifyPassword',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest'\n        },\n        qs: {\n          email: 'my@user.com',\n          password: 'mypass'\n        }\n      });\n    }).then(response => {\n      const res = response.text;\n      expect(typeof res).toBe('string');\n      const body = JSON.parse(res);\n      expect(typeof body['objectId']).toEqual('string');\n      expect(Object.prototype.hasOwnProperty.call(body, 'sessionToken')).toEqual(false);\n      expect(Object.prototype.hasOwnProperty.call(body, 'password')).toEqual(false);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"succeed to verify password with username when user1 has username === user2 email REST API","suites":["Verify User Password"],"line":467,"updatePoint":{"line":467,"column":95,"index":15320},"code":"  it('succeed to verify password with username when user1 has username === user2 email REST API', done => {\n    const user1 = new Parse.User();\n    user1.save({\n      username: 'email@user.com',\n      password: 'mypass1',\n      email: '1@user.com'\n    }).then(() => {\n      const user2 = new Parse.User();\n      return user2.save({\n        username: 'user2',\n        password: 'mypass2',\n        email: 'email@user.com'\n      });\n    }).then(() => {\n      return verifyPassword('email@user.com', 'mypass1');\n    }).then(response => {\n      const res = response.data;\n      expect(typeof res).toBe('object');\n      expect(typeof res['objectId']).toEqual('string');\n      expect(Object.prototype.hasOwnProperty.call(res, 'sessionToken')).toEqual(false);\n      expect(Object.prototype.hasOwnProperty.call(res, 'password')).toEqual(false);\n      done();\n    });\n  });","file":"VerifyUserPassword.spec.js","skipped":false,"dir":"spec"},{"name":"denies object prototype to be polluted with keyword \"constructor\"","suites":["Vulnerabilities","Object prototype pollution"],"line":4,"updatePoint":{"line":4,"column":73,"index":202},"code":"    it('denies object prototype to be polluted with keyword \"constructor\"', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const response = await request({\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/PP',\n        body: JSON.stringify({\n          obj: {\n            constructor: {\n              prototype: {\n                dummy: 0\n              }\n            }\n          }\n        })\n      }).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"constructor\"}.');\n      expect(Object.prototype.dummy).toBeUndefined();\n    });","file":"vulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"denies object prototype to be polluted with keypath string \"constructor\"","suites":["Vulnerabilities","Object prototype pollution"],"line":30,"updatePoint":{"line":30,"column":80,"index":1103},"code":"    it('denies object prototype to be polluted with keypath string \"constructor\"', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const objResponse = await request({\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/PP',\n        body: JSON.stringify({\n          obj: {}\n        })\n      }).catch(e => e);\n      const pollResponse = await request({\n        headers: headers,\n        method: 'PUT',\n        url: `http://localhost:8378/1/classes/PP/${objResponse.data.objectId}`,\n        body: JSON.stringify({\n          'obj.constructor.prototype.dummy': {\n            __op: 'Increment',\n            amount: 1\n          }\n        })\n      }).catch(e => e);\n      expect(Object.prototype.dummy).toBeUndefined();\n      expect(pollResponse.status).toBe(400);\n      const text = JSON.parse(pollResponse.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"constructor\"}.');\n      expect(Object.prototype.dummy).toBeUndefined();\n    });","file":"vulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"denies object prototype to be polluted with keyword \"__proto__\"","suites":["Vulnerabilities","Object prototype pollution"],"line":62,"updatePoint":{"line":62,"column":71,"index":2290},"code":"    it('denies object prototype to be polluted with keyword \"__proto__\"', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const response = await request({\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/PP',\n        body: JSON.stringify({\n          'obj.__proto__.dummy': 0\n        })\n      }).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"__proto__\"}.');\n      expect(Object.prototype.dummy).toBeUndefined();\n    });","file":"vulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"denies BSON type code data in write request by default","suites":["Vulnerabilities","Request denylist"],"line":84,"updatePoint":{"line":84,"column":62,"index":3113},"code":"    it('denies BSON type code data in write request by default', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            _bsontype: 'Code',\n            code: 'delete Object.prototype.evalFunctions'\n          }\n        })\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"_bsontype\",\"value\":\"Code\"}.');\n    });","file":"vulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"allows BSON type code data in write request with custom denylist","suites":["Vulnerabilities","Request denylist"],"line":107,"updatePoint":{"line":107,"column":72,"index":3975},"code":"    it('allows BSON type code data in write request with custom denylist', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: []\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            _bsontype: 'Code',\n            code: 'delete Object.prototype.evalFunctions'\n          }\n        })\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(201);\n      const text = JSON.parse(response.text);\n      expect(text.objectId).toBeDefined();\n    });","file":"vulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"denies write request with custom denylist of key/value","suites":["Vulnerabilities","Request denylist"],"line":132,"updatePoint":{"line":132,"column":62,"index":4781},"code":"    it('denies write request with custom denylist of key/value', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{\n          key: 'a[K]ey',\n          value: 'aValue[123]*'\n        }]\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            aKey: 'aValue321',\n            code: 'delete Object.prototype.evalFunctions'\n          }\n        })\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"a[K]ey\",\"value\":\"aValue[123]*\"}.');\n    });","file":"vulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"denies write request with custom denylist of nested key/value","suites":["Vulnerabilities","Request denylist"],"line":161,"updatePoint":{"line":161,"column":69,"index":5790},"code":"    it('denies write request with custom denylist of nested key/value', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{\n          key: 'a[K]ey',\n          value: 'aValue[123]*'\n        }]\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            nested: {\n              aKey: 'aValue321',\n              code: 'delete Object.prototype.evalFunctions'\n            }\n          }\n        })\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"a[K]ey\",\"value\":\"aValue[123]*\"}.');\n    });","file":"vulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"denies write request with custom denylist of key/value in array","suites":["Vulnerabilities","Request denylist"],"line":192,"updatePoint":{"line":192,"column":71,"index":6841},"code":"    it('denies write request with custom denylist of key/value in array', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{\n          key: 'a[K]ey',\n          value: 'aValue[123]*'\n        }]\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: [{\n            aKey: 'aValue321',\n            code: 'delete Object.prototype.evalFunctions'\n          }]\n        })\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"a[K]ey\",\"value\":\"aValue[123]*\"}.');\n    });","file":"vulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"denies write request with custom denylist of key","suites":["Vulnerabilities","Request denylist"],"line":221,"updatePoint":{"line":221,"column":56,"index":7839},"code":"    it('denies write request with custom denylist of key', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{\n          key: 'a[K]ey'\n        }]\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            aKey: 'aValue321',\n            code: 'delete Object.prototype.evalFunctions'\n          }\n        })\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"a[K]ey\"}.');\n    });","file":"vulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"denies write request with custom denylist of value","suites":["Vulnerabilities","Request denylist"],"line":249,"updatePoint":{"line":249,"column":58,"index":8781},"code":"    it('denies write request with custom denylist of value', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{\n          value: 'aValue[123]*'\n        }]\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            aKey: 'aValue321',\n            code: 'delete Object.prototype.evalFunctions'\n          }\n        })\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"value\":\"aValue[123]*\"}.');\n    });","file":"vulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"ignores write request that contains only fraction of denied keyword","suites":["Vulnerabilities","Ignore non-matches"],"line":279,"updatePoint":{"line":279,"column":75,"index":9803},"code":"    it('ignores write request that contains only fraction of denied keyword', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{\n          key: 'abc'\n        }]\n      });\n      // Initially saving an object executes the keyword detection in RestWrite.js\n      const obj = new TestObject({\n        a: {\n          b: {\n            c: 0\n          }\n        }\n      });\n      await expectAsync(obj.save()).toBeResolved();\n      // Modifying a nested key executes the keyword detection in DatabaseController.js\n      obj.increment('a.b.c');\n      await expectAsync(obj.save()).toBeResolved();\n    });","file":"vulnerabilities.spec.js","skipped":false,"dir":"spec"},{"name":"Verify INFO logs","suites":[],"line":8,"updatePoint":{"line":8,"column":22,"index":290},"code":"  it('Verify INFO logs', done => {\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('info', 'testing info logs with 1234');\n    winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'info',\n      order: 'desc'\n    }, results => {\n      if (results.length == 0) {\n        fail('The adapter should return non-empty results');\n      } else {\n        const log = results.find(x => x.message === 'testing info logs with 1234');\n        expect(log.level).toEqual('info');\n      }\n      // Check the error log\n      // Regression #2639\n      winstonLoggerAdapter.query({\n        from: new Date(Date.now() - 200),\n        size: 100,\n        level: 'error'\n      }, errors => {\n        const log = errors.find(x => x.message === 'testing info logs with 1234');\n        expect(log).toBeUndefined();\n        done();\n      });\n    });\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"info logs should interpolate string","suites":[],"line":36,"updatePoint":{"line":36,"column":41,"index":1224},"code":"  it('info logs should interpolate string', async () => {\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('info', 'testing info logs with %s', 'replace');\n    const results = await winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'info',\n      order: 'desc'\n    });\n    expect(results.length > 0).toBeTruthy();\n    const log = results.find(x => x.message === 'testing info logs with replace');\n    expect(log);\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"info logs should interpolate json","suites":[],"line":49,"updatePoint":{"line":49,"column":39,"index":1731},"code":"  it('info logs should interpolate json', async () => {\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('info', 'testing info logs with %j', {\n      hello: 'world'\n    });\n    const results = await winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'info',\n      order: 'desc'\n    });\n    expect(results.length > 0).toBeTruthy();\n    const log = results.find(x => x.message === 'testing info logs with {\"hello\":\"world\"}');\n    expect(log);\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"info logs should interpolate number","suites":[],"line":64,"updatePoint":{"line":64,"column":41,"index":2269},"code":"  it('info logs should interpolate number', async () => {\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('info', 'testing info logs with %d', 123);\n    const results = await winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'info',\n      order: 'desc'\n    });\n    expect(results.length > 0).toBeTruthy();\n    const log = results.find(x => x.message === 'testing info logs with 123');\n    expect(log);\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"Verify ERROR logs","suites":[],"line":81,"updatePoint":{"line":81,"column":23,"index":2858},"code":"  it('Verify ERROR logs', done => {\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('error', 'testing error logs');\n    winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'error'\n    }, results => {\n      if (results.length == 0) {\n        fail('The adapter should return non-empty results');\n        done();\n      } else {\n        expect(results[0].message).toEqual('testing error logs');\n        done();\n      }\n    });\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"Should filter on query","suites":[],"line":98,"updatePoint":{"line":98,"column":28,"index":3381},"code":"  it('Should filter on query', done => {\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('error', 'testing error logs');\n    winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'error'\n    }, results => {\n      expect(results.filter(e => e.level !== 'error').length).toBe(0);\n      done();\n    });\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"error logs should interpolate string","suites":[],"line":110,"updatePoint":{"line":110,"column":42,"index":3788},"code":"  it('error logs should interpolate string', async () => {\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('error', 'testing error logs with %s', 'replace');\n    const results = await winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'error'\n    });\n    expect(results.length > 0).toBeTruthy();\n    const log = results.find(x => x.message === 'testing error logs with replace');\n    expect(log);\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"error logs should interpolate json","suites":[],"line":122,"updatePoint":{"line":122,"column":40,"index":4279},"code":"  it('error logs should interpolate json', async () => {\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('error', 'testing error logs with %j', {\n      hello: 'world'\n    });\n    const results = await winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'error',\n      order: 'desc'\n    });\n    expect(results.length > 0).toBeTruthy();\n    const log = results.find(x => x.message === 'testing error logs with {\"hello\":\"world\"}');\n    expect(log);\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"error logs should interpolate number","suites":[],"line":137,"updatePoint":{"line":137,"column":42,"index":4822},"code":"  it('error logs should interpolate number', async () => {\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('error', 'testing error logs with %d', 123);\n    const results = await winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'error',\n      order: 'desc'\n    });\n    expect(results.length > 0).toBeTruthy();\n    const log = results.find(x => x.message === 'testing error logs with 123');\n    expect(log);\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"mask sensitive information in _User class","suites":[],"line":154,"updatePoint":{"line":154,"column":47,"index":5441},"code":"  it('mask sensitive information in _User class', done => {\n    reconfigureServer({\n      verbose: true\n    }).then(() => createTestUser()).then(() => {\n      const winstonLoggerAdapter = new WinstonLoggerAdapter();\n      return winstonLoggerAdapter.query({\n        from: new Date(Date.now() - 500),\n        size: 100,\n        level: 'verbose'\n      });\n    }).then(results => {\n      const logString = JSON.stringify(results);\n      expect(logString.match(/\\*\\*\\*\\*\\*\\*\\*\\*/g).length).not.toBe(0);\n      expect(logString.match(/moon-y/g)).toBe(null);\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest'\n      };\n      request({\n        headers: headers,\n        url: 'http://localhost:8378/1/login?username=test&password=moon-y'\n      }).then(() => {\n        const winstonLoggerAdapter = new WinstonLoggerAdapter();\n        return winstonLoggerAdapter.query({\n          from: new Date(Date.now() - 500),\n          size: 100,\n          level: 'verbose'\n        }).then(results => {\n          const logString = JSON.stringify(results);\n          expect(logString.match(/\\*\\*\\*\\*\\*\\*\\*\\*/g).length).not.toBe(0);\n          expect(logString.match(/moon-y/g)).toBe(null);\n          done();\n        });\n      });\n    }).catch(err => {\n      fail(JSON.stringify(err));\n      done();\n    });\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"verbose logs should interpolate string","suites":[],"line":193,"updatePoint":{"line":193,"column":44,"index":6781},"code":"  it('verbose logs should interpolate string', async () => {\n    await reconfigureServer({\n      verbose: true\n    });\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('verbose', 'testing verbose logs with %s', 'replace');\n    const results = await winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'verbose'\n    });\n    expect(results.length > 0).toBeTruthy();\n    const log = results.find(x => x.message === 'testing verbose logs with replace');\n    expect(log);\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"verbose logs should interpolate json","suites":[],"line":208,"updatePoint":{"line":208,"column":42,"index":7340},"code":"  it('verbose logs should interpolate json', async () => {\n    await reconfigureServer({\n      verbose: true\n    });\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('verbose', 'testing verbose logs with %j', {\n      hello: 'world'\n    });\n    const results = await winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'verbose',\n      order: 'desc'\n    });\n    expect(results.length > 0).toBeTruthy();\n    const log = results.find(x => x.message === 'testing verbose logs with {\"hello\":\"world\"}');\n    expect(log);\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"verbose logs should interpolate number","suites":[],"line":226,"updatePoint":{"line":226,"column":44,"index":7951},"code":"  it('verbose logs should interpolate number', async () => {\n    await reconfigureServer({\n      verbose: true\n    });\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('verbose', 'testing verbose logs with %d', 123);\n    const results = await winstonLoggerAdapter.query({\n      from: new Date(Date.now() - 500),\n      size: 100,\n      level: 'verbose',\n      order: 'desc'\n    });\n    expect(results.length > 0).toBeTruthy();\n    const log = results.find(x => x.message === 'testing verbose logs with 123');\n    expect(log);\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"},{"name":"verbose logs should interpolate stdout","suites":[],"line":242,"updatePoint":{"line":242,"column":44,"index":8523},"code":"  it('verbose logs should interpolate stdout', async () => {\n    await reconfigureServer({\n      verbose: true,\n      silent: false,\n      logsFolder: null\n    });\n    spyOn(process.stdout, 'write');\n    const winstonLoggerAdapter = new WinstonLoggerAdapter();\n    winstonLoggerAdapter.log('verbose', 'testing verbose logs with %j', {\n      hello: 'world'\n    });\n    const firstLog = process.stdout.write.calls.first().args[0];\n    expect(firstLog).toBe('verbose: testing verbose logs with {\"hello\":\"world\"}\\n');\n  });","file":"WinstonLoggerAdapter.spec.js","skipped":false,"dir":"spec"}]}