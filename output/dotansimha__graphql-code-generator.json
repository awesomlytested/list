{
    "repo": "dotansimha/graphql-code-generator",
    "url": "https://github.com/dotansimha/graphql-code-generator",
    "branch": "master",
    "configs": [
        {
            "package": "@graphql-codegen/cli",
            "lang": "ts",
            "dir": "packages/graphql-codegen-cli/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/core",
            "lang": "ts",
            "dir": "packages/graphql-codegen-core/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/c-sharp-operations",
            "lang": "ts",
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/c-sharp",
            "lang": "ts",
            "dir": "packages/plugins/c-sharp/c-sharp/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/flow",
            "lang": "ts",
            "dir": "packages/plugins/flow/flow/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/flow-operations",
            "lang": "ts",
            "dir": "packages/plugins/flow/operations/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/flow-resolvers",
            "lang": "ts",
            "dir": "packages/plugins/flow/resolvers/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/java-apollo-android",
            "lang": "ts",
            "dir": "packages/plugins/java/apollo-android/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/java-common",
            "lang": "ts",
            "dir": "packages/plugins/java/common/tests",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@graphql-codegen/java",
            "lang": "ts",
            "dir": "packages/plugins/java/java/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/kotlin",
            "lang": "ts",
            "dir": "packages/plugins/java/kotlin/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/java-resolvers",
            "lang": "ts",
            "dir": "packages/plugins/java/resolvers/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/fragment-matcher",
            "lang": "ts",
            "dir": "packages/plugins/other/fragment-matcher/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/introspection",
            "lang": "ts",
            "dir": "packages/plugins/other/introspection/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/jsdoc",
            "lang": "ts",
            "dir": "packages/plugins/other/jsdoc/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/schema-ast",
            "lang": "ts",
            "dir": "packages/plugins/other/schema-ast/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/time",
            "lang": "ts",
            "dir": "packages/plugins/other/time/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/urql-introspection",
            "lang": "ts",
            "dir": "packages/plugins/other/urql-introspection/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/visitor-plugin-common",
            "lang": "ts",
            "dir": "packages/plugins/other/visitor-plugin-common/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-apollo-angular",
            "lang": "ts",
            "dir": "packages/plugins/typescript/apollo-angular/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-apollo-client-helpers",
            "lang": "ts",
            "dir": "packages/plugins/typescript/apollo-client-helpers/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-document-nodes",
            "lang": "ts",
            "dir": "packages/plugins/typescript/document-nodes/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-enum-array",
            "lang": "ts",
            "dir": "packages/plugins/typescript/enum-array/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-generic-sdk",
            "lang": "ts",
            "dir": "packages/plugins/typescript/generic-sdk/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-graphql-apollo",
            "lang": "ts",
            "dir": "packages/plugins/typescript/graphql-apollo/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-graphql-files-modules",
            "lang": "ts",
            "dir": "packages/plugins/typescript/graphql-files-modules/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-graphql-request",
            "lang": "ts",
            "dir": "packages/plugins/typescript/graphql-request/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-jit-sdk",
            "lang": "ts",
            "dir": "packages/plugins/typescript/jit-sdk/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-mongodb",
            "lang": "ts",
            "dir": "packages/plugins/typescript/mongodb/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-msw",
            "lang": "ts",
            "dir": "packages/plugins/typescript/msw/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/named-operations-object",
            "lang": "ts",
            "dir": "packages/plugins/typescript/named-operations-object/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-oclif",
            "lang": "ts",
            "dir": "packages/plugins/typescript/oclif/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-operations",
            "lang": "ts",
            "dir": "packages/plugins/typescript/operations/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-react-apollo",
            "lang": "ts",
            "dir": "packages/plugins/typescript/react-apollo/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-react-query",
            "lang": "ts",
            "dir": "packages/plugins/typescript/react-query/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-resolvers",
            "lang": "ts",
            "dir": "packages/plugins/typescript/resolvers/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-rtk-query",
            "lang": "ts",
            "dir": "packages/plugins/typescript/rtk-query/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-stencil-apollo",
            "lang": "ts",
            "dir": "packages/plugins/typescript/stencil-apollo/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-type-graphql",
            "lang": "ts",
            "dir": "packages/plugins/typescript/type-graphql/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typed-document-node",
            "lang": "ts",
            "dir": "packages/plugins/typescript/typed-document-node/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript",
            "lang": "ts",
            "dir": "packages/plugins/typescript/typescript/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-urql-graphcache",
            "lang": "ts",
            "dir": "packages/plugins/typescript/urql-graphcache/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/urql-svelte-operations-store",
            "lang": "ts",
            "dir": "packages/plugins/typescript/urql-svelte-operations-store/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-urql",
            "lang": "ts",
            "dir": "packages/plugins/typescript/urql/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-vue-apollo-smart-ops",
            "lang": "ts",
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-vue-apollo",
            "lang": "ts",
            "dir": "packages/plugins/typescript/vue-apollo/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-vue-urql",
            "lang": "ts",
            "dir": "packages/plugins/typescript/vue-urql/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/gql-tag-operations-preset",
            "lang": "ts",
            "dir": "packages/presets/gql-tag-operations/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/graphql-modules-preset",
            "lang": "ts",
            "dir": "packages/presets/graphql-modules/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/import-types-preset",
            "lang": "ts",
            "dir": "packages/presets/import-types/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/near-operation-file-preset",
            "lang": "ts",
            "dir": "packages/presets/near-operation-file/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/plugin-helpers",
            "lang": "ts",
            "dir": "packages/utils/plugins-helpers/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "should handle an Error",
            "suites": [
                "cliError"
            ],
            "updatePoint": {
                "line": 19,
                "column": 28
            },
            "line": 19,
            "code": "  it('should handle an Error', () => {\n    const msg = 'used as error';\n\n    cliError(new Error(msg));\n\n    expect(spyProcessExit).toBeCalledWith(1);\n  });",
            "file": "cli-error.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle string",
            "suites": [
                "cliError"
            ],
            "updatePoint": {
                "line": 27,
                "column": 26
            },
            "line": 27,
            "code": "  it('should handle string', () => {\n    const msg = 'used as string';\n\n    cliError(msg);\n\n    expect(spyProcessExit).toBeCalledWith(1);\n  });",
            "file": "cli-error.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle an object",
            "suites": [
                "cliError"
            ],
            "updatePoint": {
                "line": 35,
                "column": 29
            },
            "line": 35,
            "code": "  it('should handle an object', () => {\n    const obj = {\n      foo: 1,\n    };\n\n    cliError(obj);\n\n    expect(spyProcessExit).toBeCalledWith(1);\n  });",
            "file": "cli-error.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should create basic config using new yml API",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 37,
                "column": 50
            },
            "line": 37,
            "code": "  it('Should create basic config using new yml API', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv();\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toEqual('schema.graphql');\n    expect(config.generates).toEqual({ 'file.ts': ['plugin'] });\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should use different config file correctly with --config",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 51,
                "column": 62
            },
            "line": 51,
            "code": "  it('Should use different config file correctly with --config', async () => {\n    mockConfig(\n      `\n        schema: schema.graphql\n        generates:\n            file.ts:\n                - plugin\n      `,\n      'other.yml'\n    );\n    const args = createArgv('--config other.yml');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toEqual('schema.graphql');\n    expect(config.generates).toEqual({ 'file.ts': ['plugin'] });\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should set --watch with new YML api",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 68,
                "column": 41
            },
            "line": 68,
            "code": "  it('Should set --watch with new YML api', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--watch');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.watch).toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should set watch and overwrite to default (false) with new YML api",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 81,
                "column": 72
            },
            "line": 81,
            "code": "  it('Should set watch and overwrite to default (false) with new YML api', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv();\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.watch).not.toBeTruthy();\n    expect(config.overwrite).not.toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite watch config using cli flag to true",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 95,
                "column": 58
            },
            "line": 95,
            "code": "  it('Should overwrite watch config using cli flag to true', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        watch: false\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--watch');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.watch).toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite watch config using cli flags to false",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 109,
                "column": 60
            },
            "line": 109,
            "code": "  it('Should overwrite watch config using cli flags to false', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        watch: true\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--watch=false');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.watch).toBeFalsy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite ignoreNoDocuments config using cli flags to false",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 123,
                "column": 72
            },
            "line": 123,
            "code": "  it('Should overwrite ignoreNoDocuments config using cli flags to false', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        ignoreNoDocuments: true\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--ignore-no-documents=false');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.ignoreNoDocuments).toBeFalsy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite emitLegacyCommonJSImports config using cli flags to true",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 137,
                "column": 79
            },
            "line": 137,
            "code": "  it('Should overwrite emitLegacyCommonJSImports config using cli flags to true', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        emitLegacyCommonJSImports: false\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--emit-legacy-common-js-imports');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.emitLegacyCommonJSImports).toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite emitLegacyCommonJSImports config using cli flags to false",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 151,
                "column": 80
            },
            "line": 151,
            "code": "  it('Should overwrite emitLegacyCommonJSImports config using cli flags to false', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        emitLegacyCommonJSImports: true\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--emit-legacy-common-js-imports=false');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.emitLegacyCommonJSImports).toBeFalsy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite ignoreNoDocuments config using cli flags to true",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 165,
                "column": 71
            },
            "line": 165,
            "code": "  it('Should overwrite ignoreNoDocuments config using cli flags to true', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        ignoreNoDocuments: false\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--ignore-no-documents');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.ignoreNoDocuments).toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should set --overwrite with new YML api",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 179,
                "column": 45
            },
            "line": 179,
            "code": "  it('Should set --overwrite with new YML api', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--overwrite');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.overwrite).toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should interpolate environmental variables in YML",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 192,
                "column": 55
            },
            "line": 192,
            "code": "  it('Should interpolate environmental variables in YML', async () => {\n    process.env.SCHEMA_PATH = 'schema-env.graphql';\n    mockConfig(`\n        schema: \\${SCHEMA_PATH}\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--overwrite');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toBe('schema-env.graphql');\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should interpolate multiple environmental variables in YML",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 206,
                "column": 64
            },
            "line": 206,
            "code": "  it('Should interpolate multiple environmental variables in YML', async () => {\n    process.env.SCHEMA_SCHEME = 'https';\n    process.env.SCHEMA_HOST = 'localhost';\n    mockConfig(`\n        schema: \\${SCHEMA_SCHEME}://\\${SCHEMA_HOST}/graphql\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--overwrite');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toBe('https://localhost/graphql');\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should interpolate environmental variables in YML and support default value",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 221,
                "column": 81
            },
            "line": 221,
            "code": "  it('Should interpolate environmental variables in YML and support default value', async () => {\n    process.env.SCHEMA_PATH = '';\n\n    mockConfig(`\n        schema: \\${SCHEMA_PATH:schema.graphql}\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--overwrite');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toBe('schema.graphql');\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should interpolate environmental variables in YML and support default value containing \":\"",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 236,
                "column": 96
            },
            "line": 236,
            "code": "  it('Should interpolate environmental variables in YML and support default value containing \":\"', async () => {\n    process.env.SCHEMA_PATH = '';\n\n    mockConfig(`\n        schema: \\${SCHEMA_PATH:http://url-to-graphql-api}\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--overwrite');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toBe('http://url-to-graphql-api');\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should load require extensions provided by cli flags",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 251,
                "column": 58
            },
            "line": 251,
            "code": "  it('Should load require extensions provided by cli flags', async () => {\n    process.env.SCHEMA_PATH = 'schema-env.graphql';\n    mockConfig(`\n        schema: \\${SCHEMA_PATH}\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--require my-extension');\n\n    try {\n      await createContext(parseArgv(args));\n      expect(true).toBeFalsy();\n    } catch (e) {\n      expect(e.code).toEqual('MODULE_NOT_FOUND');\n    }\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should output the correct filenames",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 27,
                "column": 43
            },
            "line": 27,
            "code": "    it('Should output the correct filenames', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out1.ts': { plugins: ['typescript'] },\n          'out2.ts': { plugins: ['typescript'] },\n        },\n      });\n\n      expect(output.length).toBe(2);\n      expect(output.map(f => f.filename)).toEqual(expect.arrayContaining(['out1.ts', 'out2.ts']));\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should load require extensions",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 40,
                "column": 38
            },
            "line": 40,
            "code": "    it('Should load require extensions', async () => {\n      expect((global as any).dummyWasLoaded).toBeFalsy();\n      const output = await executeCodegen({\n        schema: join(__dirname, './test-files/schema-dir/schema-object.js'),\n        require: join(__dirname, './dummy-require.js'),\n        generates: {\n          'out1.ts': { plugins: ['typescript'] },\n        },\n        cwd: __dirname,\n      });\n\n      expect(output.length).toBe(1);\n      expect((global as any).dummyWasLoaded).toBeTruthy();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when require extension is invalid",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 55,
                "column": 54
            },
            "line": 55,
            "code": "    it('Should throw when require extension is invalid', async () => {\n      try {\n        await executeCodegen({\n          schema: join(__dirname, './test-files/schema-dir/schema-object.js'),\n          require: join(__dirname, './missing.js'),\n          generates: {\n            'out1.ts': { plugins: ['typescript'] },\n          },\n          cwd: __dirname,\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should accept plugins as object",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 72,
                "column": 39
            },
            "line": 72,
            "code": "    it('Should accept plugins as object', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: [\n              {\n                'typescript-operations': {},\n              },\n            ],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type RootQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should accept plugins as array of objects",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 91,
                "column": 49
            },
            "line": 91,
            "code": "    it('Should accept plugins as array of objects', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: [{ 'typescript-operations': {} }],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type RootQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when no output files has been specified",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 106,
                "column": 60
            },
            "line": 106,
            "code": "    it('Should throw when no output files has been specified', async () => {\n      try {\n        await executeCodegen({\n          schema: SIMPLE_TEST_SCHEMA,\n          generates: {},\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n        expect(e.message).toMatch('Invalid Codegen Configuration!');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should work with just schema",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 120,
                "column": 36
            },
            "line": 120,
            "code": "    it('Should work with just schema', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should not throw when every output has a schema and there is no root schema",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 133,
                "column": 83
            },
            "line": 133,
            "code": "    it('Should not throw when every output has a schema and there is no root schema', async () => {\n      try {\n        const output = await executeCodegen({\n          generates: {\n            'out.ts': {\n              schema: SIMPLE_TEST_SCHEMA,\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        expect(output.length).toBe(1);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n        expect(e.message).not.toMatch('Invalid Codegen Configuration!');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when there is no root schema and some outputs have not defined its own schema",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 151,
                "column": 98
            },
            "line": 151,
            "code": "    it('Should throw when there is no root schema and some outputs have not defined its own schema', async () => {\n      try {\n        await executeCodegen({\n          generates: {\n            'out.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).toMatch('Invalid Codegen Configuration!');\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when one output has no plugins or preset defined",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 168,
                "column": 69
            },
            "line": 168,
            "code": "    it('Should throw when one output has no plugins or preset defined', async () => {\n      expect.assertions(1);\n      try {\n        await executeCodegen({\n          schema: SIMPLE_TEST_SCHEMA,\n          generates: {\n            'out.ts': {},\n          },\n        });\n      } catch (e) {\n        expect(e.message).toMatch('Invalid Codegen Configuration!');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when one output has no plugins defined",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 182,
                "column": 59
            },
            "line": 182,
            "code": "    it('Should throw when one output has no plugins defined', async () => {\n      expect.assertions(1);\n      try {\n        await executeCodegen({\n          schema: SIMPLE_TEST_SCHEMA,\n          generates: {\n            'out.ts': {\n              plugins: [],\n            },\n          },\n        });\n      } catch (e) {\n        expect(e.message).toMatch('Invalid Codegen Configuration!');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should succeed when one output has no plugins but preset defined",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 198,
                "column": 72
            },
            "line": 198,
            "code": "    it('Should succeed when one output has no plugins but preset defined', async () => {\n      await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          './src/gql/': {\n            preset: 'client-preset',\n          },\n        },\n      });\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle extend keyword when GraphQLSchema is used",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 209,
                "column": 63
            },
            "line": 209,
            "code": "    it('should handle extend keyword when GraphQLSchema is used', async () => {\n      const output = await executeCodegen({\n        schema: './tests/test-files/schema-dir/with-extend.js',\n        generates: {\n          'out.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].filename).toBe('out.ts');\n      expect(output[0].content).toContain(`hello?: Maybe<Scalars['String']>`);\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow to specify schema extension for specific output",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 226,
                "column": 68
            },
            "line": 226,
            "code": "    it('Should allow to specify schema extension for specific output', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out1.ts': {\n            schema: `\n              type OtherType { a: String }\n            `,\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type Query');\n      expect(output[0].content).toContain('export type MyType');\n      expect(output[0].content).toContain('export type OtherType');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow to specify documents extension for specific output",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 245,
                "column": 71
            },
            "line": 245,
            "code": "    it('Should allow to specify documents extension for specific output', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out1.ts': {\n            documents: `query q { f }`,\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type QQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should extend existing documents",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 260,
                "column": 40
            },
            "line": 260,
            "code": "    it('Should extend existing documents', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            documents: `query q { f }`,\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type QQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw on duplicated names",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 276,
                "column": 40
            },
            "line": 276,
            "code": "    it('Should throw on duplicated names', async () => {\n      try {\n        await executeCodegen({\n          schema: `\n            type RootQuery { f: String }\n            schema { query: RootQuery }\n          `,\n          documents: [`query q { e }`, `query q { f }`],\n          generates: {\n            'out1.ts': { plugins: ['typescript'] },\n          },\n        });\n        throw SHOULD_NOT_THROW_STRING;\n      } catch (e) {\n        expect(e).not.toEqual(SHOULD_NOT_THROW_STRING);\n        expect(e.message).toContain('Not all operations have an unique name: q');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle gql tag in ts with with nested fragment",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 295,
                "column": 61
            },
            "line": 295,
            "code": "    it('should handle gql tag in ts with with nested fragment', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/my-fragment.ts', './tests/test-documents/query-with-my-fragment.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n      expect(result[0].content).toContain('MyQuery');\n      expect(result[0].filename).toEqual('out1.ts');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle gql tag in ts with with multiple nested fragment",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 309,
                "column": 70
            },
            "line": 309,
            "code": "    it('should handle gql tag in ts with with multiple nested fragment', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/my-fragment.ts', './tests/test-documents/query-with-my-fragment.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(result[0].content).toContain('MyQuery');\n      expect(result[0].filename).toEqual('out1.ts');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle gql tag in js with with nested fragment",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 324,
                "column": 61
            },
            "line": 324,
            "code": "    it('should handle gql tag in js with with nested fragment', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/js-query-with-my-fragment.js', './tests/test-documents/js-my-fragment.js'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(result[0].content).toContain('MyQuery');\n      expect(result[0].filename).toEqual('out1.ts');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle TypeScript features",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 339,
                "column": 41
            },
            "line": 339,
            "code": "    it('should handle TypeScript features', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/ts-features-with-query.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(result[0].content).toContain('MyQuery');\n      expect(result[0].content).toContain('MyQueryInNamespace');\n      expect(result[0].filename).toEqual('out1.ts');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle multiple fragments with the same name, but one is commented out",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 355,
                "column": 85
            },
            "line": 355,
            "code": "    it('should handle multiple fragments with the same name, but one is commented out', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/query-with-commented-fragment.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n      expect(result[0].content).toContain('MyQuery');\n      expect(result[0].filename).toEqual('out1.ts');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle graphql-tag and gatsby by default (documents)",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 369,
                "column": 67
            },
            "line": 369,
            "code": "    it('should handle graphql-tag and gatsby by default (documents)', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/gatsby-and-custom-parsers.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(result[0].content).toContain('FragmentA'); // import gql from 'graphql-tag'\n      expect(result[0].content).toContain('FragmentB'); // import { graphql } from 'gatsby'\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle custom graphql string parsers (documents)",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 384,
                "column": 63
            },
            "line": 384,
            "code": "    it('should handle custom graphql string parsers (documents)', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/gatsby-and-custom-parsers.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n        pluckConfig: {\n          modules: [\n            {\n              name: 'custom-graphql-parser',\n              identifier: 'parser',\n            },\n          ],\n        },\n      });\n\n      expect(result[0].content).toContain('FragmentC'); // import { parser } from 'custom-graphql-parser';\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle graphql-tag and gatsby by default (schema)",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "line": 407,
            "code": "    it.skip('should handle graphql-tag and gatsby by default (schema)', async () => {",
            "file": "codegen.spec.ts",
            "skipped": true,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle custom graphql string parsers (schema)",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "line": 423,
            "code": "    it.skip('should handle custom graphql string parsers (schema)', async () => {",
            "file": "codegen.spec.ts",
            "skipped": true,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should inherit root config",
            "suites": [
                "Codegen Executor",
                "Plugin Configuration"
            ],
            "updatePoint": {
                "line": 448,
                "column": 34
            },
            "line": 448,
            "code": "    it('Should inherit root config', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        config: {\n          namingConvention: 'change-case-all#lowerCase',\n        },\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type rootquery');\n      expect(output[0].content).toContain('export type root');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should accept config in per-output (override)",
            "suites": [
                "Codegen Executor",
                "Plugin Configuration"
            ],
            "updatePoint": {
                "line": 467,
                "column": 53
            },
            "line": 467,
            "code": "    it('Should accept config in per-output (override)', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            config: {\n              namingConvention: 'change-case-all#lowerCase',\n            },\n            plugins: ['typescript', 'typescript-operations'],\n          },\n          'out2.ts': {\n            config: {\n              namingConvention: 'change-case-all#upperCase',\n            },\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(2);\n      expect(output[0].content).toContain('export type rootquery');\n      expect(output[1].content).toContain('export type ROOTQUERY');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should accept config in per-plugin",
            "suites": [
                "Codegen Executor",
                "Plugin Configuration"
            ],
            "updatePoint": {
                "line": 492,
                "column": 42
            },
            "line": 492,
            "code": "    it('Should accept config in per-plugin', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: [\n              {\n                'typescript-operations': {\n                  namingConvention: 'change-case-all#lowerCase',\n                },\n              },\n            ],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type root');\n      expect(output[0].content).toContain('export type rootquery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow override of config in",
            "suites": [
                "Codegen Executor",
                "Plugin Configuration"
            ],
            "updatePoint": {
                "line": 514,
                "column": 42
            },
            "line": 514,
            "code": "    it('Should allow override of config in', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        config: {\n          namingConvention: 'change-case-all#lowerCase',\n        },\n        generates: {\n          'out1.ts': {\n            plugins: [\n              {\n                'typescript-operations': {\n                  namingConvention: 'change-case-all#upperCase',\n                },\n              },\n            ],\n          },\n          'out2.ts': {\n            plugins: [\n              {\n                'typescript-operations': {\n                  namingConvention: 'change-case-all#pascalCase',\n                },\n              },\n            ],\n          },\n        },\n      });\n\n      expect(output.length).toBe(2);\n      expect(output[0].content).toContain('export type ROOTQUERY');\n      expect(output[1].content).toContain('export type RootQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should load custom plugin from local file",
            "suites": [
                "Codegen Executor",
                "Plugin loading"
            ],
            "updatePoint": {
                "line": 550,
                "column": 49
            },
            "line": 550,
            "code": "    it('Should load custom plugin from local file', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out1.ts': {\n            plugins: ['./tests/custom-plugins/basic.js'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('plugin');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when custom plugin is not valid",
            "suites": [
                "Codegen Executor",
                "Plugin loading"
            ],
            "updatePoint": {
                "line": 564,
                "column": 52
            },
            "line": 564,
            "code": "    it('Should throw when custom plugin is not valid', async () => {\n      try {\n        await executeCodegen({\n          schema: SIMPLE_TEST_SCHEMA,\n          generates: {\n            'out1.ts': {\n              plugins: ['./tests/custom-plugins/invalid.js'],\n            },\n          },\n        });\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n        expect(e.message).toContain('Invalid Custom Plugin');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should execute custom plugin validation and throw when it fails",
            "suites": [
                "Codegen Executor",
                "Plugin loading"
            ],
            "updatePoint": {
                "line": 581,
                "column": 71
            },
            "line": 581,
            "code": "    it('Should execute custom plugin validation and throw when it fails', async () => {\n      try {\n        await executeCodegen({\n          schema: SIMPLE_TEST_SCHEMA,\n          generates: {\n            'out1.ts': {\n              plugins: ['./tests/custom-plugins/validation.js'],\n            },\n          },\n        });\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n        expect(e.message).toContain('validation failed');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow plugins to extend schema",
            "suites": [
                "Codegen Executor",
                "Plugin loading"
            ],
            "updatePoint": {
                "line": 598,
                "column": 45
            },
            "line": 598,
            "code": "    it('Should allow plugins to extend schema', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out1.ts': {\n            plugins: ['./tests/custom-plugins/extends-schema.js', './tests/custom-plugins/checks-extended-schema.js'],\n          },\n        },\n      });\n\n      expect(output[0].content).toContain('MyType,');\n      expect(output[0].content).toContain('Extension');\n      expect(output[0].content).toContain(`Should have the Extension type: 'Extension'`);\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow plugins to extend schema (using a function)",
            "suites": [
                "Codegen Executor",
                "Plugin loading"
            ],
            "updatePoint": {
                "line": 613,
                "column": 64
            },
            "line": 613,
            "code": "    it('Should allow plugins to extend schema (using a function)', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        config: {\n          test: 'MyType',\n        },\n        generates: {\n          'out1.ts': {\n            plugins: ['./tests/custom-plugins/extends-schema-fn.js'],\n          },\n        },\n      });\n\n      expect(output[0].content).toContain('MyType');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should keep definitions of all directives",
            "suites": [
                "Codegen Executor",
                "Schema Merging"
            ],
            "updatePoint": {
                "line": 631,
                "column": 49
            },
            "line": 631,
            "code": "    it('should keep definitions of all directives', async () => {\n      const merged = buildASTSchema(\n        mergeTypeDefs([\n          buildSchema(SIMPLE_TEST_SCHEMA),\n          buildSchema(/* GraphQL */ `\n            directive @id on FIELD_DEFINITION\n\n            type Post {\n              id: String @id\n            }\n          `),\n        ])\n      );\n\n      expect(merged.getDirectives().map(({ name }) => name)).toContainEqual('id');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should keep directives in types",
            "suites": [
                "Codegen Executor",
                "Schema Merging"
            ],
            "updatePoint": {
                "line": 648,
                "column": 39
            },
            "line": 648,
            "code": "    it('should keep directives in types', async () => {\n      const merged = buildASTSchema(\n        mergeTypeDefs([\n          buildSchema(SIMPLE_TEST_SCHEMA),\n          buildSchema(/* GraphQL */ `\n            directive @id on FIELD_DEFINITION\n            directive @test on OBJECT\n\n            type Post @test {\n              id: String @id\n            }\n\n            type Query {\n              posts: [Post]\n            }\n\n            schema {\n              query: Query\n            }\n          `),\n        ])\n      );\n\n      expect(merged.getType('Post').astNode.directives.map(({ name }) => name.value)).toContainEqual('test');\n      expect(\n        (merged.getType('Post') as GraphQLObjectType).getFields().id.astNode.directives.map(({ name }) => name.value)\n      ).toContainEqual('id');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should keep scalars",
            "suites": [
                "Codegen Executor",
                "Schema Merging"
            ],
            "updatePoint": {
                "line": 677,
                "column": 27
            },
            "line": 677,
            "code": "    it('should keep scalars', async () => {\n      const schemaA = SIMPLE_TEST_SCHEMA;\n      const schemaB = `\n        scalar UniqueID\n\n        type Post {\n          id: UniqueID\n        }\n      `;\n      const schemaC = parse(`\n        scalar NotUniqueID\n      `);\n\n      const merged = mergeTypeDefs([schemaA, schemaB, schemaC]);\n\n      expect(print(merged)).toContain('scalar UniqueID');\n      expect(print(merged)).toContain('scalar NotUniqueID');\n\n      const schema = buildASTSchema(merged);\n\n      expect(schema.getType('UniqueID')).toBeDefined();\n      expect(schema.getType('NotUniqueID')).toBeDefined();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should keep scalars when executing codegen",
            "suites": [
                "Codegen Executor",
                "Schema Merging"
            ],
            "updatePoint": {
                "line": 701,
                "column": 50
            },
            "line": 701,
            "code": "    it('should keep scalars when executing codegen', async () => {\n      const schemaA = SIMPLE_TEST_SCHEMA;\n      const schemaB = `\n        scalar UniqueID\n\n        type Post {\n          id: UniqueID\n        }\n      `;\n\n      const output = await executeCodegen({\n        schema: [schemaA, schemaB],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toBeSimilarStringTo(`export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n        UniqueID: any;\n      };`);\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow custom loaders to load schema on root level",
            "suites": [
                "Codegen Executor",
                "Custom schema loader"
            ],
            "updatePoint": {
                "line": 733,
                "column": 64
            },
            "line": 733,
            "code": "    it('Should allow custom loaders to load schema on root level', async () => {\n      await executeCodegen({\n        schema: [\n          {\n            './tests/test-documents/schema.graphql': {\n              loader: './tests/custom-loaders/custom-schema-loader.js',\n            },\n          },\n        ],\n        generates: {\n          'out1.ts': { plugins: ['typescript'] },\n        },\n      });\n\n      expect((global as any).CUSTOM_SCHEMA_LOADER_CALLED).toBeTruthy();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow custom loaders to load schema on output level",
            "suites": [
                "Codegen Executor",
                "Custom schema loader"
            ],
            "updatePoint": {
                "line": 750,
                "column": 66
            },
            "line": 750,
            "code": "    it('Should allow custom loaders to load schema on output level', async () => {\n      await executeCodegen({\n        generates: {\n          'out1.ts': {\n            schema: [\n              {\n                './tests/test-documents/schema.graphql': {\n                  loader: './tests/custom-loaders/custom-schema-loader.js',\n                },\n              },\n            ],\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect((global as any).CUSTOM_SCHEMA_LOADER_CALLED).toBeTruthy();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid return value from loader",
            "suites": [
                "Codegen Executor",
                "Custom schema loader"
            ],
            "updatePoint": {
                "line": 769,
                "column": 58
            },
            "line": 769,
            "code": "    it('Should throw when invalid return value from loader', async () => {\n      try {\n        await executeCodegen({\n          schema: [\n            {\n              './tests/test-documents/schema.graphql': {\n                loader: './tests/custom-loaders/invalid-return-value-schema-loader.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': { plugins: ['typescript'] },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Failed to load schema');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid module specified as loader",
            "suites": [
                "Codegen Executor",
                "Custom schema loader"
            ],
            "updatePoint": {
                "line": 790,
                "column": 60
            },
            "line": 790,
            "code": "    it('Should throw when invalid module specified as loader', async () => {\n      try {\n        await executeCodegen({\n          schema: [\n            {\n              './tests/test-documents/schema.graphql': {\n                loader: './tests/custom-loaders/non-existing.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Failed to load custom loader');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid file declaration",
            "suites": [
                "Codegen Executor",
                "Custom schema loader"
            ],
            "updatePoint": {
                "line": 813,
                "column": 50
            },
            "line": 813,
            "code": "    it('Should throw when invalid file declaration', async () => {\n      try {\n        await executeCodegen({\n          schema: [\n            {\n              './tests/test-documents/schema.graphql': {\n                loader: './tests/custom-loaders/invalid-export.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Failed to load schema');\n        expect(error.message).toContain('Failed to load custom loader');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow to use custom documents loader on root level",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 839,
                "column": 65
            },
            "line": 839,
            "code": "    it('Should allow to use custom documents loader on root level', async () => {\n      await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: [\n          {\n            './tests/test-documents/valid.graphql': {\n              loader: './tests/custom-loaders/custom-documents-loader.js',\n            },\n          },\n        ],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect((global as any).CUSTOM_DOCUMENT_LOADER_CALLED).toBeTruthy();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow custom loaders to load documents on output level",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 859,
                "column": 69
            },
            "line": 859,
            "code": "    it('Should allow custom loaders to load documents on output level', async () => {\n      await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        generates: {\n          'out1.ts': {\n            documents: [\n              {\n                './tests/test-documents/valid.graphql': {\n                  loader: join(__dirname, './custom-loaders/custom-documents-loader.js'),\n                },\n              },\n            ],\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect((global as any).CUSTOM_DOCUMENT_LOADER_CALLED).toBeTruthy();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid return value from custom documents loader",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 879,
                "column": 75
            },
            "line": 879,
            "code": "    it('Should throw when invalid return value from custom documents loader', async () => {\n      try {\n        await executeCodegen({\n          schema: ['./tests/test-documents/schema.graphql'],\n          documents: [\n            {\n              './tests/test-documents/valid.graphql': {\n                loader: './tests/custom-loaders/invalid-return-value-documents-loader.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Unable to find any GraphQL type definitions for the following pointers');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid module specified as loader",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 903,
                "column": 60
            },
            "line": 903,
            "code": "    it('Should throw when invalid module specified as loader', async () => {\n      try {\n        await executeCodegen({\n          schema: ['./tests/test-documents/schema.graphql'],\n          documents: [\n            {\n              './tests/test-documents/valid.graphql': {\n                loader: './tests/custom-loaders/non-existing.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Failed to load custom loader');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid file declaration",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 927,
                "column": 50
            },
            "line": 927,
            "code": "    it('Should throw when invalid file declaration', async () => {\n      try {\n        await executeCodegen({\n          schema: ['./tests/test-documents/schema.graphql'],\n          documents: [\n            {\n              './tests/test-documents/valid.graphql': {\n                loader: './tests/custom-loaders/invalid-export.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Failed to load custom loader');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should load schema with custom fetch",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 952,
                "column": 42
            },
            "line": 952,
            "code": "  it('should load schema with custom fetch', async () => {\n    try {\n      await executeCodegen({\n        schema: ['http://www.dummyschema.com/graphql'],\n        customFetch: 'some-fetch#someFetchFn',\n        documents: ['./tests/test-documents/valid.graphql'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n    } catch (error) {\n      expect(error.message).toContain('Failed to load schema from http://www.dummyschema.com/graphql');\n    }\n    expect((global as any).CUSTOM_FETCH_FN_CALLED).toBeTruthy();\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should evaluate glob expressions correctly",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 970,
                "column": 48
            },
            "line": 970,
            "code": "  it('should evaluate glob expressions correctly', async () => {\n    try {\n      await executeCodegen({\n        schema: ['./tests/test-documents/*schema.graphql', '!./tests/test-documents/invalid-schema.graphql'],\n        documents: [\n          './tests/test-documents/*.graphql',\n          '!./tests/test-documents/invalid-*.graphql',\n          '!./tests/test-documents/unused-*.graphql',\n        ],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.error(e);\n      throw new Error('This should not throw as the invalid file is excluded via glob.');\n    }\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow plugins to extend schema with custom root",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 992,
                "column": 60
            },
            "line": 992,
            "code": "  it('Should allow plugins to extend schema with custom root', async () => {\n    try {\n      const output = await executeCodegen({\n        schema: `schema { query: RootQuery } type MyType { f: String } type RootQuery { f: String }`,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: ['./tests/custom-plugins/extends-schema.js', './tests/custom-plugins/checks-extended-schema.js'],\n          },\n        },\n      });\n      expect(output.length).toBe(1);\n    } catch (e) {\n      expect(e.message).not.toBe('Query root type must be provided.');\n    }\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow plugin context to be accessed and modified",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 1009,
                "column": 61
            },
            "line": 1009,
            "code": "  it('Should allow plugin context to be accessed and modified', async () => {\n    const output = await executeCodegen({\n      schema: [\n        {\n          './tests/test-documents/schema.graphql': {\n            loader: './tests/custom-loaders/custom-schema-loader-with-context.js',\n          },\n        },\n      ],\n      generates: {\n        'out1.ts': {\n          plugins: ['./tests/custom-plugins/context.js'],\n        },\n      },\n    });\n\n    expect(output.length).toBe(1);\n    expect(output[0].content).toContain('Hello world!');\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should sort the input schema",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 1029,
                "column": 34
            },
            "line": 1029,
            "code": "  it('Should sort the input schema', async () => {\n    const nonSortedSchema = /* GraphQL */ `\n      type Query {\n        d: String\n        z: String\n        a: String\n      }\n\n      type User {\n        aa: String\n        a: String\n      }\n\n      type A {\n        s: String\n        b: String\n      }\n    `;\n    const output = await executeCodegen({\n      schema: [nonSortedSchema],\n      generates: {\n        'out1.graphql': {\n          plugins: ['schema-ast'],\n        },\n      },\n      config: {\n        sort: true,\n      },\n    });\n\n    expect(output.length).toBe(1);\n    expect(output[0].content).toBeSimilarStringTo(/* GraphQL */ `\n      type A {\n        b: String\n        s: String\n      }\n\n      type Query {\n        a: String\n        d: String\n        z: String\n      }\n\n      type User {\n        a: String\n        aa: String\n      }\n    `);\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Handles weird errors due to invalid schema",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 1079,
                "column": 48
            },
            "line": 1079,
            "code": "  it('Handles weird errors due to invalid schema', async () => {\n    const schema = /* GraphQL */ `\n      type Query {\n        brrrt:1\n      }\n    `;\n    try {\n      await executeCodegen({\n        schema: [schema],\n        generates: {\n          'out1.graphql': {\n            plugins: ['schema-ast'],\n          },\n        },\n      });\n    } catch (error) {\n      expect(error.message).toContain('Failed to load schema from');\n    }\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should generate documents output even if prj1/documents and prj1/extensions/codegen/generate/xxx/documents are both definded with the same glob files",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 1099,
                "column": 155
            },
            "line": 1099,
            "code": "  it('Should generate documents output even if prj1/documents and prj1/extensions/codegen/generate/xxx/documents are both definded with the same glob files', async () => {\n    const prj1 = await createContext({\n      config: './tests/test-files/graphql.config.js',\n      project: 'prj1',\n      errorsOnly: true,\n      overwrite: true,\n      profile: true,\n      require: [],\n      silent: false,\n      watch: false,\n    });\n    const config = prj1.getConfig();\n    const output = await executeCodegen(config);\n    expect(output[0].content).toContain('DocumentNode<MyQueryQuery, MyQueryQueryVariables>');\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should transform documents",
            "suites": [
                "Codegen Executor",
                "Document Transform"
            ],
            "updatePoint": {
                "line": 1116,
                "column": 34
            },
            "line": 1116,
            "code": "    it('Should transform documents', async () => {\n      const transform: Types.DocumentTransformFunction = ({ documents }) => {\n        const newDocuments = [\n          {\n            document: {\n              ...documents[0].document,\n              definitions: [\n                {\n                  ...documents[0].document.definitions[0],\n                  name: { kind: Kind.NAME, value: 'bar' },\n                } as OperationDefinitionNode,\n              ],\n            },\n          },\n        ];\n        return newDocuments;\n      };\n\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query foo { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n            documentTransforms: [{ transform }],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type BarQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow users to set config",
            "suites": [
                "Codegen Executor",
                "Document Transform"
            ],
            "updatePoint": {
                "line": 1149,
                "column": 40
            },
            "line": 1149,
            "code": "    it('Should allow users to set config', async () => {\n      const generateDocumentTransform: (config: { queryName: string }) => Types.DocumentTransformObject = ({\n        queryName,\n      }) => {\n        return {\n          transform: ({ documents }) => {\n            const newDocuments = [\n              {\n                document: {\n                  ...documents[0].document,\n                  definitions: [\n                    {\n                      ...documents[0].document.definitions[0],\n                      name: { kind: Kind.NAME, value: queryName },\n                    } as OperationDefinitionNode,\n                  ],\n                },\n              },\n            ];\n            return newDocuments;\n          },\n        };\n      };\n\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query foo { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n            documentTransforms: [generateDocumentTransform({ queryName: 'test' })],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type TestQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should transform documents when specifying files",
            "suites": [
                "Codegen Executor",
                "Document Transform"
            ],
            "updatePoint": {
                "line": 1188,
                "column": 56
            },
            "line": 1188,
            "code": "    it('Should transform documents when specifying files', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n            documentTransforms: ['./tests/custom-document-transforms/document-transform.js'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type BarQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow users to set config when specifying files",
            "suites": [
                "Codegen Executor",
                "Document Transform"
            ],
            "updatePoint": {
                "line": 1204,
                "column": 62
            },
            "line": 1204,
            "code": "    it('Should allow users to set config when specifying files', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n            documentTransforms: [\n              {\n                './tests/custom-document-transforms/test-config.js': {\n                  queryName: 'test',\n                },\n              },\n            ],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type TestQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow plugin context to be accessed and modified",
            "suites": [
                "Codegen Executor",
                "Document Transform"
            ],
            "updatePoint": {
                "line": 1226,
                "column": 63
            },
            "line": 1226,
            "code": "    it('Should allow plugin context to be accessed and modified', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            documentTransforms: [\n              {\n                transform: ({ pluginContext, documents }) => {\n                  pluginContext.myPluginInfo = 'world';\n                  return documents;\n                },\n              },\n            ],\n            plugins: ['./tests/custom-plugins/document-transform-context.js'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('Hello world!');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should throw an understandable error if it fails.",
            "suites": [
                "Codegen Executor",
                "Document Transform"
            ],
            "updatePoint": {
                "line": 1249,
                "column": 57
            },
            "line": 1249,
            "code": "    it('should throw an understandable error if it fails.', async () => {\n      try {\n        await executeCodegen({\n          schema: SIMPLE_TEST_SCHEMA,\n          documents: `query foo { f }`,\n          generates: {\n            'out1.ts': {\n              plugins: ['typescript'],\n              documentTransforms: [\n                {\n                  transform: () => {\n                    throw new Error('Something Wrong!');\n                  },\n                },\n              ],\n            },\n          },\n        });\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n        expect(e.message).toContain('DocumentTransform \"the element at index 0 of the documentTransforms\" failed');\n        expect(e.message).toContain('Something Wrong!');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should transform documents with client-preset",
            "suites": [
                "Codegen Executor",
                "Document Transform"
            ],
            "updatePoint": {
                "line": 1275,
                "column": 53
            },
            "line": 1275,
            "code": "    it('Should transform documents with client-preset', async () => {\n      const transform: Types.DocumentTransformFunction = ({ documents }) => {\n        const newDocuments = [\n          {\n            document: {\n              ...documents[0].document,\n              definitions: [\n                {\n                  ...documents[0].document.definitions[0],\n                  name: { kind: Kind.NAME, value: 'bar' },\n                } as OperationDefinitionNode,\n              ],\n            },\n          },\n        ];\n        return newDocuments;\n      };\n\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query foo { f }`,\n        generates: {\n          './src/gql/': {\n            preset: 'client',\n            documentTransforms: [{ transform }],\n          },\n        },\n      });\n\n      const fileOutput = output.find(file => file.filename === './src/gql/graphql.ts');\n      expect(fileOutput.content).toContain('export type BarQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "allow to specify overwrite for specific output (should write file)",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 22,
                "column": 74
            },
            "line": 22,
            "code": "  test('allow to specify overwrite for specific output (should write file)', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n\n    const output = await generate(\n      {\n        schema: SIMPLE_TEST_SCHEMA,\n        overwrite: false,\n        generates: {\n          [filename]: {\n            overwrite: true,\n            schema: `\n            type OtherType { a: String }\n          `,\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    // makes sure it writes a new file\n    expect(writeSpy).toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "allow to specify overwrite for specific output (should not write file)",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 48,
                "column": 78
            },
            "line": 48,
            "code": "  test('allow to specify overwrite for specific output (should not write file)', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n    // forces file to exist\n    const fileReadSpy = jest.spyOn(fs, 'readFile');\n    fileReadSpy.mockImplementation(async () => '');\n\n    const output = await generate(\n      {\n        schema: SIMPLE_TEST_SCHEMA,\n        overwrite: true,\n        generates: {\n          [filename]: {\n            overwrite: false,\n            schema: `\n            type OtherType { a: String }\n          `,\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    // makes sure it checks if file is there\n    expect(fileReadSpy).toHaveBeenCalledWith(filename);\n    // makes sure it doesn't write a new file\n    expect(writeSpy).not.toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use global overwrite option and write a file",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 79,
                "column": 59
            },
            "line": 79,
            "code": "  test('should use global overwrite option and write a file', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n\n    const output = await generate(\n      {\n        schema: SIMPLE_TEST_SCHEMA,\n        overwrite: true,\n        generates: {\n          [filename]: {\n            schema: `\n            type OtherType { a: String }\n          `,\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    // makes sure it writes a new file\n    expect(writeSpy).toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use global overwrite option and not write a file",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 104,
                "column": 63
            },
            "line": 104,
            "code": "  test('should use global overwrite option and not write a file', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n    // forces file to exist\n    const fileReadSpy = jest.spyOn(fs, 'readFile');\n    fileReadSpy.mockImplementation(async () => '');\n\n    const output = await generate(\n      {\n        schema: SIMPLE_TEST_SCHEMA,\n        overwrite: false,\n        generates: {\n          [filename]: {\n            schema: `\n            type OtherType { a: String }\n          `,\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    // makes sure it checks if file is there\n    expect(fileReadSpy).toHaveBeenCalledWith(filename);\n    // makes sure it doesn't write a new file\n    expect(writeSpy).not.toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should overwrite a file by default",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 134,
                "column": 42
            },
            "line": 134,
            "code": "  test('should overwrite a file by default', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n    const readSpy = jest.spyOn(fs, 'readFile').mockImplementation();\n    readSpy.mockImplementation(async _f => '');\n\n    const output = await generate(\n      {\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          [filename]: {\n            schema: /* GraphQL */ `\n              type OtherType {\n                a: String\n              }\n            `,\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    // makes sure it doesn't write a new file\n    expect(writeSpy).toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should override generated files",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 162,
                "column": 39
            },
            "line": 162,
            "code": "  test('should override generated files', async () => {\n    jest.unmock('fs');\n    const fs = await import('fs');\n\n    makeDir.sync(dirname(outputFile));\n    if (fs.existsSync(outputFile)) {\n      fs.unlinkSync(outputFile);\n    }\n    fs.writeFileSync(\n      inputFile,\n      `\n    import gql from 'graphql-tag';\n    const MyQuery = gql\\`query MyQuery { f }\\`;\n  `,\n      'utf8'\n    );\n    const generateOnce: () => Promise<Types.FileOutput[]> = () =>\n      generate(\n        {\n          schema: SIMPLE_TEST_SCHEMA,\n          documents: inputFile,\n          generates: {\n            [outputFile]: {\n              plugins: ['typescript', 'typescript-operations', 'typescript-react-apollo'],\n            },\n          },\n        },\n        true\n      );\n    const [firstOutput] = await generateOnce();\n    fs.writeFileSync(firstOutput.filename, firstOutput.content);\n    await generateOnce();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should extract a document from the gql tag (imported from apollo-server)",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 195,
                "column": 80
            },
            "line": 195,
            "code": "  test('should extract a document from the gql tag (imported from apollo-server)', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n\n    const output = await generate(\n      {\n        schema: `./tests/test-files/schema-dir/gatsby-and-custom-parsers/apollo-server.ts`,\n        generates: {\n          [filename]: {\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    expect(output[0].content).toMatch('Used apollo-server');\n    // makes sure it doesn't write a new file\n    expect(writeSpy).toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should allow to alter the content with the beforeOneFileWrite hook",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 216,
                "column": 74
            },
            "line": 216,
            "code": "  test('should allow to alter the content with the beforeOneFileWrite hook', async () => {\n    const filename = 'modify.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n\n    const output = await generate(\n      {\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          [filename]: {\n            plugins: ['typescript'],\n            hooks: {\n              beforeOneFileWrite: [() => 'new content'],\n            },\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    expect(output[0].content).toMatch('new content');\n    // makes sure it doesn't write a new file\n    expect(writeSpy).toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess angular projects",
            "suites": [
                "init",
                "guessTargets()"
            ],
            "updatePoint": {
                "line": 89,
                "column": 37
            },
            "line": 89,
            "code": "    it('should guess angular projects', async () => {\n      require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withAngular);\n      const targets = await guessTargets();\n      expect(targets.Angular).toEqual(true);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess typescript projects",
            "suites": [
                "init",
                "guessTargets()"
            ],
            "updatePoint": {
                "line": 95,
                "column": 40
            },
            "line": 95,
            "code": "    it('should guess typescript projects', async () => {\n      require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withTypescript);\n      const targets = await guessTargets();\n      expect(targets.TypeScript).toEqual(true);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess react projects",
            "suites": [
                "init",
                "guessTargets()"
            ],
            "updatePoint": {
                "line": 101,
                "column": 35
            },
            "line": 101,
            "code": "    it('should guess react projects', async () => {\n      require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withReact);\n      const targets = await guessTargets();\n      expect(targets.React).toEqual(true);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess stencil projects",
            "suites": [
                "init",
                "guessTargets()"
            ],
            "updatePoint": {
                "line": 107,
                "column": 37
            },
            "line": 107,
            "code": "    it('should guess stencil projects', async () => {\n      require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withStencil);\n      const targets = await guessTargets();\n      expect(targets.Stencil).toEqual(true);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess flow projects",
            "suites": [
                "init",
                "guessTargets()"
            ],
            "updatePoint": {
                "line": 113,
                "column": 34
            },
            "line": 113,
            "code": "    it('should guess flow projects', async () => {\n      require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withFlow);\n      const targets = await guessTargets();\n      expect(targets.Flow).toEqual(true);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess vue projects",
            "suites": [
                "init",
                "guessTargets()"
            ],
            "updatePoint": {
                "line": 119,
                "column": 33
            },
            "line": 119,
            "code": "    it('should guess vue projects', async () => {\n      require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withVue);\n      const targets = await guessTargets();\n      expect(targets.Vue).toEqual(true);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess graphql-request projects",
            "suites": [
                "init",
                "guessTargets()"
            ],
            "updatePoint": {
                "line": 125,
                "column": 45
            },
            "line": 125,
            "code": "    it('should guess graphql-request projects', async () => {\n      require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withGraphqlRequest);\n      const targets = await guessTargets();\n      expect(targets.graphqlRequest).toEqual(true);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use angular related plugins when @angular/core is found",
            "suites": [
                "init",
                "plugins suggestions for client-side setup"
            ],
            "updatePoint": {
                "line": 133,
                "column": 70
            },
            "line": 133,
            "code": "    it('should use angular related plugins when @angular/core is found', async () => {\n      const fs = require('fs');\n      fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withAngular);\n      // make sure we don't write stuff\n      const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n      // silent\n      jest.spyOn(console, 'log').mockImplementation();\n\n      useInputs({\n        onTarget: [ENTER], // confirm target\n        onSchema: [ENTER], // use default\n        onDocuments: [ENTER],\n        onPlugins: [ENTER], // use selected packages\n        onOutput: [ENTER], // use default output path\n        onIntrospection: ['n', ENTER], // no introspection,\n        onConfig: [ENTER], // use default config path\n        onScript: ['graphql', ENTER], // use custom npm script\n      });\n\n      await init();\n\n      expect(writeFileSpy).toHaveBeenCalledTimes(2);\n\n      const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n      const config = writeFileSpy.mock.calls[0][1] as string;\n\n      expect(config).toMatchSnapshot();\n\n      // expected plugins\n      expect(pkg.devDependencies).toEqual({\n        '@graphql-codegen/cli': '1.0.0',\n        '@graphql-codegen/typescript-apollo-angular': '1.0.0',\n      });\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use react related plugins when react is found",
            "suites": [
                "init",
                "plugins suggestions for client-side setup"
            ],
            "updatePoint": {
                "line": 168,
                "column": 60
            },
            "line": 168,
            "code": "    it('should use react related plugins when react is found', async () => {\n      const fs = require('fs');\n      fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withReact);\n      // make sure we don't write stuff\n      const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n      // silent\n      jest.spyOn(console, 'log').mockImplementation();\n\n      useInputs({\n        onTarget: [ENTER], // confirm react target\n        onSchema: [ENTER], // use default\n        onDocuments: [ENTER],\n        onOutput: [ENTER], // use default output path\n        onIntrospection: ['n', ENTER], // no introspection,\n        onConfig: [ENTER], // use default config path\n        onScript: ['graphql', ENTER], // use custom npm script\n      });\n\n      await init();\n\n      expect(writeFileSpy).toHaveBeenCalledTimes(2);\n\n      const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n      const config = writeFileSpy.mock.calls[0][1] as string;\n\n      expect(config).toMatchSnapshot();\n\n      // expected plugins\n      expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/cli');\n      expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/client-preset');\n      // should not have other plugins\n      expect(Object.keys(pkg.devDependencies)).toHaveLength(2);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use stencil related plugins when @stencil/core is found",
            "suites": [
                "init",
                "plugins suggestions for client-side setup"
            ],
            "updatePoint": {
                "line": 202,
                "column": 70
            },
            "line": 202,
            "code": "    it('should use stencil related plugins when @stencil/core is found', async () => {\n      const fs = require('fs');\n      fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withStencil);\n      // make sure we don't write stuff\n      const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n      // silent\n      jest.spyOn(console, 'log').mockImplementation();\n\n      useInputs({\n        onTarget: [ENTER], // confirm stencil target\n        onSchema: [ENTER], // use default\n        onDocuments: [ENTER],\n        onPlugins: [ENTER], // use selected packages\n        onOutput: [ENTER], // use default output path\n        onIntrospection: ['n', ENTER], // no introspection,\n        onConfig: [ENTER], // use default config path\n        onScript: ['graphql', ENTER], // use custom npm script\n      });\n\n      await init();\n\n      expect(writeFileSpy).toHaveBeenCalledTimes(2);\n\n      const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n      const config = writeFileSpy.mock.calls[0][1] as string;\n\n      expect(config).toMatchSnapshot();\n\n      // expected plugins\n      expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript');\n      expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-operations');\n      expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-stencil-apollo');\n      // should not have other plugins\n      expect(Object.keys(pkg.devDependencies)).toHaveLength(4);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use typescript related plugins when typescript is found (node)",
            "suites": [
                "init",
                "plugins suggestions non client-side setup"
            ],
            "updatePoint": {
                "line": 240,
                "column": 77
            },
            "line": 240,
            "code": "    it('should use typescript related plugins when typescript is found (node)', async () => {\n      const fs = require('fs');\n      fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withTypescript);\n      // make sure we don't write stuff\n      const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n      // silent\n      jest.spyOn(console, 'log').mockImplementation();\n\n      useInputs({\n        onTarget: [SELECT, ENTER], // confirm api target\n        onSchema: [ENTER], // use default\n        onPlugins: [ENTER], // use selected packages\n        onOutput: [ENTER], // use default output path\n        onIntrospection: ['n', ENTER], // no introspection,\n        onConfig: [ENTER], // use default config path\n        onScript: ['graphql', ENTER], // use custom npm script\n      });\n\n      await init();\n\n      expect(writeFileSpy).toHaveBeenCalledTimes(2);\n\n      const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n      const config = writeFileSpy.mock.calls[0][1] as string;\n\n      expect(config).toMatchSnapshot();\n\n      // expected plugins\n      expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript');\n      expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-resolvers');\n      // should not have other plugins\n      expect(Object.keys(pkg.devDependencies)).toHaveLength(4); // 3 - because we have typescript package in devDeps\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should have few default values",
            "suites": [
                "init",
                "plugins suggestions non client-side setup"
            ],
            "updatePoint": {
                "line": 275,
                "column": 36
            },
            "line": 275,
            "code": "  it('should have few default values', async () => {\n    const fs = require('fs');\n    fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withReact);\n    // make sure we don't write stuff\n    const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n    const logSpy = jest.spyOn(console, 'log').mockImplementation();\n    const defaults = {\n      config: 'codegen.ts',\n    };\n\n    useInputs({\n      onTarget: [ENTER], // confirm angular target\n      onSchema: [ENTER], // use default\n      onDocuments: [ENTER],\n      onOutput: [ENTER], // use default output path\n      onIntrospection: [ENTER], // no introspection,\n      onConfig: [ENTER], // use default config path\n      onScript: ['graphql', ENTER], // use custom npm script\n    });\n\n    await init();\n\n    const configFile = writeFileSpy.mock.calls[0][0] as string;\n    const config = writeFileSpy.mock.calls[0][1] as string;\n    const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n\n    expect(pkg.scripts.graphql).toEqual(`graphql-codegen --config codegen.ts`);\n    expect(configFile).toEqual(resolve(process.cwd(), defaults.config));\n    expect(config).toMatchSnapshot();\n    expect(logSpy.mock.calls[2][0]).toContain(`Config file generated at ${bold(defaults.config)}`);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should have few default values",
            "suites": [
                "init",
                "plugins suggestions non client-side setup"
            ],
            "updatePoint": {
                "line": 307,
                "column": 36
            },
            "line": 307,
            "code": "  it('should have few default values', async () => {\n    const fs = require('fs');\n    fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withReact);\n    // make sure we don't write stuff\n    const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n    const logSpy = jest.spyOn(console, 'log').mockImplementation();\n    const options = {\n      script: 'graphql',\n      schema: './schema.ts',\n      documents: 'graphql/**/*.graphql',\n      output: 'graphql/index.ts',\n      config: 'app-codegen.yml',\n    };\n\n    useInputs({\n      onTarget: [ENTER], // confirm target\n      onSchema: [options.schema, ENTER], // use default\n      onDocuments: [options.documents, ENTER],\n      onOutput: [options.output, ENTER], // use default output path\n      onIntrospection: ['y', ENTER], // with introspection,\n      onConfig: [options.config, ENTER], // use default config path\n      onScript: [options.script, ENTER], // use custom npm script\n    });\n\n    await init();\n\n    const configFile = writeFileSpy.mock.calls[0][0] as string;\n    const config = writeFileSpy.mock.calls[0][1] as string;\n    const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n\n    expect(pkg.scripts[options.script]).toEqual(`graphql-codegen --config ${options.config}`);\n    expect(configFile).toEqual(resolve(process.cwd(), options.config));\n    expect(config).toMatchSnapshot();\n    expect(logSpy.mock.calls[2][0]).toContain(`Config file generated at ${bold(options.config)}`);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "custom setup",
            "suites": [
                "init",
                "plugins suggestions non client-side setup"
            ],
            "updatePoint": {
                "line": 343,
                "column": 18
            },
            "line": 343,
            "code": "  it('custom setup', async () => {\n    const fs = require('fs');\n    fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withReact);\n    // make sure we don't write stuff\n    const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n    const logSpy = jest.spyOn(console, 'log').mockImplementation();\n    const documents = 'graphql/*.ts';\n    const script = 'generate:types';\n\n    useInputs({\n      onTarget: [ENTER], // confirm target\n      onSchema: [ENTER], // use default\n      onDocuments: [documents, ENTER],\n      onOutput: [ENTER], // use default output path\n      onIntrospection: ['y', ENTER], // no introspection,\n      onConfig: [ENTER], // use default config path\n      onScript: [script, ENTER], // use custom npm script\n    });\n\n    await init();\n\n    expect(writeFileSpy).toHaveBeenCalledTimes(2);\n\n    const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n    const config = writeFileSpy.mock.calls[0][1] as string;\n\n    // config\n    expect(config).toMatchSnapshot();\n\n    // script name should match what we provided\n    expect(pkg.scripts[script]).toEqual('graphql-codegen --config codegen.ts');\n    // expected plugins\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/introspection');\n    // should not have these plugins\n    expect(pkg.devDependencies).not.toHaveProperty('@graphql-codegen/typescript-resolvers');\n\n    // logs\n    const welcomeMsg = logSpy.mock.calls[0][0];\n    const doneMsg = logSpy.mock.calls[2][0];\n\n    expect(welcomeMsg).toContain(`Welcome to ${bold('GraphQL Code Generator')}`);\n    expect(doneMsg).toContain(`Config file generated at ${bold('codegen.ts')}`);\n    expect(doneMsg).toContain(bold('$ npm install'));\n    expect(doneMsg).toContain(bold(`$ npm run ${script}`));\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "node",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 425,
                "column": 12
            },
            "line": 425,
            "code": "    it('node', () => {\n      const { available, selected } = getPlugins([Tags.node]);\n\n      // available\n      expect(available).toHaveLength(6);\n      expect(available).toContainEqual('typescript');\n      expect(available).toContainEqual('typescript-resolvers');\n      expect(available).toContainEqual('typescript-mongodb');\n      expect(available).toContainEqual('typescript-document-nodes');\n      expect(available).toContainEqual('flow');\n      expect(available).toContainEqual('flow-resolvers');\n      // selected\n      expect(selected).toHaveLength(0);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "node + typescript",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 440,
                "column": 25
            },
            "line": 440,
            "code": "    it('node + typescript', () => {\n      const { selected, available } = getPlugins([Tags.node, Tags.typescript]);\n\n      // available\n      expect(available).toHaveLength(4);\n      expect(available).toContainEqual('typescript');\n      expect(available).toContainEqual('typescript-resolvers');\n      expect(available).toContainEqual('typescript-mongodb');\n      expect(available).toContainEqual('typescript-document-nodes');\n      // selected\n      expect(selected).toHaveLength(2);\n      expect(selected).toContainEqual('typescript');\n      expect(selected).toContainEqual('typescript-resolvers');\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "node + flow",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 455,
                "column": 19
            },
            "line": 455,
            "code": "    it('node + flow', () => {\n      const { selected, available } = getPlugins([Tags.node, Tags.flow]);\n\n      // available\n      expect(available).toHaveLength(2);\n      expect(available).toContainEqual('flow');\n      expect(available).toContainEqual('flow-resolvers');\n      // selected\n      expect(selected).toHaveLength(2);\n      expect(selected).toContainEqual('flow');\n      expect(selected).toContainEqual('flow-resolvers');\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "angular",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 468,
                "column": 15
            },
            "line": 468,
            "code": "    it('angular', () => {\n      const { selected, available } = getPlugins([Tags.angular]);\n\n      // available\n      expect(available).toHaveLength(2);\n      expect(available).toEqual(['fragment-matcher', 'typescript-apollo-angular']);\n      // selected\n      expect(selected).toHaveLength(1);\n      expect(selected).toEqual(['typescript-apollo-angular']);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "react",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 479,
                "column": 13
            },
            "line": 479,
            "code": "    it('react', () => {\n      const { selected, available } = getPlugins([Tags.react]);\n\n      // available\n      expect(available).toHaveLength(2);\n      expect(available).toContainEqual('fragment-matcher');\n      expect(available).toContainEqual('urql-introspection');\n      // selected\n      expect(selected).toHaveLength(0);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "react + flow",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 490,
                "column": 20
            },
            "line": 490,
            "code": "    it('react + flow', () => {\n      const { selected, available } = getPlugins([Tags.react, Tags.flow]);\n\n      // available\n      expect(available).toHaveLength(4);\n      expect(available).toContainEqual('flow');\n      expect(available).toContainEqual('flow-operations');\n      expect(available).toContainEqual('fragment-matcher');\n      // selected\n      expect(selected).toHaveLength(2);\n      expect(selected).toContainEqual('flow');\n      expect(selected).toContainEqual('flow-operations');\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "stencil",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 504,
                "column": 15
            },
            "line": 504,
            "code": "    it('stencil', () => {\n      const { selected, available } = getPlugins([Tags.stencil]);\n\n      // available\n      expect(available).toHaveLength(7);\n      expect(available).toContainEqual('typescript');\n      expect(available).toContainEqual('typescript-operations');\n      expect(available).toContainEqual('typescript-stencil-apollo');\n      expect(available).toContainEqual('typescript-graphql-files-modules');\n      expect(available).toContainEqual('typescript-document-nodes');\n      expect(available).toContainEqual('fragment-matcher');\n      // selected\n      expect(selected).toHaveLength(3);\n      expect(selected).toContainEqual('typescript');\n      expect(selected).toContainEqual('typescript-operations');\n      expect(selected).toContainEqual('typescript-stencil-apollo');\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should sort and use the correct order",
            "suites": [
                "sortPrependValues"
            ],
            "updatePoint": {
                "line": 4,
                "column": 43
            },
            "line": 4,
            "code": "  it('Should sort and use the correct order', () => {\n    const strings: string[] = [`import `, '/* comment */', `// This is a comment`];\n\n    const sorted = sortPrependValues(strings);\n\n    expect(sorted).toEqual(['/* comment */', `// This is a comment`, `import `]);\n  });",
            "file": "prepend.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-core/tests"
        },
        {
            "name": "should not throw on tsx?, jsx?, json files, both in lower and upper case",
            "suites": [
                "Fragment Matcher Plugin",
                "validate"
            ],
            "updatePoint": {
                "line": 66,
                "column": 80
            },
            "line": 66,
            "code": "    it('should not throw on tsx?, jsx?, json files, both in lower and upper case', async () => {\n      const extensions = ['.json', '.js', '.jsx', '.ts', '.tsx'];\n      const allCases = extensions.concat(extensions.map(val => val.toUpperCase()));\n\n      try {\n        await Promise.all(allCases.map(ext => validate(schema, [], {}, `foo${ext}`, [])));\n\n        throw new Error('DONE');\n      } catch (e) {\n        expect(e.message).toEqual('DONE');\n      }\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should throw on commonjs + ts",
            "suites": [
                "Fragment Matcher Plugin",
                "validate"
            ],
            "updatePoint": {
                "line": 79,
                "column": 37
            },
            "line": 79,
            "code": "    it('should throw on commonjs + ts', async () => {\n      try {\n        await validate(schema, [], { module: 'commonjs' }, 'foo.ts', []);\n\n        throw new Error('SHOULD_NOT_BE_HERE');\n      } catch (e) {\n        expect(e.message).toContain('commonjs');\n      }\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should throw on unsupported extension",
            "suites": [
                "Fragment Matcher Plugin",
                "validate"
            ],
            "updatePoint": {
                "line": 89,
                "column": 45
            },
            "line": 89,
            "code": "    it('should throw on unsupported extension', async () => {\n      try {\n        await validate(schema, [], {}, 'foo.yml', []);\n\n        throw new Error('SHOULD_NOT_BE_HERE');\n      } catch (e) {\n        expect(e.message).toContain('extension');\n      }\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should stringify the result",
            "suites": [
                "Fragment Matcher Plugin",
                "JSON"
            ],
            "updatePoint": {
                "line": 100,
                "column": 35
            },
            "line": 100,
            "code": "    it('should stringify the result', async () => {\n      const content = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n        },\n        {\n          outputFile: 'foo.json',\n        }\n      );\n\n      expect(content).toEqual(introspection);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should use es2015 module by default",
            "suites": [
                "Fragment Matcher Plugin",
                "JavaScript"
            ],
            "updatePoint": {
                "line": 117,
                "column": 43
            },
            "line": 117,
            "code": "    it('should use es2015 module by default', async () => {\n      const jsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n        },\n        {\n          outputFile: 'foo.js',\n        }\n      );\n      const jsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n        },\n        {\n          outputFile: 'foo.jsx',\n        }\n      );\n      const output = `\n        export default ${introspection}\n      `;\n\n      expect(jsContent).toBeSimilarStringTo(output);\n      expect(jsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should be able to use commonjs",
            "suites": [
                "Fragment Matcher Plugin",
                "JavaScript"
            ],
            "updatePoint": {
                "line": 146,
                "column": 38
            },
            "line": 146,
            "code": "    it('should be able to use commonjs', async () => {\n      const jsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.js',\n        }\n      );\n      const jsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.jsx',\n        }\n      );\n      const output = `\n        module.exports = ${introspection}\n      `;\n\n      expect(jsContent).toBeSimilarStringTo(output);\n      expect(jsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should use es2015 module by default",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 179,
                "column": 43
            },
            "line": 179,
            "code": "    it('should use es2015 module by default', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `\n        export interface IntrospectionResultData {\n          __schema: {\n            types: {\n              kind: string;\n              name: string;\n              possibleTypes: {\n                name: string;\n              }[];\n            }[];\n          };\n        }\n        const result: IntrospectionResultData = ${introspection};\n        export default result;\n      `;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should use es2015 module by default - apollo client 3",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 220,
                "column": 61
            },
            "line": 220,
            "code": "    it('should use es2015 module by default - apollo client 3', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 3,\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 3,\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `\n      export interface PossibleTypesResultData {\n        possibleTypes: {\n          [key: string]: string[]\n        }\n      }\n\n        const result: PossibleTypesResultData = ${apolloClient3Result};\n\n        export default result;\n      `;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should use es2015 even though commonjs is requested",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 257,
                "column": 59
            },
            "line": 257,
            "code": "    it('should use es2015 even though commonjs is requested', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `\n        export default result;\n      `;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should support exportAsConst for apolloClientVersion 2",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 286,
                "column": 62
            },
            "line": 286,
            "code": "    it('should support exportAsConst for apolloClientVersion 2', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n          useExplicitTyping: true,\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n          useExplicitTyping: true,\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `\n        export type IntrospectionResultData = ${introspection};\n        const result: IntrospectionResultData = ${introspection};\n        export default result;\n      `;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should support useExplicitTyping for apolloClientVersion 3",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 319,
                "column": 66
            },
            "line": 319,
            "code": "    it('should support useExplicitTyping for apolloClientVersion 3', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 3,\n          useExplicitTyping: true,\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 3,\n          useExplicitTyping: true,\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `\n        export type PossibleTypesResultData = ${apolloClient3Result};\n        const result: PossibleTypesResultData = ${apolloClient3Result};\n        export default result;\n      `;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should support Apollo Federation",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 353,
                "column": 38
            },
            "line": 353,
            "code": "  it('should support Apollo Federation', async () => {\n    const federatedSchema = parse(/* GraphQL */ `\n      type Character @key(fields: \"id\") {\n        id: ID\n        name: String\n      }\n\n      type Jedi @key(fields: \"id\") {\n        id: ID\n        side: String\n      }\n\n      type Droid @key(fields: \"id\") {\n        id: ID\n        model: String\n      }\n\n      union People = Character | Jedi | Droid\n\n      type Query {\n        allPeople: [People]\n      }\n    `);\n    const content = await codegen({\n      filename: 'foo.json',\n      schema: federatedSchema,\n      documents: [],\n      plugins: [\n        {\n          'fragment-matcher': {},\n        },\n      ],\n      config: {\n        federation: true,\n        apolloClientVersion: 2,\n      },\n      pluginMap: {\n        'fragment-matcher': {\n          plugin,\n          validate,\n        },\n      },\n    });\n\n    expect(content).toEqual(introspection);\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should support Apollo Federation with predefined directive definitions",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 399,
                "column": 76
            },
            "line": 399,
            "code": "  it('should support Apollo Federation with predefined directive definitions', async () => {\n    const federatedSchema = parse(/* GraphQL */ `\n      directive @key(fields: String!) on FIELD_DEFINITION\n\n      type Character @key(fields: \"id\") {\n        id: ID\n        name: String\n      }\n\n      type Jedi @key(fields: \"id\") {\n        id: ID\n        side: String\n      }\n\n      type Droid @key(fields: \"id\") {\n        id: ID\n        model: String\n      }\n\n      union People = Character | Jedi | Droid\n\n      type Query {\n        allPeople: [People]\n      }\n    `);\n    const content = await codegen({\n      filename: 'foo.json',\n      schema: federatedSchema,\n      documents: [],\n      plugins: [\n        {\n          'fragment-matcher': {},\n        },\n      ],\n      config: {\n        apolloClientVersion: 2,\n        federation: true,\n      },\n      pluginMap: {\n        'fragment-matcher': {\n          plugin,\n          validate,\n        },\n      },\n    });\n\n    expect(content).toEqual(introspection);\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should output a JSON file",
            "suites": [
                "Introspection template"
            ],
            "updatePoint": {
                "line": 6,
                "column": 31
            },
            "line": 6,
            "code": "  it('should output a JSON file', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        fieldTest: String\n      }\n\n      schema {\n        query: Query\n      }\n    `);\n\n    const content = await plugin(schema, [], {}, { outputFile: '' });\n    const introspection = JSON.stringify(\n      introspectionFromSchema(schema, { descriptions: true, schemaDescription: false, specifiedByUrl: false }),\n      null,\n      2\n    );\n    expect(introspection).toEqual(content);\n  });",
            "file": "introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/introspection/tests"
        },
        {
            "name": "should output a JSON file minified",
            "suites": [
                "Introspection template"
            ],
            "updatePoint": {
                "line": 26,
                "column": 40
            },
            "line": 26,
            "code": "  it('should output a JSON file minified', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        fieldTest: String\n      }\n\n      schema {\n        query: Query\n      }\n    `);\n\n    const content = await plugin(schema, [], { minify: true }, { outputFile: '' });\n    const introspection = JSON.stringify(\n      introspectionFromSchema(schema, { descriptions: true, schemaDescription: false, specifiedByUrl: false })\n    );\n    expect(introspection).toEqual(content);\n  });",
            "file": "introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/introspection/tests"
        },
        {
            "name": "should support Apollo Federation",
            "suites": [
                "Introspection template"
            ],
            "updatePoint": {
                "line": 44,
                "column": 38
            },
            "line": 44,
            "code": "  it('should support Apollo Federation', async () => {\n    const schema = parse(/* GraphQL */ `\n      type Character @key(fields: \"id\") {\n        id: ID\n        name: String\n      }\n\n      type Jedi @key(fields: \"id\") {\n        id: ID\n        side: String\n      }\n\n      type Droid @key(fields: \"id\") {\n        id: ID\n        model: String\n      }\n\n      union People = Character | Jedi | Droid\n\n      type Query {\n        allPeople: [People]\n      }\n    `);\n\n    const content = await codegen({\n      filename: 'foo.json',\n      schema,\n      documents: [],\n      plugins: [\n        {\n          introspection: {},\n        },\n      ],\n      config: {\n        federation: true,\n      },\n      pluginMap: {\n        introspection: {\n          plugin,\n        },\n      },\n    });\n\n    const introspection: IntrospectionQuery = JSON.parse(content);\n    const { types } = introspection.__schema;\n    const queryType = types.find(\n      type => type.name === introspection.__schema.queryType.name\n    ) as IntrospectionObjectType;\n\n    // scalar _Any\n    expect(types.some(type => type.name === '_Any')).toBe(false);\n    // union _Entity\n    expect(types.some(type => type.name === '_Entity')).toBe(false);\n    // type _Service\n    expect(types.some(type => type.name === '_Service')).toBe(false);\n    // type Query { _entities, _service }\n    expect(queryType.fields.some(f => f.name === '_entities')).toBe(false);\n    expect(queryType.fields.some(f => f.name === '_service')).toBe(false);\n  });",
            "file": "introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/introspection/tests"
        },
        {
            "name": "Should enforce graphql extension when its the only plugin",
            "suites": [
                "Schema AST",
                "Validation"
            ],
            "updatePoint": {
                "line": 11,
                "column": 65
            },
            "line": 11,
            "code": "    it('Should enforce graphql extension when its the only plugin', async () => {\n      const fileName = 'output.ts';\n      const plugins: Types.ConfiguredPlugin[] = [\n        {\n          'schema-ast': {},\n        },\n      ];\n\n      try {\n        await validate(null, null, null, fileName, plugins);\n\n        throw new Error(SHOULD_THROW_ERROR);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_THROW_ERROR);\n        expect(e.message).toBe('Plugin \"schema-ast\" requires extension to be \".graphql\" or \".gql\"!');\n      }\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should not enforce graphql extension when its not the only plugin",
            "suites": [
                "Schema AST",
                "Validation"
            ],
            "updatePoint": {
                "line": 29,
                "column": 73
            },
            "line": 29,
            "code": "    it('Should not enforce graphql extension when its not the only plugin', async () => {\n      const fileName = 'output.ts';\n      const plugins: Types.ConfiguredPlugin[] = [\n        {\n          add: {},\n        },\n        {\n          'schema-ast': {},\n        },\n      ];\n\n      try {\n        await validate(null, null, null, fileName, plugins);\n      } catch (e) {\n        expect(true).toBeFalsy();\n      }\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should allow .graphql extension when its the only plugin",
            "suites": [
                "Schema AST",
                "Validation"
            ],
            "updatePoint": {
                "line": 47,
                "column": 64
            },
            "line": 47,
            "code": "    it('Should allow .graphql extension when its the only plugin', async () => {\n      const fileName = 'output.graphql';\n      const plugins: Types.ConfiguredPlugin[] = [\n        {\n          'schema-ast': {},\n        },\n      ];\n\n      try {\n        await validate(null, null, null, fileName, plugins);\n      } catch (e) {\n        expect(true).toBeFalsy();\n      }\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should allow .gql extension when its the only plugin",
            "suites": [
                "Schema AST",
                "Validation"
            ],
            "updatePoint": {
                "line": 62,
                "column": 60
            },
            "line": 62,
            "code": "    it('Should allow .gql extension when its the only plugin', async () => {\n      const fileName = 'output.gql';\n      const plugins: Types.ConfiguredPlugin[] = [\n        {\n          'schema-ast': {},\n        },\n      ];\n\n      try {\n        await validate(null, null, null, fileName, plugins);\n      } catch (e) {\n        expect(true).toBeFalsy();\n      }\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema without directives when \"includeDirectives\" is unset",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 91,
                "column": 80
            },
            "line": 91,
            "code": "    it('Should print schema without directives when \"includeDirectives\" is unset', async () => {\n      const content = await plugin(schema, [], { includeDirectives: false });\n\n      expect(content).toBeSimilarStringTo(`\n        type Query {\n          fieldTest: String\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema with as \"\"\" comment as default",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 101,
                "column": 58
            },
            "line": 101,
            "code": "    it('Should print schema with as \"\"\" comment as default', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          \"\"\"\n          test\n          \"\"\"\n          fieldTest: String\n        }\n      `);\n      const content = await plugin(testSchema, [], { includeDirectives: false });\n\n      expect(content).toBeSimilarStringTo(`\n        type Query {\n          \"\"\"test\"\"\"\n          fieldTest: String\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema with as # when commentDescriptions=true",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 121,
                "column": 69
            },
            "line": 121,
            "code": "      it('Should print schema with as # when commentDescriptions=true', async () => {\n        const testSchema = buildSchema(/* GraphQL */ `\n          type Query {\n            \"\"\"\n            test\n            \"\"\"\n            fieldTest: String\n          }\n        `);\n        const content = await plugin(testSchema, [], { commentDescriptions: true, includeDirectives: false });\n\n        expect(content).toBeSimilarStringTo(`\n        type Query {\n          #  test\n          fieldTest: String\n        }\n      `);\n      });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema with directives when \"includeDirectives\" is set",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 141,
                "column": 75
            },
            "line": 141,
            "code": "    it('Should print schema with directives when \"includeDirectives\" is set', async () => {\n      const content = await plugin(schema, [], { includeDirectives: true });\n\n      expect(content).toBeSimilarStringTo(`\n        directive @modify(limit: Int) on FIELD_DEFINITION\n      `);\n      expect(content).toBeSimilarStringTo(`\n        type Query {\n          fieldTest: String @modify(limit: 1)\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema with introspection when \"includeIntrospectionTypes\" is set",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 154,
                "column": 86
            },
            "line": 154,
            "code": "    it('Should print schema with introspection when \"includeIntrospectionTypes\" is set', async () => {\n      const content = await plugin(schema, [], { includeIntrospectionTypes: true });\n\n      expect(content).toBeSimilarStringTo(`\n        type __Schema\n      `);\n\n      expect(content).toBeSimilarStringTo(`\n        type Query {\n          fieldTest: String\n          __schema: __Schema!\n          __type(name: String!): __Type\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema without introspection when \"includeIntrospectionTypes\" is unset",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 170,
                "column": 91
            },
            "line": 170,
            "code": "    it('Should print schema without introspection when \"includeIntrospectionTypes\" is unset', async () => {\n      const content = await plugin(schema, [], { includeIntrospectionTypes: false });\n\n      expect(content).not.toBeSimilarStringTo(`\n        type __Schema\n      `);\n\n      expect(content).toBeSimilarStringTo(`\n        type Query {\n          fieldTest: String\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "should support Apollo Federation",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 184,
                "column": 40
            },
            "line": 184,
            "code": "    it('should support Apollo Federation', async () => {\n      const federatedSchema = parse(/* GraphQL */ `\n        type Character @key(fields: \"id\") {\n          id: ID\n          name: String\n        }\n\n        type Jedi @key(fields: \"id\") {\n          id: ID\n          side: String\n        }\n\n        type Droid @key(fields: \"id\") {\n          id: ID\n          model: String\n        }\n\n        union People = Character | Jedi | Droid\n\n        type Query {\n          allPeople: [People]\n        }\n      `);\n\n      const content = await codegen({\n        filename: 'foo.graphql',\n        schema: federatedSchema,\n        documents: [],\n        plugins: [\n          {\n            'schema-ast': {},\n          },\n        ],\n        config: {\n          federation: true,\n        },\n        pluginMap: {\n          'schema-ast': {\n            plugin,\n            validate,\n          },\n        },\n      });\n\n      expect(content).not.toContain(`scalar _Any`);\n      expect(content).not.toContain(`union _Entity`);\n      expect(content).not.toContain(`type _Service`);\n\n      expect(content).toBeSimilarStringTo(`\n        type Character {\n          id: ID\n          name: String\n        }\n\n        type Jedi {\n          id: ID\n          side: String\n        }\n\n        type Droid {\n          id: ID\n          model: String\n        }\n\n        union People = Character | Jedi | Droid\n\n        type Query {\n          allPeople: [People]\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should use default comment when extension is unknown",
            "suites": [
                "Time"
            ],
            "updatePoint": {
                "line": 4,
                "column": 58
            },
            "line": 4,
            "code": "  it('Should use default comment when extension is unknown', async () => {\n    const result = await plugin(null as any, [], null, { outputFile: null });\n    expect(result).toContain('// Generated on');\n  });",
            "file": "time.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/time/tests"
        },
        {
            "name": "Should use # prefix for comment when extension is graphql",
            "suites": [
                "Time"
            ],
            "updatePoint": {
                "line": 9,
                "column": 63
            },
            "line": 9,
            "code": "  it('Should use # prefix for comment when extension is graphql', async () => {\n    const result = await plugin(null as any, [], null, { outputFile: 'schema.graphql' });\n    expect(result).toContain('# Generated on');\n  });",
            "file": "time.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/time/tests"
        },
        {
            "name": "does not append `.js` to Operations import path",
            "suites": [
                "getImports",
                "when documentMode \"external\", importDocumentNodeExternallyFrom is \"near-operation-file\"",
                "when emitLegacyCommonJSImports is true"
            ],
            "updatePoint": {
                "line": 18,
                "column": 57
            },
            "line": 18,
            "code": "      it('does not append `.js` to Operations import path', () => {\n        const fileName = 'fooBarQuery';\n        const importPath = `src/queries/${fileName}`;\n\n        const document = parse(\n          `query fooBarQuery {\n            a {\n              foo\n              bar\n            }\n          }\n        `\n        );\n\n        const visitor = new ClientSideBaseVisitor(\n          schema,\n          [],\n          {\n            emitLegacyCommonJSImports: true,\n            importDocumentNodeExternallyFrom: 'near-operation-file',\n            documentMode: DocumentMode.external,\n          },\n          {},\n          [{ document, location: importPath }]\n        );\n\n        visitor.OperationDefinition(document.definitions[0] as OperationDefinitionNode);\n\n        const imports = visitor.getImports();\n        expect(imports[0]).toBe(`import * as Operations from './${fileName}';`);\n      });",
            "file": "client-side-base-visitor.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "appends `.js` to Operations import path",
            "suites": [
                "getImports",
                "when documentMode \"external\", importDocumentNodeExternallyFrom is \"near-operation-file\"",
                "when emitLegacyCommonJSImports is false"
            ],
            "updatePoint": {
                "line": 52,
                "column": 49
            },
            "line": 52,
            "code": "      it('appends `.js` to Operations import path', () => {\n        const fileName = 'fooBarQuery';\n        const importPath = `src/queries/${fileName}`;\n\n        const document = parse(\n          `query fooBarQuery {\n            a {\n              foo\n              bar\n            }\n          }\n        `\n        );\n\n        const visitor = new ClientSideBaseVisitor(\n          schema,\n          [],\n          {\n            emitLegacyCommonJSImports: false,\n            importDocumentNodeExternallyFrom: 'near-operation-file',\n            documentMode: DocumentMode.external,\n          },\n          {},\n          [{ document, location: importPath }]\n        );\n\n        visitor.OperationDefinition(document.definitions[0] as OperationDefinitionNode);\n\n        const imports = visitor.getImports();\n        expect(imports[0]).toBe(`import * as Operations from './${fileName}.js';`);\n      });",
            "file": "client-side-base-visitor.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "preserves `.js` on Operations import path",
            "suites": [
                "getImports",
                "when documentMode \"external\", importDocumentNodeExternallyFrom is relative path",
                "when emitLegacyCommonJSImports is false"
            ],
            "updatePoint": {
                "line": 99,
                "column": 51
            },
            "line": 99,
            "code": "      it('preserves `.js` on Operations import path', () => {\n        const fileName = 'fooBarQuery';\n        const importPath = `./src/queries/${fileName}.js`;\n\n        const document = parse(\n          `query fooBarQuery {\n            a {\n              foo\n              bar\n            }\n          }\n        `\n        );\n\n        const visitor = new ClientSideBaseVisitor(\n          schema,\n          [],\n          {\n            emitLegacyCommonJSImports: false,\n            importDocumentNodeExternallyFrom: importPath,\n            documentMode: DocumentMode.external,\n          },\n          {},\n          [{ document, location: importPath }]\n        );\n\n        visitor.OperationDefinition(document.definitions[0] as OperationDefinitionNode);\n\n        const imports = visitor.getImports();\n        expect(imports[0]).toBe(`import * as Operations from '${importPath}';`);\n      });",
            "file": "client-side-base-visitor.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "checks if types are actually included when Omit is applied",
            "suites": [
                "BaseResolversVisitor.createResolversFields"
            ],
            "updatePoint": {
                "line": 19,
                "column": 64
            },
            "line": 19,
            "code": "  it('checks if types are actually included when Omit is applied', () => {\n    /**\n     * This makes sure that https://github.com/dotansimha/graphql-code-generator/issues/6709 doesn't occur again.\n     * The result looked like this without the fix:\n     * export type ResolversParentTypes = {\n     *   Query: {}\n     *   A: Omit<A, 'b'> & { b?: Maybe<ResolversParentTypes['B']> }\n     *   Boolean: Scalars['Boolean']\n     *   String: Scalars['String']\n     * };\n     */\n    const visitor = new BaseResolversVisitor(\n      {\n        mappers: {\n          B: './some-file#B',\n        },\n      },\n      {} as ParsedResolversConfig,\n      schema\n    );\n\n    expect(visitor.buildResolversParentTypes()).toEqual(\n      `/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = {\n  Query: {}\n  A: A\n  Boolean: Scalars['Boolean']\n  String: Scalars['String']\n};\n`\n    );\n  });",
            "file": "create-resolvers-fields.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "generates proper types when typesPrefix is used along with `enumPrefix: false`",
            "suites": [
                "BaseResolversVisitor.createResolversFields"
            ],
            "updatePoint": {
                "line": 52,
                "column": 84
            },
            "line": 52,
            "code": "  it('generates proper types when typesPrefix is used along with `enumPrefix: false`', () => {\n    /**\n     * This makes sure that https://github.com/dotansimha/graphql-code-generator/issues/6709 doesn't occur again.\n     * The result looked like this without the fix:\n     * export type ResolversParentTypes = {\n     *   Query: {}\n     *   A: Omit<A, 'b'> & { b?: Maybe<ResolversParentTypes['B']> }\n     *   Boolean: Scalars['Boolean']\n     *   String: Scalars['String']\n     * };\n     */\n    const visitor = new BaseResolversVisitor(\n      {\n        mappers: {\n          B: './some-file#B',\n        },\n        typesPrefix: 'I',\n        enumPrefix: false,\n      },\n      {} as ParsedResolversConfig,\n      schema\n    );\n\n    expect(visitor.buildResolversParentTypes()).toEqual(\n      `/** Mapping between all available schema types and the resolvers parents */\nexport type IResolversParentTypes = {\n  Query: {}\n  A: IA\n  Boolean: Scalars['Boolean']\n  String: Scalars['String']\n};\n`\n    );\n  });",
            "file": "create-resolvers-fields.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should work with namespaces",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 17,
                "column": 33
            },
            "line": 17,
            "code": "  it('should work with namespaces', () => {\n    const result = parseEnumValues({\n      schema,\n      mapOrStr: {\n        Test: `my-file#SomeNamespace.ETest`,\n      },\n    });\n\n    expect(result).toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: 'my-file',\n        sourceIdentifier: 'SomeNamespace.ETest',\n        importIdentifier: 'SomeNamespace',\n        mappedValues: null,\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should work with regular type",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 37,
                "column": 35
            },
            "line": 37,
            "code": "  it('should work with regular type', () => {\n    const result = parseEnumValues({\n      schema,\n      mapOrStr: {\n        Test: `my-file#ETest`,\n      },\n    });\n\n    expect(result).toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: 'my-file',\n        sourceIdentifier: 'ETest',\n        importIdentifier: 'ETest',\n        mappedValues: null,\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should work with aliased type",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 57,
                "column": 35
            },
            "line": 57,
            "code": "  it('should work with aliased type', () => {\n    const result = parseEnumValues({\n      schema,\n      mapOrStr: {\n        Test: `my-file#ETest as Something`,\n      },\n    });\n\n    expect(result).toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: 'my-file',\n        sourceIdentifier: 'Something',\n        importIdentifier: 'ETest as Something',\n        mappedValues: null,\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should respect enum values from schema and escape it if needed",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 104,
                "column": 68
            },
            "line": 104,
            "code": "  it('should respect enum values from schema and escape it if needed', () => {\n    const result = parseEnumValues({\n      schema: schemaWithEnumValues,\n      mapOrStr: {},\n      ignoreEnumValuesFromSchema: false,\n    });\n\n    expect(result).toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: null,\n        importIdentifier: null,\n        sourceIdentifier: null,\n        mappedValues: {\n          A: 'a',\n          B: 'b',\n          C: 'c',\n          D: `escape me \\\\'`,\n        },\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should ignore enum values from schema",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 128,
                "column": 43
            },
            "line": 128,
            "code": "  it('should ignore enum values from schema', () => {\n    const result = parseEnumValues({\n      schema: schemaWithEnumValues,\n      mapOrStr: {},\n      ignoreEnumValuesFromSchema: true,\n    });\n\n    expect(result).not.toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: null,\n        importIdentifier: null,\n        sourceIdentifier: null,\n        mappedValues: {\n          A: 'a',\n          B: 'b',\n          C: 'c',\n        },\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should respect non-string enum values",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 178,
                "column": 43
            },
            "line": 178,
            "code": "  it('should respect non-string enum values', () => {\n    const result = parseEnumValues({\n      schema: schemaWithNonStringEnumValues,\n      mapOrStr: {},\n      ignoreEnumValuesFromSchema: false,\n    });\n\n    expect(result).not.toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: null,\n        importIdentifier: null,\n        sourceIdentifier: null,\n        mappedValues: {\n          A: '1',\n          B: 'true',\n          C: 'null',\n          D: 'undefined',\n        },\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should return the correct values for a simple named mapper",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 4,
                "column": 64
            },
            "line": 4,
            "code": "  it('Should return the correct values for a simple named mapper', () => {\n    const result = parseMapper('MyType');\n\n    expect(result).toEqual({\n      isExternal: false,\n      type: 'MyType',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should support a custom mapper with no imports",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 13,
                "column": 52
            },
            "line": 13,
            "code": "  it('Should support a custom mapper with no imports', () => {\n    const result = parseMapper('CustomMergeTypeMapper<SomeType, SomeOtherType>', 'SomeType');\n\n    expect(result).toEqual({\n      isExternal: false,\n      type: 'CustomMergeTypeMapper<SomeType, SomeOtherType>',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should return the correct values for a external named mapper",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 22,
                "column": 66
            },
            "line": 22,
            "code": "  it('Should return the correct values for a external named mapper', () => {\n    const result = parseMapper('file#MyType');\n\n    expect(result).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'MyType',\n      type: 'MyType',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should return the correct values for a external default mapper",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 34,
                "column": 68
            },
            "line": 34,
            "code": "  it('Should return the correct values for a external default mapper', () => {\n    const result = parseMapper('file#default', 'MyGqlType');\n\n    expect(result).toEqual({\n      default: true,\n      isExternal: true,\n      import: 'MyGqlType',\n      type: 'MyGqlType',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should support namespaces",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 46,
                "column": 31
            },
            "line": 46,
            "code": "  it('Should support namespaces', () => {\n    const result = parseMapper('file#Namespace.Type', 'MyGqlType');\n\n    expect(result).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'Namespace',\n      type: 'Namespace.Type',\n      source: 'file',\n    });\n\n    // legacy\n    const legacyResult = parseMapper('file#Namespace#Type', 'MyGqlType');\n\n    expect(legacyResult).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'Namespace',\n      type: 'Namespace.Type',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should support aliases",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 69,
                "column": 28
            },
            "line": 69,
            "code": "  it('Should support aliases', () => {\n    const result = parseMapper('file#Type as SomeOtherType', 'SomeType');\n\n    expect(result).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'Type as SomeOtherType',\n      type: 'SomeOtherType',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should support aliases (default)",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 81,
                "column": 38
            },
            "line": 81,
            "code": "  it('Should support aliases (default)', () => {\n    const result = parseMapper('file#default as SomeOtherType', 'SomeType');\n\n    expect(result).toEqual({\n      default: true,\n      isExternal: true,\n      import: 'SomeOtherType',\n      type: 'SomeOtherType',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should support generic with complex setup",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 93,
                "column": 47
            },
            "line": 93,
            "code": "  it('should support generic with complex setup', () => {\n    const result = parseMapper(`@common-types#Edge<ResolversParentTypes['User']>`, 'SomeType');\n\n    expect(result).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'Edge',\n      type: `Edge<ResolversParentTypes['User']>`,\n      source: '@common-types',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should support generics",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 105,
                "column": 29
            },
            "line": 105,
            "code": "  it('Should support generics', () => {\n    const result = parseMapper('file#Type<Generic>', 'SomeType');\n\n    expect(result).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'Type',\n      type: 'Type<Generic>',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should not add a suffix to a simple named mapper",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 118,
                "column": 56
            },
            "line": 118,
            "code": "    it('Should not add a suffix to a simple named mapper', () => {\n      const result = parseMapper('MyType', null, 'Model');\n\n      expect(result).toEqual({\n        isExternal: false,\n        type: 'MyType',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should add a suffix to an external named mapper",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 127,
                "column": 55
            },
            "line": 127,
            "code": "    it('Should add a suffix to an external named mapper', () => {\n      const result = parseMapper('file#Type', null, 'Model');\n\n      expect(result).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Type as TypeModel',\n        type: 'TypeModel',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should add a suffix to an external default mapper",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 139,
                "column": 57
            },
            "line": 139,
            "code": "    it('Should add a suffix to an external default mapper', () => {\n      const result = parseMapper('file#default', 'MyGqlType', 'Model');\n\n      expect(result).toEqual({\n        default: true,\n        isExternal: true,\n        import: 'MyGqlTypeModel',\n        type: 'MyGqlTypeModel',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should add a suffix and support generics",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 151,
                "column": 48
            },
            "line": 151,
            "code": "    it('Should add a suffix and support generics', () => {\n      const result = parseMapper('file#Type<Generic>', 'SomeType', 'Model');\n\n      expect(result).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Type as TypeModel',\n        type: 'TypeModel<Generic>',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should not add a suffix to a namespace",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 163,
                "column": 46
            },
            "line": 163,
            "code": "    it('Should not add a suffix to a namespace', () => {\n      const result = parseMapper('file#Namespace.Type', 'MyGqlType', 'Model');\n\n      expect(result).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Namespace',\n        type: 'Namespace.Type',\n        source: 'file',\n      });\n\n      // legacy\n      const legacyResult = parseMapper('file#Namespace#Type', 'MyGqlType', 'Model');\n\n      expect(legacyResult).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Namespace',\n        type: 'Namespace.Type',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should add a suffix next to an alias",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 186,
                "column": 44
            },
            "line": 186,
            "code": "    it('Should add a suffix next to an alias', () => {\n      const result = parseMapper('file#Type as SomeOtherType', 'SomeType', 'Model');\n\n      expect(result).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Type as SomeOtherTypeModel',\n        type: 'SomeOtherTypeModel',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "transformMappers should apply a suffix to parseMapper",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 198,
                "column": 61
            },
            "line": 198,
            "code": "    it('transformMappers should apply a suffix to parseMapper', () => {\n      const mappers = transformMappers(\n        {\n          Type: 'file#Type as SomeOtherType',\n        },\n        'Suffix'\n      );\n\n      const result = mappers.Type;\n\n      expect(result).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Type as SomeOtherTypeSuffix',\n        type: 'SomeOtherTypeSuffix',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should use pascal case by default",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 4,
                "column": 39
            },
            "line": 4,
            "code": "  it('Should use pascal case by default', () => {\n    const factory = convertFactory({\n      namingConvention: null,\n    });\n\n    expect(factory('MyName')).toBe('MyName');\n    expect(factory('myName')).toBe('MyName');\n    expect(factory('myname')).toBe('Myname');\n    expect(factory('MyNAME')).toBe('MyName');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to override underscore behaviour directly from configuration.",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 15,
                "column": 80
            },
            "line": 15,
            "code": "  it('Should allow to override underscore behaviour directly from configuration.', () => {\n    const factory = convertFactory({\n      namingConvention: {\n        transformUnderscore: true,\n      },\n    });\n\n    expect(factory('My_Name')).toBe('MyName');\n    expect(factory('_Myname')).toBe('Myname');\n    expect(factory('My_name')).toBe('MyName');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to use \"keep\" as root",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 27,
                "column": 40
            },
            "line": 27,
            "code": "  it('Should allow to use \"keep\" as root', () => {\n    const factory = convertFactory({\n      namingConvention: 'keep',\n    });\n\n    expect(factory('MyName')).toBe('MyName');\n    expect(factory('myName')).toBe('myName');\n    expect(factory('myname')).toBe('myname');\n    expect(factory('MyNAME')).toBe('MyNAME');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to use Function as root",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 38,
                "column": 42
            },
            "line": 38,
            "code": "  it('Should allow to use Function as root', () => {\n    const factory = convertFactory({\n      namingConvention: str => {\n        return 'something' + str;\n      },\n    });\n\n    expect(factory('MyName')).toBe('somethingMyName');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to use object of naming conventions",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 48,
                "column": 54
            },
            "line": 48,
            "code": "  it('Should allow to use object of naming conventions', () => {\n    const factory = convertFactory({\n      namingConvention: {\n        typeNames: 'keep',\n        enumValues: 'keep',\n      },\n    });\n\n    expect(factory('MyName')).toBe('MyName');\n    expect(factory('Myname')).toBe('Myname');\n    expect(factory('NYNAME')).toBe('NYNAME');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to use function of naming conventions",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 61,
                "column": 56
            },
            "line": 61,
            "code": "  it('Should allow to use function of naming conventions', () => {\n    const factory = convertFactory({\n      namingConvention: {\n        typeNames: str => 'a_' + str,\n        enumValues: 'keep',\n      },\n    });\n\n    expect(factory('MyName')).toBe('a_MyName');\n    expect(factory('Myname')).toBe('a_Myname');\n    expect(factory('NYNAME')).toBe('a_NYNAME');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to use function of naming conventions",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 74,
                "column": 56
            },
            "line": 74,
            "code": "  it('Should allow to use function of naming conventions', () => {\n    const factory = convertFactory({\n      namingConvention: {\n        typeNames: str => 'a_' + str,\n        enumValues: 'keep',\n      },\n    });\n\n    expect(factory('MyName')).toBe('a_MyName');\n    expect(factory('Myname')).toBe('a_Myname');\n    expect(factory('NYNAME')).toBe('a_NYNAME');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should keep underscore by default",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 87,
                "column": 39
            },
            "line": 87,
            "code": "  it('Should keep underscore by default', () => {\n    const factory = convertFactory({\n      namingConvention: null,\n    });\n\n    expect(factory('My_Name')).toBe('My_Name');\n    expect(factory('_Myname')).toBe('_Myname');\n    expect(factory('My_name')).toBe('My_Name');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to override underscore behaviour",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 97,
                "column": 51
            },
            "line": 97,
            "code": "  it('Should allow to override underscore behaviour', () => {\n    const factory = convertFactory({\n      namingConvention: null,\n    });\n\n    expect(factory('My_Name', { transformUnderscore: true })).toBe('MyName');\n    expect(factory('_Myname', { transformUnderscore: true })).toBe('Myname');\n    expect(factory('My_name', { transformUnderscore: true })).toBe('MyName');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to override transformUnderscore in config",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 107,
                "column": 60
            },
            "line": 107,
            "code": "  it('Should allow to override transformUnderscore in config', () => {\n    const factory = convertFactory({\n      namingConvention: {\n        typeNames: str => str.replace('_', ''),\n        enumValues: 'keep',\n        transformUnderscore: true,\n      },\n    });\n\n    expect(factory('My_Name')).toBe('MyName');\n    expect(factory('_Myname')).toBe('Myname');\n    expect(factory('My_name')).toBe('Myname');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should generate simple module with one file",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 7,
                "column": 49
            },
            "line": 7,
            "code": "  it('Should generate simple module with one file', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MyQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate correctly for mutiple files",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 34,
                "column": 49
            },
            "line": 34,
            "code": "  it('Should generate correctly for mutiple files', async () => {\n    const result = (await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n        {\n          location: 'some/file/my-other-query.graphql',\n          document: parse(/* GraphQL */ `\n            query OtherQuery {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MyQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n\n      export const OtherQuery = gql\\`\n        query OtherQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should ignore unnamed documents",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 75,
                "column": 37
            },
            "line": 75,
            "code": "  it('Should ignore unnamed documents', async () => {\n    const result = (await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo('');\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate simple module with two documents in one file",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 96,
                "column": 66
            },
            "line": 96,
            "code": "  it('Should generate simple module with two documents in one file', async () => {\n    const result = (await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n\n            query OtherQuery {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MyQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n\n      export const OtherQuery = gql\\`\n        query OtherQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with a name as a camel case",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 133,
                "column": 56
            },
            "line": 133,
            "code": "  it('Should generate module with a name as a camel case', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      { namingConvention: 'change-case-all#camelCase' },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const myQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with a name as a pascal case with underscores",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 160,
                "column": 74
            },
            "line": 160,
            "code": "  it('Should generate module with a name as a pascal case with underscores', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query My_Query {\n              field\n            }\n          `),\n        },\n      ],\n      { namingConvention: 'change-case-all#pascalCase', transformUnderscore: false } as any,\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const My_Query = gql\\`\n        query My_Query {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with a name as a pascal case without underscores",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 187,
                "column": 77
            },
            "line": 187,
            "code": "  it('Should generate module with a name as a pascal case without underscores', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query My_Query {\n              field\n            }\n          `),\n        },\n      ],\n      {\n        namingConvention: {\n          typeNames: 'change-case-all#pascalCase',\n          transformUnderscore: true,\n        },\n      },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MyQuery = gql\\`\n        query My_Query {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with a name as a contant case",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 219,
                "column": 58
            },
            "line": 219,
            "code": "  it('Should generate module with a name as a contant case', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      { namingConvention: 'change-case-all#constantCase' },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MY_QUERY = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with prefix for a name",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 246,
                "column": 51
            },
            "line": 246,
            "code": "  it('Should generate module with prefix for a name', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      { namePrefix: 'Graphql' },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const GraphqlMyQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with suffix for a name",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 273,
                "column": 51
            },
            "line": 273,
            "code": "  it('Should generate module with suffix for a name', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      { nameSuffix: 'Query' },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MyQueryQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate simple module without graphql-tag",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 300,
                "column": 55
            },
            "line": 300,
            "code": "  it('Should generate simple module without graphql-tag', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      { noGraphQLTag: true },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export const MyQuery = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"MyQuery\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"field\"}}]}}]} as unknown as DocumentNode;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "should contain fragment definitions",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 323,
                "column": 41
            },
            "line": 323,
            "code": "  it('should contain fragment definitions', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            # Put your operations here\n            fragment fragment1 on User {\n              id\n              username\n            }\n\n            query user {\n              user(id: 1) {\n                ...fragment1\n              }\n            }\n\n            query user2 {\n              user2: user(id: 1) {\n                ...fragment1\n                email\n              }\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export const Fragment1 = gql\\`\n      fragment fragment1 on User {\n        id\n        username\n      }\n    \\`;\n    \n    export const User = gql\\`\n      query user {\n        user(id: 1) {\n          ...fragment1\n        }\n      }\n    \\${Fragment1}\\`;\n    \n    export const User2 = gql\\`\n      query user2 {\n        user2: user(id: 1) {\n          ...fragment1\n          email\n        }\n      }\n    \\${Fragment1}\\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should not generate \"export\" when noExport is set to true",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 106,
                "column": 65
            },
            "line": 106,
            "code": "    it('Should not generate \"export\" when noExport is set to true', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                created: createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { noExport: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).not.toContain('export');\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle \"namespacedImportName\" and add it when specified",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 134,
                "column": 70
            },
            "line": 134,
            "code": "    it('Should handle \"namespacedImportName\" and add it when specified', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n              textAlias: text\n            }\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                created: createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false, namespacedImportName: 'Types' };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type NotificationsQuery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<Types.TextNotification, 'text' | 'id'>\n            & { textAlias: Types.TextNotification['text'] }\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<Types.ImageNotification, 'imageUrl' | 'id'>\n            & { metadata: (\n              { __typename?: 'ImageMetadata' }\n              & { created: Types.ImageMetadata['createdBy'] }\n            ) }\n          )> }\n        );\n      `);\n      await validate(content, config, schema, '', [`Cannot find namespace 'Types'.`]);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Can merge an inline fragment with a spread",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 183,
                "column": 50
            },
            "line": 183,
            "code": "    it('Can merge an inline fragment with a spread', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Comment {\n          id: ID!\n          title: String!\n        }\n\n        type TextComment implements Comment {\n          id: ID!\n          title: String!\n          text: String!\n        }\n\n        type ImageComment implements Comment {\n          id: ID!\n          title: String!\n          image: String!\n        }\n\n        type Post {\n          id: ID!\n          comments: [Comment!]!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        fragment Post on Post {\n          id\n          comments {\n            ... on TextComment {\n              text\n            }\n          }\n        }\n\n        fragment PostPlus on Post {\n          ...Post\n          comments {\n            id\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: 'test-file.ts', document: ast }],\n        {},\n        {\n          outputFile: '',\n        }\n      );\n      expect(content).toBeSimilarStringTo(`\n        export type PostFragment = { __typename?: 'Post', id: string, comments: Array<{ __typename?: 'TextComment', text: string } | { __typename?: 'ImageComment' }> };\n\n        export type PostPlusFragment = { __typename?: 'Post', id: string, comments: Array<{ __typename?: 'TextComment', text: string, id: string } | { __typename?: 'ImageComment', id: string }> };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle \"namespacedImportName\" and \"preResolveTypes\" together",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 241,
                "column": 75
            },
            "line": 241,
            "code": "    it('Should handle \"namespacedImportName\" and \"preResolveTypes\" together', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          f: E\n          user: User!\n        }\n\n        enum E {\n          A\n          B\n        }\n\n        scalar JSON\n\n        type User {\n          id: ID!\n          f: E\n          j: JSON\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query test {\n          f\n          user {\n            id\n            f\n            j\n          }\n        }\n      `);\n      const config = { namespacedImportName: 'Types', preResolveTypes: true };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type TestQuery = { __typename?: 'Query', f?: Types.E | null, user: { __typename?: 'User', id: string, f?: Types.E | null, j?: any | null } };`\n      );\n\n      await validate(content, config, schema, '', [`Cannot find namespace 'Types'.`]);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct output when using immutableTypes config",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 283,
                "column": 75
            },
            "line": 283,
            "code": "    it('Should generate the correct output when using immutableTypes config', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false, namingConvention: 'change-case-all#lowerCase', immutableTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type notificationsquery = (\n          { readonly __typename?: 'Query' }\n          & { readonly notifications: ReadonlyArray<(\n            { readonly __typename?: 'TextNotification' }\n            & Pick<textnotification, 'text' | 'id'>\n          ) | (\n            { readonly __typename?: 'ImageNotification' }\n            & Pick<imagenotification, 'imageUrl' | 'id'>\n            & { readonly metadata: (\n              { readonly __typename?: 'ImageMetadata' }\n              & Pick<imagemetadata, 'createdBy'>\n            ) }\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should include fragment variable definitions when experimentalFragmentVariables is set",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 326,
                "column": 94
            },
            "line": 326,
            "code": "    it('should include fragment variable definitions when experimentalFragmentVariables is set', async () => {\n      const ast = parse(\n        /* GraphQL */ `\n          fragment TextNotificationFragment($skip: Boolean!) on TextNotification {\n            text @skip(if: $skip)\n          }\n        `,\n        // < v15 compatibility\n        { experimentalFragmentVariables: true, allowLegacyFragmentVariables: true } as any\n      );\n      const config = { experimentalFragmentVariables: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should resolve optionals according to maybeValue",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 343,
                "column": 56
            },
            "line": 343,
            "code": "    it('should resolve optionals according to maybeValue', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n\n        type User {\n          name: String!\n          age: Int\n          address: String!\n          nicknames: [String!]\n          parents: [User!]!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($showProperty: Boolean!) {\n          user {\n            name\n            age\n            address @include(if: $showProperty)\n            nicknames @include(if: $showProperty)\n            parents @include(if: $showProperty)\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          preResolveTypes: true,\n          maybeValue: \"T | 'specialType'\",\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n      expect(content).toBeSimilarStringTo(`\n      export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', name: string, age?: number | 'specialType', address?: string, nicknames?: Array<string> | 'specialType', parents?: Array<User> } };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should include scalars when doing pick",
            "suites": [
                "TypeScript Operations Plugin",
                "Scalars"
            ],
            "updatePoint": {
                "line": 388,
                "column": 46
            },
            "line": 388,
            "code": "    it('Should include scalars when doing pick', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        scalar Date\n        type Query {\n          me: User\n        }\n        type User {\n          id: ID!\n          joinDate: Date!\n        }\n      `);\n\n      const doc = parse(/* GraphQL */ `\n        query {\n          me {\n            id\n            joinDate\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: doc }], config, {\n        outputFile: '',\n      });\n      expect(content).toContain(`Pick<User, 'id' | 'joinDate'>`);\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate custom operation result name",
            "suites": [
                "TypeScript Operations Plugin",
                "Custom Operation Result Name Suffix"
            ],
            "updatePoint": {
                "line": 418,
                "column": 52
            },
            "line": 418,
            "code": "    it('Should generate custom operation result name', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { operationResultSuffix: 'Result', preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type NotificationsQueryVariables = Exact<{ [key: string]: never; }>;`\n      );\n      expect(content).toBeSimilarStringTo(`\n        export type NotificationsQueryResult = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'text' | 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'imageUrl' | 'id'>\n            & { metadata: (\n              { __typename?: 'ImageMetadata' }\n              & Pick<ImageMetadata, 'createdBy'>\n            ) }\n          )> }\n        );\n      `);\n\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should allow custom naming and point to the correct type",
            "suites": [
                "TypeScript Operations Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 467,
                "column": 64
            },
            "line": 467,
            "code": "    it('Should allow custom naming and point to the correct type', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false, namingConvention: 'change-case-all#lowerCase' };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type notificationsquery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<textnotification, 'text' | 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<imagenotification, 'imageUrl' | 'id'>\n            & { metadata: (\n              { __typename?: 'ImageMetadata' }\n              & Pick<imagemetadata, 'createdBy'>\n            ) }\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should allow custom naming and point to the correct type - with custom prefix",
            "suites": [
                "TypeScript Operations Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 510,
                "column": 85
            },
            "line": 510,
            "code": "    it('Should allow custom naming and point to the correct type - with custom prefix', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n\n      const config = { preResolveTypes: false, typesPrefix: 'i', namingConvention: 'change-case-all#lowerCase' };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type inotificationsqueryvariables = Exact<{ [key: string]: never; }>;`\n      );\n      expect(content).toBeSimilarStringTo(`\n        export type inotificationsquery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<itextnotification, 'text' | 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<iimagenotification, 'imageUrl' | 'id'>\n            & { metadata: (\n                { __typename?: 'ImageMetadata' }\n                & Pick<iimagemetadata, 'createdBy'>\n              ) }\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Test for dedupeOperationSuffix",
            "suites": [
                "TypeScript Operations Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 557,
                "column": 38
            },
            "line": 557,
            "code": "    it('Test for dedupeOperationSuffix', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notificationsQuery {\n          notifications {\n            id\n          }\n        }\n\n        fragment MyFragment on Query {\n          notifications {\n            id\n          }\n        }\n      `);\n      const ast2 = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n          }\n        }\n\n        fragment My on Query {\n          notifications {\n            id\n          }\n        }\n      `);\n      const ast3 = parse(/* GraphQL */ `\n        query notificationsQuery {\n          ...MyFragment\n        }\n\n        fragment MyFragment on Query {\n          notifications {\n            id\n          }\n        }\n      `);\n\n      expect(\n        (await plugin(schema, [{ location: 'test-file.ts', document: ast }], {}, { outputFile: '' })).content\n      ).toContain('export type NotificationsQueryQuery =');\n      expect(\n        (await plugin(schema, [{ location: 'test-file.ts', document: ast }], {}, { outputFile: '' })).content\n      ).toContain('export type MyFragmentFragment =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type NotificationsQueryQuery =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type NotificationsQuery =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type MyFragment =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type NotificationsQuery =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type NotificationsQuery =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type MyFragment =');\n\n      const withUsage = (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast3 }],\n          { dedupeOperationSuffix: true, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content;\n      expect(withUsage).toBeSimilarStringTo(`\n        export type MyFragment = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'id'>\n          )> }\n        );\n      `);\n      expect(withUsage).toBeSimilarStringTo(`\n      export type NotificationsQuery = (\n        { __typename?: 'Query' }\n        & { notifications: Array<(\n          { __typename?: 'TextNotification' }\n          & Pick<TextNotification, 'id'>\n        ) | (\n          { __typename?: 'ImageNotification' }\n          & Pick<ImageNotification, 'id'>\n        )> }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Test for omitOperationSuffix",
            "suites": [
                "TypeScript Operations Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 698,
                "column": 34
            },
            "line": 698,
            "code": "  it('Test for omitOperationSuffix', async () => {\n    const ast = parse(/* GraphQL */ `\n      query notificationsQuery {\n        notifications {\n          id\n        }\n      }\n\n      fragment MyFragment on Query {\n        notifications {\n          id\n        }\n      }\n    `);\n    const ast2 = parse(/* GraphQL */ `\n      query notifications {\n        notifications {\n          id\n        }\n      }\n\n      fragment My on Query {\n        notifications {\n          id\n        }\n      }\n    `);\n    const ast3 = parse(/* GraphQL */ `\n      query notifications {\n        ...My\n      }\n\n      fragment My on Query {\n        notifications {\n          id\n        }\n      }\n    `);\n\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast }],\n          { preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type NotificationsQueryQuery =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast }],\n          { preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type MyFragmentFragment =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast }],\n          { omitOperationSuffix: true, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type NotificationsQuery =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast }],\n          { omitOperationSuffix: true, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type MyFragment =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast2 }],\n          { omitOperationSuffix: true, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type Notifications =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast2 }],\n          { omitOperationSuffix: true, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type My =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast2 }],\n          { omitOperationSuffix: false, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type NotificationsQuery =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast2 }],\n          { omitOperationSuffix: false, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type MyFragment =');\n\n    const withUsage = (\n      await plugin(\n        schema,\n        [{ location: 'test-file.ts', document: ast3 }],\n        { omitOperationSuffix: true, preResolveTypes: false },\n        { outputFile: '' }\n      )\n    ).content;\n    expect(withUsage).toBeSimilarStringTo(`\n      export type My = (\n        { __typename?: 'Query' }\n        & { notifications: Array<(\n          { __typename?: 'TextNotification' }\n          & Pick<TextNotification, 'id'>\n        ) | (\n          { __typename?: 'ImageNotification' }\n          & Pick<ImageNotification, 'id'>\n        )> }\n      );\n    `);\n    expect(withUsage).toBeSimilarStringTo(`\n    export type Notifications = (\n      { __typename?: 'Query' }\n      & { notifications: Array<(\n        { __typename?: 'TextNotification' }\n        & Pick<TextNotification, 'id'>\n      ) | (\n        { __typename?: 'ImageNotification' }\n        & Pick<ImageNotification, 'id'>\n      )> }\n    );\n    `);\n  });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should ignore __typename for root types with skipTypeNameForRoot = true",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 853,
                "column": 79
            },
            "line": 853,
            "code": "    it('Should ignore __typename for root types with skipTypeNameForRoot = true', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Test {\n          foo: String\n        }\n\n        type Query {\n          test: Test\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query q1 {\n          test {\n            foo\n          }\n        }\n      `);\n      const config = {\n        skipTypeNameForRoot: true,\n        preResolveTypes: false,\n      };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type Q1Query = { test?: Maybe<(\n          { __typename?: 'Test' }\n          & Pick<Test, 'foo'>\n        )> };`\n      );\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should ignore __typename for root types with skipTypeNameForRoot = true, and with nonOptionalTypename = true",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 887,
                "column": 116
            },
            "line": 887,
            "code": "    it('Should ignore __typename for root types with skipTypeNameForRoot = true, and with nonOptionalTypename = true', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Test {\n          foo: String\n        }\n\n        type Query {\n          test: Test\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query q1 {\n          test {\n            foo\n          }\n        }\n      `);\n      const config = {\n        nonOptionalTypename: true,\n        skipTypeNameForRoot: true,\n        preResolveTypes: false,\n      };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type Q1Query = { test?: Maybe<(\n          { __typename: 'Test' }\n          & Pick<Test, 'foo'>\n        )> };`\n      );\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should ignore skipTypeNameForRoot = true when __typename is specified manually",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 922,
                "column": 86
            },
            "line": 922,
            "code": "    it('Should ignore skipTypeNameForRoot = true when __typename is specified manually', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Test {\n          foo: String\n        }\n\n        type Query {\n          test: Test\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query q1 {\n          __typename\n          test {\n            foo\n          }\n        }\n      `);\n      const config = {\n        nonOptionalTypename: true,\n        skipTypeNameForRoot: true,\n        preResolveTypes: false,\n      };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type Q1Query = (\n          { __typename: 'Query' }\n          & { test?: Maybe<(\n            { __typename: 'Test' }\n            & Pick<Test, 'foo'>\n          )> }\n        );`\n      );\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename correctly with nonOptionalTypename=false,skipTypename=true,preResolveTypes=true and explicit field",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 961,
                "column": 128
            },
            "line": 961,
            "code": "    it('Should add __typename correctly with nonOptionalTypename=false,skipTypename=true,preResolveTypes=true and explicit field', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Search {\n          search: [SearchResult!]!\n        }\n\n        type Movie {\n          id: ID!\n          title: String!\n        }\n        type Person {\n          id: ID!\n          name: String!\n        }\n\n        union SearchResult = Movie | Person\n\n        type Query {\n          search(term: String!): [SearchResult!]!\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query q1 {\n          search {\n            ... on Movie {\n              __typename\n              id\n              title\n            }\n            ... on Person {\n              __typename\n              id\n              name\n            }\n          }\n        }\n\n        query q2 {\n          search {\n            __typename\n            ... on Movie {\n              id\n              title\n            }\n            ... on Person {\n              id\n              name\n            }\n          }\n        }\n      `);\n      const config = {\n        nonOptionalTypename: false,\n        skipTypename: true,\n      };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toContain(\n        `export type Q1Query = { search: Array<{ __typename: 'Movie', id: string, title: string } | { __typename: 'Person', id: string, name: string }> };`\n      );\n      expect(content).toContain(\n        `export type Q2Query = { search: Array<{ __typename: 'Movie', id: string, title: string } | { __typename: 'Person', id: string, name: string }> };`\n      );\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should skip __typename when skipTypename is set to true",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1029,
                "column": 63
            },
            "line": 1029,
            "code": "    it('Should skip __typename when skipTypename is set to true', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).not.toContain(`__typename`);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename when dealing with fragments",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1044,
                "column": 57
            },
            "line": 1044,
            "code": "    it('Should add __typename when dealing with fragments', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Node {\n          id: ID!\n        }\n\n        type A implements Node {\n          id: ID!\n          A: String\n        }\n\n        type B implements Node {\n          id: ID!\n          B: String\n        }\n\n        type Query {\n          some: Node\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        fragment Node on Node {\n          __typename\n          id\n        }\n\n        query Test {\n          some {\n            ...Node\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n      export type TestQuery = (\n        { __typename?: 'Query' }\n        & { some?: Maybe<(\n          { __typename: 'A' }\n          & Pick<A, 'id'>\n        ) | (\n          { __typename: 'B' }\n          & Pick<B, 'id'>\n        )> }\n      );\n      `);\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add aliased __typename correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1095,
                "column": 47
            },
            "line": 1095,
            "code": "    it('Should add aliased __typename correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          type: __typename\n          dummy\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n      export type Unnamed_1_Query = (\n        { __typename?: 'Query' }\n        & Pick<Query, 'dummy'>\n        & { type: 'Query' }\n      );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add aliased __typename correctly with preResovleTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1116,
                "column": 68
            },
            "line": 1116,
            "code": "    it('Should add aliased __typename correctly with preResovleTypes', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          type: __typename\n          dummy\n        }\n      `);\n      const config = { preResolveTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = { __typename?: 'Query', dummy?: string | null, type: 'Query' };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename as non-optional when explicitly specified",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1133,
                "column": 71
            },
            "line": 1133,
            "code": "    it('Should add __typename as non-optional when explicitly specified', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          __typename\n          dummy\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = (\n          { __typename: 'Query' }\n          & Pick<Query, 'dummy'>\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename as non-optional when forced",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1153,
                "column": 57
            },
            "line": 1153,
            "code": "    it('Should add __typename as non-optional when forced', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          dummy\n        }\n      `);\n      const config = { nonOptionalTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = (\n          { __typename: 'Query' }\n          & Pick<Query, 'dummy'>\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename as optional when its not specified",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1172,
                "column": 64
            },
            "line": 1172,
            "code": "    it('Should add __typename as optional when its not specified', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          dummy\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = (\n          { __typename?: 'Query' }\n          & Pick<Query, 'dummy'>\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename as non-optional when its explictly specified, even if skipTypename is true",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1191,
                "column": 104
            },
            "line": 1191,
            "code": "    it('Should add __typename as non-optional when its explictly specified, even if skipTypename is true', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          __typename\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = (\n          { __typename: 'Query' }\n          & Pick<Query, 'dummy'>\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename correctly when unions are in use",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1212,
                "column": 62
            },
            "line": 1212,
            "code": "    it('Should add __typename correctly when unions are in use', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          unionTest {\n            ... on User {\n              id\n            }\n\n            ... on Profile {\n              age\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type UnionTestQuery = (\n          { __typename?: 'Query' }\n          & { unionTest?: Maybe<(\n            { __typename?: 'User' }\n            & Pick<User, 'id'>\n          ) | (\n            { __typename?: 'Profile' }\n            & Pick<Profile, 'age'>\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename correctly when interfaces are in use",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1245,
                "column": 66
            },
            "line": 1245,
            "code": "    it('Should add __typename correctly when interfaces are in use', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type NotificationsQuery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'text' | 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'imageUrl' | 'id'>\n            & { metadata: (\n                { __typename?: 'ImageMetadata' }\n                & Pick<ImageMetadata, 'createdBy'>\n              ) }\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should mark __typename as non optional in case it is included in the selection set of an interface field",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1286,
                "column": 112
            },
            "line": 1286,
            "code": "    it('should mark __typename as non optional in case it is included in the selection set of an interface field', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            __typename\n            ... on TextNotification {\n              text\n            }\n            ... on ImageNotification {\n              imageUrl\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type NotificationsQuery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename: 'TextNotification' }\n            & Pick<TextNotification, 'text'>\n          ) | (\n            { __typename: 'ImageNotification' }\n            & Pick<ImageNotification, 'imageUrl'>\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should mark __typename as non optional in case it is included in the selection set of an union field",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1318,
                "column": 108
            },
            "line": 1318,
            "code": "    it('should mark __typename as non optional in case it is included in the selection set of an union field', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          unionTest {\n            __typename\n            ... on Profile {\n              firstName\n            }\n            ... on User {\n              email\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n      { __typename?: 'Query' }\n      & { unionTest?: Maybe<(\n        { __typename: 'User' }\n        & Pick<User, 'email'>\n      ) | (\n        { __typename: 'Profile' }\n        & Pick<Profile, 'firstName'>\n      )> }\n    );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle unnamed documents correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Unnamed Documents"
            ],
            "updatePoint": {
                "line": 1352,
                "column": 49
            },
            "line": 1352,
            "code": "    it('Should handle unnamed documents correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = Pick<Query, 'dummy'>;\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle unnamed documents correctly with multiple documents",
            "suites": [
                "TypeScript Operations Plugin",
                "Unnamed Documents"
            ],
            "updatePoint": {
                "line": 1371,
                "column": 73
            },
            "line": 1371,
            "code": "    it('Should handle unnamed documents correctly with multiple documents', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          dummy\n        }\n\n        query {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = Pick<Query, 'dummy'>;\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_2_Query = Pick<Query, 'dummy'>;\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_2_QueryVariables = Exact<{ [key: string]: never; }>;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should detect invalid types as parent and notify",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1403,
                "column": 56
            },
            "line": 1403,
            "code": "    it('Should detect invalid types as parent and notify', async () => {\n      const ast = parse(/* GraphQL */ `\n        mutation test {\n          test\n        }\n      `);\n      const config = { preResolveTypes: false };\n\n      try {\n        await plugin(\n          buildSchema(/* GraphQL */ `\n            type Query {\n              foo: String\n            }\n          `),\n          [{ location: 'test-file.ts', document: ast }],\n          config,\n          { outputFile: '' }\n        );\n        expect(true).toBeFalsy();\n      } catch (e) {\n        expect(e.message).toBe('Unable to find root schema type for operation type \"mutation\"!');\n      }\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should have valid __typename usage and split types according to that (with usage)",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1428,
                "column": 89
            },
            "line": 1428,
            "code": "    it('Should have valid __typename usage and split types according to that (with usage)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        scalar IPV4\n        scalar IPV6\n\n        type IPV4Route {\n          address: IPV4\n          gateway: IPV4\n        }\n\n        type IPV6Route {\n          address: IPV6\n          gateway: IPV6\n        }\n\n        union RouteUnion = IPV4Route | IPV6Route\n\n        type Query {\n          routes: [RouteUnion!]!\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        fragment NetRoute on RouteUnion {\n          __typename\n          ... on IPV4Route {\n            ipv4Address: address\n            ipv4Gateway: gateway\n          }\n          ... on IPV6Route {\n            ipv6Address: address\n            ipv6Gateway: gateway\n          }\n        }\n\n        query QQ {\n          routes {\n            ...NetRoute\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      const usage = `\n      type Route = QqQuery['routes'][0];\n\n      function validateGateway(route: Route) {\n          if (route.__typename === 'IPV4Route') {\n              console.log(route.ipv4Gateway)\n          } else {\n              console.log(route.ipv6Gateway)\n          }\n      }\n      `;\n\n      await validate(content, config, testSchema, usage);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct __typename when using fragment over type",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1489,
                "column": 76
            },
            "line": 1489,
            "code": "    it('Should generate the correct __typename when using fragment over type', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n        }\n\n        type User {\n          id: ID!\n          name: String\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query userQuery {\n          user {\n            ... on User {\n              id\n              name\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      await validate(content, config, testSchema);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct __typename when using both inline fragment and spread over type",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1518,
                "column": 99
            },
            "line": 1518,
            "code": "    it('Should generate the correct __typename when using both inline fragment and spread over type', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n        }\n\n        type User {\n          id: ID!\n          name: String\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query userQuery {\n          user {\n            ... on User {\n              ...user\n            }\n          }\n        }\n\n        fragment user on User {\n          id\n          name\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      await validate(content, config, testSchema);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct __typename when using fragment spread over type",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1551,
                "column": 83
            },
            "line": 1551,
            "code": "    it('Should generate the correct __typename when using fragment spread over type', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n        }\n\n        type User {\n          id: ID!\n          name: String\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query userQuery {\n          user {\n            ...user\n          }\n        }\n\n        fragment user on User {\n          id\n          name\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      await validate(content, config, testSchema);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct __typename when using fragment spread over union",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1582,
                "column": 84
            },
            "line": 1582,
            "code": "    it('Should generate the correct __typename when using fragment spread over union', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n        }\n\n        type Error {\n          message: String!\n        }\n\n        union UserResult = User | Error\n\n        type Query {\n          user: UserResult!\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        fragment UserFragment on User {\n          id\n        }\n        query aaa {\n          user {\n            ...UserFragment\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      await validate(\n        content,\n        config,\n        testSchema,\n        `function test(q: AaaQuery) {\n        console.log(q.user.__typename === 'User' ? q.user.id : null);\n        console.log(q.user.__typename === 'Error' ? q.user.__typename : null);\n      }`\n      );\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should have valid fragments intersection on different types (with usage) #2498",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1624,
                "column": 86
            },
            "line": 1624,
            "code": "    it('Should have valid fragments intersection on different types (with usage) #2498', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface User {\n          id: ID!\n        }\n\n        type Tom implements User {\n          id: ID!\n          foo: String!\n        }\n\n        type Jerry implements User {\n          id: ID!\n          bar: String!\n        }\n\n        type Query {\n          user: User\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        fragment tom on Tom {\n          id\n          foo\n        }\n\n        fragment jerry on Jerry {\n          id\n          bar\n        }\n\n        fragment user on User {\n          ...tom\n          ...jerry\n        }\n\n        query userQuery {\n          user {\n            ...user\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      await validate(\n        content,\n        config,\n        testSchema,\n        `\n          function test(a: UserFragment) {\n              if (a.__typename === 'Tom') {\n                  console.log(a.foo);\n              } else if (a.__typename === 'Jerry') {\n                  console.log(a.bar);\n              }\n          }`\n      );\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should have valid __typename usage and split types according to that (with usage)",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1687,
                "column": 89
            },
            "line": 1687,
            "code": "    it('Should have valid __typename usage and split types according to that (with usage)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        scalar IPV4\n        scalar IPV6\n\n        type IPV4Route {\n          address: IPV4\n          gateway: IPV4\n        }\n\n        type IPV6Route {\n          address: IPV6\n          gateway: IPV6\n        }\n\n        union RouteUnion = IPV4Route | IPV6Route\n\n        type Query {\n          routes: [RouteUnion!]!\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        fragment NetRoute on RouteUnion {\n          __typename\n          ... on IPV4Route {\n            ipv4Address: address\n            ipv4Gateway: gateway\n          }\n          ...test\n        }\n\n        fragment test on IPV6Route {\n          ipv6Address: address\n          ipv6Gateway: gateway\n        }\n\n        query QQ {\n          routes {\n            ...NetRoute\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      const usage = `\n      type Route = QqQuery['routes'][0];\n\n      function validateGateway(route: Route) {\n          if (route.__typename === 'IPV4Route') {\n              console.log(route.ipv4Gateway)\n          } else {\n              console.log(route.ipv6Gateway)\n          }\n      }\n      `;\n\n      await validate(content, config, testSchema, usage);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support fragment spread correctly with simple type with no other fields",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1750,
                "column": 86
            },
            "line": 1750,
            "code": "    it('Should support fragment spread correctly with simple type with no other fields', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n          username\n          profile {\n            age\n          }\n          role\n        }\n\n        query me {\n          me {\n            ...UserFields\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type MeQuery = { me?: Maybe<(\n            Pick<User, 'id' | 'username' | 'role'>\n            & { profile?: Maybe<Pick<Profile, 'age'>> }\n          )> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support fragment spread correctly with simple type with other fields",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1780,
                "column": 83
            },
            "line": 1780,
            "code": "    it('Should support fragment spread correctly with simple type with other fields', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n          profile {\n            age\n          }\n        }\n\n        query me {\n          me {\n            ...UserFields\n            username\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type MeQuery = { me?: Maybe<(\n        Pick<User, 'username' | 'id'>\n        & { profile?: Maybe<Pick<Profile, 'age'>> }\n      )> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support fragment spread correctly with multiple fragment spread",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1810,
                "column": 78
            },
            "line": 1810,
            "code": "    it('Should support fragment spread correctly with multiple fragment spread', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n        }\n\n        fragment UserProfile on User {\n          profile {\n            age\n          }\n        }\n\n        query me {\n          me {\n            ...UserFields\n            ...UserProfile\n            username\n          }\n        }\n      `);\n      const config = { skipTypename: false, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type MeQuery = (\n        { __typename?: 'Query' }\n        & { me?: Maybe<(\n          { __typename?: 'User' }\n          & Pick<User, 'username' | 'id'>\n          & { profile?: Maybe<(\n            { __typename?: 'Profile' }\n            & Pick<Profile, 'age'>\n          )> }\n        )> }\n      );\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type UserProfileFragment = (\n          { __typename?: 'User' }\n          & { profile?: Maybe<(\n            { __typename?: 'Profile' }\n            & Pick<Profile, 'age'>\n          )> }\n        );\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type UserFieldsFragment = (\n          { __typename?: 'User' }\n          & Pick<User, 'id'>\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct intersection for fragments when using with interfaces with different type",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1866,
                "column": 109
            },
            "line": 1866,
            "code": "    it('Should generate the correct intersection for fragments when using with interfaces with different type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Base {\n          id: ID!\n        }\n\n        type A implements Base {\n          id: ID!\n          x: Int!\n        }\n\n        type B implements Base {\n          id: ID!\n          y: Int!\n        }\n\n        type Query {\n          b: Base\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query {\n          b {\n            ...a\n            ...b\n          }\n        }\n\n        fragment a on A {\n          id\n          x\n        }\n\n        fragment b on B {\n          id\n          y\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type Unnamed_1_Query = (\n        { __typename?: 'Query' }\n        & { b?: Maybe<(\n          { __typename?: 'A' }\n          & Pick<A, 'id' | 'x'>\n        ) | (\n          { __typename?: 'B' }\n          & Pick<B, 'id' | 'y'>\n        )> }\n      );\n\n      export type AFragment = (\n        { __typename?: 'A' }\n        & Pick<A, 'id' | 'x'>\n      );\n\n      export type BFragment = (\n        { __typename?: 'B' }\n        & Pick<B, 'id' | 'y'>\n      );\n      `);\n      await validate(content, config, schema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct intersection for fragments when type implements 2 interfaces",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1935,
                "column": 96
            },
            "line": 1935,
            "code": "    it('Should generate the correct intersection for fragments when type implements 2 interfaces', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Base1 {\n          foo: String!\n        }\n\n        interface Base2 {\n          bar: String!\n        }\n\n        type MyType implements Base1 & Base2 {\n          foo: String!\n          bar: String!\n          test: String!\n        }\n\n        type Query {\n          myType: MyType!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query {\n          myType {\n            ...a\n            ...b\n            ...c\n          }\n        }\n\n        fragment c on MyType {\n          test\n        }\n\n        fragment a on Base1 {\n          foo\n        }\n\n        fragment b on Base2 {\n          bar\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n      export type Unnamed_1_Query = (\n        { __typename?: 'Query' }\n        & { myType: (\n          { __typename?: 'MyType' }\n          & Pick<MyType, 'foo' | 'bar' | 'test'>\n        ) }\n      );\n      `);\n      await validate(content, config, schema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct intersection for fragments when using with interfaces with same type",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1993,
                "column": 104
            },
            "line": 1993,
            "code": "    it('Should generate the correct intersection for fragments when using with interfaces with same type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Base {\n          id: ID!\n        }\n\n        type A implements Base {\n          id: ID!\n          x: Int!\n        }\n\n        type B implements Base {\n          id: ID!\n          y: Int!\n        }\n\n        type Query {\n          b: Base\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query {\n          b {\n            ...a\n            ...b\n          }\n        }\n\n        fragment a on A {\n          id\n        }\n\n        fragment b on A {\n          x\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type Unnamed_1_Query = (\n        { __typename?: 'Query' }\n        & { b?: Maybe<(\n          { __typename?: 'A' }\n          & Pick<A, 'id' | 'x'>\n        ) | { __typename?: 'B' }> }\n      );\n\n        export type AFragment = (\n          { __typename?: 'A' }\n          & Pick<A, 'id'>\n        );\n\n        export type BFragment = (\n          { __typename?: 'A' }\n          & Pick<A, 'x'>\n        );\n      `);\n      validateTs(mergeOutputs([content]), config);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support interfaces correctly when used with inline fragments",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2058,
                "column": 75
            },
            "line": 2058,
            "code": "    it('Should support interfaces correctly when used with inline fragments', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type NotificationsQuery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'text' | 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'imageUrl' | 'id'>\n            & { metadata: (\n                { __typename?: 'ImageMetadata' }\n                & Pick<ImageMetadata, 'createdBy'>\n              ) }\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support union correctly when used with inline fragments",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2101,
                "column": 70
            },
            "line": 2101,
            "code": "    it('Should support union correctly when used with inline fragments', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          unionTest {\n            ... on User {\n              id\n            }\n\n            ... on Profile {\n              age\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type UnionTestQuery = (\n          { __typename?: 'Query' }\n            & { unionTest?: Maybe<(\n            { __typename?: 'User' }\n            & Pick<User, 'id'>\n          ) | (\n            { __typename?: 'Profile' }\n            & Pick<Profile, 'age'>\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support union correctly when used with inline fragments on types implementing common interface",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2135,
                "column": 109
            },
            "line": 2135,
            "code": "    it('Should support union correctly when used with inline fragments on types implementing common interface', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          mixedNotifications {\n            ... on Notifiction {\n              id\n            }\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type UnionTestQuery = (\n          { __typename?: 'Query' }\n          & { mixedNotifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'id' | 'text'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'id' | 'imageUrl'>\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support union correctly when used with inline fragments on types implementing common interface and also other types",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2173,
                "column": 130
            },
            "line": 2173,
            "code": "    it('Should support union correctly when used with inline fragments on types implementing common interface and also other types', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          search(term: \"a\") {\n            ... on User {\n              id\n            }\n\n            ... on Notifiction {\n              id\n            }\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type UnionTestQuery = (\n          { __typename?: 'Query' }\n          & { search: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'id' | 'text'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'id' | 'imageUrl'>\n          ) | (\n            { __typename?: 'User' }\n            & Pick<User, 'id'>\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support merging identical fragment union types",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2218,
                "column": 61
            },
            "line": 2218,
            "code": "    it('Should support merging identical fragment union types', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test {\n          notifications {\n            ...N\n          }\n        }\n\n        fragment N on Notifiction {\n          id\n        }\n      `);\n      const config = { preResolveTypes: true, mergeFragmentTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type TestQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type TestQuery = (\n          { notifications: Array<(\n            { id: string }\n            & { __typename?: 'TextNotification' | 'ImageNotification' }\n          )> }\n          & { __typename?: 'Query' }\n        );\n\n        export type NFragment = (\n          { id: string }\n          & { __typename?: 'TextNotification' | 'ImageNotification' }\n        );\n     `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support computing correct names for merged fragment union types",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2254,
                "column": 78
            },
            "line": 2254,
            "code": "    it('Should support computing correct names for merged fragment union types', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment N on Notifiction {\n          id\n          ... on TextNotification {\n            text\n          }\n        }\n      `);\n      const config = { preResolveTypes: true, mergeFragmentTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        type N_TextNotification_Fragment = (\n          { text: string, id: string }\n          & { __typename?: 'TextNotification' }\n        );\n\n        type N_ImageNotification_Fragment = (\n          { id: string }\n          & { __typename?: 'ImageNotification' }\n        );\n\n        export type NFragment = N_TextNotification_Fragment | N_ImageNotification_Fragment;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support computing correct names for large merged fragment union types",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2284,
                "column": 84
            },
            "line": 2284,
            "code": "    it('Should support computing correct names for large merged fragment union types', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Node {\n          id: ID!\n        }\n\n        type A implements Node {\n          id: ID!\n          text: String!\n        }\n\n        type B implements Node {\n          id: ID!\n          text: String!\n        }\n\n        type C implements Node {\n          id: ID!\n          text: String!\n        }\n\n        type D implements Node {\n          id: ID!\n          text: String!\n        }\n\n        type E implements Node {\n          id: ID!\n          text: String!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        fragment N on Node {\n          id\n          ... on A {\n            text\n          }\n        }\n      `);\n      const config = { preResolveTypes: true, mergeFragmentTypes: true };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n         type N_A_Fragment = (\n           { text: string, id: string }\n           & { __typename?: 'A' }\n         );\n\n         type N_ZhJjUzpMTyh98zugnx0IKwiLetPNjV8KYbSlmpAeuu_Fragment = (\n           { id: string }\n           & { __typename?: 'B' | 'C' | 'D' | 'E' }\n         );\n\n         export type NFragment = N_A_Fragment | N_ZhJjUzpMTyh98zugnx0IKwiLetPNjV8KYbSlmpAeuu_Fragment;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should not create empty types when merging fragment union types",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2345,
                "column": 71
            },
            "line": 2345,
            "code": "    it('Should not create empty types when merging fragment union types', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment N on Query {\n          notifications {\n            ... on TextNotification {\n              text\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: true, mergeFragmentTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n       export type NFragment = (\n         { notifications: Array<(\n           { text: string }\n           & { __typename?: 'TextNotification' }\n         ) | { __typename?: 'ImageNotification' }> }\n         & { __typename?: 'Query' }\n       );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support merging identical fragment union types with skipTypename",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2372,
                "column": 79
            },
            "line": 2372,
            "code": "    it('Should support merging identical fragment union types with skipTypename', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test {\n          notifications {\n            ...N\n          }\n        }\n\n        fragment N on Notifiction {\n          id\n        }\n      `);\n      const config = { preResolveTypes: true, skipTypename: true, mergeFragmentTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type TestQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type TestQuery = { notifications: Array<{ id: string }> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support computing correct names for merged fragment union types with skipTypename",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2397,
                "column": 96
            },
            "line": 2397,
            "code": "    it('Should support computing correct names for merged fragment union types with skipTypename', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment N on Notifiction {\n          id\n          ... on TextNotification {\n            text\n          }\n        }\n      `);\n      const config = { preResolveTypes: true, skipTypename: true, mergeFragmentTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n       type N_TextNotification_Fragment = { text: string, id: string };\n\n       type N_ImageNotification_Fragment = { id: string };\n\n       export type NFragment = N_TextNotification_Fragment | N_ImageNotification_Fragment;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Ignores merging when enabled alongside inline fragment masking",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2421,
                "column": 70
            },
            "line": 2421,
            "code": "    it('Ignores merging when enabled alongside inline fragment masking', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test {\n          notifications {\n            ...N\n          }\n        }\n\n        fragment N on Notifiction {\n          id\n        }\n      `);\n      const config = { preResolveTypes: true, mergeFragmentTypes: true, inlineFragmentTypes: 'mask' } as const;\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n       export type TestQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n       export type TestQuery = { __typename?: 'Query', notifications: Array<(\n        { __typename?: 'TextNotification' }\n        & { ' $fragmentRefs'?: { 'N_TextNotification_Fragment': N_TextNotification_Fragment } }\n       ) | (\n        { __typename?: 'ImageNotification' }\n        & { ' $fragmentRefs'?: { 'N_ImageNotification_Fragment': N_ImageNotification_Fragment } }\n       )> };\n\n       type N_TextNotification_Fragment = { __typename?: 'TextNotification', id: string } & { ' $fragmentName'?: 'N_TextNotification_Fragment' };\n\n       type N_ImageNotification_Fragment = { __typename?: 'ImageNotification', id: string } & { ' $fragmentName'?: 'N_ImageNotification_Fragment' };\n\n       export type NFragment = N_TextNotification_Fragment | N_ImageNotification_Fragment;\n     `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support inline fragments",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2459,
                "column": 39
            },
            "line": 2459,
            "code": "    it('Should support inline fragments', async () => {\n      const ast = parse(/* GraphQL */ `\n        query currentUser {\n          me {\n            id\n            ... on User {\n              username\n              profile {\n                age\n              }\n            }\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type CurrentUserQuery = { me?: Maybe<(\n            Pick<User, 'username' | 'id'>\n            & { profile?: Maybe<Pick<Profile, 'age'>> }\n        )> };\n      `);\n\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on basic query on GitHub schema",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2487,
                "column": 80
            },
            "line": 2487,
            "code": "    it('Should build a basic selection set based on basic query on GitHub schema', async () => {\n      const ast = parse(/* GraphQL */ `\n        query me($repoFullName: String!) {\n          currentUser {\n            login\n            html_url\n          }\n          entry(repoFullName: $repoFullName) {\n            id\n            postedBy {\n              login\n              html_url\n            }\n            createdAt\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(gitHuntSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type MeQueryVariables = Exact<{\n          repoFullName: Scalars['String'];\n        }>;`\n      );\n      expect(content).toBeSimilarStringTo(`\n        export type MeQuery = { currentUser?: Maybe<Pick<User, 'login' | 'html_url'>>, entry?: Maybe<(\n          Pick<Entry, 'id' | 'createdAt'>\n          & { postedBy: Pick<User, 'login' | 'html_url'> }\n        )> };\n      `);\n      await validate(content, config, gitHuntSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on basic query on GitHub schema with preResolveTypes=true",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2523,
                "column": 106
            },
            "line": 2523,
            "code": "    it('Should build a basic selection set based on basic query on GitHub schema with preResolveTypes=true', async () => {\n      const ast = parse(/* GraphQL */ `\n        query me($repoFullName: String!) {\n          currentUser {\n            login\n            html_url\n          }\n          entry(repoFullName: $repoFullName) {\n            id\n            postedBy {\n              login\n              html_url\n            }\n            createdAt\n          }\n        }\n      `);\n      const config = { preResolveTypes: true };\n      const { content } = await plugin(gitHuntSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type MeQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', login: string, html_url: string } | null, entry?: { __typename?: 'Entry', id: number, createdAt: number, postedBy: { __typename?: 'User', login: string, html_url: string } } | null };\n      `);\n      await validate(content, config, gitHuntSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should produce valid output with preResolveTypes=true and enums",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2551,
                "column": 71
            },
            "line": 2551,
            "code": "    it('Should produce valid output with preResolveTypes=true and enums', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test {\n          info {\n            ...information\n          }\n        }\n\n        fragment information on Information {\n          entries {\n            id\n            value\n          }\n        }\n      `);\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Information {\n          entries: [Information_Entry!]!\n        }\n\n        enum Information_EntryType {\n          NAME\n          ADDRESS\n        }\n\n        type Information_Entry {\n          id: Information_EntryType!\n          value: String\n        }\n\n        type Query {\n          info: Information\n        }\n      `);\n      const config = { preResolveTypes: true };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      const o = await validate(content, config, testSchema);\n      expect(o).toContain(`export enum Information_EntryType {`);\n      expect(o).toContain(`__typename?: 'Information_Entry', id: Information_EntryType,`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should produce valid output with preResolveTypes=true and enums with prefixes set",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2595,
                "column": 89
            },
            "line": 2595,
            "code": "    it('Should produce valid output with preResolveTypes=true and enums with prefixes set', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test($e: Information_EntryType!) {\n          info {\n            ...information\n          }\n          infoArgTest(e: $e) {\n            ...information\n          }\n        }\n\n        fragment information on Information {\n          entries {\n            id\n            value\n          }\n        }\n      `);\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Information {\n          entries: [Information_Entry!]!\n        }\n\n        enum Information_EntryType {\n          NAME\n          ADDRESS\n        }\n\n        type Information_Entry {\n          id: Information_EntryType!\n          value: String\n        }\n\n        type Query {\n          infoArgTest(e: Information_EntryType!): Information\n          info: Information\n        }\n      `);\n      const config = { preResolveTypes: true, typesPrefix: 'I', enumPrefix: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      const o = await validate(content, config, testSchema);\n      expect(o).toBeSimilarStringTo(` export type ITestQueryVariables = Exact<{\n        e: Information_EntryType;\n      }>;`);\n      expect(o).toContain(`export type IQuery = {`);\n      expect(o).toContain(`export enum Information_EntryType {`);\n      expect(o).toContain(`__typename?: 'Information_Entry', id: Information_EntryType,`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on basic query",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2647,
                "column": 63
            },
            "line": 2647,
            "code": "    it('Should build a basic selection set based on basic query', async () => {\n      const ast = parse(/* GraphQL */ `\n        query dummy {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type DummyQuery = Pick<Query, 'dummy'>;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on basic query with field aliasing for basic scalar",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2664,
                "column": 100
            },
            "line": 2664,
            "code": "    it('Should build a basic selection set based on basic query with field aliasing for basic scalar', async () => {\n      const ast = parse(/* GraphQL */ `\n        query dummy {\n          customName: dummy\n          customName2: dummyWithType {\n            age\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type DummyQuery = (\n          { customName: Query['dummy'] }\n          & { customName2?: Maybe<Pick<Profile, 'age'>> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on a query with inner fields",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2687,
                "column": 77
            },
            "line": 2687,
            "code": "    it('Should build a basic selection set based on a query with inner fields', async () => {\n      const ast = parse(/* GraphQL */ `\n        query currentUser {\n          me {\n            id\n            username\n            role\n            profile {\n              age\n            }\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type CurrentUserQuery = { me?: Maybe<(\n          Pick<User, 'id' | 'username' | 'role'>\n          & { profile?: Maybe<Pick<Profile, 'age'>> }\n        )> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build fragment definition correctly - with name and selection set",
            "suites": [
                "TypeScript Operations Plugin",
                "Fragment Definition"
            ],
            "updatePoint": {
                "line": 2716,
                "column": 80
            },
            "line": 2716,
            "code": "    it('Should build fragment definition correctly - with name and selection set', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n          username\n          profile {\n            age\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type UserFieldsFragment = (\n          Pick<User, 'id' | 'username'>\n          & { profile?: Maybe<Pick<Profile, 'age'>> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should detect Mutation correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2742,
                "column": 40
            },
            "line": 2742,
            "code": "    it('Should detect Mutation correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        mutation login {\n          login(username: \"1\", password: \"2\") {\n            id\n            username\n            profile {\n              age\n            }\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type LoginMutation = { login?: Maybe<(\n          Pick<User, 'id' | 'username'>\n          & { profile?: Maybe<Pick<Profile, 'age'>> }\n        )> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should detect Query correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2768,
                "column": 37
            },
            "line": 2768,
            "code": "    it('Should detect Query correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type TestQuery = Pick<Query, 'dummy'>;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should detect Subscription correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2785,
                "column": 44
            },
            "line": 2785,
            "code": "    it('Should detect Subscription correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        subscription test {\n          userCreated {\n            id\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type TestSubscription = { userCreated?: Maybe<Pick<User, 'id'>> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle operation variables correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2804,
                "column": 51
            },
            "line": 2804,
            "code": "    it('Should handle operation variables correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        query testQuery(\n          $username: String\n          $email: String\n          $password: String!\n          $input: InputType\n          $mandatoryInput: InputType!\n          $testArray: [String]\n          $requireString: [String]!\n          $innerRequired: [String!]!\n        ) {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type TestQueryQueryVariables = Exact<{\n          username?: InputMaybe<Scalars['String']>;\n          email?: InputMaybe<Scalars['String']>;\n          password: Scalars['String'];\n          input?: InputMaybe<InputType>;\n          mandatoryInput: InputType;\n          testArray?: InputMaybe<Array<InputMaybe<Scalars['String']>> | InputMaybe<Scalars['String']>>;\n          requireString: Array<InputMaybe<Scalars['String']>> | InputMaybe<Scalars['String']>;\n          innerRequired: Array<Scalars['String']> | Scalars['String'];\n        }>;`\n      );\n      await validate(content, config, schema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle operation variables correctly when they use custom scalars",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2839,
                "column": 80
            },
            "line": 2839,
            "code": "    it('Should handle operation variables correctly when they use custom scalars', async () => {\n      const ast = parse(/* GraphQL */ `\n        query testQuery($test: DateTime) {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type TestQueryQueryVariables = Exact<{\n          test?: InputMaybe<Scalars['DateTime']>;\n        }>;`\n      );\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should create empty variables when there are no operation variables",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2858,
                "column": 75
            },
            "line": 2858,
            "code": "    it('Should create empty variables when there are no operation variables', async () => {\n      const ast = parse(/* GraphQL */ `\n        query testQuery {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`export type TestQueryQueryVariables = Exact<{ [key: string]: never; }>;`);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "avoid duplicates - each type name should be unique",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2873,
                "column": 58
            },
            "line": 2873,
            "code": "    it('avoid duplicates - each type name should be unique', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type DeleteMutation {\n          deleted: Boolean!\n        }\n        type UpdateMutation {\n          updated: Boolean!\n        }\n        union MessageMutationType = DeleteMutation | UpdateMutation\n        type Query {\n          dummy: String\n        }\n        type Mutation {\n          mutation(message: String!, type: String!): MessageMutationType!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        mutation SubmitMessage($message: String!) {\n          mutation(message: $message) {\n            ... on DeleteMutation {\n              deleted\n            }\n            ... on UpdateMutation {\n              updated\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type SubmitMessageMutation = (\n          { __typename?: 'Mutation' }\n          & { mutation: (\n            { __typename?: 'DeleteMutation' }\n            & Pick<DeleteMutation, 'deleted'>\n          ) | (\n            { __typename?: 'UpdateMutation' }\n          & Pick<UpdateMutation, 'updated'>\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should use __typename in fragments when requested",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2925,
                "column": 57
            },
            "line": 2925,
            "code": "    it('should use __typename in fragments when requested', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Post {\n          title: String\n        }\n        type Query {\n          post: Post!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query Post {\n          post {\n            ... on Post {\n              __typename\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type PostQuery = (\n          { __typename?: 'Query' }\n          & { post: { __typename: 'Post' } }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should handle introspection types (__schema)",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2961,
                "column": 52
            },
            "line": 2961,
            "code": "    it('should handle introspection types (__schema)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Post {\n          title: String\n        }\n        type Query {\n          post: Post!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query Info {\n          __schema {\n            queryType {\n              fields {\n                name\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type InfoQuery = (\n          { __typename?: 'Query' }\n          & { __schema: (\n            { __typename?: '__Schema' }\n            & { queryType: (\n              { __typename?: '__Type' }\n              & { fields?: Maybe<Array<(\n                { __typename?: '__Field' }\n                & Pick<__Field, 'name'>\n              )>> }\n            ) }\n          ) }\n        );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should handle introspection types (__type)",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 3007,
                "column": 50
            },
            "line": 3007,
            "code": "    it('should handle introspection types (__type)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Post {\n          title: String\n        }\n        type Query {\n          post: Post!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query Info {\n          __type(name: \"Post\") {\n            name\n            fields {\n              name\n              type {\n                name\n                kind\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type InfoQuery = (\n          { __typename?: 'Query' }\n          & { __type?: Maybe<(\n            { __typename?: '__Type' }\n            & Pick<__Type, 'name'>\n            & { fields?: Maybe<Array<(\n              { __typename?: '__Field' }\n              & Pick<__Field, 'name'>\n              & { type: (\n                { __typename?: '__Type' }\n                & Pick<__Type, 'name' | 'kind'>\n              ) }\n            )>> }\n          )> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should handle introspection types (like __TypeKind)",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 3059,
                "column": 59
            },
            "line": 3059,
            "code": "    it('should handle introspection types (like __TypeKind)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Post {\n          title: String\n        }\n        type Query {\n          post: Post!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query Info {\n          __type(name: \"Post\") {\n            name\n            fields {\n              name\n              type {\n                name\n                kind\n              }\n            }\n          }\n        }\n      `);\n\n      const coreContent = await tsPlugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const pluginContent = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const content = mergeOutputs([coreContent, pluginContent]);\n\n      expect(content).toBeSimilarStringTo(`\n      /** An enum describing what kind of type a given \\`__Type\\` is. */\n      export enum __TypeKind {\n        /** Indicates this type is a scalar. */\n        Scalar = 'SCALAR',\n        /** Indicates this type is an object. \\`fields\\` and \\`interfaces\\` are valid fields. */\n        Object = 'OBJECT',\n        /** Indicates this type is an interface. \\`fields\\`, \\`interfaces\\`, and \\`possibleTypes\\` are valid fields. */\n        Interface = 'INTERFACE',\n        /** Indicates this type is a union. \\`possibleTypes\\` is a valid field. */\n        Union = 'UNION',\n        /** Indicates this type is an enum. \\`enumValues\\` is a valid field. */\n        Enum = 'ENUM',\n        /** Indicates this type is an input object. \\`inputFields\\` is a valid field. */\n        InputObject = 'INPUT_OBJECT',\n        /** Indicates this type is a list. \\`ofType\\` is a valid field. */\n        List = 'LIST',\n        /** Indicates this type is a non-null. \\`ofType\\` is a valid field. */\n        NonNull = 'NON_NULL'\n      }\n      `);\n\n      validateTs(content);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate correctly when using enums and typesPrefix",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 3128,
                "column": 66
            },
            "line": 3128,
            "code": "    it('Should generate correctly when using enums and typesPrefix', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum Access {\n          Read\n          Write\n          All\n        }\n        type User {\n          access: Access\n        }\n        input Filter {\n          match: String!\n        }\n        type Query {\n          users(filter: Filter!): [User]\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query users($filter: Filter!) {\n          users(filter: $filter) {\n            access\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { typesPrefix: 'PREFIX_', preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type PREFIX_UsersQueryVariables = Exact<{\n          filter: PREFIX_Filter;\n        }>;\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type PREFIX_UsersQuery = (\n          { __typename?: 'Query' }\n          & { users?: Maybe<Array<Maybe<(\n            { __typename?: 'User' }\n            & Pick<PREFIX_User, 'access'>\n          )>>> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should make arguments optional when there is a default value",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 3178,
                "column": 68
            },
            "line": 3178,
            "code": "    it('Should make arguments optional when there is a default value', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          name: String!\n        }\n        type Query {\n          users(reverse: Boolean!): [User!]!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query users($reverse: Boolean = true) {\n          users(reverse: $reverse) {\n            name\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type UsersQueryVariables = Exact<{\n          reverse?: InputMaybe<Scalars['Boolean']>;\n        }>;\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should generate correct types for union that returns interface types",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3213,
                "column": 76
            },
            "line": 3213,
            "code": "    it('should generate correct types for union that returns interface types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n        }\n        type ComplexError implements Error {\n          message: String!\n          additionalInfo: String!\n        }\n\n        type FieldResultSuccess {\n          someValue: Boolean!\n        }\n\n        union FieldResult = Error1 | Error2 | ComplexError | FieldResultSuccess\n\n        type Query {\n          field: FieldResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query field {\n          field {\n            __typename\n            ... on Error {\n              message\n            }\n            ... on ComplexError {\n              additionalInfo\n            }\n            ... on FieldResultSuccess {\n              someValue\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n      expect(content).toBeSimilarStringTo(`\n      export type FieldQuery = (\n        { __typename?: 'Query' }\n        & { field: (\n          { __typename: 'Error1' }\n          & Pick<Error1, 'message'>\n        ) | (\n          { __typename: 'Error2' }\n          & Pick<Error2, 'message'>\n        ) | (\n          { __typename: 'ComplexError' }\n          & Pick<ComplexError, 'message' | 'additionalInfo'>\n        ) | (\n          { __typename: 'FieldResultSuccess' }\n          & Pick<FieldResultSuccess, 'someValue'>\n        ) }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should generate correct types for union that returns interface types (variant __typename in fragment)",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3288,
                "column": 109
            },
            "line": 3288,
            "code": "    it('should generate correct types for union that returns interface types (variant __typename in fragment)', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n        }\n        type ComplexError implements Error {\n          message: String!\n          additionalInfo: String!\n        }\n\n        type FieldResultSuccess {\n          someValue: Boolean!\n        }\n\n        union FieldResult = Error1 | Error2 | ComplexError | FieldResultSuccess\n\n        type Query {\n          field: FieldResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query field {\n          field {\n            ... on Error {\n              __typename\n              message\n            }\n            ... on ComplexError {\n              additionalInfo\n            }\n            ... on FieldResultSuccess {\n              someValue\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n      expect(content).toBeSimilarStringTo(`\n        export type FieldQuery = (\n          { __typename?: 'Query' }\n          & { field: (\n            { __typename: 'Error1' }\n            & Pick<Error1, 'message'>\n          ) | (\n            { __typename: 'Error2' }\n            & Pick<Error2, 'message'>\n          ) | (\n            { __typename: 'ComplexError' }\n            & Pick<ComplexError, 'message' | 'additionalInfo'>\n          ) | (\n            { __typename?: 'FieldResultSuccess' }\n            & Pick<FieldResultSuccess, 'someValue'>\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "interface with same field names",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3362,
                "column": 39
            },
            "line": 3362,
            "code": "    it('interface with same field names', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Node {\n          id: ID!\n        }\n\n        type A implements Node {\n          id: ID!\n          a: String\n        }\n\n        type B implements Node {\n          id: ID!\n          a: Boolean\n        }\n\n        type Query {\n          node: Node\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query something {\n          node {\n            ... on A {\n              a\n            }\n\n            ... on B {\n              a\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type SomethingQuery = (\n          { __typename?: 'Query' }\n          & { node?: Maybe<(\n            { __typename?: 'A' }\n            & Pick<A, 'a'>\n          ) | (\n            { __typename?: 'B' }\n            & Pick<B, 'a'>\n          )> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "union returning single interface types",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3419,
                "column": 46
            },
            "line": 3419,
            "code": "    it('union returning single interface types', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n          info: AdditionalInfo\n        }\n        type AdditionalInfo {\n          message: String!\n        }\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        union UserResult = User | Error2 | Error3\n        type Query {\n          user: UserResult\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query user {\n          user {\n            ... on User {\n              id\n              login\n            }\n            ... on Error {\n              message\n            }\n            ... on Error3 {\n              info {\n                message\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type UserQuery = (\n          { __typename?: 'Query' }\n          & { user?: Maybe<(\n            { __typename?: 'User' }\n            & Pick<User, 'id' | 'login'>\n          ) | (\n            { __typename?: 'Error2' }\n            & Pick<Error2, 'message'>\n          ) | (\n            { __typename?: 'Error3' }\n            & Pick<Error3, 'message'>\n            & { info?: Maybe<(\n              { __typename?: 'AdditionalInfo' }\n              & Pick<AdditionalInfo, 'message'>\n            )> }\n          )> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "duplicated fragment on type includes combined types only once",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3497,
                "column": 69
            },
            "line": 3497,
            "code": "    it('duplicated fragment on type includes combined types only once', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n          info: AdditionalInfo\n        }\n        type AdditionalInfo {\n          message: String!\n          message2: String!\n        }\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        union UserResult = User | Error2 | Error3\n        type Query {\n          user: UserResult\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query user {\n          user {\n            ... on User {\n              id\n              login\n            }\n            ... on Error {\n              message\n              ... on Error3 {\n                info {\n                  message\n                  message2\n                }\n              }\n            }\n            ... on Error {\n              ... on Error3 {\n                info {\n                  message\n                  message2\n                }\n              }\n            }\n            ... on Error3 {\n              info {\n                message\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type UserQuery = (\n          { __typename?: 'Query' }\n          & { user?: Maybe<(\n            { __typename?: 'User' }\n            & Pick<User, 'id' | 'login'>\n          ) | (\n            { __typename?: 'Error2' }\n            & Pick<Error2, 'message'>\n          ) | (\n            { __typename?: 'Error3' }\n            & Pick<Error3, 'message'>\n            & { info?: Maybe<(\n                { __typename?: 'AdditionalInfo' }\n                & Pick<AdditionalInfo, 'message' | 'message2'>\n              )> }\n          )> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should merge inline fragments fields correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3590,
                "column": 54
            },
            "line": 3590,
            "code": "    it('Should merge inline fragments fields correctly', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        type Query {\n          user: User!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserQuery {\n          user {\n            ... on User {\n              id\n            }\n\n            ... on User {\n              login\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const o = await validate(content, {}, testSchema);\n\n      expect(o).toBeSimilarStringTo(`\n      export type UserQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'id' | 'login'>\n        ) }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should merge inline fragments fields correctly with fragment spread over the same type",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3638,
                "column": 94
            },
            "line": 3638,
            "code": "    it('Should merge inline fragments fields correctly with fragment spread over the same type', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        type Query {\n          user: User!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserQuery {\n          user {\n            ... on User {\n              id\n            }\n\n            ...test\n          }\n        }\n\n        fragment test on User {\n          login\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const o = await validate(content, {}, testSchema);\n\n      expect(o).toBeSimilarStringTo(`\n      export type UserQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'id' | 'login'>\n        ) }\n      );`);\n\n      expect(o).toBeSimilarStringTo(`export type TestFragment = (\n        { __typename?: 'User' }\n        & Pick<User, 'login'>\n      );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle union selection sets with both FragmentSpreads and InlineFragments",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3692,
                "column": 88
            },
            "line": 3692,
            "code": "    it('Should handle union selection sets with both FragmentSpreads and InlineFragments', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n          info: AdditionalInfo\n        }\n        type AdditionalInfo {\n          message: String!\n          message2: String!\n        }\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        union UserResult = User | Error2 | Error3\n\n        type Query {\n          user: UserResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserQuery {\n          user {\n            ...UserResult\n            ...UserResult1\n            ... on User {\n              login\n            }\n            ... on Error3 {\n              message\n              info {\n                ...AdditionalInfo\n              }\n            }\n          }\n        }\n\n        fragment AdditionalInfo on AdditionalInfo {\n          message\n        }\n\n        fragment UserResult1 on UserResult {\n          ... on User {\n            id\n          }\n          ... on Error3 {\n            info {\n              message2\n            }\n          }\n        }\n\n        fragment UserResult on UserResult {\n          ... on User {\n            id\n          }\n          ... on Error2 {\n            message\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const output = await validate(\n        content,\n        {},\n        testSchema,\n        `\n        function t(q: UserQueryQuery) {\n            if (q.user) {\n                if (q.user.__typename === 'User') {\n                    if (q.user.id) {\n                        const u = q.user.login;\n                    }\n                }\n                if (q.user.__typename === 'Error2') {\n                    console.log(q.user.message);\n                }\n                if (q.user.__typename === 'Error3') {\n                    if (q.user.info) {\n                        console.log(q.user.info.__typename)\n                    }\n                }\n            }\n        }`\n      );\n      expect(mergeOutputs([content])).toMatchSnapshot();\n\n      expect(output).toBeSimilarStringTo(`\n      export type UserQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'login' | 'id'>\n        ) | (\n          { __typename?: 'Error2' }\n          & Pick<Error2, 'message'>\n        ) | (\n          { __typename?: 'Error3' }\n          & Pick<Error3, 'message'>\n          & { info?: Maybe<(\n            { __typename?: 'AdditionalInfo' }\n            & Pick<AdditionalInfo, 'message2' | 'message'>\n          )> }\n        ) }\n      );`);\n\n      expect(output).toBeSimilarStringTo(`\n      export type AdditionalInfoFragment = (\n        { __typename?: 'AdditionalInfo' }\n        & Pick<AdditionalInfo, 'message'>\n      );\n\n      type UserResult1_User_Fragment = (\n        { __typename?: 'User' }\n        & Pick<User, 'id'>\n      );\n\n      type UserResult1_Error2_Fragment = { __typename?: 'Error2' };\n\n      type UserResult1_Error3_Fragment = (\n        { __typename?: 'Error3' }\n        & { info?: Maybe<(\n          { __typename?: 'AdditionalInfo' }\n          & Pick<AdditionalInfo, 'message2'>\n        )> }\n      );\n\n      export type UserResult1Fragment = UserResult1_User_Fragment | UserResult1_Error2_Fragment | UserResult1_Error3_Fragment;\n\n      type UserResult_User_Fragment = (\n        { __typename?: 'User' }\n        & Pick<User, 'id'>\n      );\n\n      type UserResult_Error2_Fragment = (\n        { __typename?: 'Error2' }\n        & Pick<Error2, 'message'>\n      );\n\n      type UserResult_Error3_Fragment = { __typename?: 'Error3' };\n\n      export type UserResultFragment = UserResult_User_Fragment | UserResult_Error2_Fragment | UserResult_Error3_Fragment;`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle union selection sets with both FragmentSpreads and InlineFragments with flattenGeneratedTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3856,
                "column": 115
            },
            "line": 3856,
            "code": "    it('Should handle union selection sets with both FragmentSpreads and InlineFragments with flattenGeneratedTypes', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n          info: AdditionalInfo\n        }\n        type AdditionalInfo {\n          message: String!\n          message2: String!\n        }\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        union UserResult = User | Error2 | Error3\n\n        type Query {\n          user: UserResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserQuery {\n          user {\n            ...UserResult\n            ...UserResult1\n            ... on User {\n              login\n            }\n            ... on Error3 {\n              message\n              info {\n                ...AdditionalInfo\n              }\n            }\n          }\n        }\n\n        fragment AdditionalInfo on AdditionalInfo {\n          message\n        }\n\n        fragment UserResult1 on UserResult {\n          ... on User {\n            id\n          }\n          ... on Error3 {\n            info {\n              message2\n            }\n          }\n        }\n\n        fragment UserResult on UserResult {\n          ... on User {\n            id\n          }\n          ... on Error2 {\n            message\n          }\n        }\n      `);\n\n      const config = {\n        flattenGeneratedTypes: true,\n        preResolveTypes: false,\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      const output = await validate(\n        content,\n        config,\n        testSchema,\n        `\n        function t(q: UserQueryQuery) {\n            if (q.user) {\n                if (q.user.__typename === 'User') {\n                    if (q.user.id) {\n                        const u = q.user.login;\n                    }\n                }\n                if (q.user.__typename === 'Error2') {\n                    console.log(q.user.message);\n                }\n                if (q.user.__typename === 'Error3') {\n                    if (q.user.info) {\n                        console.log(q.user.info.__typename)\n                    }\n                }\n            }\n        }`\n      );\n      expect(mergeOutputs([output])).toMatchSnapshot();\n\n      expect(output).toBeSimilarStringTo(`\n      export type UserQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'id' | 'login'>\n        ) | (\n          { __typename?: 'Error2' }\n          & Pick<Error2, 'message'>\n        ) | (\n          { __typename?: 'Error3' }\n          & Pick<Error3, 'message'>\n          & { info?: Maybe<(\n            { __typename?: 'AdditionalInfo' }\n            & Pick<AdditionalInfo, 'message2' | 'message'>\n          )> }\n        ) }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#4216 - handle fragments against unions and interfaces with flattenGeneratedTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3984,
                "column": 89
            },
            "line": 3984,
            "code": "    it('#4216 - handle fragments against unions and interfaces with flattenGeneratedTypes', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          search: [Searchable!]\n        }\n\n        interface Concept {\n          id: String\n        }\n\n        type Dimension implements Concept {\n          id: String\n        }\n\n        type DimValue {\n          dimension: Dimension\n          value: String!\n        }\n\n        union Searchable = Dimension | DimValue\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query SearchPopular {\n          search {\n            ...SearchableFragment\n          }\n        }\n\n        fragment SearchableFragment on Searchable {\n          ...SearchConceptFragment\n          ...SearchDimValueFragment\n        }\n\n        fragment SearchConceptFragment on Concept {\n          id\n        }\n\n        fragment SearchDimValueFragment on DimValue {\n          dimension {\n            ...SearchConceptFragment\n          }\n          value\n        }\n      `);\n\n      const config = {\n        flattenGeneratedTypes: true,\n        preResolveTypes: false,\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      const output = await validate(content, config, testSchema);\n      expect(mergeOutputs([output])).toMatchSnapshot();\n\n      expect(output).toBeSimilarStringTo(`\n        export type Maybe<T> = T | null;\n        export type InputMaybe<T> = Maybe<T>;\n        export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\n        export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\n        export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n        /** All built-in and custom scalars, mapped to their actual values */\n        export type Scalars = {\n          ID: string;\n          String: string;\n          Boolean: boolean;\n          Int: number;\n          Float: number;\n        };\n\n        export type Query = {\n          __typename?: 'Query';\n          search?: Maybe<Array<Searchable>>;\n        };\n\n        export type Concept = {\n          id?: Maybe<Scalars['String']>;\n        };\n\n        export type Dimension = Concept & {\n          __typename?: 'Dimension';\n          id?: Maybe<Scalars['String']>;\n        };\n\n        export type DimValue = {\n          __typename?: 'DimValue';\n          dimension?: Maybe<Dimension>;\n          value: Scalars['String'];\n        };\n\n        export type Searchable = Dimension | DimValue;\n        export type SearchPopularQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type SearchPopularQuery = (\n          { __typename?: 'Query' }\n          & { search?: Maybe<Array<(\n            { __typename?: 'Dimension' }\n            & Pick<Dimension, 'id'>\n          ) | (\n            { __typename?: 'DimValue' }\n            & Pick<DimValue, 'value'>\n            & { dimension?: Maybe<(\n              { __typename?: 'Dimension' }\n              & Pick<Dimension, 'id'>\n            )> }\n          )>> }\n        );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Handles fragments across files with flattenGeneratedTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 4100,
                "column": 65
            },
            "line": 4100,
            "code": "    it('Handles fragments across files with flattenGeneratedTypes', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          search: [Dimension!]\n        }\n\n        type Dimension {\n          id: String\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query SearchPopular {\n          search {\n            ...SearchableFragment\n          }\n        }\n\n        # Unreferenced fragments are still dropped\n        fragment ExtraFragment on Dimension {\n          id\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        fragment SearchableFragment on Dimension {\n          id\n        }\n      `);\n\n      const config = {\n        flattenGeneratedTypes: true,\n        flattenGeneratedTypesIncludeFragments: true,\n        preResolveTypes: true,\n      };\n\n      const { content } = await plugin(\n        testSchema,\n        [\n          { location: '', document: query },\n          { location: '', document: fragment },\n        ],\n        config,\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const output = await validate(content, config, testSchema);\n\n      expect(output).toBeSimilarStringTo(`\n        export type Maybe<T> = T | null;\n        export type InputMaybe<T> = Maybe<T>;\n        export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\n        export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\n        export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n        /** All built-in and custom scalars, mapped to their actual values */\n        export type Scalars = {\n          ID: string;\n          String: string;\n          Boolean: boolean;\n          Int: number;\n          Float: number;\n        };\n\n        export type Query = {\n          __typename?: 'Query';\n          search?: Maybe<Array<Dimension>>;\n        };\n\n        export type Dimension = {\n          __typename?: 'Dimension';\n          id?: Maybe<Scalars['String']>;\n        };\n        export type SearchableFragmentFragment = { __typename?: 'Dimension', id?: string | null };\n\n        export type SearchPopularQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type SearchPopularQuery = { __typename?: 'Query', search?: Array<{ __typename?: 'Dimension', id?: string | null }> | null };`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Drops fragments with flattenGeneratedTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 4185,
                "column": 50
            },
            "line": 4185,
            "code": "    it('Drops fragments with flattenGeneratedTypes', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          search: [Dimension!]\n        }\n\n        type Dimension {\n          id: String\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query SearchPopular {\n          search {\n            ...SearchableFragment\n          }\n        }\n\n        # Unreferenced fragments should be dropped by flattenGeneratedTypes\n        fragment ExtraFragment on Dimension {\n          id\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        # Referenced fragments should be dropped by flattenGeneratedTypes\n        fragment SearchableFragment on Dimension {\n          id\n        }\n      `);\n\n      const config = {\n        flattenGeneratedTypes: true,\n        flattenGeneratedTypesIncludeFragments: false,\n        preResolveTypes: true,\n      };\n\n      const { content } = await plugin(\n        testSchema,\n        [\n          { location: '', document: query },\n          { location: '', document: fragment },\n        ],\n        config,\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const output = await validate(content, config, testSchema);\n\n      expect(output).toBeSimilarStringTo(`\n        export type Maybe<T> = T | null;\n        export type InputMaybe<T> = Maybe<T>;\n        export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\n        export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\n        export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n        /** All built-in and custom scalars, mapped to their actual values */\n        export type Scalars = {\n          ID: string;\n          String: string;\n          Boolean: boolean;\n          Int: number;\n          Float: number;\n        };\n\n        export type Query = {\n          __typename?: 'Query';\n          search?: Maybe<Array<Dimension>>;\n        };\n\n        export type Dimension = {\n          __typename?: 'Dimension';\n          id?: Maybe<Scalars['String']>;\n        };\n\n        export type SearchPopularQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type SearchPopularQuery = { __typename?: 'Query', search?: Array<{ __typename?: 'Dimension', id?: string | null }> | null };`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add operation name when addOperationExport is true",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 4270,
                "column": 65
            },
            "line": 4270,
            "code": "    it('Should add operation name when addOperationExport is true', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        type Query {\n          user: User!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserIdQuery {\n          user {\n            id\n          }\n        }\n        query UserLoginQuery {\n          user {\n            login\n          }\n        }\n      `);\n\n      const config = {\n        addOperationExport: true,\n        preResolveTypes: false,\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserIdQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n      export type UserIdQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'id'>\n        ) }\n      );\n\n      export type UserLoginQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n      export type UserLoginQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'login'>\n        ) }\n      );\n\n      export declare const UserIdQuery: import(\"graphql\").DocumentNode;\n      export declare const UserLoginQuery: import(\"graphql\").DocumentNode;\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle union selection sets with both FragmentSpreads and InlineFragments with flattenGeneratedTypes and directives",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 4330,
                "column": 130
            },
            "line": 4330,
            "code": "    it('Should handle union selection sets with both FragmentSpreads and InlineFragments with flattenGeneratedTypes and directives', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n          info: AdditionalInfo\n        }\n        type AdditionalInfo {\n          message: String!\n          message2: String!\n        }\n        type User {\n          id: ID!\n          login: String!\n          test: String\n          test2: String\n        }\n\n        union UserResult = User | Error2 | Error3\n\n        type Query {\n          user: UserResult!\n        }\n\n        directive @client on FIELD\n        directive @connection on FIELD\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserQuery {\n          user {\n            ...UserResult\n            ...UserResult1\n            ... on User {\n              login\n              test @client\n            }\n            ... on Error3 {\n              message\n              info {\n                ...AdditionalInfo\n              }\n            }\n          }\n        }\n\n        fragment AdditionalInfo on AdditionalInfo {\n          message\n        }\n\n        fragment UserResult1 on UserResult {\n          ... on User {\n            id\n            test2 @connection\n          }\n          ... on Error3 {\n            info {\n              message2\n            }\n          }\n        }\n\n        fragment UserResult on UserResult {\n          ... on User {\n            id\n          }\n          ... on Error2 {\n            message\n          }\n        }\n      `);\n\n      const config = {\n        flattenGeneratedTypes: true,\n        preResolveTypes: false,\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      const output = await validate(\n        content,\n        config,\n        testSchema,\n        `\n        function t(q: UserQueryQuery) {\n            if (q.user) {\n                if (q.user.__typename === 'User') {\n                    if (q.user.id) {\n                        const u = q.user.login;\n                    }\n                }\n                if (q.user.__typename === 'Error2') {\n                    console.log(q.user.message);\n                }\n                if (q.user.__typename === 'Error3') {\n                    if (q.user.info) {\n                        console.log(q.user.info.__typename)\n                    }\n                }\n            }\n        }`\n      );\n      expect(mergeOutputs([output])).toMatchSnapshot();\n\n      expect(output).toBeSimilarStringTo(`\n      export type UserQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'id' | 'test2' | 'login' | 'test'>\n        ) | (\n          { __typename?: 'Error2' }\n          & Pick<Error2, 'message'>\n        ) | (\n          { __typename?: 'Error3' }\n          & Pick<Error3, 'message'>\n          & { info?: Maybe<(\n            { __typename?: 'AdditionalInfo' }\n            & Pick<AdditionalInfo, 'message2' | 'message'>\n          )> }\n        ) }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#4212 - Should merge TS arrays in a more elegant way",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4467,
                "column": 60
            },
            "line": 4467,
            "code": "    it('#4212 - Should merge TS arrays in a more elegant way', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Item {\n          id: ID!\n          name: String!\n        }\n\n        type Object {\n          items: [Item!]!\n        }\n\n        type Query {\n          obj: Object\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        fragment Object1 on Object {\n          items {\n            id\n          }\n        }\n\n        fragment Object2 on Object {\n          items {\n            name\n          }\n        }\n\n        fragment CombinedObject on Object {\n          ...Object1\n          ...Object2\n        }\n\n        query test {\n          obj {\n            ...CombinedObject\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      await validate(\n        content,\n        {},\n        testSchema,\n        `\n          function test (t: TestQuery) {\n            for (const item of t.obj!.items) {\n              console.log(item.id, item.name, item.__typename);\n            }\n          }\n      `\n      );\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#5422 - Error when interface doesnt have implemeting types",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4531,
                "column": 66
            },
            "line": 4531,
            "code": "    it('#5422 - Error when interface doesnt have implemeting types', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface A {\n          a: String!\n        }\n\n        type Query {\n          test: A\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query test {\n          test {\n            a\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).not.toContain(`Maybe<>`);\n      expect(content).toContain(`Maybe<never>`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#4389 - validate issues with interfaces",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4563,
                "column": 47
            },
            "line": 4563,
            "code": "    it('#4389 - validate issues with interfaces', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface A {\n          a: String!\n        }\n\n        interface B implements A {\n          a: String!\n          b: String\n        }\n\n        type C implements B {\n          a: String!\n          b: String\n          c: String!\n        }\n\n        type Query {\n          foo: C\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query {\n          foo {\n            ... on A {\n              a\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n      expect(content).toContain(`{ foo?: Maybe<{ __typename?: 'C' }> }`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#5001 - incorrect output with typeSuffix",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4606,
                "column": 48
            },
            "line": 4606,
            "code": "    it('#5001 - incorrect output with typeSuffix', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          user(id: ID!): User!\n        }\n\n        type User {\n          id: ID!\n          username: String!\n          email: String!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query user {\n          user(id: 1) {\n            id\n            username\n            email\n          }\n        }\n      `);\n\n      const config = {\n        typesSuffix: 'Type',\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).not.toContain('UserTypeQueryVariablesType');\n      expect(content).not.toContain('UserTypeQueryType');\n      expect(content).toContain('UserQueryVariablesType');\n      expect(content).toContain('UserQueryType');\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#3064 - fragments over interfaces causes issues with fields",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4643,
                "column": 67
            },
            "line": 4643,
            "code": "    it('#3064 - fragments over interfaces causes issues with fields', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Venue {\n          id: String!\n          name: String!\n        }\n\n        type GPSPosition {\n          lat: Float!\n          lng: Float!\n        }\n\n        interface VenueWithPosition {\n          id: String!\n          gpsPosition: GPSPosition!\n        }\n\n        type Hotel implements VenueWithPosition & Venue {\n          id: String!\n          gpsPosition: GPSPosition!\n          name: String!\n        }\n\n        type Transport implements Venue {\n          id: String!\n          name: String!\n        }\n\n        type Query {\n          hotel: Hotel!\n          transport: Transport!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        fragment venue on Venue {\n          id\n          ... on VenueWithPosition {\n            gpsPosition {\n              lat\n              lng\n            }\n          }\n        }\n\n        query q {\n          hotel {\n            ...venue\n          }\n          transport {\n            ...venue\n          }\n        }\n      `);\n\n      const config = {};\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toMatchSnapshot();\n\n      const result = await validate(\n        content,\n        {},\n        testSchema,\n        `function test(q: QQuery) {\n        if (q.hotel) {\n            const t1 = q.hotel.gpsPosition.lat\n        }\n\n        if (q.transport) {\n            const t2 = q.transport.id;\n        }\n    }`\n      );\n      expect(mergeOutputs([result])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2916 - Missing import prefix with preResolveTypes: true and near-operation-file preset",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4723,
                "column": 95
            },
            "line": 4723,
            "code": "    it('#2916 - Missing import prefix with preResolveTypes: true and near-operation-file preset', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          user(id: ID!): User!\n        }\n\n        enum Department {\n          Direction\n          Development\n        }\n\n        type User {\n          id: ID!\n          username: String!\n          email: String!\n          department: Department!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query user {\n          user(id: 1) {\n            id\n            username\n            email\n            dep: department\n          }\n        }\n      `);\n\n      const config = {\n        skipTypename: true,\n        preResolveTypes: true,\n        namespacedImportName: 'Types',\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toContain(`dep: Types.Department`);\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2699 - Issues with multiple interfaces and unions",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4767,
                "column": 58
            },
            "line": 4767,
            "code": "    it('#2699 - Issues with multiple interfaces and unions', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Node {\n          id: ID!\n        }\n\n        scalar DateTime\n\n        interface Element {\n          active: Boolean!\n          createdAt: DateTime!\n          createdBy: User\n          updatedAt: DateTime!\n          updatedBy: User\n        }\n\n        interface Entity {\n          brandData(brand: ID!): EntityBrandData\n        }\n\n        type EntityBrandData {\n          active: Boolean!\n          browsable: Boolean!\n          description: String!\n          alternateTitle: String\n          title: String!\n        }\n\n        type Query {\n          node(id: ID!): Node!\n        }\n\n        type Company implements Element & Node & Entity {\n          active: Boolean!\n          createdAt: DateTime!\n          createdBy: User\n          updatedAt: DateTime!\n          updatedBy: User\n          id: ID!\n          brandData(brand: ID!): EntityBrandData\n        }\n\n        type Theater implements Element & Node & Entity {\n          active: Boolean!\n          createdAt: DateTime!\n          createdBy: User\n          updatedAt: DateTime!\n          updatedBy: User\n          id: ID!\n          brandData(brand: ID!): EntityBrandData\n        }\n\n        type Movie implements Element & Node & Entity {\n          active: Boolean!\n          createdAt: DateTime!\n          createdBy: User\n          updatedAt: DateTime!\n          updatedBy: User\n          id: ID!\n          brandData(brand: ID!): EntityBrandData\n        }\n\n        type User implements Element & Node & Entity {\n          active: Boolean!\n          name: String!\n          createdAt: DateTime!\n          createdBy: User\n          updatedAt: DateTime!\n          updatedBy: User\n          id: ID!\n          brandData(brand: ID!): EntityBrandData\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query getEntityBrandData($gid: ID!, $brand: ID!) {\n          node(gid: $gid) {\n            __typename\n            id\n            ... on Entity {\n              ...EntityBrandData\n            }\n            ... on Element {\n              ...ElementMetadata\n            }\n            ... on Company {\n              active\n            }\n            ... on Theater {\n              active\n            }\n          }\n        }\n\n        fragment EntityBrandData on Entity {\n          brandData(brand: $brand) {\n            active\n            browsable\n            title\n            alternateTitle\n            description\n          }\n        }\n\n        fragment ElementMetadata on Element {\n          createdAt\n          createdBy {\n            id\n            name\n          }\n          updatedAt\n          updatedBy {\n            id\n            name\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(mergeOutputs([content])).toMatchSnapshot();\n\n      await validate(\n        content,\n        {},\n        testSchema,\n        `\nfunction test(q: GetEntityBrandDataQuery): void {\n  const typeName: 'Company' | 'Theater' | 'User' | 'Movie' = q.node.__typename; // just to check that those are the types we want here\n  const brandData = q.node.brandData; // this was missing in the original issue\n  const createdAt = q.node.createdAt; // this was missing in the original issue\n\n  if (q.node.__typename === 'Company') {\n    console.log('Company:', q.node.active);\n  } else if (q.node.__typename === 'Theater') {\n    console.log('Theater:', q.node.active);\n  } else if (q.node.__typename === 'User') {\n    console.log('User:', q.node.id);\n  } else if (q.node.__typename === 'Movie') {\n    console.log('Movie:', q.node.id);\n  }\n}`\n      );\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#1624 - Should work with fragment on union type",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4919,
                "column": 55
            },
            "line": 4919,
            "code": "    it('#1624 - Should work with fragment on union type', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          fooBar: [FooBar!]!\n        }\n\n        union FooBar = Foo | Bar\n\n        type Foo {\n          id: ID!\n        }\n\n        type Bar {\n          id: ID!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query TestQuery {\n          fooBar {\n            ...FooBarFragment\n          }\n        }\n\n        fragment FooBarFragment on FooBar {\n          ... on Foo {\n            id\n          }\n          ... on Bar {\n            id\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type TestQueryQuery = (\n        { __typename?: 'Query' }\n        & { fooBar: Array<(\n          { __typename?: 'Foo' }\n          & Pick<Foo, 'id'>\n        ) | (\n          { __typename?: 'Bar' }\n          & Pick<Bar, 'id'>\n        )> }\n      );\n\n      type FooBarFragment_Foo_Fragment = (\n        { __typename?: 'Foo' }\n        & Pick<Foo, 'id'>\n      );\n\n      type FooBarFragment_Bar_Fragment = (\n        { __typename?: 'Bar' }\n        & Pick<Bar, 'id'>\n      );\n\n      export type FooBarFragmentFragment = FooBarFragment_Foo_Fragment | FooBarFragment_Bar_Fragment;\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2407 Fragment on Fragment Spread on Union type",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4988,
                "column": 55
            },
            "line": 4988,
            "code": "    it('#2407 Fragment on Fragment Spread on Union type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Price {\n          id: ID!\n          item: [PriceItemUnion]!\n        }\n\n        type Product {\n          id: ID!\n          title: String!\n        }\n\n        union PriceItemUnion = Product\n\n        type Query {\n          price: Price!\n        }\n      `);\n\n      const productFragmentDocument = parse(/* GraphQL */ `\n        fragment ProductFragment on Product {\n          id\n          title\n        }\n      `);\n\n      const priceFragmentDocument = parse(/* GraphQL */ `\n        fragment PriceFragment on Price {\n          id\n          item {\n            ... on Product {\n              ...ProductFragment\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [\n          { location: '', document: productFragmentDocument },\n          { location: '', document: priceFragmentDocument },\n        ],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type ProductFragmentFragment = (\n        { __typename?: 'Product' }\n        & Pick<Product, 'id' | 'title'>\n      );\n\n        export type PriceFragmentFragment = (\n          { __typename?: 'Price' }\n          & Pick<Price, 'id'>\n          & { item: Array<Maybe<(\n            { __typename?: 'Product' }\n            & Pick<Product, 'id' | 'title'>\n          )>> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2506 - inline fragment without typeCondition specified",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5054,
                "column": 63
            },
            "line": 5054,
            "code": "    it('#2506 - inline fragment without typeCondition specified', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n        }\n\n        type User {\n          name: String\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($withUser: Boolean! = false) {\n          ... @include(if: $withUser) {\n            user {\n              name\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQuery = (\n        { __typename?: 'Query' }\n        & { user?: Maybe<(\n          { __typename?: 'User' }\n          & Pick<User, 'name'>\n        )> }\n      );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2436 - interface with field of same name but different type is correctly handled",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5094,
                "column": 89
            },
            "line": 5094,
            "code": "    it('#2436 - interface with field of same name but different type is correctly handled', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface DashboardTile {\n          tileId: ID!\n        }\n        type TileFilterMetadata {\n          viz: String!\n          columnInfo: String!\n        }\n        type DashboardTileFilterDetails implements DashboardTile {\n          tileId: ID!\n          md: TileFilterMetadata!\n        }\n        type TileParameterMetadata {\n          viz: String!\n          columnInfo: String!\n        }\n        type DashboardTileParameterDetails implements DashboardTile {\n          tileId: ID!\n          md: TileParameterMetadata!\n        }\n        type DashboardVersion {\n          id: ID!\n          tiles: DashboardTile!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        fragment DashboardVersionFragment on DashboardVersion {\n          tiles {\n            ... on DashboardTileFilterDetails {\n              tileId\n              md {\n                viz\n                columnInfo\n              }\n            }\n            ... on DashboardTileParameterDetails {\n              tileId\n              md {\n                viz\n                columnInfo\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type DashboardVersionFragmentFragment = (\n          { __typename?: 'DashboardVersion' }\n          & { tiles: (\n            { __typename?: 'DashboardTileFilterDetails' }\n            & Pick<DashboardTileFilterDetails, 'tileId'>\n            & { md: (\n              { __typename?: 'TileFilterMetadata' }\n              & Pick<TileFilterMetadata, 'viz' | 'columnInfo'>\n            ) }\n          ) | (\n            { __typename?: 'DashboardTileParameterDetails' }\n            & Pick<DashboardTileParameterDetails, 'tileId'>\n            & { md: (\n              { __typename?: 'TileParameterMetadata' }\n              & Pick<TileParameterMetadata, 'viz' | 'columnInfo'>\n            ) }\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2436 - union with field of same name but different type is correctly handled",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5173,
                "column": 85
            },
            "line": 5173,
            "code": "    it('#2436 - union with field of same name but different type is correctly handled', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type TileFilterMetadata {\n          viz: String!\n          columnInfo: String!\n        }\n        type DashboardTileFilterDetails {\n          tileId: ID!\n          md: TileFilterMetadata!\n        }\n        type TileParameterMetadata {\n          viz: String!\n          columnInfo: String!\n        }\n        type DashboardTileParameterDetails {\n          tileId: ID!\n          md: TileParameterMetadata!\n        }\n        union DashboardTile = DashboardTileFilterDetails | DashboardTileParameterDetails\n\n        type DashboardVersion {\n          id: ID!\n          tiles: DashboardTile!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        fragment DashboardVersionFragment on DashboardVersion {\n          tiles {\n            ... on DashboardTileFilterDetails {\n              tileId\n              md {\n                viz\n                columnInfo\n              }\n            }\n            ... on DashboardTileParameterDetails {\n              tileId\n              md {\n                viz\n                columnInfo\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type DashboardVersionFragmentFragment = (\n          { __typename?: 'DashboardVersion' }\n          & { tiles: (\n            { __typename?: 'DashboardTileFilterDetails' }\n            & Pick<DashboardTileFilterDetails, 'tileId'>\n            & { md: (\n              { __typename?: 'TileFilterMetadata' }\n              & Pick<TileFilterMetadata, 'viz' | 'columnInfo'>\n            ) }\n          ) | (\n            { __typename?: 'DashboardTileParameterDetails' }\n            & Pick<DashboardTileParameterDetails, 'tileId'>\n            & { md: (\n              { __typename?: 'TileParameterMetadata' }\n              & Pick<TileParameterMetadata, 'viz' | 'columnInfo'>\n            ) }\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#3950 - Invalid output with fragments and skipTypename: true",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5251,
                "column": 68
            },
            "line": 5251,
            "code": "    it('#3950 - Invalid output with fragments and skipTypename: true', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          animals: [Animal!]!\n        }\n\n        interface Animal {\n          id: ID!\n        }\n        type Duck implements Animal {\n          id: ID!\n        }\n        type Lion implements Animal {\n          id: ID!\n        }\n        type Puma implements Animal {\n          id: ID!\n        }\n        type Wolf implements Animal {\n          id: ID!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        fragment CatFragment on Animal {\n          ... on Lion {\n            id\n          }\n          ... on Puma {\n            id\n          }\n        }\n\n        query kitty {\n          animals {\n            ...CatFragment\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: query }],\n        {\n          skipTypename: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toMatchInlineSnapshot(`\n        \"type CatFragment_Duck_Fragment = {};\n\n        type CatFragment_Lion_Fragment = { id: string };\n\n        type CatFragment_Puma_Fragment = { id: string };\n\n        type CatFragment_Wolf_Fragment = {};\n\n        export type CatFragmentFragment = CatFragment_Duck_Fragment | CatFragment_Lion_Fragment | CatFragment_Puma_Fragment | CatFragment_Wolf_Fragment;\n\n        export type KittyQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type KittyQuery = { animals: Array<{ id: string } | { id: string } | {}> };\n        \"\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#3950 - Invalid output with fragments and skipTypename: false",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5321,
                "column": 69
            },
            "line": 5321,
            "code": "    it('#3950 - Invalid output with fragments and skipTypename: false', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          animals: [Animal!]!\n        }\n\n        interface Animal {\n          id: ID!\n        }\n        type Duck implements Animal {\n          id: ID!\n        }\n        type Lion implements Animal {\n          id: ID!\n        }\n        type Puma implements Animal {\n          id: ID!\n        }\n        type Wolf implements Animal {\n          id: ID!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        fragment CatFragment on Animal {\n          ... on Lion {\n            id\n          }\n          ... on Puma {\n            id\n          }\n        }\n\n        query kitty {\n          animals {\n            ...CatFragment\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: query }],\n        {\n          skipTypename: false,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toMatchInlineSnapshot(`\n        \"type CatFragment_Duck_Fragment = { __typename?: 'Duck' };\n\n        type CatFragment_Lion_Fragment = { __typename?: 'Lion', id: string };\n\n        type CatFragment_Puma_Fragment = { __typename?: 'Puma', id: string };\n\n        type CatFragment_Wolf_Fragment = { __typename?: 'Wolf' };\n\n        export type CatFragmentFragment = CatFragment_Duck_Fragment | CatFragment_Lion_Fragment | CatFragment_Puma_Fragment | CatFragment_Wolf_Fragment;\n\n        export type KittyQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type KittyQuery = { __typename?: 'Query', animals: Array<{ __typename?: 'Duck' } | { __typename?: 'Lion', id: string } | { __typename?: 'Puma', id: string } | { __typename?: 'Wolf' }> };\n        \"\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2489 - Union that only covers one possible type with selection set and no typename",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5391,
                "column": 91
            },
            "line": 5391,
            "code": "    it('#2489 - Union that only covers one possible type with selection set and no typename', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type NotFoundError {\n          message: String!\n        }\n        type UserBannedError {\n          message: String!\n        }\n        type User {\n          id: ID!\n          login: String\n        }\n        union UserResult = NotFoundError | UserBannedError | User\n\n        type Query {\n          user: UserResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query user {\n          user {\n            ... on User {\n              id\n              login\n            }\n          }\n        }\n      `);\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: query }],\n        {\n          skipTypename: true,\n          preResolveTypes: false,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type UserQuery = { user: Pick<User, 'id' | 'login'> | {} };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#4888 - Types for input Lists do not support coercion",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5437,
                "column": 61
            },
            "line": 5437,
            "code": "    it('#4888 - Types for input Lists do not support coercion', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n        }\n\n        type Query {\n          search(testArray: [String], requireString: [String]!, innerRequired: [String!]!): [User!]\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query user($testArray: [String], $requireString: [String]!, $innerRequired: [String!]!) {\n          search(testArray: $testArray, requireString: $requireString, innerRequired: $innerRequired) {\n            id\n          }\n        }\n      `);\n      const config = { preResolveTypes: true };\n      const { content } = await plugin(schema, [{ location: '', document: ast }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQueryVariables = Exact<{\n        testArray?: InputMaybe<Array<InputMaybe<Scalars['String']>> | InputMaybe<Scalars['String']>>;\n        requireString: Array<InputMaybe<Scalars['String']>> | InputMaybe<Scalars['String']>;\n        innerRequired: Array<Scalars['String']> | Scalars['String'];\n      }>;`);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#5352 - Prevent array input coercion if arrayInputCoercion = false",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5469,
                "column": 74
            },
            "line": 5469,
            "code": "    it('#5352 - Prevent array input coercion if arrayInputCoercion = false', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n        }\n\n        type Query {\n          search(testArray: [String], requireString: [String]!, innerRequired: [String!]!): [User!]\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query user($testArray: [String], $requireString: [String]!, $innerRequired: [String!]!) {\n          search(testArray: $testArray, requireString: $requireString, innerRequired: $innerRequired) {\n            id\n          }\n        }\n      `);\n      const config = { preResolveTypes: true, arrayInputCoercion: false };\n      const { content } = await plugin(schema, [{ location: '', document: ast }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQueryVariables = Exact<{\n        testArray?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n        requireString: Array<InputMaybe<Scalars['String']>>;\n        innerRequired: Array<Scalars['String']>;\n      }>;`);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#5263 - inline fragment spread on interface field results in incorrect types",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5501,
                "column": 84
            },
            "line": 5501,
            "code": "    it('#5263 - inline fragment spread on interface field results in incorrect types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Entity {\n          id: ID!\n        }\n\n        interface NamedEntity implements Entity {\n          id: ID!\n          name: String!\n        }\n\n        type Session implements Entity {\n          id: ID!\n          data: String!\n        }\n\n        type User implements NamedEntity & Entity {\n          id: ID!\n          name: String!\n        }\n\n        type Query {\n          entity(id: ID!): Entity!\n        }\n      `);\n\n      const document = parse(/* GraphQL */ `\n        query entity {\n          entity(id: 1) {\n            id\n            ... on NamedEntity {\n              name\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type EntityQuery = (\n        { __typename?: 'Query' }\n        & { entity: (\n          { __typename?: 'Session' }\n          & Pick<Session, 'id'>\n        ) | (\n          { __typename?: 'User' }\n          & Pick<User, 'name' | 'id'>\n        ) }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "InlineFragmentQuery",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5574,
                "column": 29
            },
            "line": 5574,
            "code": "      it('InlineFragmentQuery', async () => {\n        const document = parse(/* GraphQL */ `\n          query InlineFragmentQuery {\n            user {\n              ... on User {\n                friends {\n                  id\n                }\n              }\n              ... on User {\n                friends {\n                  name\n                }\n              }\n            }\n          }\n        `);\n\n        const { content } = await plugin(\n          schema,\n          [{ location: '', document }],\n          { preResolveTypes: false },\n          {\n            outputFile: 'graphql.ts',\n          }\n        );\n\n        expect(content).toBeSimilarStringTo(`\n          export type InlineFragmentQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n          export type InlineFragmentQueryQuery = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'id' | 'name'>\n              )> }\n            ) }\n          );\n        `);\n      });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "SpreadFragmentQuery",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5616,
                "column": 29
            },
            "line": 5616,
            "code": "      it('SpreadFragmentQuery', async () => {\n        const document = parse(/* GraphQL */ `\n          fragment UserFriendsIdFragment on Query {\n            user {\n              friends {\n                id\n              }\n            }\n          }\n\n          fragment UserFriendsNameFragment on Query {\n            user {\n              friends {\n                name\n              }\n            }\n          }\n\n          query SpreadFragmentQuery {\n            ...UserFriendsIdFragment\n            ...UserFriendsNameFragment\n          }\n        `);\n\n        const { content } = await plugin(\n          schema,\n          [{ location: '', document }],\n          { preResolveTypes: false },\n          {\n            outputFile: 'graphql.ts',\n          }\n        );\n\n        expect(content).toBeSimilarStringTo(`\n          export type UserFriendsIdFragmentFragment = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'id'>\n              )> }\n            ) }\n          );\n\n          export type UserFriendsNameFragmentFragment = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'name'>\n              )> }\n            ) }\n          );\n\n          export type SpreadFragmentQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n          export type SpreadFragmentQueryQuery = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'id' | 'name'>\n              )> }\n            ) }\n          );\n\n        `);\n      });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "SpreadFragmentWithSelectionQuery",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5687,
                "column": 42
            },
            "line": 5687,
            "code": "      it('SpreadFragmentWithSelectionQuery', async () => {\n        const document = parse(/* GraphQL */ `\n          fragment UserFriendsNameFragment on Query {\n            user {\n              friends {\n                name\n              }\n            }\n          }\n\n          query SpreadFragmentWithSelectionQuery {\n            user {\n              id\n              friends {\n                id\n              }\n            }\n            ...UserFriendsNameFragment\n          }\n        `);\n\n        const { content } = await plugin(\n          schema,\n          [{ location: '', document }],\n          { preResolveTypes: false },\n          {\n            outputFile: 'graphql.ts',\n          }\n        );\n\n        expect(content).toBeSimilarStringTo(`\n          export type UserFriendsNameFragmentFragment = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'name'>\n              )> }\n            ) }\n          );\n\n          export type SpreadFragmentWithSelectionQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n          export type SpreadFragmentWithSelectionQueryQuery = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & Pick<User, 'id'>\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'id' | 'name'>\n              )> }\n            ) }\n          );\n        `);\n      });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "SpreadFragmentWithSelectionQuery - flatten",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5744,
                "column": 52
            },
            "line": 5744,
            "code": "      it('SpreadFragmentWithSelectionQuery - flatten', async () => {\n        const document = parse(/* GraphQL */ `\n          fragment UserFriendsNameFragment on Query {\n            user {\n              friends {\n                name\n              }\n            }\n          }\n\n          query SpreadFragmentWithSelectionQuery {\n            user {\n              id\n              friends {\n                id\n              }\n            }\n            ...UserFriendsNameFragment\n          }\n        `);\n\n        const { content } = await plugin(\n          schema,\n          [{ location: '', document }],\n          { preResolveTypes: false },\n          {\n            outputFile: 'graphql.ts',\n          }\n        );\n\n        expect(content).toBeSimilarStringTo(`\n          export type UserFriendsNameFragmentFragment = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'name'>\n              )> }\n            ) }\n          );\n\n          export type SpreadFragmentWithSelectionQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n          export type SpreadFragmentWithSelectionQueryQuery = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & Pick<User, 'id'>\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'id' | 'name'>\n              )> }\n            ) }\n          );\n        `);\n      });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#7811 - generates $fragmentName for fragment subtypes for fragment masking",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5803,
                "column": 82
            },
            "line": 5803,
            "code": "    it('#7811 - generates $fragmentName for fragment subtypes for fragment masking', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Character {\n          name: String\n        }\n\n        type Jedi {\n          name: String\n          side: String\n        }\n\n        type Droid {\n          model: String\n        }\n\n        union People = Character | Jedi | Droid\n\n        type Query {\n          people: People!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query GetPeople {\n          people {\n            ...PeopleInfo\n          }\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        fragment PeopleInfo on People {\n          ... on Character {\n            name\n          }\n\n          ... on Jedi {\n            side\n          }\n\n          ... on Droid {\n            model\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [\n          { location: '', document: query },\n          { location: '', document: fragment },\n        ],\n        { inlineFragmentTypes: 'mask' },\n        { outputFile: 'graphql.ts' }\n      );\n\n      expect(content).toMatchInlineSnapshot(`\n        \"export type GetPeopleQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type GetPeopleQuery = { __typename?: 'Query', people: (\n            { __typename?: 'Character' }\n            & { ' $fragmentRefs'?: { 'PeopleInfo_Character_Fragment': PeopleInfo_Character_Fragment } }\n          ) | (\n            { __typename?: 'Jedi' }\n            & { ' $fragmentRefs'?: { 'PeopleInfo_Jedi_Fragment': PeopleInfo_Jedi_Fragment } }\n          ) | (\n            { __typename?: 'Droid' }\n            & { ' $fragmentRefs'?: { 'PeopleInfo_Droid_Fragment': PeopleInfo_Droid_Fragment } }\n          ) };\n\n        type PeopleInfo_Character_Fragment = { __typename?: 'Character', name?: string | null } & { ' $fragmentName'?: 'PeopleInfo_Character_Fragment' };\n\n        type PeopleInfo_Jedi_Fragment = { __typename?: 'Jedi', side?: string | null } & { ' $fragmentName'?: 'PeopleInfo_Jedi_Fragment' };\n\n        type PeopleInfo_Droid_Fragment = { __typename?: 'Droid', model?: string | null } & { ' $fragmentName'?: 'PeopleInfo_Droid_Fragment' };\n\n        export type PeopleInfoFragment = PeopleInfo_Character_Fragment | PeopleInfo_Jedi_Fragment | PeopleInfo_Droid_Fragment;\n        \"\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#6874 - generates types when parent type differs from spread fragment member types and preResolveTypes=true",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5885,
                "column": 115
            },
            "line": 5885,
            "code": "    it('#6874 - generates types when parent type differs from spread fragment member types and preResolveTypes=true', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Animal {\n          name: String!\n        }\n        type Bat implements Animal {\n          name: String!\n          features: BatFeatures!\n        }\n        type BatFeatures {\n          color: String!\n          wingspan: Int!\n        }\n        type Snake implements Animal {\n          name: String!\n          features: SnakeFeatures!\n        }\n        type SnakeFeatures {\n          color: String!\n          length: Int!\n        }\n        type Error {\n          message: String!\n        }\n        union SnakeResult = Snake | Error\n        type Query {\n          snake: SnakeResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query SnakeQuery {\n          snake {\n            ... on Snake {\n              name\n              ...AnimalFragment\n            }\n          }\n        }\n        fragment AnimalFragment on Animal {\n          ... on Bat {\n            features {\n              color\n              wingspan\n            }\n          }\n          ... on Snake {\n            features {\n              color\n              length\n            }\n          }\n        }\n      `);\n\n      const config = { preResolveTypes: true };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#8793 selecting __typename should not be optional",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5949,
                "column": 57
            },
            "line": 5949,
            "code": "    it('#8793 selecting __typename should not be optional', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Animal {\n          name: String!\n        }\n        type Bat implements Animal {\n          name: String!\n          features: BatFeatures!\n        }\n        type BatFeatures {\n          color: String!\n          wingspan: Int!\n        }\n        type Snake implements Animal {\n          name: String!\n          features: SnakeFeatures!\n        }\n        type SnakeFeatures {\n          color: String!\n          length: Int!\n        }\n        type Error {\n          message: String!\n        }\n        union SnakeResult = Snake | Error\n        type Query {\n          snake: SnakeResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query SnakeQuery {\n          __typename\n          snake {\n            __typename\n          }\n        }\n      `);\n\n      const config = { preResolveTypes: true };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "fields with @skip, @include should pre resolve into optional",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 5999,
                "column": 68
            },
            "line": 5999,
            "code": "    it('fields with @skip, @include should pre resolve into optional', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n\n        type User {\n          name: String!\n          address: String!\n          nicknames: [String!]\n          parents: [User!]!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($showAddress: Boolean!) {\n          user {\n            name\n            address @include(if: $showAddress)\n            nicknames @include(if: $showNicknames)\n            parents @include(if: $showParents)\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          preResolveTypes: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQueryVariables = Exact<{\n        showAddress: Scalars['Boolean'];\n      }>;\n\n      export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', name: string, address?: string, nicknames?: Array<string> | null, parents?: Array<User> } };`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "objects with @skip, @include should pre resolve into optional",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6043,
                "column": 69
            },
            "line": 6043,
            "code": "    it('objects with @skip, @include should pre resolve into optional', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n\n        type User {\n          id: String!\n          name: String!\n          address: Address!\n          friends: [User!]!\n          moreFriends: [User!]!\n        }\n\n        type Address {\n          city: String!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($showAddress: Boolean!, $showName: Boolean!) {\n          user {\n            id\n            name @include(if: $showName)\n            address @include(if: $showAddress) {\n              city\n            }\n            friends @include(if: $isFriendly) {\n              id\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          preResolveTypes: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQueryVariables = Exact<{\n        showAddress: Scalars['Boolean'];\n        showName: Scalars['Boolean'];\n      }>;\n      export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', id: string, name?: string, address?: { __typename?: 'Address', city: string }, friends?: Array<{ __typename?: 'User', id: string }> } };`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "fields with @skip, @include should make container resolve into MakeOptional type",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6096,
                "column": 88
            },
            "line": 6096,
            "code": "    it('fields with @skip, @include should make container resolve into MakeOptional type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n        type User {\n          id: String!\n          name: String!\n          address: Address!\n          friends: [User!]!\n        }\n        type Address {\n          city: String!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($showAddress: Boolean!, $showName: Boolean!) {\n          user {\n            id\n            name @include(if: $showName)\n            address @include(if: $showAddress) {\n              city\n            }\n            friends @include(if: $isFriendly) {\n              id\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQueryVariables = Exact<{\n        showAddress: Scalars['Boolean'];\n        showName: Scalars['Boolean'];\n      }>;\n\n      export type UserQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & MakeOptional<Pick<User, 'id' | 'name'>, 'name'>\n          & { address?: (\n            { __typename?: 'Address' }\n            & Pick<Address, 'city'>\n          ), friends?: Array<(\n            { __typename?: 'User' }\n            & Pick<User, 'id'>\n          )> }\n        ) }\n      );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "On avoidOptionals:true, fields with @skip, @include should make container resolve into MakeMaybe type",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6158,
                "column": 109
            },
            "line": 6158,
            "code": "    it('On avoidOptionals:true, fields with @skip, @include should make container resolve into MakeMaybe type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user(id: ID!): User!\n        }\n\n        type User {\n          id: ID!\n          username: String!\n          email: String!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user {\n          user(id: 1) {\n            id\n            username\n            email @skip(if: true)\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          avoidOptionals: true,\n          preResolveTypes: false,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type UserQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type UserQuery = (\n          { __typename?: 'Query' }\n          & { user: (\n            { __typename?: 'User' }\n            & MakeMaybe<Pick<User, 'id' | 'username' | 'email'>, 'email'>\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle \"preResolveTypes\" and \"avoidOptionals\" together",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6206,
                "column": 69
            },
            "line": 6206,
            "code": "    it('Should handle \"preResolveTypes\" and \"avoidOptionals\" together', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user(id: ID!): User!\n        }\n\n        type User {\n          id: ID!\n          username: String!\n          email: String\n        }\n      `);\n      const operations = parse(/* GraphQL */ `\n        query user {\n          user(id: 1) {\n            id\n            username\n            email\n          }\n        }\n      `);\n      const config = { avoidOptionals: true, preResolveTypes: true };\n      const { content } = await plugin(schema, [{ location: '', document: operations }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', id: string, username: string, email: string | null } }`\n      );\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "On avoidOptionals:true, optionals (?) on types should be avoided",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6237,
                "column": 72
            },
            "line": 6237,
            "code": "    it('On avoidOptionals:true, optionals (?) on types should be avoided', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: User!\n        }\n\n        type User {\n          messages: [Message!]!\n        }\n\n        type Message {\n          content: String!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query MyQuery($include: Boolean!) {\n          me {\n            messages @include(if: $include) {\n              content\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          avoidOptionals: true,\n          nonOptionalTypename: true,\n          preResolveTypes: false,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type MyQueryQuery = (\n          { __typename: 'Query' }\n          & { me: (\n            { __typename: 'User' }\n            & { messages?: Array<(\n              { __typename: 'Message' }\n              & Pick<Message, 'content'>\n            )> }\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "inline fragment with conditional directives and avoidOptionals",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6289,
                "column": 70
            },
            "line": 6289,
            "code": "    it('inline fragment with conditional directives and avoidOptionals', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n          group: Group!\n        }\n\n        type User {\n          name: String\n        }\n\n        type Group {\n          id: Int!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($withUser: Boolean! = false) {\n          ... @include(if: $withUser) {\n            user {\n              name\n            }\n            group {\n              id\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: true, avoidOptionals: true },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQuery = {\n        __typename?: 'Query',\n        user?: {\n          __typename?: 'User',\n          name: string | null\n        } | null,\n        group?: {\n          __typename?: 'Group',\n          id: number\n        }\n      };`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "resolve optionals according to maybeValue together with avoidOptionals and conditional directives",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6341,
                "column": 105
            },
            "line": 6341,
            "code": "    it('resolve optionals according to maybeValue together with avoidOptionals and conditional directives', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n\n        type User {\n          name: String!\n          age: Int\n          address: String!\n          nicknames: [String!]\n          parents: [User!]!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($showProperty: Boolean!) {\n          user {\n            name\n            age\n            address @include(if: $showProperty)\n            nicknames @include(if: $showProperty)\n            parents @include(if: $showProperty)\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          preResolveTypes: true,\n          maybeValue: \"T | 'specialType'\",\n          avoidOptionals: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n      expect(content).toBeSimilarStringTo(`\n      export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', name: string, age: number | 'specialType', address?: string, nicknames?: Array<string> | 'specialType', parents?: Array<User> } };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "inline fragment with conditional directives and avoidOptionals, without preResolveTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6385,
                "column": 95
            },
            "line": 6385,
            "code": "    it('inline fragment with conditional directives and avoidOptionals, without preResolveTypes', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n          group: Group!\n        }\n\n        type User {\n          name: String\n        }\n\n        type Group {\n          id: Int!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($withUser: Boolean! = false) {\n          ... @include(if: $withUser) {\n            user {\n              name\n            }\n            group {\n              id\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: false, avoidOptionals: true },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQuery = (\n        { __typename?: 'Query' }\n        & { user?: Maybe<(\n          { __typename?: 'User' }\n          & Pick<User, 'name'>\n        )>, group?: (\n          { __typename?: 'Group' }\n          & Pick<Group, 'id'>\n        ) }\n      );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "handles unnamed queries",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6437,
                "column": 29
            },
            "line": 6437,
            "code": "  it('handles unnamed queries', async () => {\n    const ast = parse(/* GraphQL */ `\n      query {\n        notifications {\n          id\n        }\n      }\n    `);\n\n    const result = await plugin(\n      schema,\n      [{ location: 'test-file.ts', document: ast }],\n      { preResolveTypes: false },\n      { outputFile: '' }\n    );\n    expect(result.content).toBeSimilarStringTo(`\n      export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n\n      export type Unnamed_1_Query = (\n          { __typename?: 'Query' }\n        & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n          & Pick<TextNotification, 'id'>\n        ) | (\n            { __typename?: 'ImageNotification' }\n          & Pick<ImageNotification, 'id'>\n        )> }\n      );\n    `);\n  });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "'combine' yields correct types",
            "suites": [
                "TypeScript Operations Plugin",
                "inlineFragmentTypes option"
            ],
            "updatePoint": {
                "line": 6469,
                "column": 38
            },
            "line": 6469,
            "code": "    it(\"'combine' yields correct types\", async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          me {\n            ...UserFragment\n          }\n        }\n        fragment UserFragment on User {\n          id\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [{ location: 'test-file.ts', document: ast }],\n        { inlineFragmentTypes: 'combine' },\n        { outputFile: '' }\n      );\n      expect(result.content).toBeSimilarStringTo(`\n        export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type Unnamed_1_Query = { __typename?: 'Query', me?: (\n            { __typename?: 'User' }\n            & UserFragmentFragment\n          ) | null };\n\n        export type UserFragmentFragment = { __typename?: 'User', id: string };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "'inline' yields correct types",
            "suites": [
                "TypeScript Operations Plugin",
                "inlineFragmentTypes option"
            ],
            "updatePoint": {
                "line": 6499,
                "column": 37
            },
            "line": 6499,
            "code": "    it(\"'inline' yields correct types\", async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          me {\n            ...UserFragment\n          }\n        }\n        fragment UserFragment on User {\n          id\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [{ location: 'test-file.ts', document: ast }],\n        { inlineFragmentTypes: 'inline' },\n        { outputFile: '' }\n      );\n      expect(result.content).toBeSimilarStringTo(`\n        export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type Unnamed_1_Query = { __typename?: 'Query', me?: { __typename?: 'User', id: string } | null };\n\n        export type UserFragmentFragment = { __typename?: 'User', id: string };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "'mask' yields correct types",
            "suites": [
                "TypeScript Operations Plugin",
                "inlineFragmentTypes option"
            ],
            "updatePoint": {
                "line": 6526,
                "column": 35
            },
            "line": 6526,
            "code": "    it(\"'mask' yields correct types\", async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          me {\n            ...UserFragment\n          }\n        }\n        fragment UserFragment on User {\n          id\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [{ location: 'test-file.ts', document: ast }],\n        { inlineFragmentTypes: 'mask' },\n        { outputFile: '' }\n      );\n      expect(result.content).toBeSimilarStringTo(`\n        export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type Unnamed_1_Query = { __typename?: 'Query', me?: (\n            { __typename?: 'User' }\n            & { ' $fragmentRefs'?: { 'UserFragmentFragment': UserFragmentFragment } }\n          ) | null };\n\n        export type UserFragmentFragment = { __typename?: 'User', id: string } & { ' $fragmentName'?: 'UserFragmentFragment' };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should add __resolveReference to objects that have @key",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 27,
                "column": 61
            },
            "line": 27,
            "code": "  it('should add __resolveReference to objects that have @key', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        allUsers: [User]\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // User should have it\n    expect(content).toBeSimilarStringTo(`\n      __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n    `);\n    // Foo shouldn't because it doesn't have @key\n    expect(content).not.toBeSimilarStringTo(`\n      __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['Book']>, { __typename: 'Book' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support extend keyword",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 61,
                "column": 35
            },
            "line": 61,
            "code": "  it('should support extend keyword', async () => {\n    const federatedSchema = /* GraphQL */ `\n      extend type Query {\n        allUsers: [User]\n      }\n\n      extend type User @key(fields: \"id\") {\n        id: ID!\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // User should have it\n    expect(content).toBeSimilarStringTo(`\n      __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n    `);\n    // Foo shouldn't because it doesn't have @key\n    expect(content).not.toBeSimilarStringTo(`\n      __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['Book']>, { __typename: 'Book' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should include nested fields from @provides directive",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 95,
                "column": 59
            },
            "line": 95,
            "code": "  it('should include nested fields from @provides directive', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type Book {\n        author: User @provides(fields: \"name { first last}\")\n      }\n\n      type Name @key(fields: \"id\") {\n        id: ID! @external\n        first: String!\n        middle: String @external\n        last: String!\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: Name @external\n        username: String @external\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        name?: Resolver<Maybe<ResolversTypes['Name']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      }\n    `);\n\n    expect(content).toBeSimilarStringTo(`\n      export type NameResolvers<ContextType = any, ParentType extends ResolversParentTypes['Name'] = ResolversParentTypes['Name']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['Name']>, { __typename: 'Name' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        first?: Resolver<ResolversTypes['String'], { __typename: 'Name' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        last?: Resolver<ResolversTypes['String'], { __typename: 'Name' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      }\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should include fields from @requires directive",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 145,
                "column": 52
            },
            "line": 145,
            "code": "  it('should include fields from @requires directive', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String @external\n        age: Int! @external\n        username: String @requires(fields: \"name age\")\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // User should have it\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        username?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}> & GraphQLRecursivePick<ParentType, {\"name\":true,\"age\":true}>, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should handle nested fields from @requires directive",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 177,
                "column": 58
            },
            "line": 177,
            "code": "  it('should handle nested fields from @requires directive', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      extend type User @key(fields: \"id\") {\n        id: ID! @external\n        name: String @external\n        age: Int! @external\n        address: Address! @external\n        username: String @requires(fields: \"name age address { street }\")\n      }\n\n      extend type Address {\n        street: String! @external\n        zip: Int! @external\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        username?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}> & GraphQLRecursivePick<ParentType, {\"name\":true,\"age\":true,\"address\":{\"street\":true}}>, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should handle nested fields from @key directive",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 213,
                "column": 53
            },
            "line": 213,
            "code": "  it('should handle nested fields from @key directive', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type User @key(fields: \"name { first last }\") {\n        name: Name! @external\n        username: String\n      }\n\n      type Name {\n        first: String! @external\n        last: String! @external\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"name\":{\"first\":true,\"last\":true}}>, ContextType>;\n        username?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"name\":{\"first\":true,\"last\":true}}>, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not apply key/requires fields restriction for base federated types",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 246,
                "column": 79
            },
            "line": 246,
            "code": "  it('should not apply key/requires fields restriction for base federated types', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type User @key(fields: \"name { first last }\") {\n        name: Name!\n        username: String\n      }\n\n      type Name {\n        first: String!\n        last: String!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"name\":{\"first\":true,\"last\":true}}>, ContextType>;\n        name?: Resolver<ResolversTypes['Name'], ParentType, ContextType>;\n        username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should handle interface types",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "line": 280,
            "code": "  it.skip('should handle interface types', async () => {",
            "file": "federation.spec.ts",
            "skipped": true,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should skip to generate resolvers of fields with @external directive",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 324,
                "column": 74
            },
            "line": 324,
            "code": "  it('should skip to generate resolvers of fields with @external directive', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type Book {\n        author: User @provides(fields: \"name\")\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String @external\n        username: String @external\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // UserResolver should not have a resolver function of name field\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        name?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not include _FieldSet scalar",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 359,
                "column": 41
            },
            "line": 359,
            "code": "  it('should not include _FieldSet scalar', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).not.toMatch(`_FieldSet`);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not include federation directives",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 386,
                "column": 46
            },
            "line": 386,
            "code": "  it('should not include federation directives', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).not.toMatch('ExternalDirectiveResolver');\n    expect(content).not.toMatch('RequiresDirectiveResolver');\n    expect(content).not.toMatch('ProvidesDirectiveResolver');\n    expect(content).not.toMatch('KeyDirectiveResolver');\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not add directive definitions and scalars if they are already there",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 416,
                "column": 80
            },
            "line": 416,
            "code": "  it('should not add directive definitions and scalars if they are already there', async () => {\n    const federatedSchema = /* GraphQL */ `\n      scalar _FieldSet\n\n      directive @key(fields: _FieldSet!) on OBJECT | INTERFACE\n\n      type Query {\n        allUsers: [User]\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).not.toMatch(`_FieldSet`);\n    expect(content).not.toMatch('ExternalDirectiveResolver');\n    expect(content).not.toMatch('RequiresDirectiveResolver');\n    expect(content).not.toMatch('ProvidesDirectiveResolver');\n    expect(content).not.toMatch('KeyDirectiveResolver');\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should allow for duplicated directives",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 451,
                "column": 44
            },
            "line": 451,
            "code": "  it('should allow for duplicated directives', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        allUsers: [User]\n      }\n\n      extend type User @key(fields: \"id\") @key(fields: \"name\") {\n        id: ID! @external\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // User should have it\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & (GraphQLRecursivePick<ParentType, {\"id\":true}> | GraphQLRecursivePick<ParentType, {\"name\":true}>), ContextType>;\n        name?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & (GraphQLRecursivePick<ParentType, {\"id\":true}> | GraphQLRecursivePick<ParentType, {\"name\":true}>), ContextType>;\n        username?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & (GraphQLRecursivePick<ParentType, {\"id\":true}> | GraphQLRecursivePick<ParentType, {\"name\":true}>), ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should only extend an original type by a mapped type",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "line": 486,
            "code": "  it.skip('should only extend an original type by a mapped type', async () => {",
            "file": "federation.spec.ts",
            "skipped": true,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not generate unused scalars",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 520,
                "column": 40
            },
            "line": 520,
            "code": "  it('should not generate unused scalars', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        user(id: ID!): User!\n      }\n\n      type User {\n        id: ID!\n        username: String!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // no GraphQLScalarTypeConfig\n    expect(content).not.toContain('GraphQLScalarTypeConfig');\n    // no GraphQLScalarType\n    expect(content).not.toContain('GraphQLScalarType');\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should add the UnwrappedObject type",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation",
                "When field definition wrapping is enabled"
            ],
            "updatePoint": {
                "line": 546,
                "column": 43
            },
            "line": 546,
            "code": "    it('should add the UnwrappedObject type', async () => {\n      const federatedSchema = /* GraphQL */ `\n        type User @key(fields: \"id\") {\n          id: ID!\n        }\n      `;\n\n      const content = await generate({\n        schema: federatedSchema,\n        config: {\n          federation: true,\n          wrapFieldDefinitions: true,\n        },\n      });\n\n      expect(content).toBeSimilarStringTo(`type UnwrappedObject<T> = {`);\n    });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should add UnwrappedObject around ParentType for __resloveReference",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation",
                "When field definition wrapping is enabled"
            ],
            "updatePoint": {
                "line": 564,
                "column": 75
            },
            "line": 564,
            "code": "    it('should add UnwrappedObject around ParentType for __resloveReference', async () => {\n      const federatedSchema = /* GraphQL */ `\n        type User @key(fields: \"id\") {\n          id: ID!\n        }\n      `;\n\n      const content = await generate({\n        schema: federatedSchema,\n        config: {\n          federation: true,\n          wrapFieldDefinitions: true,\n        },\n      });\n\n      // __resolveReference should be unwrapped\n      expect(content).toBeSimilarStringTo(`\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<UnwrappedObject<ParentType>, {\"id\":true}>, ContextType>;\n      `);\n      // but ID should not\n      expect(content).toBeSimilarStringTo(`id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>`);\n    });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes object when there are no mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 7,
                "column": 66
            },
            "line": 7,
            "code": "  it('Should build ResolversTypes object when there are no mappers', async () => {\n    const result = await plugin(resolversTestingSchema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Child ) | ( MyOtherType );\n        MyUnion: ( Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> } ) | ( MyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Child ) | ( MyOtherType );\n        MyUnion: ( Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> } ) | ( MyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Child>;\n      MyOtherType: ResolverTypeWrapper<MyOtherType>;\n      ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> };\n        String: Scalars['String'];\n        Child: Child;\n        MyOtherType: MyOtherType;\n        ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: Scalars['ID'];\n        SomeNode: SomeNode;\n        MyUnion: ResolversUnionParentTypes['MyUnion'];\n        MyScalar: Scalars['MyScalar'];\n        Int: Scalars['Int'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with simple mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 60,
                "column": 53
            },
            "line": 60,
            "code": "  it('Should build ResolversTypes with simple mappers', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        mappers: {\n          MyType: 'MyTypeDb',\n          String: 'number',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Omit<Child, 'bar' | 'parent'> & { bar: ResolversTypes['String'], parent?: Maybe<ResolversTypes['MyType']> } ) | ( Omit<MyOtherType, 'bar'> & { bar: ResolversTypes['String'] } );\n        MyUnion: ( MyTypeDb ) | ( Omit<MyOtherType, 'bar'> & { bar: ResolversTypes['String'] } );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Omit<Child, 'bar' | 'parent'> & { bar: ResolversParentTypes['String'], parent?: Maybe<ResolversParentTypes['MyType']> } ) | ( Omit<MyOtherType, 'bar'> & { bar: ResolversParentTypes['String'] } );\n        MyUnion: ( MyTypeDb ) | ( Omit<MyOtherType, 'bar'> & { bar: ResolversParentTypes['String'] } );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<MyTypeDb>;\n        String: ResolverTypeWrapper<number>;\n        Child: ResolverTypeWrapper<Omit<Child, 'bar' | 'parent'> & { bar: ResolversTypes['String'], parent?: Maybe<ResolversTypes['MyType']> }>;\n        MyOtherType: ResolverTypeWrapper<Omit<MyOtherType, 'bar'> & { bar: ResolversTypes['String'] }>;\n        ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n        Query: ResolverTypeWrapper<{}>;\n        Subscription: ResolverTypeWrapper<{}>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        SomeNode: ResolverTypeWrapper<SomeNode>;\n        MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n        MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n        Int: ResolverTypeWrapper<Scalars['Int']>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: MyTypeDb;\n        String: number;\n        Child: Omit<Child, 'bar' | 'parent'> & { bar: ResolversParentTypes['String'], parent?: Maybe<ResolversParentTypes['MyType']> };\n        MyOtherType: Omit<MyOtherType, 'bar'> & { bar: ResolversParentTypes['String'] };\n        ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: Scalars['ID'];\n        SomeNode: SomeNode;\n        MyUnion: ResolversUnionParentTypes['MyUnion'];\n        MyScalar: Scalars['MyScalar'];\n        Int: Scalars['Int'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to map custom type that refers itself (issue #1770)",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 123,
                "column": 70
            },
            "line": 123,
            "code": "  it('Should allow to map custom type that refers itself (issue #1770)', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Movie {\n        id: ID!\n        title: String!\n      }\n\n      type Book {\n        id: ID!\n        author: String!\n      }\n\n      union MovieLike = Movie | Book\n\n      type NonInterfaceHasNarrative {\n        narrative: MovieLike!\n        movie: Movie!\n      }\n    `);\n    const result = (await plugin(\n      testSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          Movie: 'MovieEntity',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n    const content = mergeOutputs([result]);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        MovieLike: ( MovieEntity ) | ( Book );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        MovieLike: ( MovieEntity ) | ( Book );\n      };\n    `);\n    expect(content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        Movie: ResolverTypeWrapper<MovieEntity>;\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Book: ResolverTypeWrapper<Book>;\n        MovieLike: ResolverTypeWrapper<ResolversUnionTypes['MovieLike']>;\n        NonInterfaceHasNarrative: ResolverTypeWrapper<Omit<NonInterfaceHasNarrative, 'narrative' | 'movie'> & { narrative: ResolversTypes['MovieLike'], movie: ResolversTypes['Movie'] }>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n    expect(content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        Movie: MovieEntity;\n        ID: Scalars['ID'];\n        String: Scalars['String'];\n        Book: Book;\n        MovieLike: ResolversUnionParentTypes['MovieLike'];\n        NonInterfaceHasNarrative: Omit<NonInterfaceHasNarrative, 'narrative' | 'movie'> & { narrative: ResolversParentTypes['MovieLike'], movie: ResolversParentTypes['Movie'] };\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to map custom type that refers itself (issue #1770, attempt #2)",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 189,
                "column": 82
            },
            "line": 189,
            "code": "  it('Should allow to map custom type that refers itself (issue #1770, attempt #2)', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Movie {\n        id: ID!\n        title: String!\n      }\n\n      type Book {\n        id: ID!\n        author: String!\n      }\n\n      union MovieLike = Movie | Book\n\n      type NonInterfaceHasNarrative {\n        narrative: MovieLike!\n        movie: Movie!\n      }\n\n      type LayerOfIndirection {\n        id: ID!\n        movies: [NonInterfaceHasNarrative!]!\n      }\n\n      type AnotherLayerOfIndirection {\n        inner: LayerOfIndirection!\n      }\n    `);\n    const result = (await plugin(\n      testSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          Movie: 'MovieEntity',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n    const content = mergeOutputs([result]);\n\n    expect(content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        MovieLike: ( MovieEntity ) | ( Book );\n      };\n    `);\n    expect(content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        MovieLike: ( MovieEntity ) | ( Book );\n      };\n    `);\n    expect(content).toBeSimilarStringTo(`export type ResolversTypes = {\n      Movie: ResolverTypeWrapper<MovieEntity>;\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Book: ResolverTypeWrapper<Book>;\n      MovieLike: ResolverTypeWrapper<ResolversUnionTypes['MovieLike']>;\n      NonInterfaceHasNarrative: ResolverTypeWrapper<Omit<NonInterfaceHasNarrative, 'narrative' | 'movie'> & { narrative: ResolversTypes['MovieLike'], movie: ResolversTypes['Movie'] }>;\n      LayerOfIndirection: ResolverTypeWrapper<Omit<LayerOfIndirection, 'movies'> & { movies: Array<ResolversTypes['NonInterfaceHasNarrative']> }>;\n      AnotherLayerOfIndirection: ResolverTypeWrapper<Omit<AnotherLayerOfIndirection, 'inner'> & { inner: ResolversTypes['LayerOfIndirection'] }>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n    expect(content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        Movie: MovieEntity;\n        ID: Scalars['ID'];\n        String: Scalars['String'];\n        Book: Book;\n        MovieLike: ResolversUnionParentTypes['MovieLike'];\n        NonInterfaceHasNarrative: Omit<NonInterfaceHasNarrative, 'narrative' | 'movie'> & { narrative: ResolversParentTypes['MovieLike'], movie: ResolversParentTypes['Movie'] };\n        LayerOfIndirection: Omit<LayerOfIndirection, 'movies'> & { movies: Array<ResolversParentTypes['NonInterfaceHasNarrative']> };\n        AnotherLayerOfIndirection: Omit<AnotherLayerOfIndirection, 'inner'> & { inner: ResolversParentTypes['LayerOfIndirection'] };\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to map custom type that refers itself (issue #1770, attempt #3 - circular)",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 266,
                "column": 93
            },
            "line": 266,
            "code": "  it('Should allow to map custom type that refers itself (issue #1770, attempt #3 - circular)', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Account {\n        id: ID!\n        name: String!\n        programs: [Program!]!\n      }\n\n      type Program {\n        id: ID!\n        name: String!\n        account: Account!\n      }\n    `);\n    const result = (await plugin(\n      testSchema,\n      [],\n      {\n        typesPrefix: 'Gql',\n        defaultMapper: 'Partial<{T}>',\n        namingConvention: {\n          typeNames: 'change-case-all#pascalCase',\n          enumValues: 'change-case-all#upperCase',\n        },\n        noSchemaStitching: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n    const content = mergeOutputs([result]);\n\n    expect(content).toBeSimilarStringTo(`export type GqlResolversTypes = {\n      Account: ResolverTypeWrapper<Partial<GqlAccount>>;\n      ID: ResolverTypeWrapper<Partial<Scalars['ID']>>;\n      String: ResolverTypeWrapper<Partial<Scalars['String']>>;\n      Program: ResolverTypeWrapper<Partial<GqlProgram>>;\n      Boolean: ResolverTypeWrapper<Partial<Scalars['Boolean']>>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should map to a custom type on every level (+ actual usage in code)",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 305,
                "column": 73
            },
            "line": 305,
            "code": "  it('should map to a custom type on every level (+ actual usage in code)', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type User {\n        id: ID!\n        name: String!\n        chats: [Chat!]\n      }\n\n      type Chat {\n        id: ID!\n        owner: User!\n        members: [User!]\n      }\n\n      type Query {\n        me: User\n      }\n    `);\n    const result = (await plugin(\n      testSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          ID: 'number',\n          Chat: 'number',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    const usage = `\n      const resolvers: Resolvers = {\n        Query: {\n          me() {\n            return {\n              id: 1,\n              name: 'Foo',\n              chats: [0,1,2],\n            };\n          }\n        },\n        Chat: {\n          id(parent) {\n            const id: number = parent;\n            return id;\n          }\n        }\n      }\n    `;\n\n    await resolversTestingValidate(\n      mergeOutputs([usage, result]),\n      {\n        scalars: {\n          ID: 'number',\n        },\n      },\n      testSchema\n    );\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with defaultMapper set using {T}",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 367,
                "column": 66
            },
            "line": 367,
            "code": "  it('Should build ResolversTypes with defaultMapper set using {T}', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        defaultMapper: 'Partial<{T}>',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Partial<Child> ) | ( Partial<MyOtherType> );\n        MyUnion: ( Partial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }> ) | ( Partial<MyOtherType> );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Partial<Child> ) | ( Partial<MyOtherType> );\n        MyUnion: ( Partial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> }> ) | ( Partial<MyOtherType> );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<Partial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>>;\n      String: ResolverTypeWrapper<Partial<Scalars['String']>>;\n      Child: ResolverTypeWrapper<Partial<Child>>;\n      MyOtherType: ResolverTypeWrapper<Partial<MyOtherType>>;\n      ChildUnion: Partial<ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Partial<Scalars['ID']>>;\n      SomeNode: ResolverTypeWrapper<Partial<SomeNode>>;\n      MyUnion: Partial<ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>>;\n      MyScalar: ResolverTypeWrapper<Partial<Scalars['MyScalar']>>;\n      Int: ResolverTypeWrapper<Partial<Scalars['Int']>>;\n      Boolean: ResolverTypeWrapper<Partial<Scalars['Boolean']>>;\n    };`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: Partial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> }>;\n        String: Partial<Scalars['String']>;\n        Child: Partial<Child>;\n        MyOtherType: Partial<MyOtherType>;\n        ChildUnion: Partial<ResolversUnionParentTypes['ChildUnion']>;\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: Partial<Scalars['ID']>;\n        SomeNode: Partial<SomeNode>;\n        MyUnion: Partial<ResolversUnionParentTypes['MyUnion']>;\n        MyScalar: Partial<Scalars['MyScalar']>;\n        Int: Partial<Scalars['Int']>;\n        Boolean: Partial<Scalars['Boolean']>;\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with defaultMapper set using {T} with external identifier",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 427,
                "column": 91
            },
            "line": 427,
            "code": "  it('Should build ResolversTypes with defaultMapper set using {T} with external identifier', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        defaultMapper: './my-wrapper#CustomPartial<{T}>',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { CustomPartial } from './my-wrapper';`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( CustomPartial<Child> ) | ( CustomPartial<MyOtherType> );\n        MyUnion: ( CustomPartial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }> ) | ( CustomPartial<MyOtherType> );\n      }\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( CustomPartial<Child> ) | ( CustomPartial<MyOtherType> );\n        MyUnion: ( CustomPartial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> }> ) | ( CustomPartial<MyOtherType> );\n      }\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<CustomPartial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>>;\n      String: ResolverTypeWrapper<CustomPartial<Scalars['String']>>;\n      Child: ResolverTypeWrapper<CustomPartial<Child>>;\n      MyOtherType: ResolverTypeWrapper<CustomPartial<MyOtherType>>;\n      ChildUnion: CustomPartial<ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<CustomPartial<Scalars['ID']>>;\n      SomeNode: ResolverTypeWrapper<CustomPartial<SomeNode>>;\n      MyUnion: CustomPartial<ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>>;\n      MyScalar: ResolverTypeWrapper<CustomPartial<Scalars['MyScalar']>>;\n      Int: ResolverTypeWrapper<CustomPartial<Scalars['Int']>>;\n      Boolean: ResolverTypeWrapper<CustomPartial<Scalars['Boolean']>>;\n    };`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: CustomPartial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> }>;\n        String: CustomPartial<Scalars['String']>;\n        Child: CustomPartial<Child>;\n        MyOtherType: CustomPartial<MyOtherType>;\n        ChildUnion: CustomPartial<ResolversUnionParentTypes['ChildUnion']>;\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: CustomPartial<Scalars['ID']>;\n        SomeNode: CustomPartial<SomeNode>;\n        MyUnion: CustomPartial<ResolversUnionParentTypes['MyUnion']>;\n        MyScalar: CustomPartial<Scalars['MyScalar']>;\n        Int: CustomPartial<Scalars['Int']>;\n        Boolean: CustomPartial<Scalars['Boolean']>;\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with mapper set for concrete type using {T} with external identifier",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 488,
                "column": 102
            },
            "line": 488,
            "code": "  it('Should build ResolversTypes with mapper set for concrete type using {T} with external identifier', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyType: './my-wrapper#CustomPartial<{T}>',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { CustomPartial } from './my-wrapper';`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> } ) | ( MyOtherType );\n        MyUnion: ( CustomPartial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }> ) | ( MyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> } ) | ( MyOtherType );\n        MyUnion: ( CustomPartial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> }> ) | ( MyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<CustomPartial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<MyOtherType>;\n      ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: CustomPartial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> }>;\n        String: Scalars['String'];\n        Child: Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> };\n        MyOtherType: MyOtherType;\n        ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: Scalars['ID'];\n        SomeNode: SomeNode;\n        MyUnion: ResolversUnionParentTypes['MyUnion'];\n        MyScalar: Scalars['MyScalar'];\n        Int: Scalars['Int'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should map to a custom type on every level when {T} is used as default mapper",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 551,
                "column": 83
            },
            "line": 551,
            "code": "  it('Should map to a custom type on every level when {T} is used as default mapper', async () => {\n    const config = {\n      scalars: {\n        ID: 'number',\n      },\n      noSchemaStitching: true,\n      defaultMapper: 'Partial<{T}>',\n      mappers: {\n        User: 'number',\n      },\n    };\n    const testSchema = buildSchema(/* GraphQL */ `\n      type User {\n        id: ID!\n        name: String!\n        chats: [Chat!]\n      }\n\n      type Chat {\n        id: ID!\n        owner: User!\n        members: [User!]\n      }\n\n      type Query {\n        me: User\n      }\n    `);\n    const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        User: ResolverTypeWrapper<number>;\n        ID: ResolverTypeWrapper<Partial<Scalars['ID']>>;\n        String: ResolverTypeWrapper<Partial<Scalars['String']>>;\n        Chat: ResolverTypeWrapper<Partial<Omit<Chat, 'owner' | 'members'> & { owner: ResolversTypes['User'], members?: Maybe<Array<ResolversTypes['User']>> }>>;\n        Query: ResolverTypeWrapper<{}>;\n        Boolean: ResolverTypeWrapper<Partial<Scalars['Boolean']>>;\n      };\n    `);\n\n    const usage = `\n      const resolvers: Resolvers = {\n        Query: {\n          me() {\n            return 1;\n          }\n        },\n        Chat: {\n          id(chat) {\n            return chat.id;\n          },\n          owner(chat) {\n            const id: number = chat.owner;\n            return id;\n          },\n          members(chat) {\n            const ids: number[] = chat.members;\n            return ids;\n          }\n        },\n        User: {\n          id(parent) {\n            const id: number = parent;\n            return id;\n          }\n        }\n      }\n    `;\n\n    await resolversTestingValidate(mergeOutputs([result, usage]), config, testSchema);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with mapper set for concrete type using renamed external identifier",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 624,
                "column": 101
            },
            "line": 624,
            "code": "  it('Should build ResolversTypes with mapper set for concrete type using renamed external identifier', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyType: './my-type#MyType as DatabaseMyType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyType as DatabaseMyType } from './my-type';`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> } ) | ( MyOtherType );\n        MyUnion: ( DatabaseMyType ) | ( MyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> } ) | ( MyOtherType );\n        MyUnion: ( DatabaseMyType ) | ( MyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<DatabaseMyType>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<MyOtherType>;\n      ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: DatabaseMyType;\n        String: Scalars['String'];\n        Child: Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> };\n        MyOtherType: MyOtherType;\n        ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: Scalars['ID'];\n        SomeNode: SomeNode;\n        MyUnion: ResolversUnionParentTypes['MyUnion'];\n        MyScalar: Scalars['MyScalar'];\n        Int: Scalars['Int'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with mapper set for concrete type using renamed external identifier (with default)",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 687,
                "column": 116
            },
            "line": 687,
            "code": "  it('Should build ResolversTypes with mapper set for concrete type using renamed external identifier (with default)', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: './my-type#default as DatabaseMyOtherType',\n          MyType: './my-type#MyType as DatabaseMyType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import DatabaseMyOtherType, { MyType as DatabaseMyType } from './my-type';`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> } ) | ( DatabaseMyOtherType );\n        MyUnion: ( DatabaseMyType ) | ( DatabaseMyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> } ) | ( DatabaseMyOtherType );\n        MyUnion: ( DatabaseMyType ) | ( DatabaseMyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<DatabaseMyType>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<DatabaseMyOtherType>;\n      ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: DatabaseMyType;\n        String: Scalars['String'];\n        Child: Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> };\n        MyOtherType: DatabaseMyOtherType;\n        ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: Scalars['ID'];\n        SomeNode: SomeNode;\n        MyUnion: ResolversUnionParentTypes['MyUnion'];\n        MyScalar: Scalars['MyScalar'];\n        Int: Scalars['Int'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with mapper set for concrete type using renamed external identifier (with default) and type import",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 751,
                "column": 132
            },
            "line": 751,
            "code": "  it('Should build ResolversTypes with mapper set for concrete type using renamed external identifier (with default) and type import', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: './my-type#default as DatabaseMyOtherType',\n          MyType: './my-type#MyType as DatabaseMyType',\n        },\n        useTypeImports: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(\n      `import type { default as DatabaseMyOtherType, MyType as DatabaseMyType } from './my-type';`\n    );\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> } ) | ( DatabaseMyOtherType );\n        MyUnion: ( DatabaseMyType ) | ( DatabaseMyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> } ) | ( DatabaseMyOtherType );\n        MyUnion: ( DatabaseMyType ) | ( DatabaseMyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<DatabaseMyType>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<DatabaseMyOtherType>;\n      ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: DatabaseMyType;\n        String: Scalars['String'];\n        Child: Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> };\n        MyOtherType: DatabaseMyOtherType;\n        ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: Scalars['ID'];\n        SomeNode: SomeNode;\n        MyUnion: ResolversUnionParentTypes['MyUnion'];\n        MyScalar: Scalars['MyScalar'];\n        Int: Scalars['Int'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with defaultMapper set",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 818,
                "column": 56
            },
            "line": 818,
            "code": "  it('Should build ResolversTypes with defaultMapper set', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyType: 'MyTypeDb',\n          String: 'string',\n        },\n        defaultMapper: 'any',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).not.toBeSimilarStringTo(`export type ResolversUnionTypes`);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<MyTypeDb>;\n      String: ResolverTypeWrapper<string>;\n      Child: ResolverTypeWrapper<any>;\n      MyOtherType: ResolverTypeWrapper<any>;\n      ChildUnion: ResolverTypeWrapper<any>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<any>;\n      SomeNode: ResolverTypeWrapper<any>;\n      MyUnion: ResolverTypeWrapper<any>;\n      MyScalar: ResolverTypeWrapper<any>;\n      Int: ResolverTypeWrapper<any>;\n      Boolean: ResolverTypeWrapper<any>;\n    };`);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversParentTypes = {\n      MyType: MyTypeDb;\n      String: string;\n      Child: any;\n      MyOtherType: any;\n      ChildUnion: any;\n      Query: {};\n      Subscription: {};\n      Node: ResolversParentTypes['SomeNode'];\n      ID: any;\n      SomeNode: any;\n      MyUnion: any;\n      MyScalar: any;\n      Int: any;\n      Boolean: any;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with external mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 870,
                "column": 55
            },
            "line": 870,
            "code": "  it('Should build ResolversTypes with external mappers', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: './my-module#CustomMyOtherType',\n          MyType: 'MyTypeDb',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> } ) | ( CustomMyOtherType );\n        MyUnion: ( MyTypeDb ) | ( CustomMyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> } ) | ( CustomMyOtherType );\n        MyUnion: ( MyTypeDb ) | ( CustomMyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<MyTypeDb>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<CustomMyOtherType>;\n      ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: MyTypeDb;\n        String: Scalars['String'];\n        Child: Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> };\n        MyOtherType: CustomMyOtherType;\n        ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: Scalars['ID'];\n        SomeNode: SomeNode;\n        MyUnion: ResolversUnionParentTypes['MyUnion'];\n        MyScalar: Scalars['MyScalar'];\n        Int: Scalars['Int'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should handle {T} in a mapper",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 933,
                "column": 35
            },
            "line": 933,
            "code": "  it('Should handle {T} in a mapper', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyType: 'Partial<{T}>',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> } ) | ( MyOtherType );\n        MyUnion: ( Partial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }> ) | ( MyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> } ) | ( MyOtherType );\n        MyUnion: ( Partial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> }> ) | ( MyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<Partial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n        MyOtherType: ResolverTypeWrapper<MyOtherType>;\n        ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n        Query: ResolverTypeWrapper<{}>;\n        Subscription: ResolverTypeWrapper<{}>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        SomeNode: ResolverTypeWrapper<SomeNode>;\n        MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n        MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n        Int: ResolverTypeWrapper<Scalars['Int']>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: Partial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> }>;\n        String: Scalars['String'];\n        Child: Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> };\n        MyOtherType: MyOtherType;\n        ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: Scalars['ID'];\n        SomeNode: SomeNode;\n        MyUnion: ResolversUnionParentTypes['MyUnion'];\n        MyScalar: Scalars['MyScalar'];\n        Int: Scalars['Int'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should warn about unused mappers by default",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 997,
                "column": 49
            },
            "line": 997,
            "code": "  it('should warn about unused mappers by default', async () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        comments: [Comment!]!\n      }\n\n      type User {\n        id: ID!\n        name: String!\n      }\n\n      type Comment {\n        id: ID!\n        text: String!\n        author: User!\n      }\n    `);\n\n    await plugin(\n      testSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          Comment: 'number',\n          Post: 'string',\n        },\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    );\n\n    expect(spy).toHaveBeenCalledWith('Unused mappers: Post');\n    spy.mockRestore();\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should be able not to warn about unused mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1035,
                "column": 53
            },
            "line": 1035,
            "code": "  it('should be able not to warn about unused mappers', async () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        comments: [Comment!]!\n      }\n\n      type User {\n        id: ID!\n        name: String!\n      }\n\n      type Comment {\n        id: ID!\n        text: String!\n        author: User!\n      }\n    `);\n\n    await plugin(\n      testSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          Comment: 'number',\n          Post: 'string',\n        },\n        showUnusedMappers: false,\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    );\n\n    expect(spy).not.toHaveBeenCalled();\n    spy.mockRestore();\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with external mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1074,
                "column": 64
            },
            "line": 1074,
            "code": "  it('Should generate basic type resolvers with external mappers', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: './my-file#MyCustomOtherType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomOtherType } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n        export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n          bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n          __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n        };\n      `);\n\n    expect(result.content)\n      .toBeSimilarStringTo(`export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n      name: 'MyScalar';\n        }\n      `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n    await resolversTestingValidate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with external mappers using same imported type",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1156,
                "column": 89
            },
            "line": 1156,
            "code": "  it('Should generate basic type resolvers with external mappers using same imported type', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyType: './my-file#MyCustomOtherType',\n          MyOtherType: './my-file#MyCustomOtherType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomOtherType } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n        export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n          bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n          __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n        };\n      `);\n\n    expect(result.content)\n      .toBeSimilarStringTo(`export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n      name: 'MyScalar';\n        }\n      `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n    await resolversTestingValidate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate the correct resolvers when used with mappers with interfaces",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1239,
                "column": 82
            },
            "line": 1239,
            "code": "  it('Should generate the correct resolvers when used with mappers with interfaces', async () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          Node: 'MyNodeType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n        name: 'MyScalar';\n      }\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n    await resolversTestingValidate(mergeOutputs([result, `type MyNodeType = {};`]));\n\n    spy.mockRestore();\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with defaultMapper set to any",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1322,
                "column": 72
            },
            "line": 1322,
            "code": "  it('Should generate basic type resolvers with defaultMapper set to any', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        defaultMapper: 'any',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n        name: 'MyScalar';\n      }\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n    await resolversTestingValidate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with defaultMapper set to external identifier",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1390,
                "column": 88
            },
            "line": 1390,
            "code": "  it('Should generate basic type resolvers with defaultMapper set to external identifier', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        defaultMapper: './my-file#MyBaseType',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyBaseType } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n        name: 'MyScalar';\n      }\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n    await resolversTestingValidate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should replace using Omit when non-mapped type is pointing to mapped type",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1460,
                "column": 79
            },
            "line": 1460,
            "code": "  it('Should replace using Omit when non-mapped type is pointing to mapped type', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: 'MyOtherTypeCustom',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> } ) | ( MyOtherTypeCustom );\n        MyUnion: ( Omit<MyType, 'otherType' | 'unionChild'> & { otherType?: Maybe<ResolversTypes['MyOtherType']>, unionChild?: Maybe<ResolversTypes['ChildUnion']> } ) | ( MyOtherTypeCustom );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> } ) | ( MyOtherTypeCustom );\n        MyUnion: ( Omit<MyType, 'otherType' | 'unionChild'> & { otherType?: Maybe<ResolversParentTypes['MyOtherType']>, unionChild?: Maybe<ResolversParentTypes['ChildUnion']> } ) | ( MyOtherTypeCustom );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<Omit<MyType, 'otherType' | 'unionChild'> & { otherType?: Maybe<ResolversTypes['MyOtherType']>, unionChild?: Maybe<ResolversTypes['ChildUnion']> }>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<MyOtherTypeCustom>;\n      ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: Omit<MyType, 'otherType' | 'unionChild'> & { otherType?: Maybe<ResolversParentTypes['MyOtherType']>, unionChild?: Maybe<ResolversParentTypes['ChildUnion']> };\n        String: Scalars['String'];\n        Child: Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> };\n        MyOtherType: MyOtherTypeCustom;\n        ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: Scalars['ID'];\n        SomeNode: SomeNode;\n        MyUnion: ResolversUnionParentTypes['MyUnion'];\n        MyScalar: Scalars['MyScalar'];\n        Int: Scalars['Int'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n    await resolversTestingValidate(mergeOutputs([result, 'type MyOtherTypeCustom = {};']));\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should not replace using Omit when non-mapped type is pointing to mapped type",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1523,
                "column": 83
            },
            "line": 1523,
            "code": "  it('Should not replace using Omit when non-mapped type is pointing to mapped type', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: 'MyOtherTypeCustom',\n          MyType: 'MyTypeCustom',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> } ) | ( MyOtherTypeCustom );\n        MyUnion: ( MyTypeCustom ) | ( MyOtherTypeCustom );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> } ) | ( MyOtherTypeCustom );\n        MyUnion: ( MyTypeCustom ) | ( MyOtherTypeCustom );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<MyTypeCustom>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<MyOtherTypeCustom>;\n      ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: MyTypeCustom;\n        String: Scalars['String'];\n        Child: Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> };\n        MyOtherType: MyOtherTypeCustom;\n        ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: Scalars['ID'];\n        SomeNode: SomeNode;\n        MyUnion: ResolversUnionParentTypes['MyUnion'];\n        MyScalar: Scalars['MyScalar'];\n        Int: Scalars['Int'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n    await resolversTestingValidate(mergeOutputs([result, `type MyTypeCustom = {}; type MyOtherTypeCustom = {};`]));\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support namespaces",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1587,
                "column": 31
            },
            "line": 1587,
            "code": "  it('should support namespaces', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: './my-file#MyNamespace#MyCustomOtherType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyNamespace } from './my-file';`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> } ) | ( MyNamespace.MyCustomOtherType );\n        MyUnion: ( Omit<MyType, 'otherType' | 'unionChild'> & { otherType?: Maybe<ResolversTypes['MyOtherType']>, unionChild?: Maybe<ResolversTypes['ChildUnion']> } ) | ( MyNamespace.MyCustomOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> } ) | ( MyNamespace.MyCustomOtherType );\n        MyUnion: ( Omit<MyType, 'otherType' | 'unionChild'> & { otherType?: Maybe<ResolversParentTypes['MyOtherType']>, unionChild?: Maybe<ResolversParentTypes['ChildUnion']> } ) | ( MyNamespace.MyCustomOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<Omit<MyType, 'otherType' | 'unionChild'> & { otherType?: Maybe<ResolversTypes['MyOtherType']>, unionChild?: Maybe<ResolversTypes['ChildUnion']> }>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n        MyOtherType: ResolverTypeWrapper<MyNamespace.MyCustomOtherType>;\n        ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n        Query: ResolverTypeWrapper<{}>;\n        Subscription: ResolverTypeWrapper<{}>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        SomeNode: ResolverTypeWrapper<SomeNode>;\n        MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n        MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n        Int: ResolverTypeWrapper<Scalars['Int']>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversParentTypes = {\n      MyType: Omit<MyType, 'otherType' | 'unionChild'> & { otherType?: Maybe<ResolversParentTypes['MyOtherType']>, unionChild?: Maybe<ResolversParentTypes['ChildUnion']> };\n      String: Scalars['String'];\n      Child: Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> };\n      MyOtherType: MyNamespace.MyCustomOtherType;\n      ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n      Query: {};\n      Subscription: {};\n      Node: ResolversParentTypes['SomeNode'];\n      ID: Scalars['ID'];\n      SomeNode: SomeNode;\n      MyUnion: ResolversUnionParentTypes['MyUnion'];\n      MyScalar: Scalars['MyScalar'];\n      Int: Scalars['Int'];\n      Boolean: Scalars['Boolean'];\n    };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support namespaces in contextType",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1652,
                "column": 46
            },
            "line": 1652,
            "code": "  it('should support namespaces in contextType', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        contextType: './my-file#MyNamespace#MyContextType',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyNamespace } from './my-file';`);\n\n    expect(result.content).toContain(`<ContextType = MyNamespace.MyContextType>`);\n    expect(result.content).not.toContain(`<ContextType = MyNamespace>`);\n    expect(result.content).not.toContain(`<ContextType = MyContextType>`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support namespaces in defaultMapper",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1670,
                "column": 48
            },
            "line": 1670,
            "code": "  it('should support namespaces in defaultMapper', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        defaultMapper: './my-file#MyNamespace#MyDefaultMapper',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyNamespace } from './my-file';`);\n    expect(result.content).not.toBeSimilarStringTo(`export type ResolversUnionTypes`);\n    expect(result.content).not.toBeSimilarStringTo(`export type ResolversParentUnionTypes`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        String: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        Child: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        MyOtherType: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        ChildUnion: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        Query: ResolverTypeWrapper<{}>;\n        Subscription: ResolverTypeWrapper<{}>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        SomeNode: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        MyUnion: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        MyScalar: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        Int: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        Boolean: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: MyNamespace.MyDefaultMapper;\n        String: MyNamespace.MyDefaultMapper;\n        Child: MyNamespace.MyDefaultMapper;\n        MyOtherType: MyNamespace.MyDefaultMapper;\n        ChildUnion: MyNamespace.MyDefaultMapper;\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: MyNamespace.MyDefaultMapper;\n        SomeNode: MyNamespace.MyDefaultMapper;\n        MyUnion: MyNamespace.MyDefaultMapper;\n        MyScalar: MyNamespace.MyDefaultMapper;\n        Int: MyNamespace.MyDefaultMapper;\n        Boolean: MyNamespace.MyDefaultMapper;\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support namespaces in rootValueType",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1722,
                "column": 48
            },
            "line": 1722,
            "code": "  it('should support namespaces in rootValueType', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        rootValueType: './my-file#MyNamespace#MyRootType',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyNamespace } from './my-file';`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( Child ) | ( MyOtherType );\n        MyUnion: ( Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> } ) | ( MyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( Child ) | ( MyOtherType );\n        MyUnion: ( Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> } ) | ( MyOtherType );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Child: ResolverTypeWrapper<Child>;\n        MyOtherType: ResolverTypeWrapper<MyOtherType>;\n        ChildUnion: ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>;\n        Query: ResolverTypeWrapper<MyNamespace.MyRootType>;\n        Subscription: ResolverTypeWrapper<MyNamespace.MyRootType>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        SomeNode: ResolverTypeWrapper<SomeNode>;\n        MyUnion: ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>;\n        MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n        Int: ResolverTypeWrapper<Scalars['Int']>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversParentTypes = {\n      MyType: Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> };\n      String: Scalars['String'];\n      Child: Child;\n      MyOtherType: MyOtherType;\n      ChildUnion: ResolversUnionParentTypes['ChildUnion'];\n      Query: MyNamespace.MyRootType;\n      Subscription: MyNamespace.MyRootType;\n      Node: ResolversParentTypes['SomeNode'];\n      ID: Scalars['ID'];\n      SomeNode: SomeNode;\n      MyUnion: ResolversUnionParentTypes['MyUnion'];\n      MyScalar: Scalars['MyScalar'];\n      Int: Scalars['Int'];\n      Boolean: Scalars['Boolean'];\n    };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support namespaces and {T} placeholder",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1785,
                "column": 51
            },
            "line": 1785,
            "code": "  it('should support namespaces and {T} placeholder', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        defaultMapper: './my-file#MyNamespace#MyDefaultMapper<{T}>',\n        mappers: {\n          MyType: './my-file#MyNamespace#MyType<{T}>',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyNamespace } from './my-file';`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        ChildUnion: ( MyNamespace.MyDefaultMapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }> ) | ( MyNamespace.MyDefaultMapper<MyOtherType> );\n        MyUnion: ( MyNamespace.MyType<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }> ) | ( MyNamespace.MyDefaultMapper<MyOtherType> );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        ChildUnion: ( MyNamespace.MyDefaultMapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> }> ) | ( MyNamespace.MyDefaultMapper<MyOtherType> );\n        MyUnion: ( MyNamespace.MyType<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> }> ) | ( MyNamespace.MyDefaultMapper<MyOtherType> );\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<MyNamespace.MyType<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>>;\n        String: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Scalars['String']>>;\n        Child: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>>;\n        MyOtherType: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<MyOtherType>>;\n        ChildUnion: MyNamespace.MyDefaultMapper<ResolverTypeWrapper<ResolversUnionTypes['ChildUnion']>>;\n        Query: ResolverTypeWrapper<{}>;\n        Subscription: ResolverTypeWrapper<{}>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Scalars['ID']>>;\n        SomeNode: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<SomeNode>>;\n        MyUnion: MyNamespace.MyDefaultMapper<ResolverTypeWrapper<ResolversUnionTypes['MyUnion']>>;\n        MyScalar: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Scalars['MyScalar']>>;\n        Int: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Scalars['Int']>>;\n        Boolean: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Scalars['Boolean']>>;\n      };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversParentTypes = {\n      MyType: MyNamespace.MyType<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> }>;\n      String: MyNamespace.MyDefaultMapper<Scalars['String']>;\n      Child: MyNamespace.MyDefaultMapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> }>;\n      MyOtherType: MyNamespace.MyDefaultMapper<MyOtherType>;\n      ChildUnion: MyNamespace.MyDefaultMapper<ResolversUnionParentTypes['ChildUnion']>;\n      Query: {};\n      Subscription: {};\n      Node: ResolversParentTypes['SomeNode'];\n      ID: MyNamespace.MyDefaultMapper<Scalars['ID']>;\n      SomeNode: MyNamespace.MyDefaultMapper<SomeNode>;\n      MyUnion: MyNamespace.MyDefaultMapper<ResolversUnionParentTypes['MyUnion']>;\n      MyScalar: MyNamespace.MyDefaultMapper<Scalars['MyScalar']>;\n      Int: MyNamespace.MyDefaultMapper<Scalars['Int']>;\n      Boolean: MyNamespace.MyDefaultMapper<Scalars['Boolean']>;\n    };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should produce IResolvers compatible with graphql-tools",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Backward Compatability"
            ],
            "updatePoint": {
                "line": 10,
                "column": 63
            },
            "line": 10,
            "code": "    it('should produce IResolvers compatible with graphql-tools', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          users: [User!]!\n        }\n\n        type User {\n          id: ID!\n          name: String!\n        }\n      `);\n\n      const tsContent = await tsPlugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n      const resolversContent = (await plugin(\n        testSchema,\n        [],\n        {\n          contextType: 'Context',\n          useIndexSignature: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n      const content = mergeOutputs([\n        tsContent,\n        resolversContent,\n        `\n          import { makeExecutableSchema } from '@graphql-tools/schema';\n\n          interface Context {\n            users: Array<{\n              id: string;\n              name: string;\n            }>;\n          }\n\n          const resolvers: IResolvers = {\n            Query: {\n              users(parent, args, ctx, info) {\n                return ctx.users;\n              }\n            }\n          }\n\n          makeExecutableSchema({\n            typeDefs: '',\n            resolvers\n          })\n        `,\n      ]);\n\n      expect(content).toBeSimilarStringTo(`\n        export type Resolvers<ContextType = Context> = ResolversObject<{\n          Query?: QueryResolvers<ContextType>;\n          User?: UserResolvers<ContextType>;\n        }>;\n      `);\n\n      validateTs(content);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should use StitchingResolver when its active on config",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Backward Compatability"
            ],
            "updatePoint": {
                "line": 73,
                "column": 60
            },
            "line": 73,
            "code": "  it('Should use StitchingResolver when its active on config', async () => {\n    const result = await plugin(resolversTestingSchema, [], { noSchemaStitching: false }, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`export type StitchingResolver<TResult, TParent, TContext, TArgs>`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n        | ResolverFn<TResult, TParent, TContext, TArgs>\n        | ResolverWithResolve<TResult, TParent, TContext, TArgs>\n        | StitchingResolver<TResult, TParent, TContext, TArgs>;\n    `);\n\n    await resolversTestingValidate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "onlyResolveTypeForInterfaces - should allow to have only resolveType for interfaces",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 88,
                "column": 91
            },
            "line": 88,
            "code": "    it('onlyResolveTypeForInterfaces - should allow to have only resolveType for interfaces', async () => {\n      const config = {\n        onlyResolveTypeForInterfaces: true,\n      };\n      const result = await plugin(resolversTestingSchema, [], config, { outputFile: '' });\n      const content = await resolversTestingValidate(result, config, resolversTestingSchema);\n\n      expect(content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n      };`);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "optionalInfoArgument - should allow to have optional info argument",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 101,
                "column": 74
            },
            "line": 101,
            "code": "    it('optionalInfoArgument - should allow to have optional info argument', async () => {\n      const config = {\n        noSchemaStitching: true,\n        useIndexSignature: true,\n        optionalInfoArgument: true,\n      };\n      const result = await plugin(resolversTestingSchema, [], config, { outputFile: '' });\n\n      const content = await resolversTestingValidate(result, config, resolversTestingSchema);\n\n      expect(content).not.toContain(`info: `);\n      expect(content).toContain(`info?: `);\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "allowParentTypeOverride - should allow to have less strict resolvers by overrding parent type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 116,
                "column": 101
            },
            "line": 116,
            "code": "    it('allowParentTypeOverride - should allow to have less strict resolvers by overrding parent type', async () => {\n      const config = {\n        noSchemaStitching: true,\n        useIndexSignature: true,\n        allowParentTypeOverride: true,\n      };\n      const result = await plugin(resolversTestingSchema, [], config, { outputFile: '' });\n\n      const content = await resolversTestingValidate(\n        result,\n        config,\n        resolversTestingSchema,\n        `\n        export const myTypeResolvers: MyTypeResolvers<{}, { parentOverride: boolean }> = {\n          foo: (parentValue) => {\n            const a: boolean = parentValue.parentOverride;\n\n            return a.toString();\n          }\n        };\n      `\n      );\n\n      expect(content).not.toContain(`ParentType extends `);\n      expect(content).toContain(`ParentType = `);\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "namespacedImportName - should work correctly with imported namespaced type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 144,
                "column": 82
            },
            "line": 144,
            "code": "    it('namespacedImportName - should work correctly with imported namespaced type', async () => {\n      const config = {\n        noSchemaStitching: true,\n        useIndexSignature: true,\n        namespacedImportName: 'Types',\n      };\n      const result = await plugin(resolversTestingSchema, [], config, { outputFile: '' });\n      const content = mergeOutputs([result]);\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "directiveResolverMappings - should generate correct types (inline definition)",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 155,
                "column": 85
            },
            "line": 155,
            "code": "    it('directiveResolverMappings - should generate correct types (inline definition)', async () => {\n      const config = {\n        noSchemaStitching: true,\n        directiveResolverMappings: {\n          authenticated: `\n(\n  parent: TParent,\n  args: TArgs,\n  context: AuthenticatedContext,\n  info: GraphQLResolveInfo\n) => Promise<TResult> | TResult;`,\n        },\n      };\n      const result = await plugin(resolversTestingSchema, [], config, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\nexport type ResolverFnAuthenticated<TResult, TParent, TContext, TArgs> =\n(\n  parent: TParent,\n  args: TArgs,\n  context: AuthenticatedContext,\n  info: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\n\nexport type ResolverAuthenticatedWithResolve<TResult, TParent, TContext, TArgs> = {\n  resolve: ResolverFnAuthenticated<TResult, TParent, TContext, TArgs>;\n};\nexport type ResolverAuthenticated<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFnAuthenticated<TResult, TParent, TContext, TArgs> | ResolverAuthenticatedWithResolve<TResult, TParent, TContext, TArgs>;\n`);\n      expect(result.content).toBeSimilarStringTo(`\nexport type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n  foo?: ResolverAuthenticated<ResolversTypes['String'], ParentType, ContextType>;\n  otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n  withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n  unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\n      `);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "makeResolverTypeCallable - should remove ResolverWithResolve type from resolver union",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 194,
                "column": 93
            },
            "line": 194,
            "code": "    it('makeResolverTypeCallable - should remove ResolverWithResolve type from resolver union', async () => {\n      const result = await plugin(resolversTestingSchema, [], { makeResolverTypeCallable: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n      ResolverFn<TResult, TParent, TContext, TArgs>;\n    `);\n\n      expect(result.content).not.toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n      ResolverFn<TResult, TParent, TContext, TArgs>\n      | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\n    `);\n\n      await resolversTestingValidate(result);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "makeResolverTypeCallable - adds ResolverWithResolve type to resolver union when set to false",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 211,
                "column": 100
            },
            "line": 211,
            "code": "    it('makeResolverTypeCallable - adds ResolverWithResolve type to resolver union when set to false', async () => {\n      const result = await plugin(resolversTestingSchema, [], { makeResolverTypeCallable: false }, { outputFile: '' });\n\n      expect(result.content).not.toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n      ResolverFn<TResult, TParent, TContext, TArgs>;\n    `);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n      ResolverFn<TResult, TParent, TContext, TArgs>\n      | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\n    `);\n\n      await resolversTestingValidate(result);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "resolversNonOptionalTypename - adds non-optional typenames to implemented types",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 228,
                "column": 87
            },
            "line": 228,
            "code": "    it('resolversNonOptionalTypename - adds non-optional typenames to implemented types', async () => {\n      const result = await plugin(\n        resolversTestingSchema,\n        [],\n        { resolversNonOptionalTypename: true },\n        { outputFile: '' }\n      );\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ResolversUnionTypes = {\n          ChildUnion: ( Child & { __typename: \"Child\" } ) | ( MyOtherType & { __typename: \"MyOtherType\" } );\n          MyUnion: ( Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> } & { __typename: \"MyType\" } ) | ( MyOtherType & { __typename: \"MyOtherType\" } );\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type ResolversUnionParentTypes = {\n          ChildUnion: ( Child & { __typename: \"Child\" } ) | ( MyOtherType & { __typename: \"MyOtherType\" } );\n          MyUnion: ( Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> } & { __typename: \"MyType\" } ) | ( MyOtherType & { __typename: \"MyOtherType\" } );\n        };\n      `);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "resolversNonOptionalTypename - adds non-optional typenames to ResolversUnionTypes",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 250,
                "column": 89
            },
            "line": 250,
            "code": "    it('resolversNonOptionalTypename - adds non-optional typenames to ResolversUnionTypes', async () => {\n      const result = await plugin(\n        resolversTestingSchema,\n        [],\n        { resolversNonOptionalTypename: { unionMember: true } },\n        { outputFile: '' }\n      );\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ResolversUnionTypes = {\n          ChildUnion: ( Child & { __typename: \"Child\" } ) | ( MyOtherType & { __typename: \"MyOtherType\" } );\n          MyUnion: ( Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> } & { __typename: \"MyType\" } ) | ( MyOtherType & { __typename: \"MyOtherType\" } );\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type ResolversUnionParentTypes = {\n          ChildUnion: ( Child & { __typename: \"Child\" } ) | ( MyOtherType & { __typename: \"MyOtherType\" } );\n          MyUnion: ( Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> } & { __typename: \"MyType\" } ) | ( MyOtherType & { __typename: \"MyOtherType\" } );\n        };\n      `);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "directiveResolverMappings - should generate correct types (import definition)",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 273,
                "column": 83
            },
            "line": 273,
            "code": "  it('directiveResolverMappings - should generate correct types (import definition)', async () => {\n    const config = {\n      noSchemaStitching: true,\n      directiveResolverMappings: {\n        authenticated: `../resolver-types.ts#AuthenticatedResolver`,\n      },\n    };\n    const result = await plugin(resolversTestingSchema, [], config, { outputFile: '' });\n    expect(result.prepend).toContain(\n      \"import { AuthenticatedResolver as ResolverFnAuthenticated } from '../resolver-types.ts';\"\n    );\n    expect(result.prepend).toContain('export { ResolverFnAuthenticated };');\n    expect(result.content).toBeSimilarStringTo(`\nexport type ResolverAuthenticatedWithResolve<TResult, TParent, TContext, TArgs> = {\n  resolve: ResolverFnAuthenticated<TResult, TParent, TContext, TArgs>;\n};\nexport type ResolverAuthenticated<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFnAuthenticated<TResult, TParent, TContext, TArgs> | ResolverAuthenticatedWithResolve<TResult, TParent, TContext, TArgs>;\n`);\n    expect(result.content).toBeSimilarStringTo(`\nexport type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\nfoo?: ResolverAuthenticated<ResolversTypes['String'], ParentType, ContextType>;\notherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\nwithArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\nunionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should not generate enum internal values resolvers when enum doesnt have enumValues set",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 303,
                "column": 95
            },
            "line": 303,
            "code": "    it('Should not generate enum internal values resolvers when enum doesnt have enumValues set', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        noSchemaStitching: true,\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n      const mergedOutput = await resolversTestingValidate(\n        result,\n        config,\n        testSchema,\n        `\n        export const resolvers: Resolvers = {\n          Query: {\n            v: () => 'A',\n          }\n        };\n      `\n      );\n\n      expect(mergedOutput).not.toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(mergedOutput).not.toContain('EnumResolverSignature');\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has enumValues set as object with explicit values",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 336,
                "column": 114
            },
            "line": 336,
            "code": "    it('Should generate enum internal values resolvers when enum has enumValues set as object with explicit values', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        noSchemaStitching: true,\n        enumValues: {\n          MyEnum: {\n            A: 'val_1',\n            B: 'val_2',\n            C: 'val_3',\n          },\n        },\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      const mergedOutput = await resolversTestingValidate(\n        result,\n        config,\n        testSchema,\n        `\n        export const resolvers: Resolvers = {\n          MyEnum: {\n            A: 'val_1',\n            B: 'val_2',\n            C: 'val_3',\n          },\n          Query: {\n            v: () => 'val_1',\n          }\n        };\n      `\n      );\n\n      expect(mergedOutput).not.toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(mergedOutput).not.toContain('EnumResolverSignature');\n      expect(mergedOutput).toContain(`export type MyEnumResolvers = { A: 'val_1', B: 'val_2', C: 'val_3' };`);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has enumValues set as external enum",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 383,
                "column": 100
            },
            "line": 383,
            "code": "    it('Should generate enum internal values resolvers when enum has enumValues set as external enum', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        noSchemaStitching: true,\n        enumValues: {\n          MyEnum: 'MyCustomEnum',\n        },\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      const mergedOutput = await resolversTestingValidate(\n        result,\n        config,\n        testSchema,\n        `\n        enum MyCustomEnum {\n          CUSTOM_A,\n          CUSTOM_B,\n          CUSTOM_C\n        }\n\n        export const resolvers: Resolvers = {\n          MyEnum: {\n            A: MyCustomEnum.CUSTOM_A,\n            B: MyCustomEnum.CUSTOM_B,\n            C: MyCustomEnum.CUSTOM_C,\n          },\n          Query: {\n            v: () => MyCustomEnum.CUSTOM_A,\n          }\n        };\n      `\n      );\n\n      expect(mergedOutput).toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(mergedOutput).toContain('EnumResolverSignature');\n      expect(mergedOutput).toContain(\n        `export type MyEnumResolvers = EnumResolverSignature<{ A?: any, B?: any, C?: any }, ResolversTypes['MyEnum']>;`\n      );\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has mappers pointing to external enum",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 434,
                "column": 102
            },
            "line": 434,
            "code": "    it('Should generate enum internal values resolvers when enum has mappers pointing to external enum', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        noSchemaStitching: true,\n        mappers: {\n          MyEnum: 'MyCustomEnum',\n        },\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      const mergedOutput = await resolversTestingValidate(\n        result,\n        config,\n        testSchema,\n        `\n        enum MyCustomEnum {\n          CUSTOM_A,\n          CUSTOM_B,\n          CUSTOM_C\n        }\n\n        export const resolvers: Resolvers = {\n          MyEnum: {\n            A: MyCustomEnum.CUSTOM_A,\n            B: MyCustomEnum.CUSTOM_B,\n            C: MyCustomEnum.CUSTOM_C,\n          },\n          Query: {\n            v: () => MyCustomEnum.CUSTOM_A,\n          }\n        };\n      `\n      );\n\n      expect(mergedOutput).toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(mergedOutput).toContain('EnumResolverSignature');\n      expect(mergedOutput).toContain(\n        `export type MyEnumResolvers = EnumResolverSignature<{ A?: any, B?: any, C?: any }, ResolversTypes['MyEnum']>;`\n      );\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has enumValues set on a global level of all enums",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 485,
                "column": 114
            },
            "line": 485,
            "code": "    it('Should generate enum internal values resolvers when enum has enumValues set on a global level of all enums', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        noSchemaStitching: true,\n        enumValues: './enums',\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      const mergedOutput = await resolversTestingValidate(\n        result,\n        config,\n        testSchema,\n        `\n        enum MyCustomEnum {\n          CUSTOM_A,\n          CUSTOM_B,\n          CUSTOM_C\n        }\n\n        export const resolvers: Resolvers = {\n          MyEnum: {\n            A: MyCustomEnum.CUSTOM_A,\n            B: MyCustomEnum.CUSTOM_B,\n            C: MyCustomEnum.CUSTOM_C,\n          },\n          Query: {\n            v: () => MyCustomEnum.CUSTOM_A,\n          }\n        };\n      `\n      );\n\n      expect(mergedOutput).toContain(`import { MyEnum } from './enums'`);\n      expect(mergedOutput).toContain(`export { MyEnum }`);\n      expect(mergedOutput).toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(mergedOutput).toContain('EnumResolverSignature');\n      expect(mergedOutput).toContain(\n        `export type MyEnumResolvers = EnumResolverSignature<{ A?: any, B?: any, C?: any }, ResolversTypes['MyEnum']>;`\n      );\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override ResolverTypeWrapper signature",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 537,
                "column": 60
            },
            "line": 537,
            "code": "  it('Should allow to override ResolverTypeWrapper signature', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        resolverTypeWrapperSignature: 'Promise<DeepPartial<T>> | DeepPartial<T>',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toContain(`export type ResolverTypeWrapper<T> = Promise<DeepPartial<T>> | DeepPartial<T>;`);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should have default value for ResolverTypeWrapper signature",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 551,
                "column": 65
            },
            "line": 551,
            "code": "  it('Should have default value for ResolverTypeWrapper signature', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toContain(`export type ResolverTypeWrapper<T> = Promise<T> | T;`);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should not warn when noSchemaStitching is not defined",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 564,
                "column": 59
            },
            "line": 564,
            "code": "  it('Should not warn when noSchemaStitching is not defined', async () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const result = await plugin(resolversTestingSchema, [], {}, { outputFile: '' });\n\n    expect(spy).not.toHaveBeenCalled();\n\n    spy.mockRestore();\n\n    await resolversTestingValidate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should disable StitchingResolver on demand",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 575,
                "column": 48
            },
            "line": 575,
            "code": "  it('Should disable StitchingResolver on demand', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        noSchemaStitching: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).not.toBeSimilarStringTo(`\n      export type StitchingResolver<TResult, TParent, TContext, TArgs> = {\n        fragment: string;\n        resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n      };\n    `);\n    expect(result.content).not.toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n        | ResolverFn<TResult, TParent, TContext, TArgs>\n        | ResolverWithResolve<TResult, TParent, TContext, TArgs>\n        | StitchingResolver<TResult, TParent, TContext, TArgs>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n        ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\n    `);\n\n    await resolversTestingValidate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Default values of args and compatibility with typescript plugin",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 606,
                "column": 69
            },
            "line": 606,
            "code": "  it('Default values of args and compatibility with typescript plugin', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        something(arg: String = \"default_value\"): String\n      }\n    `);\n\n    const config: any = { noSchemaStitching: true };\n    const result = await plugin(testSchema, [], config, { outputFile: '' });\n    const mergedOutputs = mergeOutputs([\n      result,\n      {\n        content: `\n    const resolvers: QueryResolvers = {\n      something: (root, args, context, info) => {\n        return args.arg; // This should work becuase \"args.arg\" is now forced\n      }\n    };`,\n      },\n    ]);\n\n    expect(mergedOutputs).toContain(`export type RequireFields`);\n    expect(mergedOutputs).toContain(\n      `something?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<QuerySomethingArgs, 'arg'>>;`\n    );\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Test for enum usage in resolvers (to verify compatibility with enumValues)",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 633,
                "column": 80
            },
            "line": 633,
            "code": "  it('Test for enum usage in resolvers (to verify compatibility with enumValues)', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        a: A\n      }\n\n      enum A {\n        X\n        Y\n        Z\n      }\n\n      enum NotMapped {\n        X\n        Y\n      }\n\n      type B {\n        a: String\n      }\n    `);\n\n    const config = {\n      enumValues: {\n        A: 'MyA',\n      },\n      typesPrefix: 'GQL_',\n    };\n    const result = await plugin(testSchema, [], config, { outputFile: '' });\n    const tsContent = (await tsPlugin(testSchema, [], config, {\n      outputFile: 'graphql.ts',\n    })) as Types.ComplexPluginOutput;\n    const mergedOutputs = mergeOutputs([result, tsContent]);\n\n    expect(mergedOutputs).not.toContain(`A: A;`);\n    expect(mergedOutputs).not.toContain(`A: GQL_A;`);\n    expect(mergedOutputs).toContain(`NotMapped: GQL_NotMapped;`);\n    expect(mergedOutputs).not.toContain(`NotMapped: NotMapped;`);\n    expect(mergedOutputs).toContain(`B: GQL_B;`);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to generate optional __resolveType",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 674,
                "column": 53
            },
            "line": 674,
            "code": "  it('Should allow to generate optional __resolveType', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      { optionalResolveType: true },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType?: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType?: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 696,
                "column": 42
            },
            "line": 696,
            "code": "  it('Should generate basic type resolvers', async () => {\n    const result = await plugin(resolversTestingSchema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content)\n      .toBeSimilarStringTo(`export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n      name: 'MyScalar';\n    }`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await resolversTestingValidate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with avoidOptionals",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 767,
                "column": 62
            },
            "line": 767,
            "code": "  it('Should generate basic type resolvers with avoidOptionals', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      { avoidOptionals: true },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content)\n      .toBeSimilarStringTo(`export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n      name: 'MyScalar';\n    }`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await resolversTestingValidate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override context with simple identifier",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 842,
                "column": 61
            },
            "line": 842,
            "code": "  it('Should allow to override context with simple identifier', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        contextType: 'MyCustomCtx',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = MyCustomCtx, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await resolversTestingValidate(mergeOutputs([result, `type MyCustomCtx = {};`]));\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should with correctly with addUnderscoreToArgsType set to true",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 915,
                "column": 68
            },
            "line": 915,
            "code": "  it('Should with correctly with addUnderscoreToArgsType set to true', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        addUnderscoreToArgsType: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toContain('MyType_WithArgsArgs');\n    expect(result.content).not.toContain('MyTypeWithArgsArgs');\n\n    await resolversTestingValidate(mergeOutputs([result]));\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override context with mapped context type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 931,
                "column": 63
            },
            "line": 931,
            "code": "  it('Should allow to override context with mapped context type', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        contextType: './my-file#MyCustomCtx',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomCtx } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = MyCustomCtx, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await resolversTestingValidate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override context with mapped context type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1006,
                "column": 63
            },
            "line": 1006,
            "code": "  it('Should allow to override context with mapped context type', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        contextType: './my-file#MyCustomCtx',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomCtx } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = MyCustomCtx, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await resolversTestingValidate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override context with mapped context type as default export",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1080,
                "column": 81
            },
            "line": 1080,
            "code": "  it('Should allow to override context with mapped context type as default export', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        contextType: './my-file#default',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import ContextType from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = ContextType, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await resolversTestingValidate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override context with mapped context type as default export with type import",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1154,
                "column": 98
            },
            "line": 1154,
            "code": "  it('Should allow to override context with mapped context type as default export with type import', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        contextType: './my-file#default',\n        useTypeImports: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import type { default as ContextType } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = ContextType, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await resolversTestingValidate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate named custom field level context type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1230,
                "column": 59
            },
            "line": 1230,
            "code": "  it('should generate named custom field level context type', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        fieldContextTypes: [\n          'MyType.foo#./my-file#ContextTypeOne',\n          'Query.something#./my-file#ContextTypeTwo',\n          'MyType.otherType#SpecialContextType',\n        ],\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { ContextTypeOne, ContextTypeTwo } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextTypeOne>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, SpecialContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextTypeTwo>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate named custom field level context type for field with directive",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1263,
                "column": 84
            },
            "line": 1263,
            "code": "  it('should generate named custom field level context type for field with directive', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        directiveContextTypes: ['authenticated#./my-file#AuthenticatedContext'],\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { AuthenticatedContext } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, AuthenticatedContext<ContextType>>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate named custom field level context type for field with directive and context type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1286,
                "column": 101
            },
            "line": 1286,
            "code": "  it('should generate named custom field level context type for field with directive and context type', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        directiveContextTypes: ['authenticated#./my-file#AuthenticatedContext'],\n        contextType: './my-file#MyCustomCtx',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomCtx, AuthenticatedContext } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, AuthenticatedContext<ContextType>>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate named custom field level context type for field with directive and field context type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1310,
                "column": 107
            },
            "line": 1310,
            "code": "  it('should generate named custom field level context type for field with directive and field context type', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      {\n        directiveContextTypes: ['authenticated#./my-file#AuthenticatedContext'],\n        fieldContextTypes: ['MyType.foo#./my-file#ContextTypeOne'],\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { ContextTypeOne, AuthenticatedContext } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, AuthenticatedContext<ContextTypeOne>>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate the correct imports when schema has scalars",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1334,
                "column": 65
            },
            "line": 1334,
            "code": "  it('Should generate the correct imports when schema has scalars', async () => {\n    const testSchema = buildSchema(`scalar MyScalar`);\n    const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n    expect(result.prepend).toContain(\n      `import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';`\n    );\n    await resolversTestingValidate(result, {}, resolversTestingSchema);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate the correct imports when schema has no scalars",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1344,
                "column": 68
            },
            "line": 1344,
            "code": "  it('Should generate the correct imports when schema has no scalars', async () => {\n    const testSchema = buildSchema(`type MyType { f: String }`);\n    const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n    expect(result.prepend).not.toContain(`import { GraphQLResolveInfo, GraphQLScalarTypeConfig } from 'graphql';`);\n    await resolversTestingValidate(result, {}, testSchema);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate the correct imports when customResolveInfo defined in config",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1352,
                "column": 82
            },
            "line": 1352,
            "code": "  it('Should generate the correct imports when customResolveInfo defined in config', async () => {\n    const testSchema = buildSchema(`scalar MyScalar`);\n    const result = (await plugin(\n      testSchema,\n      [],\n      {\n        customResolveInfo: './my-type#MyGraphQLResolveInfo',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';`);\n    expect(result.prepend).toContain(`import { MyGraphQLResolveInfo as GraphQLResolveInfo } from './my-type';`);\n    await resolversTestingValidate(result, {}, testSchema);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "#8852 - should generate the correct imports when customResolveInfo defined in config with type import",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1368,
                "column": 107
            },
            "line": 1368,
            "code": "  it('#8852 - should generate the correct imports when customResolveInfo defined in config with type import', async () => {\n    const testSchema = buildSchema(`scalar MyScalar`);\n    const result = (await plugin(\n      testSchema,\n      [],\n      {\n        customResolveInfo: './my-type#MyGraphQLResolveInfo',\n        useTypeImports: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import type { GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';`);\n    expect(result.prepend).toContain(`import type { MyGraphQLResolveInfo as GraphQLResolveInfo } from './my-type';`);\n    await resolversTestingValidate(result, {}, testSchema);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "./my-type#MyResolverFn",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1386,
                "column": 30
            },
            "line": 1386,
            "code": "    it('./my-type#MyResolverFn', async () => {\n      const testSchema = buildSchema(`scalar MyScalar`);\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          customResolverFn: './my-type#MyResolverFn',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.prepend).toContain(`import { MyResolverFn as ResolverFn } from './my-type';`);\n      expect(result.prepend).toContain(`export { ResolverFn };`);\n      await resolversTestingValidate(result, {}, testSchema);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "./my-type#ResolverFn",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1402,
                "column": 28
            },
            "line": 1402,
            "code": "    it('./my-type#ResolverFn', async () => {\n      const testSchema = buildSchema(`scalar MyScalar`);\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          customResolverFn: './my-type#ResolverFn',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.prepend).toContain(`import { ResolverFn } from './my-type';`);\n      expect(result.prepend).toContain(`export { ResolverFn };`);\n      await resolversTestingValidate(result, {}, testSchema);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "definition directly",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1418,
                "column": 27
            },
            "line": 1418,
            "code": "    it(`definition directly`, async () => {\n      const testSchema = buildSchema(`scalar MyScalar`);\n      const fnDefinition = `(\n        parent: TParent,\n        args: TArgs,\n        context: TContext,\n        info: GraphQLResolveInfo & { nestedStuff: GraphQLResolveInfo }\n      ) => Promise<TResult> | TResult;\n      `;\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          customResolverFn: fnDefinition,\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.prepend).toContain(`export type ResolverFn<TResult, TParent, TContext, TArgs> = ${fnDefinition}`);\n      await resolversTestingValidate(result, {}, testSchema);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "ok with default",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1440,
                "column": 23
            },
            "line": 1440,
            "code": "    it(`ok with default`, async () => {\n      const testSchema = buildSchema(`scalar MyScalar`);\n      const defaultResolverFn = `\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => Promise<TResult> | TResult;`;\n      const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n      expect(result.content).toContain(defaultResolverFn);\n      await resolversTestingValidate(result, {}, testSchema);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should not convert type names in unions",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1456,
                "column": 45
            },
            "line": 1456,
            "code": "  it('Should not convert type names in unions', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type CCCFoo {\n        foo: String!\n      }\n\n      type CCCBar {\n        bar: String!\n      }\n\n      type Query {\n        something: CCCUnion!\n      }\n\n      union CCCUnion = CCCFoo | CCCBar\n    `);\n\n    const tsContent = await tsPlugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n    const content = await plugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n\n    expect(tsContent.content).toBeSimilarStringTo(`\n      export type CccFoo = {\n        __typename?: 'CCCFoo';\n        foo: Scalars['String'];\n      };\n    `);\n    expect(tsContent.content).toBeSimilarStringTo(`\n      export type CccBar = {\n        __typename?: 'CCCBar';\n        bar: Scalars['String'];\n      };\n    `);\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        CCCUnion: ( CccFoo ) | ( CccBar );\n      };\n    `);\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        CCCUnion: ( CccFoo ) | ( CccBar );\n      };\n    `);\n    expect(content.content).toBeSimilarStringTo(`\n    /** Mapping between all available schema types and the resolvers types */\n    export type ResolversTypes = {\n      CCCFoo: ResolverTypeWrapper<CccFoo>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      CCCBar: ResolverTypeWrapper<CccBar>;\n      Query: ResolverTypeWrapper<{}>;\n      CCCUnion: ResolverTypeWrapper<ResolversUnionTypes['CCCUnion']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };\n    `);\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        CCCFoo: CccFoo;\n        String: Scalars['String'];\n        CCCBar: CccBar;\n        Query: {};\n        CCCUnion: ResolversUnionParentTypes['CCCUnion'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n    expect(content.content).toBeSimilarStringTo(`\n    export type CccUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CCCUnion'] = ResolversParentTypes['CCCUnion']> = {\n      __resolveType: TypeResolveFn<'CCCFoo' | 'CCCBar', ParentType, ContextType>;\n    };\n    `);\n\n    await validateTs(mergeOutputs([tsContent, content]));\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate the correct resolver args type names when typesPrefix is specified",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1529,
                "column": 88
            },
            "line": 1529,
            "code": "  it('Should generate the correct resolver args type names when typesPrefix is specified', async () => {\n    const testSchema = buildSchema(`type MyType { f(a: String): String }`);\n    const config = { typesPrefix: 'T' };\n    const result = await plugin(testSchema, [], config, { outputFile: '' });\n    const o = await resolversTestingValidate(result, config, testSchema);\n\n    expect(o).toContain(\n      `f?: Resolver<Maybe<TResolversTypes['String']>, ParentType, ContextType, Partial<TMyTypeFArgs>>;`\n    );\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should make list of all-optional arguments include undefined types",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1541,
                "column": 72
            },
            "line": 1541,
            "code": "  it('should make list of all-optional arguments include undefined types', async () => {\n    const testSchema = buildSchema(`type MyType { f(a: String, b: Int): String }`);\n    const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(\n      `f?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<MyTypeFArgs>>;`\n    );\n    await resolversTestingValidate(result, {}, testSchema);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should include generic wrapper type only when necessary",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1552,
                "column": 61
            },
            "line": 1552,
            "code": "  it('should include generic wrapper type only when necessary', async () => {\n    const testSchema = buildSchema(`type MyType { f: String }`);\n    const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(\n      `f?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;`\n    );\n    await resolversTestingValidate(result, {}, testSchema);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate Resolvers interface",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1562,
                "column": 41
            },
            "line": 1562,
            "code": "  it('should generate Resolvers interface', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      directive @modify(limit: Int) on FIELD_DEFINITION\n      scalar Date\n      type Query {\n        post: Post\n        entity: PostOrUser\n      }\n      interface Node {\n        id: String\n      }\n      union PostOrUser = Post | User\n      type Post implements Node {\n        author: User\n      }\n      type User implements Node {\n        id: String\n        name: String\n      }\n      schema {\n        query: Query\n      }\n    `);\n\n    const content = (await plugin(\n      testSchema,\n      [],\n      { scalars: { Date: 'Date' } },\n      {\n        outputFile: 'graphql.ts',\n      }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type Resolvers<ContextType = any> = {\n        Date?: GraphQLScalarType;\n        Query?: QueryResolvers<ContextType>;\n        Node?: NodeResolvers<ContextType>;\n        PostOrUser?: PostOrUserResolvers<ContextType>;\n        Post?: PostResolvers<ContextType>;\n        User?: UserResolvers<ContextType>;\n      };\n    `);\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type DirectiveResolvers<ContextType = any> = {\n        modify?: ModifyDirectiveResolver<any, any, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not create DirectiveResolvers if there is no directive defined in the schema",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1613,
                "column": 89
            },
            "line": 1613,
            "code": "  it('should not create DirectiveResolvers if there is no directive defined in the schema', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        foo: String\n      }\n    `);\n\n    const content = (await plugin(\n      testSchema,\n      [],\n      { scalars: { Date: 'Date' } },\n      {\n        outputFile: 'graphql.ts',\n      }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.content).not.toBeSimilarStringTo(`\n      export type DirectiveResolvers<ContextType = any> = {};\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should produce Resolvers compatible with graphql-tools",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1634,
                "column": 60
            },
            "line": 1634,
            "code": "  it('should produce Resolvers compatible with graphql-tools', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        users: [User!]!\n      }\n\n      type User {\n        id: ID!\n        name: String!\n      }\n    `);\n\n    const tsContent = (await tsPlugin(testSchema, [], {}, { outputFile: 'graphql.ts' })) as Types.ComplexPluginOutput;\n    const resolversContent = (await plugin(\n      testSchema,\n      [],\n      {\n        contextType: 'AppContext',\n        useIndexSignature: true,\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    )) as Types.ComplexPluginOutput;\n    const content = mergeOutputs([\n      tsContent,\n      resolversContent,\n      `\n        import { makeExecutableSchema } from '@graphql-tools/schema';\n\n        interface AppContext {\n          users: Array<{\n            id: string;\n            name: string;\n          }>;\n        }\n\n        const resolvers: Resolvers = {\n          Query: {\n            users(parent, args, ctx, info) {\n              return ctx.users;\n            }\n          }\n        }\n\n        makeExecutableSchema({\n          typeDefs: '',\n          resolvers\n        })\n      `,\n    ]);\n\n    validateTs(content);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should produce resolvers compatible with graphql-tools",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1689,
                "column": 60
            },
            "line": 1689,
            "code": "  it('should produce resolvers compatible with graphql-tools', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        users: [User!]!\n      }\n\n      type User {\n        id: ID!\n        name: String!\n      }\n    `);\n\n    const tsContent = await tsPlugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n    const resolversContent = await plugin(\n      testSchema,\n      [],\n      {\n        contextType: 'AppContext',\n        useIndexSignature: true,\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    );\n    const content = mergeOutputs([\n      tsContent,\n      resolversContent,\n      `\n        import { makeExecutableSchema } from '@graphql-tools/schema';\n\n        interface AppContext {\n          users: Array<{\n            id: string;\n            name: string;\n          }>;\n        }\n\n        const query: QueryResolvers = {\n          users(parent, args, ctx, info) {\n            return ctx.users;\n          }\n        }\n\n        makeExecutableSchema({\n          typeDefs: '',\n          resolvers: {\n            Query: query\n          }\n        })\n      `,\n    ]);\n\n    validateTs(content);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should use {} as default of rootValueType",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1744,
                "column": 47
            },
            "line": 1744,
            "code": "  it('should use {} as default of rootValueType', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Subscription {\n        postAdded: Post\n      }\n\n      type Query {\n        posts: [Post]\n      }\n\n      type Mutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n    `);\n    const content = await plugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        Subscription: ResolverTypeWrapper<{}>;\n        Query: ResolverTypeWrapper<{}>;\n        Mutation: ResolverTypeWrapper<{}>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Post: ResolverTypeWrapper<Post>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate ResolversParentTypes",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1777,
                "column": 42
            },
            "line": 1777,
            "code": "  it('should generate ResolversParentTypes', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Subscription {\n        postAdded: Post\n      }\n\n      type Query {\n        posts: [Post]\n      }\n\n      type Mutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n    `);\n    const content = await plugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        Subscription: {};\n        Query: {};\n        Mutation: {};\n        String: Scalars['String'];\n        Post: Post;\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate ResolversUnionTypes",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1810,
                "column": 41
            },
            "line": 1810,
            "code": "  it('should generate ResolversUnionTypes', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        user(id: ID!): UserPayload!\n        posts: PostsPayload!\n      }\n\n      type StandardError {\n        error: String!\n      }\n\n      type User {\n        id: ID!\n        fullName: String!\n      }\n\n      type UserResult {\n        result: User\n      }\n\n      union UserPayload = UserResult | StandardError\n\n      type Post {\n        author: String\n        comment: String\n      }\n\n      type PostsResult {\n        results: [Post!]!\n      }\n\n      union PostsPayload = PostsResult | StandardError\n    `);\n    const content = await plugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversUnionTypes = {\n        UserPayload: ( UserResult ) | ( StandardError );\n        PostsPayload: ( PostsResult ) | ( StandardError );\n      };\n    `);\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversUnionParentTypes = {\n        UserPayload: ( UserResult ) | ( StandardError );\n        PostsPayload: ( PostsResult ) | ( StandardError );\n      };\n    `);\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        Query: ResolverTypeWrapper<{}>;\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        StandardError: ResolverTypeWrapper<StandardError>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        User: ResolverTypeWrapper<User>;\n        UserResult: ResolverTypeWrapper<UserResult>;\n        UserPayload: ResolverTypeWrapper<ResolversUnionTypes['UserPayload']>;\n        Post: ResolverTypeWrapper<Post>;\n        PostsResult: ResolverTypeWrapper<PostsResult>;\n        PostsPayload: ResolverTypeWrapper<ResolversUnionTypes['PostsPayload']>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        Query: {};\n        ID: Scalars['ID'];\n        StandardError: StandardError;\n        String: Scalars['String'];\n        User: User;\n        UserResult: UserResult;\n        UserPayload: ResolversUnionParentTypes['UserPayload'];\n        Post: Post;\n        PostsResult: PostsResult;\n        PostsPayload: ResolversUnionParentTypes['PostsPayload'];\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should NOT generate ResolversUnionTypes if there is no Union",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1892,
                "column": 66
            },
            "line": 1892,
            "code": "  it('should NOT generate ResolversUnionTypes if there is no Union', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        user(id: ID!): User\n      }\n\n      type User {\n        id: ID!\n        fullName: String!\n      }\n    `);\n    const content = await plugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n\n    expect(content.content).not.toBeSimilarStringTo(`export type ResolversUnionTypes`);\n    expect(content.content).not.toBeSimilarStringTo(`export type ResolversUnionParentTypes`);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should use correct value when rootValueType mapped as default",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1909,
                "column": 67
            },
            "line": 1909,
            "code": "  it('should use correct value when rootValueType mapped as default', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Subscription {\n        postAdded: Post\n      }\n\n      type Query {\n        posts: [Post]\n      }\n\n      type Mutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n    `);\n    const content = (await plugin(\n      testSchema,\n      [],\n      {\n        rootValueType: 'my-file#default',\n      },\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        Subscription: ResolverTypeWrapper<RootValueType>;\n        Query: ResolverTypeWrapper<RootValueType>;\n        Mutation: ResolverTypeWrapper<RootValueType>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Post: ResolverTypeWrapper<Post>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n\n    expect(content.prepend).toContain(`import RootValueType from 'my-file';`);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should use correct value when rootValueType mapped as default with type import",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1951,
                "column": 84
            },
            "line": 1951,
            "code": "  it('should use correct value when rootValueType mapped as default with type import', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Subscription {\n        postAdded: Post\n      }\n\n      type Query {\n        posts: [Post]\n      }\n\n      type Mutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n    `);\n    const content = (await plugin(\n      testSchema,\n      [],\n      {\n        rootValueType: 'my-file#default',\n        useTypeImports: true,\n      },\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.prepend).toContain(`import type { default as RootValueType } from 'my-file';`);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should use rootValueType in Query, Mutation and Subscription",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1983,
                "column": 66
            },
            "line": 1983,
            "code": "  it('should use rootValueType in Query, Mutation and Subscription', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type MySubscription {\n        postAdded: Post\n      }\n\n      type MyQuery {\n        posts: [Post]\n      }\n\n      type MyMutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n\n      schema {\n        query: MyQuery\n        mutation: MyMutation\n        subscription: MySubscription\n      }\n    `);\n    const content = (await plugin(\n      testSchema,\n      [],\n      {\n        rootValueType: 'MyRoot',\n      },\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MySubscription: ResolverTypeWrapper<MyRoot>;\n        MyQuery: ResolverTypeWrapper<MyRoot>;\n        MyMutation: ResolverTypeWrapper<MyRoot>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Post: ResolverTypeWrapper<Post>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate subscription types correctly",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 2029,
                "column": 50
            },
            "line": 2029,
            "code": "  it('should generate subscription types correctly', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Subscription {\n        postAdded: Post\n      }\n\n      type Query {\n        posts: [Post]\n      }\n\n      type Mutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n    `);\n    const tsContent = await tsPlugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n    const resolversContent = await plugin(\n      testSchema,\n      [],\n      {\n        rootValueType: '{version: 1}',\n      },\n      { outputFile: 'graphql.ts' }\n    );\n    const content = mergeOutputs([\n      tsContent,\n      resolversContent,\n      `\n        import { PubSub } from 'graphql-subscriptions';\n        const pubsub = new PubSub();\n\n        const POST_ADDED = 'POST_ADDED';\n\n        const resolvers: Resolvers = {\n          Subscription: {\n            postAdded: {\n              subscribe: () => pubsub.asyncIterator([POST_ADDED]),\n            }\n          },\n          Mutation: {\n            addPost: (root, { author, comment }) => {\n              const post = {\n                author,\n                comment,\n              };\n\n              // RootValue should be accessible\n              console.log(root.version);\n\n              // Pass correct data\n              pubsub.publish(POST_ADDED, post);\n\n              // Return correct data\n              return post;\n            }\n          },\n        };\n      `,\n    ]);\n\n    validateTs(content);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate valid types even when there are no implementers for an interface",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 2096,
                "column": 86
            },
            "line": 2096,
            "code": "  it('Should generate valid types even when there are no implementers for an interface', async () => {\n    const schemaWithNoImplementors = buildSchema(/* GraphQL */ `\n      interface Node {\n        id: ID!\n      }\n\n      type Query {\n        node: Node!\n      }\n    `);\n\n    const result = await plugin(schemaWithNoImplementors, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<null, ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should use MaybePromise in ResolverTypeWrapper",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 2116,
                "column": 52
            },
            "line": 2116,
            "code": "  it('should use MaybePromise in ResolverTypeWrapper', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type MySubscription {\n        postAdded: Post\n      }\n\n      type MyQuery {\n        posts: [Post]\n      }\n\n      type MyMutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n\n      schema {\n        query: MyQuery\n        mutation: MyMutation\n        subscription: MySubscription\n      }\n    `);\n    const content = (await plugin(\n      testSchema,\n      [],\n      {\n        rootValueType: 'MyRoot',\n        asyncResolverTypes: true,\n      } as any,\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolverTypeWrapper<T> = Promise<T> | T;\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support all use-cases of subscription resolvers",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "line": 2156,
            "code": "  it.skip('should support all use-cases of subscription resolvers', async () => {",
            "file": "ts-resolvers.spec.ts",
            "skipped": true,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "#4687 - incorrect suffix when used with typesSuffix",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2411,
                "column": 59
            },
            "line": 2411,
            "code": "    it('#4687 - incorrect suffix when used with typesSuffix', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          _id: ID!\n        }\n        type Query {\n          user(_id: ID!): User\n          user2(_id: ID): User\n          me: User\n        }\n      `);\n\n      const config = {\n        typesSuffix: 'QL',\n      };\n      const output = await plugin(testSchema, [], config, { outputFile: 'graphql.ts' });\n      const o = await resolversTestingValidate(output, config, testSchema);\n      expect(o).not.toContain(\n        `user?: Resolver<Maybe<ResolversTypesQL['User']>, ParentType, ContextType, RequireFields<QueryQLuserArgs, '_id'>>;`\n      );\n      expect(o).toContain(\n        `user?: Resolver<Maybe<ResolversTypesQL['User']>, ParentType, ContextType, RequireFields<QueryUserArgsQL, '_id'>>;`\n      );\n      expect(o).toContain(`me?: Resolver<Maybe<ResolversTypesQL['User']>, ParentType, ContextType>;`);\n      expect(o).toContain(\n        `user2?: Resolver<Maybe<ResolversTypesQL['User']>, ParentType, ContextType, Partial<QueryUser2ArgsQL>>;`\n      );\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should work correctly with enumPrefix: false - issue #2679",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2439,
                "column": 66
            },
            "line": 2439,
            "code": "    it('should work correctly with enumPrefix: false - issue #2679', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          t: Test\n        }\n\n        enum Test {\n          A\n          B\n          C\n        }\n      `);\n\n      const config = {\n        typesPrefix: 'I',\n        enumPrefix: false,\n        namingConvention: 'keep',\n        constEnums: true,\n      };\n      const output = await plugin(testSchema, [], config, { outputFile: 'graphql.ts' });\n      const o = await resolversTestingValidate(output, config, testSchema);\n\n      expect(o).toBeSimilarStringTo(`\n      export const enum Test {\n        A = 'A',\n        B = 'B',\n        C = 'C'\n      };`);\n      expect(o).toBeSimilarStringTo(`\n      export type IResolversTypes = {\n        Query: ResolverTypeWrapper<{}>;\n        Test: Test;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n      };`);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should keep non-optional arguments non-optional - issue #2323",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2476,
                "column": 69
            },
            "line": 2476,
            "code": "    it('should keep non-optional arguments non-optional - issue #2323', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum OrderBy {\n          name\n          id\n        }\n\n        input Filter {\n          contain: String\n        }\n\n        type Node {\n          id: ID!\n          name: String!\n        }\n\n        type Connection {\n          nodes: [Node]\n        }\n\n        type Query {\n          list(after: String, orderBy: OrderBy = name, filter: Filter!): Connection!\n        }\n      `);\n\n      const output = (await plugin(\n        testSchema,\n        [],\n        {\n          avoidOptionals: false,\n          maybeValue: 'T | undefined',\n        } as any,\n        { outputFile: 'graphql.ts' }\n      )) as Types.ComplexPluginOutput;\n\n      // filter should be non-optional\n      expect(output.content).toBeSimilarStringTo(`\n        export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n          list?: Resolver<ResolversTypes['Connection'], ParentType, ContextType, RequireFields<QueryListArgs, 'orderBy' | 'filter'>>;\n        };\n      `);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "#3257 - should not import mapper when its already imported because of enumValues",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2519,
                "column": 88
            },
            "line": 2519,
            "code": "    it('#3257 - should not import mapper when its already imported because of enumValues', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          role: [ProjectRoleDetail!]!\n        }\n\n        enum ProjectRole {\n          PROJECT_MANAGER\n          ETC\n        }\n\n        type ProjectRoleDetail {\n          code: ProjectRole!\n          name: String!\n        }\n      `);\n\n      const config = {\n        noSchemaStitching: true,\n        contextType: '@src/context#Context',\n        useIndexSignature: true,\n        avoidOptionals: true,\n        mappers: {\n          ProjectRoleDetail: '../entities#ProjectRole',\n        },\n        enumValues: {\n          ProjectRole: '../entities#ProjectRole',\n        },\n      };\n\n      const tsContent = (await tsPlugin(testSchema, [], config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n      const output = await plugin(testSchema, [], config, { outputFile: 'graphql.ts' });\n\n      expect(output.prepend.filter(t => t.includes('import')).length).toBe(2);\n      expect(output.prepend.filter(t => t.includes('ProjectRole')).length).toBe(0);\n      expect(tsContent.prepend.filter(t => t.includes('ProjectRole')).length).toBe(1);\n      expect(tsContent.prepend.includes(`import { ProjectRole } from '../entities';`)).toBeTruthy();\n      expect(output.prepend.includes(`import { ProjectRole } from '../entities';`)).toBeFalsy();\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "#3264 - enumValues is not being applied to directive resolver",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2565,
                "column": 69
            },
            "line": 2565,
            "code": "    it('#3264 - enumValues is not being applied to directive resolver', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        directive @auth(\n          role: UserRole = ADMIN\n        ) on OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n        enum UserRole {\n          ADMIN\n          USER\n        }\n\n        schema {\n          query: Query\n        }\n\n        type Query {\n          me: User!\n        }\n\n        type User {\n          id: ID!\n          username: String!\n          email: String!\n          role: UserRole!\n        }\n      `);\n\n      const output = (await plugin(\n        testSchema,\n        [],\n        {\n          noSchemaStitching: true,\n          typesPrefix: 'Gql',\n          maybeValue: 'T | undefined',\n          enumValues: {\n            UserRole: '@org/package#UserRole',\n          },\n        } as any,\n        { outputFile: 'graphql.ts' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(output.content).toContain(`export type GqlAuthDirectiveArgs = {\\n  role?: Maybe<UserRole>;\\n};`);\n      expect(output.content).toContain(\n        `export type GqlAuthDirectiveResolver<Result, Parent, ContextType = any, Args = GqlAuthDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`\n      );\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate resolvers with replaced internalResolversPrefix if specified",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2613,
                "column": 82
            },
            "line": 2613,
            "code": "  it('Should generate resolvers with replaced internalResolversPrefix if specified', async () => {\n    const result = (await plugin(\n      resolversTestingSchema,\n      [],\n      { internalResolversPrefix: '' },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).not.toContain('__resolveType');\n    expect(result.content).toContain('resolveType');\n    expect(result.content).not.toContain('__isTypeOf');\n    expect(result.content).toContain('isTypeOf');\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    await resolversTestingValidate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "#7005 - avoidOptionals should preserve optional resolvers",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2642,
                "column": 63
            },
            "line": 2642,
            "code": "  it('#7005 - avoidOptionals should preserve optional resolvers', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        users(filter: UserFilterInput = {}): [User!]!\n        ping: String!\n      }\n\n      input UserFilterInput {\n        status: String = \"ACTIVE\"\n      }\n\n      type User {\n        id: ID!\n      }\n    `);\n\n    const output = (await plugin(\n      testSchema,\n      [],\n      {\n        avoidOptionals: {\n          defaultValue: true,\n          field: true,\n          inputValue: true,\n          object: true,\n          resolvers: false,\n        },\n      } as any,\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(output.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        users?: Resolver<Array<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUsersArgs, 'filter'>>;\n        ping?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should not output imports when there are no operations at all",
            "suites": [
                "TypedDocumentNode"
            ],
            "updatePoint": {
                "line": 6,
                "column": 67
            },
            "line": 6,
            "code": "  it('Should not output imports when there are no operations at all', async () => {\n    const result = (await plugin(null as any, [], {})) as Types.ComplexPluginOutput;\n    expect(result.content).toBe('');\n    expect(result.prepend.length).toBe(0);\n  });",
            "file": "typed-document-node.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typed-document-node/tests"
        },
        {
            "name": "Check is add __typename to typed document",
            "suites": [
                "TypedDocumentNode",
                "addTypenameToSelectionSets"
            ],
            "updatePoint": {
                "line": 13,
                "column": 49
            },
            "line": 13,
            "code": "    it('Check is add __typename to typed document', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          job: Job\n        }\n\n        type Job {\n          id: ID!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query {\n          job {\n            id\n          }\n        }\n      `);\n\n      const res = (await plugin(\n        schema,\n        [{ location: '', document: ast }],\n        { addTypenameToSelectionSets: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect((res.content.match(/__typename/g) || []).length).toBe(1);\n    });",
            "file": "typed-document-node.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typed-document-node/tests"
        },
        {
            "name": "Check with __typename in selection set",
            "suites": [
                "TypedDocumentNode",
                "addTypenameToSelectionSets"
            ],
            "updatePoint": {
                "line": 46,
                "column": 46
            },
            "line": 46,
            "code": "    it('Check with __typename in selection set', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          job: Job\n        }\n\n        type Job {\n          id: ID!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query {\n          job {\n            id\n            __typename\n          }\n        }\n      `);\n\n      const res = (await plugin(\n        schema,\n        [{ location: '', document: ast }],\n        { addTypenameToSelectionSets: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect((res.content.match(/__typename/g) || []).length).toBe(1);\n    });",
            "file": "typed-document-node.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typed-document-node/tests"
        },
        {
            "name": "should expose Maybe",
            "suites": [
                "TypeScript"
            ],
            "updatePoint": {
                "line": 7,
                "column": 25
            },
            "line": 7,
            "code": "  it('should expose Maybe', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      scalar A\n    `);\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n    expect(result.prepend).toBeSimilarStringTo('export type Maybe<T> =');\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should include a description for Scalars type",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 16,
                "column": 53
            },
            "line": 16,
            "code": "    it('Should include a description for Scalars type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"My custom scalar\"\n        scalar A\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** All built-in and custom scalars, mapped to their actual values */\n      export type Scalars = {\n          ID: string;\n          String: string;\n          Boolean: boolean;\n          Int: number;\n          Float: number;\n          /** My custom scalar */\n          A: any;\n        };\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add description for input types",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 37,
                "column": 46
            },
            "line": 37,
            "code": "    it('Should add description for input types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"MyInput\"\n        input MyInput {\n          f: String\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** MyInput */\n        export type MyInput`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add description for input fields",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 51,
                "column": 47
            },
            "line": 51,
            "code": "    it('Should add description for input fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"MyInput\"\n        input MyInput {\n          \"f is something\"\n          f: String!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** MyInput */\n        export type MyInput = {\n          /** f is something */\n          f: Scalars['String'];\n        }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with multiline comment",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 69,
                "column": 42
            },
            "line": 69,
            "code": "    it('Should work with multiline comment', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"\"\"\n        MyInput\n        multiline\n        \"\"\"\n        input MyInput {\n          f: String!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /**\n         * MyInput\n         * multiline\n         */\n        export type MyInput`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with unions",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 89,
                "column": 31
            },
            "line": 89,
            "code": "    it('Should work with unions', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"my union\"\n        union A = B | C\n\n        type B {\n          id: ID\n        }\n        type C {\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** my union */\n        export type A = `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with types",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 108,
                "column": 30
            },
            "line": 108,
            "code": "    it('Should work with types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"this is b\"\n        type B {\n          id: ID\n        }\n        \"this is c\"\n        type C {\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** this is b */\n        export type B = `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** this is c */\n        export type C = `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with type fields",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 130,
                "column": 36
            },
            "line": 130,
            "code": "    it('Should work with type fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type B {\n          \"the id\"\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type B = {\n        __typename?: 'B';\n        /** the id */\n        id?: Maybe<Scalars['ID']>;\n      };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with inteface and inteface fields",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 147,
                "column": 53
            },
            "line": 147,
            "code": "    it('Should work with inteface and inteface fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Node {\n          \"the id\"\n          id: ID!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Node = {\n        /** the id */\n        id: Scalars['ID'];\n      };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum and enum values",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 163,
                "column": 45
            },
            "line": 163,
            "code": "    it('Should work with enum and enum values', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** custom enum */\n      export enum MyEnum {\n        /** this is a */\n        A = 'A',\n        /** this is b */\n        B = 'B'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should removed underscore from enum values",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 185,
                "column": 50
            },
            "line": 185,
            "code": "    it('Should removed underscore from enum values', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A_B_C\n          X_Y_Z\n          _TEST\n          My_Value\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export enum MyEnum {\n        ABC = 'A_B_C',\n        XYZ = 'X_Y_Z',\n        Test = '_TEST',\n        MyValue = 'My_Value'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum as const",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 205,
                "column": 38
            },
            "line": 205,
            "code": "    it('Should work with enum as const', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A_B_C\n          X_Y_Z\n          _TEST\n          My_Value\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsConst: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyEnum = {\n        ABC: 'A_B_C',\n        XYZ: 'X_Y_Z',\n        Test: '_TEST',\n        MyValue: 'My_Value'\n      } as const;\n      export type MyEnum = typeof MyEnum[keyof typeof MyEnum];`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum as const combined with enum values",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 231,
                "column": 64
            },
            "line": 231,
            "code": "    it('Should work with enum as const combined with enum values', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A_B_C\n          X_Y_Z\n          _TEST\n          My_Value\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          enumsAsConst: true,\n          enumValues: {\n            MyEnum: {\n              A_B_C: 0,\n              X_Y_Z: 'Foo',\n              _TEST: 'Bar',\n              My_Value: 1,\n            },\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyEnum = {\n        ABC: 0,\n        XYZ: 'Foo',\n        Test: 'Bar',\n        MyValue: 1\n      } as const;\n      export type MyEnum = typeof MyEnum[keyof typeof MyEnum];`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum and enum values (enumsAsTypes)",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 267,
                "column": 60
            },
            "line": 267,
            "code": "    it('Should work with enum and enum values (enumsAsTypes)', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** custom enum */\n      export type MyEnum =\n        /** this is a */\n        | 'A'\n        /** this is b */\n        | 'B';`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with directives",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 293,
                "column": 35
            },
            "line": 293,
            "code": "    it('Should work with directives', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"My custom directive\"\n        directive @AsNumber on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n      `);\n      const result = await plugin(\n        schema,\n        [],\n        { directiveArgumentAndInputFieldMappings: { AsNumber: 'number' } },\n        { outputFile: '' }\n      );\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** Type overrides using directives */\n      export type DirectiveArgumentAndInputFieldMappings = {\n        /** My custom directive */\n        AsNumber: number;\n      };\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should not include a description for Scalars type",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 316,
                "column": 57
            },
            "line": 316,
            "code": "    it('Should not include a description for Scalars type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"My custom scalar\"\n        scalar A\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n          ID: string;\n          String: string;\n          Boolean: boolean;\n          Int: number;\n          Float: number;\n          A: any;\n        };\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should not add description for input types",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 335,
                "column": 50
            },
            "line": 335,
            "code": "    it('Should not add description for input types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"MyInput\"\n        input MyInput {\n          f: String\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should not add description for input fields",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 348,
                "column": 51
            },
            "line": 348,
            "code": "    it('Should not add description for input fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"MyInput\"\n        input MyInput {\n          \"f is something\"\n          f: String!\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          f: Scalars['String'];\n        }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should remove multiline comment",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 364,
                "column": 39
            },
            "line": 364,
            "code": "    it('Should remove multiline comment', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"\"\"\n        MyInput\n        multiline\n        \"\"\"\n        input MyInput {\n          f: String!\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with unions",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 380,
                "column": 31
            },
            "line": 380,
            "code": "    it('Should work with unions', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"my union\"\n        union A = B | C\n\n        type B {\n          id: ID\n        }\n        type C {\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type A = `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with types",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 398,
                "column": 30
            },
            "line": 398,
            "code": "    it('Should work with types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"this is b\"\n        type B {\n          id: ID\n        }\n        \"this is c\"\n        type C {\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type B = `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type C = `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with type fields",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 418,
                "column": 36
            },
            "line": 418,
            "code": "    it('Should work with type fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type B {\n          \"the id\"\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type B = {\n        __typename?: 'B';\n        id?: Maybe<Scalars['ID']>;\n      };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with inteface and inteface fields",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 434,
                "column": 53
            },
            "line": 434,
            "code": "    it('Should work with inteface and inteface fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Node {\n          \"the id\"\n          id: ID!\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Node = {\n        id: Scalars['ID'];\n      };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum and enum values",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 449,
                "column": 45
            },
            "line": 449,
            "code": "    it('Should work with enum and enum values', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export enum MyEnum {\n        A = 'A',\n        B = 'B'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum and enum values (enumsAsTypes)",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 468,
                "column": 60
            },
            "line": 468,
            "code": "    it('Should work with enum and enum values (enumsAsTypes)', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsTypes: true, disableDescriptions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyEnum =\n        | 'A'\n        | 'B';`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should not work when config is false",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 491,
                "column": 44
            },
            "line": 491,
            "code": "    it('Should not work when config is false', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsTypes: true, disableDescriptions: false },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** custom enum */\n      export type MyEnum =\n        /** this is a */\n        | 'A'\n        /** this is b */\n        | 'B';`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#6815 - Generate different type for Maybe wrapper based on input variables",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 519,
                "column": 82
            },
            "line": 519,
            "code": "    it('#6815 - Generate different type for Maybe wrapper based on input variables', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          test(id: ID): String\n          testWithInput(filter: Filter): String\n        }\n\n        input Filter {\n          a: String\n          b: Int\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          maybeValue: 'T | null',\n          inputMaybeValue: 'T | null | undefined',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      const output = mergeOutputs([result]);\n      expect(output).toContain(`export type InputMaybe<T> = T | null | undefined;`);\n      expect(output).toContain(`export type Maybe<T> = T | null;`);\n      expect(output).toContain(`test?: Maybe<Scalars['String']>;`);\n      expect(output).toContain(`id?: InputMaybe<Scalars['ID']>;`);\n      expect(output).toContain(`filter?: InputMaybe<Filter>;`);\n      expect(output).toContain(`a?: InputMaybe<Scalars['String']>;`);\n      expect(output).toContain(`b?: InputMaybe<Scalars['Int']>;`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#5643 - Incorrect combinations of declartionKinds leads to syntax error",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 552,
                "column": 79
            },
            "line": 552,
            "code": "    it('#5643 - Incorrect combinations of declartionKinds leads to syntax error', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Base {\n          id: ID!\n        }\n\n        type MyType implements Base {\n          id: ID!\n        }\n\n        type Query {\n          t: MyType!\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          declarationKind: {\n            type: 'class',\n            interface: 'interface',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).not.toContain(`export class MyType extends Base {`);\n      expect(output).toContain(`export class MyType implements Base {`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#4564 - numeric enum values set on schema level",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 583,
                "column": 55
            },
            "line": 583,
            "code": "    it('#4564 - numeric enum values set on schema level', async () => {\n      const testSchema = new GraphQLSchema({\n        types: [\n          new GraphQLObjectType({\n            name: 'Query',\n            fields: {\n              test: {\n                type: new GraphQLEnumType({\n                  name: 'MyEnum',\n                  values: {\n                    missing: {\n                      value: 0,\n                    },\n                  },\n                }),\n              },\n            },\n          }),\n        ],\n      });\n\n      const result = (await plugin(testSchema, [], {}, { outputFile: '' })) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).not.toContain(`Missing = 'missing'`);\n      expect(output).toContain(`Missing = 0`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#4564 - numeric enum values set on schema level - complex numeric",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 610,
                "column": 73
            },
            "line": 610,
            "code": "    it('#4564 - numeric enum values set on schema level - complex numeric', async () => {\n      const testSchema = new GraphQLSchema({\n        types: [\n          new GraphQLObjectType({\n            name: 'Query',\n            fields: {\n              test: {\n                type: new GraphQLEnumType({\n                  name: 'MyEnum',\n                  values: {\n                    available: {\n                      value: '01',\n                    },\n                    somethingElse: {\n                      value: '99',\n                    },\n                  },\n                }),\n              },\n            },\n          }),\n        ],\n      });\n\n      const result = (await plugin(testSchema, [], {}, { outputFile: '' })) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).toContain(`Available = '01'`);\n      expect(output).toContain(`SomethingElse = '99'`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#7898 - falsy enum value set on schema with enumsAsTypes set",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 640,
                "column": 68
            },
            "line": 640,
            "code": "    it('#7898 - falsy enum value set on schema with enumsAsTypes set', async () => {\n      const testSchema = new GraphQLSchema({\n        types: [\n          new GraphQLObjectType({\n            name: 'Query',\n            fields: {\n              test: {\n                type: new GraphQLEnumType({\n                  name: 'MyEnum',\n                  values: {\n                    EnumValueName: {\n                      value: 0,\n                    },\n                  },\n                }),\n              },\n            },\n          }),\n        ],\n      });\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        { enumsAsTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).not.toContain('EnumValueName');\n      expect(output).toContain('0');\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#6532 - numeric enum values with namingConvention",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 672,
                "column": 57
            },
            "line": 672,
            "code": "    it('#6532 - numeric enum values with namingConvention', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          test: Test!\n        }\n\n        enum Test {\n          Boop\n          BIP\n          BaP\n          TEST_VALUE\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          numericEnums: true,\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).toBeSimilarStringTo(`export enum Test {\n        Boop = 0,\n        Bip = 1,\n        BaP = 2,\n        TestValue = 3\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#3137 - numeric enum value",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 703,
                "column": 34
            },
            "line": 703,
            "code": "    it('#3137 - numeric enum value', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          test: Test!\n        }\n\n        enum Test {\n          A\n          B\n          C\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          enumValues: {\n            Test: {\n              A: 0,\n              B: 'test',\n              C: '2',\n            },\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).toBeSimilarStringTo(`export enum Test {\n        A = 0,\n        B = 'test',\n        C = '2'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#4157 - Should generate numeric values for enums if numericEnums is set to true",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 738,
                "column": 87
            },
            "line": 738,
            "code": "    it('#4157 - Should generate numeric values for enums if numericEnums is set to true', async () => {\n      const testSchema = buildSchema(/* GraphQl */ `\n        enum Status {\n            Idle\n            Running\n            Error\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          numericEnums: true,\n        },\n        {\n          outputFile: '',\n        }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      validateTs(output);\n\n      expect(output).toBeSimilarStringTo(`\n        export enum Status {\n            Idle = 0,\n            Running = 1,\n            Error = 2\n        }\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#2679 - incorrect prefix for enums",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 769,
                "column": 42
            },
            "line": 769,
            "code": "    it('#2679 - incorrect prefix for enums', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum FilterOption {\n          New\n          Active\n          Closed\n        }\n\n        input UpdateFilterOptionInput {\n          newOption: FilterOption!\n        }\n\n        type Query {\n          exampleQuery(i: UpdateFilterOptionInput, t: FilterOption): String\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          typesPrefix: 'I',\n          enumPrefix: false,\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      validateTs(output);\n\n      expect(output).toBeSimilarStringTo(`\n      export enum FilterOption {\n        New = 'New',\n        Active = 'Active',\n        Closed = 'Closed'\n      }`);\n\n      expect(output).toBeSimilarStringTo(`\n      export type IUpdateFilterOptionInput = {\n        newOption: FilterOption;\n      };`);\n      expect(output).toBeSimilarStringTo(`\n      export type IQueryExampleQueryArgs = {\n        i?: InputMaybe<IUpdateFilterOptionInput>;\n        t?: InputMaybe<FilterOption>;\n      };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#3180 - enumValues and named default import",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 816,
                "column": 51
            },
            "line": 816,
            "code": "    it('#3180 - enumValues and named default import', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A\n          B\n          C\n        }\n\n        type Test {\n          t: MyEnum\n          test(a: MyEnum): String\n        }\n      `);\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          typesPrefix: 'I',\n          namingConvention: { enumValues: 'change-case-all#constantCase' },\n          enumValues: {\n            MyEnum: './files#default as MyEnum',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.prepend[0]).toBe(`import MyEnum from './files';`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#4834 - enum members should be quoted if numeric",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 845,
                "column": 56
            },
            "line": 845,
            "code": "    it('#4834 - enum members should be quoted if numeric', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum MediaItemSizeEnum {\n          AXB\n          _1X2\n          _3X4\n        }\n      `);\n\n      const result = (await plugin(testSchema, [], {})) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`export enum MediaItemSizeEnum {\n        Axb = 'AXB',\n        '1X2' = '_1X2',\n        '3X4' = '_3X4'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#2976 - Issues with mapped enumValues and type prefix in args",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 863,
                "column": 69
            },
            "line": 863,
            "code": "    it('#2976 - Issues with mapped enumValues and type prefix in args', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A\n          B\n          C\n        }\n\n        type Test {\n          t: MyEnum\n          test(a: MyEnum): String\n        }\n      `);\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          typesPrefix: 'I',\n          namingConvention: { enumValues: 'change-case-all#constantCase' },\n          enumValues: {\n            MyEnum: './files#MyEnum',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`export type ITest = {\n        __typename?: 'Test';\n       t?: Maybe<MyEnum>;\n       test?: Maybe<Scalars['String']>;\n     };`);\n\n      expect(result.content).toBeSimilarStringTo(`export type ITestTestArgs = {\n      a?: InputMaybe<MyEnum>;\n    };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#2082 - Issues with enumValues and types prefix",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 900,
                "column": 55
            },
            "line": 900,
            "code": "    it('#2082 - Issues with enumValues and types prefix', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A\n          B\n          C\n        }\n\n        enum OtherEnum {\n          V\n        }\n\n        type Test {\n          a: MyEnum\n          b: OtherEnum\n        }\n      `);\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          typesPrefix: 'GQL_',\n          enumValues: {\n            MyEnum: './files#MyEnum',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.prepend).toContain(`import { MyEnum } from './files';`);\n      expect(result.content).toContain(`enum GQL_OtherEnum {`);\n      expect(result.content).toContain(`a?: Maybe<MyEnum>;`);\n      expect(result.content).toContain(`b?: Maybe<GQL_OtherEnum>`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#1488 - Should generate readonly also in input types when immutableTypes is set",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 934,
                "column": 87
            },
            "line": 934,
            "code": "    it('#1488 - Should generate readonly also in input types when immutableTypes is set', async () => {\n      const schema = buildSchema(`\n      input MyInput {\n        f: String!\n      }`);\n\n      const result = (await plugin(\n        schema,\n        [],\n        { immutableTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        readonly f: Scalars['String'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#3141 - @deprecated directive support",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 954,
                "column": 45
            },
            "line": 954,
            "code": "    it('#3141 - @deprecated directive support', async () => {\n      const schema = buildSchema(`\n      type User {\n        fullName: String!\n        firstName: String! @deprecated(reason: \"Field \\`fullName\\` has been superseded by \\`firstName\\`.\")\n      }`);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export type User = {\n        __typename?: 'User';\n        fullName: Scalars['String'];\n        /** @deprecated Field \\`fullName\\` has been superseded by \\`firstName\\`. */\n        firstName: Scalars['String'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#7627 - enum value @deprecated directive support",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 972,
                "column": 56
            },
            "line": 972,
            "code": "    it('#7627 - enum value @deprecated directive support', async () => {\n      const schema = buildSchema(`\n      enum MyEnum {\n        A\n        B @deprecated(reason: \"Enum value \\`B\\` has been deprecated.\")\n      }`);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export enum MyEnum {\n        A = 'A',\n        /** @deprecated Enum value \\`B\\` has been deprecated. */\n        B = 'B'\n      }`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#7766 - input value @deprecated directive support",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 989,
                "column": 57
            },
            "line": 989,
            "code": "    it('#7766 - input value @deprecated directive support', async () => {\n      const schema = buildSchema(`\n      input MyInput {\n        A: Int\n        B: Int @deprecated(reason: \"input value \\`B\\` has been deprecated.\")\n      }`);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        A?: InputMaybe<Scalars['Int']>;\n        /** @deprecated input value \\`B\\` has been deprecated. */\n        B?: InputMaybe<Scalars['Int']>;\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#1462 - Union of scalars and argument of directive",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 1006,
                "column": 58
            },
            "line": 1006,
            "code": "    it('#1462 - Union of scalars and argument of directive', async () => {\n      const schema = buildSchema(`\n      union Any = String | Int | Float | ID\n\n      directive @default(\n        value: Any,\n      ) on ENUM_VALUE | FIELD_DEFINITION\n\n      type CardEdge {\n        count: Int! @default(value: 1)\n      }`);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(\n        `export type Any = Scalars['String'] | Scalars['Int'] | Scalars['Float'] | Scalars['ID'];`\n      );\n      expect(result.content).toBeSimilarStringTo(`\n      export type CardEdge = {\n        __typename?: 'CardEdge';\n        count: Scalars['Int'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#1954 - Duplicate type names for args type",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 1030,
                "column": 50
            },
            "line": 1030,
            "code": "    it('#1954 - Duplicate type names for args type', async () => {\n      const schema = buildSchema(`\n      type PullRequest {\n        reviewThreads(first: Int!): Int\n      }\n\n      type PullRequestReview {\n          threads(first: Int!, last: Int!): Int\n      }`);\n\n      const result = (await plugin(\n        schema,\n        [],\n        { addUnderscoreToArgsType: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toContain('PullRequest_ReviewThreadsArgs');\n      expect(result.content).toContain('PullRequestReview_ThreadsArgs');\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#1980 Do not put prefix on enums in args when enumPrefix: false",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 1050,
                "column": 71
            },
            "line": 1050,
            "code": "    it('#1980 Do not put prefix on enums in args when enumPrefix: false', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum SuggestionType {\n          concern\n          goal\n        }\n\n        type Suggestion {\n          id: ID!\n          userId: ID!\n          suggestionType: SuggestionType!\n          text: String!\n        }\n\n        type RootQueryType {\n          suggestionsForUser(userId: ID!, suggestionType: SuggestionType!): [Suggestion!]\n        }\n      `);\n      const result = (await plugin(schema, [], {\n        skipTypename: true,\n        declarationKind: 'interface',\n        typesPrefix: 'I',\n        enumPrefix: false,\n        constEnums: true,\n        scalars: {\n          DateTime: 'string',\n          Time: 'string',\n          Date: 'string',\n        },\n      })) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n          export interface ISuggestion {\n            id: Scalars['ID'];\n            userId: Scalars['ID'];\n            suggestionType: SuggestionType;\n            text: Scalars['String'];\n          }\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n          export const enum SuggestionType {\n            Concern = 'concern',\n            Goal = 'goal'\n          };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n          export interface IRootQueryType {\n            suggestionsForUser?: Maybe<Array<ISuggestion>>;\n          }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n          export interface IRootQueryTypeSuggestionsForUserArgs {\n            userId: Scalars['ID'];\n            suggestionType: SuggestionType;\n          }\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when specified with avoidOptionals config",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1112,
                "column": 77
            },
            "line": 1112,
            "code": "    it('Should build type correctly when specified with avoidOptionals config', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          foo: String\n          bar: String!\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { avoidOptionals: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          foo: Maybe<Scalars['String']>;\n          bar: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build input type correctly when specified with avoidInputOptionals config",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1136,
                "column": 88
            },
            "line": 1136,
            "code": "    it('Should build input type correctly when specified with avoidInputOptionals config', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          foo: String\n          bar: String!\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { avoidOptionals: { inputValue: true } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          foo: InputMaybe<Scalars['String']>;\n          bar: Scalars['String'];\n        }\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when specified with immutableTypes config",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1160,
                "column": 77
            },
            "line": 1160,
            "code": "    it('Should build type correctly when specified with immutableTypes config', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          foo: [String!]!\n        }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { immutableTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          readonly  __typename?: 'MyType';\n          readonly foo: ReadonlyArray<Scalars['String']>;\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use const enums when constEnums is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1181,
                "column": 53
            },
            "line": 1181,
            "code": "    it('Should use const enums when constEnums is set', async () => {\n      const schema = buildSchema(`\n      enum MyEnum {\n        A\n      }`);\n      const result = await plugin(schema, [], { constEnums: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const enum MyEnum {\n        A = 'A'\n      };\n    `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use enum as type when enumsAsTypes is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1196,
                "column": 56
            },
            "line": 1196,
            "code": "    it('Should use enum as type when enumsAsTypes is set', async () => {\n      const schema = buildSchema(`\n      enum MyEnum {\n        A\n        B\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyEnum =\n          | 'A'\n          | 'B';\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use enum as type when enumsAsTypes is set and also enumValues",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1217,
                "column": 76
            },
            "line": 1217,
            "code": "    it('Should use enum as type when enumsAsTypes is set and also enumValues', async () => {\n      const schema = buildSchema(`\n      enum MyEnum {\n        A\n        B\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: { A: 'BOOP' } }, enumsAsTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyEnum =\n          | 'BOOP'\n          | 'B';\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add `%future added value` to enum when futureProofEnums is set and also enumAsTypes",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1238,
                "column": 98
            },
            "line": 1238,
            "code": "    it('Should add `%future added value` to enum when futureProofEnums is set and also enumAsTypes', async () => {\n      const schema = buildSchema(`\n      enum MyEnum {\n        A\n        B\n      }\n\n      type MyType {\n        required: MyEnum!\n        optional: MyEnum\n      }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsTypes: true, futureProofEnums: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyEnum =\n        | 'A'\n        | 'B'\n        | '%future added value'\n    `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          required: MyEnum;\n          optional?: Maybe<MyEnum>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add `%future added value` to enum usage when futureProofEnums is set, but not enumAsTypes",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1273,
                "column": 104
            },
            "line": 1273,
            "code": "    it('Should add `%future added value` to enum usage when futureProofEnums is set, but not enumAsTypes', async () => {\n      const schema = buildSchema(`\n        enum MyEnum {\n          A\n          B\n        }\n\n        type MyType {\n          required: MyEnum!\n          optional: MyEnum\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { futureProofEnums: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum MyEnum {\n          A = 'A',\n          B = 'B'\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          required: MyEnum | '%future added value';\n          optional?: Maybe<MyEnum | '%future added value'>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add `%future added value` to enum usage when futureProofEnums is set and allowEnumStringTypes is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1309,
                "column": 115
            },
            "line": 1309,
            "code": "    it('Should add `%future added value` to enum usage when futureProofEnums is set and allowEnumStringTypes is set', async () => {\n      const schema = buildSchema(`\n        enum MyEnum {\n          A\n          B\n        }\n\n        type MyType {\n          required: MyEnum!\n          optional: MyEnum\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { futureProofEnums: true, allowEnumStringTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum MyEnum {\n          A = 'A',\n          B = 'B'\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          required: MyEnum | '%future added value' | \\`\\${MyEnum}\\`;\n          optional?: Maybe<MyEnum | '%future added value' | \\`\\${MyEnum}\\`>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use custom namingConvention for enums (keep)",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1345,
                "column": 59
            },
            "line": 1345,
            "code": "    it('Should use custom namingConvention for enums (keep)', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum Foo {\n          YES\n          NO\n        }\n        type MyType {\n          foo(a: String!, b: String, c: [String], d: [Int!]!): Foo\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          namingConvention: {\n            typeNames: 'change-case-all#lowerCase',\n            enumValues: 'keep',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum foo {\n          YES = 'YES',\n          NO = 'NO'\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type mytypefooargs = {\n          a: Scalars['String'];\n          b?: InputMaybe<Scalars['String']>;\n          c?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n          d: Array<Scalars['Int']>;\n        };\n    `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type mytype = {\n          __typename?: 'MyType';\n          foo?: Maybe<foo>;\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use custom namingConvention for enums values as string, without specifying other type converters",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1392,
                "column": 111
            },
            "line": 1392,
            "code": "    it('Should use custom namingConvention for enums values as string, without specifying other type converters', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum Foo {\n          YES\n          NO\n        }\n        type MyType {\n          foo(a: String!, b: String, c: [String], d: [Int!]!): Foo\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          namingConvention: {\n            enumValues: 'change-case-all#lowerCase',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export enum Foo {\n        yes = 'YES',\n        no = 'NO'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use custom namingConvention for enums",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1420,
                "column": 52
            },
            "line": 1420,
            "code": "    it('Should use custom namingConvention for enums', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum Foo {\n          YES\n          NO\n        }\n        type MyType {\n          foo(a: String!, b: String, c: [String], d: [Int!]!): Foo\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          namingConvention: {\n            typeNames: 'keep',\n            enumValues: 'change-case-all#lowerCase',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum Foo {\n          yes = 'YES',\n          no = 'NO'\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypefooArgs = {\n          a: Scalars['String'];\n          b?: InputMaybe<Scalars['String']>;\n          c?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n          d: Array<Scalars['Int']>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          foo?: Maybe<Foo>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should handle introspection types (like __TypeKind)",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1468,
                "column": 59
            },
            "line": 1468,
            "code": "    it('should handle introspection types (like __TypeKind)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Post {\n          title: String\n        }\n        type Query {\n          post: Post!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query Info {\n          __type(name: \"Post\") {\n            name\n            fields {\n              name\n              type {\n                name\n                kind\n              }\n            }\n          }\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** An enum describing what kind of type a given \\`__Type\\` is. */\n      export enum __TypeKind {\n        /** Indicates this type is a scalar. */\n        Scalar = 'SCALAR',\n        /** Indicates this type is an object. \\`fields\\` and \\`interfaces\\` are valid fields. */\n        Object = 'OBJECT',\n        /** Indicates this type is an interface. \\`fields\\`, \\`interfaces\\`, and \\`possibleTypes\\` are valid fields. */\n        Interface = 'INTERFACE',\n        /** Indicates this type is a union. \\`possibleTypes\\` is a valid field. */\n        Union = 'UNION',\n        /** Indicates this type is an enum. \\`enumValues\\` is a valid field. */\n        Enum = 'ENUM',\n        /** Indicates this type is an input object. \\`inputFields\\` is a valid field. */\n        InputObject = 'INPUT_OBJECT',\n        /** Indicates this type is a list. \\`ofType\\` is a valid field. */\n        List = 'LIST',\n        /** Indicates this type is a non-null. \\`ofType\\` is a valid field. */\n        NonNull = 'NON_NULL'\n      }\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use class correctly when declarationKind: class is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1524,
                "column": 69
            },
            "line": 1524,
            "code": "    it('Should use class correctly when declarationKind: class is set', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          id: ID!\n          displayName: String\n        }\n\n        type MyType {\n          id: ID!\n          displayName: String\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: 'class',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export class MyInput {\n          id: Scalars['ID'];\n          displayName?: InputMaybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export class MyType {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use interface for type when declarationKind for types is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1563,
                "column": 75
            },
            "line": 1563,
            "code": "    it('Should use interface for type when declarationKind for types is set', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          id: ID!\n          displayName: String\n        }\n\n        type MyType {\n          id: ID!\n          displayName: String\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: {\n            type: 'interface',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          id: Scalars['ID'];\n          displayName?: InputMaybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyType {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use interface for input when declarationKind for inputs is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1603,
                "column": 77
            },
            "line": 1603,
            "code": "    it('Should use interface for input when declarationKind for inputs is set', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          id: ID!\n          displayName: String\n        }\n\n        type MyType {\n          id: ID!\n          displayName: String\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: {\n            input: 'interface',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInput {\n          id: Scalars['ID'];\n          displayName?: InputMaybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use interface for arguments when declarationKind for arguments is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1643,
                "column": 84
            },
            "line": 1643,
            "code": "    it('Should use interface for arguments when declarationKind for arguments is set', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          id: ID!\n          displayName: String\n          child(id: ID!): MyType\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: {\n            arguments: 'interface',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n          child?: Maybe<MyType>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyTypeChildArgs {\n          id: Scalars['ID'];\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use interface for all objects when declarationKind is interface",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1679,
                "column": 78
            },
            "line": 1679,
            "code": "    it('Should use interface for all objects when declarationKind is interface', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          id: ID!\n          displayName: String\n        }\n\n        type MyType {\n          id: ID!\n          displayName: String\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: 'interface',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInput {\n          id: Scalars['ID'];\n          displayName?: InputMaybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyType {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should correctly render empty interfaces",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1717,
                "column": 48
            },
            "line": 1717,
            "code": "    it('Should correctly render empty interfaces', async () => {\n      const schema = buildSchema(`\n        input MyInput\n\n        type MyType\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: 'interface',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInput {}\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyType {\n          __typename?: 'MyType';\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should extend one interface from another",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1744,
                "column": 48
            },
            "line": 1744,
            "code": "    it('Should extend one interface from another', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          id: ID!\n          displayName: String\n        }\n\n        type MyType implements MyInterface {\n          id: ID!\n          displayName: String\n          value: Int\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: 'interface',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInterface {\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyType extends MyInterface {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n          value?: Maybe<Scalars['Int']>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should extend mutiple interfaces",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1784,
                "column": 40
            },
            "line": 1784,
            "code": "    it('Should extend mutiple interfaces', async () => {\n      const schema = buildSchema(`\n        interface MyInterface1 {\n          id: ID!\n          displayName: String\n        }\n\n        interface MyInterface2 {\n          value: Int\n        }\n\n        type MyType implements MyInterface1 & MyInterface2 {\n          id: ID!\n          displayName: String\n          value: Int\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: 'interface',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInterface1 {\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInterface2 {\n          value?: Maybe<Scalars['Int']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyType extends MyInterface1, MyInterface2 {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n          value?: Maybe<Scalars['Int']>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate a scalars mapping correctly for built-in scalars",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 1836,
                "column": 72
            },
            "line": 1836,
            "code": "    it('Should generate a scalars mapping correctly for built-in scalars', async () => {\n      const schema = buildSchema(`\n      type MyType {\n        foo: String\n        bar: String!\n      }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['String'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate a scalars mapping correctly when using scalars as path",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 1862,
                "column": 78
            },
            "line": 1862,
            "code": "    it('Should generate a scalars mapping correctly when using scalars as path', async () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          scalars: '../../scalars',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.prepend).toContain(`import { MyScalar } from '../../scalars';`);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: String;\n        Boolean: Boolean;\n        Int: number;\n        Float: number;\n        MyScalar: MyScalar;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['MyScalar'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should import a type of a mapped scalar",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 1899,
                "column": 47
            },
            "line": 1899,
            "code": "    it('Should import a type of a mapped scalar', async () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n      scalar MyOtherScalar\n      scalar MyAliasedScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n        baz: MyOtherScalar!\n        qux: MyAliasedScalar!\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          scalars: {\n            MyScalar: '../../scalars#default',\n            MyOtherScalar: '../../scalars#MyOtherScalar',\n            MyAliasedScalar: '../../scalars#MyAliasedScalar as AliasedScalar',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      // It seems like we don't group imports...\n      expect(result.prepend).toContain(`import MyScalar from '../../scalars';`);\n      expect(result.prepend).toContain(`import { MyOtherScalar } from '../../scalars';`);\n      expect(result.prepend).toContain(`import { MyAliasedScalar as AliasedScalar } from '../../scalars';`);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n        MyScalar: MyScalar;\n        MyOtherScalar: MyOtherScalar;\n        MyAliasedScalar: AliasedScalar;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['MyScalar'];\n        baz: Scalars['MyOtherScalar'];\n        qux: Scalars['MyAliasedScalar'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate a scalars mapping correctly for custom scalars",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 1951,
                "column": 70
            },
            "line": 1951,
            "code": "    it('Should generate a scalars mapping correctly for custom scalars', async () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n      }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n        MyScalar: any;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['MyScalar'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate a scalars mapping correctly for custom scalars with mapping",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 1980,
                "column": 83
            },
            "line": 1980,
            "code": "    it('Should generate a scalars mapping correctly for custom scalars with mapping', async () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { scalars: { MyScalar: 'Date' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n        MyScalar: Date;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['MyScalar'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should correctly throw an error when an unknown scalar is detected while using `strictScalars`",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 2014,
                "column": 102
            },
            "line": 2014,
            "code": "    it('Should correctly throw an error when an unknown scalar is detected while using `strictScalars`', () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n      }`);\n\n      expect(() => {\n        plugin(schema, [], { strictScalars: true }, { outputFile: '' });\n      }).toThrow('Unknown scalar type MyScalar');\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should allow overriding default scalar type",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 2028,
                "column": 51
            },
            "line": 2028,
            "code": "    it('Should allow overriding default scalar type', async () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { defaultScalarType: 'unknown' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n        MyScalar: unknown;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['MyScalar'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add FieldWrapper when field definition wrapping is enabled",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 2062,
                "column": 73
            },
            "line": 2062,
            "code": "    it('Should add FieldWrapper when field definition wrapping is enabled', async () => {\n      const schema = buildSchema(`\n      scalar A\n      `);\n\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.prepend).toBeSimilarStringTo('export type FieldWrapper<T> =');\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should allow the FieldWrapper type to be modified",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 2077,
                "column": 57
            },
            "line": 2077,
            "code": "    it('Should allow the FieldWrapper type to be modified', async () => {\n      const schema = buildSchema(`\n      scalar A\n      `);\n\n      const result = (await plugin(\n        schema,\n        [],\n        { fieldWrapperValue: 'T | Promise<T>', wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.prepend).toBeSimilarStringTo('export type FieldWrapper<T> = T | Promise<T>');\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2094,
                "column": 35
            },
            "line": 2094,
            "code": "    it('Should build type correctly', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          foo: String\n          bar: String!\n        }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          foo?: Maybe<Scalars['String']>;\n          bar: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when implementing interface",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2112,
                "column": 63
            },
            "line": 2112,
            "code": "    it('Should build type correctly when implementing interface', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String!\n        }\n\n        type MyType implements MyInterface {\n          foo: String!\n        }\n        `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {\n          foo: Scalars['String'];\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = MyInterface & {\n          __typename?: 'MyType';\n          foo: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when implementing multiple interfaces",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2138,
                "column": 73
            },
            "line": 2138,
            "code": "    it('Should build type correctly when implementing multiple interfaces', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String!\n        }\n\n        interface MyOtherInterface {\n          bar: String!\n        }\n\n        type MyType implements MyInterface & MyOtherInterface {\n          foo: String!\n          bar: String!\n        }\n        `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {\n          foo: Scalars['String'];\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyOtherInterface = {\n          bar: Scalars['String'];\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = MyInterface & MyOtherInterface & {\n          __typename?: 'MyType';\n          foo: Scalars['String'];\n          bar: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when implementing interface without adding fields",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2175,
                "column": 85
            },
            "line": 2175,
            "code": "    it('Should build type correctly when implementing interface without adding fields', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String!\n        }\n\n        type MyType implements MyInterface\n        `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {\n          foo: Scalars['String'];\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = MyInterface & {\n          __typename?: 'MyType';\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly with links between types",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2198,
                "column": 60
            },
            "line": 2198,
            "code": "    it('Should build type correctly with links between types', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          foo: MyOtherType!\n        }\n\n        type MyOtherType {\n          bar: String!\n        }\n        `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          foo: MyOtherType;\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyOtherType = {\n          __typename?: 'MyOtherType';\n          bar: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when wrapping field definitions",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2225,
                "column": 67
            },
            "line": 2225,
            "code": "    it('Should build type correctly when wrapping field definitions', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String!\n        }\n\n        type MyType implements MyInterface {\n          foo: String!\n        }\n        `);\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {\n          foo: FieldWrapper<Scalars['String']>;\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = MyInterface & {\n          __typename?: 'MyType';\n          foo: FieldWrapper<Scalars['String']>;\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build list type correctly when wrapping field definitions",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2256,
                "column": 72
            },
            "line": 2256,
            "code": "    it('Should build list type correctly when wrapping field definitions', async () => {\n      const schema = buildSchema(`\n        type ListOfStrings {\n          foo: [String!]!\n        }\n\n        type ListOfMaybeStrings {\n          foo: [String]!\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfStrings = {\n          __typename?: 'ListOfStrings';\n          foo: Array<FieldWrapper<Scalars['String']>>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfMaybeStrings = {\n          __typename?: 'ListOfMaybeStrings';\n          foo: Array<Maybe<FieldWrapper<Scalars['String']>>>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build list type correctly when wrapping entire field definitions",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2290,
                "column": 79
            },
            "line": 2290,
            "code": "    it('Should build list type correctly when wrapping entire field definitions', async () => {\n      const schema = buildSchema(`\n        type ListOfStrings {\n          foo: [String!]!\n        }\n\n        type ListOfMaybeStrings {\n          foo: [String]!\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapEntireFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfStrings = {\n          __typename?: 'ListOfStrings';\n          foo: EntireFieldWrapper<Array<Scalars['String']>>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfMaybeStrings = {\n          __typename?: 'ListOfMaybeStrings';\n          foo: EntireFieldWrapper<Array<Maybe<Scalars['String']>>>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build list type correctly when wrapping both field definitions and entire field definitions",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2324,
                "column": 106
            },
            "line": 2324,
            "code": "    it('Should build list type correctly when wrapping both field definitions and entire field definitions', async () => {\n      const schema = buildSchema(`\n        type ListOfStrings {\n          foo: [String!]!\n        }\n\n        type ListOfMaybeStrings {\n          foo: [String]!\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapEntireFieldDefinitions: true, wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfStrings = {\n          __typename?: 'ListOfStrings';\n          foo: EntireFieldWrapper<Array<FieldWrapper<Scalars['String']>>>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfMaybeStrings = {\n          __typename?: 'ListOfMaybeStrings';\n          foo: EntireFieldWrapper<Array<Maybe<FieldWrapper<Scalars['String']>>>>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should not wrap input type fields",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2358,
                "column": 41
            },
            "line": 2358,
            "code": "    it('Should not wrap input type fields', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          foo: String!\n        }\n        `);\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          foo: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build union as type correctly",
            "suites": [
                "TypeScript",
                "Union"
            ],
            "updatePoint": {
                "line": 2381,
                "column": 44
            },
            "line": 2381,
            "code": "    it('Should build union as type correctly', async () => {\n      const schema = buildSchema(`\n      type MyType {\n        foo: String!\n      }\n\n      type MyOtherType {\n        bar: String!\n      }\n\n      union MyUnion = MyType | MyOtherType\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyUnion = MyType | MyOtherType;\n    `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add `%other` object typename to union when futureProofUnions is set",
            "suites": [
                "TypeScript",
                "Union"
            ],
            "updatePoint": {
                "line": 2399,
                "column": 82
            },
            "line": 2399,
            "code": "    it('Should add `%other` object typename to union when futureProofUnions is set', async () => {\n      const schema = buildSchema(`\n      type MyType {\n        foo: String!\n      }\n\n      type MyOtherType {\n        bar: String!\n      }\n\n      union MyUnion = MyType | MyOtherType\n      `);\n      const result = await plugin(schema, [], { futureProofUnions: true }, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyUnion = MyType | MyOtherType | { __typename?: \"%other\" };\n    `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add `%other` object typename to union when futureProofUnions and immutableTypes is set",
            "suites": [
                "TypeScript",
                "Union"
            ],
            "updatePoint": {
                "line": 2417,
                "column": 101
            },
            "line": 2417,
            "code": "    it('Should add `%other` object typename to union when futureProofUnions and immutableTypes is set', async () => {\n      const schema = buildSchema(`\n      type MyType {\n        foo: String!\n      }\n\n      type MyOtherType {\n        bar: String!\n      }\n\n      union MyUnion = MyType | MyOtherType\n      `);\n      const result = await plugin(schema, [], { futureProofUnions: true, immutableTypes: true }, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyUnion = MyType | MyOtherType | { readonly __typename?: \"%other\" };\n    `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build interface correctly",
            "suites": [
                "TypeScript",
                "Interface"
            ],
            "updatePoint": {
                "line": 2438,
                "column": 40
            },
            "line": 2438,
            "code": "    it('Should build interface correctly', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String\n          bar: String!\n        }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {\n          foo?: Maybe<Scalars['String']>;\n          bar: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should handle directive declarations correctly",
            "suites": [
                "TypeScript",
                "Directives"
            ],
            "updatePoint": {
                "line": 2457,
                "column": 54
            },
            "line": 2457,
            "code": "    it('Should handle directive declarations correctly', async () => {\n      const schema = buildSchema(`\n        directive @simple on FIELD_DEFINITION\n        directive @withArgument(arg: Int!) on FIELD_DEFINITION\n        directive @objSimple on OBJECT\n        directive @universal on OBJECT | FIELD_DEFINITION | ENUM_VALUE\n      `);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).not.toContain('simple');\n      expect(result.content).not.toContain('withArguments');\n      expect(result.content).not.toContain('objSimple');\n      expect(result.content).not.toContain('universal');\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should handle type override",
            "suites": [
                "TypeScript",
                "Directives"
            ],
            "updatePoint": {
                "line": 2474,
                "column": 35
            },
            "line": 2474,
            "code": "    it('Should handle type override', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        directive @AsNumber on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n        input MyInput {\n          id: ID! @AsNumber\n        }\n\n        type Query {\n          myField(id: ID! @AsNumber): Boolean\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [],\n        { directiveArgumentAndInputFieldMappings: { AsNumber: 'number' } },\n        { outputFile: '' }\n      );\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type DirectiveArgumentAndInputFieldMappings = {\n        AsNumber: number;\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        id: DirectiveArgumentAndInputFieldMappings['AsNumber'];\n      };\n\n      export type Query = {\n        __typename?: 'Query';\n        myField?: Maybe<Scalars['Boolean']>;\n      };\n\n      export type QueryMyFieldArgs = {\n        id: DirectiveArgumentAndInputFieldMappings['AsNumber'];\n      };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should allow imported types",
            "suites": [
                "TypeScript",
                "Directives"
            ],
            "updatePoint": {
                "line": 2515,
                "column": 35
            },
            "line": 2515,
            "code": "    it('Should allow imported types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        directive @AsNumber on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n        input MyInput {\n          id: ID! @AsNumber\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [],\n        {\n          directiveArgumentAndInputFieldMappings: { AsNumber: './someModule#MyType' },\n          directiveArgumentAndInputFieldMappingTypeSuffix: 'Model',\n        },\n        { outputFile: '' }\n      );\n\n      expect(result.prepend).toContain(\"import { MyType as MyTypeModel } from './someModule';\");\n      expect(result.content).toBeSimilarStringTo(`\n      export type DirectiveArgumentAndInputFieldMappings = {\n        AsNumber: MyTypeModel;\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        id: DirectiveArgumentAndInputFieldMappings['AsNumber'];\n      };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use last directive override",
            "suites": [
                "TypeScript",
                "Directives"
            ],
            "updatePoint": {
                "line": 2547,
                "column": 42
            },
            "line": 2547,
            "code": "    it('Should use last directive override', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        directive @AsNumber on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n        directive @AsString on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n        input MyInput {\n          id: ID! @AsNumber @AsString\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [],\n        { directiveArgumentAndInputFieldMappings: { AsNumber: 'number', AsString: 'AsString' } },\n        { outputFile: '' }\n      );\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        id: DirectiveArgumentAndInputFieldMappings['AsString'];\n      };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should ignore unmapped directives",
            "suites": [
                "TypeScript",
                "Directives"
            ],
            "updatePoint": {
                "line": 2571,
                "column": 41
            },
            "line": 2571,
            "code": "    it('Should ignore unmapped directives', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        directive @AsNumber on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n        input MyInput {\n          id: ID! @AsNumber\n        }\n      `);\n      const result = await plugin(schema, [], { directiveArgumentAndInputFieldMappings: {} }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        id: Scalars['ID'];\n      };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "correct output for type with single field",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2594,
                "column": 51
            },
            "line": 2594,
            "code": "      it('correct output for type with single field', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input @oneOf {\n            int: Int\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n\n        expect(result.content).toBeSimilarStringTo(`\n          export type Input =\n            { int: Scalars['Int']; };\n        `);\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "correct output for type with multiple fields",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2615,
                "column": 54
            },
            "line": 2615,
            "code": "      it('correct output for type with multiple fields', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input @oneOf {\n            int: Int\n            boolean: Boolean\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n\n        expect(result.content).toBeSimilarStringTo(`\n          export type Input =\n            { int: Scalars['Int']; boolean?: never; }\n            | { int?: never; boolean: Scalars['Boolean']; };\n        `);\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "respects configured declaration kind with single field",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2638,
                "column": 64
            },
            "line": 2638,
            "code": "      it('respects configured declaration kind with single field', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input @oneOf {\n            int: Int\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        const result = await plugin(schema, [], { declarationKind: 'interface' }, { outputFile: '' });\n\n        expect(result.content).toBeSimilarStringTo(`\n          export interface Input {\n            int: Scalars['Int'];\n          }\n        `);\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "forces declaration kind of type with multiple fields",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2660,
                "column": 62
            },
            "line": 2660,
            "code": "      it('forces declaration kind of type with multiple fields', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input @oneOf {\n            int: Int\n            boolean: Boolean\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        const result = await plugin(schema, [], { declarationKind: 'interface' }, { outputFile: '' });\n\n        expect(result.content).toBeSimilarStringTo(`\n          export type Input =\n            { int: Scalars['Int']; boolean?: never; }\n            | { int?: never; boolean: Scalars['Boolean']; };\n        `);\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "raises exception for type with non-optional fields",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2683,
                "column": 60
            },
            "line": 2683,
            "code": "      it('raises exception for type with non-optional fields', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input @oneOf {\n            int: Int!\n            boolean: Boolean!\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        try {\n          await plugin(schema, [], {}, { outputFile: '' });\n          throw new Error('Plugin should have raised an exception.');\n        } catch (err) {\n          expect(err.message).toEqual(\n            'Fields on an input object type can not be non-nullable. It seems like the schema was not validated.'\n          );\n        }\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "handles extensions properly",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2707,
                "column": 37
            },
            "line": 2707,
            "code": "      it('handles extensions properly', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input @oneOf {\n            int: Int\n          }\n\n          extend input Input {\n            boolean: Boolean\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n        expect(result.content).toBeSimilarStringTo(`\n          export type Input =\n            { int: Scalars['Int']; boolean?: never; }\n            | { int?: never; boolean: Scalars['Boolean']; };\n        `);\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "handles .isOneOf property on input object types properly",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2732,
                "column": 66
            },
            "line": 2732,
            "code": "      it('handles .isOneOf property on input object types properly', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input {\n            int: Int\n            boolean: Boolean\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        const inputType: Record<'isOneOf', boolean> = schema.getType('Input') as any;\n        inputType.isOneOf = true;\n\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n        expect(result.content).toBeSimilarStringTo(`\n          export type Input =\n            { int: Scalars['Int']; boolean?: never; }\n            | { int?: never; boolean: Scalars['Boolean']; };\n        `);\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use custom namingConvention for type name and args typename",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2760,
                "column": 74
            },
            "line": 2760,
            "code": "    it('Should use custom namingConvention for type name and args typename', async () => {\n      const schema = buildSchema(`type MyType { foo(a: String!, b: String, c: [String], d: [Int!]!): String }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { namingConvention: 'change-case-all#lowerCase' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type mytypefooargs = {\n          a: Scalars['String'];\n          b?: InputMaybe<Scalars['String']>;\n          c?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n          d: Array<Scalars['Int']>;\n        };\n    `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type mytype = {\n          __typename?: 'MyType';\n          foo?: Maybe<Scalars['String']>;\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use custom namingConvention and add custom prefix",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2787,
                "column": 64
            },
            "line": 2787,
            "code": "    it('Should use custom namingConvention and add custom prefix', async () => {\n      const schema = buildSchema(`type MyType { foo(a: String!, b: String, c: [String], d: [Int!]!): String }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { namingConvention: 'change-case-all#lowerCase', typesPrefix: 'I' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type Imytypefooargs = {\n          a: Scalars['String'];\n          b?: InputMaybe<Scalars['String']>;\n          c?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n          d: Array<Scalars['Int']>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type Imytype = {\n          __typename?: 'MyType';\n          foo?: Maybe<Scalars['String']>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should allow to disable typesPrefix for enums",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2815,
                "column": 53
            },
            "line": 2815,
            "code": "    it('Should allow to disable typesPrefix for enums', async () => {\n      const schema = buildSchema(`type T { f: String, e: E } enum E { A }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { typesPrefix: 'I', enumPrefix: false },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toContain(`export enum E {`);\n      expect(result.content).toContain(`e?: Maybe<E>;`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should enable typesPrefix for enums by default",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2830,
                "column": 54
            },
            "line": 2830,
            "code": "    it('Should enable typesPrefix for enums by default', async () => {\n      const schema = buildSchema(`type T { f: String, e: E } enum E { A }`);\n      const result = await plugin(schema, [], { typesPrefix: 'I' }, { outputFile: '' });\n\n      expect(result.content).toContain(`export enum IE {`);\n      expect(result.content).toContain(`e?: Maybe<IE>;`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correct values when using links between types - lowerCase",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2882,
                "column": 81
            },
            "line": 2882,
            "code": "    it('Should generate correct values when using links between types - lowerCase', async () => {\n      const result = (await plugin(\n        schema,\n        [],\n        { namingConvention: 'change-case-all#lowerCase' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum myenum {\n          a = 'A',\n          b = 'B',\n          c = 'C'\n        }\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type mytype = {\n          __typename?: 'MyType';\n          f?: Maybe<Scalars['String']>;\n          bar?: Maybe<myenum>;\n          b_a_r?: Maybe<Scalars['String']>;\n          myOtherField?: Maybe<Scalars['String']>;\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type my_type = {\n          __typename?: 'My_Type';\n          linkTest?: Maybe<mytype>;\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type myunion = my_type | mytype;\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type some_interface = {\n          id: Scalars['ID'];\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type impl1 = some_interface & {\n          __typename?: 'Impl1';\n          id: Scalars['ID'];\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type impl_2 = some_interface & {\n          __typename?: 'Impl_2';\n          id: Scalars['ID'];\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type impl_3 = some_interface & {\n          __typename?: 'impl_3';\n          id: Scalars['ID'];\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type query = {\n          __typename?: 'Query';\n          something?: Maybe<myunion>;\n          use_interface?: Maybe<some_interface>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correct values when using links between types - pascalCase (default)",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2949,
                "column": 92
            },
            "line": 2949,
            "code": "    it('Should generate correct values when using links between types - pascalCase (default)', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export enum MyEnum {\n        A = 'A',\n        B = 'B',\n        C = 'C'\n      }\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        f?: Maybe<Scalars['String']>;\n        bar?: Maybe<MyEnum>;\n        b_a_r?: Maybe<Scalars['String']>;\n        myOtherField?: Maybe<Scalars['String']>;\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type My_Type = {\n        __typename?: 'My_Type';\n        linkTest?: Maybe<MyType>;\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyUnion = My_Type | MyType;\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Some_Interface = {\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Impl1 = Some_Interface & {\n        __typename?: 'Impl1';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Impl_2 = Some_Interface & {\n        __typename?: 'Impl_2';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Impl_3 = Some_Interface & {\n        __typename?: 'impl_3';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Query = {\n        __typename?: 'Query';\n        something?: Maybe<MyUnion>;\n        use_interface?: Maybe<Some_Interface>;\n      };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correct values when using links between types - pascalCase (default) with custom prefix",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 3011,
                "column": 111
            },
            "line": 3011,
            "code": "    it('Should generate correct values when using links between types - pascalCase (default) with custom prefix', async () => {\n      const result = await plugin(schema, [], { typesPrefix: 'I' }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export enum IMyEnum {\n        A = 'A',\n        B = 'B',\n        C = 'C'\n      }`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type IMyType = {\n        __typename?: 'MyType';\n        f?: Maybe<Scalars['String']>;\n        bar?: Maybe<IMyEnum>;\n        b_a_r?: Maybe<Scalars['String']>;\n        myOtherField?: Maybe<Scalars['String']>;\n      };`);\n      expect(result.content).toBeSimilarStringTo(`\n      export type IMy_Type = {\n        __typename?: 'My_Type';\n        linkTest?: Maybe<IMyType>;\n      };\n  `);\n      expect(result.content).toBeSimilarStringTo(`export type IMyUnion = IMy_Type | IMyType;`);\n      expect(result.content).toBeSimilarStringTo(`\n      export type ISome_Interface = {\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type IImpl1 = ISome_Interface & {\n        __typename?: 'Impl1';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type IImpl_2 = ISome_Interface & {\n        __typename?: 'Impl_2';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type IImpl_3 = ISome_Interface & {\n        __typename?: 'impl_3';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type IQuery = {\n        __typename?: 'Query';\n        something?: Maybe<IMyUnion>;\n        use_interface?: Maybe<ISome_Interface>;\n      };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for field arguments - with basic fields",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3072,
                "column": 79
            },
            "line": 3072,
            "code": "    it('Should generate correctly types for field arguments - with basic fields', async () => {\n      const schema = buildSchema(`type MyType { foo(a: String!, b: String, c: [String], d: [Int!]!): String }`);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypeFooArgs = {\n          a: Scalars['String'];\n          b?: InputMaybe<Scalars['String']>;\n          c?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n          d: Array<Scalars['Int']>;\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for field arguments - with default value",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3089,
                "column": 80
            },
            "line": 3089,
            "code": "    it('Should generate correctly types for field arguments - with default value', async () => {\n      const schema = buildSchema(\n        `type MyType { foo(a: String = \"default\", b: String! = \"default\", c: String, d: String!): String }`\n      );\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypeFooArgs = {\n          a?: InputMaybe<Scalars['String']>;\n          b?: Scalars['String'];\n          c?: InputMaybe<Scalars['String']>;\n          d: Scalars['String'];\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for field arguments - with default value and avoidOptionals option set to true",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3107,
                "column": 118
            },
            "line": 3107,
            "code": "    it('Should generate correctly types for field arguments - with default value and avoidOptionals option set to true', async () => {\n      const schema = buildSchema(\n        `type MyType { foo(a: String = \"default\", b: String! = \"default\", c: String, d: String!): String }`\n      );\n      const result = (await plugin(\n        schema,\n        [],\n        { avoidOptionals: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypeFooArgs = {\n          a?: InputMaybe<Scalars['String']>;\n          b?: Scalars['String'];\n          c: InputMaybe<Scalars['String']>;\n          d: Scalars['String'];\n      };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for field arguments - with input type",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3130,
                "column": 77
            },
            "line": 3130,
            "code": "    it('Should generate correctly types for field arguments - with input type', async () => {\n      const schema = buildSchema(\n        `input MyInput { f: String } type MyType { foo(a: MyInput, b: MyInput!, c: [MyInput], d: [MyInput]!, e: [MyInput!]!): String }`\n      );\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypeFooArgs = {\n          a?: InputMaybe<MyInput>;\n          b: MyInput;\n          c?: InputMaybe<Array<InputMaybe<MyInput>>>;\n          d: Array<InputMaybe<MyInput>>;\n          e: Array<MyInput>;\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add custom prefix for mutation arguments",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3149,
                "column": 55
            },
            "line": 3149,
            "code": "    it('Should add custom prefix for mutation arguments', async () => {\n      const schema = buildSchema(`input Input { name: String } type Mutation { foo(id: ID, input: Input): String }`);\n      const result = await plugin(schema, [], { typesPrefix: 'T' }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type TInput = {\n          name?: InputMaybe<Scalars['String']>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type TMutation = {\n          __typename?: 'Mutation';\n          foo?: Maybe<Scalars['String']>;\n        };\n\n        export type TMutationFooArgs = {\n          id?: InputMaybe<Scalars['ID']>;\n          input?: InputMaybe<TInput>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate the correct type for a method with arguments (interface object)",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3174,
                "column": 87
            },
            "line": 3174,
            "code": "    it('Should generate the correct type for a method with arguments (interface object)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Node {\n          text(arg1: String!, arg2: String): String\n        }\n\n        type Book implements Node {\n          id: ID!\n          text(arg: String, arg2: String!): String\n        }\n\n        type Query {\n          books: [Book!]!\n        }\n      `);\n      const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type NodeTextArgs = {\n          arg1: Scalars['String'];\n          arg2?: InputMaybe<Scalars['String']>;\n        };\n      `);\n      await validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for inputs with default value - #4273",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3200,
                "column": 77
            },
            "line": 3200,
            "code": "    it('Should generate correctly types for inputs with default value - #4273', async () => {\n      const schema = buildSchema(\n        `input MyInput { a: String = \"default\", b: String! = \"default\", c: String, d: String! }`\n      );\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          a?: InputMaybe<Scalars['String']>;\n          b?: Scalars['String'];\n          c?: InputMaybe<Scalars['String']>;\n          d: Scalars['String'];\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for inputs with default value and avoidOptionals.defaultValue set to true - #5112",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3218,
                "column": 121
            },
            "line": 3218,
            "code": "    it('Should generate correctly types for inputs with default value and avoidOptionals.defaultValue set to true - #5112', async () => {\n      const schema = buildSchema(\n        `input MyInput { a: String = \"default\", b: String! = \"default\", c: String, d: String! }`\n      );\n      const result = await plugin(schema, [], { avoidOptionals: { defaultValue: true } }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          a?: InputMaybe<Scalars['String']>;\n          b: Scalars['String'];\n          c?: InputMaybe<Scalars['String']>;\n          d: Scalars['String'];\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for field arguments with default value and avoidOptionals.defaultValue option set to true - #5112",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3236,
                "column": 137
            },
            "line": 3236,
            "code": "    it('Should generate correctly types for field arguments with default value and avoidOptionals.defaultValue option set to true - #5112', async () => {\n      const schema = buildSchema(\n        `type MyType { foo(a: String = \"default\", b: String! = \"default\", c: String, d: String!): String }`\n      );\n      const result = (await plugin(\n        schema,\n        [],\n        { avoidOptionals: { defaultValue: true } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypeFooArgs = {\n          a?: InputMaybe<Scalars['String']>;\n          b: Scalars['String'];\n          c?: InputMaybe<Scalars['String']>;\n          d: Scalars['String'];\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build basic enum correctly",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3261,
                "column": 41
            },
            "line": 3261,
            "code": "    it('Should build basic enum correctly', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum MyEnum {\n          A = 'A',\n          B = 'B',\n          C = 'C'\n        }\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build enum correctly with custom values",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3276,
                "column": 54
            },
            "line": 3276,
            "code": "    it('Should build enum correctly with custom values', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: { A: 'SomeValue', B: 'TEST' } } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum MyEnum {\n          A = 'SomeValue',\n          B = 'TEST',\n          C = 'C'\n        }\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build enum correctly with custom imported enum",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3296,
                "column": 61
            },
            "line": 3296,
            "code": "    it('Should build enum correctly with custom imported enum', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#MyEnum' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export enum MyEnum`);\n      expect(result.prepend).toContain(`import { MyEnum } from './my-file';`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build enum correctly with custom imported enum from namespace with different name",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3311,
                "column": 96
            },
            "line": 3311,
            "code": "    it('Should build enum correctly with custom imported enum from namespace with different name', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#NS.ETest' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export enum MyEnum`);\n      expect(result.content).toContain(`export { MyEnum }`);\n      expect(result.prepend).toContain(`import MyEnum = NS.ETest;`);\n      expect(result.prepend).toContain(`import { NS } from './my-file';`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build enum correctly with custom imported enum from namespace with same name",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3328,
                "column": 91
            },
            "line": 3328,
            "code": "    it('Should build enum correctly with custom imported enum from namespace with same name', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#NS.MyEnum' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export enum MyEnum`);\n      expect(result.content).toContain(`export { MyEnum };`);\n      expect(result.prepend).toContain(`import MyEnum = NS.MyEnum;`);\n      expect(result.prepend).toContain(`import { NS } from './my-file';`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build enum correctly with custom imported enum with different name",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3345,
                "column": 81
            },
            "line": 3345,
            "code": "    it('Should build enum correctly with custom imported enum with different name', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C } type Query { t: MyEnum }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#MyCustomEnum' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export enum MyEnum`);\n      expect(result.prepend).toContain(`import { MyCustomEnum as MyEnum } from './my-file';`);\n      expect(result.content).toContain(`export { MyEnum };`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should import all enums from a single file when specified as string",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3361,
                "column": 75
            },
            "line": 3361,
            "code": "    it('Should import all enums from a single file when specified as string', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C } enum MyEnum2 { X, Y, Z }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: './my-file' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export enum MyEnum`);\n      expect(result.content).not.toContain(`export enum MyEnum2`);\n      expect(result.prepend).toContain(`import { MyEnum } from './my-file';`);\n      expect(result.prepend).toContain(`import { MyEnum2 } from './my-file';`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should re-export external enums",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3378,
                "column": 39
            },
            "line": 3378,
            "code": "    it('Should re-export external enums', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C } enum MyEnum2 { X, Y, Z }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#MyEnum', MyEnum2: './my-file#MyEnum2X' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toContain(`export { MyEnum };`);\n      expect(result.content).toContain(`export { MyEnum2 };`);\n      expect(result.prepend).toContain(`import { MyEnum2X as MyEnum2 } from './my-file';`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should re-export external enums when single file option used",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3394,
                "column": 68
            },
            "line": 3394,
            "code": "    it('Should re-export external enums when single file option used', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C } enum MyEnum2 { X, Y, Z }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: './my-file' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.prepend).toContain(`import { MyEnum } from './my-file';`);\n      expect(result.prepend).toContain(`import { MyEnum2 } from './my-file';`);\n      expect(result.content).toContain(`export { MyEnum };`);\n      expect(result.content).toContain(`export { MyEnum2 };`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "allowEnumStringTypes",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3411,
                "column": 28
            },
            "line": 3411,
            "code": "    it('allowEnumStringTypes', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A\n          B\n          C\n        }\n        type Query {\n          a: MyEnum\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { allowEnumStringTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      validateTs(result);\n\n      expect(result.content).toBeSimilarStringTo('a?: Maybe<MyEnum | `${MyEnum}`>;');\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should not have [object Object]",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3435,
                "column": 37
            },
            "line": 3435,
            "code": "  it('should not have [object Object]', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type User {\n        id: Int!\n        name: String!\n        email: String!\n      }\n\n      type QueryRoot {\n        allUsers: [User]!\n        userById(id: Int!): User\n\n        # Generates a new answer for the guessing game\n        answer: [Int!]!\n      }\n\n      type SubscriptionRoot {\n        newUser: User\n      }\n\n      schema {\n        query: QueryRoot\n        subscription: SubscriptionRoot\n      }\n    `);\n\n    const content = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(content).not.toContainEqual('[object Object]');\n\n    validateTs(content);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should contain __typename",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3468,
                "column": 31
            },
            "line": 3468,
            "code": "  it('should contain __typename', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type User {\n        id: Int!\n        name: String!\n        email: String!\n      }\n      type QueryRoot {\n        allUsers: [User]!\n        userById(id: Int!): User\n        # Generates a new answer for the guessing game\n        answer: [Int!]!\n      }\n      type SubscriptionRoot {\n        newUser: User\n      }\n      schema {\n        query: QueryRoot\n        subscription: SubscriptionRoot\n      }\n    `);\n\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n    expect(result.content).toContain('__typename');\n\n    validateTs(result);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should not contain __typename",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3496,
                "column": 35
            },
            "line": 3496,
            "code": "  it('should not contain __typename', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type User {\n        id: Int!\n        name: String!\n        email: String!\n      }\n      type QueryRoot {\n        allUsers: [User]!\n        userById(id: Int!): User\n        # Generates a new answer for the guessing game\n        answer: [Int!]!\n      }\n      type SubscriptionRoot {\n        newUser: User\n      }\n      schema {\n        query: QueryRoot\n        subscription: SubscriptionRoot\n      }\n    `);\n\n    const result = await plugin(schema, [], { skipTypename: true }, { outputFile: '' });\n    expect(result.content).not.toContain('__typename');\n\n    validateTs(result);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should not contain \"export\" when noExport is set to true",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3524,
                "column": 62
            },
            "line": 3524,
            "code": "  it('should not contain \"export\" when noExport is set to true', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type User {\n        id: Int!\n        name: String!\n        email: String!\n      }\n      type QueryRoot {\n        allUsers: [User]!\n        userById(id: Int!): User\n        # Generates a new answer for the guessing game\n        answer: [Int!]!\n      }\n      type SubscriptionRoot {\n        newUser: User\n      }\n      schema {\n        query: QueryRoot\n        subscription: SubscriptionRoot\n      }\n    `);\n\n    const result = await plugin(schema, [], { noExport: true }, { outputFile: '' });\n    expect(result.content).not.toContain('export');\n\n    validateTs(result);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should keep non-optional arguments non-optional - issue #2323",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3552,
                "column": 67
            },
            "line": 3552,
            "code": "  it('should keep non-optional arguments non-optional - issue #2323', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      enum OrderBy {\n        name\n        id\n      }\n\n      input Filter {\n        contain: String\n      }\n\n      type Node {\n        id: ID!\n        name: String!\n      }\n\n      type Connection {\n        nodes: [Node]\n      }\n\n      type Query {\n        list(after: String, orderBy: OrderBy = name, filter: Filter!): Connection!\n      }\n    `);\n\n    const output = (await plugin(\n      testSchema,\n      [],\n      {\n        avoidOptionals: false,\n        maybeValue: 'T | undefined',\n      } as any,\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    // Filter.contain should be optional\n    expect(output.content).toBeSimilarStringTo(`\n      export type Filter = {\n        contain?: InputMaybe<Scalars['String']>;\n      };\n    `);\n    // filter should be non-optional\n    expect(output.content).toBeSimilarStringTo(`\n      export type QueryListArgs = {\n        after?: InputMaybe<Scalars['String']>;\n        orderBy?: InputMaybe<OrderBy>;\n        filter: Filter;\n      };\n    `);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should respect defined enum values",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3603,
                "column": 40
            },
            "line": 3603,
            "code": "  it('should respect defined enum values', async () => {\n    const testSchema = new GraphQLSchema({\n      query: new GraphQLObjectType({\n        name: 'Query',\n        fields: {\n          foo: {\n            type: new GraphQLEnumType({\n              name: 'Foo',\n              values: {\n                Bar: {\n                  value: 'Qux',\n                },\n              },\n            }),\n          },\n        },\n      }),\n    });\n    const output = await plugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n\n    expect(output.content).toBeSimilarStringTo(`\n      export enum Foo {\n        Bar = 'Qux'\n      }\n    `);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should use implementing types as node type - issue #5126",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3630,
                "column": 62
            },
            "line": 3630,
            "code": "  it('should use implementing types as node type - issue #5126', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Matrix {\n        pills: [Pill!]!\n      }\n\n      interface Pill {\n        id: ID!\n      }\n\n      type RedPill implements Pill {\n        red: String!\n      }\n\n      type GreenPill implements Pill {\n        green: String!\n      }\n\n      interface Foo {\n        id: ID!\n      }\n\n      type Bar implements Foo {\n        lol: String!\n      }\n\n      type Hello {\n        foo: Foo!\n      }\n\n      type NoInterface {\n        hello: Hello!\n      }\n\n      interface NestedInterface implements Foo {\n        field: String!\n      }\n\n      type NestedType1 implements NestedInterface {\n        hi: String!\n      }\n\n      type NestedType2 implements NestedInterface {\n        ho: String!\n      }\n\n      type NestedField {\n        nested: NestedInterface!\n      }\n    `);\n\n    const output = (await plugin(\n      testSchema,\n      [],\n      {\n        useImplementingTypes: true,\n      } as any,\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(output.content).toMatchSnapshot();\n\n    // Type should be Array<RedPill|GreenPill> and not Pill\n    expect(output.content).toBeSimilarStringTo(`\n      export type Matrix = {\n        __typename?: 'Matrix';\n        pills: Array<RedPill | GreenPill>;\n      };\n    `);\n    // Type should be Bar and not Foo\n    expect(output.content).toBeSimilarStringTo(`\n      export type Hello = {\n        __typename?: 'Hello';\n        foo: Bar;\n      };\n    `);\n    // Type should be Hello and not empty\n    expect(output.content).toBeSimilarStringTo(`\n      export type NoInterface = {\n        __typename?: 'NoInterface';\n        hello: Hello;\n      };\n    `);\n    // Type should be NestedType1|NestedType2\n    expect(output.content).toBeSimilarStringTo(`\n      export type NestedField = {\n        __typename?: 'NestedField';\n        nested: NestedType1 | NestedType2;\n      };\n    `);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "can imports files in the same directory",
            "suites": [
                "gql-tag-operations-preset > babelPlugin"
            ],
            "updatePoint": {
                "line": 6,
                "column": 47
            },
            "line": 6,
            "code": "  test('can imports files in the same directory', () => {\n    const result = transformFileSync(path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'), {\n      plugins: [[babelPlugin, { artifactDirectory: path.join(__dirname, 'fixtures') }]],\n      babelrc: false,\n      configFile: false,\n    }).code;\n    expect(result).toMatchInlineSnapshot(`\n      \"import { CFragmentDoc } from \"./graphql\";\n      import { BDocument } from \"./graphql\";\n      import { ADocument } from \"./graphql\";\n      /* eslint-disable @typescript-eslint/ban-ts-comment */\n      //@ts-ignore\n      import gql from 'gql-tag';\n\n      //@ts-ignore\n      const A = ADocument;\n\n      //@ts-ignore\n      const B = BDocument;\n\n      //@ts-ignore\n      const C = CFragmentDoc;\"\n    `);\n  });",
            "file": "babel.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "can import files in another directory",
            "suites": [
                "gql-tag-operations-preset > babelPlugin"
            ],
            "updatePoint": {
                "line": 30,
                "column": 45
            },
            "line": 30,
            "code": "  test('can import files in another directory', () => {\n    const result = transformFileSync(path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'), {\n      plugins: [[babelPlugin, { artifactDirectory: __dirname }]],\n      babelrc: false,\n      configFile: false,\n    }).code;\n    expect(result).toMatchInlineSnapshot(`\n      \"import { CFragmentDoc } from \"../graphql\";\n      import { BDocument } from \"../graphql\";\n      import { ADocument } from \"../graphql\";\n      /* eslint-disable @typescript-eslint/ban-ts-comment */\n      //@ts-ignore\n      import gql from 'gql-tag';\n\n      //@ts-ignore\n      const A = ADocument;\n\n      //@ts-ignore\n      const B = BDocument;\n\n      //@ts-ignore\n      const C = CFragmentDoc;\"\n    `);\n  });",
            "file": "babel.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "can generate simple examples uppercase names",
            "suites": [
                "gql-tag-operations-preset"
            ],
            "updatePoint": {
                "line": 9,
                "column": 50
            },
            "line": 9,
            "code": "  it('can generate simple examples uppercase names', async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n            b: String\n            c: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n      generates: {\n        out1: {\n          preset,\n        },\n      },\n    });\n\n    expect(result).toHaveLength(3);\n    // index.ts (re-exports)\n    const indexFile = result.find(file => file.filename === 'out1/index.ts');\n    expect(indexFile.content).toEqual('export * from \"./gql\"');\n\n    // gql.ts\n    const gqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(gqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import * as types from './graphql';\n      import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n      /**\n       * Map of all GraphQL operations in the project.\n       *\n       * This map has several performance disadvantages:\n       * 1. It is not tree-shakeable, so it will include all operations in the project.\n       * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.\n       * 3. It does not support dead code elimination, so it will add unused operations.\n       *\n       * Therefore it is highly recommended to use the babel or swc plugin for production.\n       */\n      const documents = {\n          \"\\\\n  query A {\\\\n    a\\\\n  }\\\\n\": types.ADocument,\n          \"\\\\n  query B {\\\\n    b\\\\n  }\\\\n\": types.BDocument,\n          \"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\": types.CFragmentDoc,\n      };\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       *\n       *\n       * @example\n       * \\`\\`\\`ts\n       * const query = gql(\\`query GetUser($id: ID!) { user(id: $id) { name } }\\`);\n       * \\`\\`\\`\n       *\n       * The query argument is unknown!\n       * Please regenerate the types.\n       */\n      export function gql(source: string): unknown;\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  query A {\\\\n    a\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  query A {\\\\n    a\\\\n  }\\\\n\"];\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  query B {\\\\n    b\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  query B {\\\\n    b\\\\n  }\\\\n\"];\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\"];\n\n      export function gql(source: string) {\n        return (documents as any)[source] ?? {};\n      }\n\n      export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;\"\n    `);\n\n    // graphql.ts\n    const graphqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(graphqlFile).toBeDefined();\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "can generate simple examples lowercase names",
            "suites": [
                "gql-tag-operations-preset"
            ],
            "updatePoint": {
                "line": 95,
                "column": 50
            },
            "line": 95,
            "code": "  it('can generate simple examples lowercase names', async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n            b: String\n            c: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/simple-lowercase-operation-name.ts'),\n      generates: {\n        out1: {\n          preset,\n        },\n      },\n    });\n\n    expect(result).toHaveLength(3);\n    // index.ts (re-exports)\n    const indexFile = result.find(file => file.filename === 'out1/index.ts');\n    expect(indexFile.content).toEqual('export * from \"./gql\"');\n\n    // gql.ts\n    const gqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(gqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import * as types from './graphql';\n      import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n      /**\n       * Map of all GraphQL operations in the project.\n       *\n       * This map has several performance disadvantages:\n       * 1. It is not tree-shakeable, so it will include all operations in the project.\n       * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.\n       * 3. It does not support dead code elimination, so it will add unused operations.\n       *\n       * Therefore it is highly recommended to use the babel or swc plugin for production.\n       */\n      const documents = {\n          \"\\\\n  query a {\\\\n    a\\\\n  }\\\\n\": types.ADocument,\n          \"\\\\n  query b {\\\\n    b\\\\n  }\\\\n\": types.BDocument,\n          \"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\": types.CFragmentDoc,\n      };\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       *\n       *\n       * @example\n       * \\`\\`\\`ts\n       * const query = gql(\\`query GetUser($id: ID!) { user(id: $id) { name } }\\`);\n       * \\`\\`\\`\n       *\n       * The query argument is unknown!\n       * Please regenerate the types.\n       */\n      export function gql(source: string): unknown;\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  query a {\\\\n    a\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  query a {\\\\n    a\\\\n  }\\\\n\"];\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  query b {\\\\n    b\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  query b {\\\\n    b\\\\n  }\\\\n\"];\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\"];\n\n      export function gql(source: string) {\n        return (documents as any)[source] ?? {};\n      }\n\n      export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;\"\n  `);\n\n    // graphql.ts\n    const graphqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(graphqlFile).toBeDefined();\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "generates \\n regardless of whether the source contains LF or CRLF",
            "suites": [
                "gql-tag-operations-preset"
            ],
            "updatePoint": {
                "line": 181,
                "column": 72
            },
            "line": 181,
            "code": "  it('generates \\\\n regardless of whether the source contains LF or CRLF', async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n            b: String\n            c: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/crlf-operation.ts'),\n      generates: {\n        out1: {\n          preset,\n        },\n      },\n    });\n    const gqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(gqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import * as types from './graphql';\n      import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n      /**\n       * Map of all GraphQL operations in the project.\n       *\n       * This map has several performance disadvantages:\n       * 1. It is not tree-shakeable, so it will include all operations in the project.\n       * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.\n       * 3. It does not support dead code elimination, so it will add unused operations.\n       *\n       * Therefore it is highly recommended to use the babel or swc plugin for production.\n       */\n      const documents = {\n          \"\\\\n  query a {\\\\n    a\\\\n  }\\\\n\": types.ADocument,\n          \"\\\\n  query b {\\\\n    b\\\\n  }\\\\n\": types.BDocument,\n          \"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\": types.CFragmentDoc,\n      };\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       *\n       *\n       * @example\n       * \\`\\`\\`ts\n       * const query = gql(\\`query GetUser($id: ID!) { user(id: $id) { name } }\\`);\n       * \\`\\`\\`\n       *\n       * The query argument is unknown!\n       * Please regenerate the types.\n       */\n      export function gql(source: string): unknown;\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  query a {\\\\n    a\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  query a {\\\\n    a\\\\n  }\\\\n\"];\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  query b {\\\\n    b\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  query b {\\\\n    b\\\\n  }\\\\n\"];\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\"];\n\n      export function gql(source: string) {\n        return (documents as any)[source] ?? {};\n      }\n\n      export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;\"\n    `);\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "follows 'useTypeImports': true",
            "suites": [
                "gql-tag-operations-preset"
            ],
            "updatePoint": {
                "line": 256,
                "column": 36
            },
            "line": 256,
            "code": "  it(\"follows 'useTypeImports': true\", async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n            b: String\n            c: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n      generates: {\n        out1: {\n          preset,\n        },\n      },\n      config: {\n        useTypeImports: true,\n      },\n    });\n\n    expect(result.length).toBe(3);\n    const gqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(gqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import * as types from './graphql';\n      import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n      /**\n       * Map of all GraphQL operations in the project.\n       *\n       * This map has several performance disadvantages:\n       * 1. It is not tree-shakeable, so it will include all operations in the project.\n       * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.\n       * 3. It does not support dead code elimination, so it will add unused operations.\n       *\n       * Therefore it is highly recommended to use the babel or swc plugin for production.\n       */\n      const documents = {\n          \"\\\\n  query A {\\\\n    a\\\\n  }\\\\n\": types.ADocument,\n          \"\\\\n  query B {\\\\n    b\\\\n  }\\\\n\": types.BDocument,\n          \"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\": types.CFragmentDoc,\n      };\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       *\n       *\n       * @example\n       * \\`\\`\\`ts\n       * const query = gql(\\`query GetUser($id: ID!) { user(id: $id) { name } }\\`);\n       * \\`\\`\\`\n       *\n       * The query argument is unknown!\n       * Please regenerate the types.\n       */\n      export function gql(source: string): unknown;\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  query A {\\\\n    a\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  query A {\\\\n    a\\\\n  }\\\\n\"];\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  query B {\\\\n    b\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  query B {\\\\n    b\\\\n  }\\\\n\"];\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\"];\n\n      export function gql(source: string) {\n        return (documents as any)[source] ?? {};\n      }\n\n      export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;\"\n    `);\n    const graphqlFile = result.find(file => file.filename === 'out1/graphql.ts');\n    expect(graphqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n      export type Maybe<T> = T | null;\n      export type InputMaybe<T> = Maybe<T>;\n      export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\n      export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\n      export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n      /** All built-in and custom scalars, mapped to their actual values */\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n      };\n\n      export type Query = {\n        __typename?: 'Query';\n        a?: Maybe<Scalars['String']>;\n        b?: Maybe<Scalars['String']>;\n        c?: Maybe<Scalars['String']>;\n      };\n\n      export type AQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n      export type AQuery = { __typename?: 'Query', a?: string | null };\n\n      export type BQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n      export type BQuery = { __typename?: 'Query', b?: string | null };\n\n      export type CFragment = { __typename?: 'Query', c?: string | null };\n\n      export const CFragmentDoc = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"FragmentDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"C\"},\"typeCondition\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Query\"}},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"c\"}}]}}]} as unknown as DocumentNode<CFragment, unknown>;\n      export const ADocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"A\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"a\"}}]}}]} as unknown as DocumentNode<AQuery, AQueryVariables>;\n      export const BDocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"B\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"b\"}}]}}]} as unknown as DocumentNode<BQuery, BQueryVariables>;\"\n    `);\n\n    expect(graphqlFile.content).toContain(\n      \"import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core'\"\n    );\n    expect(gqlFile.content).toContain(\n      \"import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core'\"\n    );\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "prevent duplicate operations",
            "suites": [
                "gql-tag-operations-preset"
            ],
            "updatePoint": {
                "line": 384,
                "column": 34
            },
            "line": 384,
            "code": "  it('prevent duplicate operations', async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/duplicate-operation.ts'),\n      generates: {\n        out1: {\n          preset,\n        },\n      },\n      config: {\n        useTypeImports: true,\n      },\n    });\n\n    expect(result.length).toBe(3);\n    const gqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(gqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import * as types from './graphql';\n      import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n      /**\n       * Map of all GraphQL operations in the project.\n       *\n       * This map has several performance disadvantages:\n       * 1. It is not tree-shakeable, so it will include all operations in the project.\n       * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.\n       * 3. It does not support dead code elimination, so it will add unused operations.\n       *\n       * Therefore it is highly recommended to use the babel or swc plugin for production.\n       */\n      const documents = {\n          \"\\\\n  query a {\\\\n    a\\\\n  }\\\\n\": types.ADocument,\n      };\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       *\n       *\n       * @example\n       * \\`\\`\\`ts\n       * const query = gql(\\`query GetUser($id: ID!) { user(id: $id) { name } }\\`);\n       * \\`\\`\\`\n       *\n       * The query argument is unknown!\n       * Please regenerate the types.\n       */\n      export function gql(source: string): unknown;\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  query a {\\\\n    a\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  query a {\\\\n    a\\\\n  }\\\\n\"];\n\n      export function gql(source: string) {\n        return (documents as any)[source] ?? {};\n      }\n\n      export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;\"\n    `);\n    const graphqlFile = result.find(file => file.filename === 'out1/graphql.ts');\n    expect(graphqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n      export type Maybe<T> = T | null;\n      export type InputMaybe<T> = Maybe<T>;\n      export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\n      export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\n      export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n      /** All built-in and custom scalars, mapped to their actual values */\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n      };\n\n      export type Query = {\n        __typename?: 'Query';\n        a?: Maybe<Scalars['String']>;\n      };\n\n      export type AQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n      export type AQuery = { __typename?: 'Query', a?: string | null };\n\n\n      export const ADocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"a\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"a\"}}]}}]} as unknown as DocumentNode<AQuery, AQueryVariables>;\"\n    `);\n\n    expect(gqlFile.content.match(/query a {/g).length).toBe(3);\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "fragmentMasking: true",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 486,
                "column": 29
            },
            "line": 486,
            "code": "    it('fragmentMasking: true', async () => {\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              a: String\n              b: String\n              c: String\n            }\n          `,\n        ],\n        documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n        generates: {\n          out1: {\n            preset,\n            presetConfig: {\n              fragmentMasking: true,\n            },\n          },\n        },\n      });\n\n      expect(result).toHaveLength(4);\n      const fileNames = result.map(res => res.filename);\n      expect(fileNames).toContain('out1/fragment-masking.ts');\n      expect(fileNames).toContain('out1/index.ts');\n      expect(fileNames).toContain('out1/gql.ts');\n      expect(fileNames).toContain('out1/graphql.ts');\n\n      const gqlFile = result.find(file => file.filename === 'out1/index.ts');\n      expect(gqlFile.content).toMatchInlineSnapshot(`\n        \"export * from \"./gql\"\n        export * from \"./fragment-masking\"\"\n      `);\n      const fragmentMaskingFile = result.find(file => file.filename === 'out1/fragment-masking.ts');\n      expect(fragmentMaskingFile.content).toMatchInlineSnapshot(`\n        \"import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n\n        export type FragmentType<TDocumentType extends DocumentNode<any, any>> = TDocumentType extends DocumentNode<\n          infer TType,\n          any\n        >\n          ? TType extends { ' $fragmentName'?: infer TKey }\n            ? TKey extends string\n              ? { ' $fragmentRefs'?: { [key in TKey]: TType } }\n              : never\n            : never\n          : never;\n\n        // return non-nullable if \\`fragmentType\\` is non-nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>>\n        ): TType;\n        // return nullable if \\`fragmentType\\` is nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>> | null | undefined\n        ): TType | null | undefined;\n        // return array of non-nullable if \\`fragmentType\\` is array of non-nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>>\n        ): ReadonlyArray<TType>;\n        // return array of nullable if \\`fragmentType\\` is array of nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n        ): ReadonlyArray<TType> | null | undefined;\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>> | ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n        ): TType | ReadonlyArray<TType> | null | undefined {\n          return fragmentType as any;\n        }\n        \"\n      `);\n    });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "fragmentMasking: {}",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 566,
                "column": 27
            },
            "line": 566,
            "code": "    it('fragmentMasking: {}', async () => {\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              a: String\n              b: String\n              c: String\n            }\n          `,\n        ],\n        documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n        generates: {\n          out1: {\n            preset,\n            presetConfig: {\n              fragmentMasking: {},\n            },\n          },\n        },\n      });\n\n      expect(result).toHaveLength(4);\n    });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "fragmentMasking.unmaskFunctionName",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 591,
                "column": 42
            },
            "line": 591,
            "code": "    it('fragmentMasking.unmaskFunctionName', async () => {\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              a: String\n              b: String\n              c: String\n            }\n          `,\n        ],\n        documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n        generates: {\n          out1: {\n            preset,\n            presetConfig: {\n              fragmentMasking: {\n                unmaskFunctionName: 'iLikeTurtles',\n              },\n            },\n          },\n        },\n      });\n\n      expect(result).toHaveLength(4);\n      const gqlFile = result.find(file => file.filename === 'out1/fragment-masking.ts');\n      expect(gqlFile.content).toMatchInlineSnapshot(`\n        \"import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n\n        export type FragmentType<TDocumentType extends DocumentNode<any, any>> = TDocumentType extends DocumentNode<\n          infer TType,\n          any\n        >\n          ? TType extends { ' $fragmentName'?: infer TKey }\n            ? TKey extends string\n              ? { ' $fragmentRefs'?: { [key in TKey]: TType } }\n              : never\n            : never\n          : never;\n\n        // return non-nullable if \\`fragmentType\\` is non-nullable\n        export function iLikeTurtles<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>>\n        ): TType;\n        // return nullable if \\`fragmentType\\` is nullable\n        export function iLikeTurtles<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>> | null | undefined\n        ): TType | null | undefined;\n        // return array of non-nullable if \\`fragmentType\\` is array of non-nullable\n        export function iLikeTurtles<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>>\n        ): ReadonlyArray<TType>;\n        // return array of nullable if \\`fragmentType\\` is array of nullable\n        export function iLikeTurtles<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n        ): ReadonlyArray<TType> | null | undefined;\n        export function iLikeTurtles<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>> | ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n        ): TType | ReadonlyArray<TType> | null | undefined {\n          return fragmentType as any;\n        }\n        \"\n      `);\n\n      expect(gqlFile.content).toBeSimilarStringTo(`\n      export function iLikeTurtles<TType>(\n        _documentNode: DocumentNode<TType, any>,\n        fragmentType: FragmentType<DocumentNode<TType, any>>\n      ): TType;\n      `);\n      expect(gqlFile.content).toBeSimilarStringTo(`\n      export function iLikeTurtles<TType>(\n        _documentNode: DocumentNode<TType, any>,\n        fragmentType: FragmentType<DocumentNode<TType, any>> | null | undefined\n      ): TType | null | undefined;\n      `);\n      expect(gqlFile.content).toBeSimilarStringTo(`\n      export function iLikeTurtles<TType>(\n        _documentNode: DocumentNode<TType, any>,\n        fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>>\n      ): ReadonlyArray<TType>;\n      `);\n      expect(gqlFile.content).toBeSimilarStringTo(`\n      export function iLikeTurtles<TType>(\n        _documentNode: DocumentNode<TType, any>,\n        fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n      ): ReadonlyArray<TType> | null | undefined;\n      `);\n      expect(gqlFile.content).toBeSimilarStringTo(`\n      export function iLikeTurtles<TType>(\n        _documentNode: DocumentNode<TType, any>,\n        fragmentType: FragmentType<DocumentNode<TType, any>> | ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n      ): TType | ReadonlyArray<TType> | null | undefined {\n        return fragmentType as any;\n      }\n      `);\n    });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "can accept null in useFragment",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 695,
                "column": 38
            },
            "line": 695,
            "code": "    it('can accept null in useFragment', async () => {\n      const docPath = path.join(__dirname, 'fixtures/with-fragment.ts');\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              foo: Foo\n              foos: [Foo]\n            }\n\n            type Foo {\n              value: String\n            }\n          `,\n        ],\n        documents: docPath,\n        generates: {\n          out1: {\n            preset,\n            presetConfig: {\n              fragmentMasking: true,\n            },\n          },\n        },\n      });\n\n      const content = mergeOutputs([\n        ...result,\n        readFileSync(docPath, 'utf8'),\n        `\n        function App(props: { data: FooQuery }) {\n          const fragment: FooFragment | null | undefined = useFragment(Fragment, props.data.foo);\n          return fragment == null ? \"no data\" : fragment.value;\n        }\n        `,\n      ]);\n      validateTs(content, undefined, false, true, [`Duplicate identifier 'DocumentNode'.`], true);\n    });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "can accept list in useFragment",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 734,
                "column": 38
            },
            "line": 734,
            "code": "    it('can accept list in useFragment', async () => {\n      const docPath = path.join(__dirname, 'fixtures/with-fragment.ts');\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              foo: Foo\n              foos: [Foo!]\n            }\n\n            type Foo {\n              value: String\n            }\n          `,\n        ],\n        documents: docPath,\n        generates: {\n          out1: {\n            preset,\n            presetConfig: {\n              fragmentMasking: true,\n            },\n          },\n        },\n      });\n\n      const content = mergeOutputs([\n        ...result,\n        readFileSync(docPath, 'utf8'),\n        `\n        function App(props: { data: FoosQuery }) {\n          const fragments: ReadonlyArray<FooFragment> | null | undefined = useFragment(Fragment, props.data.foos);\n          return fragments == null ? \"no data\" : fragments.map(f => f.value);\n        }\n        `,\n      ]);\n      validateTs(content, undefined, false, true, [`Duplicate identifier 'DocumentNode'.`], true);\n    });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "fragmentMasking.augmentedModuleName",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 774,
                "column": 41
            },
            "line": 774,
            "code": "  it('fragmentMasking.augmentedModuleName', async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n            b: String\n            c: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n      generates: {\n        out1: {\n          preset,\n          presetConfig: {\n            fragmentMasking: {\n              augmentedModuleName: '@urql/fragment',\n            },\n          },\n        },\n      },\n    });\n\n    expect(result).toHaveLength(4);\n    const fragmentMaskingFile = result.find(file => file.filename === 'out1/fragment-masking.d.ts');\n    expect(fragmentMaskingFile).toBeDefined();\n    expect(fragmentMaskingFile.content).toMatchInlineSnapshot(`\n      \"import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n      declare module \"@urql/fragment\" {\n\n        export type FragmentType<TDocumentType extends DocumentNode<any, any>> = TDocumentType extends DocumentNode<\n          infer TType,\n          any\n        >\n          ? TType extends { ' $fragmentName'?: infer TKey }\n            ? TKey extends string\n              ? { ' $fragmentRefs'?: { [key in TKey]: TType } }\n              : never\n            : never\n          : never;\n\n\n        // return non-nullable if \\`fragmentType\\` is non-nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>>\n        ): TType\n        // return nullable if \\`fragmentType\\` is nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>> | null | undefined\n        ): TType | null | undefined\n        // return array of non-nullable if \\`fragmentType\\` is array of non-nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>>\n        ): ReadonlyArray<TType>\n        // return array of nullable if \\`fragmentType\\` is array of nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n        ): ReadonlyArray<TType> | null | undefined\n      }\"\n    `);\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "generates correct named imports for ESM",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 842,
                "column": 45
            },
            "line": 842,
            "code": "  it('generates correct named imports for ESM', async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n            b: String\n            c: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n      generates: {\n        out1: {\n          preset,\n        },\n      },\n      emitLegacyCommonJSImports: false,\n    });\n\n    expect(result).toHaveLength(3);\n    // index.ts (re-exports)\n    const indexFile = result.find(file => file.filename === 'out1/index.ts');\n    expect(indexFile.content).toEqual('export * from \"./gql.js\"');\n\n    // gql.ts\n    const gqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(gqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import * as types from './graphql.js';\n      import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n      /**\n       * Map of all GraphQL operations in the project.\n       *\n       * This map has several performance disadvantages:\n       * 1. It is not tree-shakeable, so it will include all operations in the project.\n       * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.\n       * 3. It does not support dead code elimination, so it will add unused operations.\n       *\n       * Therefore it is highly recommended to use the babel or swc plugin for production.\n       */\n      const documents = {\n          \"\\\\n  query A {\\\\n    a\\\\n  }\\\\n\": types.ADocument,\n          \"\\\\n  query B {\\\\n    b\\\\n  }\\\\n\": types.BDocument,\n          \"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\": types.CFragmentDoc,\n      };\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       *\n       *\n       * @example\n       * \\`\\`\\`ts\n       * const query = gql(\\`query GetUser($id: ID!) { user(id: $id) { name } }\\`);\n       * \\`\\`\\`\n       *\n       * The query argument is unknown!\n       * Please regenerate the types.\n       */\n      export function gql(source: string): unknown;\n\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  query A {\\\\n    a\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  query A {\\\\n    a\\\\n  }\\\\n\"];\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  query B {\\\\n    b\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  query B {\\\\n    b\\\\n  }\\\\n\"];\n      /**\n       * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n       */\n      export function gql(source: \"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\"): (typeof documents)[\"\\\\n  fragment C on Query {\\\\n    c\\\\n  }\\\\n\"];\n\n      export function gql(source: string) {\n        return (documents as any)[source] ?? {};\n      }\n\n      export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;\"\n    `);\n\n    // graphql.ts\n    const graphqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(graphqlFile).toBeDefined();\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "should generate interface field resolvers",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 47
            },
            "line": 51,
            "code": "test('should generate interface field resolvers', () => {\n  const output = buildModule(\n    'test',\n    parse(/* GraphQL */ `\n      interface BaseUser {\n        id: ID!\n        email: String!\n      }\n\n      type User implements BaseUser {\n        id: ID!\n        email: String!\n      }\n\n      type Query {\n        me: BaseUser!\n      }\n    `),\n    {\n      importPath: '../types',\n      importNamespace: 'core',\n      encapsulate: 'none',\n      requireRootResolvers: false,\n      shouldDeclare: false,\n      rootTypes: ROOT_TYPES,\n      baseVisitor,\n      useGraphQLModules: true,\n    }\n  );\n\n  expect(output).toContain(`BaseUser: 'id' | 'email';`);\n  expect(output).toContain(`export type BaseUser = Pick<core.BaseUser, DefinedFields['BaseUser']>;`);\n  expect(output).toContain(`export type BaseUserResolvers = Pick<core.BaseUserResolvers, DefinedFields['BaseUser']>;`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should not generate graphql-modules code when useGraphQLModules=false",
            "suites": [],
            "updatePoint": {
                "line": 86,
                "column": 75
            },
            "line": 86,
            "code": "test('should not generate graphql-modules code when useGraphQLModules=false', () => {\n  const output = buildModule(\n    'test',\n    parse(/* GraphQL */ `\n      interface BaseUser {\n        id: ID!\n        email: String!\n      }\n\n      type User implements BaseUser {\n        id: ID!\n        email: String!\n      }\n\n      type Query {\n        me: BaseUser!\n      }\n    `),\n    {\n      importPath: '../types',\n      importNamespace: 'core',\n      encapsulate: 'none',\n      shouldDeclare: false,\n      rootTypes: ROOT_TYPES,\n      baseVisitor,\n      useGraphQLModules: false,\n      requireRootResolvers: false,\n    }\n  );\n\n  expect(output).not.toContain(`graphql-modules`);\n  expect(output).not.toContain(`gm.`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should generate interface extensions field resolvers ",
            "suites": [],
            "updatePoint": {
                "line": 120,
                "column": 59
            },
            "line": 120,
            "code": "test('should generate interface extensions field resolvers ', () => {\n  const output = buildModule(\n    'test',\n    parse(/* GraphQL */ `\n      extend interface BaseUser {\n        newField: String!\n      }\n\n      type Query {\n        me: BaseUser!\n      }\n    `),\n    {\n      importPath: '../types',\n      importNamespace: 'core',\n      encapsulate: 'none',\n      requireRootResolvers: false,\n      shouldDeclare: false,\n      rootTypes: ROOT_TYPES,\n      baseVisitor,\n      useGraphQLModules: true,\n    }\n  );\n\n  expect(output).toContain(`BaseUser: 'newField';`);\n  expect(output).toContain(`export type BaseUser = core.BaseUser`);\n  expect(output).toContain(`export type BaseUserResolvers = Pick<core.BaseUserResolvers, DefinedFields['BaseUser']>;`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should include import statement",
            "suites": [],
            "updatePoint": {
                "line": 149,
                "column": 37
            },
            "line": 149,
            "code": "test('should include import statement', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    import * as core from \"../types\";\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should include import type statement",
            "suites": [],
            "updatePoint": {
                "line": 166,
                "column": 42
            },
            "line": 166,
            "code": "test('should include import type statement', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n    useTypeImports: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    import type * as core from \"../types\";\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should work with naming conventions",
            "suites": [],
            "updatePoint": {
                "line": 184,
                "column": 41
            },
            "line": 184,
            "code": "test('should work with naming conventions', () => {\n  const output = buildModule('test', parse(`type query_root { test: ID! } schema { query: query_root }`), {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toContain(`Pick<core.Query_RootResolvers, `);\n  expect(output).toContain(`Pick<core.Query_Root,`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "encapsulate: should wrap correctly with namespace",
            "suites": [],
            "updatePoint": {
                "line": 200,
                "column": 55
            },
            "line": 200,
            "code": "test('encapsulate: should wrap correctly with namespace', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'namespace',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`export namespace TestModule {`);\n  expect(output).toMatchSnapshot();\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "encapsulate: should wrap correctly with a declared namespace",
            "suites": [],
            "updatePoint": {
                "line": 216,
                "column": 66
            },
            "line": 216,
            "code": "test('encapsulate: should wrap correctly with a declared namespace', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'namespace',\n    requireRootResolvers: false,\n    shouldDeclare: true,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`declare namespace TestModule {`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "encapsulate: should wrap correctly with prefix",
            "suites": [],
            "updatePoint": {
                "line": 231,
                "column": 52
            },
            "line": 231,
            "code": "test('encapsulate: should wrap correctly with prefix', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'prefix',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toMatchSnapshot();\n  expect(output).toContain(`export type Test_Article`);\n  expect(output).toContain(`export type Test_User`);\n  expect(output).toContain(`export type Test_Scalars`);\n  expect(output).toContain(`export type Test_ArticleResolvers`);\n  expect(output).toContain(`export interface Test_Resolvers`);\n  expect(output).toContain(`export interface Test_MiddlewareMap`);\n  expect(output).toContain(`interface DefinedFields {`);\n  expect(output).toContain(`interface DefinedEnumValues {`);\n  expect(output).toContain(`interface DefinedInputFields {`);\n  expect(output).not.toBeSimilarStringTo(`export namespace Test {`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should pick fields from defined and extended types",
            "suites": [],
            "updatePoint": {
                "line": 256,
                "column": 56
            },
            "line": 256,
            "code": "test('should pick fields from defined and extended types', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    interface DefinedFields {\n      Article: 'id' | 'title' | 'text' | 'author' | 'comments' | 'url';\n      Query: 'articles' | 'articleById' | 'articlesByUser';\n      User: 'articles';\n      Node: 'id';\n    };\n  `);\n\n  expect(output).toBeSimilarStringTo(`\n    interface DefinedEnumValues {\n      UserKind: 'ADMIN' | 'WRITER' | 'REGULAR';\n    };\n  `);\n\n  expect(output).toBeSimilarStringTo(`\n    interface DefinedInputFields {\n      NewArticle: 'title' | 'text';\n    };\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should reexport used types but not defined in module",
            "suites": [],
            "updatePoint": {
                "line": 290,
                "column": 58
            },
            "line": 290,
            "code": "test('should reexport used types but not defined in module', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    export type User = core.User;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type Comment = core.Comment;\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should export partial types, only those defined in module or root types",
            "suites": [],
            "updatePoint": {
                "line": 310,
                "column": 77
            },
            "line": 310,
            "code": "test('should export partial types, only those defined in module or root types', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    export type Article = Pick<core.Article, DefinedFields['Article']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type Query = Pick<core.Query, DefinedFields['Query']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type UserKind = DefinedEnumValues['UserKind'];\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type NewArticle = Pick<core.NewArticle, DefinedInputFields['NewArticle']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type Node = Pick<core.Node, DefinedFields['Node']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type ArticleOrUser = core.ArticleOrUser;\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should export partial types of scalars, only those defined in module or root types",
            "suites": [],
            "updatePoint": {
                "line": 342,
                "column": 88
            },
            "line": 342,
            "code": "test('should export partial types of scalars, only those defined in module or root types', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    export type Scalars = Pick<core.Scalars, 'DateTime' | 'URL'>;\n  `);\n\n  // DateTime type should not be generated\n  expect(output).not.toBeSimilarStringTo(`\n    export type DateTime =\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should use and export resolver signatures of types defined or extended in a module",
            "suites": [],
            "updatePoint": {
                "line": 364,
                "column": 88
            },
            "line": 364,
            "code": "test('should use and export resolver signatures of types defined or extended in a module', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    export type ArticleResolvers = Pick<core.ArticleResolvers, DefinedFields['Article'] | '__isTypeOf'>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type QueryResolvers = Pick<core.QueryResolvers, DefinedFields['Query']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type UserResolvers = Pick<core.UserResolvers, DefinedFields['User']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type DateTimeScalarConfig = core.DateTimeScalarConfig;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type UrlScalarConfig = core.UrlScalarConfig;\n  `);\n  // Interfaces should not have resolvers\n  // We want Object types to have __isTypeOf\n  expect(output).toBeSimilarStringTo(`\n    export type NodeResolvers\n  `);\n  // Unions should not have resolvers\n  // We want Object types to have __isTypeOf\n  expect(output).not.toBeSimilarStringTo(`\n    export type ArticleOrUserResolvers\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should not generate resolver signatures of types that are not defined or extened by a module",
            "suites": [],
            "updatePoint": {
                "line": 403,
                "column": 98
            },
            "line": 403,
            "code": "test('should not generate resolver signatures of types that are not defined or extened by a module', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).not.toContain('CommentResolvers');\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should generate an aggregation of individual resolver signatures",
            "suites": [],
            "updatePoint": {
                "line": 418,
                "column": 70
            },
            "line": 418,
            "code": "test('should generate an aggregation of individual resolver signatures', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    export interface Resolvers {\n      Article?: ArticleResolvers;\n      Query?: QueryResolvers;\n      User?: UserResolvers;\n      DateTime?: core.Resolvers['DateTime'];\n      URL?: core.Resolvers['URL'];\n    };\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should generate a signature for ResolveMiddleware (with widlcards)",
            "suites": [],
            "updatePoint": {
                "line": 441,
                "column": 72
            },
            "line": 441,
            "code": "test('should generate a signature for ResolveMiddleware (with widlcards)', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    requireRootResolvers: false,\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toContain(`import * as gm from \"graphql-modules\";`);\n\n  expect(output).toBeSimilarStringTo(`\n    export interface MiddlewareMap {\n      '*'?: {\n        '*'?: gm.Middleware[];\n      };\n      Article?: {\n        '*'?: gm.Middleware[];\n        id?: gm.Middleware[];\n        title?: gm.Middleware[];\n        text?: gm.Middleware[];\n        author?: gm.Middleware[];\n        comments?: gm.Middleware[];\n        url?: gm.Middleware[];\n      };\n      User?: {\n        '*'?: gm.Middleware[];\n        articles?: gm.Middleware[];\n      };\n      Query?: {\n        '*'?: gm.Middleware[];\n        articles?: gm.Middleware[];\n        articleById?: gm.Middleware[];\n        articlesByUser?: gm.Middleware[];\n      };\n    };\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should generate a base output and 4 for modules",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 35,
                "column": 55
            },
            "line": 35,
            "code": "  test('should generate a base output and 4 for modules', async () => {\n    const output = await executeCodegen(options);\n\n    expect(output.length).toBe(5);\n    expect(normalize(output[0].filename)).toMatch(normalize(`/modules/global-types.ts`));\n    expect(normalize(output[1].filename)).toMatch(normalize(`/modules/blog/module-types.ts`));\n    expect(normalize(output[2].filename)).toMatch(normalize(`/modules/common/module-types.ts`));\n    expect(normalize(output[3].filename)).toMatch(normalize(`/modules/dotanions/module-types.ts`));\n    expect(normalize(output[4].filename)).toMatch(normalize(`/modules/users/module-types.ts`));\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should not duplicate type even if type and extend type are in the same module",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 46,
                "column": 85
            },
            "line": 46,
            "code": "  test('should not duplicate type even if type and extend type are in the same module', async () => {\n    const output = await executeCodegen(options);\n\n    const userResolversStr = `export type UserResolvers = Pick<Types.UserResolvers, DefinedFields['User'] | '__isTypeOf'>;`;\n    const nbOfTimeUserResolverFound = output[4].content.split(userResolversStr).length - 1;\n\n    expect(nbOfTimeUserResolverFound).toBe(1);\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should allow to override importBaseTypesFrom correctly",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 55,
                "column": 62
            },
            "line": 55,
            "code": "  test('should allow to override importBaseTypesFrom correctly', async () => {\n    const output = await executeCodegen({\n      generates: {\n        './tests/test-files/modules': {\n          schema: './tests/test-files/modules/*/types/*.graphql',\n          plugins: ['typescript', 'typescript-resolvers'],\n          preset: 'graphql-modules',\n          presetConfig: {\n            importBaseTypesFrom: '@types',\n            baseTypesPath: 'global-types.ts',\n            filename: 'module-types.ts',\n            encapsulateModuleTypes: 'none',\n          },\n        },\n      },\n    });\n    const importStatement = `import * as Types from \"@types\";`;\n\n    expect(output.length).toBe(5);\n    expect(output[1].content).toMatch(importStatement);\n    expect(output[2].content).toMatch(importStatement);\n    expect(output[3].content).toMatch(importStatement);\n    expect(output[4].content).toMatch(importStatement);\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should import with respect of useTypeImports config correctly",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 80,
                "column": 69
            },
            "line": 80,
            "code": "  test('should import with respect of useTypeImports config correctly', async () => {\n    const output = await executeCodegen({\n      generates: {\n        './tests/test-files/modules': {\n          schema: './tests/test-files/modules/*/types/*.graphql',\n          plugins: ['typescript', 'typescript-resolvers'],\n          preset: 'graphql-modules',\n          presetConfig: {\n            importBaseTypesFrom: '@types',\n            baseTypesPath: 'global-types.ts',\n            filename: 'module-types.ts',\n            encapsulateModuleTypes: 'none',\n          },\n        },\n      },\n      config: {\n        useTypeImports: true,\n      },\n    });\n\n    const importStatement = `import type * as Types from \"@types\";`;\n\n    expect(output.length).toBe(5);\n    expect(output[1].content).toMatch(importStatement);\n    expect(output[2].content).toMatch(importStatement);\n    expect(output[3].content).toMatch(importStatement);\n    expect(output[4].content).toMatch(importStatement);\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should allow to disable graphql-modules",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 109,
                "column": 47
            },
            "line": 109,
            "code": "  test('should allow to disable graphql-modules', async () => {\n    const output = await executeCodegen({\n      generates: {\n        './tests/test-files/modules': {\n          schema: './tests/test-files/modules/*/types/*.graphql',\n          plugins: ['typescript', 'typescript-resolvers'],\n          preset: 'graphql-modules',\n          presetConfig: {\n            importBaseTypesFrom: '@types',\n            baseTypesPath: 'global-types.ts',\n            filename: 'module-types.ts',\n            encapsulateModuleTypes: 'none',\n            useGraphQLModules: false,\n          },\n        },\n      },\n    });\n\n    for (const record of output) {\n      expect(record).not.toContain(`graphql-modules`);\n      expect(record).not.toContain(`gm.`);\n    }\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "each module-types should include a relative import to glob-types module",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 133,
                "column": 79
            },
            "line": 133,
            "code": "  test('each module-types should include a relative import to glob-types module', async () => {\n    const output = await executeCodegen(options);\n    const importStatement = `import * as Types from \"../global-types\";`;\n\n    expect(output.length).toBe(5);\n    expect(output[1].content).toMatch(importStatement);\n    expect(output[2].content).toMatch(importStatement);\n    expect(output[3].content).toMatch(importStatement);\n    expect(output[4].content).toMatch(importStatement);\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "each module-types should export Resolvers",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 144,
                "column": 49
            },
            "line": 144,
            "code": "  test('each module-types should export Resolvers', async () => {\n    const output = await executeCodegen(options);\n    const exportStatemment = `export interface Resolvers `;\n\n    expect(output.length).toBe(5);\n    expect(output[1].content).toMatch(exportStatemment);\n    expect(output[2].content).toMatch(exportStatemment);\n    expect(output[3].content).toMatch(exportStatemment);\n    expect(output[4].content).toMatch(exportStatemment);\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "dotanions module should export DefinedFields, Schema Types with Picks and resolvers",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 155,
                "column": 91
            },
            "line": 155,
            "code": "  test('dotanions module should export DefinedFields, Schema Types with Picks and resolvers', async () => {\n    const output = await executeCodegen(options);\n\n    expect(output.length).toBe(5);\n    expect(output[3].content).toMatchSnapshot();\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should NOT produce required root-level resolvers in Resolvers interface by default",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 162,
                "column": 90
            },
            "line": 162,
            "code": "  test('should NOT produce required root-level resolvers in Resolvers interface by default', async () => {\n    const output = await executeCodegen(options);\n\n    const usersModuleOutput = output.find(o => o.filename.includes('users'))!;\n\n    expect(usersModuleOutput).toBeDefined();\n    expect(usersModuleOutput.content).toContain(\n      `export type QueryResolvers = Pick<Types.QueryResolvers, DefinedFields['Query']>;`\n    );\n    expect(usersModuleOutput.content).toContain('Query?: QueryResolvers;');\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should produce required root-level resolvers in Resolvers interface when requireRootResolvers flag is enabled",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 174,
                "column": 117
            },
            "line": 174,
            "code": "  test('should produce required root-level resolvers in Resolvers interface when requireRootResolvers flag is enabled', async () => {\n    const optionsCopy = Object.assign({} as any, options);\n\n    optionsCopy.generates['./tests/test-files/modules'].presetConfig = {\n      ...optionsCopy.generates['./tests/test-files/modules'].presetConfig,\n      requireRootResolvers: true,\n      useGraphQLModules: false,\n    };\n\n    const output = await executeCodegen(optionsCopy);\n\n    const usersModuleOutput = output.find(o => o.filename.includes('users'))!;\n\n    expect(usersModuleOutput).toBeDefined();\n\n    // Only Query related properties should be required\n    expect(usersModuleOutput.content).toBeSimilarStringTo(`\n      export type UserResolvers = Pick<Types.UserResolvers, DefinedFields['User'] | '__isTypeOf'>;\n      export type QueryResolvers = Required<Pick<Types.QueryResolvers, DefinedFields['Query']>>;\n    `);\n    expect(usersModuleOutput.content).toBeSimilarStringTo(`\n      export interface Resolvers {\n        User?: UserResolvers;\n        Query: QueryResolvers;\n      };\n    `);\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        }
    ],
    "error": "Exclusive tests detected. `.only` call found in resolve-external-module-and-fn.spec.ts:4\nRemove `.only` to restore test checks"
}