{"repo":"highlightjs/highlight.js","url":"https://github.com/highlightjs/highlight.js","branch":"main","configs":[{"package":"highlight.js","lang":"js","dir":"test","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should get an existing language","suites":[".autoDetection()"],"updatePoint":{"line":8,"column":37},"line":8,"code":"  it('should get an existing language', () => {\n    const result = hljs.autoDetection('python');\n    result.should.be.instanceOf(Object);\n  });","file":"api/autoDetection.js","skipped":false,"dir":"test"},{"name":"should get an existing language by alias","suites":[".autoDetection()"],"updatePoint":{"line":12,"column":46},"line":12,"code":"  it('should get an existing language by alias', () => {\n    const result = hljs.autoDetection('py');\n    result.should.be.instanceOf(Object);\n  });","file":"api/autoDetection.js","skipped":false,"dir":"test"},{"name":"should be case insensitive","suites":[".autoDetection()"],"updatePoint":{"line":16,"column":32},"line":16,"code":"  it('should be case insensitive', () => {\n    const result = hljs.autoDetection('pYTHOn');\n    result.should.be.instanceOf(Object);\n  });","file":"api/autoDetection.js","skipped":false,"dir":"test"},{"name":"should return undefined","suites":[".autoDetection()"],"updatePoint":{"line":20,"column":29},"line":20,"code":"  it('should return undefined', () => {\n    const result = hljs.autoDetection('-impossible-');\n    should.strictEqual(result, undefined);\n  });","file":"api/autoDetection.js","skipped":false,"dir":"test"},{"name":"should not break on undefined","suites":[".autoDetection()"],"updatePoint":{"line":24,"column":35},"line":24,"code":"  it('should not break on undefined', () => {\n    const result = hljs.autoDetection(undefined);\n    should.strictEqual(result, undefined);\n  });","file":"api/autoDetection.js","skipped":false,"dir":"test"},{"name":"should allow subsequence matches to still succeed","suites":["beginKeywords"],"updatePoint":{"line":29,"column":55},"line":29,"code":"  it(\"should allow subsequence matches to still succeed\", () => {\n    let content = \"A.class = self\";\n    let res = hljs.highlight(content, {\n      language: \"has-followup\"\n    });\n    res.value.should.equal('A.<span class=\"hljs-found\">class</span> = self');\n  });","file":"api/beginKeywords.js","skipped":false,"dir":"test"},{"name":"should ignore a preceeding .","suites":["beginKeywords"],"updatePoint":{"line":36,"column":34},"line":36,"code":"  it(\"should ignore a preceeding .\", () => {\n    let content = \"A.class = self\";\n    let res = hljs.highlight(content, {\n      language: \"test\"\n    });\n    res.value.should.equal('A.class = self');\n  });","file":"api/beginKeywords.js","skipped":false,"dir":"test"},{"name":"should ignore a trailing .","suites":["beginKeywords"],"updatePoint":{"line":43,"column":32},"line":43,"code":"  it(\"should ignore a trailing .\", () => {\n    let content = \"class.config = true\";\n    let res = hljs.highlight(content, {\n      language: \"test\"\n    });\n    res.value.should.equal('class.config = true');\n  });","file":"api/beginKeywords.js","skipped":false,"dir":"test"},{"name":"should detect keywords","suites":["beginKeywords"],"updatePoint":{"line":50,"column":28},"line":50,"code":"  it('should detect keywords', () => {\n    let content = \"I have a class yes I do.\";\n    let res = hljs.highlight(content, {\n      language: \"test\"\n    });\n    res.value.should.equal('I have a <span class=\"hljs-keyword\">class</span> yes I do.');\n  });","file":"api/beginKeywords.js","skipped":false,"dir":"test"},{"name":"should match binary numbers","suites":[".BINARY_NUMBER_RE"],"updatePoint":{"line":7,"column":33},"line":7,"code":"  it('should match binary numbers', () => {\n    const numbers = ['0b0101', '0b1100', '0b1001', '0b11110101', '0b11001111', '0b1010111111000001'];\n    numbers.should.matchEach(pattern);\n  });","file":"api/binaryNumber.js","skipped":false,"dir":"test"},{"name":"should not match binary numbers greater than 2","suites":[".BINARY_NUMBER_RE"],"updatePoint":{"line":11,"column":52},"line":11,"code":"  it('should not match binary numbers greater than 2', () => {\n    const numbers = ['0b2101', '0b1130', '0b1041', '0b11150101', '0b11061111', '0b1010111117000001'];\n    numbers.should.not.matchEach(pattern);\n  });","file":"api/binaryNumber.js","skipped":false,"dir":"test"},{"name":"should match regular numbers","suites":[".C_NUMBER_RE"],"updatePoint":{"line":9,"column":34},"line":9,"code":"  it('should match regular numbers', () => {\n    const numbers = _.range(0, 1001).map(x => x.toString());\n\n    numbers.should.matchEach(pattern);\n  });","file":"api/cNumber.js","skipped":false,"dir":"test"},{"name":"should match decimals","suites":[".C_NUMBER_RE"],"updatePoint":{"line":14,"column":27},"line":14,"code":"  it('should match decimals', () => {\n    const decimal = _.range(0, 1.001, 0.001).map(x => x.toString());\n\n    const noLeadingZero = ['.1234', '.5206', '.0002', '.9998'];\n    const numbers = [].concat(decimal, noLeadingZero);\n    numbers.should.matchEach(pattern);\n  });","file":"api/cNumber.js","skipped":false,"dir":"test"},{"name":"should match hex numbers","suites":[".C_NUMBER_RE"],"updatePoint":{"line":21,"column":30},"line":21,"code":"  it('should match hex numbers', () => {\n    const numbers = ['0xbada55', '0xfa1755', '0x45362e', '0xfedcba', '0x123456', '0x00000f', '0xfff000', '0xf0e1d2'];\n    numbers.should.matchEach(pattern);\n  });","file":"api/cNumber.js","skipped":false,"dir":"test"},{"name":"should not match hex numbers greater than \"f\"","suites":[".C_NUMBER_RE"],"updatePoint":{"line":25,"column":51},"line":25,"code":"  it('should not match hex numbers greater than \"f\"', () => {\n    const numbers = ['0xgada55', '0xfh1755', '0x45i62e'];\n    numbers.should.not.matchEach(pattern);\n  });","file":"api/cNumber.js","skipped":false,"dir":"test"},{"name":"should not match binary numbers","suites":[".C_NUMBER_RE"],"updatePoint":{"line":29,"column":37},"line":29,"code":"  it('should not match binary numbers', () => {\n    const numbers = ['0b0101', '0b1100', '0b1001'];\n    numbers.should.not.matchEach(pattern);\n  });","file":"api/cNumber.js","skipped":false,"dir":"test"},{"name":"should get an existing language","suites":[".getLanguage()"],"updatePoint":{"line":8,"column":37},"line":8,"code":"  it('should get an existing language', () => {\n    const result = hljs.getLanguage('python');\n    result.should.be.instanceOf(Object);\n  });","file":"api/getLanguage.js","skipped":false,"dir":"test"},{"name":"should get an existing language by alias","suites":[".getLanguage()"],"updatePoint":{"line":12,"column":46},"line":12,"code":"  it('should get an existing language by alias', () => {\n    const result = hljs.getLanguage('py');\n    result.should.be.instanceOf(Object);\n  });","file":"api/getLanguage.js","skipped":false,"dir":"test"},{"name":"should be case insensitive","suites":[".getLanguage()"],"updatePoint":{"line":16,"column":32},"line":16,"code":"  it('should be case insensitive', () => {\n    const result = hljs.getLanguage('pYTHOn');\n    result.should.be.instanceOf(Object);\n  });","file":"api/getLanguage.js","skipped":false,"dir":"test"},{"name":"should return undefined","suites":[".getLanguage()"],"updatePoint":{"line":20,"column":29},"line":20,"code":"  it('should return undefined', () => {\n    const result = hljs.getLanguage('-impossible-');\n    should.strictEqual(result, undefined);\n  });","file":"api/getLanguage.js","skipped":false,"dir":"test"},{"name":"should not break on undefined","suites":[".getLanguage()"],"updatePoint":{"line":24,"column":35},"line":24,"code":"  it('should not break on undefined', () => {\n    const result = hljs.getLanguage(undefined);\n    should.strictEqual(result, undefined);\n  });","file":"api/getLanguage.js","skipped":false,"dir":"test"},{"name":"should get the csharp language by c# alias","suites":[".getLanguage()"],"updatePoint":{"line":28,"column":48},"line":28,"code":"  it('should get the csharp language by c# alias', () => {\n    const result = hljs.getLanguage('c#');\n    result.should.be.instanceOf(Object);\n    result.should.have.property('aliases').with.containEql('cs');\n    should.strictEqual(result, hljs.getLanguage('csharp'));\n  });","file":"api/getLanguage.js","skipped":false,"dir":"test"},{"name":"should not succeed for constructor","suites":[".getLanguage()"],"updatePoint":{"line":34,"column":40},"line":34,"code":"  it('should not succeed for constructor', () => {\n    const result = hljs.getLanguage('constructor');\n    should.strictEqual(result, undefined);\n  });","file":"api/getLanguage.js","skipped":false,"dir":"test"},{"name":"should not succeed for __proto__","suites":[".getLanguage()"],"updatePoint":{"line":38,"column":38},"line":38,"code":"  it('should not succeed for __proto__', () => {\n    const result = hljs.getLanguage('__proto__');\n    should.strictEqual(result, undefined);\n  });","file":"api/getLanguage.js","skipped":false,"dir":"test"},{"name":"should support ignoreIllegals (old API)","suites":[".highlight()"],"updatePoint":{"line":8,"column":45},"line":8,"code":"  it('should support ignoreIllegals (old API)', () => {\n    let code = \"float # float\";\n    let result = hljs.highlight(\"java\", code, true);\n    result.value.should.equal(`<span class=\"hljs-type\">float</span> # <span class=\"hljs-type\">float</span>`);\n    code = \"float # float\";\n    result = hljs.highlight(\"java\", code, false);\n    result.value.should.equal(\"float # float\");\n    result.illegal.should.equal(true);\n  });","file":"api/highlight.js","skipped":false,"dir":"test"},{"name":"should support ignoreIllegals (new API)","suites":[".highlight()"],"updatePoint":{"line":17,"column":45},"line":17,"code":"  it('should support ignoreIllegals (new API)', () => {\n    let code = \"float # float\";\n    let result = hljs.highlight(code, {\n      language: \"java\",\n      ignoreIllegals: true\n    });\n    result.value.should.equal(`<span class=\"hljs-type\">float</span> # <span class=\"hljs-type\">float</span>`);\n    code = \"float # float\";\n    result = hljs.highlight(code, {\n      language: \"java\",\n      ignoreIllegals: false\n    });\n    result.value.should.equal(\"float # float\");\n    result.illegal.should.equal(true); // defaults to true\n\n    code = \"float # float\";\n    result = hljs.highlight(code, {\n      language: \"java\"\n    });\n    result.value.should.equal(`<span class=\"hljs-type\">float</span> # <span class=\"hljs-type\">float</span>`);\n    result.illegal.should.equal(false);\n  });","file":"api/highlight.js","skipped":false,"dir":"test"},{"name":"should use new API with options","suites":[".highlight()"],"updatePoint":{"line":39,"column":37},"line":39,"code":"  it('should use new API with options', () => {\n    const code = \"public void moveTo(int x, int y, int z);\";\n    const result = hljs.highlight(code, {\n      language: \"java\"\n    });\n    result.value.should.equal('<span class=\"hljs-keyword\">public</span> ' + '<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">moveTo</span>' + '<span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, ' + '<span class=\"hljs-type\">int</span> y, ' + '<span class=\"hljs-type\">int</span> z)</span>;');\n  });","file":"api/highlight.js","skipped":false,"dir":"test"},{"name":"should works without continuation","suites":[".highlight()"],"updatePoint":{"line":46,"column":39},"line":46,"code":"  it('should works without continuation', () => {\n    const code = \"public void moveTo(int x, int y, int z);\";\n    const result = hljs.highlight(code, {\n      language: 'java'\n    });\n    result.value.should.equal('<span class=\"hljs-keyword\">public</span> ' + '<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">moveTo</span>' + '<span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, ' + '<span class=\"hljs-type\">int</span> y, ' + '<span class=\"hljs-type\">int</span> z)</span>;');\n  });","file":"api/highlight.js","skipped":false,"dir":"test"},{"name":"should match non-underscore starting words","suites":[".IDENT_RE"],"updatePoint":{"line":7,"column":48},"line":7,"code":"  it('should match non-underscore starting words', () => {\n    const words = ['foo', 'bar', 'baz', 'Foo', 'Bar', 'Baz', 'f_oo', 'ba_r', 'baz_', 'F_oo', 'Ba_r', 'Baz_'];\n    words.should.matchEach(pattern);\n  });","file":"api/ident.js","skipped":false,"dir":"test"},{"name":"should not match underscore starting words","suites":[".IDENT_RE"],"updatePoint":{"line":11,"column":48},"line":11,"code":"  it('should not match underscore starting words', () => {\n    const words = ['_foo', '_bar', '_baz', '_Foo', '_Bar', '_Baz', '_f_oo', '_ba_r', '_baz_', '_F_oo', '_Ba_r', '_Baz_'];\n    words.should.not.matchEach(pattern);\n  });","file":"api/ident.js","skipped":false,"dir":"test"},{"name":"should ignore common keywords","suites":["computing the relevance score of a language"],"updatePoint":{"line":6,"column":35},"line":6,"code":"  it('should ignore common keywords', () => {\n    const grammar = function () {\n      return {\n        keywords: \"farmer river weeds\" + \" and of\" // keywords that happen to also be common\n\n      };\n    };\n\n    const code = \"farmer and of river weeds\";\n    hljs.registerLanguage(\"test\", grammar);\n    const result = hljs.highlight(code, {\n      language: 'test'\n    });\n    result.relevance.should.equal(3);\n  });","file":"api/keywords.js","skipped":false,"dir":"test"},{"name":"should not ignore weighted common keywords","suites":["computing the relevance score of a language"],"updatePoint":{"line":21,"column":48},"line":21,"code":"  it('should not ignore weighted common keywords', () => {\n    const grammar = function () {\n      return {\n        keywords: \"farmer river weeds\" + \" and of|10\" // keywords that happen to also be common\n\n      };\n    };\n\n    const code = \"farmer and of river weeds\";\n    hljs.registerLanguage(\"test\", grammar);\n    const result = hljs.highlight(code, {\n      language: 'test'\n    });\n    result.relevance.should.equal(13);\n  });","file":"api/keywords.js","skipped":false,"dir":"test"},{"name":"should not ignore weighted common keywords (if 1 is forced)","suites":["computing the relevance score of a language"],"updatePoint":{"line":36,"column":65},"line":36,"code":"  it('should not ignore weighted common keywords (if 1 is forced)', () => {\n    const grammar = function () {\n      return {\n        keywords: \"farmer river weeds\" + \" and of|1\" // keywords that happen to also be common\n\n      };\n    };\n\n    const code = \"farmer and of river weeds\";\n    hljs.registerLanguage(\"test\", grammar);\n    const result = hljs.highlight(code, {\n      language: 'test'\n    });\n    result.relevance.should.equal(4);\n  });","file":"api/keywords.js","skipped":false,"dir":"test"},{"name":"should support begin","suites":["multi-class matchers"],"updatePoint":{"line":47,"column":26},"line":47,"code":"  it('should support begin', () => {\n    const code = \"abcdef\";\n    const result = hljs.highlight(code, {\n      language: 'test'\n    });\n    result.value.should.equal(`<span class=\"hljs-a\">a</span>b<span class=\"hljs-c\">c</span><span class=\"hljs-def\">def</span>`);\n    result.relevance.should.equal(2);\n  });","file":"api/multiClassMatch.js","skipped":false,"dir":"test"},{"name":"basic functionality","suites":["multi-class matchers"],"updatePoint":{"line":55,"column":25},"line":55,"code":"  it('basic functionality', () => {\n    const code = \"func(){ test }\";\n    const result = hljs.highlight(code, {\n      language: 'test'\n    });\n    result.value.should.equal(`<span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span><span class=\"hljs-body\">{ test }</span>`);\n    result.relevance.should.equal(1);\n  });","file":"api/multiClassMatch.js","skipped":false,"dir":"test"},{"name":"works inside a classified parent mode","suites":["multi-class matchers"],"updatePoint":{"line":63,"column":43},"line":63,"code":"  it('works inside a classified parent mode', () => {\n    const code = \"^^^what abc now^^^\";\n    const result = hljs.highlight(code, {\n      language: 'test'\n    });\n    result.value.should.equal(`<span class=\"hljs-carrot\">^^^what ` + `<span class=\"hljs-a\">a</span>b<span class=\"hljs-c\">c</span>` + ` now^^^</span>`);\n  });","file":"api/multiClassMatch.js","skipped":false,"dir":"test"},{"name":"should match regular numbers and decimals","suites":[".NUMBER_RE"],"updatePoint":{"line":9,"column":47},"line":9,"code":"  it('should match regular numbers and decimals', () => {\n    const number = _.range(0, 1001).map(x => x.toString());\n\n    const decimal = _.range(0, 1.001, 0.001).map(x => x.toString());\n\n    const noLeadingZero = ['.1234', '.5206', '.0002', '.9998'];\n    const numbers = [].concat(number, decimal, noLeadingZero);\n    numbers.should.matchEach(pattern);\n  });","file":"api/number.js","skipped":false,"dir":"test"},{"name":"should not match hex or binary numbers","suites":[".NUMBER_RE"],"updatePoint":{"line":18,"column":44},"line":18,"code":"  it('should not match hex or binary numbers', () => {\n    const numbers = ['0xbada55', '0xfa1755', '0x45362e', '0b0101', '0b1100', '0b1001'];\n    numbers.should.not.matchEach(pattern);\n  });","file":"api/number.js","skipped":false,"dir":"test"},{"name":"should get an existing language by alias","suites":[".registerAliases()"],"updatePoint":{"line":8,"column":46},"line":8,"code":"  it('should get an existing language by alias', () => {\n    hljs.registerAliases('jquery', {\n      languageName: 'javascript'\n    });\n    const result = hljs.getLanguage('jquery');\n    result.should.be.instanceOf(Object);\n  });","file":"api/registerAlias.js","skipped":false,"dir":"test"},{"name":"should get an existing language by aliases","suites":[".registerAliases()"],"updatePoint":{"line":15,"column":48},"line":15,"code":"  it('should get an existing language by aliases', () => {\n    hljs.registerAliases(['jquery', 'jqueryui'], {\n      languageName: 'javascript'\n    });\n    const result = hljs.getLanguage('jquery');\n    result.should.be.instanceOf(Object);\n  });","file":"api/registerAlias.js","skipped":false,"dir":"test"},{"name":"should match boolean operators","suites":[".RE_STARTERS_RE"],"updatePoint":{"line":7,"column":36},"line":7,"code":"  it('should match boolean operators', () => {\n    const operators = ['!', '!=', '!==', '==', '===', '<=', '>=', '<', '>', '||', '&&', '?'];\n    operators.should.matchEach(pattern);\n  });","file":"api/starters.js","skipped":false,"dir":"test"},{"name":"should match arithmetic operators","suites":[".RE_STARTERS_RE"],"updatePoint":{"line":11,"column":39},"line":11,"code":"  it('should match arithmetic operators', () => {\n    const operators = ['*', '*=', '+', '+=', '-', '-=', '/', '/=', '%', '%='];\n    operators.should.matchEach(pattern);\n  });","file":"api/starters.js","skipped":false,"dir":"test"},{"name":"should match binary operators","suites":[".RE_STARTERS_RE"],"updatePoint":{"line":15,"column":35},"line":15,"code":"  it('should match binary operators', () => {\n    const operators = ['&', '&=', '|', '|=', '<<', '<<=', '>>', '>>=', '>>>', '>>>=', '^', '^=', '~'];\n    operators.should.matchEach(pattern);\n  });","file":"api/starters.js","skipped":false,"dir":"test"},{"name":"should match miscellaneous operators","suites":[".RE_STARTERS_RE"],"updatePoint":{"line":19,"column":42},"line":19,"code":"  it('should match miscellaneous operators', () => {\n    const operators = [',', '=', ':', ';', '[', '{', '('];\n    operators.should.matchEach(pattern);\n  });","file":"api/starters.js","skipped":false,"dir":"test"},{"name":"should match any word starting without numbers","suites":[".UNDERSCORE_IDENT_RE"],"updatePoint":{"line":7,"column":52},"line":7,"code":"  it('should match any word starting without numbers', () => {\n    const words = ['foo', 'bar', 'baz', 'Foo', 'Bar', 'Baz', '_foo', '_bar', '_baz', '_Foo', '_Bar', '_Baz', '_f_oo', '_ba_r', '_baz_', '_F_oo', '_Ba_r', '_Baz_'];\n    words.should.matchEach(pattern);\n  });","file":"api/underscoreIdent.js","skipped":false,"dir":"test"},{"name":"should not match any word starting with numbers","suites":[".UNDERSCORE_IDENT_RE"],"updatePoint":{"line":11,"column":53},"line":11,"code":"  it('should not match any word starting with numbers', () => {\n    const words = ['1foo', '6bar', '0baz', '2Foo', '7Bar', '1Baz', '3f_oo', '8ba_r', '2baz_', '4F_oo', '9Ba_r', '3Baz_'];\n    words.should.not.matchEach(pattern);\n  });","file":"api/underscoreIdent.js","skipped":false,"dir":"test"},{"name":"should remove an existing language","suites":[".unregisterLanguage()"],"updatePoint":{"line":18,"column":40},"line":18,"code":"  it(\"should remove an existing language\", () => {\n    hljs.unregisterLanguage(\"test\");\n    const result = hljs.getLanguage(\"test\");\n    should(result).be.undefined();\n  });","file":"api/unregisterLanguage.js","skipped":false,"dir":"test"},{"name":"should remove an existing language and its aliases","suites":[".unregisterLanguage()"],"updatePoint":{"line":23,"column":56},"line":23,"code":"  it(\"should remove an existing language and its aliases\", () => {\n    hljs.registerAliases([\"jquery\", \"jqueryui\"], {\n      languageName: \"test\"\n    });\n    {\n      const result = hljs.getLanguage(\"jquery\");\n      should(result.name).equal(\"jQuery\");\n    }\n    hljs.unregisterLanguage(\"test\");\n    {\n      const result = hljs.getLanguage(\"jquery\");\n      should(result).be.undefined();\n    }\n  });","file":"api/unregisterLanguage.js","skipped":false,"dir":"test"},{"name":"is upgraded to new API automatically","suites":["old highlightBlock plugin"],"updatePoint":{"line":42,"column":42},"line":42,"code":"  it(\"is upgraded to new API automatically\", async function () {\n    // we need a stub testcase juts for buildFakeDOM to work\n    const testCase = newTestCase({\n      html: \"\"\n    });\n    await buildFakeDOM.bind(this)(testCase);\n    const old = new OldPlugin();\n    should(old[\"after:highlightElement\"]).be.undefined();\n    should(old[\"before:highlightElement\"]).be.undefined();\n    this.hljs.addPlugin(old);\n    should(old[\"after:highlightElement\"]).not.be.undefined();\n    should(old[\"before:highlightElement\"]).not.be.undefined();\n  });","file":"browser/highlight_block_callbacks.js","skipped":false,"dir":"test"},{"name":"supports class based plugins","suites":["callback system"],"updatePoint":{"line":57,"column":34},"line":57,"code":"  it(\"supports class based plugins\", async function () {\n    const testCase = newTestCase({\n      code: \"var b\",\n      language: \"javascript\",\n      expect: `<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">5</span>;`\n    });\n    await buildFakeDOM.bind(this)(testCase);\n    this.hljs.addPlugin(new ContentAdder({\n      content: \" = 5;\"\n    }));\n    this.hljs.highlightElement(this.block);\n    const actual = this.block.innerHTML;\n    actual.should.equal(testCase.expect);\n  });","file":"browser/highlight_block_callbacks.js","skipped":false,"dir":"test"},{"name":"is called","suites":["before:highlightElement"],"updatePoint":{"line":73,"column":15},"line":73,"code":"  it('is called', async function () {\n    await buildFakeDOM.bind(this)(defaultCase);\n    var called = false;\n    this.hljs.addPlugin({\n      'before:highlightElement': ({\n        el,\n        result\n      }) => {\n        called = true;\n      }\n    });\n    this.hljs.highlightElement(this.block);\n    called.should.equal(true);\n  });","file":"browser/highlight_block_callbacks.js","skipped":false,"dir":"test"},{"name":"can modify block content before highlight","suites":["before:highlightElement"],"updatePoint":{"line":87,"column":47},"line":87,"code":"  it('can modify block content before highlight', async function () {\n    const testCase = newTestCase({\n      code: \"This is the original content.\",\n      language: \"javascript\"\n    });\n    await buildFakeDOM.bind(this)(testCase);\n    this.hljs.addPlugin({\n      'before:highlightElement': ({\n        el,\n        language\n      }) => {\n        language.should.equal(\"javascript\");\n        el.innerHTML = \"var a;\";\n      }\n    });\n    this.hljs.highlightElement(this.block);\n    const actual = this.block.innerHTML;\n    actual.should.equal(`<span class=\"hljs-keyword\">var</span> a;`);\n  });","file":"browser/highlight_block_callbacks.js","skipped":false,"dir":"test"},{"name":"is called","suites":["after:highlightElement"],"updatePoint":{"line":108,"column":15},"line":108,"code":"  it('is called', async function () {\n    await buildFakeDOM.bind(this)(defaultCase);\n    var called = false;\n    this.hljs.addPlugin({\n      'after:highlightElement': ({\n        el,\n        result\n      }) => {\n        called = true;\n      }\n    });\n    this.hljs.highlightElement(this.block);\n    called.should.equal(true);\n  });","file":"browser/highlight_block_callbacks.js","skipped":false,"dir":"test"},{"name":"receives result data","suites":["after:highlightElement"],"updatePoint":{"line":122,"column":26},"line":122,"code":"  it('receives result data', async function () {\n    await buildFakeDOM.bind(this)(defaultCase);\n    this.hljs.addPlugin({\n      'after:highlightElement': ({\n        el,\n        result\n      }) => {\n        result.language.should.equal(\"javascript\");\n        result.relevance.should.above(0);\n      }\n    });\n    this.hljs.highlightElement(this.block);\n  });","file":"browser/highlight_block_callbacks.js","skipped":false,"dir":"test"},{"name":"can override language if not originally provided (in class)","suites":["after:highlightElement"],"updatePoint":{"line":135,"column":65},"line":135,"code":"  it('can override language if not originally provided (in class)', async function () {\n    var test = newTestCase({\n      code: \"anothingstring\",\n      language: \"java\"\n    });\n    await buildFakeDOM.bind(this)(test);\n    this.hljs.addPlugin({\n      'after:highlightElement': ({\n        el,\n        result\n      }) => {\n        // scan class list and remove other languages\n        el.classList.remove(\"language-java\");\n        el.classList.add(\"language-basic\");\n      }\n    });\n    this.hljs.highlightElement(this.block);\n    should(this.block.className).equal(`hljs language-basic`);\n  });","file":"browser/highlight_block_callbacks.js","skipped":false,"dir":"test"},{"name":"can modify element after render","suites":["after:highlightElement"],"updatePoint":{"line":154,"column":37},"line":154,"code":"  it('can modify element after render', async function () {\n    var test = newTestCase({\n      code: \"var a = 4;\",\n      language: \"javascript\"\n    });\n    await buildFakeDOM.bind(this)(test);\n    this.hljs.addPlugin({\n      'after:highlightElement': ({\n        el,\n        result\n      }) => {\n        el.innerHTML = \"redacted\";\n      }\n    });\n    this.hljs.highlightElement(this.block);\n    this.block.outerHTML.should.equal(`<code class=\"language-javascript hljs\">redacted</code>`);\n  });","file":"browser/highlight_block_callbacks.js","skipped":false,"dir":"test"},{"name":"should return relevance key","suites":["plain browser"],"updatePoint":{"line":10,"column":33},"line":10,"code":"  it('should return relevance key', async function () {\n    await buildFakeDOM.bind(this, defaultCase)();\n    var out = this.hljs.highlight(\"\", {\n      language: \"javascript\"\n    });\n    out.relevance.should.equal(0);\n  });","file":"browser/plain.js","skipped":false,"dir":"test"},{"name":"should highlight block","suites":["plain browser"],"updatePoint":{"line":17,"column":28},"line":17,"code":"  it('should highlight block', defaultCase.runner);","file":"browser/plain.js","skipped":false,"dir":"test"},{"name":"should highlight text","suites":["web worker"],"updatePoint":{"line":33,"column":27},"line":33,"code":"  it('should highlight text', function (done) {\n    this.worker.onmessage = event => {\n      const actual = event.data; // the &quot; will be encoded since it's not being\n      // filtered by the browsers innerHTML implementation\n\n      const expect = '<span class=\"hljs-keyword\">' + 'var</span> say = <span class=\"hljs-string\">' + '&quot;Hello&quot;</span>;';\n      actual.should.equal(expect);\n      done();\n    };\n\n    this.worker.postMessage(defaultCase.code);\n  });","file":"browser/worker.js","skipped":false,"dir":"test"},{"name":"should be detected as ","suites":[],"updatePoint":{"line":24,"column":39},"line":24,"code":"  it(`should be detected as ${language}`, async () => {\n    const dir = await fs.stat(languagePath);\n    dir.isDirectory().should.be.true();\n    const filenames = await fs.readdir(languagePath);\n    await Promise.all(filenames.map(async function (example) {\n      const filename = path.join(languagePath, example);\n      const content = await fs.readFile(filename, 'utf-8');\n      const detectedLanguage = hljs.highlightAuto(content).language;\n      detectedLanguage.should.equal(language, `${path.basename(filename)} should be detected as ${language}, but was ${detectedLanguage}`);\n    }));\n  });","file":"detect/index.js","skipped":false,"dir":"test"},{"name":"compiling the grammars","suites":["hljs.highlightAuto()","hljs.highlightAuto()"],"updatePoint":{"line":60,"column":28},"line":60,"code":"  it(\"compiling the grammars\", async function () {\n    const languages = hljs.listLanguages();\n    languages.forEach(lang => hljs.highlight(\"\", {\n      language: lang\n    }));\n  }); // this is also required for the dynamic test generation above to work","file":"detect/index.js","skipped":false,"dir":"test"},{"name":"should markup ","suites":[],"updatePoint":{"line":29,"column":35},"line":29,"code":"      it(`should markup ${testName}`, function (done) {\n        const sourceFile = fs.readFile(sourceName, 'utf-8');\n        const expectedFile = fs.readFile(filename, 'utf-8');\n        Promise.all([sourceFile, expectedFile]).then(function ([source, expected]) {\n          const actual = hljs.highlight(source, {\n            language\n          }).value; // Uncomment this for major changes that rewrite the test expectations\n          // which will then need to be manually compared by hand of course\n          // require('fs').writeFileSync(filename, actual);\n\n          actual.trim().should.equal(expected.trim());\n          done();\n        }).catch(function (err) {\n          return done(err);\n        });\n      });","file":"markup/index.js","skipped":false,"dir":"test"},{"name":"adding dynamic tests...","suites":["highlight() markup"],"updatePoint":{"line":72,"column":29},"line":72,"code":"  it(\"adding dynamic tests...\", async function () {}); // this is required to work","file":"markup/index.js","skipped":false,"dir":"test"},{"name":"should support multi-class","suites":["beginScope and endScope"],"updatePoint":{"line":45,"column":32},"line":45,"code":"  it('should support multi-class', () => {\n    const code = \"123 abcd\";\n    const result = hljs.highlight(code, {\n      language: 'test'\n    });\n    result.value.should.equal(`123 <span class=\"hljs-apple\">a</span><span class=\"hljs-boy\">b</span>c<span class=\"hljs-delta\">d</span>`);\n  });","file":"parser/beginEndScope.js","skipped":false,"dir":"test"},{"name":"should support an outer scope wrapper","suites":["beginScope and endScope"],"updatePoint":{"line":52,"column":43},"line":52,"code":"  it('should support an outer scope wrapper', () => {\n    const code = \"xyz me 123\";\n    const result = hljs.highlight(code, {\n      language: 'test'\n    });\n    result.value.should.equal(`<span class=\"hljs-string\">` + `<span class=\"hljs-red\">xyz</span> me <span class=\"hljs-green\">123</span>` + `</span>`);\n  });","file":"parser/beginEndScope.js","skipped":false,"dir":"test"},{"name":"should support textual beginScope & endScope pair","suites":["beginScope and endScope"],"updatePoint":{"line":59,"column":55},"line":59,"code":"  it('should support textual beginScope & endScope pair', () => {\n    const code = \"dumb really luck\";\n    const result = hljs.highlight(code, {\n      language: 'test'\n    });\n    result.value.should.equal(`<span class=\"hljs-red\">dumb</span> really <span class=\"hljs-green\">luck</span>`);\n  });","file":"parser/beginEndScope.js","skipped":false,"dir":"test"},{"name":"should support textual beginScope","suites":["beginScope and endScope"],"updatePoint":{"line":66,"column":39},"line":66,"code":"  it('should support textual beginScope', () => {\n    const code = \"abcdef\";\n    const result = hljs.highlight(code, {\n      language: 'test'\n    });\n    result.value.should.equal(`<span class=\"hljs-letters\">abc</span><span class=\"hljs-more\">def</span>`);\n  });","file":"parser/beginEndScope.js","skipped":false,"dir":"test"},{"name":"before:compileEarly is executed","suites":["compiler extension plugins","triggered using a plugin"],"updatePoint":{"line":40,"column":39},"line":40,"code":"    it(\"before:compileEarly is executed\", function () {\n      this.first.begin.should.equal(\"booger\");\n    });","file":"parser/compiler-extensions.js","skipped":true,"dir":"test"},{"name":"before:compileLate is executed","suites":["compiler extension plugins","triggered using a plugin"],"updatePoint":{"line":43,"column":38},"line":43,"code":"    it(\"before:compileLate is executed\", function () {\n      this.second.begin.should.equal(\"booger\");\n    });","file":"parser/compiler-extensions.js","skipped":true,"dir":"test"},{"name":"should run early extensions first, then late","suites":["compiler extension plugins","triggered using a plugin"],"updatePoint":{"line":46,"column":52},"line":46,"code":"    it(\"should run early extensions first, then late\", function () {\n      // early rule changes apple to orange\n      // late rule change orange to lime\n      this.first.lime.should.equal(true);\n    });","file":"parser/compiler-extensions.js","skipped":true,"dir":"test"},{"name":"should match successfully","suites":["parser specifics","a grammar with look-ahead end matchers"],"updatePoint":{"line":6,"column":33},"line":6,"code":"    it(\"should match successfully\", () => {\n      hljs.registerLanguage('test-language', hljs => {\n        // broken regex from old Fortran ruleset\n        const PATTERN = {\n          className: \"pattern\",\n          begin: '[A-Z]{3}',\n          // followed by at least one space\n          end: '\\\\d{3}(?=\\\\s+)'\n        };\n        return {\n          contains: [PATTERN]\n        };\n      });\n      hljs.highlight('ABC123 is the secret. XYZ123. End of string: ABC123', {\n        language: 'test-language'\n      }).value.should.equal( // one full match at beginning, other match begins with XYZ but then never terminates,\n      // so the end of the parsing finally closes the span tag\n      '<span class=\"hljs-pattern\">ABC123</span> is the secret. <span class=\"hljs-pattern\">XYZ123. End of string: ABC123</span>');\n    });","file":"parser/look-ahead-end-matchers.js","skipped":false,"dir":"test"},{"name":"should count a keyword 7 times for relevance, no more","suites":["max keyword hits"],"updatePoint":{"line":4,"column":59},"line":4,"code":"  it(\"should count a keyword 7 times for relevance, no more\", () => {\n    hljs.registerLanguage('test-language', hljs => {\n      return {\n        keywords: \"bob suzy|2\"\n      };\n    });\n    let result = hljs.highlight('bob bob bob bob bob bob bob bob bob bob bob bob bob', {\n      language: 'test-language'\n    });\n    result.relevance.should.equal(7);\n    result = hljs.highlight('suzy suzy suzy suzy suzy suzy suzy suzy suzy suzy suzy suzy suzy', {\n      language: 'test-language'\n    });\n    result.relevance.should.equal(14);\n    hljs.unregisterLanguage(\"test-language\");\n  });","file":"parser/max_keyword_hits.js","skipped":false,"dir":"test"},{"name":"should continue to highlight later matches","suites":["bugs","resume scan when a match is ignored"],"updatePoint":{"line":9,"column":50},"line":9,"code":"    it(\"should continue to highlight later matches\", () => {\n      const result = hljs.highlight('ImmutablePair.of(Stuff.class, \"bar\")', {\n        language: 'java'\n      });\n      result.value.should.equal('ImmutablePair.of(Stuff.class, <span class=\"hljs-string\">&quot;bar&quot;</span>)');\n    }); // previously the match rule was resumed but it would scan ahead too far and ignore","file":"parser/resume-scan.js","skipped":false,"dir":"test"},{"name":"BUT should not skip ahead too far","suites":["bugs","resume scan when a match is ignored"],"updatePoint":{"line":19,"column":41},"line":19,"code":"    it(\"BUT should not skip ahead too far\", () => {\n      const result = hljs.highlight('ImmutablePair.of(Stuff.class, \"bar\");\\n23', {\n        language: 'java'\n      });\n      result.value.should.equal('ImmutablePair.of(Stuff.class, <span class=\"hljs-string\">&quot;bar&quot;</span>);\\n' + '<span class=\"hljs-number\">23</span>');\n    });","file":"parser/resume-scan.js","skipped":false,"dir":"test"},{"name":"should be allowed to be reused","suites":["bugs","modes containing 'endsWithParent'"],"updatePoint":{"line":5,"column":38},"line":5,"code":"    it(\"should be allowed to be reused\", () => {\n      hljs.registerLanguage('test-language', hljs => {\n        const TAG_CONTENTS = {\n          className: 'name',\n          begin: /\\w+/,\n          starts: {\n            endsWithParent: true\n          }\n        };\n        const PAREN_TAG = {\n          className: 'tag',\n          begin: /\\(/,\n          end: /\\)/,\n          contains: [TAG_CONTENTS]\n        };\n        const SQUARE_BRACKET_TAG = {\n          className: 'tag',\n          begin: /\\[/,\n          end: /\\]/,\n          contains: [TAG_CONTENTS]\n        };\n        return {\n          contains: [PAREN_TAG, SQUARE_BRACKET_TAG]\n        };\n      });\n      hljs.highlight('(abc 123) [abc 123] (abc 123)', {\n        language: 'test-language'\n      }).value.should.equal('<span class=\"hljs-tag\">(<span class=\"hljs-name\">abc</span> 123)</span> ' + '<span class=\"hljs-tag\">[<span class=\"hljs-name\">abc</span> 123]</span> ' + '<span class=\"hljs-tag\">(<span class=\"hljs-name\">abc</span> 123)</span>');\n    });","file":"parser/reuse-endsWithParent.js","skipped":false,"dir":"test"},{"name":"should instead count it as a 1 character match","suites":["parser/should not destroy data","a grammar with a mode that makes a 0 width match"],"updatePoint":{"line":6,"column":54},"line":6,"code":"    it(\"should instead count it as a 1 character match\", () => {\n      hljs.safeMode();\n      hljs.registerLanguage('test-language', hljs => {\n        // broken regex from old Fortran ruleset\n        const NUMBER = {\n          className: \"number\",\n          begin: '(?=\\\\b|\\\\+|-|\\\\.)(?=\\\\.\\\\d|\\\\d)(?:\\\\d+)?(?:\\\\.?\\\\d*)(?:[de][+-]?\\\\d+)?\\\\b\\\\.?'\n        };\n        return {\n          contains: [NUMBER]\n        };\n      });\n      hljs.highlight('The number is 123_longint yes.', {\n        language: 'test-language'\n      }).value.should.equal( // The whole number isn't highlighted (the rule doesn't handle the _type)\n      // But the key thing is the \"1\" is registered as a match for the rule\n      // instead of disappearing from the output completely, which is what\n      // would happen previously.\n      'The number is <span class=\"hljs-number\">1</span>23_longint yes.' // Incorrect prior output:\n      // 'The number is <span class=\"hljs-number\"></span>23_longint yes.'\n      );\n      hljs.debugMode();\n      should(() => {\n        hljs.highlight('The number is 123_longint yes.', {\n          language: 'test-language'\n        }).value;\n      }).throw(Error, {\n        message: /0 width match regex/,\n        languageName: \"test-language\"\n      });\n    });","file":"parser/should-not-destroyData.js","skipped":false,"dir":"test"},{"name":"have a name","suites":[],"updatePoint":{"line":87,"column":19},"line":87,"code":"    it(\"have a name\", function () {\n      language.name.should.not.equal(undefined);\n    }); // it('should not match the empty string', function () {","file":"regex/index.js","skipped":false,"dir":"test"},{"name":"have  regex matchers","suites":[],"updatePoint":{"line":97,"column":43},"line":97,"code":"    it(`have ${rules.length} regex matchers`, () => {});","file":"regex/index.js","skipped":false,"dir":"test"},{"name":"should not use octal escapes","suites":[],"updatePoint":{"line":98,"column":36},"line":98,"code":"    it('should not use octal escapes', function () {\n      forEachPattern(rules, ({\n        ast,\n        rulePath,\n        reportError\n      }) => {\n        visitRegExpAST(ast.pattern, {\n          onCharacterEnter(node) {\n            if (/^\\\\(?:[1-9]|\\d{2,})$/.test(node.raw)) {\n              reportError(`${rulePath}: Octal escape ${node.raw}.\\n\\n` + `Octal escapes can be confused with backreferences, so please do not use them.\\n` + `To fix this, use a different escape method. ` + `Note that this could also be an invalid backreference, so be sure to carefully analyse the pattern.`);\n            }\n          }\n\n        });\n      });\n    });","file":"regex/index.js","skipped":false,"dir":"test"},{"name":"should not cause exponential backtracking","suites":[],"updatePoint":{"line":114,"column":49},"line":114,"code":"    it('should not cause exponential backtracking', function () {\n      forEachPattern(rules, ({\n        pattern,\n        ast,\n        rulePath,\n        reportError\n      }) => {\n        const patternStr = String(pattern);\n\n        if (expBacktrackingCache[patternStr] === false) {\n          // we know that the pattern won't cause exp backtracking because we checked before\n          return;\n        }\n\n        const parser = JS.Parser.fromAst(ast);\n        /**\n         * Parses the given element and creates its NFA.\n         *\n         * @param {import(\"refa\").JS.ParsableElement} element\n         * @returns {NFA}\n         */\n\n        function toNFA(element, debug = false) {\n          const {\n            expression,\n            maxCharacter\n          } = parser.parseElement(element, {\n            backreferences: \"resolve\",\n            lookarounds: \"disable\"\n          });\n          return NFA.fromRegex(expression, {\n            maxCharacter\n          });\n        }\n        /**\n         * Checks whether the alternatives of the given node are disjoint. If the alternatives are not disjoint\n         * and the give node is a descendant of an effective Kleene star, then an error will be thrown.\n         *\n         * @param {CapturingGroup | Group | LookaroundAssertion} node\n         * @returns {void}\n         */\n\n\n        function checkDisjointAlternatives(node) {\n          if (!underAStar(node) || node.alternatives.length < 2) {\n            return;\n          }\n\n          const alternatives = node.alternatives;\n          const total = toNFA(alternatives[0]);\n          total.removeEmptyWord();\n\n          for (let i = 1, l = alternatives.length; i < l; i++) {\n            const a = alternatives[i];\n            const current = toNFA(a);\n            current.removeEmptyWord();\n\n            if (!total.isDisjointWith(current)) {\n              reportError(`${rulePath}: The alternative \\`${a.raw}\\` is not disjoint with at least one previous alternative.` + ` This will cause exponential backtracking.` + `\\n\\nTo fix this issue, you have to rewrite the ${node.type} \\`${node.raw}\\`.` + ` The goal is that all of its alternatives are disjoint.` + ` This means that if a (sub-)string is matched by the ${node.type}, then only one of its alternatives can match the (sub-)string.` + `\\n\\nExample: \\`(?:[ab]|\\\\w|::)+\\`` + `\\nThe alternatives of the group are not disjoint because the string \"a\" can be matched by both \\`[ab]\\` and \\`\\\\w\\`.` + ` In this example, the pattern by easily fixed because the \\`[ab]\\` is a subset of the \\`\\\\w\\`, so its enough to remove the \\`[ab]\\` alternative to get \\`(?:\\\\w|::)+\\` as the fixed pattern.` + `\\nIn the real world, patterns can be a lot harder to fix.` + ` If you are trying to make the tests pass for a pull request but can\\'t fix the issue yourself, then make the pull request (or commit) anyway.` + ` A maintainer will help you.` + `\\n\\nFull pattern:\\n${pattern}`);\n            } else if (i !== l - 1) {\n              total.union(current);\n            }\n          }\n        }\n\n        visitRegExpAST(ast.pattern, {\n          onCapturingGroupLeave: checkDisjointAlternatives,\n          onGroupLeave: checkDisjointAlternatives,\n\n          onAssertionLeave(node) {\n            if (node.kind === \"lookahead\" || node.kind === \"lookbehind\") {\n              checkDisjointAlternatives(node);\n            }\n          },\n\n          onQuantifierLeave(node) {\n            if (node.max < 10) {\n              return; // not a star\n            }\n\n            if (node.element.type !== \"CapturingGroup\" && node.element.type !== \"Group\") {\n              return; // not a group\n            } // The idea here is the following:\n            //\n            // We have found a part `A*` of the regex (`A` is assumed to not accept the empty word). Let `I` be\n            // the intersection of `A` and `A{2,}`. If `I` is not empty, then there exists a non-empty word `w`\n            // that is accepted by both `A` and `A{2,}`. That means that there exists some `m>1` for which `w`\n            // is accepted by `A{m}`.\n            // This means that there are at least two ways `A*` can accept `w`. It can be accepted as `A` or as\n            // `A{m}`. Hence there are at least 2^n ways for `A*` to accept the word `w{n}`. This is the main\n            // requirement for exponential backtracking.\n            //\n            // This is actually only a crude approximation for the real analysis that would have to be done. We\n            // would actually have to check the intersection `A{p}` and `A{p+1,}` for all p>0. However, in most\n            // cases, the approximation is good enough.\n\n\n            const nfa = toNFA(node.element, true);\n            nfa.removeEmptyWord();\n            const twoStar = nfa.copy();\n            twoStar.quantify(2, Infinity);\n\n            if (!nfa.isDisjointWith(twoStar)) {\n              const example = Words.fromUnicodeToString(firstOf(NFA.intersectionWords(nfa, twoStar)));\n              reportError(`${rulePath}: The quantifier \\`${node.raw}\\` ambiguous for all words ${JSON.stringify(example)}.repeat(n) for any n>1.` + ` This will cause exponential backtracking.` + `\\n\\nTo fix this issue, you have to rewrite the element (let's call it E) of the quantifier.` + ` The goal is modify E such that it is disjoint with repetitions of itself.` + ` This means that if a (sub-)string is matched by E, then it must not be possible for E{2}, E{3}, E{4}, etc. to match that (sub-)string.` + `\\n\\nExample: \\`(?:\\\\w+|::)+\\`` + `\\nThe problem lies in \\`\\\\w+\\` because \\`\\\\w+\\` and \\`(?:\\\\w+){2}\\` are not disjoint as the string \"aa\" is fully matched by both.` + ` In this example, the pattern by easily fixed by changing \\`\\\\w+\\` to \\`\\\\w\\`.` + `\\nIn the real world, patterns can be a lot harder to fix.` + ` If you are trying to make the tests pass for a pull request but can\\'t fix the issue yourself, then make the pull request (or commit) anyway.` + ` A maintainer will help you.` + `\\n\\nFull pattern:\\n${pattern}`);\n            }\n          }\n\n        });\n        expBacktrackingCache[patternStr] = false;\n      });\n    });","file":"regex/index.js","skipped":false,"dir":"test"},{"name":"should not cause polynomial backtracking","suites":[],"updatePoint":{"line":226,"column":48},"line":226,"code":"    it('should not cause polynomial backtracking', function () {\n      forEachPattern(rules, ({\n        pattern,\n        ast,\n        rulePath,\n        reportError\n      }) => {\n        const patternStr = String(pattern);\n\n        if (polyBacktrackingCache[patternStr] === false) {\n          // we know that the pattern won't cause poly backtracking because we checked before\n          return;\n        }\n\n        const EMPTY = ast.flags.unicode ? CharSet.empty(0x10FFFF) : CharSet.empty(0xFFFF);\n        /**\n         * @param {Node} node\n         * @returns {CharSet}\n         */\n\n        function toCharSet(node) {\n          switch (node.type) {\n            case \"Alternative\":\n              {\n                if (node.elements.length === 1) {\n                  return toCharSet(node.elements[0]);\n                }\n\n                return EMPTY;\n              }\n\n            case \"CapturingGroup\":\n            case \"Group\":\n              {\n                let total = EMPTY;\n\n                for (const item of node.alternatives) {\n                  total = total.union(toCharSet(item));\n                }\n\n                return total;\n              }\n\n            case \"Character\":\n              return JS.createCharSet([node.value], ast.flags);\n\n            case \"CharacterClass\":\n              {\n                const value = JS.createCharSet(node.elements.map(x => {\n                  if (x.type === \"CharacterSet\") {\n                    return x;\n                  } else if (x.type === \"Character\") {\n                    return x.value;\n                  } else {\n                    return {\n                      min: x.min.value,\n                      max: x.max.value\n                    };\n                  }\n                }), ast.flags);\n\n                if (node.negate) {\n                  return value.negate();\n                } else {\n                  return value;\n                }\n              }\n\n            case \"CharacterSet\":\n              return JS.createCharSet([node], ast.flags);\n\n            default:\n              return EMPTY;\n          }\n        }\n        /**\n         * @param {Element} from\n         * @returns {Element | null}\n         */\n\n\n        function getAfter(from) {\n          const parent = from.parent;\n\n          if (parent.type === \"Quantifier\") {\n            return getAfter(parent);\n          } else if (parent.type === \"Alternative\") {\n            const index = parent.elements.indexOf(from);\n            const after = parent.elements[index + 1];\n\n            if (after) {\n              return after;\n            } else {\n              const grandParent = parent.parent;\n\n              if (grandParent.type === \"Pattern\") {\n                return null;\n              } else {\n                return getAfter(grandParent);\n              }\n            }\n          } else {\n            throw Error(\"Unreachable\");\n          }\n        }\n\n        visitRegExpAST(ast.pattern, {\n          onQuantifierLeave(node) {\n            if (node.max !== Infinity) {\n              return;\n            }\n\n            const char = toCharSet(node.element);\n            tryReachUntil(getAfter(node), char, null);\n            /**\n             * @param {Quantifier} quantifier\n             * @param {CharSet} char\n             */\n\n            function assertNoPoly(quantifier, char) {\n              if (quantifier.max === Infinity) {\n                const qChar = toCharSet(quantifier.element);\n\n                if (qChar && !qChar.isDisjointWith(char)) {\n                  const intersection = qChar.intersect(char);\n                  const literal = JS.toLiteral({\n                    type: \"Concatenation\",\n                    elements: [{\n                      type: \"CharacterClass\",\n                      characters: intersection\n                    }]\n                  });\n                  const lang = `/${literal.source}/${literal.flags}`;\n                  const rangeStr = patternStr.substring(node.start + 1, quantifier.end + 1);\n                  const rangeHighlight = `^${\"~\".repeat(node.end - node.start - 1)}${\" \".repeat(quantifier.start - node.end)}^${\"~\".repeat(quantifier.end - quantifier.start - 1)}`;\n                  reportError(`${rulePath}: Polynomial backtracking. By repeating any character that matches ${lang}, an attack string can be created.\\n\\n    ${rangeStr}\\n    ${rangeHighlight}\\n\\nFull pattern:\\n${patternStr}\\n${\" \".repeat(node.start + 1)}${rangeHighlight}`);\n                }\n              }\n            }\n            /**\n             * @param {Element | null | undefined} element\n             * @param {CharSet} char\n             * @param {Element | null | undefined} until\n             * @returns {CharSet}\n             */\n\n\n            function tryReachUntil(element, char, until) {\n              if (!element || element == until || char.isEmpty) {\n                return char;\n              }\n\n              const after = getAfter(element);\n\n              if (element.type === \"Quantifier\") {\n                assertNoPoly(element, char);\n              }\n\n              return tryReachUntil(after, goInto(element, after, char), until);\n            }\n            /**\n             * @param {Element} element\n             * @param {Element} after\n             * @param {CharSet} char\n             * @returns {CharSet}\n             */\n\n\n            function goInto(element, after, char) {\n              switch (element.type) {\n                case \"Assertion\":\n                  {\n                    if (element.kind === \"lookahead\" || element.kind === \"lookbehind\") {\n                      for (const alt of element.alternatives) {\n                        if (alt.elements.length > 0) {\n                          tryReachUntil(alt.elements[0], char, after);\n                        }\n                      }\n                    }\n\n                    return EMPTY;\n                  }\n\n                case \"Group\":\n                case \"CapturingGroup\":\n                  {\n                    let total = EMPTY;\n\n                    for (const alt of element.alternatives) {\n                      if (alt.elements.length > 0) {\n                        total = total.union(tryReachUntil(alt.elements[0], char, after));\n                      } else {\n                        total = char;\n                      }\n                    }\n\n                    return total;\n                  }\n\n                case \"Character\":\n                case \"CharacterClass\":\n                case \"CharacterSet\":\n                  {\n                    return char.intersect(toCharSet(element));\n                  }\n\n                case \"Quantifier\":\n                  {\n                    if (element.min === 0) {\n                      goInto(element.element, after, char);\n                      return char;\n                    } else {\n                      return goInto(element.element, after, char);\n                    }\n                  }\n\n                default:\n                  return EMPTY;\n              }\n            }\n          }\n\n        });\n        polyBacktrackingCache[patternStr] = false;\n      });\n    });","file":"regex/index.js","skipped":false,"dir":"test"},{"name":"have  total regex","suites":["COMBINED: All grammars"],"updatePoint":{"line":467,"column":31},"line":467,"code":"  it(`have ${count} total regex`, () => {});","file":"regex/index.js","skipped":false,"dir":"test"},{"name":"should add language class name to block","suites":["block class names"],"updatePoint":{"line":8,"column":45},"line":8,"code":"  it('should add language class name to block', () => {\n    const expected = 'some-class hljs language-xml',\n          actual = this.blocks[0];\n    actual.should.equal(expected);\n  });","file":"special/buildClassName.js","skipped":false,"dir":"test"},{"name":"should not clutter block class (first)","suites":["block class names"],"updatePoint":{"line":13,"column":44},"line":13,"code":"  it('should not clutter block class (first)', () => {\n    const expected = 'hljs some-class language-xml',\n          actual = this.blocks[1];\n    actual.should.equal(expected);\n  });","file":"special/buildClassName.js","skipped":false,"dir":"test"},{"name":"should not clutter block class (last)","suites":["block class names"],"updatePoint":{"line":18,"column":43},"line":18,"code":"  it('should not clutter block class (last)', () => {\n    const expected = 'some-class hljs language-xml',\n          actual = this.blocks[2];\n    actual.should.equal(expected);\n  });","file":"special/buildClassName.js","skipped":false,"dir":"test"},{"name":"should not clutter block class (spaces around)","suites":["block class names"],"updatePoint":{"line":23,"column":52},"line":23,"code":"  it('should not clutter block class (spaces around)', () => {\n    const expected = 'hljs some-class language-xml',\n          actual = this.blocks[3];\n    actual.should.equal(expected);\n  });","file":"special/buildClassName.js","skipped":false,"dir":"test"},{"name":"should end on all variants","suites":["ends with parent variants"],"updatePoint":{"line":11,"column":32},"line":11,"code":"  it('should end on all variants', () => {\n    const actual = this.blocks[0];\n    actual.should.equal(this.expected);\n  });","file":"special/endsWithParentVariants.js","skipped":false,"dir":"test"},{"name":"should highlight block with language in code tag","suites":["explicit language class"],"updatePoint":{"line":11,"column":54},"line":11,"code":"  it('should highlight block with language in code tag', () => {\n    const actual = this.blocks[0];\n    actual.should.equal(this.expected);\n  });","file":"special/explicitLanguage.js","skipped":false,"dir":"test"},{"name":"should highlight block with language in pre tag","suites":["explicit language class"],"updatePoint":{"line":15,"column":53},"line":15,"code":"  it('should highlight block with language in pre tag', () => {\n    const actual = this.blocks[1];\n    actual.should.equal(this.expected);\n  });","file":"special/explicitLanguage.js","skipped":false,"dir":"test"},{"name":"should highlight using html 5 style (language-*)","suites":["explicit language class"],"updatePoint":{"line":19,"column":54},"line":19,"code":"  it('should highlight using html 5 style (language-*)', () => {\n    const actual = this.blocks[2];\n    actual.should.equal(this.expected);\n  });","file":"special/explicitLanguage.js","skipped":false,"dir":"test"},{"name":"should highlight with shortened prefix (lang-)","suites":["explicit language class"],"updatePoint":{"line":23,"column":52},"line":23,"code":"  it('should highlight with shortened prefix (lang-)', () => {\n    const filename = utility.buildPath('fixtures', 'expect', 'explicit2.txt'),\n          actual = this.blocks[3];\n    return utility.expectedFile(filename, 'utf-8', actual);\n  });","file":"special/explicitLanguage.js","skipped":false,"dir":"test"},{"name":"should highlight if classname contains uppercase symbols","suites":["explicit language class"],"updatePoint":{"line":28,"column":62},"line":28,"code":"  it('should highlight if classname contains uppercase symbols', () => {\n    const filename = utility.buildPath('fixtures', 'expect', 'explicit2.txt'),\n          actual = this.blocks[4];\n    return utility.expectedFile(filename, 'utf-8', actual);\n  });","file":"special/explicitLanguage.js","skipped":false,"dir":"test"},{"name":"should highlight as aliased language","suites":["language alias"],"updatePoint":{"line":10,"column":42},"line":10,"code":"  it('should highlight as aliased language', () => {\n    const filename = utility.buildPath('fixtures', 'expect', 'languagealias.txt'),\n          actual = this.blocks[0];\n    return utility.expectedFile(filename, 'utf-8', actual);\n  });","file":"special/languageAlias.js","skipped":false,"dir":"test"},{"name":"should keep block unchanged (nohighlight)","suites":["no highlighting"],"updatePoint":{"line":13,"column":47},"line":13,"code":"  it('should keep block unchanged (nohighlight)', () => {\n    const expected = this.expected.html,\n          actual = this.blocks[0];\n    actual.should.equal(expected);\n  });","file":"special/noHighlight.js","skipped":false,"dir":"test"},{"name":"should keep block unchanged (no-highlight)","suites":["no highlighting"],"updatePoint":{"line":18,"column":48},"line":18,"code":"  it('should keep block unchanged (no-highlight)', () => {\n    const expected = this.expected.html,\n          actual = this.blocks[1];\n    actual.should.equal(expected);\n  });","file":"special/noHighlight.js","skipped":false,"dir":"test"},{"name":"should skip pre tags without a child code tag","suites":["no highlighting"],"updatePoint":{"line":23,"column":51},"line":23,"code":"  it('should skip pre tags without a child code tag', () => {\n    const expected = 'Computer output',\n          actual = this.blocks[2];\n    actual.should.equal(expected);\n  });","file":"special/noHighlight.js","skipped":false,"dir":"test"},{"name":"should keep block unchanged (unsupported language)","suites":["no highlighting"],"updatePoint":{"line":28,"column":56},"line":28,"code":"  it('should keep block unchanged (unsupported language)', () => {\n    const expected = this.expected.python,\n          actual = this.blocks[3];\n    actual.should.equal(expected);\n  });","file":"special/noHighlight.js","skipped":false,"dir":"test"},{"name":"should keep block unchanged (unsupported lang)","suites":["no highlighting"],"updatePoint":{"line":33,"column":52},"line":33,"code":"  it('should keep block unchanged (unsupported lang)', () => {\n    const expected = this.expected.python,\n          actual = this.blocks[4];\n    actual.should.equal(expected);\n  });","file":"special/noHighlight.js","skipped":false,"dir":"test"},{"name":"should keep block unchanged (unsupported prefixed language)","suites":["no highlighting"],"updatePoint":{"line":38,"column":65},"line":38,"code":"  it('should keep block unchanged (unsupported prefixed language)', () => {\n    const expected = this.expected.python,\n          actual = this.blocks[5];\n    actual.should.equal(expected);\n  });","file":"special/noHighlight.js","skipped":false,"dir":"test"},{"name":"should highlight XML with PHP and JavaScript","suites":["sub-languages"],"updatePoint":{"line":9,"column":50},"line":9,"code":"  it('should highlight XML with PHP and JavaScript', () => {\n    const filename = utility.buildPath('fixtures', 'expect', 'sublanguages.txt'),\n          actual = this.block.innerHTML;\n    return utility.expectedFile(filename, 'utf-8', actual);\n  });","file":"special/subLanguages.js","skipped":false,"dir":"test"}]}