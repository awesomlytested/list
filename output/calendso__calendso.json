{
    "repo": "calendso/calendso",
    "url": "https://github.com/calendso/calendso",
    "branch": "main",
    "configs": [
        {
            "package": "calendso",
            "lang": "js",
            "dir": "test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "correctly translates Availability (UTC+0) to UTC workingHours",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 65
            },
            "line": 10,
            "code": "it(\"correctly translates Availability (UTC+0) to UTC workingHours\", async () => {\n  expect(getWorkingHours({\n    timeZone: \"GMT\"\n  }, [{\n    days: [0],\n    startTime: new Date(Date.UTC(2021, 11, 16, 23)),\n    endTime: new Date(Date.UTC(2021, 11, 16, 23, 59))\n  }])).toStrictEqual([{\n    days: [0],\n    endTime: 1439,\n    startTime: 1380\n  }]);\n});",
            "file": "lib/getWorkingHours.test.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "correctly translates Availability in a positive UTC offset (Pacific/Auckland) to UTC workingHours",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 101
            },
            "line": 23,
            "code": "it(\"correctly translates Availability in a positive UTC offset (Pacific/Auckland) to UTC workingHours\", async () => {\n  // Take note that (Pacific/Auckland) is UTC+12 on 2021-06-20, NOT +13 like the other half of the year.\n  expect(getWorkingHours({\n    timeZone: \"Pacific/Auckland\"\n  }, [{\n    days: [1],\n    startTime: new Date(Date.UTC(2021, 11, 16, 0)),\n    endTime: new Date(Date.UTC(2021, 11, 16, 23, 59))\n  }])).toStrictEqual([{\n    days: [1],\n    endTime: 719,\n    startTime: 0\n  }, {\n    days: [0],\n    endTime: 1439,\n    startTime: 720 // 0 (midnight) - 12 * 60 (DST)\n\n  }]);\n});",
            "file": "lib/getWorkingHours.test.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "correctly translates Availability in a negative UTC offset (Pacific/Midway) to UTC workingHours",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 99
            },
            "line": 42,
            "code": "it(\"correctly translates Availability in a negative UTC offset (Pacific/Midway) to UTC workingHours\", async () => {\n  // Take note that (Pacific/Midway) is UTC-12 on 2021-06-20, NOT +13 like the other half of the year.\n  expect(getWorkingHours({\n    timeZone: \"Pacific/Midway\"\n  }, [{\n    days: [1],\n    startTime: new Date(Date.UTC(2021, 11, 16, 0)),\n    endTime: new Date(Date.UTC(2021, 11, 16, 23, 59))\n  }])).toStrictEqual([{\n    days: [2],\n    endTime: 659,\n    startTime: 0\n  }, {\n    days: [1],\n    endTime: 1439,\n    startTime: 660\n  }]);\n});",
            "file": "lib/getWorkingHours.test.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can do the same with UTC offsets",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 36
            },
            "line": 60,
            "code": "it(\"can do the same with UTC offsets\", async () => {\n  // Take note that (Pacific/Midway) is UTC-12 on 2021-06-20, NOT +13 like the other half of the year.\n  expect(getWorkingHours({\n    utcOffset: dayjs().tz(\"Pacific/Midway\").utcOffset()\n  }, [{\n    days: [1],\n    startTime: new Date(Date.UTC(2021, 11, 16, 0)),\n    endTime: new Date(Date.UTC(2021, 11, 16, 23, 59))\n  }])).toStrictEqual([{\n    days: [2],\n    endTime: 659,\n    startTime: 0\n  }, {\n    days: [1],\n    endTime: 1439,\n    startTime: 660\n  }]);\n});",
            "file": "lib/getWorkingHours.test.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can also shift UTC into other timeZones",
            "suites": [],
            "updatePoint": {
                "line": 78,
                "column": 43
            },
            "line": 78,
            "code": "it(\"can also shift UTC into other timeZones\", async () => {\n  // UTC+0 time with 23:00 - 23:59 (Sunday) and 00:00 - 16:00 (Monday) when cast into UTC+1 should become 00:00 = 17:00 (Monday)\n  expect(getWorkingHours({\n    utcOffset: -60\n  }, [{\n    days: [0],\n    startTime: new Date(Date.UTC(2021, 11, 16, 23)),\n    endTime: new Date(Date.UTC(2021, 11, 16, 23, 59))\n  }, {\n    days: [1],\n    startTime: new Date(Date.UTC(2021, 11, 17, 0)),\n    endTime: new Date(Date.UTC(2021, 11, 17, 16))\n  }])).toStrictEqual([// TODO: Maybe the desired result is 0-1020 as a single entry, but this requires some post-processing to merge. It may work as is so leaving this as now.\n  {\n    days: [1],\n    endTime: 59,\n    startTime: 0\n  }, {\n    days: [1],\n    endTime: 1020,\n    startTime: 60\n  }]); // And the other way around; UTC+0 time with 00:00 - 1:00 (Monday) and 21:00 - 24:00 (Sunday) when cast into UTC-1 should become 20:00 = 24:00 (Sunday)\n\n  expect(getWorkingHours({\n    utcOffset: 60\n  }, [{\n    days: [0],\n    startTime: new Date(Date.UTC(2021, 11, 16, 21)),\n    endTime: new Date(Date.UTC(2021, 11, 16, 23, 59))\n  }, {\n    days: [1],\n    startTime: new Date(Date.UTC(2021, 11, 17, 0)),\n    endTime: new Date(Date.UTC(2021, 11, 17, 1))\n  }])).toStrictEqual([// TODO: Maybe the desired result is 1200-1439 as a single entry, but this requires some post-processing to merge. It may work as is so leaving this as now.\n  {\n    days: [0],\n    endTime: 1379,\n    startTime: 1200\n  }, {\n    days: [0],\n    endTime: 1439,\n    startTime: 1380\n  }]);\n});",
            "file": "lib/getWorkingHours.test.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has the right utcOffset regardless of the local timeZone",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 60
            },
            "line": 6,
            "code": "it(\"has the right utcOffset regardless of the local timeZone\", async () => {\n  expect(parseZone(EXPECTED_DATE_STRING)?.utcOffset()).toEqual(120);\n  expect(parseZone(EXPECTED_DATE_STRING)?.format()).toEqual(EXPECTED_DATE_STRING);\n});",
            "file": "lib/parseZone.test.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can fit 24 hourly slots for an empty day",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 44
            },
            "line": 11,
            "code": "it(\"can fit 24 hourly slots for an empty day\", async () => {\n  // 24h in a day.\n  expect(getSlots({\n    inviteeDate: dayjs.utc().add(1, \"day\").startOf(\"day\"),\n    frequency: 60,\n    minimumBookingNotice: 0,\n    workingHours: [{\n      days: Array.from(Array(7).keys()),\n      startTime: MINUTES_DAY_START,\n      endTime: MINUTES_DAY_END\n    }]\n  })).toHaveLength(24);\n}); // TODO: This test is sound; it should pass!",
            "file": "lib/slots.test.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "only shows future booking slots on the same day",
            "suites": [],
            "updatePoint": {
                "line": 25,
                "column": 51
            },
            "line": 25,
            "code": "it(\"only shows future booking slots on the same day\", async () => {\n  // The mock date is 1s to midday, so 12 slots should be open given 0 booking notice.\n  expect(getSlots({\n    inviteeDate: dayjs.utc(),\n    frequency: 60,\n    minimumBookingNotice: 0,\n    workingHours: [{\n      days: Array.from(Array(7).keys()),\n      startTime: MINUTES_DAY_START,\n      endTime: MINUTES_DAY_END\n    }]\n  })).toHaveLength(12);\n});",
            "file": "lib/slots.test.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can cut off dates that due to invitee timezone differences fall on the next day",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 83
            },
            "line": 38,
            "code": "it(\"can cut off dates that due to invitee timezone differences fall on the next day\", async () => {\n  expect(getSlots({\n    inviteeDate: dayjs().tz(\"Europe/Amsterdam\").startOf(\"day\"),\n    // time translation +01:00\n    frequency: 60,\n    minimumBookingNotice: 0,\n    workingHours: [{\n      days: [0],\n      startTime: 23 * 60,\n      // 23h\n      endTime: MINUTES_DAY_END\n    }]\n  })).toHaveLength(0);\n});",
            "file": "lib/slots.test.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can cut off dates that due to invitee timezone differences fall on the previous day",
            "suites": [],
            "updatePoint": {
                "line": 52,
                "column": 87
            },
            "line": 52,
            "code": "it(\"can cut off dates that due to invitee timezone differences fall on the previous day\", async () => {\n  const workingHours = [{\n    days: [0],\n    startTime: MINUTES_DAY_START,\n    endTime: 1 * 60 // 1h\n\n  }];\n  expect(getSlots({\n    inviteeDate: dayjs().tz(\"Atlantic/Cape_Verde\").startOf(\"day\"),\n    // time translation -01:00\n    frequency: 60,\n    minimumBookingNotice: 0,\n    workingHours\n  })).toHaveLength(0);\n});",
            "file": "lib/slots.test.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "adds minimum booking notice correctly",
            "suites": [],
            "updatePoint": {
                "line": 67,
                "column": 41
            },
            "line": 67,
            "code": "it(\"adds minimum booking notice correctly\", async () => {\n  // 24h in a day.\n  expect(getSlots({\n    inviteeDate: dayjs.utc().add(1, \"day\").startOf(\"day\"),\n    frequency: 60,\n    minimumBookingNotice: 1500,\n    workingHours: [{\n      days: Array.from(Array(7).keys()),\n      startTime: MINUTES_DAY_START,\n      endTime: MINUTES_DAY_END\n    }]\n  })).toHaveLength(11);\n});",
            "file": "lib/slots.test.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can find lucky users",
            "suites": [],
            "updatePoint": {
                "line": 2,
                "column": 24
            },
            "line": 2,
            "code": "it(\"can find lucky users\", async () => {\n  const users = [{\n    id: 1,\n    username: \"test\",\n    name: \"Test User\",\n    credentials: [],\n    timeZone: \"GMT\",\n    bufferTime: 0,\n    email: \"test@example.com\"\n  }, {\n    id: 2,\n    username: \"test2\",\n    name: \"Test 2 User\",\n    credentials: [],\n    timeZone: \"GMT\",\n    bufferTime: 0,\n    email: \"test2@example.com\"\n  }];\n  expect(getLuckyUsers(users, [{\n    username: \"test\",\n    bookingCount: 2\n  }, {\n    username: \"test2\",\n    bookingCount: 0\n  }])).toStrictEqual([users[1]]);\n});",
            "file": "lib/team-event-types.test.ts",
            "skipped": false,
            "dir": "test"
        }
    ],
    "badge": "calendso__calendso.svg"
}