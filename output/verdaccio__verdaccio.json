{"repo":"verdaccio/verdaccio","url":"https://github.com/verdaccio/verdaccio","branch":"master","configs":[{"package":"verdaccio-dev","lang":"js","dir":"test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/api","lang":"js","dir":"packages/api/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/auth","lang":"ts","dir":"packages/auth/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/cli","lang":"ts","dir":"packages/cli/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/config","lang":"ts","dir":"packages/config/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/core","lang":"ts","dir":"packages/core/core/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/file-locking","lang":"ts","dir":"packages/core/file-locking/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/readme","lang":"ts","dir":"packages/core/readme/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/streams","lang":"ts","dir":"packages/core/streams/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/tarball","lang":"ts","dir":"packages/core/tarball/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/url","lang":"ts","dir":"packages/core/url/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/hooks","lang":"ts","dir":"packages/hooks/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/loaders","lang":"ts","dir":"packages/loaders/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/logger-prettify","lang":"ts","dir":"packages/logger-prettify/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/logger","lang":"ts","dir":"packages/logger/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/middleware","lang":"ts","dir":"packages/middleware/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/node-api","lang":"ts","dir":"packages/node-api/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/active-directory","lang":"ts","dir":"packages/plugins/active-directory/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-audit","lang":"ts","dir":"packages/plugins/audit/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-auth-memory","lang":"ts","dir":"packages/plugins/auth-memory/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-aws-s3-storage","lang":"ts","dir":"packages/plugins/aws-storage/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-google-cloud","lang":"ts","dir":"packages/plugins/google-cloud-storage/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-htpasswd","lang":"ts","dir":"packages/plugins/htpasswd/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/local-storage","lang":"ts","dir":"packages/plugins/local-storage/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-memory","lang":"ts","dir":"packages/plugins/memory/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/proxy","lang":"ts","dir":"packages/proxy/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/server","lang":"js","dir":"packages/server/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/store","lang":"ts","dir":"packages/store/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/mock","lang":"ts","dir":"packages/tools/mock/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/utils","lang":"ts","dir":"packages/utils/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio","lang":"js","dir":"packages/verdaccio/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/web","lang":"ts","dir":"packages/web/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should display dist-tag (npm dist-tag ls)","suites":["package"],"line":9,"code":"  test.each([['foo'], ['@scope/foo']])('should display dist-tag (npm dist-tag ls)', async pkg => {\n    await publishVersion(app, pkg, '1.0.0');\n    await publishVersion(app, pkg, '1.0.1');\n    const response = await getDisTags(app, pkg);\n    expect(response.body).toEqual({\n      latest: '1.0.1'\n    });\n  });","file":"integration/distTag.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should add a version to a tag (npm dist-tag add)","suites":["package"],"updatePoint":{"line":17,"column":56,"index":680},"line":17,"code":"  test('should add a version to a tag (npm dist-tag add)', async () => {\n    await publishVersion(app, encodeURIComponent('foo'), '1.0.0');\n    await publishVersion(app, encodeURIComponent('foo'), '1.0.1');\n    const response = await supertest(app).put(`/${encodeURIComponent('foo')}/test`).set(HEADERS.ACCEPT, HEADERS.GZIP).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify('1.0.1')).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.CREATED);\n    expect(response.body.ok).toEqual(API_MESSAGE.TAG_ADDED);\n    const response2 = await getDisTags(app, 'foo');\n    expect(response2.body).toEqual({\n      latest: '1.0.1',\n      test: '1.0.1'\n    });\n  });","file":"integration/distTag.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails if  a version is missing (npm dist-tag add)","suites":["package"],"updatePoint":{"line":28,"column":64,"index":1422},"line":28,"code":"  test('should fails if  a version is missing (npm dist-tag add)', async () => {\n    await publishVersion(app, encodeURIComponent('foo'), '1.0.0');\n    await publishVersion(app, encodeURIComponent('foo'), '1.0.1');\n    await supertest(app).put(`/${encodeURIComponent('foo')}/test`).set(HEADERS.ACCEPT, HEADERS.GZIP).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify({})).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.BAD_REQUEST);\n  });","file":"integration/distTag.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should delete a previous added tag (npm dist-tag rm)","suites":["package"],"updatePoint":{"line":33,"column":60,"index":1897},"line":33,"code":"  test('should delete a previous added tag (npm dist-tag rm)', async () => {\n    await publishVersion(app, encodeURIComponent('foo'), '1.0.0');\n    await publishVersion(app, encodeURIComponent('foo'), '1.0.1');\n    const response = await supertest(app).put(`/${encodeURIComponent('foo')}/beta`).set(HEADERS.ACCEPT, HEADERS.GZIP).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify('1.0.1')).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.CREATED);\n    expect(response.body.ok).toEqual(API_MESSAGE.TAG_ADDED);\n    const response2 = await getDisTags(app, 'foo');\n    expect(response2.body).toEqual({\n      latest: '1.0.1',\n      beta: '1.0.1'\n    });\n    const response3 = await supertest(app).delete(`/-/package/${encodeURIComponent('foo')}/dist-tags/beta`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.CREATED);\n    expect(response3.body.ok).toEqual(API_MESSAGE.TAG_REMOVED);\n    const response4 = await getDisTags(app, 'foo');\n    expect(response4.body).toEqual({\n      latest: '1.0.1'\n    });\n  });","file":"integration/distTag.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should return a file tarball","suites":["package","get tarball"],"line":11,"code":"    test.each([['foo', 'foo-1.0.0.tgz'], ['@scope/foo', 'foo-1.0.0.tgz']])('should return a file tarball', async (pkg, fileName) => {\n      await publishVersion(app, pkg, '1.0.0');\n      const response = await supertest(app).get(`/${pkg}/-/${fileName}`).set(HEADERS.ACCEPT, HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.OCTET_STREAM).expect(HTTP_STATUS.OK);\n      expect(Buffer.from(response.body).toString('utf8')).toBeDefined();\n    });","file":"integration/package.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails if tarball does not exist","suites":["package","get tarball"],"line":16,"code":"    test.each([['foo', 'foo-1.0.0.tgz'], ['@scope/foo', 'foo-1.0.0.tgz']])('should fails if tarball does not exist', async (pkg, fileName) => {\n      await publishVersion(app, pkg, '1.0.1');\n      return await supertest(app).get(`/${pkg}/-/${fileName}`).set(HEADERS.ACCEPT, HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.OCTET_STREAM).expect(HTTP_STATUS.NOT_FOUND);\n    });","file":"integration/package.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"check content length file header","suites":["package","get tarball"],"line":20,"code":"    test.todo('check content length file header');","file":"integration/package.spec.ts","skipped":true,"dir":"packages/api/test"},{"name":"fails on file was aborted","suites":["package","get tarball"],"line":21,"code":"    test.todo('fails on file was aborted');","file":"integration/package.spec.ts","skipped":true,"dir":"packages/api/test"},{"name":"should return a foo private package","suites":["package","get package"],"line":28,"code":"    test.each([['foo'], ['@scope/foo']])('should return a foo private package', async pkg => {\n      await publishVersion(app, pkg, '1.0.0');\n      const response = await supertest(app).get(`/${pkg}`).set(HEADERS.ACCEPT, HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n      expect(response.body.name).toEqual(pkg);\n    });","file":"integration/package.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should return a foo private package by version","suites":["package","get package"],"line":33,"code":"    test.each([['foo'], ['@scope/foo']])('should return a foo private package by version', async pkg => {\n      await publishVersion(app, pkg, '1.0.0');\n      const response = await supertest(app).get(`/${pkg}`).set(HEADERS.ACCEPT, HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n      expect(response.body.name).toEqual(pkg);\n    });","file":"integration/package.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should return a foo private package by version","suites":["package","get package"],"line":38,"code":"    test.each([['foo'], ['@scope/foo']])('should return a foo private package by version', async pkg => {\n      await publishVersion(app, pkg, '1.0.0');\n      const response = await supertest(app).get(`/${pkg}`).set(HEADERS.ACCEPT, HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n      expect(response.body.name).toEqual(pkg);\n    });","file":"integration/package.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should return abbreviated local manifest","suites":["package","get package"],"line":43,"code":"    test.each([['foo-abbreviated'], ['@scope/foo-abbreviated']])('should return abbreviated local manifest', async pkg => {\n      await publishVersion(app, pkg, '1.0.0');\n      const response = await supertest(app).get(`/${pkg}`).set(HEADERS.ACCEPT, HEADERS.JSON).set(HEADERS.ACCEPT, Storage.ABBREVIATED_HEADER).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_INSTALL_CHARSET).expect(HTTP_STATUS.OK);\n      expect(response.body.name).toEqual(pkg);\n      expect(response.body.time).toBeDefined();\n      expect(response.body.modified).toBeDefined();\n      expect(response.body[DIST_TAGS]).toEqual({\n        latest: '1.0.0'\n      });\n      expect(response.body.readme).not.toBeDefined();\n      expect(response.body._rev).not.toBeDefined();\n      expect(response.body.users).not.toBeDefined();\n    });","file":"integration/package.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should return the reply the ping","suites":["ping"],"updatePoint":{"line":5,"column":40,"index":216},"line":5,"code":"  test('should return the reply the ping', async () => {\n    const app = await initializeServer('ping.yaml');\n    const response = await supertest(app).get('/-/ping').set('Accept', HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n    expect(response.body).toEqual({});\n  });","file":"integration/ping.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fail on publish a bad _attachments package","suites":["publish","handle errors"],"updatePoint":{"line":12,"column":59,"index":610},"line":12,"code":"    test('should fail on publish a bad _attachments package', async () => {\n      const app = await initializeServer('publish.yaml');\n      const response = await supertest(app).put(`/${encodeURIComponent(pkgName)}`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify(Object.assign({}, pkgMetadata, {\n        _attachments: {}\n      }))).set('accept', HEADERS.GZIP).expect(HTTP_STATUS.BAD_REQUEST);\n      expect(response.body.error).toEqual(API_ERROR.UNSUPORTED_REGISTRY_CALL);\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fail on publish a bad versions package","suites":["publish","handle errors"],"updatePoint":{"line":19,"column":55,"index":1104},"line":19,"code":"    test('should fail on publish a bad versions package', async () => {\n      const app = await initializeServer('publish.yaml');\n      return new Promise(resolve => {\n        supertest(app).put(`/${encodeURIComponent(pkgName)}`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify(Object.assign({}, pkgMetadata, {\n          versions: ''\n        }))).set('accept', HEADERS.GZIP).expect(HTTP_STATUS.BAD_REQUEST).then(response => {\n          expect(response.body.error).toEqual(API_ERROR.UNSUPORTED_REGISTRY_CALL);\n          resolve(response);\n        });\n      });\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails on publish a duplicated package","suites":["publish","handle errors"],"line":30,"code":"    test.each([['foo', '@scope/foo']])('should fails on publish a duplicated package', async pkgName => {\n      const app = await initializeServer('publish.yaml');\n      await publishVersion(app, pkgName, '1.0.0');\n      return new Promise(resolve => {\n        publishVersion(app, pkgName, '1.0.0').expect(HTTP_STATUS.CONFLICT).then(response => {\n          expect(response.body.error).toEqual(API_ERROR.PACKAGE_EXIST);\n          resolve(response);\n        });\n      });\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should publish a package","suites":["publish","publish a package","no proxies setup"],"line":43,"code":"      test.each([['foo', '@scope/foo']])('should publish a package', async pkgName => {\n        const app = await initializeServer('publish.yaml');\n        return new Promise(resolve => {\n          publishVersion(app, pkgName, '1.0.0').expect(HTTP_STATUS.CREATED).then(response => {\n            expect(response.body.ok).toEqual(API_MESSAGE.PKG_CREATED);\n            resolve(response);\n          });\n        });\n      });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should publish a new package","suites":["publish","publish a package","no proxies setup"],"line":52,"code":"      test.each([['foo', '@scope/foo']])('should publish a new package', async pkgName => {\n        const pkgMetadata = generatePackageMetadata(pkgName, '1.0.0');\n        const app = await initializeServer('publish.yaml');\n        return new Promise(resolve => {\n          supertest(app).put(`/${encodeURIComponent(pkgName)}`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify(Object.assign({}, pkgMetadata))).set('accept', HEADERS.GZIP).expect(HTTP_STATUS.CREATED).then(response => {\n            expect(response.body.ok).toEqual(API_MESSAGE.PKG_CREATED);\n            resolve(response);\n          });\n        });\n      });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should publish a new package with no readme","suites":["publish","publish a package","no proxies setup"],"updatePoint":{"line":62,"column":55,"index":3311},"line":62,"code":"      test('should publish a new package with no readme', async () => {\n        const pkgName = 'test';\n        const pkgMetadata = generatePackageMetadata(pkgName, '1.0.0');\n        const app = await initializeServer('publish.yaml');\n        return new Promise(resolve => {\n          supertest(app).put(`/${encodeURIComponent(pkgName)}`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify(Object.assign({}, pkgMetadata, {\n            versions: {\n              ['1.0.0']: {\n                readme: null\n              }\n            }\n          }))).set('accept', HEADERS.GZIP).expect(HTTP_STATUS.CREATED).then(response => {\n            expect(response.body.ok).toEqual(API_MESSAGE.PKG_CREATED);\n            resolve(response);\n          });\n        });\n      });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should publish a a patch package that already exist on a remote","suites":["publish","publish a package","proxies setup"],"line":81,"code":"      test.each([['foo', '@scope%2Ffoo']])('should publish a a patch package that already exist on a remote', async pkgName => {\n        const upstreamManifest = generateRemotePackageMetadata(pkgName, '1.0.0', 'https://registry.npmjs.org', ['1.0.1', '1.0.2', '1.0.3']);\n        nock('https://registry.npmjs.org').get(`/${pkgName}`).reply(200, upstreamManifest);\n        const app = await initializeServer('publish-proxy.yaml');\n        const manifest = await getPackage(app, '', decodeURIComponent(pkgName));\n        expect(manifest.body.name).toEqual(decodeURIComponent(pkgName));\n        const response = await publishVersion(app, decodeURIComponent(pkgName), '1.0.1-patch').expect(HTTP_STATUS.CREATED);\n        expect(response.body.ok).toEqual(API_MESSAGE.PKG_CHANGED);\n        const response2 = await publishVersion(app, decodeURIComponent(pkgName), '1.0.2-patch').expect(HTTP_STATUS.CREATED);\n        expect(response2.body.ok).toEqual(API_MESSAGE.PKG_CHANGED);\n      });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should unpublish entirely a package","suites":["publish","unpublish a package"],"line":95,"code":"    test.each([['foo', '@scope/foo']])('should unpublish entirely a package', async pkgName => {\n      const app = await initializeServer('publish.yaml');\n      await publishVersion(app, pkgName, '1.0.0');\n      const response = await supertest(app)\n      // FIXME: should be filtered by revision to avoid\n      // conflicts\n      .delete(`/${encodeURIComponent(pkgName)}/-rev/xxx`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HTTP_STATUS.CREATED);\n      expect(response.body.ok).toEqual(API_MESSAGE.PKG_REMOVED);\n      // package should be completely un published\n      await supertest(app).get(`/${pkgName}`).set('Accept', HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.NOT_FOUND);\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails unpublish entirely a package","suites":["publish","unpublish a package"],"line":106,"code":"    test.each([['foo', '@scope/foo']])('should fails unpublish entirely a package', async pkgName => {\n      const app = await initializeServer('publish.yaml');\n      const response = await supertest(app).delete(`/${encodeURIComponent(pkgName)}/-rev/1cf3-fe3`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HTTP_STATUS.NOT_FOUND);\n      expect(response.body.error).toEqual(API_ERROR.NO_PACKAGE);\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails remove a tarball of a package does not exist","suites":["publish","unpublish a package"],"line":111,"code":"    test.each([['foo', '@scope/foo']])('should fails remove a tarball of a package does not exist', async pkgName => {\n      const app = await initializeServer('publish.yaml');\n      const response = await supertest(app).delete(`/${pkgName}/-/${basename(pkgName)}-1.0.3.tgz/-rev/revision`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HTTP_STATUS.NOT_FOUND);\n      expect(response.body.error).toEqual(API_ERROR.NO_PACKAGE);\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails on try remove a tarball does not exist","suites":["publish","unpublish a package"],"line":116,"code":"    test.each([['foo', '@scope/foo']])('should fails on try remove a tarball does not exist', async pkgName => {\n      const app = await initializeServer('publish.yaml');\n      await publishVersion(app, pkgName, '1.0.0');\n      const response = await supertest(app).delete(`/${pkgName}/-/${basename(pkgName)}-1.0.3.tgz/-rev/revision`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HTTP_STATUS.NOT_FOUND);\n      expect(response.body.error).toEqual(API_ERROR.NO_SUCH_FILE);\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should remove a tarball that does exist","suites":["publish","unpublish a package"],"line":122,"code":"    test.each([['foo', '@scope/foo']])('should remove a tarball that does exist', async pkgName => {\n      const app = await initializeServer('publish.yaml');\n      await publishVersion(app, pkgName, '1.0.0');\n      const response = await supertest(app).delete(`/${pkgName}/-/${basename(pkgName)}-1.0.0.tgz/-rev/revision`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HTTP_STATUS.CREATED);\n      expect(response.body.ok).toEqual(API_MESSAGE.TARBALL_REMOVED);\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should return a foo private package","suites":["search","search authenticated"],"line":11,"code":"    test.each([['foo']])('should return a foo private package', async pkg => {\n      const mockDate = '2018-01-14T11:17:40.712Z';\n      MockDate.set(mockDate);\n      const res = await createUser(app, 'test', 'test');\n      await publishVersionWithToken(app, pkg, '1.0.0', res.body.token);\n      // this should not be displayed as part of the search\n      await publishVersionWithToken(app, 'private-auth', '1.0.0', res.body.token);\n      const response = await supertest(app).get(`/-/v1/search?text=${encodeURIComponent(pkg)}&size=2000&from=0&quality=1&popularity=0.1&maintenance=0.1`).set(HEADERS.ACCEPT, HEADERS.JSON).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HEADERS.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n      expect(response.body).toEqual({\n        objects: [{\n          package: {\n            author: {\n              email: 'user@domain.com',\n              name: 'User NPM'\n            },\n            date: mockDate,\n            description: 'package generated',\n            keywords: [],\n            links: {\n              npm: ''\n            },\n            name: pkg,\n            publisher: {},\n            scope: '',\n            version: '1.0.0'\n          },\n          score: {\n            detail: {\n              maintenance: 0,\n              popularity: 1,\n              quality: 1\n            },\n            final: 1\n          },\n          searchScore: 1,\n          verdaccioPkgCached: false,\n          verdaccioPrivate: true\n        }],\n        time: 'Sun, 14 Jan 2018 11:17:40 GMT',\n        total: 1\n      });\n    });","file":"integration/search.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should return a scoped foo private package","suites":["search","search authenticated"],"line":53,"code":"    test.each([['@scope/foo']])('should return a scoped foo private package', async pkg => {\n      const mockDate = '2018-01-14T11:17:40.712Z';\n      MockDate.set(mockDate);\n      const res = await createUser(app, 'test', 'test');\n      await publishVersionWithToken(app, pkg, '1.0.0', res.body.token);\n      // this should not be displayed as part of the search\n      await publishVersionWithToken(app, '@private/auth', '1.0.0', res.body.token);\n      const response = await supertest(app).get(`/-/v1/search?text=${encodeURIComponent(pkg)}&size=2000&from=0&quality=1&popularity=0.1&maintenance=0.1`).set(HEADERS.ACCEPT, HEADERS.JSON).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HEADERS.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n      expect(response.body).toEqual({\n        objects: [{\n          package: {\n            author: {\n              email: 'user@domain.com',\n              name: 'User NPM'\n            },\n            date: mockDate,\n            description: 'package generated',\n            keywords: [],\n            links: {\n              npm: ''\n            },\n            name: pkg,\n            publisher: {},\n            scope: '@scope',\n            version: '1.0.0'\n          },\n          score: {\n            detail: {\n              maintenance: 0,\n              popularity: 1,\n              quality: 1\n            },\n            final: 1\n          },\n          searchScore: 1,\n          verdaccioPkgCached: false,\n          verdaccioPrivate: true\n        }],\n        time: 'Sun, 14 Jan 2018 11:17:40 GMT',\n        total: 1\n      });\n    });","file":"integration/search.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should able to abort the request","suites":["search","error handling"],"line":97,"code":"    test.todo('should able to abort the request');","file":"integration/search.spec.ts","skipped":true,"dir":"packages/api/test"},{"name":"should list stared packages for an user","suites":["star"],"line":7,"code":"  test.each([['foo', '@scope%2Ffoo']])('should list stared packages for an user', async pkgName => {\n    const userLogged = 'jota_token';\n    nock('https://registry.npmjs.org').get(`/${pkgName}`).reply(404);\n    const app = await initializeServer('star.yaml');\n    const token = await getNewToken(app, {\n      name: userLogged,\n      password: 'secretPass'\n    });\n    await publishVersion(app, pkgName, '1.0.0', undefined, token).expect(HTTP_STATUS.CREATED);\n    await publishVersion(app, 'pkg-1', '1.0.0', undefined, token).expect(HTTP_STATUS.CREATED);\n    await publishVersion(app, 'pkg-2', '1.0.0', undefined, token).expect(HTTP_STATUS.CREATED);\n    const manifest = await getPackage(app, '', decodeURIComponent(pkgName));\n    await starPackage(app, {\n      _rev: manifest.body._rev,\n      _id: manifest.body.id,\n      name: pkgName,\n      users: {\n        [userLogged]: true\n      }\n    }, token).expect(HTTP_STATUS.CREATED);\n    await starPackage(app, {\n      _rev: manifest.body._rev,\n      _id: manifest.body.id,\n      name: 'pkg-1',\n      users: {\n        [userLogged]: true\n      }\n    }, token).expect(HTTP_STATUS.CREATED);\n    await starPackage(app, {\n      _rev: manifest.body._rev,\n      _id: manifest.body.id,\n      name: 'pkg-2',\n      users: {\n        [userLogged]: true\n      }\n    }, token).expect(HTTP_STATUS.CREATED);\n    const resp = await supertest(app).get(`/-/_view/starredByUser?key=%22jota_token%22`).set('Accept', HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n    expect(resp.body.rows).toHaveLength(3);\n    expect(resp.body.rows).toEqual([{\n      value: 'foo'\n    }, {\n      value: 'pkg-1'\n    }, {\n      value: 'pkg-2'\n    }]);\n  });","file":"integration/star.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should requires parameters","suites":["star"],"line":53,"code":"  test.each([['foo']])('should requires parameters', async pkgName => {\n    const userLogged = 'jota_token';\n    nock('https://registry.npmjs.org').get(`/${pkgName}`).reply(404);\n    const app = await initializeServer('star.yaml');\n    const token = await getNewToken(app, {\n      name: userLogged,\n      password: 'secretPass'\n    });\n    await publishVersion(app, pkgName, '1.0.0', undefined, token).expect(HTTP_STATUS.CREATED);\n    return supertest(app).get(`/-/_view/starredByUser?key_xxxxx=other`).set('Accept', HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.BAD_REQUEST);\n  });","file":"integration/star.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should list empty tokens","suites":["token","basics"],"line":8,"code":"    test.each([['token.yaml'], ['token.jwt.yaml']])('should list empty tokens', async conf => {\n      const app = await initializeServer(conf);\n      const token = await getNewToken(app, {\n        name: 'jota_token',\n        password: 'secretPass'\n      });\n      const response = await supertest(app).get('/-/npm/v1/tokens').set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n      expect(response.body.objects).toHaveLength(0);\n    });","file":"integration/token.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should generate one token","suites":["token","basics"],"line":17,"code":"    test.each([['token.yaml'], ['token.jwt.yaml']])('should generate one token', async conf => {\n      const app = await initializeServer(conf);\n      const credentials = {\n        name: 'jota_token',\n        password: 'secretPass'\n      };\n      const token = await getNewToken(app, credentials);\n      await generateTokenCLI(app, token, {\n        password: credentials.password,\n        readonly: false,\n        cidr_whitelist: []\n      });\n      const response = await supertest(app).get('/-/npm/v1/tokens').set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n      const {\n        objects,\n        urls\n      } = response.body;\n      expect(objects).toHaveLength(1);\n      const [tokenGenerated] = objects;\n      expect(tokenGenerated.user).toEqual(credentials.name);\n      expect(tokenGenerated.readonly).toBeFalsy();\n      expect(tokenGenerated.token).toMatch(/.../);\n      expect(_.isString(tokenGenerated.created)).toBeTruthy();\n\n      // we don't support pagination yet\n      expect(urls.next).toEqual('');\n    });","file":"integration/token.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should delete a token","suites":["token","basics"],"line":44,"code":"    test.each([['token.yaml'], ['token.jwt.yaml']])('should delete a token', async conf => {\n      const app = await initializeServer(conf);\n      const credentials = {\n        name: 'jota_token',\n        password: 'secretPass'\n      };\n      const token = await getNewToken(app, credentials);\n      const response = await generateTokenCLI(app, token, {\n        password: credentials.password,\n        readonly: false,\n        cidr_whitelist: []\n      });\n      const key = response.body.key;\n      await deleteTokenCLI(app, token, key);\n      const response2 = await supertest(app).get('/-/npm/v1/tokens').set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n      const {\n        objects\n      } = response2.body;\n      expect(objects).toHaveLength(0);\n    });","file":"integration/token.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should delete a token","suites":["token","handle errors"],"line":66,"code":"    test.each([['token.yaml'], ['token.jwt.yaml']])('should delete a token', async conf => {\n      const app = await initializeServer(conf);\n      const credentials = {\n        name: 'jota_token',\n        password: 'secretPass'\n      };\n      const token = await getNewToken(app, credentials);\n      const resp = await generateTokenCLI(app, token, {\n        password: 'wrongPassword',\n        readonly: false,\n        cidr_whitelist: []\n      });\n      expect(resp.body.error).toEqual(API_ERROR.BAD_USERNAME_PASSWORD);\n    });","file":"integration/token.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fail if readonly is missing","suites":["token","handle errors"],"line":80,"code":"    test.each([['token.yaml'], ['token.jwt.yaml']])('should fail if readonly is missing', async conf => {\n      const app = await initializeServer(conf);\n      const credentials = {\n        name: 'jota_token',\n        password: 'secretPass'\n      };\n      const token = await getNewToken(app, credentials);\n      const resp = await generateTokenCLI(app, token, {\n        password: credentials.password,\n        cidr_whitelist: []\n      });\n      expect(resp.body.error).toEqual(SUPPORT_ERRORS.PARAMETERS_NOT_VALID);\n    });","file":"integration/token.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fail if cidr_whitelist is missing","suites":["token","handle errors"],"line":94,"code":"  test.each([['token.yaml'], ['token.jwt.yaml']])('should fail if cidr_whitelist is missing', async conf => {\n    const app = await initializeServer(conf);\n    const credentials = {\n      name: 'jota_token',\n      password: 'secretPass'\n    };\n    const token = await getNewToken(app, credentials);\n    const resp = await generateTokenCLI(app, token, {\n      password: credentials.password,\n      readonly: false\n    });\n    expect(resp.body.error).toEqual(SUPPORT_ERRORS.PARAMETERS_NOT_VALID);\n  });","file":"integration/token.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"handle failure if delete token","suites":["token","handle errors"],"line":107,"code":"  test.todo('handle failure if delete token');","file":"integration/token.spec.ts","skipped":true,"dir":"packages/api/test"},{"name":"handle failure if getApiToken fails","suites":["token","handle errors"],"line":108,"code":"  test.todo('handle failure if getApiToken fails');","file":"integration/token.spec.ts","skipped":true,"dir":"packages/api/test"},{"name":"handle failure if token creating fails","suites":["token","handle errors"],"line":109,"code":"  test.todo('handle failure if token creating fails');","file":"integration/token.spec.ts","skipped":true,"dir":"packages/api/test"},{"name":"handle failure if token list fails","suites":["token","handle errors"],"line":110,"code":"  test.todo('handle failure if token list fails');","file":"integration/token.spec.ts","skipped":true,"dir":"packages/api/test"},{"name":"should test add a new user","suites":["token","basics"],"line":10,"code":"    test.each([['user.yaml'], ['user.jwt.yaml']])('should test add a new user', async conf => {\n      const app = await initializeServer(conf);\n      const credentials = {\n        name: 'JotaJWT',\n        password: 'secretPass'\n      };\n      const response = await createUser(app, credentials.name, credentials.password);\n      expect(response.body.ok).toMatch(`user '${credentials.name}' created`);\n      const vueResponse = await getPackage(app, response.body.token, 'vue');\n      expect(vueResponse.body).toBeDefined();\n      expect(vueResponse.body.name).toMatch('vue');\n      const vueFailResp = await getPackage(app, FAKE_TOKEN, 'vue', HTTP_STATUS.UNAUTHORIZED);\n      expect(vueFailResp.body.error).toMatch(FORBIDDEN_VUE);\n    });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should login an user","suites":["token","basics"],"line":24,"code":"    test.each([['user.yaml'], ['user.jwt.yaml']])('should login an user', async conf => {\n      const app = await initializeServer(conf);\n      const credentials = {\n        name: 'test',\n        password: 'test'\n      };\n      const response = await createUser(app, credentials.name, credentials.password);\n      expect(response.body.ok).toMatch(`user '${credentials.name}' created`);\n      await supertest(app).put(`/-/user/org.couchdb.user:${credentials.name}`).send({\n        name: credentials.name,\n        password: credentials.password\n      }).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, response.body.token)).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.CREATED);\n    });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails login a valid user","suites":["token","basics"],"line":37,"code":"    test.each([['user.yaml'], ['user.jwt.yaml']])('should fails login a valid user', async conf => {\n      const app = await initializeServer(conf);\n      const credentials = {\n        name: 'test',\n        password: 'test'\n      };\n      const response = await createUser(app, credentials.name, credentials.password);\n      expect(response.body.ok).toMatch(`user '${credentials.name}' created`);\n      await supertest(app).put(`/-/user/org.couchdb.user:${credentials.name}`).send({\n        name: credentials.name,\n        password: 'failPassword'\n      }).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, response.body.token)).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.UNAUTHORIZED);\n    });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should test conflict create new user","suites":["token","basics"],"line":50,"code":"    test.each([['user.yaml'], ['user.jwt.yaml']])('should test conflict create new user', async conf => {\n      const app = await initializeServer(conf);\n      const credentials = {\n        name: 'JotaJWT',\n        password: 'secretPass'\n      };\n      const response = await createUser(app, credentials.name, credentials.password);\n      expect(response.body.ok).toMatch(`user '${credentials.name}' created`);\n      const response2 = await supertest(app).put(`/-/user/org.couchdb.user:${credentials.name}`).send({\n        name: credentials.name,\n        password: credentials.password\n      }).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.CONFLICT);\n      expect(response2.body.error).toBe(API_ERROR.USERNAME_ALREADY_REGISTERED);\n    });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails on login if user credentials are invalid","suites":["token","basics"],"line":64,"code":"    test.each([['user.yaml'], ['user.jwt.yaml']])('should fails on login if user credentials are invalid', async conf => {\n      const app = await initializeServer(conf);\n      const credentials = {\n        name: 'newFailsUser',\n        password: 'secretPass'\n      };\n      const response = await createUser(app, credentials.name, credentials.password);\n      expect(response.body.ok).toMatch(`user '${credentials.name}' created`);\n      const response2 = await supertest(app).put(`/-/user/org.couchdb.user:${credentials.name}`).send({\n        name: credentials.name,\n        password: 'BAD_PASSWORD'\n      }).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.UNAUTHORIZED);\n      expect(response2.body.error).toBe(API_ERROR.UNAUTHORIZED_ACCESS);\n    });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails password validation","suites":["token","basics"],"line":78,"code":"    test.each([['user.yaml'], ['user.jwt.yaml']])('should fails password validation', async conf => {\n      const credentials = {\n        name: 'test',\n        password: '12'\n      };\n      const app = await initializeServer(conf);\n      const response = await supertest(app).put(`/-/user/org.couchdb.user:${credentials.name}`).send({\n        name: credentials.name,\n        password: credentials.password\n      }).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.BAD_REQUEST);\n      expect(response.body.error).toBe(API_ERROR.PASSWORD_SHORT);\n    });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails missing password validation","suites":["token","basics"],"line":90,"code":"    test.each([['user.yaml'], ['user.jwt.yaml']])('should fails missing password validation', async conf => {\n      const credentials = {\n        name: 'test'\n      };\n      const app = await initializeServer(conf);\n      const response = await supertest(app).put(`/-/user/org.couchdb.user:${credentials.name}`).send({\n        name: credentials.name,\n        password: undefined\n      }).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.BAD_REQUEST);\n      expect(response.body.error).toBe(API_ERROR.PASSWORD_SHORT);\n    });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should verify if user is logged","suites":["token","basics"],"line":101,"code":"    test.each([['user.yaml'], ['user.jwt.yaml']])('should verify if user is logged', async conf => {\n      const app = await initializeServer(conf);\n      const credentials = {\n        name: 'jota',\n        password: 'secretPass'\n      };\n      const response = await createUser(app, credentials.name, credentials.password);\n      expect(response.body.ok).toMatch(`user '${credentials.name}' created`);\n      const response2 = await supertest(app).get(`/-/user/org.couchdb.user:${credentials.name}`).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, response.body.token)).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n      expect(response2.body.ok).toBe(`you are authenticated as '${credentials.name}'`);\n    });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should logout user","suites":["token","basics"],"line":112,"code":"    test.each([['user.yaml'], ['user.jwt.yaml']])('should logout user', async conf => {\n      const app = await initializeServer(conf);\n      const credentials = {\n        name: 'jota',\n        password: 'secretPass'\n      };\n      const response = await createUser(app, credentials.name, credentials.password);\n      await supertest(app).get(`/-/user/org.couchdb.user:${credentials.name}`).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, response.body.token)).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n      await supertest(app).delete(`/-/user/token/someSecretToken:${response.body.token}`).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK);\n    });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should return the logged username","suites":["whoami"],"updatePoint":{"line":6,"column":41,"index":279},"line":6,"code":"  test('should return the logged username', async () => {\n    const app = await initializeServer('whoami.yaml');\n    // @ts-expect-error internal property\n    const {\n      _body\n    } = await createUser(app, 'test', 'test');\n    return supertest(app).get('/-/whoami').set('Accept', HEADERS.JSON).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, _body.token)).expect('Content-Type', HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).then(response => {\n      expect(response.body.username).toEqual('test');\n    });\n  });","file":"integration/whoami.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails with 401 if is not logged in","suites":["whoami"],"updatePoint":{"line":16,"column":49,"index":805},"line":16,"code":"  test('should fails with 401 if is not logged in', async () => {\n    const app = await initializeServer('whoami.yaml');\n    // @ts-expect-error internal property\n    const {\n      _body\n    } = await createUser(app, 'test', 'test');\n    return supertest(app).get('/-/whoami').set('Accept', HEADERS.JSON).set(HEADERS.AUTHORIZATION, buildToken('invalid-token', _body.token)).expect('Content-Type', HEADERS.JSON_CHARSET).expect(HTTP_STATUS.UNAUTHORIZED);\n  });","file":"integration/whoami.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should validate \":%s\"","suites":["api endpoint app.param()"],"line":36,"code":"  test.each(Object.keys(appParams))('should validate \":%s\"', param => {\n    expect(appParams[param]).toEqual('ok');\n  });","file":"unit/validate.api.params.middleware.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"authentication should fail by default (default)","suites":["Auth utilities","getDefaultPlugins"],"updatePoint":{"line":127,"column":57},"line":127,"code":"    test('authentication should fail by default (default)', () => {\n      const plugin = getDefaultPlugins({ trace: jest.fn() });\n      plugin.authenticate('foo', 'bar', (error: any) => {\n        expect(error).toEqual(errorUtils.getForbidden(API_ERROR.BAD_USERNAME_PASSWORD));\n      });\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"add user should fail by default (default)","suites":["Auth utilities","getDefaultPlugins"],"updatePoint":{"line":134,"column":51},"line":134,"code":"    test('add user should fail by default (default)', () => {\n      const plugin = getDefaultPlugins({ trace: jest.fn() });\n      // @ts-ignore\n      plugin.adduser('foo', 'bar', (error: any) => {\n        expect(error).toEqual(errorUtils.getForbidden(API_ERROR.BAD_USERNAME_PASSWORD));\n      });\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should restrict %s to anonymous users","suites":["Auth utilities","allow_action","access/publish/unpublish and anonymous"],"line":153,"code":"      test.each(['access', 'publish', 'unpublish'])(\n        'should restrict %s to anonymous users',\n        (type) => {\n          allow_action(type as ActionsAllowed, { trace: jest.fn() })(\n            createAnonymousRemoteUser(),\n            {\n              ...packageAccess,\n              [type]: ['foo'],\n            },\n            (error: VerdaccioError | null, allowed: AllowActionCallbackResponse) => {\n              expect(error).not.toBeNull();\n              expect(allowed).toBeUndefined();\n            }\n          );\n        }\n      );","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should allow %s to anonymous users","suites":["Auth utilities","allow_action","access/publish/unpublish and anonymous"],"line":170,"code":"      test.each(['access', 'publish', 'unpublish'])(\n        'should allow %s to anonymous users',\n        (type) => {\n          allow_action(type as ActionsAllowed, { trace: jest.fn() })(\n            createAnonymousRemoteUser(),\n            {\n              ...packageAccess,\n              [type]: [ROLES.$ANONYMOUS],\n            },\n            (error: VerdaccioError | null, allowed: AllowActionCallbackResponse) => {\n              expect(error).toBeNull();\n              expect(allowed).toBe(true);\n            }\n          );\n        }\n      );","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should allow %s only if user is anonymous if the logged user has groups","suites":["Auth utilities","allow_action","access/publish/unpublish and anonymous"],"line":187,"code":"      test.each(['access', 'publish', 'unpublish'])(\n        'should allow %s only if user is anonymous if the logged user has groups',\n        (type) => {\n          allow_action(type as ActionsAllowed, { trace: jest.fn() })(\n            createRemoteUser('juan', ['maintainer', 'admin']),\n            {\n              ...packageAccess,\n              [type]: [ROLES.$ANONYMOUS],\n            },\n            (error: VerdaccioError | null, allowed: AllowActionCallbackResponse) => {\n              expect(error).not.toBeNull();\n              expect(allowed).toBeUndefined();\n            }\n          );\n        }\n      );","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should allow %s only if user is anonymous match any other groups","suites":["Auth utilities","allow_action","access/publish/unpublish and anonymous"],"line":204,"code":"      test.each(['access', 'publish', 'unpublish'])(\n        'should allow %s only if user is anonymous match any other groups',\n        (type) => {\n          allow_action(type as ActionsAllowed, { trace: jest.fn() })(\n            createRemoteUser('juan', ['maintainer', 'admin']),\n            {\n              ...packageAccess,\n              [type]: ['admin', 'some-other-group', ROLES.$ANONYMOUS],\n            },\n            (error: VerdaccioError | null, allowed: AllowActionCallbackResponse) => {\n              expect(error).toBeNull();\n              expect(allowed).toBe(true);\n            }\n          );\n        }\n      );","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should not allow %s anonymous if other groups are defined and does not match","suites":["Auth utilities","allow_action","access/publish/unpublish and anonymous"],"line":221,"code":"      test.each(['access', 'publish', 'unpublish'])(\n        'should not allow %s anonymous if other groups are defined and does not match',\n        (type) => {\n          allow_action(type as ActionsAllowed, { trace: jest.fn() })(\n            createRemoteUser('juan', ['maintainer', 'admin']),\n            {\n              ...packageAccess,\n              [type]: ['bla-bla-group', 'some-other-group', ROLES.$ANONYMOUS],\n            },\n            (error: VerdaccioError | null, allowed: AllowActionCallbackResponse) => {\n              expect(error).not.toBeNull();\n              expect(allowed).toBeUndefined();\n            }\n          );\n        }\n      );","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"create remote user","suites":["Auth utilities","createRemoteUser"],"updatePoint":{"line":241,"column":28},"line":241,"code":"    test('create remote user', () => {\n      expect(createRemoteUser('test', [])).toEqual({\n        name: 'test',\n        real_groups: [],\n        groups: ['$all', '$authenticated', '@all', '@authenticated', 'all'],\n      });\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"create remote user with groups","suites":["Auth utilities","createRemoteUser"],"updatePoint":{"line":248,"column":40},"line":248,"code":"    test('create remote user with groups', () => {\n      expect(createRemoteUser('test', ['group1', 'group2'])).toEqual({\n        name: 'test',\n        real_groups: ['group1', 'group2'],\n        groups: ['group1', 'group2', '$all', '$authenticated', '@all', '@authenticated', 'all'],\n      });\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"create anonymous remote user","suites":["Auth utilities","createRemoteUser"],"updatePoint":{"line":255,"column":38},"line":255,"code":"    test('create anonymous remote user', () => {\n      expect(createAnonymousRemoteUser()).toEqual({\n        name: undefined,\n        real_groups: [],\n        groups: ['$all', '$anonymous', '@all', '@anonymous'],\n      });\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with aes and security missing","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":265,"column":57},"line":265,"code":"    test('should sign token with aes and security missing', async () => {\n      const token = await getTokenByConfiguration(\n        'security-missing',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'aesEncrypt',\n        'jwtEncrypt'\n      );\n\n      verifyAES(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n      expect(_.isString(token)).toBeTruthy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with aes and security empty","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":279,"column":55},"line":279,"code":"    test('should sign token with aes and security empty', async () => {\n      const token = await getTokenByConfiguration(\n        'security-empty',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'aesEncrypt',\n        'jwtEncrypt'\n      );\n\n      verifyAES(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n      expect(_.isString(token)).toBeTruthy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with aes","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":293,"column":36},"line":293,"code":"    test('should sign token with aes', async () => {\n      const token = await getTokenByConfiguration(\n        'security-basic',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'aesEncrypt',\n        'jwtEncrypt'\n      );\n\n      verifyAES(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n      expect(_.isString(token)).toBeTruthy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with legacy and jwt disabled","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":307,"column":56},"line":307,"code":"    test('should sign token with legacy and jwt disabled', async () => {\n      const token = await getTokenByConfiguration(\n        'security-no-legacy',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'aesEncrypt',\n        'jwtEncrypt'\n      );\n\n      expect(_.isString(token)).toBeTruthy();\n      verifyAES(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with legacy enabled and jwt enabled","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":321,"column":63},"line":321,"code":"    test('should sign token with legacy enabled and jwt enabled', async () => {\n      const token = await getTokenByConfiguration(\n        'security-jwt-legacy-enabled',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'jwtEncrypt',\n        'aesEncrypt'\n      );\n\n      verifyJWT(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n      expect(_.isString(token)).toBeTruthy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with jwt enabled","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":335,"column":44},"line":335,"code":"    test('should sign token with jwt enabled', async () => {\n      const token = await getTokenByConfiguration(\n        'security-jwt',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'jwtEncrypt',\n        'aesEncrypt'\n      );\n\n      expect(_.isString(token)).toBeTruthy();\n      verifyJWT(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign with jwt whether legacy is disabled","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":349,"column":57},"line":349,"code":"    test('should sign with jwt whether legacy is disabled', async () => {\n      const token = await getTokenByConfiguration(\n        'security-legacy-disabled',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'jwtEncrypt',\n        'aesEncrypt'\n      );\n\n      expect(_.isString(token)).toBeTruthy();\n      verifyJWT(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with jwt enabled","suites":["Auth utilities","getAuthenticatedMessage test"],"updatePoint":{"line":365,"column":44},"line":365,"code":"    test('should sign token with jwt enabled', () => {\n      expect(getAuthenticatedMessage('test')).toBe(\"you are authenticated as 'test'\");\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should fail on verify the token and return anonymous users","suites":["Auth utilities","getMiddlewareCredentials test","verifyJWTPayload"],"updatePoint":{"line":467,"column":70},"line":467,"code":"      test('should fail on verify the token and return anonymous users', () => {\n        expect(verifyJWTPayload('fakeToken', 'b2df428b9929d3ace7c598bbf4e496b2')).toEqual(\n          createAnonymousRemoteUser()\n        );\n      });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should verify the token and return a remote user","suites":["Auth utilities","getMiddlewareCredentials test","verifyJWTPayload"],"updatePoint":{"line":473,"column":60},"line":473,"code":"      test('should verify the token and return a remote user', async () => {\n        const remoteUser = createRemoteUser('foo', []);\n        const token = await signPayload(remoteUser, '12345');\n        const verifiedToken = verifyJWTPayload(token, '12345');\n        expect(verifiedToken.groups).toEqual(remoteUser.groups);\n        expect(verifiedToken.name).toEqual(remoteUser.name);\n      });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should return anonymous whether token is corrupted","suites":["Auth utilities","getMiddlewareCredentials test","should get JWT credentials"],"updatePoint":{"line":483,"column":62},"line":483,"code":"      test('should return anonymous whether token is corrupted', () => {\n        const config: Config = getConfig('security-jwt', '12345');\n        const security: Security = config.security;\n        const credentials = getMiddlewareCredentials(\n          security,\n          '12345',\n          buildToken(TOKEN_BEARER, 'fakeToken')\n        ) as RemoteUser;\n\n        expect(credentials).toBeDefined();\n        expect(credentials.name).not.toBeDefined();\n        expect(credentials.real_groups).toBeDefined();\n\n        expect(credentials.groups).toEqual(['$all', '$anonymous', '@all', '@anonymous']);\n      });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should return anonymous whether token and scheme are corrupted","suites":["Auth utilities","getMiddlewareCredentials test","should get JWT credentials"],"updatePoint":{"line":499,"column":74},"line":499,"code":"      test('should return anonymous whether token and scheme are corrupted', () => {\n        const config: Config = getConfig('security-jwt', '12345');\n        const security: Security = config.security;\n        const credentials = getMiddlewareCredentials(\n          security,\n          '12345',\n          buildToken('FakeScheme', 'fakeToken')\n        );\n\n        expect(credentials).not.toBeDefined();\n      });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should verify successfully a JWT token","suites":["Auth utilities","getMiddlewareCredentials test","should get JWT credentials"],"updatePoint":{"line":511,"column":50},"line":511,"code":"      test('should verify successfully a JWT token', async () => {\n        const secret = 'b2df428b9929d3ace7c598bbf4e496b2';\n        const user = 'test';\n        const config: Config = getConfig('security-jwt', secret);\n        const token = await getTokenByConfiguration(\n          'security-jwt',\n          user,\n          'secretTest',\n          secret,\n          'jwtEncrypt',\n          'aesEncrypt'\n        );\n        const security: Security = config.security;\n        const credentials = getMiddlewareCredentials(\n          security,\n          secret,\n          buildToken(TOKEN_BEARER, token)\n        ) as RemoteUser;\n        expect(credentials).toBeDefined();\n\n        expect(credentials.name).toEqual(user);\n        expect(credentials.real_groups).toBeDefined();\n        expect(credentials.real_groups).toEqual([\n          'test',\n          '$all',\n          '$authenticated',\n          '@all',\n          '@authenticated',\n          'all',\n        ]);\n        expect(credentials.groups).toEqual([\n          'company-role1',\n          'company-role2',\n          'test',\n          '$all',\n          '$authenticated',\n          '@all',\n          '@authenticated',\n          'all',\n        ]);\n      });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should init correctly","suites":["AuthTest"],"updatePoint":{"line":14,"column":29},"line":14,"code":"  test('should init correctly', async () => {\n    const config: Config = new AppConfig({ ...authProfileConf });\n    config.checkSecretKey('12345');\n\n    const auth: Auth = new Auth(config);\n    await auth.init();\n    expect(auth).toBeDefined();\n  });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should load default auth plugin","suites":["AuthTest"],"updatePoint":{"line":23,"column":39},"line":23,"code":"  test('should load default auth plugin', async () => {\n    const config: Config = new AppConfig({ ...authProfileConf, auth: undefined });\n    config.checkSecretKey('12345');\n\n    const auth: Auth = new Auth(config);\n    await auth.init();\n    expect(auth).toBeDefined();\n  });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should be a success login","suites":["AuthTest","test authenticate method","test authenticate states"],"updatePoint":{"line":34,"column":37},"line":34,"code":"      test('should be a success login', async () => {\n        const config: Config = new AppConfig({ ...authProfileConf });\n        config.checkSecretKey('12345');\n        const auth: Auth = new Auth(config);\n        await auth.init();\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n        const groups = ['test'];\n\n        auth.authenticate('foo', 'bar', callback);\n\n        expect(callback).toHaveBeenCalledTimes(1);\n        expect(callback).toHaveBeenCalledWith(null, {\n          groups: [\n            'test',\n            ROLES.$ALL,\n            ROLES.$AUTH,\n            ROLES.DEPRECATED_ALL,\n            ROLES.DEPRECATED_AUTH,\n            ROLES.ALL,\n          ],\n          name: 'foo',\n          real_groups: groups,\n        });\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should be a fail on login","suites":["AuthTest","test authenticate method","test authenticate states"],"updatePoint":{"line":61,"column":37},"line":61,"code":"      test('should be a fail on login', async () => {\n        const config: Config = new AppConfig(authPluginFailureConf);\n        config.checkSecretKey('12345');\n        const auth: Auth = new Auth(config);\n        await auth.init();\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n\n        auth.authenticate('foo', 'bar', callback);\n        expect(callback).toHaveBeenCalledTimes(1);\n        expect(callback).toHaveBeenCalledWith(errorUtils.getInternalError());\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should skip falsy values","suites":["AuthTest","test authenticate method","test authenticate out of control inputs from plugins"],"updatePoint":{"line":80,"column":36},"line":80,"code":"      test('should skip falsy values', async () => {\n        const config: Config = new AppConfig({ ...authPluginPassThrougConf });\n        config.checkSecretKey('12345');\n        const auth: Auth = new Auth(config);\n        await auth.init();\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n        let index = 0;\n\n        // as defined by https://developer.mozilla.org/en-US/docs/Glossary/Falsy\n        for (const value of [false, 0, '', null, undefined, NaN]) {\n          // @ts-ignore\n          auth.authenticate(null, value, callback);\n          const call = callback.mock.calls[index++];\n          expect(call[0]).toBeDefined();\n          expect(call[1]).toBeUndefined();\n        }\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should error truthy non-array","suites":["AuthTest","test authenticate method","test authenticate out of control inputs from plugins"],"updatePoint":{"line":100,"column":41},"line":100,"code":"      test('should error truthy non-array', async () => {\n        const config: Config = new AppConfig({ ...authPluginPassThrougConf });\n        config.checkSecretKey('12345');\n        const auth: Auth = new Auth(config);\n        await auth.init();\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n\n        for (const value of [true, 1, 'test', {}]) {\n          expect(function () {\n            // @ts-ignore\n            auth.authenticate(null, value, callback);\n          }).toThrow(TypeError);\n          expect(callback).not.toHaveBeenCalled();\n        }\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should skip empty array","suites":["AuthTest","test authenticate method","test authenticate out of control inputs from plugins"],"updatePoint":{"line":118,"column":35},"line":118,"code":"      test('should skip empty array', async () => {\n        const config: Config = new AppConfig({ ...authPluginPassThrougConf });\n        config.checkSecretKey('12345');\n        const auth: Auth = new Auth(config);\n        await auth.init();\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n        const value = [];\n\n        // @ts-ignore\n        auth.authenticate(null, value, callback);\n        expect(callback.mock.calls).toHaveLength(1);\n        expect(callback.mock.calls[0][0]).toBeDefined();\n        expect(callback.mock.calls[0][1]).toBeUndefined();\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should accept valid array","suites":["AuthTest","test authenticate method","test authenticate out of control inputs from plugins"],"updatePoint":{"line":135,"column":37},"line":135,"code":"      test('should accept valid array', async () => {\n        const config: Config = new AppConfig({ ...authPluginPassThrougConf });\n        config.checkSecretKey('12345');\n        const auth: Auth = new Auth(config);\n        await auth.init();\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n        let index = 0;\n\n        for (const value of [[''], ['1'], ['0'], ['000']]) {\n          // @ts-ignore\n          auth.authenticate(null, value, callback);\n          const call = callback.mock.calls[index++];\n          expect(call[0]).toBeNull();\n          expect(call[1].real_groups).toBe(value);\n        }\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should skip falsy values","suites":["AuthTest","test multiple authenticate methods"],"updatePoint":{"line":157,"column":34},"line":157,"code":"    test('should skip falsy values', async () => {\n      const config: Config = new AppConfig({\n        ...getDefaultConfig(),\n        plugins: path.join(__dirname, './partials/plugin'),\n        auth: {\n          success: {},\n          'fail-invalid-method': {},\n        },\n      });\n      config.checkSecretKey('12345');\n      const auth: Auth = new Auth(config);\n      await auth.init();\n\n      return new Promise((resolve) => {\n        auth.authenticate('foo', 'bar', (err, value) => {\n          expect(value).toEqual({\n            name: 'foo',\n            groups: ['test', '$all', '$authenticated', '@all', '@authenticated', 'all'],\n            real_groups: ['test'],\n          });\n          resolve(value);\n        });\n      });\n    });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"decrypt payload flow","suites":["test crypto utils"],"updatePoint":{"line":4,"column":28},"line":4,"code":"  test('decrypt payload flow', () => {\n    const secret = 'f5bb945cc57fea2f25961e1bd6fb3c89';\n    const payload = 'juan:password';\n    const token = aesEncrypt(payload, secret) as string;\n    const data = aesDecrypt(token, secret);\n\n    expect(payload).toEqual(data);\n  });","file":"legacy-token.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"crypt fails if secret is incorrect","suites":["test crypto utils"],"updatePoint":{"line":13,"column":42},"line":13,"code":"  test('crypt fails if secret is incorrect', () => {\n    const secret = 'f5bb945cc57fea2f25961e1bd6fb3c89_TO_LONG';\n    const payload = 'juan';\n    const token = aesEncrypt(payload, secret) as string;\n    expect(token).toBeUndefined();\n  });","file":"legacy-token.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"write some test for this module","suites":["cli test"],"line":2,"code":"  test.todo('write some test for this module');","file":"cli-test.spec.ts","skipped":true,"dir":"packages/cli/test"},{"name":"valid version node.js","suites":[],"updatePoint":{"line":3,"column":27},"line":3,"code":"test('valid version node.js', () => {\n  expect(isVersionValid('v14.0.0')).toBeTruthy();\n  expect(isVersionValid('v15.0.0')).toBeTruthy();\n  expect(isVersionValid('v16.0.0')).toBeTruthy();\n  expect(isVersionValid('v17.0.0')).toBeTruthy();\n});","file":"utils.spec.ts","skipped":false,"dir":"packages/cli/test"},{"name":"is invalid version node.js","suites":[],"updatePoint":{"line":10,"column":32},"line":10,"code":"test('is invalid version node.js', () => {\n  expect(isVersionValid('v13.0.0')).toBeFalsy();\n  expect(isVersionValid('v12.0.0')).toBeFalsy();\n  expect(isVersionValid('v8.0.0')).toBeFalsy();\n  expect(isVersionValid('v4.0.0')).toBeFalsy();\n  expect(isVersionValid('v0.0.10')).toBeFalsy();\n});","file":"utils.spec.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should create a configuration file as object","suites":["Config builder"],"updatePoint":{"line":4,"column":52},"line":4,"code":"  test('should create a configuration file as object', () => {\n    const config = ConfigBuilder.build();\n    config\n      .addUplink('upstream', { url: 'https://registry.verdaccio.org' })\n      .addUplink('upstream2', { url: 'https://registry.verdaccio.org' })\n      .addPackageAccess('upstream/*', {\n        access: 'public',\n        publish: 'foo, bar',\n        unpublish: 'foo, bar',\n        proxy: 'some',\n      })\n      .addLogger({ level: 'info', type: 'stdout', format: 'json' })\n      .addStorage('/tmp/verdaccio')\n      .addSecurity({ api: { legacy: true } });\n    expect(config.getConfig()).toEqual({\n      security: {\n        api: {\n          legacy: true,\n        },\n      },\n      storage: '/tmp/verdaccio',\n      packages: {\n        'upstream/*': {\n          access: 'public',\n          publish: 'foo, bar',\n          unpublish: 'foo, bar',\n          proxy: 'some',\n        },\n      },\n      uplinks: {\n        upstream: {\n          url: 'https://registry.verdaccio.org',\n        },\n        upstream2: {\n          url: 'https://registry.verdaccio.org',\n        },\n      },\n      log: {\n        level: 'info',\n        type: 'stdout',\n        format: 'json',\n      },\n    });\n  });","file":"builder.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should create a configuration file as yaml","suites":["Config builder"],"updatePoint":{"line":49,"column":50},"line":49,"code":"  test('should create a configuration file as yaml', () => {\n    const config = ConfigBuilder.build();\n    config\n      .addUplink('upstream', { url: 'https://registry.verdaccio.org' })\n      .addUplink('upstream2', { url: 'https://registry.verdaccio.org' })\n      .addPackageAccess('upstream/*', {\n        access: 'public',\n        publish: 'foo, bar',\n        unpublish: 'foo, bar',\n        proxy: 'some',\n      })\n      .addLogger({ level: 'info', type: 'stdout', format: 'json' })\n      .addStorage('/tmp/verdaccio')\n      .addSecurity({ api: { legacy: true } });\n    expect(config.getAsYaml()).toMatchSnapshot();\n  });","file":"builder.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse default.json","suites":["parse","parseConfigFile","JSON format"],"updatePoint":{"line":14,"column":30},"line":14,"code":"      test('parse default.json', () => {\n        const config = parseConfigFile(parseConfigurationFile('default.json'));\n\n        expect(config.storage).toBeDefined();\n      });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse invalid.json","suites":["parse","parseConfigFile","JSON format"],"updatePoint":{"line":20,"column":30},"line":20,"code":"      test('parse invalid.json', () => {\n        expect(function () {\n          parseConfigFile(parseConfigurationFile('invalid.json'));\n        }).toThrow(new RegExp(/CONFIG: it does not look like a valid config file/));\n      });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse not-exists.json","suites":["parse","parseConfigFile","JSON format"],"updatePoint":{"line":26,"column":33},"line":26,"code":"      test('parse not-exists.json', () => {\n        expect(function () {\n          parseConfigFile(parseConfigurationFile('not-exists.json'));\n        }).toThrow(/config file does not exist or not reachable/);\n      });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse default.js","suites":["parse","parseConfigFile","JavaScript format"],"updatePoint":{"line":34,"column":28},"line":34,"code":"      test('parse default.js', () => {\n        const config = parseConfigFile(parseConfigurationFile('default.js'));\n\n        expect(config.storage).toBeDefined();\n      });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse invalid.js","suites":["parse","parseConfigFile","JavaScript format"],"updatePoint":{"line":40,"column":28},"line":40,"code":"      test('parse invalid.js', () => {\n        expect(function () {\n          parseConfigFile(parseConfigurationFile('invalid.js'));\n        }).toThrow(new RegExp(/CONFIG: it does not look like a valid config file/));\n      });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse not-exists.js","suites":["parse","parseConfigFile","JavaScript format"],"updatePoint":{"line":46,"column":31},"line":46,"code":"      test('parse not-exists.js', () => {\n        expect(function () {\n          parseConfigFile(parseConfigurationFile('not-exists.js'));\n        }).toThrow(/config file does not exist or not reachable/);\n      });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"basic conversion roundtrip","suites":["parse","fromJStoYAML"],"updatePoint":{"line":55,"column":36},"line":55,"code":"    test('basic conversion roundtrip', async () => {\n      // from to js to yaml\n      const config = require('./partials/config/js/from-js-to-yaml');\n      const yaml = fromJStoYAML(config) as string;\n      expect(yaml).toMatchSnapshot();\n      const tempFolder = await fileUtils.createTempFolder('fromJStoYAML-test');\n      const configPath = path.join(tempFolder, 'config.yaml');\n      await writeFile(configPath, yaml);\n      const parsed = parseConfigFile(configPath);\n      expect(parsed.configPath).toEqual(path.join(tempFolder, 'config.yaml'));\n      expect(parsed.storage).toEqual('./storage_default_storage');\n      expect(parsed.uplinks).toEqual({ npmjs: { url: 'http://localhost:4873/' } });\n      expect(parsed.log).toEqual({ type: 'stdout', format: 'pretty', level: 'warn' });\n    });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"folderExists","suites":["config-utils"],"updatePoint":{"line":6,"column":20},"line":6,"code":"  test('folderExists', () => {\n    expect(folderExists(path.join(__dirname, './partials/exist'))).toBeTruthy();\n  });","file":"config-utils.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"folderExists == false","suites":["config-utils"],"updatePoint":{"line":10,"column":29},"line":10,"code":"  test('folderExists == false', () => {\n    expect(folderExists(path.join(__dirname, './partials/NOT_exist'))).toBeFalsy();\n  });","file":"config-utils.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"fileExists","suites":["config-utils"],"updatePoint":{"line":14,"column":18},"line":14,"code":"  test('fileExists', () => {\n    expect(fileExists(path.join(__dirname, './partials/exist/README.md'))).toBeTruthy();\n  });","file":"config-utils.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"fileExists == false","suites":["config-utils"],"updatePoint":{"line":18,"column":27},"line":18,"code":"  test('fileExists == false', () => {\n    expect(fileExists(path.join(__dirname, './partials/exist/NOT_EXIST.md'))).toBeFalsy();\n  });","file":"config-utils.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with custom location","suites":["config-path","findConfigFile","using defiled location from arguments"],"updatePoint":{"line":38,"column":34},"line":38,"code":"        test('with custom location', () => {\n          expect(findConfigFile('/home/user/custom/location/config.yaml')).toEqual(\n            '/home/user/custom/location/config.yaml'\n          );\n          expect(mockwriteFile).not.toHaveBeenCalled();\n          expect(mockmkDir).not.toHaveBeenCalled();\n        });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with XDG_CONFIG_HOME if directory exist but config file is missing","suites":["config-path","findConfigFile","whith env variables"],"updatePoint":{"line":48,"column":80},"line":48,"code":"        test('with XDG_CONFIG_HOME if directory exist but config file is missing', () => {\n          process.env.XDG_CONFIG_HOME = '/home/user';\n          expect(findConfigFile()).toEqual('/home/user/verdaccio/config.yaml');\n          expect(mockwriteFile).toHaveBeenCalledWith('/home/user/verdaccio/config.yaml');\n          expect(mockmkDir).toHaveBeenCalledWith('/home/user/verdaccio');\n        });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with HOME if directory exist but config file is missing","suites":["config-path","findConfigFile","whith env variables"],"updatePoint":{"line":55,"column":69},"line":55,"code":"        test('with HOME if directory exist but config file is missing', () => {\n          delete process.env.XDG_CONFIG_HOME;\n          process.env.HOME = '/home/user';\n          expect(findConfigFile()).toEqual('/home/user/.config/verdaccio/config.yaml');\n          expect(mockwriteFile).toHaveBeenCalledWith('/home/user/.config/verdaccio/config.yaml');\n          expect(mockmkDir).toHaveBeenCalledWith('/home/user/.config/verdaccio');\n        });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"XDG_CONFIG_HOME is not directory fallback to default","suites":["config-path","findConfigFile","whith env variables","error handling"],"updatePoint":{"line":64,"column":68},"line":64,"code":"          test('XDG_CONFIG_HOME is not directory fallback to default', () => {\n            process.env.XDG_CONFIG_HOME = '/home/user/fail';\n            mockaccessSync.mockImplementation(() => {});\n            mockwriteFile.mockImplementation(() => {});\n            expect(findConfigFile()).toMatch('packages/config/verdaccio/config.yaml');\n          });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"no permissions on read default config file","suites":["config-path","findConfigFile","whith env variables","error handling"],"updatePoint":{"line":71,"column":58},"line":71,"code":"          test('no permissions on read default config file', () => {\n            process.env.XDG_CONFIG_HOME = '/home/user';\n            mockaccessSync.mockImplementation(() => {\n              throw new Error('error on write file');\n            });\n\n            expect(function () {\n              findConfigFile();\n            }).toThrow(/configuration file does not have enough permissions for reading/);\n          });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with relative location","suites":["config-path","findConfigFile","with no env variables"],"updatePoint":{"line":85,"column":36},"line":85,"code":"        test('with relative location', () => {\n          mockaccessSync.mockImplementation(() => {});\n          delete process.env.XDG_CONFIG_HOME;\n          delete process.env.HOME;\n          process.env.APPDATA = '/app/data/';\n          expect(findConfigFile()).toMatch('packages/config/verdaccio/config.yaml');\n          expect(mockwriteFile).toHaveBeenCalled();\n          expect(mockmkDir).toHaveBeenCalled();\n        });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with windows as directory exist but config file is missing","suites":["config-path","findConfigFile","with no env variables"],"updatePoint":{"line":96,"column":70},"line":96,"code":"      test('with windows as directory exist but config file is missing', () => {\n        delete process.env.XDG_CONFIG_HOME;\n        delete process.env.HOME;\n        process.env.APPDATA = '/app/data/';\n        expect(findConfigFile()).toMatch('\\\\app\\\\data\\\\verdaccio\\\\config.yaml');\n        expect(mockwriteFile).toHaveBeenCalled();\n        expect(mockmkDir).toHaveBeenCalled();\n      });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse default.yaml","suites":["check basic content parsed file"],"updatePoint":{"line":77,"column":26},"line":77,"code":"  test('parse default.yaml', () => {\n    const config = new Config(getDefaultConfig());\n    checkDefaultUplink(config);\n    expect(config.storage).toBe('./storage');\n    expect(config.auth.htpasswd.file).toBe('./htpasswd');\n    checkDefaultConfPackages(config);\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse docker.yaml","suites":["check basic content parsed file"],"updatePoint":{"line":85,"column":25},"line":85,"code":"  test('parse docker.yaml', () => {\n    const config = new Config(getDefaultConfig('docker.yaml'));\n    checkDefaultUplink(config);\n    expect(config.storage).toBe('/verdaccio/storage/data');\n    expect(config.auth.htpasswd.file).toBe('/verdaccio/storage/htpasswd');\n    checkDefaultConfPackages(config);\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with default.yaml and pre selected secret","suites":["checkSecretKey"],"updatePoint":{"line":95,"column":49},"line":95,"code":"  test('with default.yaml and pre selected secret', () => {\n    const config = new Config(parseConfigFile(resolveConf('default')));\n    expect(config.checkSecretKey('12345')).toEqual('12345');\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with default.yaml and void secret","suites":["checkSecretKey"],"updatePoint":{"line":100,"column":41},"line":100,"code":"  test('with default.yaml and void secret', () => {\n    const config = new Config(parseConfigFile(resolveConf('default')));\n    expect(typeof config.checkSecretKey() === 'string').toBeTruthy();\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with default.yaml and emtpy string secret","suites":["checkSecretKey"],"updatePoint":{"line":105,"column":49},"line":105,"code":"  test('with default.yaml and emtpy string secret', () => {\n    const config = new Config(parseConfigFile(resolveConf('default')));\n    expect(typeof config.checkSecretKey('') === 'string').toBeTruthy();\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should match with react as defined in config file","suites":["getMatchedPackagesSpec"],"updatePoint":{"line":112,"column":57},"line":112,"code":"  test('should match with react as defined in config file', () => {\n    const configParsed = parseConfigFile(parseConfigurationFile('config-getMatchedPackagesSpec'));\n    const config = new Config(configParsed);\n    expect(config.getMatchedPackagesSpec('react')).toEqual({\n      access: ['admin'],\n      proxy: ['facebook'],\n      publish: ['admin'],\n      unpublish: false,\n    });\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should not match with react as defined in config file","suites":["getMatchedPackagesSpec"],"updatePoint":{"line":123,"column":61},"line":123,"code":"  test('should not match with react as defined in config file', () => {\n    const configParsed = parseConfigFile(parseConfigurationFile('config-getMatchedPackagesSpec'));\n    const config = new Config(configParsed);\n    expect(config.getMatchedPackagesSpec('somePackage')).toEqual({\n      access: [ROLES.$ALL],\n      proxy: ['npmjs'],\n      publish: [ROLES.$AUTH],\n      unpublish: false,\n    });\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should set storage to value set in VERDACCIO_STORAGE_PATH environment variable","suites":["VERDACCIO_STORAGE_PATH"],"updatePoint":{"line":136,"column":86},"line":136,"code":"  test('should set storage to value set in VERDACCIO_STORAGE_PATH environment variable', () => {\n    const storageLocation = '/tmp/verdaccio';\n    process.env.VERDACCIO_STORAGE_PATH = storageLocation;\n    const config = new Config(parseConfigFile(resolveConf('default')));\n    expect(config.storage).toBe(storageLocation);\n    delete process.env.VERDACCIO_STORAGE_PATH;\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should set storage path to VERDACCIO_STORAGE_PATH if both config and env are set","suites":["VERDACCIO_STORAGE_PATH"],"updatePoint":{"line":144,"column":88},"line":144,"code":"  test('should set storage path to VERDACCIO_STORAGE_PATH if both config and env are set', () => {\n    const storageLocation = '/tmp/verdaccio';\n    process.env.VERDACCIO_STORAGE_PATH = storageLocation;\n    const config = new Config(parseConfigFile(parseConfigurationFile('storage')));\n    expect(config.storage).toBe(storageLocation);\n    delete process.env.VERDACCIO_STORAGE_PATH;\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should take storage from environment variable if not exists in configs","suites":["VERDACCIO_STORAGE_PATH"],"updatePoint":{"line":152,"column":78},"line":152,"code":"  test('should take storage from environment variable if not exists in configs', () => {\n    const storageLocation = '/tmp/verdaccio';\n    process.env.VERDACCIO_STORAGE_PATH = storageLocation;\n    const defaultConfig = parseConfigFile(resolveConf('default'));\n    delete defaultConfig.storage;\n    const config = new Config(defaultConfig);\n    expect(config.storage).toBe(storageLocation);\n    delete process.env.VERDACCIO_STORAGE_PATH;\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should test basic conversion","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":9,"column":38},"line":9,"code":"    test('should test basic conversion', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-basic'));\n      const access = normalisePackageAccess(packages);\n\n      expect(access).toBeDefined();\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n\n      expect(scoped).toBeDefined();\n      expect(all).toBeDefined();\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should define an empty publish array even if is not defined in packages","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":21,"column":81},"line":21,"code":"    test('should define an empty publish array even if is not defined in packages', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-basic-no-publish'));\n      const access = normalisePackageAccess(packages);\n\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n      // publish must defined\n      expect(scoped.publish).toBeDefined();\n      expect(scoped.publish).toHaveLength(0);\n      expect(all.publish).toBeDefined();\n      expect(all.publish).toHaveLength(0);\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should define an empty access array even if is not defined in packages","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":34,"column":80},"line":34,"code":"    test('should define an empty access array even if is not defined in packages', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-basic-no-access'));\n      const access = normalisePackageAccess(packages);\n\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n      // publish must defined\n      expect(scoped.access).toBeDefined();\n      expect(scoped.access).toHaveLength(0);\n      expect(all.access).toBeDefined();\n      expect(all.access).toHaveLength(0);\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should define an empty proxy array even if is not defined in package","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":47,"column":78},"line":47,"code":"    test('should define an empty proxy array even if is not defined in package', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-basic-no-proxy'));\n      const access = normalisePackageAccess(packages);\n\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n      // publish must defined\n      expect(scoped.proxy).toBeDefined();\n      expect(scoped.proxy).toHaveLength(0);\n      expect(all.proxy).toBeDefined();\n      expect(all.proxy).toHaveLength(0);\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should test multi user group definition","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":60,"column":49},"line":60,"code":"    test('should test multi user group definition', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-multi-group'));\n      const access = normalisePackageAccess(packages);\n\n      expect(access).toBeDefined();\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n\n      expect(scoped).toBeDefined();\n      expect(scoped.access).toContain('$all');\n      expect(scoped.publish).toHaveLength(2);\n      expect(scoped.publish).toContain('admin');\n      expect(scoped.publish).toContain('superadmin');\n\n      expect(all).toBeDefined();\n      expect(all.access).toHaveLength(3);\n      expect(all.access).toContain('$all');\n      expect(all.publish).toHaveLength(1);\n      expect(all.publish).toContain('admin');\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should check not default packages access","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":109,"column":50},"line":109,"code":"    test('should check not default packages access', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-empty'));\n      const access = normalisePackageAccess(packages);\n      expect(access).toBeDefined();\n\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n      expect(scoped).toBeUndefined();\n      // ** should be added by default **\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n      expect(all).toBeDefined();\n\n      expect(all.access).toBeDefined();\n      expect(_.isArray(all.access)).toBeTruthy();\n      expect(all.publish).toBeDefined();\n      expect(_.isArray(all.publish)).toBeTruthy();\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"token test valid length","suites":[],"updatePoint":{"line":3,"column":29},"line":3,"code":"test('token test valid length', () => {\n  const token = generateRandomSecretKey();\n  expect(token).toHaveLength(TOKEN_VALID_LENGTH);\n});","file":"token.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should test basic conversion","suites":["Uplinks Utilities","uplinkSanityCheck"],"updatePoint":{"line":7,"column":38},"line":7,"code":"    test('should test basic conversion', () => {\n      const uplinks = uplinkSanityCheck(\n        parseConfigFile(parseConfigurationFile('uplink-basic')).uplinks\n      );\n      expect(Object.keys(uplinks)).toContain('server1');\n      expect(Object.keys(uplinks)).toContain('server2');\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should throw error on blacklisted uplink name","suites":["Uplinks Utilities","uplinkSanityCheck"],"updatePoint":{"line":15,"column":55},"line":15,"code":"    test('should throw error on blacklisted uplink name', () => {\n      const { uplinks } = parseConfigFile(parseConfigurationFile('uplink-wrong'));\n\n      expect(() => {\n        uplinkSanityCheck(uplinks);\n      }).toThrow('CONFIG: reserved uplink name: anonymous');\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should fails if url prop is missing","suites":["Uplinks Utilities","sanityCheckUplinksProps"],"updatePoint":{"line":25,"column":45},"line":25,"code":"    test('should fails if url prop is missing', () => {\n      const { uplinks } = parseConfigFile(parseConfigurationFile('uplink-wrong'));\n      expect(() => {\n        sanityCheckUplinksProps(uplinks);\n      }).toThrow('CONFIG: no url for uplink: none-url');\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should bypass an empty uplink list","suites":["Uplinks Utilities","sanityCheckUplinksProps"],"updatePoint":{"line":32,"column":44},"line":32,"code":"    test('should bypass an empty uplink list', () => {\n      // @ts-ignore\n      expect(sanityCheckUplinksProps([])).toHaveLength(0);\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should test basic config","suites":["Uplinks Utilities","hasProxyTo"],"updatePoint":{"line":39,"column":34},"line":39,"code":"    test('should test basic config', () => {\n      const packages = normalisePackageAccess(\n        parseConfigFile(parseConfigurationFile('pkgs-basic')).packages\n      );\n      // react\n      expect(hasProxyTo('react', 'facebook', packages)).toBeFalsy();\n      expect(hasProxyTo('react', 'google', packages)).toBeFalsy();\n      // vue\n      expect(hasProxyTo('vue', 'google', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'fake', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'npmjs', packages)).toBeTruthy();\n      // angular\n      expect(hasProxyTo('angular', 'google', packages)).toBeFalsy();\n      expect(hasProxyTo('angular', 'facebook', packages)).toBeFalsy();\n      expect(hasProxyTo('angular', 'npmjs', packages)).toBeTruthy();\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should test resolve based on custom package access","suites":["Uplinks Utilities","hasProxyTo"],"updatePoint":{"line":56,"column":60},"line":56,"code":"    test('should test resolve based on custom package access', () => {\n      const packages = normalisePackageAccess(\n        parseConfigFile(parseConfigurationFile('pkgs-custom')).packages\n      );\n      // react\n      expect(hasProxyTo('react', 'facebook', packages)).toBeTruthy();\n      expect(hasProxyTo('react', 'google', packages)).toBeFalsy();\n      // vue\n      expect(hasProxyTo('vue', 'google', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'fake', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'npmjs', packages)).toBeTruthy();\n      // angular\n      expect(hasProxyTo('angular', 'google', packages)).toBeTruthy();\n      expect(hasProxyTo('angular', 'facebook', packages)).toBeFalsy();\n      expect(hasProxyTo('angular', 'npmjs', packages)).toBeFalsy();\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should not resolve any proxy","suites":["Uplinks Utilities","hasProxyTo"],"updatePoint":{"line":73,"column":38},"line":73,"code":"    test('should not resolve any proxy', () => {\n      const packages = normalisePackageAccess(\n        parseConfigFile(parseConfigurationFile('pkgs-empty')).packages\n      );\n      // react\n      expect(hasProxyTo('react', 'npmjs', packages)).toBeFalsy();\n      expect(hasProxyTo('react', 'npmjs', packages)).toBeFalsy();\n      // vue\n      expect(hasProxyTo('vue', 'npmjs', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'npmjs', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'npmjs', packages)).toBeFalsy();\n      // angular\n      expect(hasProxyTo('angular', 'npmjs', packages)).toBeFalsy();\n      expect(hasProxyTo('angular', 'npmjs', packages)).toBeFalsy();\n      expect(hasProxyTo('angular', 'npmjs', packages)).toBeFalsy();\n      // private\n      expect(hasProxyTo('private', 'fake', packages)).toBeFalsy();\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should create a remote user with default groups","suites":["createRemoteUser and createAnonymousRemoteUser"],"updatePoint":{"line":4,"column":55},"line":4,"code":"  test('should create a remote user with default groups', () => {\n    expect(createRemoteUser('12345', ['foo', 'bar'])).toEqual({\n      groups: [\n        'foo',\n        'bar',\n        ROLES.$ALL,\n        ROLES.$AUTH,\n        ROLES.DEPRECATED_ALL,\n        ROLES.DEPRECATED_AUTH,\n        ROLES.ALL,\n      ],\n      name: '12345',\n      real_groups: ['foo', 'bar'],\n    });\n  });","file":"utils.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should create a anonymous remote user with default groups","suites":["createRemoteUser and createAnonymousRemoteUser"],"updatePoint":{"line":20,"column":65},"line":20,"code":"  test('should create a anonymous remote user with default groups', () => {\n    expect(createAnonymousRemoteUser()).toEqual({\n      groups: [ROLES.$ALL, ROLES.$ANONYMOUS, ROLES.DEPRECATED_ALL, ROLES.DEPRECATED_ANONYMOUS],\n      name: undefined,\n      real_groups: [],\n    });\n  });","file":"utils.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should qualify as an native error","suites":["testing errors"],"updatePoint":{"line":18,"column":41},"line":18,"code":"  test('should qualify as an native error', () => {\n    expect(_.isError(getNotFound())).toBeTruthy();\n    expect(_.isError(getConflict())).toBeTruthy();\n    expect(_.isError(getBadData())).toBeTruthy();\n    expect(_.isError(getInternalError())).toBeTruthy();\n    expect(_.isError(getUnauthorized())).toBeTruthy();\n    expect(_.isError(getForbidden())).toBeTruthy();\n    expect(_.isError(getServiceUnavailable())).toBeTruthy();\n    expect(_.isError(getCode(400, 'fooError'))).toBeTruthy();\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test not found","suites":["testing errors"],"updatePoint":{"line":29,"column":29},"line":29,"code":"  test('should test not found', () => {\n    const err: VerdaccioError = getNotFound('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.NOT_FOUND);\n    expect(err.statusCode).toEqual(HTTP_STATUS.NOT_FOUND);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test conflict","suites":["testing errors"],"updatePoint":{"line":38,"column":28},"line":38,"code":"  test('should test conflict', () => {\n    const err: VerdaccioError = getConflict('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.CONFLICT);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test bad data","suites":["testing errors"],"updatePoint":{"line":46,"column":28},"line":46,"code":"  test('should test bad data', () => {\n    const err: VerdaccioError = getBadData('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.BAD_DATA);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test internal error custom message","suites":["testing errors"],"updatePoint":{"line":54,"column":49},"line":54,"code":"  test('should test internal error custom message', () => {\n    const err: VerdaccioError = getInternalError('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.INTERNAL_ERROR);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test internal error","suites":["testing errors"],"updatePoint":{"line":62,"column":34},"line":62,"code":"  test('should test internal error', () => {\n    const err: VerdaccioError = getInternalError();\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.INTERNAL_ERROR);\n    expect(err.message).toEqual(API_ERROR.UNKNOWN_ERROR);\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test Unauthorized message","suites":["testing errors"],"updatePoint":{"line":70,"column":40},"line":70,"code":"  test('should test Unauthorized message', () => {\n    const err: VerdaccioError = getUnauthorized('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.UNAUTHORIZED);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test forbidden message","suites":["testing errors"],"updatePoint":{"line":78,"column":37},"line":78,"code":"  test('should test forbidden message', () => {\n    const err: VerdaccioError = getForbidden('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.FORBIDDEN);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test service unavailable message","suites":["testing errors"],"updatePoint":{"line":86,"column":47},"line":86,"code":"  test('should test service unavailable message', () => {\n    const err: VerdaccioError = getServiceUnavailable('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.SERVICE_UNAVAILABLE);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test custom code error message","suites":["testing errors"],"updatePoint":{"line":94,"column":45},"line":94,"code":"  test('should test custom code error message', () => {\n    const err: VerdaccioError = getCode(HTTP_STATUS.NOT_FOUND, 'foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.NOT_FOUND);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test custom code ok message","suites":["testing errors"],"updatePoint":{"line":102,"column":42},"line":102,"code":"  test('should test custom code ok message', () => {\n    const err: VerdaccioError = getCode(HTTP_STATUS.OK, 'foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.OK);\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"simple","suites":["Storage._merge_versions versions"],"updatePoint":{"line":4,"column":14},"line":4,"code":"  test('simple', () => {\n    let pkg = {\n      versions: { a: 1, b: 1, c: 1 },\n      'dist-tags': {},\n    };\n\n    // @ts-ignore\n    mergeVersions(pkg, { versions: { a: 2, q: 2 } });\n\n    expect(pkg).toStrictEqual({\n      versions: { a: 1, b: 1, c: 1, q: 2 },\n      'dist-tags': {},\n    });\n  });","file":"merge.dist.tags.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"dist-tags - compat","suites":["Storage._merge_versions versions"],"updatePoint":{"line":19,"column":26},"line":19,"code":"  test('dist-tags - compat', () => {\n    let pkg = {\n      versions: {},\n      'dist-tags': { q: '1.1.1', w: '2.2.2' },\n    };\n\n    // @ts-ignore\n    mergeVersions(pkg, { 'dist-tags': { q: '2.2.2', w: '3.3.3', t: '4.4.4' } });\n\n    expect(pkg).toStrictEqual({\n      versions: {},\n      'dist-tags': { q: '2.2.2', w: '3.3.3', t: '4.4.4' },\n    });\n  });","file":"merge.dist.tags.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"dist-tags - staging","suites":["Storage._merge_versions versions"],"updatePoint":{"line":34,"column":27},"line":34,"code":"  test('dist-tags - staging', () => {\n    let pkg = {\n      versions: {},\n      // we've been locally publishing 1.1.x in preparation for the next\n      // public release\n      'dist-tags': { q: '1.1.10', w: '2.2.2' },\n    };\n    // 1.1.2 is the latest public release, but we want to continue testing\n    // against our local 1.1.10, which may end up published as 1.1.3 in the\n    // future\n\n    // @ts-ignore\n    mergeVersions(pkg, { 'dist-tags': { q: '1.1.2', w: '3.3.3', t: '4.4.4' } });\n\n    expect(pkg).toStrictEqual({\n      versions: {},\n      'dist-tags': { q: '1.1.10', w: '3.3.3', t: '4.4.4' },\n    });\n  });","file":"merge.dist.tags.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"semverSort","suites":["Storage._merge_versions versions"],"updatePoint":{"line":54,"column":18},"line":54,"code":"  test('semverSort', () => {\n    expect(semverSort(['1.2.3', '1.2', '1.2.3a', '1.2.3c', '1.2.3-b'])).toStrictEqual([\n      '1.2.3a',\n      '1.2.3-b',\n      '1.2.3c',\n      '1.2.3',\n    ]);\n  });","file":"merge.dist.tags.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"readableToString single string","suites":["mystreams"],"updatePoint":{"line":6,"column":38},"line":6,"code":"  test('readableToString single string', async () => {\n    expect(await readableToString(Stream.Readable.from('foo'))).toEqual('foo');\n  });","file":"mystreams.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"readableToString single object","suites":["mystreams"],"updatePoint":{"line":10,"column":38},"line":10,"code":"  test('readableToString single object', async () => {\n    expect(\n      JSON.parse(await readableToString(Stream.Readable.from(JSON.stringify({ foo: 1 }))))\n    ).toEqual({\n      foo: 1,\n    });\n  });","file":"mystreams.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"extractTarballName","suites":["pkg-utils"],"updatePoint":{"line":4,"column":26},"line":4,"code":"  test('extractTarballName', () => {\n    expect(pkgUtils.extractTarballName('https://registry.npmjs.org/test/-/test-0.0.2.tgz')).toBe(\n      'test-0.0.2.tgz'\n    );\n  });","file":"pkg-utils.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"extractTarballName with no tarball should not fails","suites":["pkg-utils"],"updatePoint":{"line":10,"column":59},"line":10,"code":"  test('extractTarballName with no tarball should not fails', () => {\n    expect(pkgUtils.extractTarballName('https://registry.npmjs.org/')).toBe('');\n  });","file":"pkg-utils.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"extractTarballName fails","suites":["pkg-utils"],"updatePoint":{"line":14,"column":32},"line":14,"code":"  test('extractTarballName fails', () => {\n    expect(() =>\n      pkgUtils.extractTarballName('xxxxregistry.npmjs.org/test/-/test-0.0.2.tgz')\n    ).toThrow();\n  });","file":"pkg-utils.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"getLatest fails if no versions","suites":["pkg-utils"],"updatePoint":{"line":20,"column":38},"line":20,"code":"  test('getLatest fails if no versions', () => {\n    expect(() =>\n      // @ts-expect-error\n      pkgUtils.getLatest({\n        versions: {},\n      })\n    ).toThrow('cannot get lastest version of none');\n  });","file":"pkg-utils.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"getLatest get latest","suites":["pkg-utils"],"updatePoint":{"line":29,"column":28},"line":29,"code":"  test('getLatest get latest', () => {\n    expect(\n      pkgUtils.getLatest({\n        versions: {\n          // @ts-expect-error\n          '1.0.0': {},\n        },\n        [DIST_TAGS]: {\n          latest: '1.0.0',\n        },\n      })\n    ).toBe('1.0.0');\n  });","file":"pkg-utils.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"getByQualityPriorityValue","suites":["string-utils"],"updatePoint":{"line":4,"column":33},"line":4,"code":"  test('getByQualityPriorityValue', () => {\n    expect(stringUtils.getByQualityPriorityValue('')).toEqual('');\n    expect(stringUtils.getByQualityPriorityValue(null)).toEqual('');\n    expect(stringUtils.getByQualityPriorityValue(undefined)).toEqual('');\n    expect(stringUtils.getByQualityPriorityValue('something')).toEqual('something');\n    expect(stringUtils.getByQualityPriorityValue('something,')).toEqual('something');\n    expect(stringUtils.getByQualityPriorityValue('0,')).toEqual('0');\n    expect(stringUtils.getByQualityPriorityValue('application/json')).toEqual('application/json');\n    expect(stringUtils.getByQualityPriorityValue('application/json; q=1')).toEqual(\n      'application/json'\n    );\n    expect(stringUtils.getByQualityPriorityValue('application/json; q=')).toEqual(\n      'application/json'\n    );\n    expect(stringUtils.getByQualityPriorityValue('application/json;')).toEqual('application/json');\n    expect(\n      stringUtils.getByQualityPriorityValue(\n        'application/json; q=1.0, application/vnd.npm.install-v1+json; q=0.9, */*'\n      )\n    ).toEqual('application/json');\n    expect(\n      stringUtils.getByQualityPriorityValue(\n        'application/json; q=1.0, application/vnd.npm.install-v1+json; q=, */*'\n      )\n    ).toEqual('application/json');\n    expect(\n      stringUtils.getByQualityPriorityValue(\n        'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.9, */*'\n      )\n    ).toEqual('application/vnd.npm.install-v1+json');\n    expect(\n      stringUtils.getByQualityPriorityValue(\n        'application/vnd.npm.install-v1+json; q=, application/json; q=0.9, */*'\n      )\n    ).toEqual('application/json');\n  });","file":"string-utils.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should validate package names","suites":["validatePackage"],"updatePoint":{"line":12,"column":37},"line":12,"code":"  test('should validate package names', () => {\n    expect(validatePackage('package-name')).toBeTruthy();\n    expect(validatePackage('@scope/package-name')).toBeTruthy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails on validate package names","suites":["validatePackage"],"updatePoint":{"line":17,"column":46},"line":17,"code":"  test('should fails on validate package names', () => {\n    expect(validatePackage('package-name/test/fake')).toBeFalsy();\n    expect(validatePackage('@/package-name')).toBeFalsy();\n    expect(validatePackage('$%$%#$%$#%#$%$#')).toBeFalsy();\n    expect(validatePackage('node_modules')).toBeFalsy();\n    expect(validatePackage('__proto__')).toBeFalsy();\n    expect(validatePackage('favicon.ico')).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"isObject metadata","suites":["isObject"],"updatePoint":{"line":28,"column":25},"line":28,"code":"  test('isObject metadata', () => {\n    expect(isObject({ foo: 'bar' })).toBeTruthy();\n    // expect(isObject('foo')).toBeTruthy();\n    expect(isObject(['foo'])).toBeFalsy();\n    expect(isObject(null)).toBeFalsy();\n    expect(isObject(undefined)).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fills an empty metadata object","suites":["normalizeMetadata"],"updatePoint":{"line":38,"column":45},"line":38,"code":"  test('should fills an empty metadata object', () => {\n    // intended to fail with flow, do not remove\n    // @ts-ignore\n    expect(Object.keys(normalizeMetadata({}))).toContain(DIST_TAGS);\n    // @ts-ignore\n    expect(Object.keys(normalizeMetadata({}))).toContain('versions');\n    // @ts-ignore\n    expect(Object.keys(normalizeMetadata({}))).toContain('time');\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails the assertions is not an object","suites":["normalizeMetadata"],"line":48,"code":"  test.skip('should fails the assertions is not an object', () => {","file":"validation-utilts.spec.ts","skipped":true,"dir":"packages/core/core/test"},{"name":"should fails the assertions is name does not match","suites":["normalizeMetadata"],"updatePoint":{"line":56,"column":58},"line":56,"code":"  test('should fails the assertions is name does not match', () => {\n    expect(function () {\n      // @ts-ignore\n      normalizeMetadata({}, 'no-name');\n      // @ts-ignore\n    }).toThrow(expect.hasAssertions());\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails with no string","suites":["validateName"],"updatePoint":{"line":66,"column":35},"line":66,"code":"  test('should fails with no string', () => {\n    // intended to fail with Typescript, do not remove\n    // @ts-ignore\n    expect(validateName(null)).toBeFalsy();\n    // @ts-ignore\n    expect(validateName(undefined)).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"good ones","suites":["validateName"],"updatePoint":{"line":74,"column":17},"line":74,"code":"  test('good ones', () => {\n    expect(validateName('verdaccio')).toBeTruthy();\n    expect(validateName('some.weird.package-zzz')).toBeTruthy();\n    expect(validateName('old-package@0.1.2.tgz')).toBeTruthy();\n    // fix https://github.com/verdaccio/verdaccio/issues/1400\n    expect(validateName('-build-infra')).toBeTruthy();\n    expect(validateName('@pkg-scoped/without-extension')).toBeTruthy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should be valid using uppercase","suites":["validateName"],"updatePoint":{"line":83,"column":39},"line":83,"code":"  test('should be valid using uppercase', () => {\n    expect(validateName('ETE')).toBeTruthy();\n    expect(validateName('JSONStream')).toBeTruthy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails with path seps","suites":["validateName"],"updatePoint":{"line":88,"column":35},"line":88,"code":"  test('should fails with path seps', () => {\n    expect(validateName('some/thing')).toBeFalsy();\n    expect(validateName('some\\\\thing')).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fail with no hidden files","suites":["validateName"],"updatePoint":{"line":93,"column":40},"line":93,"code":"  test('should fail with no hidden files', () => {\n    expect(validateName('.bin')).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails with reserved words","suites":["validateName"],"updatePoint":{"line":97,"column":40},"line":97,"code":"  test('should fails with reserved words', () => {\n    expect(validateName('favicon.ico')).toBeFalsy();\n    expect(validateName('node_modules')).toBeFalsy();\n    expect(validateName('__proto__')).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails with other options","suites":["validateName"],"updatePoint":{"line":103,"column":39},"line":103,"code":"  test('should fails with other options', () => {\n    expect(validateName('pk g')).toBeFalsy();\n    expect(validateName('pk\\tg')).toBeFalsy();\n    expect(validateName('pk%20g')).toBeFalsy();\n    expect(validateName('pk+g')).toBeFalsy();\n    expect(validateName('pk:g')).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should be valid","suites":["validatePublishSingleVersion"],"updatePoint":{"line":113,"column":23},"line":113,"code":"  test('should be valid', () => {\n    expect(\n      validatePublishSingleVersion({\n        name: 'foo-pkg',\n        _attachments: { '2': {} },\n        versions: { '1': {} },\n      })\n    ).toBeTruthy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should be invalid if name is missing","suites":["validatePublishSingleVersion"],"updatePoint":{"line":123,"column":44},"line":123,"code":"  test('should be invalid if name is missing', () => {\n    expect(\n      validatePublishSingleVersion({\n        _attachments: { '2': {} },\n        versions: { '1': {} },\n      })\n    ).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should be invalid if _attachments is missing","suites":["validatePublishSingleVersion"],"updatePoint":{"line":132,"column":52},"line":132,"code":"  test('should be invalid if _attachments is missing', () => {\n    expect(\n      validatePublishSingleVersion({\n        name: 'foo-pkg',\n        versions: { '1': {} },\n      })\n    ).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should be invalid if versions is missing","suites":["validatePublishSingleVersion"],"updatePoint":{"line":141,"column":48},"line":141,"code":"  test('should be invalid if versions is missing', () => {\n    expect(\n      validatePublishSingleVersion({\n        name: 'foo-pkg',\n        _attachments: { '1': {} },\n      })\n    ).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should be invalid if versions is more than 1","suites":["validatePublishSingleVersion"],"updatePoint":{"line":150,"column":52},"line":150,"code":"  test('should be invalid if versions is more than 1', () => {\n    expect(\n      validatePublishSingleVersion({\n        name: 'foo-pkg',\n        versions: { '1': {}, '2': {} },\n        _attachments: { '1': {} },\n      })\n    ).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should be invalid if _attachments is more than 1","suites":["validatePublishSingleVersion"],"updatePoint":{"line":160,"column":56},"line":160,"code":"  test('should be invalid if _attachments is more than 1', () => {\n    expect(\n      validatePublishSingleVersion({\n        name: 'foo-pkg',\n        _attachments: { '1': {}, '2': {} },\n        versions: { '1': {} },\n      })\n    ).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should validate password according the length","suites":["validatePassword"],"updatePoint":{"line":172,"column":53},"line":172,"code":"  test('should validate password according the length', () => {\n    expect(validatePassword('12345', DEFAULT_PASSWORD_VALIDATION)).toBeTruthy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should validate invalid regex","suites":["validatePassword"],"updatePoint":{"line":176,"column":37},"line":176,"code":"  test('should validate invalid regex', () => {\n    // @ts-expect-error\n    expect(validatePassword('12345', 34234342)).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should validate invalid regex (undefined)","suites":["validatePassword"],"updatePoint":{"line":181,"column":49},"line":181,"code":"  test('should validate invalid regex (undefined)', () => {\n    expect(validatePassword('12345', undefined)).toBeTruthy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should validate invalid password)","suites":["validatePassword"],"updatePoint":{"line":185,"column":41},"line":185,"code":"  test('should validate invalid password)', () => {\n    // @ts-expect-error\n    expect(validatePassword(undefined)).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should validate invalid password number)","suites":["validatePassword"],"updatePoint":{"line":190,"column":48},"line":190,"code":"  test('should validate invalid password number)', () => {\n    // @ts-expect-error\n    expect(validatePassword(2342344234342)).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails on validate password according the length","suites":["validatePassword"],"updatePoint":{"line":195,"column":62},"line":195,"code":"  test('should fails on validate password according the length', () => {\n    expect(validatePassword('12345', /.{10}$/)).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails handle complex password validation","suites":["validatePassword"],"updatePoint":{"line":199,"column":55},"line":199,"code":"  test('should fails handle complex password validation', () => {\n    expect(validatePassword('12345', /^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$/)).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should handle complex password validation","suites":["validatePassword"],"updatePoint":{"line":203,"column":49},"line":203,"code":"  test('should handle complex password validation', () => {\n    expect(\n      validatePassword(\n        'c<?_:srdsj&WyZgY}r4:l[F<RgV<}',\n        /^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,}$/\n      )\n    ).toBeTruthy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails on validate password according the length and default config","suites":["validatePassword"],"updatePoint":{"line":212,"column":81},"line":212,"code":"  test('should fails on validate password according the length and default config', () => {\n    expect(validatePassword('12')).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should validate password according the length and default config","suites":["validatePassword"],"updatePoint":{"line":216,"column":72},"line":216,"code":"  test('should validate password according the length and default config', () => {\n    expect(validatePassword('1235678910')).toBeTruthy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"file should be found to be locked","suites":["testing locking","lockFile"],"updatePoint":{"line":25,"column":43},"line":25,"code":"    test('file should be found to be locked', (done) => {\n      lockFile(getFilePath('package.json'), (error: Error) => {\n        expect(error).toBeNull();\n        removeTempFile('package.json.lock');\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"file should fail to be found to be locked","suites":["testing locking","lockFile"],"updatePoint":{"line":33,"column":51},"line":33,"code":"    test('file should fail to be found to be locked', (done) => {\n      lockFile(getFilePath('package.fail.json'), (error: Error) => {\n        expect(error.message).toMatch(\n          /ENOENT: no such file or directory, stat '(.*)package.fail.json'/\n        );\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"file should to be found to be unLock","suites":["testing locking","unlockFile"],"updatePoint":{"line":44,"column":46},"line":44,"code":"    test('file should to be found to be unLock', (done) => {\n      unlockFile(getFilePath('package.json.lock'), (error: Error) => {\n        expect(error).toBeNull();\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with no options should to be found to be read it as string","suites":["testing locking","readFile"],"updatePoint":{"line":53,"column":78},"line":53,"code":"    test('read file with no options should to be found to be read it as string', (done) => {\n      readFile(getFilePath('package.json'), {}, (error: Error, data: string) => {\n        expect(error).toBeNull();\n        expect(data).toMatchInlineSnapshot(`\n          \"{\n            \"name\": \"assets\",\n            \"version\": \"0.0.1\"\n          }\n          \"\n        `);\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with no options should to be found to be read it as object","suites":["testing locking","readFile"],"updatePoint":{"line":67,"column":78},"line":67,"code":"    test('read file with no options should to be found to be read it as object', (done) => {\n      const options = {\n        parse: true,\n      };\n      readFile(getFilePath('package.json'), options, (error: Error, data: string) => {\n        expect(error).toBeNull();\n        expect(data).toMatchInlineSnapshot(`\n          {\n            \"name\": \"assets\",\n            \"version\": \"0.0.1\",\n          }\n        `);\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options (parse) should to be not found to be read it","suites":["testing locking","readFile"],"updatePoint":{"line":83,"column":77},"line":83,"code":"    test('read file with options (parse) should to be not found to be read it', (done) => {\n      const options = {\n        parse: true,\n      };\n      readFile(getFilePath('package.fail.json'), options, (error: Error) => {\n        expect(error.message).toMatch(\n          /ENOENT: no such file or directory, open '(.*)package.fail.json'/\n        );\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options should be found to be read it and fails to be parsed","suites":["testing locking","readFile"],"updatePoint":{"line":95,"column":85},"line":95,"code":"    test('read file with options should be found to be read it and fails to be parsed', (done) => {\n      const options = {\n        parse: true,\n      };\n      readFile(getFilePath('wrong.package.json'), options, (error: Error) => {\n        expect(error.message).toMatch(/Unexpected token } in JSON at position \\d+/);\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options (parse, lock) should be found to be read it as object","suites":["testing locking","readFile"],"updatePoint":{"line":105,"column":86},"line":105,"code":"    test('read file with options (parse, lock) should be found to be read it as object', (done) => {\n      const options = {\n        parse: true,\n        lock: true,\n      };\n      readFile(getFilePath('package2.json'), options, (error: Error, data: string) => {\n        expect(error).toBeNull();\n        expect(data).toMatchInlineSnapshot(`\n          {\n            \"name\": \"assets\",\n            \"version\": \"0.0.1\",\n          }\n        `);\n        removeTempFile('package2.json.lock');\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"file should be found to be locked","suites":["testing locking","lockFile"],"updatePoint":{"line":22,"column":43},"line":22,"code":"    test('file should be found to be locked', async () => {\n      await lockFileNext(getFilePath('package.json'));\n      removeTempFile('package.json.lock');\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"file should fail to be found to be locked","suites":["testing locking","lockFile"],"updatePoint":{"line":27,"column":51},"line":27,"code":"    test('file should fail to be found to be locked', async () => {\n      await expect(lockFileNext(getFilePath('package.fail.json'))).rejects.toThrow(\n        'ENOENT: no such file or directory'\n      );\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"file should to be found to be unLock","suites":["testing locking","unlockFile"],"updatePoint":{"line":35,"column":46},"line":35,"code":"    test('file should to be found to be unLock', async () => {\n      await expect(unlockFileNext(getFilePath('package.json.lock'))).resolves.toBeUndefined();\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"error on missing dir","suites":["testing locking","statDir"],"updatePoint":{"line":41,"column":30},"line":41,"code":"    test('error on missing dir', async () => {\n      await expect(statDir(getFilePath('package.json/package.json'))).rejects.toThrow(\n        'is not a directory'\n      );\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"error on missing dir","suites":["testing locking","statFile"],"updatePoint":{"line":49,"column":30},"line":49,"code":"    test('error on missing dir', async () => {\n      await expect(statFile(getFilePath(''))).rejects.toThrow('is not a file');\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with no options should to be found to be read it as string","suites":["testing locking","readFile"],"updatePoint":{"line":55,"column":78},"line":55,"code":"    test('read file with no options should to be found to be read it as string', async () => {\n      const data = await readFileNext(getFilePath('package.json'), {});\n      expect(data).toMatchInlineSnapshot(`\n        \"{\n          \"name\": \"assets\",\n          \"version\": \"0.0.1\"\n        }\n        \"\n      `);\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with no options should to be found to be read it as object","suites":["testing locking","readFile"],"updatePoint":{"line":66,"column":78},"line":66,"code":"    test('read file with no options should to be found to be read it as object', async () => {\n      const options = {\n        parse: true,\n      };\n      const data = await readFileNext(getFilePath('package.json'), options);\n      expect(data).toMatchInlineSnapshot(`\n        {\n          \"name\": \"assets\",\n          \"version\": \"0.0.1\",\n        }\n      `);\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options (parse) should to be not found to be read it","suites":["testing locking","readFile"],"updatePoint":{"line":79,"column":77},"line":79,"code":"    test('read file with options (parse) should to be not found to be read it', async () => {\n      const options = {\n        parse: true,\n      };\n      await expect(readFileNext(getFilePath('package.fail.json'), options)).rejects.toThrow(\n        /ENOENT: no such file or directory, open '(.*)package.fail.json'/\n      );\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options should be found to be read it and fails to be parsed","suites":["testing locking","readFile"],"updatePoint":{"line":88,"column":85},"line":88,"code":"    test('read file with options should be found to be read it and fails to be parsed', async () => {\n      const options = {\n        parse: true,\n      };\n      await expect(readFileNext(getFilePath('wrong.package.json'), options)).rejects.toThrow(\n        'Unexpected token } in JSON at position 44'\n      );\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options (parse, lock) should be found to be read it as object","suites":["testing locking","readFile"],"updatePoint":{"line":97,"column":86},"line":97,"code":"    test('read file with options (parse, lock) should be found to be read it as object', async () => {\n      const options = {\n        parse: true,\n        lock: true,\n      };\n      await expect(readFileNext(getFilePath('package2.json'), options)).resolves\n        .toMatchInlineSnapshot(`\n        {\n          \"name\": \"assets\",\n          \"version\": \"0.0.1\",\n        }\n      `);\n      removeTempFile('package2.json.lock');\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"should build a URI for dist tarball based on new domain","suites":["convertDistRemoteToLocalTarballUrls"],"updatePoint":{"line":26,"column":63},"line":26,"code":"  test('should build a URI for dist tarball based on new domain', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: fakeHost,\n        [HEADERS.FORWARDED_PROTO]: 'http',\n      },\n      url: '/',\n    });\n    const convertDist = convertDistRemoteToLocalTarballUrls(cloneMetadata(), {\n      host: req.hostname,\n      headers: req.headers as any,\n      protocol: req.protocol,\n    });\n    expect(convertDist.versions['1.0.0'].dist.tarball).toEqual(buildURI(fakeHost, '1.0.0'));\n    expect(convertDist.versions['1.0.1'].dist.tarball).toEqual(buildURI(fakeHost, '1.0.1'));\n  });","file":"convertDistRemoteToLocalTarballUrls.spec.ts","skipped":false,"dir":"packages/core/tarball/tests"},{"name":"should return same URI whether host is missing","suites":["convertDistRemoteToLocalTarballUrls"],"updatePoint":{"line":44,"column":54},"line":44,"code":"  test('should return same URI whether host is missing', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'http',\n      },\n      url: '/',\n    });\n    const convertDist = convertDistRemoteToLocalTarballUrls(cloneMetadata(), {\n      host: req.hostname,\n      headers: req.headers as any,\n      protocol: req.protocol,\n    });\n    expect(convertDist.versions['1.0.0'].dist.tarball).toEqual(\n      convertDist.versions['1.0.0'].dist.tarball\n    );\n  });","file":"convertDistRemoteToLocalTarballUrls.spec.ts","skipped":false,"dir":"packages/core/tarball/tests"},{"name":"should return same URI whether host is undefined","suites":["convertDistRemoteToLocalTarballUrls"],"updatePoint":{"line":62,"column":56},"line":62,"code":"  test('should return same URI whether host is undefined', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: undefined,\n      },\n      url: '/',\n    });\n    const convertDist = convertDistRemoteToLocalTarballUrls(cloneMetadata(), {\n      host: req.hostname,\n      headers: req.headers as any,\n      protocol: req.protocol,\n    });\n    expect(convertDist.versions['1.0.0'].dist.tarball).toEqual(\n      convertDist.versions['1.0.0'].dist.tarball\n    );\n  });","file":"convertDistRemoteToLocalTarballUrls.spec.ts","skipped":false,"dir":"packages/core/tarball/tests"},{"name":"should create a URI","suites":["combineBaseUrl"],"updatePoint":{"line":4,"column":27},"line":4,"code":"  test('should create a URI', () => {\n    expect(combineBaseUrl('http', 'domain')).toEqual('http://domain/');\n  });","file":"combineBaseUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should create a base url for registry","suites":["combineBaseUrl"],"updatePoint":{"line":8,"column":45},"line":8,"code":"  test('should create a base url for registry', () => {\n    expect(combineBaseUrl('http', 'domain.com', '')).toEqual('http://domain.com/');\n    expect(combineBaseUrl('http', 'domain.com', '/')).toEqual('http://domain.com/');\n    expect(combineBaseUrl('http', 'domain.com', '/prefix/')).toEqual('http://domain.com/prefix/');\n    expect(combineBaseUrl('http', 'domain.com', '/prefix/deep')).toEqual(\n      'http://domain.com/prefix/deep/'\n    );\n    expect(combineBaseUrl('http', 'domain.com', 'prefix/')).toEqual('http://domain.com/prefix/');\n    expect(combineBaseUrl('http', 'domain.com', 'prefix')).toEqual('http://domain.com/prefix/');\n  });","file":"combineBaseUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"invalid url prefix","suites":["combineBaseUrl"],"updatePoint":{"line":19,"column":26},"line":19,"code":"  test('invalid url prefix', () => {\n    expect(combineBaseUrl('http', 'domain.com', 'only-prefix')).toEqual(\n      'http://domain.com/only-prefix/'\n    );\n    expect(combineBaseUrl('https', 'domain.com', 'only-prefix')).toEqual(\n      'https://domain.com/only-prefix/'\n    );\n  });","file":"combineBaseUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"get empty string with missing host header","suites":["host"],"updatePoint":{"line":10,"column":49},"line":10,"code":"  test('get empty string with missing host header', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      url: '/',\n    });\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"get a valid host","suites":["host"],"updatePoint":{"line":24,"column":24},"line":24,"code":"  test('get a valid host', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n      },\n      url: '/',\n    });\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"check a valid host header injection","suites":["host"],"updatePoint":{"line":41,"column":43},"line":41,"code":"  test('check a valid host header injection', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: `some.com\"><svg onload=\"alert(1)\">`,\n      },\n      hostname: `some.com\"><svg onload=\"alert(1)\">`,\n      url: '/',\n    });\n    expect(function () {\n      getPublicUrl('', {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      });\n    }).toThrow('invalid host');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"get a valid host with prefix","suites":["host"],"updatePoint":{"line":59,"column":36},"line":59,"code":"  test('get a valid host with prefix', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl('/prefix/', {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/prefix/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"get a valid host with prefix no trailing","suites":["host"],"updatePoint":{"line":77,"column":48},"line":77,"code":"  test('get a valid host with prefix no trailing', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl('/prefix-no-trailing', {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/prefix-no-trailing/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"get a valid host with null prefix","suites":["host"],"updatePoint":{"line":95,"column":41},"line":95,"code":"  test('get a valid host with null prefix', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(null, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a valid X-Forwarded-Proto https","suites":["X-Forwarded-Proto"],"updatePoint":{"line":115,"column":44},"line":115,"code":"  test('with a valid X-Forwarded-Proto https', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'https',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('https://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a invalid X-Forwarded-Proto https","suites":["X-Forwarded-Proto"],"updatePoint":{"line":134,"column":46},"line":134,"code":"  test('with a invalid X-Forwarded-Proto https', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'invalidProto',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a HAProxy X-Forwarded-Proto https","suites":["X-Forwarded-Proto"],"updatePoint":{"line":153,"column":46},"line":153,"code":"  test('with a HAProxy X-Forwarded-Proto https', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'https,https',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('https://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a HAProxy X-Forwarded-Proto different protocol","suites":["X-Forwarded-Proto"],"updatePoint":{"line":172,"column":59},"line":172,"code":"  test('with a HAProxy X-Forwarded-Proto different protocol', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'http,https',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a valid X-Forwarded-Proto https and env variable","suites":["env variable"],"updatePoint":{"line":193,"column":61},"line":193,"code":"  test('with a valid X-Forwarded-Proto https and env variable', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'https://env.domain.com';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'https',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('https://env.domain.com/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a valid X-Forwarded-Proto https and env variable with prefix","suites":["env variable"],"updatePoint":{"line":214,"column":73},"line":214,"code":"  test('with a valid X-Forwarded-Proto https and env variable with prefix', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'https://env.domain.com/urlPrefix/';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'https',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('https://env.domain.com/urlPrefix/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a invalid X-Forwarded-Proto https and env variable","suites":["env variable"],"updatePoint":{"line":235,"column":63},"line":235,"code":"  test('with a invalid X-Forwarded-Proto https and env variable', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'https://env.domain.com/';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'invalidProtocol',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('https://env.domain.com/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a invalid X-Forwarded-Proto https and invalid url with env variable","suites":["env variable"],"updatePoint":{"line":256,"column":80},"line":256,"code":"  test('with a invalid X-Forwarded-Proto https and invalid url with env variable', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'ftp://env.domain.com';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'invalidProtocol',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a invalid X-Forwarded-Proto https and host injection with host","suites":["env variable"],"updatePoint":{"line":277,"column":75},"line":277,"code":"  test('with a invalid X-Forwarded-Proto https and host injection with host', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'http://injection.test.com\"><svg onload=\"alert(1)\">';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'invalidProtocol',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with the VERDACCIO_FORWARDED_PROTO undefined","suites":["env variable"],"updatePoint":{"line":298,"column":52},"line":298,"code":"  test('with the VERDACCIO_FORWARDED_PROTO undefined', () => {\n    process.env.VERDACCIO_FORWARDED_PROTO = undefined;\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'https',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl('/test/', {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/test/');\n    delete process.env.VERDACCIO_FORWARDED_PROTO;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a invalid X-Forwarded-Proto https and host injection with invalid host","suites":["env variable"],"updatePoint":{"line":319,"column":83},"line":319,"code":"  test('with a invalid X-Forwarded-Proto https and host injection with invalid host', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'http://injection.test.com\"><svg onload=\"alert(1)\">';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some',\n        [HEADERS.FORWARDED_PROTO]: 'invalidProtocol',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should handle undefined header","suites":["getWebProtocol"],"updatePoint":{"line":4,"column":38},"line":4,"code":"  test('should handle undefined header', () => {\n    expect(getWebProtocol(undefined, 'http')).toBe('http');\n  });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should handle emtpy string","suites":["getWebProtocol"],"updatePoint":{"line":8,"column":34},"line":8,"code":"  test('should handle emtpy string', () => {\n    expect(getWebProtocol('', 'http')).toBe('http');\n  });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should have header priority over request protocol","suites":["getWebProtocol"],"updatePoint":{"line":12,"column":57},"line":12,"code":"  test('should have header priority over request protocol', () => {\n    expect(getWebProtocol('https', 'http')).toBe('https');\n  });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should have handle empty protocol","suites":["getWebProtocol"],"updatePoint":{"line":16,"column":41},"line":16,"code":"  test('should have handle empty protocol', () => {\n    expect(getWebProtocol('https', '')).toBe('https');\n  });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should have handle invalid protocol","suites":["getWebProtocol"],"updatePoint":{"line":20,"column":43},"line":20,"code":"  test('should have handle invalid protocol', () => {\n    expect(getWebProtocol('ftp', '')).toBe('http');\n  });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should handle http","suites":["getWebProtocol","getWebProtocol and HAProxy variant"],"updatePoint":{"line":26,"column":28},"line":26,"code":"    test('should handle http', () => {\n      expect(getWebProtocol('http,http', 'https')).toBe('http');\n    });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should handle https","suites":["getWebProtocol","getWebProtocol and HAProxy variant"],"updatePoint":{"line":30,"column":29},"line":30,"code":"    test('should handle https', () => {\n      expect(getWebProtocol('https,https', 'http')).toBe('https');\n    });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should be HTTP/HTTPS protocol","suites":[],"updatePoint":{"line":3,"column":35},"line":3,"code":"test('should be HTTP/HTTPS protocol', () => {\n  expect(isURLhasValidProtocol('http://domain.com/-/static/logo.png')).toBeTruthy();\n  expect(isURLhasValidProtocol('https://www.domain.com/-/static/logo.png')).toBeTruthy();\n  expect(isURLhasValidProtocol('//domain.com/-/static/logo.png')).toBeTruthy();\n});","file":"htttProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should not be a valid HTTP protocol","suites":[],"updatePoint":{"line":9,"column":41},"line":9,"code":"test('should not be a valid HTTP protocol', () => {\n  expect(isURLhasValidProtocol('file:///home/user/logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('file:///F:/home/user/logo.png')).toBeFalsy();\n  // Note that uses ftp protocol in src was deprecated in modern browsers\n  expect(isURLhasValidProtocol('ftp://1.2.3.4/home/user/logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('./logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('.\\\\logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('../logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('..\\\\logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('../../static/logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('..\\\\..\\\\static\\\\logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('.logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('/static/logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('F:\\\\static\\\\logo.png')).toBeFalsy();\n});","file":"htttProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"valid host","suites":[],"updatePoint":{"line":3,"column":16},"line":3,"code":"test('valid host', () => {\n  expect(isHost('http://ddd.dd.og')).toBeTruthy();\n  expect(isHost('https://ddd.dd.og')).toBeTruthy();\n  expect(isHost('https://ddd.dd.og/valid')).toBeTruthy();\n  expect(isHost('ddd.dd.og')).toBeTruthy();\n  expect(isHost('ddd.dd.og:40')).toBeTruthy();\n  expect(isHost('ddd.dd.og/someprefix')).toBeTruthy();\n});","file":"validHost.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"invalid","suites":[],"updatePoint":{"line":12,"column":13},"line":12,"code":"test('invalid', () => {\n  expect(isHost('/ddd.dd.og:40')).toBeFalsy();\n  expect(isHost('/')).toBeFalsy();\n  expect(isHost('')).toBeFalsy();\n  expect(isHost(undefined)).toBeFalsy();\n  expect(isHost(`/ddd.dd.og>\"<svg onload=\"alert(1)\">`)).toBeFalsy();\n});","file":"validHost.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"when sending a empty notification","suites":["Notifications:: notifyRequest"],"updatePoint":{"line":28,"column":41},"line":28,"code":"  test('when sending a empty notification', async () => {\n    const mockAgent = new MockAgent({ connections: 1 });\n    setGlobalDispatcher(mockAgent);\n    const mockClient = mockAgent.get(domain);\n    mockClient.intercept(options).reply(200, { body: 'test' });\n\n    const notificationResponse = await notify({}, {}, createRemoteUser('foo', []), 'bar');\n    expect(notificationResponse).toEqual([false]);\n  });","file":"notify-request.spec.ts","skipped":false,"dir":"packages/hooks/test"},{"name":"when sending a single notification","suites":["Notifications:: notifyRequest"],"updatePoint":{"line":38,"column":42},"line":38,"code":"  test('when sending a single notification', async () => {\n    const mockAgent = new MockAgent({ connections: 1 });\n    setGlobalDispatcher(mockAgent);\n    const mockClient = mockAgent.get(domain);\n    mockClient.intercept(options).reply(200, { body: 'test' });\n\n    const notificationResponse = await notify(\n      {},\n      singleHeaderNotificationConfig,\n      createRemoteUser('foo', []),\n      'bar'\n    );\n    expect(notificationResponse).toEqual([true]);\n    await mockClient.close();\n  });","file":"notify-request.spec.ts","skipped":false,"dir":"packages/hooks/test"},{"name":"when notification endpoint is missing","suites":["Notifications:: notifyRequest"],"updatePoint":{"line":54,"column":45},"line":54,"code":"  test('when notification endpoint is missing', async () => {\n    const mockAgent = new MockAgent({ connections: 1 });\n    setGlobalDispatcher(mockAgent);\n    const mockClient = mockAgent.get(domain);\n    mockClient.intercept(options).reply(200, { body: 'test' });\n    const name = 'package';\n    const config: Partial<Config> = {\n      // @ts-ignore\n      notify: {\n        method: 'POST',\n        endpoint: undefined,\n        content: '',\n      },\n    };\n    const notificationResponse = await notify({ name }, config, createRemoteUser('foo', []), 'bar');\n    expect(notificationResponse).toEqual([false]);\n  });","file":"notify-request.spec.ts","skipped":false,"dir":"packages/hooks/test"},{"name":"when multiple notifications","suites":["Notifications:: notifyRequest"],"updatePoint":{"line":72,"column":35},"line":72,"code":"  test('when multiple notifications', async () => {\n    const mockAgent = new MockAgent({ connections: 1 });\n    setGlobalDispatcher(mockAgent);\n    const mockClient = mockAgent.get(domain);\n    mockClient.intercept(options).reply(200, { body: 'test' });\n    mockClient.intercept(options).reply(400, {});\n    mockClient.intercept(options).reply(500, { message: 'Something bad happened' });\n\n    const name = 'package';\n    const responses = await notify({ name }, multiNotificationConfig, { name: 'foo' }, 'bar');\n    expect(responses).toEqual([true, false, false]);\n    await mockClient.close();\n  });","file":"notify-request.spec.ts","skipped":false,"dir":"packages/hooks/test"},{"name":"testing auth valid plugin loader","suites":["plugin loader","file plugins","absolute path"],"updatePoint":{"line":25,"column":44},"line":25,"code":"      test('testing auth valid plugin loader', async () => {\n        const config = getConfig('valid-plugin.yaml');\n        config.plugins = pluginsPartialsFolder;\n        const plugins = await asyncLoadPlugin(config.auth, { config, logger }, authSanitize);\n\n        expect(plugins).toHaveLength(1);\n      });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"should handle does not exist plugin folder","suites":["plugin loader","file plugins","absolute path"],"updatePoint":{"line":33,"column":54},"line":33,"code":"      test('should handle does not exist plugin folder', async () => {\n        const config = getConfig('plugins-folder-fake.yaml');\n        const plugins = await asyncLoadPlugin(\n          config.auth,\n          { logger: logger, config: config },\n          authSanitize\n        );\n\n        expect(plugins).toHaveLength(0);\n      });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"testing load auth npm package invalid method check","suites":["plugin loader","file plugins","absolute path"],"updatePoint":{"line":44,"column":62},"line":44,"code":"      test('testing load auth npm package invalid method check', async () => {\n        const config = getConfig('valid-plugin.yaml');\n        config.plugins = pluginsPartialsFolder;\n        const plugins = await asyncLoadPlugin<pluginUtils.Auth<unknown>>(\n          config.auth,\n          { config, logger },\n          // @ts-expect-error\n          (p) => typeof p.somethingFake !== 'undefined'\n        );\n\n        expect(plugins).toHaveLength(0);\n      });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"should fails if plugins folder is not a directory","suites":["plugin loader","file plugins","absolute path"],"updatePoint":{"line":57,"column":61},"line":57,"code":"      test('should fails if plugins folder is not a directory', async () => {\n        const config = getConfig('plugins-folder-fake.yaml');\n        // force file instead a folder.\n        config.plugins = path.join(__dirname, 'just-a-file.js');\n        const plugins = await asyncLoadPlugin(\n          config.auth,\n          { logger: logger, config: config },\n          authSanitize\n        );\n\n        expect(plugins).toHaveLength(0);\n      });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"should resolve plugin based on relative path","suites":["plugin loader","file plugins","relative path"],"updatePoint":{"line":71,"column":56},"line":71,"code":"      test('should resolve plugin based on relative path', async () => {\n        const config = getConfig('relative-plugins.yaml');\n        // force file instead a folder.\n        const plugins = await asyncLoadPlugin(\n          config.auth,\n          { logger: logger, config: config },\n          authSanitize\n        );\n\n        expect(plugins).toHaveLength(1);\n      });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"should fails if config path is missing","suites":["plugin loader","file plugins","relative path"],"updatePoint":{"line":83,"column":50},"line":83,"code":"      test('should fails if config path is missing', async () => {\n        const config = getConfig('relative-plugins.yaml');\n        // @ts-expect-error\n        config.configPath = undefined;\n        // @ts-expect-error\n        config.config_path = undefined;\n        // force file instead a folder.\n        const plugins = await asyncLoadPlugin(\n          config.auth,\n          { logger: logger, config: config },\n          authSanitize\n        );\n\n        expect(plugins).toHaveLength(0);\n      });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"should fails if config path is missing (only config_path)","suites":["plugin loader","file plugins","relative path"],"updatePoint":{"line":100,"column":69},"line":100,"code":"      test('should fails if config path is missing (only config_path)', async () => {\n        const config = getConfig('relative-plugins.yaml');\n        // @ts-expect-error\n        config.configPath = undefined;\n        // force file instead a folder.\n        const plugins = await asyncLoadPlugin(\n          config.auth,\n          { logger: logger, config: config },\n          authSanitize\n        );\n\n        expect(plugins).toHaveLength(0);\n      });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"testing load auth npm package","suites":["plugin loader","npm plugins"],"updatePoint":{"line":117,"column":39},"line":117,"code":"    test('testing load auth npm package', async () => {\n      const config = getConfig('npm-plugin-auth.yaml');\n      const plugins = await asyncLoadPlugin(config.auth, { config, logger }, authSanitize);\n\n      expect(plugins).toHaveLength(1);\n    });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"should handle not found installed package","suites":["plugin loader","npm plugins"],"updatePoint":{"line":124,"column":51},"line":124,"code":"    test('should handle not found installed package', async () => {\n      const config = getConfig('npm-plugin-not-found.yaml');\n      const plugins = await asyncLoadPlugin<pluginUtils.Auth<unknown>>(\n        config.auth,\n        { config, logger },\n        (p) => typeof p.authenticate !== 'undefined'\n      );\n\n      expect(plugins).toHaveLength(0);\n    });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"testing load auth npm package invalid method check","suites":["plugin loader","npm plugins"],"updatePoint":{"line":135,"column":60},"line":135,"code":"    test('testing load auth npm package invalid method check', async () => {\n      const config = getConfig('npm-plugin-auth.yaml');\n      const plugins = await asyncLoadPlugin<pluginUtils.Auth<unknown>>(\n        config.auth,\n        { config, logger },\n        // @ts-expect-error\n        (p) => typeof p.somethingFake !== 'undefined'\n      );\n\n      expect(plugins).toHaveLength(0);\n    });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"testing load auth npm package custom prefix","suites":["plugin loader","npm plugins"],"updatePoint":{"line":147,"column":53},"line":147,"code":"    test('testing load auth npm package custom prefix', async () => {\n      const config = getConfig('custom-prefix-auth.yaml');\n      const plugins = await asyncLoadPlugin(\n        config.auth,\n        { config, logger },\n        authSanitize,\n        'customprefix'\n      );\n\n      expect(plugins).toHaveLength(1);\n    });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"testing load auth scope npm package","suites":["plugin loader","npm plugins"],"updatePoint":{"line":159,"column":45},"line":159,"code":"    test('testing load auth scope npm package', async () => {\n      const config = getConfig('scope-auth.yaml');\n      const plugins = await asyncLoadPlugin(config.auth, { config, logger }, authSanitize);\n      expect(plugins).toHaveLength(1);\n    });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"should fallback to npm package if does not find on plugins folder","suites":["plugin loader","fallback plugins"],"updatePoint":{"line":167,"column":75},"line":167,"code":"    test('should fallback to npm package if does not find on plugins folder', async () => {\n      const config = getConfig('npm-plugin-auth.yaml');\n      config.plugins = pluginsPartialsFolder;\n      const plugins = await asyncLoadPlugin(config.auth, { config, logger }, authSanitize);\n\n      expect(plugins).toHaveLength(1);\n    });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"should fallback to npm package if plugins folder does not exist","suites":["plugin loader","fallback plugins"],"updatePoint":{"line":175,"column":73},"line":175,"code":"    test('should fallback to npm package if plugins folder does not exist', async () => {\n      const config = getConfig('npm-plugin-auth.yaml');\n      config.plugins = '/does-not-exist';\n      const plugins = await asyncLoadPlugin(config.auth, { config, logger }, authSanitize);\n\n      expect(plugins).toHaveLength(1);\n    });","file":"plugin_loader_async.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"should allow request","suites":[],"updatePoint":{"line":11,"column":26},"line":11,"code":"test('should allow request', async () => {\n  const can = allow(\n    {\n      allow_publish: (params, remove, cb) => {\n        return cb(null, true);\n      },\n    },\n    logger\n  );\n  const app = getApp([]);\n  // @ts-ignore\n  app.get('/:package', can('publish'), (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  return request(app).get('/react').expect(HTTP_STATUS.OK);\n});","file":"allow.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should allow scope request","suites":[],"updatePoint":{"line":29,"column":32},"line":29,"code":"test('should allow scope request', async () => {\n  const can = allow(\n    {\n      allow_publish: (params, remove, cb) => {\n        return cb(null, true);\n      },\n    },\n    logger\n  );\n  const app = getApp([]);\n  // @ts-ignore\n  app.get('/:package/:scope', can('publish'), (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  return request(app).get('/@verdaccio/core').expect(HTTP_STATUS.OK);\n});","file":"allow.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should allow filename request","suites":[],"updatePoint":{"line":47,"column":35},"line":47,"code":"test('should allow filename request', async () => {\n  const can = allow(\n    {\n      allow_publish: (params, remove, cb) => {\n        return cb(null, true);\n      },\n    },\n    logger\n  );\n  const app = getApp([]);\n  // @ts-ignore\n  app.get('/:filename', can('publish'), (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  return request(app).get('/aaa-0.0.1.tgz').expect(HTTP_STATUS.OK);\n});","file":"allow.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should not allow request","suites":[],"updatePoint":{"line":65,"column":30},"line":65,"code":"test('should not allow request', async () => {\n  const can = allow(\n    {\n      allow_publish: (params, remove, cb) => {\n        return cb(null, false);\n      },\n    },\n    logger\n  );\n  const app = getApp([]);\n  // @ts-ignore\n  app.get('/sec', can('publish'), (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  return request(app).get('/sec').expect(HTTP_STATUS.INTERNAL_ERROR);\n});","file":"allow.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should handle error request","suites":[],"updatePoint":{"line":83,"column":33},"line":83,"code":"test('should handle error request', async () => {\n  const can = allow(\n    {\n      allow_publish: (params, remove, cb) => {\n        return cb(Error('foo error'));\n      },\n    },\n    logger\n  );\n  const app = getApp([]);\n  // @ts-ignore\n  app.get('/err', can('publish'));\n\n  return request(app).get('/err').expect(HTTP_STATUS.INTERNAL_ERROR);\n});","file":"allow.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"encode is json","suites":[],"updatePoint":{"line":8,"column":20},"line":8,"code":"test('encode is json', async () => {\n  const app = getApp([]);\n  // @ts-ignore\n  app.use(encodeScopePackage);\n  // @ts-ignore\n  app.get('/:id', (req, res) => {\n    const { id } = req.params;\n    res.status(HTTP_STATUS.OK).json({ id });\n  });\n\n  const res = await request(app).get('/@scope/foo');\n  expect(res.body).toEqual({ id: '@scope/foo' });\n  expect(res.status).toEqual(HTTP_STATUS.OK);\n});","file":"encode.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"handle error as object","suites":[],"updatePoint":{"line":9,"column":28},"line":9,"code":"test('handle error as object', async () => {\n  const app = express();\n  app.use(bodyParser.json({ strict: false, limit: '10mb' }));\n  app.get('/401', (req, res, next) => {\n    res.status(HTTP_STATUS.UNAUTHORIZED);\n    next({ error: 'some error' });\n  });\n  // @ts-ignore\n  app.use(final);\n\n  const res = await request(app).get('/401');\n  expect(res.get(HEADERS.WWW_AUTH)).toEqual('Basic, Bearer');\n  expect(res.get(HEADERS.CONTENT_TYPE)).toEqual(HEADERS.JSON_CHARSET);\n  expect(res.get(HEADERS.ETAG)).toEqual('W/\"1c-CP1UoQiM59AjHpEk0334sfSp1kc\"');\n  expect(res.body).toEqual({ error: 'some error' });\n});","file":"final.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"handle error as string","suites":[],"updatePoint":{"line":26,"column":28},"line":26,"code":"test('handle error as string', async () => {\n  const app = express();\n  app.use(bodyParser.json({ strict: false, limit: '10mb' }));\n  app.get('/200', (req, res, next) => {\n    res.status(HTTP_STATUS.OK);\n    // error as json string\n    next(JSON.stringify({ error: 'some error' }));\n  });\n  // @ts-ignore\n  app.use(final);\n\n  const res = await request(app).get('/200');\n  expect(res.get(HEADERS.WWW_AUTH)).not.toBeDefined();\n  expect(res.get(HEADERS.CONTENT_TYPE)).toEqual(HEADERS.JSON_CHARSET);\n  expect(res.get(HEADERS.ETAG)).toEqual('\"3f3a7b9afa23269e16685af6e707d109\"');\n  expect(res.body).toEqual({ error: 'some error' });\n});","file":"final.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"handle error as unknown string no parsable","suites":[],"updatePoint":{"line":44,"column":48},"line":44,"code":"test('handle error as unknown string no parsable', async () => {\n  const app = express();\n  app.use(bodyParser.json({ strict: false, limit: '10mb' }));\n  app.get('/200', (req, res) => {\n    res.status(HTTP_STATUS.OK);\n    // error as json string\n    throw Error('uknonwn');\n  });\n  // @ts-ignore\n  app.use(final);\n\n  const res = await request(app).get('/200');\n  expect(res.get(HEADERS.WWW_AUTH)).not.toBeDefined();\n  expect(res.get(HEADERS.CONTENT_TYPE)).toEqual(HEADERS.JSON_CHARSET);\n  expect(res.get(HEADERS.ETAG)).toEqual('\"8a80554c91d9fca8acb82f023de02f11\"');\n  expect(res.body).toEqual({});\n});","file":"final.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"body is json","suites":[],"updatePoint":{"line":9,"column":18},"line":9,"code":"test('body is json', async () => {\n  const app = getApp([]);\n  app.use(bodyParser.json({ strict: false, limit: '10mb' }));\n  // @ts-ignore\n  app.put('/json', expectJson, (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  return request(app)\n    .put('/json')\n    .send({ name: 'john' })\n    .set(HEADERS.CONTENT_TYPE, 'application/json')\n    .expect(HTTP_STATUS.OK);\n});","file":"json.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"body is not json","suites":[],"updatePoint":{"line":24,"column":22},"line":24,"code":"test('body is not json', async () => {\n  const app = getApp([]);\n  // @ts-ignore\n  app.put('/json', expectJson, (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  return request(app).put('/json').send('test=4').expect(HTTP_STATUS.BAD_REQUEST);\n});","file":"json.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should log request","suites":[],"updatePoint":{"line":17,"column":24},"line":17,"code":"test('should log request', async () => {\n  const app = getApp([]);\n  // @ts-ignore\n  app.use(log(logger));\n  // @ts-ignore\n  app.get('/:package', (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  // TODO: pending output\n  return request(app).get('/react').expect(HTTP_STATUS.OK);\n});","file":"log.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should not be a loop","suites":[],"updatePoint":{"line":8,"column":26},"line":8,"code":"test('should not be a loop', async () => {\n  const app = getApp([]);\n  // @ts-ignore\n  app.use(antiLoop({ server_id: '1' }));\n  app.get('/sec', (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  return request(app).get('/sec').set('via', 'Server 2').expect(HTTP_STATUS.OK);\n});","file":"loop.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should be a loop","suites":[],"updatePoint":{"line":19,"column":22},"line":19,"code":"test('should be a loop', async () => {\n  const app = getApp([]);\n  // @ts-ignore\n  app.use(antiLoop({ server_id: '1' }));\n  app.get('/sec', (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  return request(app)\n    .get('/sec')\n    .set('via', 'Server 1, Server 2')\n    .expect(HTTP_STATUS.LOOP_DETECTED);\n});","file":"loop.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"media is json","suites":[],"updatePoint":{"line":9,"column":19},"line":9,"code":"test('media is json', async () => {\n  const app = getApp([]);\n  app.get('/json', media(mime.getType('json')), (req, res) => {\n    res.status(200).json();\n  });\n\n  return request(app)\n    .get('/json')\n    .set(HEADERS.CONTENT_TYPE, 'application/json')\n    .expect('Content-Type', /json/)\n    .expect(200);\n});","file":"media.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"media is not json","suites":[],"updatePoint":{"line":22,"column":23},"line":22,"code":"test('media is not json', async () => {\n  const app = getApp([]);\n  app.get('/json', media(mime.getType('json')), (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  return request(app)\n    .get('/json')\n    .set(HEADERS.CONTENT_TYPE, 'text/html; charset=utf-8')\n    .expect('Content-Type', /html/)\n    .expect(HTTP_STATUS.UNSUPPORTED_MEDIA);\n});","file":"media.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should validate package name","suites":["validate params"],"updatePoint":{"line":9,"column":36},"line":9,"code":"  test('should validate package name', async () => {\n    const app = getApp([]);\n    // @ts-ignore\n    app.param('package', validatePackage);\n    app.get('/pkg/:package', (req, res) => {\n      res.status(HTTP_STATUS.OK).json({});\n    });\n\n    return request(app).get('/pkg/react').expect(HTTP_STATUS.OK);\n  });","file":"params.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should fails validate package name","suites":["validate params"],"updatePoint":{"line":20,"column":42},"line":20,"code":"  test('should fails validate package name', async () => {\n    const app = getApp([]);\n    // @ts-ignore\n    app.param('package', validatePackage);\n    app.get('/pkg/:package', (req, res) => {\n      res.status(HTTP_STATUS.OK).json({});\n    });\n\n    return request(app).get('/pkg/node_modules').expect(HTTP_STATUS.FORBIDDEN);\n  });","file":"params.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should fails file name package name","suites":["validate params"],"updatePoint":{"line":31,"column":43},"line":31,"code":"  test('should fails file name package name', async () => {\n    const app = getApp([]);\n    // @ts-ignore\n    app.param('filename', validateName);\n    app.get('/file/:filename', (req, res) => {\n      res.status(HTTP_STATUS.OK).json({});\n    });\n\n    return request(app).get('/file/__proto__').expect(HTTP_STATUS.FORBIDDEN);\n  });","file":"params.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should validate file name package name","suites":["validate params"],"updatePoint":{"line":42,"column":46},"line":42,"code":"  test('should validate file name package name', async () => {\n    const app = getApp([]);\n    // @ts-ignore\n    app.param('filename', validateName);\n    app.get('/file/:filename', (req, res) => {\n      res.status(HTTP_STATUS.OK).json({});\n    });\n\n    return request(app).get('/file/react.tar.gz').expect(HTTP_STATUS.OK);\n  });","file":"params.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should not match middleware","suites":["match"],"updatePoint":{"line":55,"column":35},"line":55,"code":"  test('should not match middleware', async () => {\n    const app = getApp([]);\n    app.param('_rev', match(/^-rev$/));\n    app.param('org_couchdb_user', match(/^org\\.couchdb\\.user:/));\n    app.get('/-/user/:org_couchdb_user', (req, res) => {\n      res.status(HTTP_STATUS.OK).json({});\n    });\n\n    app.use((res: any) => {\n      res.status(HTTP_STATUS.INTERNAL_ERROR);\n    });\n\n    return request(app).get('/-/user/test').expect(HTTP_STATUS.INTERNAL_ERROR);\n  });","file":"params.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should match middleware","suites":["match"],"updatePoint":{"line":70,"column":31},"line":70,"code":"  test('should match middleware', async () => {\n    const app = getApp([]);\n    app.param('_rev', match(/^-rev$/));\n    app.get('/-/user/:_rev?', (req, res) => {\n      res.status(HTTP_STATUS.OK).json({});\n    });\n\n    app.use((res: any) => {\n      res.status(HTTP_STATUS.INTERNAL_ERROR);\n    });\n\n    return request(app).get('/-/user/-rev').expect(HTTP_STATUS.OK);\n  });","file":"params.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should get frame options","suites":[],"updatePoint":{"line":8,"column":30},"line":8,"code":"test('should get frame options', async () => {\n  const app = getApp([]);\n  // @ts-ignore\n  app.use(setSecurityWebHeaders);\n  app.get('/sec', (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  const res = await request(app).get('/sec').expect(HTTP_STATUS.OK);\n  expect(res.get(HEADERS.FRAMES_OPTIONS)).toEqual('deny');\n});","file":"security.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should get csp options","suites":[],"updatePoint":{"line":20,"column":28},"line":20,"code":"test('should get csp options', async () => {\n  const app = getApp([]);\n  // @ts-ignore\n  app.use(setSecurityWebHeaders);\n  app.get('/sec', (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  const res = await request(app).get('/sec').expect(HTTP_STATUS.OK);\n  expect(res.get(HEADERS.CSP)).toEqual(\"connect-src 'self'\");\n});","file":"security.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should get cto","suites":[],"updatePoint":{"line":32,"column":20},"line":32,"code":"test('should get cto', async () => {\n  const app = getApp([]);\n  // @ts-ignore\n  app.use(setSecurityWebHeaders);\n  app.get('/sec', (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  const res = await request(app).get('/sec').expect(HTTP_STATUS.OK);\n  expect(res.get(HEADERS.CTO)).toEqual('nosniff');\n});","file":"security.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should get xss","suites":[],"updatePoint":{"line":44,"column":20},"line":44,"code":"test('should get xss', async () => {\n  const app = getApp([]);\n  // @ts-ignore\n  app.use(setSecurityWebHeaders);\n  app.get('/sec', (req, res) => {\n    res.status(HTTP_STATUS.OK).json({});\n  });\n\n  const res = await request(app).get('/sec').expect(HTTP_STATUS.OK);\n  expect(res.get(HEADERS.XSS)).toEqual('1; mode=block');\n});","file":"security.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should return no address if a single address is wrong","suites":["getListListenAddresses test"],"updatePoint":{"line":11,"column":61},"line":11,"code":"  test('should return no address if a single address is wrong', () => {\n    // @ts-ignore\n    const addrs = getListListenAddresses('wrong');\n\n    expect(_.isArray(addrs)).toBeTruthy();\n    expect(addrs).toHaveLength(0);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should return no address if a two address are wrong","suites":["getListListenAddresses test"],"updatePoint":{"line":19,"column":59},"line":19,"code":"  test('should return no address if a two address are wrong', () => {\n    // @ts-ignore\n    const addrs = getListListenAddresses(['wrong', 'same-wrong']);\n\n    expect(_.isArray(addrs)).toBeTruthy();\n    expect(addrs).toHaveLength(0);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should return a list of 1 address provided","suites":["getListListenAddresses test"],"updatePoint":{"line":27,"column":50},"line":27,"code":"  test('should return a list of 1 address provided', () => {\n    // @ts-ignore\n    const addrs = getListListenAddresses(null, '1000');\n\n    expect(_.isArray(addrs)).toBeTruthy();\n    expect(addrs).toHaveLength(1);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should return a list of 2 address provided","suites":["getListListenAddresses test"],"updatePoint":{"line":35,"column":50},"line":35,"code":"  test('should return a list of 2 address provided', () => {\n    // @ts-ignore\n    const addrs = getListListenAddresses(null, ['1000', '2000']);\n\n    expect(_.isArray(addrs)).toBeTruthy();\n    expect(addrs).toHaveLength(2);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should return by default ","suites":["getListListenAddresses test"],"updatePoint":{"line":43,"column":48},"line":43,"code":"  test(`should return by default ${DEFAULT_PORT}`, () => {\n    // @ts-ignore\n    const [addrs] = getListListenAddresses();\n\n    // @ts-ignore\n    expect(addrs.proto).toBe(DEFAULT_PROTOCOL);\n    // @ts-ignore\n    expect(addrs.host).toBe(DEFAULT_DOMAIN);\n    // @ts-ignore\n    expect(addrs.port).toBe(DEFAULT_PORT);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should return default proto, host and custom port","suites":["getListListenAddresses test"],"updatePoint":{"line":55,"column":57},"line":55,"code":"  test('should return default proto, host and custom port', () => {\n    const initPort = '1000';\n    // @ts-ignore\n    const [addrs] = getListListenAddresses(null, initPort);\n\n    // @ts-ignore\n    expect(addrs.proto).toEqual(DEFAULT_PROTOCOL);\n    // @ts-ignore\n    expect(addrs.host).toEqual(DEFAULT_DOMAIN);\n    // @ts-ignore\n    expect(addrs.port).toEqual(initPort);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should parse (%s - %s - %s - %s)","suites":["Parse listen address"],"line":33,"code":"  test.each(useCases)(`should parse (%s - %s - %s - %s)`, (uri, proto, host, port) => {\n    const parsed = parseAddress(uri);\n\n    if (_.isNull(proto)) {\n      expect(parsed).toBeNull();\n    } else if (port) {\n      expect(parsed).toEqual({\n        proto,\n        host,\n        port,\n      });\n    } else {\n      expect(parsed).toEqual({\n        proto,\n        path: host,\n      });\n    }\n  });","file":"parseAddress.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should provide all HTTP server data","suites":["startServer via API"],"updatePoint":{"line":6,"column":43},"line":6,"code":"  test('should provide all HTTP server data', async () => {\n    const webServer = await runServer();\n    expect(webServer).toBeDefined();\n    await request(webServer).get('/').expect(200);\n  });","file":"run-server.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should fail on start with empty configuration","suites":["startServer via API"],"updatePoint":{"line":12,"column":53},"line":12,"code":"  test('should fail on start with empty configuration', async () => {\n    // @ts-expect-error\n    await expect(runServer({})).rejects.toThrow('config_path is required');\n  });","file":"run-server.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should fail on start with null as entry","suites":["startServer via API"],"updatePoint":{"line":17,"column":47},"line":17,"code":"  test('should fail on start with null as entry', async () => {\n    // @ts-expect-error\n    await expect(runServer(null)).rejects.toThrow();\n  });","file":"run-server.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"get error when connection fails","suites":["Active Directory Plugin"],"updatePoint":{"line":40,"column":39},"line":40,"code":"  test('get error when connection fails', (done) => {\n    const errorMessage = 'Unknown error';\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(errorMessage, undefined));\n\n    adPlugin.authenticate('', '', (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(logger.warn).toHaveBeenCalled();\n      expect(error.code).toBe(HTTP_STATUS.INTERNAL_ERROR);\n      expect(error.message).toBe(errorMessage);\n      expect(authUser).toBeUndefined();\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"get error when not authenticated satisfactory","suites":["Active Directory Plugin"],"updatePoint":{"line":54,"column":53},"line":54,"code":"  test('get error when not authenticated satisfactory', (done) => {\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, false));\n\n    adPlugin.authenticate('', '', (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(logger.warn).toHaveBeenCalledWith(NotAuthMessage);\n      expect(error.code).toBe(HTTP_STATUS.UNAUTHORIZED);\n      expect(error.message).toBe(NotAuthMessage);\n      expect(authUser).toBeUndefined();\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"connect satisfactory without groups","suites":["Active Directory Plugin"],"updatePoint":{"line":67,"column":43},"line":67,"code":"  test('connect satisfactory without groups', (done) => {\n    const user = 'user';\n    const password = 'password';\n\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, true));\n\n    adPlugin.authenticate(user, password, (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(logger.info).toHaveBeenCalled();\n      expect(error).toBeNull();\n      expect(authUser).toStrictEqual([user]);\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"get error when getting groups for user","suites":["Active Directory Plugin"],"updatePoint":{"line":82,"column":46},"line":82,"code":"  test('get error when getting groups for user', (done) => {\n    const errorMessage = 'Unknown error retrieving groups';\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, true));\n    ActiveDirectory.prototype.getGroupMembershipForUser = jest.fn((_, cb) =>\n      cb(errorMessage as unknown as object, null)\n    ) as jest.Mock;\n\n    adPluginSingleGroup.authenticate('', '', (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(ActiveDirectory.prototype.getGroupMembershipForUser).toHaveBeenCalled();\n      expect(logger.warn).toHaveBeenCalled();\n      expect(error.code).toBe(HTTP_STATUS.INTERNAL_ERROR);\n      expect(error.message).toBe(errorMessage);\n      expect(authUser).toBeUndefined();\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"get error when user groups do not match","suites":["Active Directory Plugin"],"updatePoint":{"line":100,"column":47},"line":100,"code":"  test('get error when user groups do not match', (done) => {\n    const user = 'user';\n    const password = 'password';\n\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, true));\n    ActiveDirectory.prototype.getGroupMembershipForUser = jest.fn((_, cb) =>\n      cb(null, [{ cn: 'notMatchGroup' }])\n    ) as jest.Mock;\n\n    adPluginSingleGroup.authenticate(user, password, (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(ActiveDirectory.prototype.getGroupMembershipForUser).toHaveBeenCalled();\n      expect(logger.warn).toHaveBeenCalled();\n      expect(error.code).toBe(HTTP_STATUS.FORBIDDEN);\n      expect(error.message).toBe(\n        `AD - User ${user} is not member of group(s): ${configSingleGroup.groupName}`\n      );\n      expect(authUser).toBeUndefined();\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"connect satisfactory when connection has only one group defined","suites":["Active Directory Plugin"],"updatePoint":{"line":122,"column":71},"line":122,"code":"  test('connect satisfactory when connection has only one group defined', (done) => {\n    const { groupName } = configSingleGroup;\n    const user = 'user';\n    const password = 'password';\n\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, true));\n    ActiveDirectory.prototype.getGroupMembershipForUser = jest.fn((_, cb) =>\n      cb(null, [{ cn: groupName }])\n    ) as jest.Mock;\n\n    adPluginSingleGroup.authenticate(user, password, (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(ActiveDirectory.prototype.getGroupMembershipForUser).toHaveBeenCalled();\n      expect(logger.info).toHaveBeenCalled();\n      expect(error).toBeNull();\n      expect(authUser).toStrictEqual([groupName, user]);\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"connect satisfactory when connection has multiple groups defined","suites":["Active Directory Plugin"],"updatePoint":{"line":142,"column":72},"line":142,"code":"  test('connect satisfactory when connection has multiple groups defined', (done) => {\n    const [, group2, group3] = configMultiGroups.groupName;\n    const user = 'user';\n    const password = 'password';\n\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, true));\n    ActiveDirectory.prototype.getGroupMembershipForUser = jest.fn((_, cb) =>\n      cb(null, [{ cn: group2 }, { dn: group3 }])\n    ) as jest.Mock;\n\n    adPluginMultiGroups.authenticate(user, password, (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(ActiveDirectory.prototype.getGroupMembershipForUser).toHaveBeenCalled();\n      expect(logger.info).toHaveBeenCalled();\n      expect(error).toBeNull();\n      expect(authUser).toStrictEqual([group2, group3, user]);\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"should test audit","suites":["Audit plugin"],"updatePoint":{"line":19,"column":25},"line":19,"code":"  test('should test audit', () => {\n    const audit = new ProxyAudit(auditConfig, {\n      logger,\n      config: new Config(parseConfigFile(join(__dirname, 'config.yaml'))),\n    });\n    expect(audit).toBeDefined();\n  });","file":"audit.spec.ts","skipped":false,"dir":"packages/plugins/audit/tests"},{"name":"should test audit with configuration","suites":["Audit plugin"],"updatePoint":{"line":27,"column":44},"line":27,"code":"  test('should test audit with configuration', () => {\n    const config = { strict_ssl: false } as ConfigAudit;\n    const audit = new ProxyAudit(auditConfig, { logger, config: config });\n    expect(audit).toBeDefined();\n    // expect(audit.strict_ssl).toBeFalsy();\n  });","file":"audit.spec.ts","skipped":false,"dir":"packages/plugins/audit/tests"},{"name":"should handle /-/npm/v1/security/audits/quick","suites":["Audit plugin"],"updatePoint":{"line":34,"column":53},"line":34,"code":"  test('should handle /-/npm/v1/security/audits/quick', async () => {\n    nock('https://registry.npmjs.org')\n      .post('/-/npm/v1/security/audits/quick')\n      .reply(200, { foo: 'someData' });\n    const config = { strict_ssl: false } as ConfigAudit;\n    const audit = new ProxyAudit(auditConfig, { logger, config: config });\n    const app = express();\n    audit.register_middlewares(app, {\n      // @ts-ignore\n      config: {\n        https_proxy: '',\n        http_proxy: '',\n      },\n    });\n    await supertest(app).post('/-/npm/v1/security/audits/quick').expect(HTTP_STATUS.OK);\n  });","file":"audit.spec.ts","skipped":false,"dir":"packages/plugins/audit/tests"},{"name":"should handle /-/npm/v1/security/audits/bulk","suites":["Audit plugin"],"updatePoint":{"line":51,"column":52},"line":51,"code":"  test('should handle /-/npm/v1/security/audits/bulk', async () => {\n    nock('https://registry.npmjs.org')\n      .post('/-/npm/v1/security/advisories/bulk')\n      .reply(200, { foo: 'someData' });\n    const config = { strict_ssl: false } as ConfigAudit;\n    const audit = new ProxyAudit(auditConfig, { logger, config: config });\n    const app = express();\n    audit.register_middlewares(app, {\n      // @ts-ignore\n      config: {\n        https_proxy: '',\n        http_proxy: '',\n      },\n    });\n    await supertest(app).post('/-/npm/v1/security/advisories/bulk').expect(HTTP_STATUS.OK);\n  });","file":"audit.spec.ts","skipped":false,"dir":"packages/plugins/audit/tests"},{"name":"should handle /-/npm/v1/security/audits","suites":["Audit plugin"],"updatePoint":{"line":68,"column":47},"line":68,"code":"  test('should handle /-/npm/v1/security/audits', async () => {\n    nock('https://registry.npmjs.org')\n      .post('/-/npm/v1/security/audits')\n      .reply(200, { foo: 'someData' });\n    const config = { strict_ssl: false } as ConfigAudit;\n    const audit = new ProxyAudit(auditConfig, { logger, config: config });\n    const app = express();\n    audit.register_middlewares(app, {\n      // @ts-ignore\n      config: {\n        https_proxy: '',\n        http_proxy: '',\n      },\n    });\n    await supertest(app).post('/-/npm/v1/security/audits').expect(HTTP_STATUS.OK);\n  });","file":"audit.spec.ts","skipped":false,"dir":"packages/plugins/audit/tests"},{"name":"should handle proxy","suites":["Audit plugin"],"updatePoint":{"line":85,"column":27},"line":85,"code":"  test('should handle proxy', async () => {\n    nock('https://registry.npmjs.org')\n      .post('/-/npm/v1/security/audits/quick')\n      .reply(200, { foo: 'someData' });\n    const config = { strict_ssl: false } as ConfigAudit;\n    const audit = new ProxyAudit(auditConfig, { logger, config: config });\n    const app = express();\n    audit.register_middlewares(app, {\n      // @ts-ignore\n      config: {\n        https_proxy: 'https://registry.proxy.org',\n        http_proxy: '',\n      },\n    });\n    await supertest(app).post('/-/npm/v1/security/audits/quick').expect(HTTP_STATUS.OK);\n  });","file":"audit.spec.ts","skipped":false,"dir":"packages/plugins/audit/tests"},{"name":"adds users","suites":["Memory","#adduser"],"updatePoint":{"line":39,"column":20},"line":39,"code":"    test('adds users', function (done) {\n      auth.adduser?.('test', 'secret', function (err, user) {\n        expect(err).toBeNull();\n        expect(user).toEqual(true);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"login existing users","suites":["Memory","#adduser"],"updatePoint":{"line":47,"column":30},"line":47,"code":"    test('login existing users', function (done) {\n      auth.adduser?.('test', 'secret', function (err, user) {\n        expect(err).toBeNull();\n        expect(user).toEqual(true);\n        auth.adduser?.('test', 'secret', function (err, user) {\n          expect(err).toBeNull();\n          expect(user).toBe(true);\n          done();\n        });\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"max users reached","suites":["Memory","#adduser"],"updatePoint":{"line":59,"column":27},"line":59,"code":"    test('max users reached', function (done) {\n      const auth = new Memory({ users } as VerdaccioMemoryConfig, {\n        // @ts-expect-error\n        config: { ...config, max_users: -1 },\n        logger,\n      });\n      auth.adduser?.('fooooooooo', 'secret', function (err) {\n        expect(err).not.toBeNull();\n        expect(err?.message).toMatch(/maximum amount of users reached/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $all to the package","suites":["Memory","#allow_access"],"updatePoint":{"line":96,"column":60},"line":96,"code":"    test('should be allowed to access as $all to the package', function (done) {\n      accessBy(['$all'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $anonymous to the package","suites":["Memory","#allow_access"],"updatePoint":{"line":100,"column":66},"line":100,"code":"    test('should be allowed to access as $anonymous to the package', function (done) {\n      accessBy(['$anonymous'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $authenticated to the package","suites":["Memory","#allow_access"],"updatePoint":{"line":104,"column":70},"line":104,"code":"    test('should be allowed to access as $authenticated to the package', function (done) {\n      accessBy(['$authenticated'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as test to the package","suites":["Memory","#allow_access"],"updatePoint":{"line":108,"column":60},"line":108,"code":"    test('should be allowed to access as test to the package', function (done) {\n      accessBy(['test'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should not to be allowed to access any package","suites":["Memory","#allow_access"],"updatePoint":{"line":112,"column":56},"line":112,"code":"    test('should not to be allowed to access any package', function (done) {\n      // @ts-expect-error\n      auth.allow_access?.({}, { access: [], publish: [], proxy: [] }, function (err) {\n        expect(err).not.toBeNull();\n        expect(err?.message).toMatch(/not allowed to access package/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should not to be allowed to access the anyOtherUser package","suites":["Memory","#allow_access"],"updatePoint":{"line":121,"column":69},"line":121,"code":"    test('should not to be allowed to access the anyOtherUser package', function (done) {\n      // @ts-expect-error\n      auth.allow_access?.({}, { access: ['anyOtherUser'], publish: [], proxy: [] }, function (err) {\n        expect(err).not.toBeNull();\n        expect(err?.message).toMatch(/not allowed to access package/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $all to the package","suites":["Memory","#allow_publish"],"updatePoint":{"line":154,"column":60},"line":154,"code":"    test('should be allowed to access as $all to the package', function (done) {\n      accessBy(['$all'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $anonymous to the package","suites":["Memory","#allow_publish"],"updatePoint":{"line":158,"column":66},"line":158,"code":"    test('should be allowed to access as $anonymous to the package', function (done) {\n      accessBy(['$anonymous'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $authenticated to the package","suites":["Memory","#allow_publish"],"updatePoint":{"line":162,"column":70},"line":162,"code":"    test('should be allowed to access as $authenticated to the package', function (done) {\n      accessBy(['$authenticated'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as test to the package","suites":["Memory","#allow_publish"],"updatePoint":{"line":166,"column":60},"line":166,"code":"    test('should be allowed to access as test to the package', function (done) {\n      accessBy(['test'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should not to be allowed to access any package","suites":["Memory","#allow_publish"],"updatePoint":{"line":170,"column":56},"line":170,"code":"    test('should not to be allowed to access any package', function (done) {\n      // @ts-expect-error\n      auth.allow_publish?.({}, { publish: [], proxy: [], access: [] }, function (err) {\n        expect(err).not.toBeNull();\n        expect(err?.message).toMatch(/not allowed to publish package/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should not to be allowed to access the anyOtherUser package","suites":["Memory","#allow_publish"],"updatePoint":{"line":179,"column":69},"line":179,"code":"    test('should not to be allowed to access the anyOtherUser package', function (done) {\n      // @ts-expect-error\n      auth.allow_publish({}, { publish: ['anyOtherUser'], proxy: [], access: [] }, function (err) {\n        expect(err).not.toBeNull();\n        expect(err?.message).toMatch(/not allowed to publish package/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should change password","suites":["Memory","#changePassword"],"updatePoint":{"line":205,"column":32},"line":205,"code":"    test('should change password', function (done) {\n      auth.changePassword('test', 'secret', 'newSecret', function (err, ok) {\n        expect(err).toBeNull();\n        expect(ok).toBe(true);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should fail change password with user not found","suites":["Memory","#changePassword"],"updatePoint":{"line":213,"column":57},"line":213,"code":"    test('should fail change password with user not found', function (done) {\n      auth.changePassword('NOTFOUND', 'secret', 'newSecret', function (err) {\n        expect(err).not.toBeNull();\n        expect(err.message).toMatch(/user not found/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"validates existing users","suites":["Memory","#authenticate"],"updatePoint":{"line":236,"column":34},"line":236,"code":"    test('validates existing users', function (done) {\n      auth.authenticate('test', 'secret', function (err, groups) {\n        expect(err).toBeNull();\n        expect(groups).toBeDefined();\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"fails if wrong password","suites":["Memory","#authenticate"],"updatePoint":{"line":244,"column":33},"line":244,"code":"    test('fails if wrong password', function (done) {\n      auth.authenticate('test', 'no-secret', function (err) {\n        expect(err).not.toBeNull();\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"fails if user does not exist","suites":["Memory","#authenticate"],"updatePoint":{"line":251,"column":38},"line":251,"code":"    test('fails if user does not exist', function (done) {\n      auth.authenticate('john', 'secret', function (err, groups) {\n        expect(err).toBeNull();\n        expect(groups).toBeFalsy();\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should match with the correct salt type","suites":["createSalt"],"updatePoint":{"line":14,"column":47},"line":14,"code":"  test('should match with the correct salt type', () => {\n    expect(createSalt(EncryptionMethod.crypt)).toEqual('/U');\n    expect(createSalt(EncryptionMethod.md5)).toEqual('$1$/UEGzD0RxS');\n    expect(createSalt(EncryptionMethod.blowfish)).toEqual('$2a$/UEGzD0RxS');\n    expect(createSalt(EncryptionMethod.sha256)).toEqual('$5$/UEGzD0RxS');\n    expect(createSalt(EncryptionMethod.sha512)).toEqual('$6$/UEGzD0RxS');\n  });","file":"crypt3.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should fails on unkwon type","suites":["createSalt"],"updatePoint":{"line":22,"column":35},"line":22,"code":"  test('should fails on unkwon type', () => {\n    expect(function () {\n      createSalt('bad' as any);\n    }).toThrow(/Unknown salt type at crypt3.createSalt: bad/);\n  });","file":"crypt3.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should generate legacy crypt salt by default","suites":["createSalt"],"updatePoint":{"line":28,"column":52},"line":28,"code":"  test('should generate legacy crypt salt by default', () => {\n    expect(createSalt()).toEqual(createSalt(EncryptionMethod.crypt));\n  });","file":"crypt3.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should ensure file path configuration exists","suites":["HTPasswd","constructor()"],"updatePoint":{"line":48,"column":54},"line":48,"code":"    test('should ensure file path configuration exists', () => {\n      expect(function () {\n        new HTPasswd({} as HTPasswdConfig, emptyPluginOptions);\n      }).toThrow(/should specify \"file\" in config/);\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error about incorrect algorithm","suites":["HTPasswd","constructor()"],"updatePoint":{"line":54,"column":54},"line":54,"code":"    test('should throw error about incorrect algorithm', () => {\n      expect(function () {\n        let invalidConfig = { algorithm: 'invalid', ...config } as HTPasswdConfig;\n        new HTPasswd(invalidConfig, emptyPluginOptions);\n      }).toThrow(/Invalid algorithm \"invalid\"/);\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should authenticate user with given credentials","suites":["HTPasswd","authenticate()"],"updatePoint":{"line":63,"column":60},"line":63,"code":"    test('it should authenticate user with given credentials', (done) => {\n      const users = [\n        { username: 'test', password: 'test' },\n        { username: 'username', password: 'password' },\n        { username: 'bcrypt', password: 'password' },\n      ];\n      let usersAuthenticated = 0;\n      const generateCallback = (username) => (error, userGroups) => {\n        usersAuthenticated += 1;\n        expect(error).toBeNull();\n        expect(userGroups).toContain(username);\n        usersAuthenticated === users.length && done();\n      };\n      users.forEach(({ username, password }) =>\n        wrapper.authenticate(username, password, generateCallback(username))\n      );\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should not authenticate user with given credentials","suites":["HTPasswd","authenticate()"],"updatePoint":{"line":81,"column":64},"line":81,"code":"    test('it should not authenticate user with given credentials', (done) => {\n      const users = ['test', 'username', 'bcrypt'];\n      let usersAuthenticated = 0;\n      const generateCallback = () => (error, userGroups) => {\n        usersAuthenticated += 1;\n        expect(error).toBeNull();\n        expect(userGroups).toBeFalsy();\n        usersAuthenticated === users.length && done();\n      };\n      users.forEach((username) =>\n        wrapper.authenticate(username, 'somerandompassword', generateCallback())\n      );\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should warn on slow password verification","suites":["HTPasswd","authenticate()"],"updatePoint":{"line":95,"column":54},"line":95,"code":"    test('it should warn on slow password verification', (done) => {\n      // @ts-ignore\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bcrypt.compare = jest.fn(async (_passwd, _hash) => {\n        await new Promise((resolve) => setTimeout(resolve, DEFAULT_SLOW_VERIFY_MS + 1));\n        return true;\n      });\n      const callback = (a, b): void => {\n        expect(a).toBeNull();\n        expect(b).toContain('bcrypt');\n        // TODO: figure out how to test the warning properly without mocking the logger\n        // maybe mocking pino? not sure.\n        // const mockWarn = options.logger.warn as jest.MockedFn<jest.MockableFunction>;\n        // expect(mockWarn.mock.calls.length).toBe(1);\n        // const [{ user, durationMs }, message] = mockWarn.mock.calls[0];\n        // expect(user).toEqual('bcrypt');\n        // expect(durationMs).toBeGreaterThan(DEFAULT_SLOW_VERIFY_MS);\n        // expect(message).toEqual('Password for user \"@{user}\" took @{durationMs}ms to verify');\n        done();\n      };\n      wrapper.authenticate('bcrypt', 'password', callback);\n    }, 18000);","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should not pass sanity check","suites":["HTPasswd","addUser()"],"updatePoint":{"line":120,"column":41},"line":120,"code":"    test('it should not pass sanity check', (done) => {\n      const callback = (a): void => {\n        expect(a.message).toEqual('unauthorized access');\n        done();\n      };\n      wrapper.adduser('test', 'somerandompassword', callback);\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should add the user","suites":["HTPasswd","addUser()"],"updatePoint":{"line":128,"column":32},"line":128,"code":"    test('it should add the user', (done) => {\n      let dataToWrite;\n      // @ts-ignore\n      fs.writeFile = jest.fn((_name, data, callback) => {\n        dataToWrite = data;\n        callback();\n      });\n\n      MockDate.set('2018-01-14T11:17:40.712Z');\n\n      const callback = (a, b): void => {\n        expect(a).toBeNull();\n        expect(b).toBeTruthy();\n        expect(fs.writeFile).toHaveBeenCalled();\n        expect(dataToWrite.indexOf('usernotpresent')).not.toEqual(-1);\n        done();\n      };\n      wrapper.adduser('usernotpresent', 'somerandompassword', callback);\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"sanityCheck should return an Error","suites":["HTPasswd","addUser()","addUser() error handling"],"updatePoint":{"line":149,"column":46},"line":149,"code":"      test('sanityCheck should return an Error', (done) => {\n        jest.doMock('../src/utils.ts', () => {\n          return {\n            sanityCheck: (): Error => Error('some error'),\n            HtpasswdHashAlgorithm,\n          };\n        });\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.adduser('sanityCheck', 'test', (sanity) => {\n          expect(sanity.message).toBeDefined();\n          expect(sanity.message).toMatch('some error');\n          done();\n        });\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"lockAndRead should return an Error","suites":["HTPasswd","addUser()","addUser() error handling"],"updatePoint":{"line":166,"column":46},"line":166,"code":"      test('lockAndRead should return an Error', (done) => {\n        jest.doMock('../src/utils.ts', () => {\n          return {\n            sanityCheck: (): any => null,\n            lockAndRead: (_a, b): any => b(new Error('lock error')),\n            HtpasswdHashAlgorithm,\n          };\n        });\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.adduser('lockAndRead', 'test', (sanity) => {\n          expect(sanity.message).toBeDefined();\n          expect(sanity.message).toMatch('lock error');\n          done();\n        });\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"addUserToHTPasswd should return an Error","suites":["HTPasswd","addUser()","addUser() error handling"],"updatePoint":{"line":184,"column":52},"line":184,"code":"      test('addUserToHTPasswd should return an Error', (done) => {\n        jest.doMock('../src/utils.ts', () => {\n          return {\n            sanityCheck: (): any => null,\n            parseHTPasswd: (): void => {},\n            lockAndRead: (_a, b): any => b(null, ''),\n            unlockFile: (_a, b): any => b(),\n            HtpasswdHashAlgorithm,\n          };\n        });\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.adduser('addUserToHTPasswd', 'test', () => {\n          done();\n        });\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"writeFile should return an Error","suites":["HTPasswd","addUser()","addUser() error handling"],"updatePoint":{"line":202,"column":44},"line":202,"code":"      test('writeFile should return an Error', (done) => {\n        jest.doMock('../src/utils.ts', () => {\n          return {\n            sanityCheck: (): any => null,\n            parseHTPasswd: (): void => {},\n            lockAndRead: (_a, b): any => b(null, ''),\n            addUserToHTPasswd: (): void => {},\n            HtpasswdHashAlgorithm,\n          };\n        });\n        jest.doMock('fs', () => {\n          const original = jest.requireActual('fs');\n          return {\n            ...original,\n            writeFile: jest.fn((_name, _data, callback) => {\n              callback(new Error('write error'));\n            }),\n          };\n        });\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.adduser('addUserToHTPasswd', 'test', (err) => {\n          expect(err).not.toBeNull();\n          expect(err.message).toMatch('write error');\n          done();\n        });\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should read the file and set the users","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":233,"column":53},"line":233,"code":"      test('it should read the file and set the users', (done) => {\n        const output = {\n          test: '$6FrCaT/v0dwE',\n          username: '$66to3JK5RgZM',\n          bcrypt: '$2y$04$K2Cn3StiXx4CnLmcTW/ymekOrj7WlycZZF9xgmoJ/U0zGPqSLPVBe',\n        };\n        const callback = (): void => {\n          expect(wrapper.users).toEqual(output);\n          done();\n        };\n        wrapper.reload(callback);\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"reload should fails on check file","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":246,"column":45},"line":246,"code":"      test('reload should fails on check file', (done) => {\n        jest.doMock('fs', () => {\n          return {\n            readFile: (_name, callback): void => {\n              callback(new Error('stat error'), null);\n            },\n            stat: (_name, callback): void => {\n              callback(new Error('stat error'), null);\n            },\n          };\n        });\n        const callback = (err): void => {\n          expect(err).not.toBeNull();\n          expect(err.message).toMatch('stat error');\n          done();\n        };\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.reload(callback);\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"reload times match","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":268,"column":30},"line":268,"code":"      test('reload times match', (done) => {\n        jest.doMock('fs', () => {\n          return {\n            readFile: (_name, callback): void => {\n              callback(new Error('stat error'), null);\n            },\n            stat: (_name, callback): void => {\n              callback(null, {\n                mtime: null,\n              });\n            },\n          };\n        });\n        const callback = (err): void => {\n          expect(err).toBeUndefined();\n          done();\n        };\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.reload(callback);\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"reload should fails on read file","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":291,"column":44},"line":291,"code":"      test('reload should fails on read file', (done) => {\n        jest.doMock('fs', () => {\n          return {\n            stat: jest.requireActual('fs').stat,\n            readFile: (_name, _format, callback): void => {\n              callback(new Error('read error'), null);\n            },\n          };\n        });\n        const callback = (err): void => {\n          expect(err).not.toBeNull();\n          expect(err.message).toMatch('read error');\n          done();\n        };\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.reload(callback);\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"changePassword - it should throw an error for user not found","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":313,"column":68},"line":313,"code":"  test('changePassword - it should throw an error for user not found', (done) => {\n    const callback = (error, isSuccess): void => {\n      expect(error).not.toBeNull();\n      expect(error.message).toBe(\n        `Unable to change password for user 'usernotpresent': user does not currently exist`\n      );\n      expect(isSuccess).toBeFalsy();\n      done();\n    };\n    wrapper.changePassword('usernotpresent', 'oldPassword', 'newPassword', callback);\n  });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"changePassword - it should throw an error for wrong password","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":325,"column":68},"line":325,"code":"  test('changePassword - it should throw an error for wrong password', (done) => {\n    const callback = (error, isSuccess): void => {\n      expect(error).not.toBeNull();\n      expect(error.message).toBe(\n        `Unable to change password for user 'username': invalid old password`\n      );\n      expect(isSuccess).toBeFalsy();\n      done();\n    };\n    wrapper.changePassword('username', 'wrongPassword', 'newPassword', callback);\n  });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"changePassword - it should change password","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":337,"column":50},"line":337,"code":"  test('changePassword - it should change password', (done) => {\n    let dataToWrite;\n    // @ts-ignore\n    fs.writeFile = jest.fn((_name, data, callback) => {\n      dataToWrite = data;\n      callback();\n    });\n    const callback = (error, isSuccess): void => {\n      expect(error).toBeNull();\n      expect(isSuccess).toBeTruthy();\n      expect(fs.writeFile).toHaveBeenCalled();\n      expect(dataToWrite.indexOf('username')).not.toEqual(-1);\n      done();\n    };\n    wrapper.changePassword('username', 'password', 'newPassword', callback);\n  });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should parse the password for a single line","suites":["parseHTPasswd"],"updatePoint":{"line":43,"column":49},"line":43,"code":"  it('should parse the password for a single line', () => {\n    const input = 'test:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z';\n    const output = { test: '$6b9MlB3WUELU' };\n    expect(parseHTPasswd(input)).toEqual(output);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should parse the password for two lines","suites":["parseHTPasswd"],"updatePoint":{"line":49,"column":45},"line":49,"code":"  it('should parse the password for two lines', () => {\n    const input = `user1:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z\nuser2:$6FrCaT/v0dwE:autocreated 2017-12-14T13:30:20.838Z`;\n    const output = { user1: '$6b9MlB3WUELU', user2: '$6FrCaT/v0dwE' };\n    expect(parseHTPasswd(input)).toEqual(output);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should parse the password for multiple lines","suites":["parseHTPasswd"],"updatePoint":{"line":56,"column":50},"line":56,"code":"  it('should parse the password for multiple lines', () => {\n    const input = `user1:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z\nuser2:$6FrCaT/v0dwE:autocreated 2017-12-14T13:30:20.838Z\nuser3:$6FrCdfd\\v0dwE:autocreated 2017-12-14T13:30:20.838Z\nuser4:$6FrCasdvppdwE:autocreated 2017-12-14T13:30:20.838Z`;\n    const output = {\n      user1: '$6b9MlB3WUELU',\n      user2: '$6FrCaT/v0dwE',\n      user3: '$6FrCdfd\\v0dwE',\n      user4: '$6FrCasdvppdwE',\n    };\n    expect(parseHTPasswd(input)).toEqual(output);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the MD5/Crypt3 password with true","suites":["verifyPassword"],"updatePoint":{"line":72,"column":53},"line":72,"code":"  it('should verify the MD5/Crypt3 password with true', async () => {\n    const input = ['test', '$apr1$sKXK9.lG$rZ4Iy63Vtn8jF9/USc4BV0'];\n    expect(await verifyPassword(input[0], input[1])).toBeTruthy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the MD5/Crypt3 password with false","suites":["verifyPassword"],"updatePoint":{"line":76,"column":54},"line":76,"code":"  it('should verify the MD5/Crypt3 password with false', async () => {\n    const input = ['testpasswordchanged', '$apr1$sKXK9.lG$rZ4Iy63Vtn8jF9/USc4BV0'];\n    expect(await verifyPassword(input[0], input[1])).toBeFalsy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the plain password with true","suites":["verifyPassword"],"updatePoint":{"line":80,"column":48},"line":80,"code":"  it('should verify the plain password with true', async () => {\n    const input = ['testpasswordchanged', '{PLAIN}testpasswordchanged'];\n    expect(await verifyPassword(input[0], input[1])).toBeTruthy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the plain password with false","suites":["verifyPassword"],"updatePoint":{"line":84,"column":49},"line":84,"code":"  it('should verify the plain password with false', async () => {\n    const input = ['testpassword', '{PLAIN}testpasswordchanged'];\n    expect(await verifyPassword(input[0], input[1])).toBeFalsy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the crypto SHA password with true","suites":["verifyPassword"],"updatePoint":{"line":88,"column":53},"line":88,"code":"  it('should verify the crypto SHA password with true', async () => {\n    const input = ['testpassword', '{SHA}i7YRj4/Wk1rQh2o740pxfTJwj/0='];\n    expect(await verifyPassword(input[0], input[1])).toBeTruthy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the crypto SHA password with false","suites":["verifyPassword"],"updatePoint":{"line":92,"column":54},"line":92,"code":"  it('should verify the crypto SHA password with false', async () => {\n    const input = ['testpasswordchanged', '{SHA}i7YRj4/Wk1rQh2o740pxfTJwj/0='];\n    expect(await verifyPassword(input[0], input[1])).toBeFalsy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the bcrypt password with true","suites":["verifyPassword"],"updatePoint":{"line":96,"column":49},"line":96,"code":"  it('should verify the bcrypt password with true', async () => {\n    const input = ['testpassword', '$2y$04$Wqed4yN0OktGbiUdxSTwtOva1xfESfkNIZfcS9/vmHLsn3.lkFxJO'];\n    expect(await verifyPassword(input[0], input[1])).toBeTruthy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the bcrypt password with false","suites":["verifyPassword"],"updatePoint":{"line":100,"column":50},"line":100,"code":"  it('should verify the bcrypt password with false', async () => {\n    const input = [\n      'testpasswordchanged',\n      '$2y$04$Wqed4yN0OktGbiUdxSTwtOva1xfESfkNIZfcS9/vmHLsn3.lkFxJO',\n    ];\n    expect(await verifyPassword(input[0], input[1])).toBeFalsy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should correctly generate line for md5","suites":["generateHtpasswdLine"],"updatePoint":{"line":114,"column":44},"line":114,"code":"  it('should correctly generate line for md5', () => {\n    const md5Conf = { algorithm: HtpasswdHashAlgorithm.md5 };\n    expect(generateHtpasswdLine(user, passwd, md5Conf)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should correctly generate line for sha1","suites":["generateHtpasswdLine"],"updatePoint":{"line":119,"column":45},"line":119,"code":"  it('should correctly generate line for sha1', () => {\n    const sha1Conf = { algorithm: HtpasswdHashAlgorithm.sha1 };\n    expect(generateHtpasswdLine(user, passwd, sha1Conf)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should correctly generate line for crypt","suites":["generateHtpasswdLine"],"updatePoint":{"line":124,"column":46},"line":124,"code":"  it('should correctly generate line for crypt', () => {\n    const cryptConf = { algorithm: HtpasswdHashAlgorithm.crypt };\n    expect(generateHtpasswdLine(user, passwd, cryptConf)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should correctly generate line for bcrypt","suites":["generateHtpasswdLine"],"updatePoint":{"line":129,"column":47},"line":129,"code":"  it('should correctly generate line for bcrypt', () => {\n    const bcryptAlgoConfig = {\n      algorithm: HtpasswdHashAlgorithm.bcrypt,\n      rounds: 2,\n    };\n    expect(generateHtpasswdLine(user, passwd, bcryptAlgoConfig)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should add new htpasswd to the end","suites":["addUserToHTPasswd - bcrypt"],"updatePoint":{"line":141,"column":40},"line":141,"code":"  it('should add new htpasswd to the end', () => {\n    const input = ['', 'username', 'password'];\n    expect(addUserToHTPasswd(input[0], input[1], input[2], defaultHashConfig)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should add new htpasswd to the end in multiline input","suites":["addUserToHTPasswd - bcrypt"],"updatePoint":{"line":146,"column":59},"line":146,"code":"  it('should add new htpasswd to the end in multiline input', () => {\n    const body = `test1:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z\n    test2:$6FrCaT/v0dwE:autocreated 2017-12-14T13:30:20.838Z`;\n    const input = [body, 'username', 'password'];\n    expect(addUserToHTPasswd(input[0], input[1], input[2], defaultHashConfig)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw an error for incorrect username with space","suites":["addUserToHTPasswd - bcrypt"],"updatePoint":{"line":153,"column":61},"line":153,"code":"  it('should throw an error for incorrect username with space', () => {\n    const [a, b, c] = ['', 'firstname lastname', 'password'];\n    expect(() => addUserToHTPasswd(a, b, c, defaultHashConfig)).toThrowErrorMatchingSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should call the readFile method","suites":["lockAndRead"],"updatePoint":{"line":160,"column":37},"line":160,"code":"  it('should call the readFile method', () => {\n    const cb = (): void => {};\n    lockAndRead('.htpasswd', cb);\n    expect(mockReadFile).toHaveBeenCalled();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for user already exists","suites":["sanityCheck"],"updatePoint":{"line":174,"column":50},"line":174,"code":"  test('should throw error for user already exists', async () => {\n    const verifyFn = jest.fn();\n    const input = await sanityCheck('test', users.test, verifyFn, users, Infinity);\n    expect((input as HttpError<number>).status).toEqual(401);\n    expect((input as HttpError<number>).message).toEqual('unauthorized access');\n    expect(verifyFn).toHaveBeenCalled();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for registration disabled of users","suites":["sanityCheck"],"updatePoint":{"line":182,"column":61},"line":182,"code":"  test('should throw error for registration disabled of users', async () => {\n    const verifyFn = (): void => {};\n    const input = await sanityCheck('username', users.test, verifyFn, users, -1);\n    expect((input as HttpError<number>).status).toEqual(409);\n    expect((input as HttpError<number>).message).toEqual('user registration disabled');\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error max number of users","suites":["sanityCheck"],"updatePoint":{"line":189,"column":46},"line":189,"code":"  test('should throw error max number of users', async () => {\n    const verifyFn = (): void => {};\n    const input = await sanityCheck('username', users.test, verifyFn, users, 1);\n    expect((input as HttpError<number>).status).toEqual(403);\n    expect((input as HttpError<number>).message).toEqual('maximum amount of users reached');\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should not throw anything and sanity check","suites":["sanityCheck"],"updatePoint":{"line":196,"column":50},"line":196,"code":"  test('should not throw anything and sanity check', async () => {\n    const verifyFn = (): void => {};\n    const input = await sanityCheck('username', users.test, verifyFn, users, 2);\n    expect(input).toBeNull();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for required username field","suites":["sanityCheck"],"updatePoint":{"line":202,"column":54},"line":202,"code":"  test('should throw error for required username field', async () => {\n    const verifyFn = (): void => {};\n    // @ts-expect-error\n    const input = await sanityCheck(undefined, users.test, verifyFn, users, 2);\n    expect((input as HttpError<number>).message).toEqual('username and password is required');\n    expect((input as HttpError<number>).status).toEqual(400);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for required password field","suites":["sanityCheck"],"updatePoint":{"line":210,"column":54},"line":210,"code":"  test('should throw error for required password field', async () => {\n    const verifyFn = (): void => {};\n    // @ts-expect-error\n    const input = await sanityCheck('username', undefined, verifyFn, users, 2);\n    expect((input as HttpError<number>).message).toEqual('username and password is required');\n    expect((input as HttpError<number>).status).toEqual(400);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for required username & password fields","suites":["sanityCheck"],"updatePoint":{"line":218,"column":66},"line":218,"code":"  test('should throw error for required username & password fields', async () => {\n    const verifyFn = (): void => {};\n    // @ts-expect-error\n    const input = await sanityCheck(undefined, undefined, verifyFn, users, 2);\n    expect((input as HttpError<number>).message).toEqual('username and password is required');\n    expect((input as HttpError<number>).status).toEqual(400);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for existing username and password","suites":["sanityCheck"],"updatePoint":{"line":226,"column":61},"line":226,"code":"  test('should throw error for existing username and password', async () => {\n    const verifyFn = jest.fn(() => true);\n    const input = await sanityCheck('test', users.test, verifyFn, users, 2);\n    expect((input as HttpError<number>).status).toEqual(409);\n    expect((input as HttpError<number>).message).toEqual('username is already registered');\n    expect(verifyFn).toHaveBeenCalledTimes(1);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for wrong password","suites":["changePasswordToHTPasswd"],"updatePoint":{"line":247,"column":45},"line":247,"code":"  test('should throw error for wrong password', async () => {\n    const body = 'test:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z';\n\n    try {\n      await changePasswordToHTPasswd(\n        body,\n        'test',\n        'somerandompassword',\n        'newPassword',\n        defaultHashConfig\n      );\n    } catch (error: any) {\n      expect(error.message).toEqual(\n        `Unable to change password for user 'test': invalid old password`\n      );\n    }\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error when user does not exist","suites":["changePasswordToHTPasswd"],"updatePoint":{"line":265,"column":51},"line":265,"code":"  test('should throw error when user does not exist', async () => {\n    const body = 'test:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z';\n\n    try {\n      await changePasswordToHTPasswd(\n        body,\n        'test2',\n        'somerandompassword',\n        'newPassword',\n        defaultHashConfig\n      );\n    } catch (error: any) {\n      expect(error.message).toEqual(\n        `Unable to change password for user 'test2': user does not currently exist`\n      );\n    }\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should change the password","suites":["changePasswordToHTPasswd"],"updatePoint":{"line":283,"column":34},"line":283,"code":"  test('should change the password', async () => {\n    const body = 'root:$6qLTHoPfGLy2:autocreated 2018-08-20T13:38:12.164Z';\n\n    expect(\n      await changePasswordToHTPasswd(body, 'root', 'demo123', 'newPassword', defaultHashConfig)\n    ).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"getFolders storage 1","suites":[],"updatePoint":{"line":13,"column":26},"line":13,"code":"test('getFolders storage 1', async () => {\n  const files = await getFolders(join(pathStorage1, '@bar'));\n  expect(files).toHaveLength(2);\n  expect(files).toEqual(['pkg1', 'pkg2']);\n});","file":"dir-utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"getFolders storage 2","suites":[],"updatePoint":{"line":19,"column":26},"line":19,"code":"test('getFolders storage 2', async () => {\n  const files = await getFolders(pathStorage2);\n  expect(files).toHaveLength(1);\n  expect(files).toEqual(['pkg4']);\n});","file":"dir-utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"getFolders storage 2 with pattern","suites":[],"updatePoint":{"line":25,"column":39},"line":25,"code":"test('getFolders storage 2 with pattern', async () => {\n  const files = await getFolders(pathStorage1, '*bar*');\n  expect(files).toHaveLength(1);\n  expect(files).toEqual(['@bar']);\n});","file":"dir-utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should find results","suites":["searchOnFolders"],"updatePoint":{"line":32,"column":27},"line":32,"code":"  test('should find results', async () => {\n    const packages = await searchOnStorage(mockFolder, storages);\n    expect(packages).toHaveLength(9);\n    expect(packages).toEqual([\n      {\n        name: '@foo/pkg1',\n        scoped: '@foo',\n      },\n      {\n        name: '@foo/pkg2',\n        scoped: '@foo',\n      },\n      { name: 'dont-include' },\n      {\n        name: 'pkg1',\n      },\n\n      {\n        name: 'pkg2',\n      },\n      {\n        name: 'pkg3',\n      },\n      {\n        name: '@bar/pkg1',\n        scoped: '@bar',\n      },\n      {\n        name: '@bar/pkg2',\n        scoped: '@bar',\n      },\n      {\n        name: 'pkg4',\n      },\n    ]);\n  });","file":"dir-utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should create an instance","suites":["Local Database"],"updatePoint":{"line":53,"column":33},"line":53,"code":"  test('should create an instance', () => {\n    expect(locaDatabase).toBeDefined();\n  });","file":"local-database.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should display log error if fails on load database","suites":["Local Database"],"updatePoint":{"line":57,"column":58},"line":57,"code":"  test('should display log error if fails on load database', async () => {\n    mockmkdir.mockImplementation(() => {\n      throw Error();\n    });\n    const tmpFolder = await fileUtils.createTempFolder('local-storage-plugin-');\n    const tempFolder = path.join(tmpFolder, 'verdaccio-test.yaml');\n    const instance = new LocalDatabase(\n      // @ts-expect-error\n      {\n        storage: 'storage',\n        config_path: tempFolder,\n      },\n      optionsPlugin.logger\n    );\n\n    await expect(instance.init()).rejects.toEqual(new Error(ERROR_DB_LOCKED));\n    // expect(optionsPlugin.logger.error).toHaveBeenCalled();\n  });","file":"local-database.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should create get secret","suites":["Local Database","should handle secret"],"updatePoint":{"line":77,"column":34},"line":77,"code":"    test('should create get secret', async () => {\n      const secretKey = await locaDatabase.getSecret();\n      expect(secretKey).toBeDefined();\n      expect(typeof secretKey === 'string').toBeTruthy();\n    });","file":"local-database.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should create set secret","suites":["Local Database","should handle secret"],"updatePoint":{"line":83,"column":34},"line":83,"code":"    test('should create set secret', async () => {\n      await locaDatabase.setSecret('foooo');\n      const fetchedSecretKey = await locaDatabase.getSecret();\n      expect('foooo').toBe(fetchedSecretKey);\n    });","file":"local-database.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"write tarball","suites":["Local Database","should handle secret"],"line":90,"code":"  test.todo('write tarball');","file":"local-database.test.ts","skipped":true,"dir":"packages/plugins/local-storage/tests"},{"name":"read tarball","suites":["Local Database","should handle secret"],"line":91,"code":"  test.todo('read tarball');","file":"local-database.test.ts","skipped":true,"dir":"packages/plugins/local-storage/tests"},{"name":"should delete a package","suites":["Local FS test","deletePackage() group"],"updatePoint":{"line":41,"column":33},"line":41,"code":"    test('should delete a package', async () => {\n      const localFs = new LocalDriver(path.join(localTempStorage, 'createPackage'), logger);\n      await localFs.createPackag('createPackage', pkg as unknown as Manifest);\n      // verdaccio removes the package.json instead the package name\n      await localFs.deletePackage('package.json');\n      // verify if the `package.json` does not exist anymore\n      // note: the folder still remains\n      await expect(checkFileExists(localFs._getStorage('package.json'))).resolves.toBeFalsy();\n    });","file":"local-fs.test.ts","skipped":true,"dir":"packages/plugins/local-storage/tests"},{"name":"should fails on delete a package","suites":["Local FS test","deletePackage() group"],"updatePoint":{"line":50,"column":42},"line":50,"code":"    test('should fails on delete a package', async () => {\n      const localFs = new LocalDriver(path.join(localTempStorage, 'createPackage'), logger);\n      // verdaccio removes the package.json instead the package name\n      await expect(localFs.deletePackage('package.json')).rejects.toThrow('ENOENT');\n    });","file":"local-fs.test.ts","skipped":true,"dir":"packages/plugins/local-storage/tests"},{"name":"should successfully remove the package","suites":["Local FS test","removePackage() group"],"updatePoint":{"line":62,"column":48},"line":62,"code":"    test('should successfully remove the package', async () => {\n      const localFs: ILocalPackageManager = new LocalDriver(\n        path.join(localTempStorage, '_toDelete'),\n        logger\n      );\n\n      await expect(localFs.removePackage()).resolves.toBeUndefined();\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"removePackage() fails","suites":["Local FS test","removePackage() group"],"updatePoint":{"line":71,"column":31},"line":71,"code":"    test('removePackage() fails', async () => {\n      const localFs: ILocalPackageManager = new LocalDriver(\n        path.join(localTempStorage, '_toDelete_fake'),\n        logger\n      );\n      await expect(localFs.removePackage()).rejects.toThrow(/ENOENT/);\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should write a tarball","suites":["Local FS test","writeTarballNext"],"updatePoint":{"line":81,"column":32},"line":81,"code":"    test('should write a tarball', (done) => {\n      const abort = new AbortController();\n      const tmp = createTempFolder('local-fs-write-tarball');\n      const localFs = new LocalDriver(tmp, logger);\n      const readableStream = Readable.from('foooo');\n      // TODO: verify file exist\n      localFs.writeTarball('juan-1.0.0.tgz', { signal: abort.signal }).then((stream) => {\n        stream.on('finish', () => {\n          done();\n        });\n        readableStream.pipe(stream);\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should read a tarball","suites":["Local FS test","readTarballNext"],"updatePoint":{"line":97,"column":31},"line":97,"code":"    test('should read a tarball', (done) => {\n      const abort = new AbortController();\n      const localFs = new LocalDriver(\n        path.join(__dirname, '__fixtures__/readme-test-next'),\n        logger\n      );\n      localFs.readTarball('test-readme-0.0.0.tgz', { signal: abort.signal }).then((stream) => {\n        stream.on('data', (data) => {\n          expect(data.length).toEqual(352);\n        });\n        stream.on('end', () => {\n          done();\n        });\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should aboort read a tarball","suites":["Local FS test","readTarballNext"],"updatePoint":{"line":113,"column":38},"line":113,"code":"    test('should aboort read a tarball', (done) => {\n      const abort = new AbortController();\n      const localFs = new LocalDriver(\n        path.join(__dirname, '__fixtures__/readme-test-next'),\n        logger\n      );\n      localFs.readTarball('test-readme-0.0.0.tgz', { signal: abort.signal }).then((stream) => {\n        stream.on('error', (error: any) => {\n          expect(error.code).toEqual('ABORT_ERR');\n          done();\n        });\n        abort.abort();\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"fails on read a tarball doex not exist","suites":["Local FS test","readTarballNext"],"updatePoint":{"line":128,"column":48},"line":128,"code":"    test('fails on read a tarball doex not exist', (done) => {\n      const abort = new AbortController();\n\n      const localFs = new LocalDriver(\n        path.join(__dirname, '__fixtures__/readme-test-next'),\n        logger\n      );\n      localFs.readTarball('does-not-exist-0.0.0.tgz', { signal: abort.signal }).then((stream) => {\n        stream.on('error', (error: any) => {\n          expect(error.code).toEqual('ENOENT');\n          done();\n        });\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should return content-length","suites":["Local FS test","readTarballNext"],"updatePoint":{"line":143,"column":38},"line":143,"code":"    test('should return content-length', (done) => {\n      const localFs = new LocalDriver(\n        path.join(__dirname, '__fixtures__/readme-test-next'),\n        logger\n      );\n      const abort = new AbortController();\n\n      localFs.readTarball('test-readme-0.0.0.tgz', { signal: abort.signal }).then((stream) => {\n        stream.on('data', (data) => {\n          expect(data.length).toEqual(352);\n        });\n        stream.on('content-length', (content) => {\n          expect(content).toEqual(352);\n          done();\n        });\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should save and get token","suites":["Local Database","token"],"updatePoint":{"line":53,"column":35},"line":53,"code":"    test('should save and get token', async () => {\n      await locaDatabase.saveToken(token);\n      const tokens = await locaDatabase.readTokens({ user: token.user });\n      expect(tokens).toHaveLength(1);\n      expect(tokens[0]).toEqual(token);\n    });","file":"token.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should revoke and get token","suites":["Local Database","token"],"updatePoint":{"line":60,"column":37},"line":60,"code":"    test('should revoke and get token', async () => {\n      await locaDatabase.saveToken(token);\n      const tokens = await locaDatabase.readTokens({ user: token.user });\n      expect(tokens).toHaveLength(1);\n      expect(tokens[0]).toEqual(token);\n      await locaDatabase.deleteToken(token.user, token.key);\n      const tokens2 = await locaDatabase.readTokens({ user: token.user });\n      expect(tokens2).toHaveLength(0);\n    });","file":"token.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should fail on revoke","suites":["Local Database","token"],"updatePoint":{"line":70,"column":31},"line":70,"code":"    test('should fail on revoke', async () => {\n      await expect(locaDatabase.deleteToken({ user: 'foo', key: 'bar' })).rejects.toThrow(\n        'user not found'\n      );\n    });","file":"token.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should verify save more than one token","suites":["Local Database","token"],"updatePoint":{"line":76,"column":48},"line":76,"code":"    test('should verify save more than one token', async () => {\n      await locaDatabase.saveToken(token);\n      const tokens = await locaDatabase.readTokens({ user: token.user });\n      expect(tokens).toHaveLength(1);\n      expect(tokens[0]).toEqual(token);\n      await locaDatabase.saveToken({ ...token, key: 'foo' });\n      expect(tokens).toHaveLength(2);\n      expect(tokens[1].key).toEqual('foo');\n    });","file":"token.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should load private packages","suites":["Utitlies"],"updatePoint":{"line":27,"column":36},"line":27,"code":"  test('should load private packages', async () => {\n    const database = loadDb('ok');\n    const db = await loadPrivatePackages(database, logger);\n\n    expect(db.list).toHaveLength(15);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should load and empty private packages if database file is valid and empty","suites":["Utitlies"],"updatePoint":{"line":34,"column":82},"line":34,"code":"  test('should load and empty private packages if database file is valid and empty', async () => {\n    const database = loadDb('empty');\n    const db = await loadPrivatePackages(database, logger);\n\n    expect(db.list).toHaveLength(0);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should fails on load private packages","suites":["Utitlies"],"updatePoint":{"line":41,"column":45},"line":41,"code":"  test('should fails on load private packages', async () => {\n    const database = loadDb('corrupted');\n\n    await expect(loadPrivatePackages(database, logger)).rejects.toThrow();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should handle null read values and return empty database","suites":["Utitlies"],"updatePoint":{"line":47,"column":64},"line":47,"code":"  test('should handle null read values and return empty database', async () => {\n    const spy = jest.spyOn(readFile, 'readFilePromise');\n    spy.mockResolvedValue(null);\n    const database = loadDb('ok');\n    const db = await loadPrivatePackages(database, logger);\n\n    expect(db.list).toHaveLength(0);\n\n    spy.mockRestore();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should fails on wrong storage path","suites":["Utitlies","find packages"],"updatePoint":{"line":59,"column":44},"line":59,"code":"    test('should fails on wrong storage path', async () => {\n      try {\n        await findPackages(\n          './no_such_folder_fake',\n          jest.fn(() => true)\n        );\n      } catch (e: any) {\n        expect(e.code).toEqual(noSuchFile);\n      }\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should fetch all packages from valid storage","suites":["Utitlies","find packages"],"updatePoint":{"line":70,"column":54},"line":70,"code":"    test('should fetch all packages from valid storage', async () => {\n      const storage = path.join(__dirname, '__fixtures__/findPackages');\n      const validator = jest.fn((file) => file.indexOf('.') === -1);\n      const pkgs = await findPackages(storage, validator);\n      // the result is 7 due number of packages on \"findPackages\" directory\n      expect(pkgs).toHaveLength(5);\n      expect(validator).toHaveBeenCalledTimes(8);\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should generate a storage path","suites":["Utitlies","dbGenPath"],"updatePoint":{"line":81,"column":40},"line":81,"code":"    test('should generate a storage path', () => {\n      expect(\n        _dbGenPath('local.db', {\n          storage: './storage',\n          config_path: '/etc/foo/config.yaml',\n        })\n      ).toMatch('local.db');\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should verify with empty storage","suites":["Utitlies","dbGenPath"],"updatePoint":{"line":90,"column":42},"line":90,"code":"    test('should verify with empty storage', () => {\n      expect(\n        _dbGenPath('local.db', {\n          storage: '',\n          config_path: '/etc/foo/config.yaml',\n        })\n      ).toMatch('local.db');\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should verify with undefined storage","suites":["Utitlies","dbGenPath"],"updatePoint":{"line":99,"column":46},"line":99,"code":"    test('should verify with undefined storage', () => {\n      expect(\n        _dbGenPath('local.db', {\n          storage: '',\n          config_path: '/etc/foo/config.yaml',\n        })\n      ).toMatch('local.db');\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should verify with config path is invalid","suites":["Utitlies","dbGenPath"],"updatePoint":{"line":108,"column":51},"line":108,"code":"    test('should verify with config path is invalid', () => {\n      expect(\n        _dbGenPath('local.db', {\n          storage: './storage',\n          config_path: undefined,\n        })\n      ).toMatch('local.db');\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should create an LocalMemory instance","suites":["memory unit test .","LocalMemory"],"updatePoint":{"line":19,"column":47},"line":19,"code":"    test('should create an LocalMemory instance', () => {\n      const localMemory: pluginUtils.Storage<ConfigMemory> = new LocalMemory(\n        { limit: 10 },\n        { ...defaultConfig, config }\n      );\n\n      expect(localMemory).toBeDefined();\n    });","file":"local-memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should create add a package","suites":["memory unit test .","LocalMemory"],"updatePoint":{"line":28,"column":37},"line":28,"code":"    test('should create add a package', (done) => {\n      const localMemory: pluginUtils.Storage<ConfigMemory> = new LocalMemory(\n        { limit: 10 },\n        { ...defaultConfig, config }\n      );\n      localMemory.add('test').then(() => {\n        localMemory.get().then((data: DataHandler) => {\n          expect(data).toHaveLength(1);\n          done();\n        });\n      });\n    });","file":"local-memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should reach max limit","suites":["memory unit test .","LocalMemory"],"updatePoint":{"line":41,"column":32},"line":41,"code":"    test('should reach max limit', (done) => {\n      const localMemory: pluginUtils.Storage<ConfigMemory> = new LocalMemory(\n        { limit: 2 },\n        defaultConfig\n      );\n\n      localMemory.add('test1').then(() => {\n        localMemory.add('test2').then(() => {\n          localMemory.add('test3').catch((err) => {\n            expect(err).not.toBeNull();\n            expect(err.message).toMatch(/Storage memory has reached limit of limit packages/);\n            done();\n          });\n        });\n      });\n    });","file":"local-memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should remove a package","suites":["memory unit test .","LocalMemory"],"updatePoint":{"line":58,"column":33},"line":58,"code":"    test('should remove a package', (done) => {\n      const pkgName = 'test';\n      const localMemory: pluginUtils.Storage<ConfigMemory> = new LocalMemory(\n        {},\n        { ...defaultConfig, config }\n      );\n      localMemory.add(pkgName).then(() => {\n        localMemory.remove(pkgName).then(() => {\n          localMemory.get().then((data) => {\n            expect(data).toHaveLength(0);\n            done();\n          });\n        });\n      });\n    });","file":"local-memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"if set headers empty should return default headers","suites":["setHeadersNext"],"updatePoint":{"line":25,"column":58},"line":25,"code":"  test('if set headers empty should return default headers', () => {\n    const headers = setHeadersNext();\n    const keys = Object.keys(headers);\n    const keysExpected = [HEADERS.ACCEPT, HEADERS.ACCEPT_ENCODING, HEADERS.USER_AGENT];\n\n    expect(keys).toEqual(keysExpected);\n    expect(keys).toHaveLength(3);\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"if assigns value invalid to attribute auth","suites":["setHeadersNext"],"updatePoint":{"line":34,"column":50},"line":34,"code":"  test('if assigns value invalid to attribute auth', () => {\n    const fnError = function () {\n      setHeadersNext({\n        auth: '',\n      });\n    };\n\n    expect(function () {\n      fnError();\n    }).toThrow(Error('Auth invalid'));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"if assigns the header authorization","suites":["setHeadersNext"],"updatePoint":{"line":46,"column":43},"line":46,"code":"  test('if assigns the header authorization', () => {\n    const headers = setHeadersNext(\n      {},\n      {\n        [HEADERS.AUTHORIZATION]: buildToken(TOKEN_BASIC, 'Zm9vX2Jhcg=='),\n      }\n    );\n\n    expect(Object.keys(headers)).toHaveLength(4);\n    expect(headers[HEADERS.AUTHORIZATION]).toEqual(buildToken(TOKEN_BASIC, 'Zm9vX2Jhcg=='));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"if assigns headers authorization and token the header precedes","suites":["setHeadersNext"],"updatePoint":{"line":58,"column":70},"line":58,"code":"  test('if assigns headers authorization and token the header precedes', () => {\n    const headers = setHeadersNext(\n      {\n        auth: {\n          type: TOKEN_BEARER,\n          token: 'tokenBearer',\n        },\n      },\n      {\n        [HEADERS.AUTHORIZATION]: buildToken(TOKEN_BASIC, 'tokenBasic'),\n      }\n    );\n\n    expect(headers[HEADERS.AUTHORIZATION]).toEqual(buildToken(TOKEN_BASIC, 'tokenBasic'));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"set type auth basic","suites":["setHeadersNext"],"updatePoint":{"line":74,"column":27},"line":74,"code":"  test('set type auth basic', () => {\n    const headers = setHeadersNext({\n      auth: {\n        type: TOKEN_BASIC,\n        token: 'Zm9vX2Jhcg==',\n      },\n    });\n\n    expect(Object.keys(headers)).toHaveLength(4);\n    expect(headers[HEADERS.AUTHORIZATION]).toEqual(buildToken(TOKEN_BASIC, 'Zm9vX2Jhcg=='));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"set type auth bearer","suites":["setHeadersNext"],"updatePoint":{"line":86,"column":28},"line":86,"code":"  test('set type auth bearer', () => {\n    const headers = setHeadersNext({\n      auth: {\n        type: TOKEN_BEARER,\n        token: 'Zm9vX2Jhcf===',\n      },\n    });\n\n    expect(Object.keys(headers)).toHaveLength(4);\n    expect(headers[HEADERS.AUTHORIZATION]).toEqual(buildToken(TOKEN_BEARER, 'Zm9vX2Jhcf==='));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"set auth type invalid","suites":["setHeadersNext"],"updatePoint":{"line":98,"column":29},"line":98,"code":"  test('set auth type invalid', () => {\n    const fnError = function () {\n      setHeadersNext({\n        auth: {\n          type: 'null',\n          token: 'Zm9vX2Jhcf===',\n        },\n      });\n    };\n\n    expect(function () {\n      fnError();\n    }).toThrow(Error(`Auth type 'null' not allowed`));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"set auth with NPM_TOKEN","suites":["setHeadersNext"],"updatePoint":{"line":113,"column":31},"line":113,"code":"  test('set auth with NPM_TOKEN', () => {\n    process.env.NPM_TOKEN = 'myToken';\n    const headers = setHeadersNext({\n      auth: {\n        type: TOKEN_BEARER,\n      },\n    });\n\n    expect(headers[HEADERS.AUTHORIZATION]).toBe(buildToken(TOKEN_BEARER, 'myToken'));\n    delete process.env.NPM_TOKEN;\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"set auth with token name and assigns in env","suites":["setHeadersNext"],"updatePoint":{"line":125,"column":51},"line":125,"code":"  test('set auth with token name and assigns in env', () => {\n    process.env.NPM_TOKEN_TEST = 'myTokenTest';\n    const headers = setHeadersNext({\n      auth: {\n        type: TOKEN_BASIC,\n        token_env: 'NPM_TOKEN_TEST',\n      },\n    });\n\n    expect(headers[HEADERS.AUTHORIZATION]).toBe(buildToken(TOKEN_BASIC, 'myTokenTest'));\n    delete process.env.NPM_TOKEN_TEST;\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"if token not set","suites":["setHeadersNext"],"updatePoint":{"line":138,"column":24},"line":138,"code":"  test('if token not set', () => {\n    const fnError = function () {\n      setHeadersNext({\n        auth: {\n          type: TOKEN_BASIC,\n        },\n      });\n    };\n\n    expect(function () {\n      fnError();\n    }).toThrow(constants.ERROR_CODE.token_required);\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should do not define proxy","suites":["Use proxy","basic tets"],"updatePoint":{"line":13,"column":36},"line":13,"code":"    test('should do not define proxy', () => {\n      const x = getProxyInstance('http://registry.domain.org', {}, {});\n\n      expect(x.proxy).toEqual(undefined);\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"uplink configuration should take priority","suites":["Use proxy","basic tets"],"updatePoint":{"line":19,"column":51},"line":19,"code":"    test('uplink configuration should take priority', () => {\n      expect(\n        getProxyInstance(\n          'http://registry.domain.org',\n          { http_proxy: 'http:\\\\registry.local.org' },\n          { http_proxy: 'registry.domain.org' }\n        ).proxy\n      ).toEqual('http:\\\\registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"global configuration should be used","suites":["Use proxy","basic tets"],"updatePoint":{"line":29,"column":45},"line":29,"code":"    test('global configuration should be used', () => {\n      expect(\n        getProxyInstance(\n          'http://registry.some.org',\n          {},\n          { http_proxy: 'http://registry.domain.org' }\n        ).proxy\n      ).toEqual('http://registry.domain.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy is null","suites":["Use proxy","no_proxy invalid cases"],"updatePoint":{"line":41,"column":26},"line":41,"code":"    test('no_proxy is null', () => {\n      let x = getProxyInstance(\n        'http://x/x',\n        { http_proxy: 'http:\\\\registry.local.org', no_proxy: null },\n        {}\n      );\n      expect(x.proxy).toEqual('http:\\\\registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy is empty array","suites":["Use proxy","no_proxy invalid cases"],"updatePoint":{"line":50,"column":33},"line":50,"code":"    test('no_proxy is empty array', () => {\n      let x = getProxyInstance(\n        'http://x/x',\n        { http_proxy: 'http:\\\\registry.local.org', no_proxy: [] },\n        {}\n      );\n      expect(x.proxy).toEqual('http:\\\\registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy is empty object","suites":["Use proxy","no_proxy invalid cases"],"updatePoint":{"line":59,"column":34},"line":59,"code":"    test('no_proxy is empty object', () => {\n      let x = getProxyInstance(\n        'http://x/x',\n        { http_proxy: 'http:\\\\registry.local.org', no_proxy: '' },\n        {}\n      );\n      expect(x.proxy).toEqual('http:\\\\registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy - simple/include","suites":["Use proxy","no_proxy invalid cases"],"updatePoint":{"line":68,"column":35},"line":68,"code":"    test('no_proxy - simple/include', () => {\n      let x = getProxyInstance(\n        'http://localhost',\n        { http_proxy: 'http:\\\\registry.local.org' },\n        { no_proxy: 'localhost' }\n      );\n\n      expect(x.proxy).toEqual(undefined);\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy - simple/not","suites":["Use proxy","no_proxy invalid cases"],"updatePoint":{"line":78,"column":31},"line":78,"code":"    test('no_proxy - simple/not', () => {\n      let x = getProxyInstance(\n        'http://localhost',\n        { http_proxy: 'http:\\\\registry.local.org' },\n        { no_proxy: 'blah' }\n      );\n\n      expect(x.proxy).toEqual('http:\\\\registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy is boolean","suites":["Use proxy","no_proxy invalid cases"],"updatePoint":{"line":88,"column":29},"line":88,"code":"    test('no_proxy is boolean', () => {\n      let x = getProxyInstance(\n        'http://registry.some.domain',\n        { http_proxy: 'http:\\\\registry.local.org', no_proxy: false },\n        {}\n      );\n      expect(x.proxy).toEqual('http:\\\\registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy - various, single string","suites":["Use proxy","no_proxy override http_proxy use cases"],"updatePoint":{"line":99,"column":43},"line":99,"code":"    test('no_proxy - various, single string', () => {\n      let x = getProxyInstance(\n        'http://blahblah',\n        { http_proxy: 'http:\\\\registry.local.org' },\n        { no_proxy: 'blah' }\n      );\n\n      expect(x.proxy).toEqual('http:\\\\registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should disable proxy if match hostname","suites":["Use proxy","no_proxy override http_proxy use cases"],"updatePoint":{"line":108,"column":48},"line":108,"code":"    test('should disable proxy if match hostname', () => {\n      let x = getProxyInstance(\n        'http://registry.local.org',\n        {},\n        { http_proxy: 'http:\\\\registry.local.org', no_proxy: 'registry.local.org' }\n      );\n      expect(x.proxy).toEqual(undefined);\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should not override http_proxy if domain does not match","suites":["Use proxy","no_proxy override http_proxy use cases"],"updatePoint":{"line":116,"column":65},"line":116,"code":"    test('should not override http_proxy if domain does not match', () => {\n      let x = getProxyInstance(\n        'http://blahblah',\n        {},\n        { http_proxy: 'http://registry.local.org', no_proxy: '.blah' }\n      );\n      expect(x.proxy).toEqual('http://registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should override http_proxy if match domain no_proxy","suites":["Use proxy","no_proxy override http_proxy use cases"],"updatePoint":{"line":124,"column":61},"line":124,"code":"    test('should override http_proxy if match domain no_proxy', () => {\n      let x = getProxyInstance('http://blah.blah', { http_proxy: '123', no_proxy: '.blah' }, {});\n      expect(x.proxy).toEqual(undefined);\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should override http_proxy due no_proxy match with hostname","suites":["Use proxy","no_proxy override http_proxy use cases"],"updatePoint":{"line":128,"column":69},"line":128,"code":"    test('should override http_proxy due no_proxy match with hostname', () => {\n      let x = getProxyInstance('http://blah', { http_proxy: '123', no_proxy: '.blah' }, {});\n      expect(x.proxy).toEqual(undefined);\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should not override http_proxy if no_proxy does not match","suites":["Use proxy","no_proxy override http_proxy use cases"],"updatePoint":{"line":132,"column":67},"line":132,"code":"    test('should not override http_proxy if no_proxy does not match', () => {\n      let x = getProxyInstance(\n        'http://blahh',\n        { http_proxy: 'http://registry.local.org', no_proxy: 'blah' },\n        {}\n      );\n      expect(x.proxy).toEqual('http://registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should not override http_proxy if not match domain","suites":["Use proxy","no_proxy as array of domains"],"updatePoint":{"line":142,"column":60},"line":142,"code":"    test('should not override http_proxy if not match domain', () => {\n      let x = getProxyInstance(\n        'http://blahblah',\n        { http_proxy: 'http:\\\\registry.local.org' },\n        { no_proxy: 'foo,bar,blah' }\n      );\n\n      expect(x.proxy).toEqual('http:\\\\registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should disable proxy if match domain","suites":["Use proxy","no_proxy as array of domains"],"updatePoint":{"line":151,"column":46},"line":151,"code":"    test('should disable proxy if match domain', () => {\n      let x = getProxyInstance(\n        'http://blah.blah',\n        { http_proxy: 'http:\\\\registry.local.org' },\n        { no_proxy: 'foo,bar,blah' }\n      );\n      expect(x.proxy).toEqual(undefined);\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"disable proxy if match domain .foo","suites":["Use proxy","no_proxy as array of domains"],"updatePoint":{"line":160,"column":44},"line":160,"code":"    test('disable proxy if match domain .foo', () => {\n      let x = getProxyInstance(\n        'http://blah.foo',\n        { http_proxy: 'http:\\\\registry.local.org' },\n        { no_proxy: 'foo,bar,blah' }\n      );\n      expect(x.proxy).toEqual(undefined);\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should not disable http_proxy if not match domain","suites":["Use proxy","no_proxy as array of domains"],"updatePoint":{"line":168,"column":59},"line":168,"code":"    test('should not disable http_proxy if not match domain', () => {\n      let x = getProxyInstance(\n        'http://foo.baz',\n        { http_proxy: 'http:\\\\registry.local.org' },\n        { no_proxy: 'foo,bar,blah' }\n      );\n      expect(x.proxy).toEqual('http:\\\\registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy should not find match no_proxy as array invalid domains","suites":["Use proxy","no_proxy as array of domains"],"updatePoint":{"line":176,"column":74},"line":176,"code":"    test('no_proxy should not find match no_proxy as array invalid domains', () => {\n      let x = getProxyInstance(\n        'http://blahblah',\n        { http_proxy: 'http:\\\\registry.local.org' },\n        { no_proxy: ['foo', 'bar', 'blah'] }\n      );\n      expect(x.proxy).toEqual('http:\\\\registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy should find match no_proxy as array valid domains","suites":["Use proxy","no_proxy as array of domains"],"updatePoint":{"line":184,"column":68},"line":184,"code":"    test('no_proxy should find match no_proxy as array valid domains', () => {\n      let x = getProxyInstance(\n        'http://blah.blah',\n        { http_proxy: 'http:\\\\registry.local.org' },\n        { no_proxy: ['foo', 'bar', 'blah'] }\n      );\n      expect(x.proxy).toEqual(undefined);\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy - hostport","suites":["Use proxy","no_proxy with ports"],"updatePoint":{"line":195,"column":29},"line":195,"code":"    test('no_proxy - hostport', () => {\n      let x = getProxyInstance(\n        'http://localhost:80',\n        { http_proxy: '123' },\n        { no_proxy: 'localhost' }\n      );\n\n      expect(x.proxy).toEqual(undefined);\n      x = getProxyInstance(\n        'http://localhost:8080',\n        { http_proxy: '123' },\n        { no_proxy: 'localhost' }\n      );\n      expect(x.proxy).toEqual(undefined);\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should not override if https_proxy is defined","suites":["Use proxy","no_proxy with https match"],"updatePoint":{"line":213,"column":55},"line":213,"code":"    test('should not override if https_proxy is defined', () => {\n      let x = getProxyInstance('https://something', { http_proxy: '123' }, {});\n\n      expect(x.proxy).toEqual(undefined);\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should define proxy if https_proxy match","suites":["Use proxy","no_proxy with https match"],"updatePoint":{"line":218,"column":50},"line":218,"code":"    test('should define proxy if https_proxy match', () => {\n      let x = getProxyInstance(\n        'https://something',\n        { https_proxy: 'https://registry.local.org' },\n        {}\n      );\n      expect(x.proxy).toEqual('https://registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should match https_proxy if https protocol match","suites":["Use proxy","no_proxy with https match"],"updatePoint":{"line":226,"column":58},"line":226,"code":"    test('should match https_proxy if https protocol match', () => {\n      let x = getProxyInstance(\n        'https://something',\n        { http_proxy: 'http://registry.local.org', https_proxy: 'https://registry.local.org' },\n        {}\n      );\n      expect(x.proxy).toEqual('https://registry.local.org');\n    });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"success call to remote","suites":["proxy","getRemoteMetadataNext","basic requests"],"updatePoint":{"line":69,"column":34},"line":69,"code":"      test('success call to remote', async () => {\n        nock(domain, {\n          reqheaders: {\n            accept: 'application/json;',\n            'accept-encoding': 'gzip',\n            'x-forwarded-for': '127.0.0.1',\n            via: '1.1 foo-phseudo-bytes (Verdaccio)',\n          },\n        })\n          .get('/jquery')\n          .reply(200, { body: 'test' });\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        const [manifest] = await prox1.getRemoteMetadataNext('jquery', {\n          remoteAddress: '127.0.0.1',\n        });\n        expect(manifest).toEqual({ body: 'test' });\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"proxy call with etag","suites":["proxy","getRemoteMetadataNext","etag header"],"updatePoint":{"line":89,"column":32},"line":89,"code":"      test('proxy call with etag', async () => {\n        nock(domain, {\n          reqheaders: {\n            accept: 'application/json;',\n            'accept-encoding': 'gzip',\n            'x-forwarded-for': '127.0.0.1',\n            via: '1.1 foo-phseudo-bytes (Verdaccio)',\n          },\n        })\n          .get('/jquery')\n          .reply(\n            200,\n            { body: 'test' },\n            {\n              etag: () => `_ref_4444`,\n            }\n          );\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        const [manifest, etag] = await prox1.getRemoteMetadataNext('jquery', {\n          remoteAddress: '127.0.0.1',\n        });\n        expect(etag).toEqual('_ref_4444');\n        expect(manifest).toEqual({ body: 'test' });\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"proxy call with etag as option","suites":["proxy","getRemoteMetadataNext","etag header"],"updatePoint":{"line":114,"column":42},"line":114,"code":"      test('proxy call with etag as option', async () => {\n        nock(domain, {\n          reqheaders: {\n            accept: 'application/json;',\n            'accept-encoding': 'gzip',\n            'x-forwarded-for': '127.0.0.1',\n            via: '1.1 foo-phseudo-bytes (Verdaccio)',\n            // match only if etag is set as option\n            'if-none-match': 'foo',\n          },\n        })\n          .get('/jquery')\n          .reply(\n            200,\n            { body: 'test' },\n            {\n              etag: () => `_ref_4444`,\n            }\n          );\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        const [manifest, etag] = await prox1.getRemoteMetadataNext('jquery', {\n          etag: 'foo',\n          remoteAddress: '127.0.0.1',\n        });\n        expect(etag).toEqual('_ref_4444');\n        expect(manifest).toEqual({ body: 'test' });\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"proxy call with etag","suites":["proxy","getRemoteMetadataNext","log activity"],"updatePoint":{"line":144,"column":32},"line":144,"code":"      test('proxy call with etag', async () => {\n        nock(domain)\n          .get('/jquery')\n          .reply(200, { body: { name: 'foo', version: '1.0.0' } }, {});\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        await prox1.getRemoteMetadataNext('jquery', {\n          remoteAddress: '127.0.0.1',\n        });\n        expect(mockHttp).toHaveBeenCalledTimes(2);\n        expect(mockHttp).toHaveBeenCalledWith(\n          {\n            request: { method: 'GET', url: `${domain}/jquery` },\n            status: 200,\n          },\n          \"@{!status}, req: '@{request.method} @{request.url}' (streaming)\"\n        );\n        expect(mockHttp).toHaveBeenLastCalledWith(\n          {\n            request: { method: 'GET', url: `${domain}/jquery` },\n            status: 200,\n            bytes: {\n              in: 0,\n              out: 41,\n            },\n          },\n          \"@{!status}, req: '@{request.method} @{request.url}'\"\n        );\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"proxy call with 304","suites":["proxy","getRemoteMetadataNext","error handling"],"updatePoint":{"line":175,"column":31},"line":175,"code":"      test('proxy call with 304', async () => {\n        nock(domain).get('/jquery').reply(304);\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        await expect(prox1.getRemoteMetadataNext('jquery', { etag: 'rev_3333' })).rejects.toThrow(\n          'no data'\n        );\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"reply with error","suites":["proxy","getRemoteMetadataNext","error handling"],"updatePoint":{"line":183,"column":28},"line":183,"code":"      test('reply with error', async () => {\n        nock(domain).get('/jquery').replyWithError('something awful happened');\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        await expect(\n          prox1.getRemoteMetadataNext('jquery', {\n            remoteAddress: '127.0.0.1',\n          })\n        ).rejects.toThrowError(new Error('something awful happened'));\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"reply with 409 error","suites":["proxy","getRemoteMetadataNext","error handling"],"updatePoint":{"line":193,"column":32},"line":193,"code":"      test('reply with 409 error', async () => {\n        nock(domain).get('/jquery').reply(409);\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        await expect(prox1.getRemoteMetadataNext('jquery', { retry: 0 })).rejects.toThrow(\n          new Error('bad status code: 409')\n        );\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"reply with bad body json format","suites":["proxy","getRemoteMetadataNext","error handling"],"updatePoint":{"line":201,"column":43},"line":201,"code":"      test('reply with bad body json format', async () => {\n        nock(domain).get('/jquery').reply(200, 'some-text');\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        await expect(\n          prox1.getRemoteMetadataNext('jquery', {\n            remoteAddress: '127.0.0.1',\n          })\n        ).rejects.toThrowError(\n          new Error(\n            'Unexpected token s in JSON at position 0 in \"https://registry.npmjs.org/jquery\"'\n          )\n        );\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"400 error proxy call","suites":["proxy","getRemoteMetadataNext","error handling"],"updatePoint":{"line":215,"column":32},"line":215,"code":"      test('400 error proxy call', async () => {\n        nock(domain).get('/jquery').reply(409);\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        await expect(\n          prox1.getRemoteMetadataNext('jquery', {\n            remoteAddress: '127.0.0.1',\n          })\n        ).rejects.toThrowError(\n          errorUtils.getInternalError(`${errorUtils.API_ERROR.BAD_STATUS_CODE}: 409`)\n        );\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"proxy  not found","suites":["proxy","getRemoteMetadataNext","error handling"],"updatePoint":{"line":227,"column":28},"line":227,"code":"      test('proxy  not found', async () => {\n        nock(domain).get('/jquery').reply(404);\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        await expect(\n          prox1.getRemoteMetadataNext('jquery', {\n            remoteAddress: '127.0.0.1',\n          })\n        ).rejects.toThrowError(errorUtils.getNotFound(API_ERROR.NOT_PACKAGE_UPLINK));\n        expect(mockHttp).toHaveBeenCalledTimes(1);\n        expect(mockHttp).toHaveBeenLastCalledWith(\n          {\n            request: { method: 'GET', url: `${domain}/jquery` },\n            status: 404,\n          },\n          \"@{!status}, req: '@{request.method} @{request.url}' (streaming)\"\n        );\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"retry twice on 500 and return 200 logging offline activity","suites":["proxy","getRemoteMetadataNext","retry"],"updatePoint":{"line":247,"column":70},"line":247,"code":"      test('retry twice on 500 and return 200 logging offline activity', async () => {\n        nock(domain)\n          .get('/jquery')\n          .twice()\n          .reply(500, 'some-text')\n          .get('/jquery')\n          .once()\n          .reply(200, { body: { name: 'foo', version: '1.0.0' } });\n\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        const [manifest] = await prox1.getRemoteMetadataNext('jquery', {\n          retry: { limit: 2 },\n        });\n        expect(manifest).toEqual({ body: { name: 'foo', version: '1.0.0' } });\n        expect(mockInfo).toHaveBeenCalledTimes(2);\n        expect(mockInfo).toHaveBeenLastCalledWith(\n          {\n            error: 'Response code 500 (Internal Server Error)',\n            request: { method: 'GET', url: `${domain}/jquery` },\n            retryCount: 2,\n          },\n          \"retry @{retryCount} req: '@{request.method} @{request.url}'\"\n        );\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"retry is exceded and uplink goes offline with logging activity","suites":["proxy","getRemoteMetadataNext","retry"],"updatePoint":{"line":272,"column":74},"line":272,"code":"      test('retry is exceded and uplink goes offline with logging activity', async () => {\n        nock(domain).get('/jquery').times(10).reply(500);\n\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        await expect(\n          prox1.getRemoteMetadataNext('jquery', {\n            remoteAddress: '127.0.0.1',\n            retry: { limit: 2 },\n          })\n        ).rejects.toThrowError();\n        await expect(\n          prox1.getRemoteMetadataNext('jquery', {\n            remoteAddress: '127.0.0.1',\n            retry: { limit: 2 },\n          })\n        ).rejects.toThrowError(errorUtils.getInternalError(errorUtils.API_ERROR.UPLINK_OFFLINE));\n        expect(mockWarn).toHaveBeenCalledTimes(1);\n        expect(mockWarn).toHaveBeenLastCalledWith(\n          {\n            host: 'registry.npmjs.org',\n          },\n          'host @{host} is now offline'\n        );\n      });","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"fails calls and recover with 200 with log online activity","suites":["proxy","getRemoteMetadataNext","retry"],"updatePoint":{"line":297,"column":69},"line":297,"code":"      test('fails calls and recover with 200 with log online activity', async () => {\n        // This unit test is designed to verify if the uplink goes to offline\n        // and recover after the fail_timeout has expired.\n        nock(domain)\n          .get('/jquery')\n          .thrice()\n          .reply(500, 'some-text')\n          .get('/jquery')\n          .once()\n          .reply(200, { body: { name: 'foo', version: '1.0.0' } });\n\n        const prox1 = new ProxyStorage(\n          { ...defaultRequestOptions, fail_timeout: '1s', max_fails: 1 },\n          conf\n        );\n        // force retry\n        await expect(\n          prox1.getRemoteMetadataNext('jquery', {\n            remoteAddress: '127.0.0.1',\n            retry: { limit: 2 },\n          })\n        ).rejects.toThrowError();\n        // display offline error on exausted retry\n        await expect(\n          prox1.getRemoteMetadataNext('jquery', {\n            remoteAddress: '127.0.0.1',\n            retry: { limit: 2 },\n          })\n        ).rejects.toThrowError(errorUtils.getInternalError(errorUtils.API_ERROR.UPLINK_OFFLINE));\n        expect(mockWarn).toHaveBeenCalledTimes(2);\n        expect(mockWarn).toHaveBeenLastCalledWith(\n          {\n            host: 'registry.npmjs.org',\n          },\n          'host @{host} is now offline'\n        );\n        expect(mockWarn).toHaveBeenLastCalledWith(\n          {\n            host: 'registry.npmjs.org',\n          },\n          'host @{host} is now offline'\n        );\n        // this is based on max_fails, if change that also change here acordingly\n        await setTimeout(3000);\n        const [manifest] = await prox1.getRemoteMetadataNext('jquery', {\n          retry: { limit: 2 },\n        });\n        expect(manifest).toEqual({ body: { name: 'foo', version: '1.0.0' } });\n        expect(mockWarn).toHaveBeenLastCalledWith(\n          {\n            host: 'registry.npmjs.org',\n          },\n          'host @{host} is now online'\n        );\n      }, 10000);","file":"proxy.metadata.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"get response from endpoint","suites":["proxy","search"],"updatePoint":{"line":53,"column":36},"line":53,"code":"    test('get response from endpoint', async () => {\n      const response = require('./partials/search-v1.json');\n      const mockAgent = new MockAgent({ connections: 1 });\n      mockAgent.disableNetConnect();\n      setGlobalDispatcher(mockAgent);\n      const mockClient = mockAgent.get(domain);\n      mockClient.intercept(options).reply(200, JSON.stringify(response));\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      const abort = new AbortController();\n      const stream = await prox1.search({\n        abort,\n        url: queryUrl,\n      });\n\n      const searchResponse = await getStream(stream.pipe(streamUtils.transformObjectToString()));\n      expect(searchResponse).toEqual(searchResponse);\n    });","file":"proxy.search.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"handle bad response 409","suites":["proxy","search"],"updatePoint":{"line":71,"column":33},"line":71,"code":"    test('handle bad response 409', async () => {\n      const mockAgent = new MockAgent({ connections: 1 });\n      mockAgent.disableNetConnect();\n      setGlobalDispatcher(mockAgent);\n      const mockClient = mockAgent.get(domain);\n      mockClient.intercept(options).reply(409, {});\n      const abort = new AbortController();\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      await expect(\n        prox1.search({\n          abort,\n          url: queryUrl,\n        })\n      ).rejects.toThrow('bad status code 409 from uplink');\n    });","file":"proxy.search.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"abort search from endpoint","suites":["proxy","search"],"line":87,"code":"    test.todo('abort search from endpoint');","file":"proxy.search.spec.ts","skipped":true,"dir":"packages/proxy/test"},{"name":"get file from endpoint with gzip headers","suites":["proxy","search"],"line":91,"code":"    test.todo('get file from endpoint with gzip headers');","file":"proxy.search.spec.ts","skipped":true,"dir":"packages/proxy/test"},{"name":"search endpoint fails","suites":["proxy","search"],"updatePoint":{"line":93,"column":31},"line":93,"code":"    test('search endpoint fails', async () => {\n      const mockAgent = new MockAgent({ connections: 1 });\n      mockAgent.disableNetConnect();\n      setGlobalDispatcher(mockAgent);\n      const mockClient = mockAgent.get(domain);\n      mockClient.intercept(options).reply(500, {});\n      const abort = new AbortController();\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      await expect(\n        prox1.search({\n          abort,\n          url: queryUrl,\n        })\n      ).rejects.toThrow('bad status code 500 from uplink');\n    });","file":"proxy.search.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"get file tarball fetch","suites":["tarball proxy","fetchTarballNext"],"updatePoint":{"line":43,"column":32},"line":43,"code":"    test('get file tarball fetch', (done) => {\n      nock('https://registry.verdaccio.org')\n        .get('/jquery/-/jquery-0.0.1.tgz')\n        .replyWithFile(201, path.join(__dirname, 'partials/jquery-0.0.1.tgz'));\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      const stream = prox1.fetchTarballNext(\n        'https://registry.verdaccio.org/jquery/-/jquery-0.0.1.tgz',\n        {}\n      );\n      stream.on('response', () => {\n        done();\n      });\n      stream.on('error', (err) => {\n        done(err);\n      });\n    });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"get file tarball handle retries","suites":["tarball proxy","fetchTarballNext"],"line":60,"code":"    test.skip('get file tarball handle retries', (done) => {","file":"proxy.tarball.spec.ts","skipped":true,"dir":"packages/proxy/test"},{"name":"remove duplicates","suites":["search","search manager utils"],"updatePoint":{"line":13,"column":27},"line":13,"code":"    test('remove duplicates', () => {\n      const item: searchUtils.SearchPackageItem = {\n        // @ts-expect-error\n        package: {\n          name: 'foo',\n        },\n        ['dist-tags']: {\n          latest: '1.0.0',\n        },\n        // @ts-expect-error\n        score: {},\n        searchScore: 0.4,\n      };\n\n      expect(removeDuplicates([item, item])).toEqual([item]);\n    });","file":"search.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"search items","suites":["search","search manager utils"],"updatePoint":{"line":30,"column":22},"line":30,"code":"    test('search items', async () => {\n      const { MockAgent } = require('undici');\n      // FIXME: fetch is already part of undici\n      const domain = 'https://registry.npmjs.org';\n      const url = '/-/v1/search?maintenance=1&popularity=1&quality=1&size=10&text=verdaccio';\n      const response = require('./fixtures/search.json');\n      const options = {\n        path: url,\n        method: 'GET',\n      };\n      const mockAgent = new MockAgent({ connections: 1 });\n      mockAgent.disableNetConnect();\n      setGlobalDispatcher(mockAgent);\n      const mockClient = mockAgent.get(domain);\n      mockClient.intercept(options).reply(200, JSON.stringify(response));\n      const config = new Config(getDefaultConfig());\n      const storage = new Storage(config);\n      await storage.init(config);\n\n      // @ts-expect-error\n      const results = await storage.search({ url, query: { text: 'foo' } });\n      expect(results).toHaveLength(4);\n    });","file":"search.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should not allow add star with no existing users","suites":["Star Utils","isExecutingStarCommand","disallow states"],"updatePoint":{"line":10,"column":60},"line":10,"code":"      test('should not allow add star with no existing users', () => {\n        expect(isExecutingStarCommand({}, 'foo', false)).toBeFalsy();\n      });","file":"star-utils.test.ts","skipped":false,"dir":"packages/store/test"},{"name":"should not allow add star with existing users","suites":["Star Utils","isExecutingStarCommand","disallow states"],"updatePoint":{"line":14,"column":57},"line":14,"code":"      test('should not allow add star with existing users', () => {\n        expect(isExecutingStarCommand({ bar: true }, 'foo', false)).toBeFalsy();\n      });","file":"star-utils.test.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails if user already exist and us trying to add star","suites":["Star Utils","isExecutingStarCommand","disallow states"],"updatePoint":{"line":18,"column":72},"line":18,"code":"      test('should fails if user already exist and us trying to add star', () => {\n        expect(isExecutingStarCommand({ foo: true }, 'foo', true)).toBeFalsy();\n      });","file":"star-utils.test.ts","skipped":false,"dir":"packages/store/test"},{"name":"should allow add star with existing users","suites":["Star Utils","isExecutingStarCommand","allow states"],"updatePoint":{"line":24,"column":53},"line":24,"code":"      test('should allow add star with existing users', () => {\n        expect(isExecutingStarCommand({ foo: true }, 'foo', false)).toBeTruthy();\n      });","file":"star-utils.test.ts","skipped":false,"dir":"packages/store/test"},{"name":"should allow if is adding star and does not exist","suites":["Star Utils","isExecutingStarCommand","allow states"],"updatePoint":{"line":28,"column":61},"line":28,"code":"      test('should allow if is adding star and does not exist', () => {\n        expect(isExecutingStarCommand({ foo: true }, 'bar', true)).toBeTruthy();\n      });","file":"star-utils.test.ts","skipped":false,"dir":"packages/store/test"},{"name":"is not star manifest","suites":["Star Utils","isStarManifest"],"updatePoint":{"line":35,"column":30},"line":35,"code":"    test('is not star manifest', () => {\n      const pkg = generatePackageMetadata('foo');\n      expect(isStarManifest(pkg)).toBe(false);\n    });","file":"star-utils.test.ts","skipped":false,"dir":"packages/store/test"},{"name":"is not star manifest empty users","suites":["Star Utils","isStarManifest"],"updatePoint":{"line":40,"column":42},"line":40,"code":"    test('is not star manifest empty users', () => {\n      const pkg = generatePackageMetadata('foo');\n      pkg.users = {};\n      expect(isStarManifest(pkg)).toBe(false);\n    });","file":"star-utils.test.ts","skipped":false,"dir":"packages/store/test"},{"name":"is star manifest","suites":["Star Utils","isStarManifest"],"updatePoint":{"line":46,"column":26},"line":46,"code":"    test('is star manifest', () => {\n      const pkg = generatePackageMetadata('foo', '3.0.0') as Manifest;\n      // Staring a package usually is without versions and the user property within\n      // the manifest body\n      // @ts-expect-error\n      delete pkg.versions;\n      pkg.users = {\n        foo: true,\n      };\n      expect(isStarManifest(pkg)).toBe(true);\n    });","file":"star-utils.test.ts","skipped":false,"dir":"packages/store/test"},{"name":"should delete a invalid latest version","suites":["Storage Utils","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":35,"column":50},"line":35,"code":"      test('should delete a invalid latest version', () => {\n        const pkg = cloneMetadata();\n        pkg[DIST_TAGS] = {\n          latest: '20000',\n        };\n\n        normalizeDistTags(pkg);\n\n        expect(Object.keys(pkg[DIST_TAGS])).toHaveLength(0);\n      });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should define last published version as latest","suites":["Storage Utils","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":46,"column":58},"line":46,"code":"      test('should define last published version as latest', () => {\n        const pkg = cloneMetadata();\n        pkg[DIST_TAGS] = {};\n\n        normalizeDistTags(pkg);\n\n        expect(pkg[DIST_TAGS]).toEqual({ latest: '1.0.1' });\n      });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should define last published version as latest with a custom dist-tag","suites":["Storage Utils","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":55,"column":81},"line":55,"code":"      test('should define last published version as latest with a custom dist-tag', () => {\n        const pkg = cloneMetadata();\n        pkg[DIST_TAGS] = {\n          beta: '1.0.1',\n        };\n\n        normalizeDistTags(pkg);\n\n        expect(pkg[DIST_TAGS]).toEqual({ beta: '1.0.1', latest: '1.0.1' });\n      });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should convert any array of dist-tags to a plain string","suites":["Storage Utils","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":66,"column":67},"line":66,"code":"      test('should convert any array of dist-tags to a plain string', () => {\n        const pkg = cloneMetadata();\n        pkg[DIST_TAGS] = {\n          latest: ['1.0.1'],\n        };\n\n        normalizeDistTags(pkg);\n\n        expect(pkg[DIST_TAGS]).toEqual({ latest: '1.0.1' });\n      });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should convert any empty array to empty list of dist-tags","suites":["Storage Utils","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":77,"column":69},"line":77,"code":"      test('should convert any empty array to empty list of dist-tags', () => {\n        const pkg = cloneMetadata();\n        pkg[DIST_TAGS] = {\n          latest: [],\n        };\n\n        expect(normalizeDistTags(pkg)[DIST_TAGS]).toEqual({});\n      });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should clean up a invalid latest version","suites":["Storage Utils","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":87,"column":50},"line":87,"code":"    test('should clean up a invalid latest version', () => {\n      const pkg = cloneMetadata();\n      pkg[DIST_TAGS] = {\n        latest: '20000',\n      };\n\n      expect(Object.keys(normalizeDistTags(pkg)[DIST_TAGS])).toHaveLength(0);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should handle empty dis-tags and define last published version as latest","suites":["Storage Utils","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":96,"column":82},"line":96,"code":"    test('should handle empty dis-tags and define last published version as latest', () => {\n      const pkg = cloneMetadata();\n      pkg[DIST_TAGS] = {};\n\n      expect(normalizeDistTags(pkg)[DIST_TAGS]).toEqual({ latest: '1.0.1' });\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should define last published version as latest with a custom dist-tag","suites":["Storage Utils","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":103,"column":79},"line":103,"code":"    test('should define last published version as latest with a custom dist-tag', () => {\n      const pkg = cloneMetadata();\n      pkg[DIST_TAGS] = {\n        beta: '1.0.1',\n      };\n\n      expect(normalizeDistTags(pkg)[DIST_TAGS]).toEqual({ beta: '1.0.1', latest: '1.0.1' });\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"normalizePackage clean","suites":["Storage Utils","normalizePackage"],"updatePoint":{"line":114,"column":32},"line":114,"code":"    test('normalizePackage clean', () => {\n      // @ts-expect-error\n      const pkg = normalizePackage({\n        _attachments: {},\n        _distfiles: {},\n        _rev: '',\n        _uplinks: {},\n        name: '',\n        versions: {},\n        [DIST_TAGS]: {},\n      });\n      expect(pkg).toBeDefined();\n      expect(pkg.time).toBeInstanceOf(Object);\n      expect(pkg.versions).toBeInstanceOf(Object);\n      expect(pkg[DIST_TAGS]).toBeInstanceOf(Object);\n      expect(pkg._distfiles).toBeInstanceOf(Object);\n      expect(pkg._attachments).toBeInstanceOf(Object);\n      expect(pkg._uplinks).toBeInstanceOf(Object);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"normalizePackage partial metadata","suites":["Storage Utils","normalizePackage"],"updatePoint":{"line":134,"column":43},"line":134,"code":"    test('normalizePackage partial metadata', () => {\n      // @ts-ignore\n      const pkg = normalizePackage(readFile('metadata'));\n      expect(pkg).toBeDefined();\n      expect(pkg.time).toBeInstanceOf(Object);\n      expect(pkg.versions).toBeInstanceOf(Object);\n      expect(pkg[DIST_TAGS]).toBeInstanceOf(Object);\n      expect(pkg._distfiles).toBeInstanceOf(Object);\n      expect(pkg._attachments).toBeInstanceOf(Object);\n      expect(pkg._uplinks).toBeInstanceOf(Object);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"normalizePackage partial default revision","suites":["Storage Utils","normalizePackage"],"updatePoint":{"line":146,"column":51},"line":146,"code":"    test('normalizePackage partial default revision', () => {\n      // @ts-ignore\n      const pkg = normalizePackage(readFile('metadata'));\n      expect(pkg).toBeDefined();\n      expect(pkg._rev).toBeDefined();\n      expect(pkg._rev).toBe(STORAGE.DEFAULT_REVISION);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"mergeTime basic","suites":["Storage Utils","mergeTime"],"updatePoint":{"line":165,"column":25},"line":165,"code":"    test('mergeTime basic', () => {\n      const pkg1: Manifest = {\n        _attachments: {},\n        _distfiles: {},\n        _rev: '',\n        _uplinks: {},\n        time: {\n          modified: '2018-06-13T06:44:45.747Z',\n          created: '2018-06-07T05:50:21.505Z',\n          ...vGroup1,\n        },\n        name: '',\n        versions: {},\n        [DIST_TAGS]: {},\n      };\n\n      const pkg2: Manifest = {\n        _attachments: {},\n        _distfiles: {},\n        _rev: '',\n        _uplinks: {},\n        name: '',\n        time: {\n          modified: '2019-06-13T06:44:45.747Z',\n          created: '2019-06-07T05:50:21.505Z',\n          ...vGroup2,\n        },\n        versions: {},\n        [DIST_TAGS]: {},\n      };\n\n      const mergedPkg = mergeUplinkTimeIntoLocal(pkg1, pkg2);\n      expect(Object.keys(mergedPkg)).toEqual([\n        'modified',\n        'created',\n        ...Object.keys(vGroup1),\n        ...Object.keys(vGroup2),\n      ]);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"mergeTime remote empty","suites":["Storage Utils","mergeTime"],"updatePoint":{"line":205,"column":32},"line":205,"code":"    test('mergeTime remote empty', () => {\n      const pkg1: Manifest = {\n        _attachments: {},\n        _distfiles: {},\n        _rev: '',\n        _uplinks: {},\n        name: '',\n        time: {\n          modified: '2018-06-13T06:44:45.747Z',\n          created: '2018-06-07T05:50:21.505Z',\n          ...vGroup1,\n        },\n        versions: {},\n        [DIST_TAGS]: {},\n      };\n\n      const pkg2: Manifest = {\n        _attachments: {},\n        _distfiles: {},\n        _rev: '',\n        _uplinks: {},\n        name: '',\n        versions: {},\n        [DIST_TAGS]: {},\n      };\n      const mergedPkg = mergeUplinkTimeIntoLocal(pkg1, pkg2);\n      expect(Object.keys(mergedPkg)).toEqual(['modified', 'created', ...Object.keys(vGroup1)]);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"is not deprecated manifest","suites":["Storage Utils","isDeprecatedManifest"],"updatePoint":{"line":236,"column":36},"line":236,"code":"    test('is not deprecated manifest', () => {\n      const pkg = generatePackageMetadata('foo');\n      expect(isDeprecatedManifest(pkg)).toBe(false);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"is not deprecated manifest no _attachments","suites":["Storage Utils","isDeprecatedManifest"],"updatePoint":{"line":241,"column":52},"line":241,"code":"    test('is not deprecated manifest no _attachments', () => {\n      const pkg = generatePackageMetadata('foo');\n      // @ts-ignore\n      delete pkg._attachments;\n      expect(isDeprecatedManifest(pkg)).toBe(false);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"is deprecated manifest","suites":["Storage Utils","isDeprecatedManifest"],"updatePoint":{"line":248,"column":32},"line":248,"code":"    test('is deprecated manifest', () => {\n      const pkg = generatePackageMetadata('foo', '2.0.0');\n      // @ts-ignore\n      pkg.versions['2.0.0'].deprecated = 'some reason';\n      pkg._attachments = {};\n      expect(isDeprecatedManifest(pkg)).toBe(true);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"is not deprecated manifest if _attachment contains data","suites":["Storage Utils","isDeprecatedManifest"],"updatePoint":{"line":256,"column":65},"line":256,"code":"    test('is not deprecated manifest if _attachment contains data', () => {\n      const pkg = generatePackageMetadata('foo', '2.0.0');\n      // @ts-ignore\n      pkg.versions['2.0.0'].deprecated = 'some reason';\n      pkg._attachments = {\n        ['2.0.0']: {\n          data: 'fooData',\n        },\n      };\n      expect(isDeprecatedManifest(pkg)).toBe(false);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"isDifferentThanOne is true","suites":["Storage Utils","isDifferentThanOne"],"updatePoint":{"line":270,"column":36},"line":270,"code":"    test('isDifferentThanOne is true', () => {\n      expect(isDifferentThanOne({})).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"isDifferentThanOne is false","suites":["Storage Utils","isDifferentThanOne"],"updatePoint":{"line":273,"column":37},"line":273,"code":"    test('isDifferentThanOne is false', () => {\n      expect(\n        isDifferentThanOne({\n          foo: 'bar',\n        })\n      ).toBeFalsy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"isDifferentThanOne with two items is true","suites":["Storage Utils","isDifferentThanOne"],"updatePoint":{"line":280,"column":51},"line":280,"code":"    test('isDifferentThanOne with two items is true', () => {\n      expect(\n        isDifferentThanOne({\n          foo: 'bar',\n          foo1: 'bar',\n        })\n      ).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should be valid","suites":["Storage Utils","hasInvalidPublishBody"],"updatePoint":{"line":291,"column":25},"line":291,"code":"    test('should be valid', () => {\n      expect(\n        hasInvalidPublishBody({\n          _attachments: {\n            'forbidden-place-1.0.6.tgz': {\n              content_type: 'application/octet-stream',\n              data: 'foo',\n              length: 512,\n            },\n          },\n          versions: {\n            // @ts-expect-error\n            '1.0.0': {},\n          },\n        })\n      ).toBeFalsy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should be invalid due missing versions","suites":["Storage Utils","hasInvalidPublishBody"],"updatePoint":{"line":309,"column":48},"line":309,"code":"    test('should be invalid due missing versions', () => {\n      expect(\n        hasInvalidPublishBody({\n          _attachments: {},\n          versions: {},\n        })\n      ).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should be invalid due missing _attachments","suites":["Storage Utils","hasInvalidPublishBody"],"updatePoint":{"line":318,"column":52},"line":318,"code":"    test('should be invalid due missing _attachments', () => {\n      expect(\n        hasInvalidPublishBody({\n          _attachments: {},\n          versions: {},\n        })\n      ).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should be invalid due invalid empty versions  object","suites":["Storage Utils","hasInvalidPublishBody"],"updatePoint":{"line":327,"column":62},"line":327,"code":"    test('should be invalid due invalid empty versions  object', () => {\n      expect(\n        hasInvalidPublishBody({\n          _attachments: {\n            'forbidden-place-1.0.6.tgz': {\n              content_type: 'application/octet-stream',\n              data: 'foo',\n              length: 512,\n            },\n          },\n          versions: {},\n        })\n      ).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should be invalid due empty _attachments object","suites":["Storage Utils","hasInvalidPublishBody"],"updatePoint":{"line":342,"column":57},"line":342,"code":"    test('should be invalid due empty _attachments object', () => {\n      expect(\n        hasInvalidPublishBody({\n          _attachments: {},\n          versions: {\n            // @ts-expect-error\n            '1.0.0': {},\n            // @ts-expect-error\n            '1.0.1': {},\n          },\n        })\n      ).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"create private package","suites":["storage","updateManifest","publishing"],"updatePoint":{"line":101,"column":34},"line":101,"code":"      test('create private package', async () => {\n        const mockDate = '2018-01-14T11:17:40.712Z';\n        MockDate.set(mockDate);\n        const pkgName = 'upstream';\n        const requestOptions = {\n          host: 'localhost',\n          protocol: 'http',\n          headers: {},\n        };\n        const config = new Config(\n          configExample(\n            {\n              ...getDefaultConfig(),\n              storage: generateRandomStorage(),\n            },\n            './fixtures/config/updateManifest-1.yaml',\n            __dirname\n          )\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n        const bodyNewManifest = generatePackageMetadata(pkgName, '1.0.0');\n        await storage.updateManifest(bodyNewManifest, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          uplinksLook: true,\n          revision: '1',\n          requestOptions,\n        });\n        const manifest = (await storage.getPackageByOptions({\n          name: pkgName,\n          uplinksLook: true,\n          requestOptions,\n        })) as Manifest;\n        expect(manifest.name).toEqual(pkgName);\n        expect(manifest._id).toEqual(pkgName);\n        expect(Object.keys(manifest.versions)).toEqual(['1.0.0']);\n        expect(manifest.time).toEqual({\n          '1.0.0': mockDate,\n          created: mockDate,\n          modified: mockDate,\n        });\n        expect(manifest[DIST_TAGS]).toEqual({ latest: '1.0.0' });\n        expect(manifest.readme).toEqual('# test');\n        expect(manifest._attachments).toEqual({});\n        expect(typeof manifest._rev).toBeTruthy();\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"abort creating a private package","suites":["storage","updateManifest","publishing"],"line":150,"code":"      test.skip('abort creating a private package', async () => {","file":"storage.spec.ts","skipped":true,"dir":"packages/store/test"},{"name":"create private package with multiple consecutive versions","suites":["storage","updateManifest","publishing"],"updatePoint":{"line":185,"column":69},"line":185,"code":"      test('create private package with multiple consecutive versions', async () => {\n        const mockDate = '2018-01-14T11:17:40.712Z';\n        MockDate.set(mockDate);\n        const settings = {\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: {\n            host: 'localhost',\n            protocol: 'http',\n            headers: {},\n          },\n        };\n        const pkgName = 'upstream';\n        // const storage = generateRandomStorage();\n        const config = new Config(\n          configExample(\n            {\n              storage: await fileUtils.createTempStorageFolder('storage-test'),\n            },\n            './fixtures/config/updateManifest-1.yaml',\n            __dirname\n          )\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n        // create a package\n        const bodyNewManifest1 = generatePackageMetadata(pkgName, '1.0.0');\n        await storage.updateManifest(bodyNewManifest1, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          ...settings,\n        });\n        // publish second version\n        const bodyNewManifest2 = generatePackageMetadata(pkgName, '1.0.1');\n        await storage.updateManifest(bodyNewManifest2, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          ...settings,\n        });\n        // retrieve package metadata\n        const manifest = (await storage.getPackageByOptions({\n          name: pkgName,\n          uplinksLook: true,\n          requestOptions: {\n            host: 'localhost',\n            protocol: 'http',\n            headers: {},\n          },\n        })) as Manifest;\n        expect(manifest.name).toEqual(pkgName);\n        expect(manifest._id).toEqual(pkgName);\n        expect(Object.keys(manifest.versions)).toEqual(['1.0.0', '1.0.1']);\n        expect(manifest.time).toEqual({\n          '1.0.0': mockDate,\n          '1.0.1': mockDate,\n          created: mockDate,\n          modified: mockDate,\n        });\n        expect(manifest[DIST_TAGS]).toEqual({ latest: '1.0.1' });\n        expect(manifest.readme).toEqual('# test');\n        expect(manifest._attachments).toEqual({});\n        expect(typeof manifest._rev).toBeTruthy();\n        // verify the version structure is correct\n        const manifestVersion = (await storage.getPackageByOptions({\n          name: pkgName,\n          version: '1.0.1',\n          uplinksLook: true,\n          requestOptions: {\n            host: 'localhost',\n            protocol: 'http',\n            headers: {},\n          },\n        })) as Version;\n        expect(manifestVersion.name).toEqual(pkgName);\n        expect(manifestVersion.version).toEqual('1.0.1');\n        expect(manifestVersion._id).toEqual(`${pkgName}@1.0.1`);\n        expect(manifestVersion.description).toEqual('package generated');\n        expect(manifestVersion.dist).toEqual({\n          integrity:\n            'sha512-6gHiERpiDgtb3hjqpQH5/i7zRmvYi9pmCjQf2ZMy3QEa9wVk9RgdZaPWUt7ZOnWUPFjcr9cmE6dUBf+XoPoH4g==',\n          shasum: '2c03764f651a9f016ca0b7620421457b619151b9',\n          tarball: 'http://localhost:5555/upstream/-/upstream-1.0.1.tgz',\n        });\n\n        expect(manifestVersion.contributors).toEqual([]);\n        expect(manifestVersion.main).toEqual('index.js');\n        expect(manifestVersion.author).toEqual({ name: 'User NPM', email: 'user@domain.com' });\n        expect(manifestVersion.dependencies).toEqual({ verdaccio: '^2.7.2' });\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"fails if version already exist","suites":["storage","updateManifest","publishing"],"updatePoint":{"line":275,"column":42},"line":275,"code":"      test('fails if version already exist', async () => {\n        const settings = {\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: {\n            host: 'localhost',\n            protocol: 'http',\n            headers: {},\n          },\n        };\n        const pkgName = 'upstream';\n        const config = new Config(\n          configExample(\n            {\n              storage: generateRandomStorage(),\n            },\n            './fixtures/config/getTarballNext-getupstream.yaml',\n            __dirname\n          )\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n        const bodyNewManifest1 = generatePackageMetadata(pkgName, '1.0.0');\n        const bodyNewManifest2 = generatePackageMetadata(pkgName, '1.0.0');\n        await storage.updateManifest(bodyNewManifest1, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          ...settings,\n        });\n        await expect(\n          storage.updateManifest(bodyNewManifest2, {\n            signal: new AbortController().signal,\n            name: pkgName,\n            ...settings,\n          })\n        ).rejects.toThrow(API_ERROR.PACKAGE_EXIST);\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"deprecate package %s","suites":["storage","updateManifest","deprecate"],"line":314,"code":"      test.each([['foo'], ['@scope/foo']])('deprecate package %s', async (pkgName) => {\n        const mockDate = '2018-01-14T11:17:40.712Z';\n        MockDate.set(mockDate);\n        const config = getConfig('deprecate.yaml');\n        const storage = new Storage(config);\n        await storage.init(config);\n        const bodyNewManifest = generatePackageMetadata(pkgName, '1.0.0');\n        await storage.updateManifest(bodyNewManifest, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: defaultRequestOptions,\n        });\n        const manifest1 = (await storage.getPackageByOptions({\n          name: pkgName,\n          uplinksLook: true,\n          requestOptions: defaultRequestOptions,\n        })) as Manifest;\n        expect(manifest1.versions['1.0.0'].deprecated).toBeUndefined();\n\n        const deprecatedManifest = getDeprecatedPackageMetadata(\n          pkgName,\n          '1.0.0',\n          {\n            ['latest']: '1.0.0',\n          },\n          'some deprecation message',\n          manifest1._rev\n        );\n        await storage.updateManifest(deprecatedManifest, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: defaultRequestOptions,\n        });\n        const manifest = (await storage.getPackageByOptions({\n          name: pkgName,\n          uplinksLook: true,\n          requestOptions: defaultRequestOptions,\n        })) as Manifest;\n        expect(manifest.name).toEqual(pkgName);\n        expect(manifest.versions['1.0.0'].deprecated).toEqual('some deprecation message');\n        // important revision is updated\n        expect(manifest._rev !== deprecatedManifest._rev).toBeTruthy();\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"undeprecate package %s","suites":["storage","updateManifest","deprecate"],"line":361,"code":"      test.each([['foo'], ['@scope/foo']])('undeprecate package %s', async (pkgName) => {\n        const mockDate = '2018-01-14T11:17:40.712Z';\n        MockDate.set(mockDate);\n        const config = getConfig('deprecate.yaml');\n        const storage = new Storage(config);\n        await storage.init(config);\n        // publish new package\n        const bodyNewManifest = generatePackageMetadata(pkgName, '1.0.0');\n        await storage.updateManifest(bodyNewManifest, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: defaultRequestOptions,\n        });\n\n        // verify not deprecated\n        const manifest1 = (await storage.getPackageByOptions({\n          name: pkgName,\n          uplinksLook: true,\n          requestOptions: defaultRequestOptions,\n        })) as Manifest;\n        expect(manifest1.versions['1.0.0'].deprecated).toBeUndefined();\n\n        // deprecate version\n        const deprecatedManifest = getDeprecatedPackageMetadata(\n          pkgName,\n          '1.0.0',\n          {\n            ['latest']: '1.0.0',\n          },\n          'some deprecation message',\n          manifest1._rev\n        );\n        await storage.updateManifest(deprecatedManifest, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: defaultRequestOptions,\n        });\n        const manifest = (await storage.getPackageByOptions({\n          name: pkgName,\n          uplinksLook: true,\n          requestOptions: defaultRequestOptions,\n        })) as Manifest;\n        expect(manifest.name).toEqual(pkgName);\n        expect(manifest.versions['1.0.0'].deprecated).toEqual('some deprecation message');\n        // important revision is updated\n        expect(manifest._rev !== deprecatedManifest._rev).toBeTruthy();\n\n        // un deprecated the previous deprecated\n        const undeprecatedManifest = {\n          ...manifest,\n        };\n        undeprecatedManifest.versions['1.0.0'].deprecated = '';\n        await storage.updateManifest(undeprecatedManifest, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: defaultRequestOptions,\n        });\n\n        const manifest3 = (await storage.getPackageByOptions({\n          name: pkgName,\n          uplinksLook: true,\n          requestOptions: defaultRequestOptions,\n        })) as Manifest;\n        expect(manifest3.name).toEqual(pkgName);\n        expect(manifest3.versions['1.0.0'].deprecated).toBeUndefined();\n        // important revision is updated\n        expect(manifest3._rev !== deprecatedManifest._rev).toBeTruthy();\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"star package %s","suites":["storage","updateManifest","star"],"line":437,"code":"      test.each([['foo']])('star package %s', async (pkgName) => {\n        const config = getConfig('deprecate.yaml');\n        const storage = new Storage(config);\n        await storage.init(config);\n        const bodyNewManifest = generatePackageMetadata(pkgName, '1.0.0');\n        await storage.updateManifest(bodyNewManifest, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: defaultRequestOptions,\n        });\n        const message = await executeStarPackage(storage, {\n          _rev: bodyNewManifest._rev,\n          _id: bodyNewManifest._id,\n          name: pkgName,\n          username: 'fooUser',\n          users: { fooUser: true },\n        });\n        expect(message).toEqual(API_MESSAGE.PKG_CHANGED);\n        const manifest1 = (await storage.getPackageByOptions({\n          name: pkgName,\n          uplinksLook: true,\n          requestOptions: defaultRequestOptions,\n        })) as Manifest;\n\n        expect(manifest1?.users).toEqual({\n          fooUser: true,\n        });\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should add multiple users to package %s","suites":["storage","updateManifest","star"],"line":468,"code":"      test.each([['foo']])('should add multiple users to package %s', async (pkgName) => {\n        const mockDate = '2018-01-14T11:17:40.712Z';\n        MockDate.set(mockDate);\n        const config = getConfig('deprecate.yaml');\n        const storage = new Storage(config);\n        await storage.init(config);\n        const bodyNewManifest = generatePackageMetadata(pkgName, '1.0.0');\n        await storage.updateManifest(bodyNewManifest, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: defaultRequestOptions,\n        });\n        const message = await executeStarPackage(storage, {\n          _rev: bodyNewManifest._rev,\n          _id: bodyNewManifest._id,\n          name: pkgName,\n          username: 'fooUser',\n          users: { fooUser: true },\n        });\n        expect(message).toEqual(API_MESSAGE.PKG_CHANGED);\n\n        await executeStarPackage(storage, {\n          _rev: bodyNewManifest._rev,\n          _id: bodyNewManifest._id,\n          name: pkgName,\n          username: 'owner',\n          users: { owner: true },\n        });\n        const manifest1 = (await storage.getPackageByOptions({\n          name: pkgName,\n          uplinksLook: true,\n          requestOptions: defaultRequestOptions,\n        })) as Manifest;\n\n        expect(manifest1?.users).toEqual({\n          fooUser: true,\n          owner: true,\n        });\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should ignore duplicate users to package %s","suites":["storage","updateManifest","star"],"line":510,"code":"      test.each([['foo']])('should ignore duplicate users to package %s', async (pkgName) => {\n        const mockDate = '2018-01-14T11:17:40.712Z';\n        MockDate.set(mockDate);\n        const config = getConfig('deprecate.yaml');\n        const storage = new Storage(config);\n        await storage.init(config);\n        const bodyNewManifest = generatePackageMetadata(pkgName, '1.0.0');\n        await storage.updateManifest(bodyNewManifest, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: defaultRequestOptions,\n        });\n        const message = await executeStarPackage(storage, {\n          _rev: bodyNewManifest._rev,\n          _id: bodyNewManifest._id,\n          name: pkgName,\n          username: 'fooUser',\n          users: { fooUser: true },\n        });\n        expect(message).toEqual(API_MESSAGE.PKG_CHANGED);\n\n        await executeStarPackage(storage, {\n          _rev: bodyNewManifest._rev,\n          _id: bodyNewManifest._id,\n          name: pkgName,\n          username: 'fooUser',\n          users: { fooUser: true },\n        });\n        const manifest1 = (await storage.getPackageByOptions({\n          name: pkgName,\n          uplinksLook: true,\n          requestOptions: defaultRequestOptions,\n        })) as Manifest;\n\n        expect(manifest1?.users).toEqual({\n          fooUser: true,\n        });\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should unstar a package %s","suites":["storage","updateManifest","star"],"line":551,"code":"      test.each([['foo']])('should unstar a package %s', async (pkgName) => {\n        const config = getConfig('deprecate.yaml');\n        const storage = new Storage(config);\n        await storage.init(config);\n        const bodyNewManifest = generatePackageMetadata(pkgName, '1.0.0');\n        await storage.updateManifest(bodyNewManifest, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: defaultRequestOptions,\n        });\n        const message = await executeStarPackage(storage, {\n          _rev: bodyNewManifest._rev,\n          _id: bodyNewManifest._id,\n          name: pkgName,\n          username: 'fooUser',\n          users: { fooUser: true },\n        });\n        expect(message).toEqual(API_MESSAGE.PKG_CHANGED);\n\n        await executeStarPackage(storage, {\n          _rev: bodyNewManifest._rev,\n          _id: bodyNewManifest._id,\n          name: pkgName,\n          username: 'fooUser',\n          users: {},\n        });\n        const manifest1 = (await storage.getPackageByOptions({\n          name: pkgName,\n          uplinksLook: true,\n          requestOptions: defaultRequestOptions,\n        })) as Manifest;\n\n        expect(manifest1?.users).toEqual({});\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should handle missing username %s","suites":["storage","updateManifest","star"],"line":588,"code":"      test.each([['foo']])('should handle missing username %s', async (pkgName) => {\n        const config = getConfig('deprecate.yaml');\n        const storage = new Storage(config);\n        await storage.init(config);\n        const bodyNewManifest = generatePackageMetadata(pkgName, '1.0.0');\n        await storage.updateManifest(bodyNewManifest, {\n          signal: new AbortController().signal,\n          name: pkgName,\n          uplinksLook: true,\n          revision: '1',\n          requestOptions: defaultRequestOptions,\n        });\n        await expect(\n          executeStarPackage(storage, {\n            _rev: bodyNewManifest._rev,\n            _id: bodyNewManifest._id,\n            name: pkgName,\n            // @ts-expect-error\n            username: undefined,\n            users: { fooUser: true },\n          })\n        ).rejects.toThrow();\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should not found a package anywhere","suites":["storage","getTarballNext"],"updatePoint":{"line":615,"column":45},"line":615,"code":"    test('should not found a package anywhere', (done) => {\n      const config = new Config(\n        configExample({\n          ...getDefaultConfig(),\n          storage: generateRandomStorage(),\n        })\n      );\n      const storage = new Storage(config);\n      storage.init(config).then(() => {\n        const abort = new AbortController();\n        storage\n          .getTarballNext('some-tarball', 'some-tarball-1.0.0.tgz', {\n            signal: abort.signal,\n          })\n          .then((stream) => {\n            stream.on('error', (err) => {\n              expect(err).toEqual(errorUtils.getNotFound(API_ERROR.NO_PACKAGE));\n              done();\n            });\n          });\n      });\n    });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should create a package if tarball is requested and does not exist locally","suites":["storage","getTarballNext"],"updatePoint":{"line":638,"column":84},"line":638,"code":"    test('should create a package if tarball is requested and does not exist locally', (done) => {\n      const pkgName = 'upstream';\n      const upstreamManifest = generateRemotePackageMetadata(\n        pkgName,\n        '1.0.0',\n        'https://registry.something.org'\n      );\n      nock('https://registry.verdaccio.org').get(`/${pkgName}`).reply(201, upstreamManifest);\n      nock('https://registry.something.org')\n        .get(`/${pkgName}/-/${pkgName}-1.0.0.tgz`)\n        // types does not match here with documentation\n        // @ts-expect-error\n        .replyWithFile(201, path.join(__dirname, 'fixtures/tarball.tgz'), {\n          [HEADER_TYPE.CONTENT_LENGTH]: 277,\n        });\n      const config = new Config(\n        configExample(\n          {\n            storage: generateRandomStorage(),\n          },\n          './fixtures/config/getTarballNext-getupstream.yaml',\n          __dirname\n        )\n      );\n      const storage = new Storage(config);\n      storage.init(config).then(() => {\n        const abort = new AbortController();\n        storage\n          .getTarballNext(pkgName, `${pkgName}-1.0.0.tgz`, {\n            signal: abort.signal,\n          })\n          .then((stream) => {\n            stream.on('data', (dat) => {\n              expect(dat).toBeDefined();\n            });\n            stream.on('end', () => {\n              done();\n            });\n            stream.on('error', () => {\n              done('this should not happen');\n            });\n          });\n      });\n    });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should serve fetch tarball from upstream without dist info local","suites":["storage","getTarballNext"],"updatePoint":{"line":683,"column":74},"line":683,"code":"    test('should serve fetch tarball from upstream without dist info local', (done) => {\n      const pkgName = 'upstream';\n      const upstreamManifest = addNewVersion(\n        generateRemotePackageMetadata(pkgName, '1.0.0'),\n        '1.0.1'\n      );\n      nock('https://registry.verdaccio.org').get(`/${pkgName}`).reply(201, upstreamManifest);\n      nock('http://localhost:5555')\n        .get(`/${pkgName}/-/${pkgName}-1.0.1.tgz`)\n        // types does not match here with documentation\n        // @ts-expect-error\n        .replyWithFile(201, path.join(__dirname, 'fixtures/tarball.tgz'), {\n          [HEADER_TYPE.CONTENT_LENGTH]: 277,\n        });\n      const config = new Config(\n        configExample(\n          {\n            storage: generateRandomStorage(),\n          },\n          './fixtures/config/getTarballNext-getupstream.yaml',\n          __dirname\n        )\n      );\n      const storage = new Storage(config);\n      storage.init(config).then(() => {\n        const ac = new AbortController();\n        const bodyNewManifest = generatePackageMetadata(pkgName, '1.0.0');\n        storage\n          .updateManifest(bodyNewManifest, {\n            signal: ac.signal,\n            name: pkgName,\n            uplinksLook: true,\n            revision: '1',\n            requestOptions: {\n              host: 'localhost',\n              protocol: 'http',\n              headers: {},\n            },\n          })\n          .then(() => {\n            const abort = new AbortController();\n            storage\n              .getTarballNext(pkgName, `${pkgName}-1.0.1.tgz`, {\n                signal: abort.signal,\n              })\n              .then((stream) => {\n                stream.on('data', (dat) => {\n                  expect(dat).toBeDefined();\n                });\n                stream.on('end', () => {\n                  done();\n                });\n                stream.on('error', () => {\n                  done('this should not happen');\n                });\n              });\n          });\n      });\n    });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should serve fetch tarball from upstream without with info local","suites":["storage","getTarballNext"],"updatePoint":{"line":743,"column":74},"line":743,"code":"    test('should serve fetch tarball from upstream without with info local', (done) => {\n      const pkgName = 'upstream';\n      const upstreamManifest = addNewVersion(\n        addNewVersion(generateRemotePackageMetadata(pkgName, '1.0.0'), '1.0.1'),\n        '1.0.2'\n      );\n      nock('https://registry.verdaccio.org')\n        .get(`/${pkgName}`)\n        .times(10)\n        .reply(201, upstreamManifest);\n      nock('http://localhost:5555')\n        .get(`/${pkgName}/-/${pkgName}-1.0.0.tgz`)\n        // types does not match here with documentation\n        // @ts-expect-error\n        .replyWithFile(201, path.join(__dirname, 'fixtures/tarball.tgz'), {\n          [HEADER_TYPE.CONTENT_LENGTH]: 277,\n        });\n      const storagePath = generateRandomStorage();\n      const config = new Config(\n        configExample(\n          {\n            storage: storagePath,\n          },\n          './fixtures/config/getTarballNext-getupstream.yaml',\n          __dirname\n        )\n      );\n      const storage = new Storage(config);\n      storage.init(config).then(() => {\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        return storage\n          .getPackageByOptions({\n            name: pkgName,\n            uplinksLook: true,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host') as string,\n            },\n          })\n          .then(() => {\n            const abort = new AbortController();\n            storage\n              .getTarballNext(pkgName, `${pkgName}-1.0.0.tgz`, {\n                signal: abort.signal,\n              })\n              .then((stream) => {\n                stream.on('data', (dat) => {\n                  expect(dat).toBeDefined();\n                });\n                stream.on('end', () => {\n                  done();\n                });\n                stream.once('error', () => {\n                  done('this should not happen');\n                });\n              });\n          });\n      });\n    });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should serve local cache","suites":["storage","getTarballNext"],"updatePoint":{"line":812,"column":34},"line":812,"code":"    test('should serve local cache', (done) => {\n      const pkgName = 'upstream';\n      const config = new Config(\n        configExample(\n          {\n            storage: generateRandomStorage(),\n          },\n          './fixtures/config/getTarballNext-getupstream.yaml',\n          __dirname\n        )\n      );\n      const storage = new Storage(config);\n      storage.init(config).then(() => {\n        const ac = new AbortController();\n        const bodyNewManifest = generatePackageMetadata(pkgName, '1.0.0');\n        storage\n          .updateManifest(bodyNewManifest, {\n            signal: ac.signal,\n            name: pkgName,\n            uplinksLook: true,\n            revision: '1',\n            requestOptions: {\n              host: 'localhost',\n              protocol: 'http',\n              headers: {},\n            },\n          })\n          .then(() => {\n            const abort = new AbortController();\n            storage\n              .getTarballNext(pkgName, `${pkgName}-1.0.0.tgz`, {\n                signal: abort.signal,\n              })\n              .then((stream) => {\n                stream.on('data', (dat) => {\n                  expect(dat).toBeDefined();\n                });\n                stream.on('end', () => {\n                  done();\n                });\n                stream.on('error', () => {\n                  done('this should not happen');\n                });\n              });\n          });\n      });\n    });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should handle double failure on uplinks with timeout","suites":["storage","syncUplinksMetadataNext()","error handling"],"updatePoint":{"line":863,"column":64},"line":863,"code":"      test('should handle double failure on uplinks with timeout', async () => {\n        const fooManifest = generatePackageMetadata('timeout', '8.0.0');\n\n        nock('https://registry.domain.com')\n          .get('/timeout')\n          .times(10)\n          .delayConnection(2000)\n          .reply(201, manifestFooRemoteNpmjs);\n\n        const config = new Config(\n          configExample(\n            {\n              storage: generateRandomStorage(),\n            },\n            './fixtures/config/syncDoubleUplinksMetadata.yaml',\n            __dirname\n          )\n        );\n\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.syncUplinksMetadataNext(fooManifest.name, null, {\n            retry: { limit: 0 },\n            timeout: {\n              lookup: 100,\n              connect: 50,\n              secureConnect: 50,\n              socket: 500,\n              // send: 10000,\n              response: 1000,\n            },\n          })\n        ).rejects.toThrow('ETIMEDOUT');\n      }, 10000);","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should handle one proxy fails","suites":["storage","syncUplinksMetadataNext()","error handling"],"updatePoint":{"line":899,"column":41},"line":899,"code":"      test('should handle one proxy fails', async () => {\n        const fooManifest = generatePackageMetadata('foo', '8.0.0');\n        nock('https://registry.verdaccio.org').get('/foo').replyWithError('service in holidays');\n        const config = new Config(\n          configExample(\n            {\n              storage: generateRandomStorage(),\n            },\n            './fixtures/config/syncSingleUplinksMetadata.yaml',\n            __dirname\n          )\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.syncUplinksMetadataNext(fooManifest.name, null, {\n            retry: { limit: 0 },\n          })\n        ).rejects.toThrow(API_ERROR.NO_PACKAGE);\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should handle one proxy reply 304","suites":["storage","syncUplinksMetadataNext()","error handling"],"updatePoint":{"line":920,"column":45},"line":920,"code":"      test('should handle one proxy reply 304', async () => {\n        const fooManifest = generatePackageMetadata('foo-no-data', '8.0.0');\n        nock('https://registry.verdaccio.org').get('/foo-no-data').reply(304);\n        const config = new Config(\n          configExample(\n            {\n              storage: generateRandomStorage(),\n            },\n            './fixtures/config/syncSingleUplinksMetadata.yaml',\n            __dirname\n          )\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n        const [manifest] = await storage.syncUplinksMetadataNext(fooManifest.name, fooManifest, {\n          retry: 0,\n        });\n        expect(manifest).toBe(fooManifest);\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should handle one proxy success","suites":["storage","syncUplinksMetadataNext()","success scenarios"],"updatePoint":{"line":942,"column":43},"line":942,"code":"      test('should handle one proxy success', async () => {\n        const fooManifest = generateLocalPackageMetadata('foo', '8.0.0');\n        nock('https://registry.verdaccio.org').get('/foo').reply(201, manifestFooRemoteNpmjs);\n        const config = new Config(\n          configExample(\n            {\n              storage: generateRandomStorage(),\n            },\n            './fixtures/config/syncSingleUplinksMetadata.yaml',\n            __dirname\n          )\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n\n        const [response] = await storage.syncUplinksMetadataNext(fooManifest.name, fooManifest);\n        expect(response).not.toBeNull();\n        expect((response as Manifest).name).toEqual(fooManifest.name);\n        expect(Object.keys((response as Manifest).versions)).toEqual([\n          '8.0.0',\n          '1.0.0',\n          '0.0.3',\n          '0.0.4',\n          '0.0.5',\n          '0.0.6',\n          '0.0.7',\n        ]);\n        expect(Object.keys((response as Manifest).time)).toEqual([\n          'modified',\n          'created',\n          '8.0.0',\n          '1.0.0',\n          '0.0.3',\n          '0.0.4',\n          '0.0.5',\n          '0.0.6',\n          '0.0.7',\n        ]);\n        expect((response as Manifest)[DIST_TAGS].latest).toEqual('8.0.0');\n        expect((response as Manifest).time['8.0.0']).toBeDefined();\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should handle one proxy success with no local cache manifest","suites":["storage","syncUplinksMetadataNext()","success scenarios"],"updatePoint":{"line":984,"column":72},"line":984,"code":"      test('should handle one proxy success with no local cache manifest', async () => {\n        nock('https://registry.verdaccio.org').get('/foo').reply(201, manifestFooRemoteNpmjs);\n        const config = new Config(\n          configExample(\n            {\n              storage: generateRandomStorage(),\n            },\n            './fixtures/config/syncSingleUplinksMetadata.yaml',\n            __dirname\n          )\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n\n        const [response] = await storage.syncUplinksMetadataNext(fooManifest.name, null);\n        // the latest from the remote manifest\n        expect(response).not.toBeNull();\n        expect((response as Manifest).name).toEqual(fooManifest.name);\n        expect((response as Manifest)[DIST_TAGS].latest).toEqual('0.0.7');\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should handle no proxy found with local cache manifest","suites":["storage","syncUplinksMetadataNext()","success scenarios"],"updatePoint":{"line":1005,"column":66},"line":1005,"code":"      test('should handle no proxy found with local cache manifest', async () => {\n        const fooManifest = generatePackageMetadata('foo', '8.0.0');\n        nock('https://registry.verdaccio.org').get('/foo').reply(201, manifestFooRemoteNpmjs);\n        const config = new Config(\n          configExample(\n            {\n              storage: generateRandomStorage(),\n            },\n            './fixtures/config/syncNoUplinksMetadata.yaml',\n            __dirname\n          )\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n\n        const [response] = await storage.syncUplinksMetadataNext(fooManifest.name, fooManifest);\n        expect(response).not.toBeNull();\n        expect((response as Manifest).name).toEqual(fooManifest.name);\n        expect((response as Manifest)[DIST_TAGS].latest).toEqual('8.0.0');\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should handle double proxy with last one success","suites":["storage","syncUplinksMetadataNext()","success scenarios"],"line":1025,"code":"      test.todo('should handle double proxy with last one success');","file":"storage.spec.ts","skipped":true,"dir":"packages/store/test"},{"name":"should handle disable uplinks via options.uplinksLook=false with cache","suites":["storage","syncUplinksMetadataNext()","options"],"updatePoint":{"line":1029,"column":82},"line":1029,"code":"      test('should handle disable uplinks via options.uplinksLook=false with cache', async () => {\n        const fooManifest = generatePackageMetadata('foo', '8.0.0');\n        nock('https://registry.verdaccio.org').get('/foo').reply(201, manifestFooRemoteNpmjs);\n        const config = new Config(\n          configExample(\n            {\n              storage: generateRandomStorage(),\n            },\n            './fixtures/config/syncSingleUplinksMetadata.yaml',\n            __dirname\n          )\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n\n        const [response] = await storage.syncUplinksMetadataNext(fooManifest.name, fooManifest, {\n          uplinksLook: false,\n        });\n\n        expect((response as Manifest).name).toEqual(fooManifest.name);\n        expect((response as Manifest)[DIST_TAGS].latest).toEqual('8.0.0');\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should handle disable uplinks via options.uplinksLook=false without cache","suites":["storage","syncUplinksMetadataNext()","options"],"updatePoint":{"line":1052,"column":85},"line":1052,"code":"      test('should handle disable uplinks via options.uplinksLook=false without cache', async () => {\n        const fooRemoteManifest = generateRemotePackageMetadata(\n          'foo',\n          '9.0.0',\n          'https://registry.verdaccio.org',\n          ['9.0.0', '9.0.1', '9.0.2', '9.0.3']\n        );\n        nock('https://registry.verdaccio.org').get('/foo').reply(201, fooRemoteManifest);\n        const config = new Config(\n          configExample(\n            {\n              ...getDefaultConfig(),\n              storage: generateRandomStorage(),\n            },\n            './fixtures/config/syncSingleUplinksMetadata.yaml',\n            __dirname\n          )\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n\n        const [response] = await storage.syncUplinksMetadataNext('foo', null, {\n          uplinksLook: true,\n        });\n\n        expect((response as Manifest).name).toEqual('foo');\n        expect((response as Manifest)[DIST_TAGS].latest).toEqual('9.0.0');\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should return 0 local packages","suites":["storage","getLocalDatabase"],"updatePoint":{"line":1084,"column":40},"line":1084,"code":"    test('should return 0 local packages', async () => {\n      const config = new Config(\n        configExample({\n          ...getDefaultConfig(),\n          storage: generateRandomStorage(),\n        })\n      );\n      const storage = new Storage(config);\n      await storage.init(config);\n      await expect(storage.getLocalDatabase()).resolves.toHaveLength(0);\n    });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should return 1 local packages","suites":["storage","getLocalDatabase"],"updatePoint":{"line":1096,"column":40},"line":1096,"code":"    test('should return 1 local packages', async () => {\n      const config = new Config(\n        configExample({\n          ...getDefaultConfig(),\n          storage: generateRandomStorage(),\n        })\n      );\n      const req = httpMocks.createRequest({\n        method: 'GET',\n        connection: { remoteAddress: fakeHost },\n        headers: {\n          host: 'host',\n        },\n        url: '/',\n      });\n      const storage = new Storage(config);\n      await storage.init(config);\n      const manifest = generatePackageMetadata('foo');\n      const ac = new AbortController();\n      await storage.updateManifest(manifest, {\n        signal: ac.signal,\n        name: 'foo',\n        uplinksLook: false,\n        requestOptions: {\n          headers: req.headers as any,\n          protocol: req.protocol,\n          host: req.get('host') as string,\n        },\n      });\n      const response = await storage.getLocalDatabase();\n      expect(response).toHaveLength(1);\n      expect(response[0]).toEqual(expect.objectContaining({ name: 'foo', version: '1.0.0' }));\n    });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should retrieve tokens created","suites":["storage","tokens","saveToken"],"updatePoint":{"line":1133,"column":42},"line":1133,"code":"      test('should retrieve tokens created', async () => {\n        const config = new Config(\n          configExample({\n            ...getDefaultConfig(),\n            storage: generateRandomStorage(),\n          })\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n        await storage.saveToken({\n          user: 'foo',\n          token: 'secret',\n          key: 'key',\n          created: 'created',\n          readonly: true,\n        });\n        const tokens = await storage.readTokens({ user: 'foo' });\n        expect(tokens).toEqual([\n          { user: 'foo', token: 'secret', key: 'key', readonly: true, created: 'created' },\n        ]);\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should delete a token created","suites":["storage","tokens","saveToken"],"updatePoint":{"line":1155,"column":41},"line":1155,"code":"      test('should delete a token created', async () => {\n        const config = new Config(\n          configExample({\n            ...getDefaultConfig(),\n            storage: generateRandomStorage(),\n          })\n        );\n        const storage = new Storage(config);\n        await storage.init(config);\n        await storage.saveToken({\n          user: 'foo',\n          token: 'secret',\n          key: 'key',\n          created: 'created',\n          readonly: true,\n        });\n        const tokens = await storage.readTokens({ user: 'foo' });\n        expect(tokens).toHaveLength(1);\n        await storage.deleteToken('foo', 'key');\n        const tokens2 = await storage.readTokens({ user: 'foo' });\n        expect(tokens2).toHaveLength(0);\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fail on remove tarball of package does not exist","suites":["storage","removeTarball"],"updatePoint":{"line":1181,"column":65},"line":1181,"code":"    test('should fail on remove tarball of package does not exist', async () => {\n      const config = new Config(\n        configExample({\n          ...getDefaultConfig(),\n          storage: generateRandomStorage(),\n        })\n      );\n      const storage = new Storage(config);\n      await storage.init(config);\n      await expect(storage.removeTarball('foo', 'foo-1.0.0.tgz', 'rev')).rejects.toThrow(\n        API_ERROR.NO_PACKAGE\n      );\n    });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should remove entirely a package","suites":["storage","removePackage"],"updatePoint":{"line":1197,"column":42},"line":1197,"code":"    test('should remove entirely a package', async () => {\n      const config = new Config(\n        configExample({\n          ...getDefaultConfig(),\n          storage: generateRandomStorage(),\n        })\n      );\n      const req = httpMocks.createRequest({\n        method: 'GET',\n        connection: { remoteAddress: fakeHost },\n        headers: {\n          host: fakeHost,\n          [HEADERS.FORWARDED_PROTO]: 'http',\n        },\n        url: '/',\n      });\n      const storage = new Storage(config);\n      await storage.init(config);\n\n      const manifest = generatePackageMetadata('foo');\n      const ac = new AbortController();\n      // 1. publish a package\n      await storage.updateManifest(manifest, {\n        signal: ac.signal,\n        name: 'foo',\n        uplinksLook: false,\n        requestOptions: {\n          headers: req.headers as any,\n          protocol: req.protocol,\n          host: req.get('host') as string,\n        },\n      });\n      // 2. request package (should be available in the local cache)\n      const manifest1 = (await storage.getPackageByOptions({\n        name: 'foo',\n        uplinksLook: false,\n        requestOptions: {\n          headers: req.headers as any,\n          protocol: req.protocol,\n          host: req.get('host') as string,\n        },\n      })) as Manifest;\n      const _rev = manifest1._rev;\n      // 3. remove the tarball\n      await expect(\n        storage.removeTarball(manifest1.name, 'foo-1.0.0.tgz', _rev)\n      ).resolves.toBeDefined();\n      // 4. remove the package\n      await storage.removePackage(manifest1.name, _rev);\n      // 5. fails if package does not exist anymore in storage\n      await expect(\n        storage.getPackageByOptions({\n          name: 'foo',\n          uplinksLook: false,\n          requestOptions: {\n            headers: req.headers as any,\n            protocol: req.protocol,\n            host: req.get('host') as string,\n          },\n        })\n      ).rejects.toThrowError('package does not exist on uplink: foo');\n    });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get 201 and merge from uplink","suites":["storage","getPackageByOptions()","with uplinks"],"updatePoint":{"line":1263,"column":48},"line":1263,"code":"      test('should get 201 and merge from uplink', async () => {\n        nock(domain).get('/foo').reply(201, fooManifest);\n        const config = new Config(\n          configExample({\n            ...getDefaultConfig(),\n            storage: generateRandomStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo',\n            uplinksLook: true,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host') as string,\n            },\n          })\n        ).resolves.toEqual(expect.objectContaining({ name: 'foo' }));\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get 201 and merge from uplink with version","suites":["storage","getPackageByOptions()","with uplinks"],"updatePoint":{"line":1295,"column":61},"line":1295,"code":"      test('should get 201 and merge from uplink with version', async () => {\n        nock(domain).get('/foo').reply(201, fooManifest);\n        const config = new Config(\n          configExample({\n            ...getDefaultConfig(),\n            storage: generateRandomStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo',\n            version: '1.0.0',\n            uplinksLook: true,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host') as string,\n            },\n          })\n        ).resolves.toEqual(expect.objectContaining({ name: 'foo' }));\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get 201 and merge from uplink with dist-tag","suites":["storage","getPackageByOptions()","with uplinks"],"updatePoint":{"line":1328,"column":62},"line":1328,"code":"      test('should get 201 and merge from uplink with dist-tag', async () => {\n        nock(domain).get('/foo').reply(201, fooManifest);\n        const config = new Config(\n          configExample({\n            ...getDefaultConfig(),\n            storage: generateRandomStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo',\n            version: 'latest',\n            uplinksLook: true,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host') as string,\n            },\n          })\n        ).resolves.toEqual(expect.objectContaining({ name: 'foo' }));\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get 404 for version does not exist","suites":["storage","getPackageByOptions()","with uplinks"],"updatePoint":{"line":1361,"column":53},"line":1361,"code":"      test('should get 404 for version does not exist', async () => {\n        nock(domain).get('/foo').reply(201, fooManifest);\n        const config = new Config(\n          configExample({\n            ...getDefaultConfig(),\n            storage: generateRandomStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo',\n            version: '1.0.0-does-not-exist',\n            uplinksLook: true,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host') as string,\n            },\n          })\n        ).rejects.toThrow(\n          errorUtils.getNotFound(\"this version doesn't exist: 1.0.0-does-not-exist\")\n        );\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get 404","suites":["storage","getPackageByOptions()","with uplinks"],"updatePoint":{"line":1396,"column":26},"line":1396,"code":"      test('should get 404', async () => {\n        nock(domain).get('/foo2').reply(404);\n        const config = new Config(\n          configExample({\n            ...getDefaultConfig(),\n            uplinks: {\n              npmjs: {\n                url: domain,\n              },\n            },\n            storage: generateRandomStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo2',\n            uplinksLook: true,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host') as string,\n            },\n          })\n        ).rejects.toThrow(errorUtils.getNotFound());\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get ETIMEDOUT with uplink","suites":["storage","getPackageByOptions()","with uplinks"],"updatePoint":{"line":1433,"column":44},"line":1433,"code":"      test('should get ETIMEDOUT with uplink', async () => {\n        nock(domain).get('/foo2').replyWithError({\n          code: 'ETIMEDOUT',\n          errno: 'ETIMEDOUT',\n        });\n        const config = new Config(\n          configExample({\n            ...getDefaultConfig(),\n            uplinks: {\n              npmjs: {\n                url: domain,\n              },\n            },\n            storage: generateRandomStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo2',\n            uplinksLook: true,\n            retry: { limit: 0 },\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host') as string,\n            },\n          })\n        ).rejects.toThrow(errorUtils.getServiceUnavailable('ETIMEDOUT'));\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fetch abbreviated version of manifest ","suites":["storage","getPackageByOptions()","with uplinks"],"updatePoint":{"line":1474,"column":57},"line":1474,"code":"      test('should fetch abbreviated version of manifest ', async () => {\n        const fooManifest = generateLocalPackageMetadata('foo', '1.0.0');\n        nock(domain).get('/foo').reply(201, fooManifest);\n        const config = new Config(\n          configExample({\n            ...getDefaultConfig(),\n            storage: generateRandomStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n\n        const manifest = (await storage.getPackageByOptions({\n          name: 'foo',\n          uplinksLook: true,\n          requestOptions: {\n            headers: req.headers as any,\n            protocol: req.protocol,\n            host: req.get('host') as string,\n          },\n          abbreviated: true,\n        })) as AbbreviatedManifest;\n        const { versions, name } = manifest;\n        expect(name).toEqual('foo');\n        expect(Object.keys(versions)).toEqual(['1.0.0']);\n        expect(manifest[DIST_TAGS]).toEqual({ latest: '1.0.0' });\n        const version = versions['1.0.0'];\n        expect(Object.keys(version)).toEqual([\n          'name',\n          'version',\n          'description',\n          'deprecated',\n          'bin',\n          'dist',\n          'engines',\n          'funding',\n          'directories',\n          'dependencies',\n          'devDependencies',\n          'peerDependencies',\n          'optionalDependencies',\n          'bundleDependencies',\n          '_hasShrinkwrap',\n          'hasInstallScript',\n        ]);\n        expect(manifest.modified).toBeDefined();\n        // special case for pnpm/rfcs/pull/2\n        expect(manifest.time).toBeDefined();\n        // fields must not have\n        // @ts-expect-error\n        expect(manifest.readme).not.toBeDefined();\n        // @ts-expect-error\n        expect(manifest._attachments).not.toBeDefined();\n        // @ts-expect-error\n        expect(manifest._rev).not.toBeDefined();\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get the right version","suites":["versions-utils","getVersion"],"updatePoint":{"line":20,"column":38},"line":20,"code":"    test('should get the right version', () => {\n      expect(getVersion({ ...metadata } as any, '1.0.0')).toEqual({ dist: dist('1.0.0') });\n      expect(getVersion({ ...metadata } as any, 'v1.0.0')).toEqual({ dist: dist('1.0.0') });\n      expect(getVersion({ ...metadata } as any, 'v0.2.1-1')).toEqual({ dist: dist('0.2.1-1') });\n      expect(getVersion({ ...metadata } as any, '0.2.1-alpha')).toEqual({\n        dist: dist('0.2.1-alpha'),\n      });\n      expect(getVersion({ ...metadata } as any, '0.2.1-alpha.0')).toEqual({\n        dist: dist('0.2.1-alpha.0'),\n      });\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should return nothing on get non existing version","suites":["versions-utils","getVersion"],"updatePoint":{"line":32,"column":59},"line":32,"code":"    test('should return nothing on get non existing version', () => {\n      expect(getVersion({ ...metadata } as any, '0')).toBeUndefined();\n      expect(getVersion({ ...metadata } as any, '2.0.0')).toBeUndefined();\n      expect(getVersion({ ...metadata } as any, 'v2.0.0')).toBeUndefined();\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should return nothing on get invalid versions","suites":["versions-utils","getVersion"],"updatePoint":{"line":38,"column":55},"line":38,"code":"    test('should return nothing on get invalid versions', () => {\n      expect(getVersion({ ...metadata } as any, undefined)).toBeUndefined();\n      expect(getVersion({ ...metadata } as any, null)).toBeUndefined();\n      expect(getVersion({ ...metadata } as any, 8)).toBeUndefined();\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should handle no versions","suites":["versions-utils","getVersion"],"updatePoint":{"line":44,"column":35},"line":44,"code":"    test('should handle no versions', () => {\n      expect(getVersion(undefined, undefined)).toBeUndefined();\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should sort versions","suites":["versions-utils","sortVersionsAndFilterInvalid"],"updatePoint":{"line":50,"column":30},"line":50,"code":"    test('should sort versions', () => {\n      expect(sortVersionsAndFilterInvalid(['1.0.0', '5.0.0', '2.0.0'])).toEqual([\n        '1.0.0',\n        '2.0.0',\n        '5.0.0',\n      ]);\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should sort versions and filter out invalid","suites":["versions-utils","sortVersionsAndFilterInvalid"],"updatePoint":{"line":57,"column":53},"line":57,"code":"    test('should sort versions and filter out invalid', () => {\n      expect(sortVersionsAndFilterInvalid(['1.0.0', '5.0.0', '2.0.0', '', null])).toEqual([\n        '1.0.0',\n        '2.0.0',\n        '5.0.0',\n      ]);\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"add new one","suites":["versions-utils","tagVersion"],"updatePoint":{"line":67,"column":21},"line":67,"code":"    test('add new one', () => {\n      let pkg = {\n        versions: {},\n        'dist-tags': {},\n      };\n\n      // @ts-ignore\n      assert(tagVersion(pkg, '1.1.1', 'foo', {}));\n      assert.deepEqual(pkg, {\n        versions: {},\n        'dist-tags': { foo: '1.1.1' },\n      });\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"add (compat)","suites":["versions-utils","tagVersion"],"updatePoint":{"line":81,"column":22},"line":81,"code":"    test('add (compat)', () => {\n      const x = {\n        versions: {},\n        'dist-tags': { foo: '1.1.0' },\n      };\n\n      // @ts-ignore\n      assert(tagVersion(x, '1.1.1', 'foo'));\n      assert.deepEqual(x, {\n        versions: {},\n        'dist-tags': { foo: '1.1.1' },\n      });\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"add fresh tag","suites":["versions-utils","tagVersion"],"updatePoint":{"line":95,"column":23},"line":95,"code":"    test('add fresh tag', () => {\n      let x = {\n        versions: {},\n        'dist-tags': { foo: '1.1.0' },\n      };\n\n      // @ts-ignore\n      assert(tagVersion(x, '1.1.1', 'foo'));\n      assert.deepEqual(x, {\n        versions: {},\n        'dist-tags': { foo: '1.1.1' },\n      });\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should generate session token","suites":["Auth Utilities","createSessionToken"],"updatePoint":{"line":5,"column":39},"line":5,"code":"    test('should generate session token', () => {\n      expect(createSessionToken()).toHaveProperty('expires');\n      expect(createSessionToken().expires).toBeInstanceOf(Date);\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should generate user message token","suites":["Auth Utilities","getAuthenticatedMessage"],"updatePoint":{"line":12,"column":44},"line":12,"code":"    test('should generate user message token', () => {\n      expect(getAuthenticatedMessage('foo')).toEqual(\"you are authenticated as 'foo'\");\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should test basic config","suites":["getMatchedPackagesSpec"],"updatePoint":{"line":4,"column":32},"line":4,"code":"  test('should test basic config', () => {\n    const packages = {\n      react: {\n        access: 'admin',\n        publish: 'admin',\n        proxy: 'facebook',\n      },\n      angular: {\n        access: 'admin',\n        publish: 'admin',\n        proxy: 'google',\n      },\n      '@*/*': {\n        access: '$all',\n        publish: '$authenticated',\n        proxy: 'npmjs',\n      },\n      '**': {\n        access: '$all',\n        publish: '$authenticated',\n        proxy: 'npmjs',\n      },\n    };\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('react', packages).proxy).toMatch('facebook');\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('angular', packages).proxy).toMatch('google');\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('vue', packages).proxy).toMatch('npmjs');\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('@scope/vue', packages).proxy).toMatch('npmjs');\n  });","file":"matcher.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should test no ** wildcard on config","suites":["getMatchedPackagesSpec"],"updatePoint":{"line":37,"column":44},"line":37,"code":"  test('should test no ** wildcard on config', () => {\n    const packages = {\n      react: {\n        access: 'admin',\n        publish: 'admin',\n        proxy: 'facebook',\n      },\n      angular: {\n        access: 'admin',\n        publish: 'admin',\n        proxy: 'google',\n      },\n      '@fake/*': {\n        access: '$all',\n        publish: '$authenticated',\n        proxy: 'npmjs',\n      },\n    };\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('react', packages).proxy).toMatch('facebook');\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('angular', packages).proxy).toMatch('google');\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('@fake/angular', packages).proxy).toMatch('npmjs');\n    expect(getMatchedPackagesSpec('vue', packages)).toBeUndefined();\n    expect(getMatchedPackagesSpec('@scope/vue', packages)).toBeUndefined();\n  });","file":"matcher.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should get the right version","suites":["Utilities","getVersionFromTarball"],"updatePoint":{"line":5,"column":38},"line":5,"code":"    test('should get the right version', () => {\n      const simpleName = 'test-name-4.2.12.tgz';\n      const complexName = 'test-5.6.4-beta.2.tgz';\n      const otherComplexName = 'test-3.5.0-6.tgz';\n      expect(getVersionFromTarball(simpleName)).toEqual('4.2.12');\n      expect(getVersionFromTarball(complexName)).toEqual('5.6.4-beta.2');\n      expect(getVersionFromTarball(otherComplexName)).toEqual('3.5.0-6');\n    });","file":"middleware-utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should don'n fall at incorrect tarball name","suites":["Utilities","getVersionFromTarball"],"updatePoint":{"line":14,"column":53},"line":14,"code":"    test(\"should don'n fall at incorrect tarball name\", () => {\n      expect(getVersionFromTarball('incorrectName')).toBeUndefined();\n    });","file":"middleware-utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should check author field different values","suites":["Utilities","formatAuthor"],"updatePoint":{"line":12,"column":52},"line":12,"code":"    test('should check author field different values', () => {\n      const author = 'verdaccioNpm';\n      expect(formatAuthor(author).name).toEqual(author);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should check author field for object value","suites":["Utilities","formatAuthor"],"updatePoint":{"line":16,"column":52},"line":16,"code":"    test('should check author field for object value', () => {\n      const user = {\n        name: 'Verdaccion NPM',\n        email: 'verdaccio@verdaccio.org',\n        url: 'https://verdaccio.org',\n      };\n      expect(formatAuthor(user).url).toEqual(user.url);\n      expect(formatAuthor(user).email).toEqual(user.email);\n      expect(formatAuthor(user).name).toEqual(user.name);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should check author field for other value","suites":["Utilities","formatAuthor"],"updatePoint":{"line":26,"column":51},"line":26,"code":"    test('should check author field for other value', () => {\n      expect(formatAuthor(null).name).toEqual(DEFAULT_USER);\n      // @ts-expected-error\n      expect(formatAuthor({}).name).toEqual(DEFAULT_USER);\n      // @ts-expected-error\n      expect(formatAuthor([]).name).toEqual(DEFAULT_USER);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should generate gravatar url with email","suites":["Utilities","User utilities"],"updatePoint":{"line":36,"column":49},"line":36,"code":"    test('should generate gravatar url with email', () => {\n      const gravatarUrl: string = generateGravatarUrl('user@verdaccio.org');\n\n      expect(gravatarUrl).toMatch('https://www.gravatar.com/avatar/');\n      expect(gravatarUrl).not.toMatch('000000000');\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should generate generic gravatar url","suites":["Utilities","User utilities"],"updatePoint":{"line":43,"column":46},"line":43,"code":"    test('should generate generic gravatar url', () => {\n      const gravatarUrl: string = generateGravatarUrl();\n\n      expect(gravatarUrl).toMatch(GENERIC_AVATAR);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"check for blank object","suites":["Utilities","addGravatarSupport"],"updatePoint":{"line":51,"column":32},"line":51,"code":"    test('check for blank object', () => {\n      // @ts-ignore\n      expect(addGravatarSupport({})).toEqual({});\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"author, contributors and maintainers fields are not present","suites":["Utilities","addGravatarSupport"],"updatePoint":{"line":56,"column":69},"line":56,"code":"    test('author, contributors and maintainers fields are not present', () => {\n      const packageInfo = {\n        latest: {},\n      };\n\n      // @ts-ignore\n      expect(addGravatarSupport(packageInfo)).toEqual(packageInfo);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"author field is a blank object","suites":["Utilities","addGravatarSupport"],"updatePoint":{"line":65,"column":40},"line":65,"code":"    test('author field is a blank object', () => {\n      const packageInfo = { latest: { author: {} } };\n\n      // @ts-ignore\n      expect(addGravatarSupport(packageInfo)).toEqual(packageInfo);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"author field is a string type","suites":["Utilities","addGravatarSupport"],"updatePoint":{"line":72,"column":39},"line":72,"code":"    test('author field is a string type', () => {\n      const packageInfo = {\n        latest: { author: 'user@verdccio.org' },\n      };\n      const result = {\n        latest: {\n          author: {\n            author: 'user@verdccio.org',\n            avatar: GENERIC_AVATAR,\n            email: '',\n          },\n        },\n      };\n\n      // @ts-ignore\n      expect(addGravatarSupport(packageInfo)).toEqual(result);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"author field is an object type with author information","suites":["Utilities","addGravatarSupport"],"updatePoint":{"line":90,"column":64},"line":90,"code":"    test('author field is an object type with author information', () => {\n      const packageInfo = {\n        latest: { author: { name: 'verdaccio', email: 'user@verdccio.org' } },\n      };\n      const result = {\n        latest: {\n          author: {\n            avatar: 'https://www.gravatar.com/avatar/794d7f6ef93d0689437de3c3e48fadc7',\n            email: 'user@verdccio.org',\n            name: 'verdaccio',\n          },\n        },\n      };\n\n      // @ts-ignore\n      expect(addGravatarSupport(packageInfo)).toEqual(result);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"contributor field is a blank array","suites":["Utilities","addGravatarSupport"],"updatePoint":{"line":108,"column":44},"line":108,"code":"    test('contributor field is a blank array', () => {\n      const packageInfo = {\n        latest: {\n          contributors: [],\n        },\n      };\n\n      // @ts-ignore\n      expect(addGravatarSupport(packageInfo)).toEqual(packageInfo);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"contributors field has contributors","suites":["Utilities","addGravatarSupport","contributors"],"updatePoint":{"line":120,"column":47},"line":120,"code":"      test('contributors field has contributors', () => {\n        const packageInfo = {\n          latest: {\n            contributors: [\n              { name: 'user', email: 'user@verdccio.org' },\n              { name: 'user1', email: 'user1@verdccio.org' },\n            ],\n          },\n        };\n\n        const result = {\n          latest: {\n            contributors: [\n              {\n                avatar: 'https://www.gravatar.com/avatar/794d7f6ef93d0689437de3c3e48fadc7',\n                email: 'user@verdccio.org',\n                name: 'user',\n              },\n              {\n                avatar: 'https://www.gravatar.com/avatar/51105a49ce4a9c2bfabf0f6a2cba3762',\n                email: 'user1@verdccio.org',\n                name: 'user1',\n              },\n            ],\n          },\n        };\n\n        // @ts-ignore\n        expect(addGravatarSupport(packageInfo)).toEqual(result);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"contributors field is an object","suites":["Utilities","addGravatarSupport","contributors"],"updatePoint":{"line":151,"column":43},"line":151,"code":"      test('contributors field is an object', () => {\n        const packageInfo = {\n          latest: {\n            contributors: { name: 'user', email: 'user@verdccio.org' },\n          },\n        };\n\n        const result = {\n          latest: {\n            contributors: [\n              {\n                avatar: 'https://www.gravatar.com/avatar/794d7f6ef93d0689437de3c3e48fadc7',\n                email: 'user@verdccio.org',\n                name: 'user',\n              },\n            ],\n          },\n        };\n\n        // @ts-ignore\n        expect(addGravatarSupport(packageInfo)).toEqual(result);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"contributors field is a string","suites":["Utilities","addGravatarSupport","contributors"],"updatePoint":{"line":174,"column":42},"line":174,"code":"      test('contributors field is a string', () => {\n        const contributor = 'Barney Rubble <b@rubble.com> (http://barnyrubble.tumblr.com/)';\n        const packageInfo = {\n          latest: {\n            contributors: contributor,\n          },\n        };\n\n        const result = {\n          latest: {\n            contributors: [\n              {\n                avatar: GENERIC_AVATAR,\n                email: contributor,\n                name: contributor,\n              },\n            ],\n          },\n        };\n\n        // @ts-ignore\n        expect(addGravatarSupport(packageInfo)).toEqual(result);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"maintainers field is a blank array","suites":["Utilities","addGravatarSupport","contributors"],"updatePoint":{"line":199,"column":44},"line":199,"code":"    test('maintainers field is a blank array', () => {\n      const packageInfo = {\n        latest: {\n          maintainers: [],\n        },\n      };\n\n      // @ts-ignore\n      expect(addGravatarSupport(packageInfo)).toEqual(packageInfo);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"maintainers field has maintainers","suites":["Utilities","addGravatarSupport","contributors"],"updatePoint":{"line":210,"column":43},"line":210,"code":"    test('maintainers field has maintainers', () => {\n      const packageInfo = {\n        latest: {\n          maintainers: [\n            { name: 'user', email: 'user@verdccio.org' },\n            { name: 'user1', email: 'user1@verdccio.org' },\n          ],\n        },\n      };\n\n      const result = {\n        latest: {\n          maintainers: [\n            {\n              avatar: 'https://www.gravatar.com/avatar/794d7f6ef93d0689437de3c3e48fadc7',\n              email: 'user@verdccio.org',\n              name: 'user',\n            },\n            {\n              avatar: 'https://www.gravatar.com/avatar/51105a49ce4a9c2bfabf0f6a2cba3762',\n              email: 'user1@verdccio.org',\n              name: 'user1',\n            },\n          ],\n        },\n      };\n\n      // @ts-ignore\n      expect(addGravatarSupport(packageInfo)).toEqual(result);\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"ping","suites":["basic test endpoints","server health"],"updatePoint":{"line":32,"column":14,"index":1048},"line":32,"code":"    test('ping', async () => {\n      const server = new ServerQuery(registry.getRegistryUrl());\n      await server.ping();\n    });","file":"basic.spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"shoud unpublish the whole package of many published","suites":["basic test endpoints","unpublish package"],"updatePoint":{"line":38,"column":61,"index":1272},"line":38,"code":"    test('shoud unpublish the whole package of many published', async function () {\n      const server = new ServerQuery(registry.getRegistryUrl());\n      await server.addPackage('unpublish-new-package', '1.0.0');\n      await server.addPackage('unpublish-new-package', '1.0.1', API_MESSAGE.PKG_CHANGED);\n      await server.addPackage('unpublish-new-package', '1.0.2', API_MESSAGE.PKG_CHANGED);\n      (await server.getPackage('unpublish-new-package')).status(HTTP_STATUS.OK);\n      (await server.removePackage('unpublish-new-package', '_rev')).status(HTTP_STATUS.CREATED);\n      (await server.getPackage('unpublish-new-package')).status(HTTP_STATUS.NOT_FOUND);\n      // FIXME: throws 500 instead 404\n      // (await server.getTarball('unpublish-new-package', 'unpublish-new-package-1.0.0.tgz')).status(\n      //   HTTP_STATUS.NOT_FOUND\n      // );\n    });","file":"basic.spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"should find html on root","suites":["html"],"updatePoint":{"line":32,"column":32,"index":1002},"line":32,"code":"  test('should find html on root', async () => {\n    const data = await got.get(`http://localhost:${registry.getPort()}`, {}).text();\n    expect(data).toContain('<title>Verdaccio</title>');\n  });","file":"html.spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"should publish multiple packages","suites":["race publishing packages"],"updatePoint":{"line":31,"column":40,"index":1032},"line":31,"code":"  test('should publish multiple packages', async () => {\n    const server = new ServerQuery(registry.getRegistryUrl());\n    const times = 100;\n    let success = 0;\n    for (const time of Array.from(Array(times).keys())) {\n      try {\n        let message = success === 0 ? API_MESSAGE.PKG_CREATED : API_MESSAGE.PKG_CHANGED;\n        await server.addPackage('race-pkg', `1.0.${time}`, message);\n        success++;\n      } catch (error) {\n        console.error('this should not trigger', error);\n      }\n    }\n    expect(success).toBe(times);\n  }, 40000);","file":"massive.spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"should fetch package through a proxy","suites":["multiple proxy registries configuration"],"updatePoint":{"line":113,"column":44,"index":3959},"line":113,"code":"  test('should fetch package through a proxy', async function () {\n    const server = new ServerQuery(registry.getRegistryUrl());\n    const server2 = new ServerQuery(registry2.getRegistryUrl());\n    await server.addPackage('package-proxy');\n    (await server2.getPackage('package-proxy')).status(HTTP_STATUS.OK);\n  });","file":"proxy-multilpe-registry.spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"should fails if proxy server does not authorize with not found","suites":["multiple proxy registries configuration"],"updatePoint":{"line":119,"column":70,"index":4304},"line":119,"code":"  test('should fails if proxy server does not authorize with not found', async function () {\n    const server2 = new ServerQuery(registry2.getRegistryUrl());\n    (await server2.getPackage('jquery')).status(HTTP_STATUS.NOT_FOUND);\n  });","file":"proxy-multilpe-registry.spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"should fetch package through proxy server (test requires internet conection)","suites":["multiple proxy registries configuration"],"updatePoint":{"line":123,"column":84,"index":4554},"line":123,"code":"  test('should fetch package through proxy server (test requires internet conection)', async function () {\n    const server2 = new ServerQuery(registry2.getRegistryUrl());\n    (await server2.getPackage('react')).status(HTTP_STATUS.OK);\n  });","file":"proxy-multilpe-registry.spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"should fetch webpack from secondary option proxy registry (test requires internet conection)","suites":["multiple proxy registries configuration"],"updatePoint":{"line":127,"column":100,"index":4812},"line":127,"code":"  test('should fetch webpack from secondary option proxy registry (test requires internet conection)', async function () {\n    const server2 = new ServerQuery(registry2.getRegistryUrl());\n    (await server2.getPackage('webpack')).status(HTTP_STATUS.OK);\n  });","file":"proxy-multilpe-registry.spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"should fail fetch pnpm with not found if proxy is down","suites":["multiple proxy registries configuration"],"updatePoint":{"line":131,"column":62,"index":5034},"line":131,"code":"  test('should fail fetch pnpm with not found if proxy is down', async function () {\n    const server2 = new ServerQuery(registry2.getRegistryUrl());\n    (await server2.getPackage('pnpm')).status(HTTP_STATUS.NOT_FOUND);\n  });","file":"proxy-multilpe-registry.spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"should fail with timeout","suites":["multiple proxy registries configuration"],"line":135,"code":"  test.skip('should fail with timeout', async function () {","file":"proxy-multilpe-registry.spec.ts","skipped":true,"dir":"packages/verdaccio/test"},{"name":"should fails 9 of 10 published packages","suites":["race publishing packages"],"updatePoint":{"line":34,"column":47,"index":1119},"line":34,"code":"  test('should fails 9 of 10 published packages', async () => {\n    const server = new ServerQuery(registry.getRegistryUrl());\n    const times = 10;\n    let failures = 0;\n    let success = 0;\n\n    // eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars\n    for (const _time of Array.from(Array(times).keys())) {\n      try {\n        await server.addPackage('race-pkg', `1.0.0`);\n        success++;\n      } catch (error) {\n        failures++;\n      }\n    }\n    expect(failures).toBe(times - 1);\n    expect(success).toBe(1);\n  });","file":"race.spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"server run","suites":["server query"],"updatePoint":{"line":7,"column":18,"index":287},"line":7,"code":"  test('server run', async () => {\n    const registry = new Registry(configFile);\n    const vPath = path.join(__dirname, '../bin/verdaccio');\n    const d = await registry.init(vPath);\n    expect(d.pid).toBeDefined();\n    expect(registry.getPort()).toBeDefined();\n    expect(registry.getAuthStr()).toBeDefined();\n    expect(registry.getToken).toBeDefined();\n    registry.stop();\n  });","file":"server-query-spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"server create user","suites":["server query"],"updatePoint":{"line":17,"column":26,"index":679},"line":17,"code":"  test('server create user', async () => {\n    const registry = new Registry(configFile, {\n      createUser: true\n    });\n    const vPath = path.join(__dirname, '../bin/verdaccio');\n    const d = await registry.init(vPath);\n    expect(d.pid).toBeDefined();\n    registry.stop();\n  });","file":"server-query-spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"fetch debug ok","suites":["server query"],"updatePoint":{"line":26,"column":22,"index":959},"line":26,"code":"  test('fetch debug ok', async () => {\n    nock('https://registry.verdaccio.org').get(`/-/_debug`).reply(201, {\n      ok: 'debug'\n    });\n    expect(true).toBeTruthy();\n    const server = new ServerQuery('https://registry.verdaccio.org');\n    const query = await server.debug();\n    query.status(201).body_ok(/debug/);\n  });","file":"server-query-spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"fetch debug fail","suites":["server query"],"updatePoint":{"line":35,"column":24,"index":1286},"line":35,"code":"  test('fetch debug fail', async () => {\n    nock('https://registry.verdaccio.org').get(`/-/_debug`).reply(500, {\n      error: 'fail debug'\n    });\n    expect(true).toBeTruthy();\n    const server = new ServerQuery('https://registry.verdaccio.org');\n    const query = await server.debug();\n    query.status(500).body_error(/fail debug/);\n  });","file":"server-query-spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"fetch package ok","suites":["server query"],"updatePoint":{"line":44,"column":24,"index":1629},"line":44,"code":"  test('fetch package ok', async () => {\n    const pkgName = 'upstream';\n    const upstreamManifest = generateRemotePackageMetadata(pkgName, '1.0.0', 'https://registry.domain.org');\n    nock('https://registry.domain.org').get(`/upstream`).reply(201, upstreamManifest);\n    expect(true).toBeTruthy();\n    const server = new ServerQuery('https://registry.domain.org');\n    const query = await server.getPackage('upstream');\n    query.status(201).body_ok(upstreamManifest);\n  });","file":"server-query-spec.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"should OK to package api","suites":["test web server"],"updatePoint":{"line":20,"column":32},"line":20,"code":"  test('should OK to package api', async () => {\n    mockManifest.mockReturnValue(() => ({\n      staticPath: path.join(__dirname, 'static'),\n      manifestFiles: {\n        js: ['runtime.js', 'vendors.js', 'main.js'],\n      },\n      manifest: require('./partials/manifest/manifest.json'),\n    }));\n    const response = await supertest(await initializeServer('default-test.yaml'))\n      .get('/-/verdaccio/data/packages')\n      .set('Accept', HEADERS.JSON_CHARSET)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.OK);\n    expect(response.body).toEqual([]);\n  });","file":"api.packages.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should fetch readme scoped package","suites":["readme api"],"updatePoint":{"line":32,"column":42},"line":32,"code":"  test('should fetch readme scoped package', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, '@scope/pk1-test', '1.0.0', { readme: 'my readme scoped' });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/package/readme/@scope/pk1-test')\n      .set('Accept', HEADERS.TEXT_PLAIN)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_PLAIN_UTF8)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch('my readme scoped');\n  }, 70000);","file":"api.readme.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should fetch readme scoped package with not found message","suites":["readme api"],"updatePoint":{"line":43,"column":65},"line":43,"code":"  test('should fetch readme scoped package with not found message', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, '@scope/pk1-test', '1.0.0', { readme: null });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/package/readme/@scope/pk1-test')\n      .set('Accept', HEADERS.TEXT_PLAIN)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_PLAIN_UTF8)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch(NOT_README_FOUND);\n  });","file":"api.readme.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should fetch readme a package","suites":["readme api"],"updatePoint":{"line":54,"column":37},"line":54,"code":"  test('should fetch readme a package', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, 'pk1-test', '1.0.0', { readme: 'my readme' });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/package/readme/pk1-test')\n      .set('Accept', HEADERS.TEXT_PLAIN)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_PLAIN_UTF8)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch('my readme');\n  });","file":"api.readme.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should fetch readme a package with not found message","suites":["readme api"],"updatePoint":{"line":65,"column":60},"line":65,"code":"  test('should fetch readme a package with not found message', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, 'pk1-test', '1.0.0', { readme: null });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/package/readme/pk1-test')\n      .set('Accept', HEADERS.TEXT_PLAIN)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_PLAIN_UTF8)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch(NOT_README_FOUND);\n  });","file":"api.readme.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should find results to search api","suites":["test web server"],"updatePoint":{"line":32,"column":41},"line":32,"code":"  test('should find results to search api', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, 'foo', '1.0.0');\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/search/foo')\n      .set('Accept', HEADERS.JSON_CHARSET)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.OK);\n    expect(response.body).toHaveLength(1);\n    // FUTURE: we can improve here matching the right outcome\n  });","file":"api.search.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should found no results to search","suites":["test web server"],"updatePoint":{"line":44,"column":41},"line":44,"code":"  test('should found no results to search', async () => {\n    const response = await supertest(await initializeServer('default-test.yaml'))\n      .get('/-/verdaccio/data/search/notFound')\n      .set('Accept', HEADERS.JSON_CHARSET)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.OK);\n    expect(response.body).toHaveLength(0);\n  });","file":"api.search.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should fail search api","suites":["test web server"],"line":54,"code":"  test.skip('should fail search api', async () => {","file":"api.search.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"search abort request","suites":["test web server"],"line":63,"code":"  test.todo('search abort request');","file":"api.search.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"search allow request permissions","suites":["test web server"],"line":65,"code":"  test.todo('search allow request permissions');","file":"api.search.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"search query params, pagination etc","suites":["test web server"],"line":66,"code":"  test.todo('search query params, pagination etc');","file":"api.search.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"should display sidebar info scoped package","suites":["sidebar api"],"updatePoint":{"line":31,"column":50},"line":31,"code":"  test('should display sidebar info scoped package', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, '@scope/pk1-test', '1.0.0', { readme: 'my readme scoped' });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/sidebar/@scope/pk1-test')\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch('@scope/pk1-test');\n  });","file":"api.sidebar.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should display sidebar info package","suites":["sidebar api"],"updatePoint":{"line":41,"column":43},"line":41,"code":"  test('should display sidebar info package', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, 'pk2-test', '1.0.0', { readme: 'my readme scoped' });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/sidebar/pk2-test')\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch('pk2-test');\n  });","file":"api.sidebar.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should get 401","suites":["test web server"],"updatePoint":{"line":30,"column":22},"line":30,"code":"  test('should get 401', async () => {\n    return supertest(await initializeServer('default-test.yaml'))\n      .post('/-/verdaccio/sec/login')\n      .send(\n        JSON.stringify({\n          username: 'test',\n          password: 'password1',\n        })\n      )\n      .set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.UNAUTHORIZED)\n      .then((response) => {\n        expect(response.body.error).toEqual(API_ERROR.BAD_USERNAME_PASSWORD);\n      });\n  });","file":"api.user.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should log in","suites":["test web server"],"updatePoint":{"line":47,"column":21},"line":47,"code":"  test('should log in', async () => {\n    return supertest(await initializeServer('default-test.yaml'))\n      .post('/-/verdaccio/sec/login')\n      .send(\n        JSON.stringify({\n          username: 'test',\n          password: 'test',\n        })\n      )\n      .set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HEADERS.CACHE_CONTROL, 'no-cache, no-store')\n      .expect(HTTP_STATUS.OK)\n      .then((res) => {\n        expect(res.body.error).toBeUndefined();\n        expect(res.body.token).toBeDefined();\n        expect(res.body.token).toBeTruthy();\n        expect(res.body.username).toMatch('test');\n      });\n  });","file":"api.user.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"log in should be disabled","suites":["test web server"],"line":68,"code":"  test.skip('log in should be disabled', async () => {","file":"api.user.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"should change password","suites":["test web server"],"line":81,"code":"  test.todo('should change password');","file":"api.user.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"should not change password if flag is disabled","suites":["test web server"],"line":82,"code":"  test.todo('should not change password if flag is disabled');","file":"api.user.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"getManifestValue","suites":["manifest"],"updatePoint":{"line":6,"column":24},"line":6,"code":"  test('getManifestValue', () => {\n    expect(getManifestValue(['main.js'], manifest)).toEqual([\n      '/-/static/main.6126058572f989c948b1.js',\n    ]);\n  });","file":"manifest.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should match render set ui properties","suites":["test web server","render","output"],"updatePoint":{"line":42,"column":49},"line":42,"code":"      test('should match render set ui properties', async () => {\n        const {\n          window: { __VERDACCIO_BASENAME_UI_OPTIONS },\n        } = await render('web.yaml');\n        expect(__VERDACCIO_BASENAME_UI_OPTIONS).toEqual(\n          expect.objectContaining({\n            showInfo: true,\n            showSettings: true,\n            showThemeSwitch: true,\n            showFooter: true,\n            showSearch: true,\n            showDownloadTarball: true,\n            darkMode: false,\n            url_prefix: '/prefix',\n            basename: '/prefix/',\n            primaryColor: '#ffffff',\n            // FIXME: mock these values, avoid random\n            // base: 'http://127.0.0.1:60864/prefix/',\n            // version: '6.0.0-6-next.28',\n            logoURI: '',\n            flags: { searchRemote: true },\n            login: true,\n            pkgManagers: ['pnpm', 'yarn'],\n            title: 'verdaccio web',\n            scope: '@scope',\n            language: 'es-US',\n          })\n        );\n      });","file":"render.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should default title","suites":["test web server","render","output"],"line":72,"code":"      test.todo('should default title');","file":"render.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"should need html cache","suites":["test web server","render","output"],"line":73,"code":"      test.todo('should need html cache');","file":"render.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"should return the http status 200 for root","suites":["test web server","render","status"],"updatePoint":{"line":77,"column":54},"line":77,"code":"      test('should return the http status 200 for root', async () => {\n        return supertest(await initializeServer('default-test.yaml'))\n          .get('/')\n          .set('Accept', HEADERS.TEXT_HTML)\n          .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_HTML_UTF8)\n          .expect(HTTP_STATUS.OK);\n      });","file":"render.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should return the body for a package detail page","suites":["test web server","render","status"],"updatePoint":{"line":85,"column":60},"line":85,"code":"      test('should return the body for a package detail page', async () => {\n        return supertest(await initializeServer('default-test.yaml'))\n          .get('/-/web/section/some-package')\n          .set('Accept', HEADERS.TEXT_HTML)\n          .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_HTML_UTF8)\n          .expect(HTTP_STATUS.OK);\n      });","file":"render.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should static file not found","suites":["test web server","render","status"],"updatePoint":{"line":93,"column":40},"line":93,"code":"      test('should static file not found', async () => {\n        return supertest(await initializeServer('default-test.yaml'))\n          .get('/-/static/not-found.js')\n          .set('Accept', HEADERS.TEXT_HTML)\n          .expect(HTTP_STATUS.NOT_FOUND);\n      });","file":"render.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should static file found","suites":["test web server","render","status"],"updatePoint":{"line":100,"column":36},"line":100,"code":"      test('should static file found', async () => {\n        return supertest(await initializeServer('default-test.yaml'))\n          .get('/-/static/main.js')\n          .set('Accept', HEADERS.TEXT_HTML)\n          .expect(HTTP_STATUS.OK);\n      });","file":"render.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"custom render","suites":["template"],"updatePoint":{"line":12,"column":21},"line":12,"code":"  test('custom render', () => {\n    expect(\n      template({ options: { base: 'http://domain.com' }, manifest: exampleManifest }, manifest)\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"custom title","suites":["template"],"updatePoint":{"line":18,"column":20},"line":18,"code":"  test('custom title', () => {\n    expect(\n      template(\n        { options: { base: 'http://domain.com', title: 'foo title' }, manifest: exampleManifest },\n        manifest\n      )\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"custom title","suites":["template"],"updatePoint":{"line":27,"column":20},"line":27,"code":"  test('custom title', () => {\n    expect(\n      template(\n        { options: { base: 'http://domain.com', title: 'foo title' }, manifest: exampleManifest },\n        manifest\n      )\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"meta scripts","suites":["template"],"updatePoint":{"line":36,"column":20},"line":36,"code":"  test('meta scripts', () => {\n    expect(\n      template(\n        {\n          options: { base: 'http://domain.com' },\n          metaScripts: [`<style>.someclass{font-size:10px;}</style>`],\n          manifest: exampleManifest,\n        },\n        manifest\n      )\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"custom body after","suites":["template"],"updatePoint":{"line":49,"column":25},"line":49,"code":"  test('custom body after', () => {\n    expect(\n      template(\n        {\n          options: { base: 'http://domain.com' },\n          scriptsBodyAfter: [`<script src=\"foo\"/>`],\n          manifest: exampleManifest,\n        },\n        manifest\n      )\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"custom body before","suites":["template"],"updatePoint":{"line":62,"column":26},"line":62,"code":"  test('custom body before', () => {\n    expect(\n      template(\n        {\n          options: { base: 'http://domain.com' },\n          scriptsbodyBefore: [`<script src=\"fooBefore\"/>`, `<script src=\"barBefore\"/>`],\n          manifest: exampleManifest,\n        },\n        manifest\n      )\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"is valid","suites":["Utilities","validatePrimaryColor"],"updatePoint":{"line":5,"column":18},"line":5,"code":"    test('is valid', () => {\n      expect(validatePrimaryColor('#222222')).toEqual('#222222');\n      expect(validatePrimaryColor('#222fff')).toEqual('#222fff');\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/web/test"},{"name":"is invalid","suites":["Utilities","validatePrimaryColor"],"updatePoint":{"line":9,"column":20},"line":9,"code":"    test('is invalid', () => {\n      expect(validatePrimaryColor('fff')).toBeUndefined();\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/web/test"},{"name":"should order ascending","suites":["Utilities","Sort packages"],"updatePoint":{"line":16,"column":32},"line":16,"code":"    test('should order ascending', () => {\n      expect(sortByName(packages)).toEqual([\n        {\n          name: 'abc',\n        },\n        {\n          name: 'ghc',\n        },\n        {\n          name: 'zxy',\n        },\n      ]);\n    });","file":"web-utils.spec.ts","skipped":false,"dir":"packages/web/test"},{"name":"should order descending","suites":["Utilities","Sort packages"],"updatePoint":{"line":30,"column":33},"line":30,"code":"    test('should order descending', () => {\n      expect(sortByName(packages, false)).toEqual([\n        {\n          name: 'zxy',\n        },\n        {\n          name: 'ghc',\n        },\n        {\n          name: 'abc',\n        },\n      ]);\n    });","file":"web-utils.spec.ts","skipped":false,"dir":"packages/web/test"}]}