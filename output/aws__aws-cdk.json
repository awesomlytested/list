{"repo":"aws/aws-cdk","url":"https://github.com/aws/aws-cdk","branch":"master","configs":[{"package":"@aws-cdk-containers/ecs-service-extensions","lang":"ts","dir":"packages/@aws-cdk-containers/ecs-service-extensions/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/alexa-ask","lang":"ts","dir":"packages/@aws-cdk/alexa-ask/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/app-delivery","lang":"ts","dir":"packages/@aws-cdk/app-delivery/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/assert-internal","lang":"ts","dir":"packages/@aws-cdk/assert-internal/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/assertions","lang":"ts","dir":"packages/@aws-cdk/assertions/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/assets","lang":"ts","dir":"packages/@aws-cdk/assets/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-accessanalyzer","lang":"ts","dir":"packages/@aws-cdk/aws-accessanalyzer/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-acmpca","lang":"ts","dir":"packages/@aws-cdk/aws-acmpca/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-amazonmq","lang":"ts","dir":"packages/@aws-cdk/aws-amazonmq/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-amplify","lang":"ts","dir":"packages/@aws-cdk/aws-amplify/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-amplifyuibuilder","lang":"ts","dir":"packages/@aws-cdk/aws-amplifyuibuilder/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-apigateway","lang":"ts","dir":"packages/@aws-cdk/aws-apigateway/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-apigatewayv2-authorizers","lang":"js","dir":"packages/@aws-cdk/aws-apigatewayv2-authorizers/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-apigatewayv2-integrations","lang":"js","dir":"packages/@aws-cdk/aws-apigatewayv2-integrations/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-apigatewayv2","lang":"js","dir":"packages/@aws-cdk/aws-apigatewayv2/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-appconfig","lang":"ts","dir":"packages/@aws-cdk/aws-appconfig/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-appflow","lang":"ts","dir":"packages/@aws-cdk/aws-appflow/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-appintegrations","lang":"ts","dir":"packages/@aws-cdk/aws-appintegrations/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-applicationautoscaling","lang":"ts","dir":"packages/@aws-cdk/aws-applicationautoscaling/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-applicationinsights","lang":"ts","dir":"packages/@aws-cdk/aws-applicationinsights/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-appmesh","lang":"ts","dir":"packages/@aws-cdk/aws-appmesh/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-apprunner","lang":"ts","dir":"packages/@aws-cdk/aws-apprunner/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-appstream","lang":"ts","dir":"packages/@aws-cdk/aws-appstream/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-appsync","lang":"ts","dir":"packages/@aws-cdk/aws-appsync/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-aps","lang":"ts","dir":"packages/@aws-cdk/aws-aps/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-athena","lang":"ts","dir":"packages/@aws-cdk/aws-athena/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-auditmanager","lang":"ts","dir":"packages/@aws-cdk/aws-auditmanager/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-autoscaling-common","lang":"ts","dir":"packages/@aws-cdk/aws-autoscaling-common/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-autoscaling-hooktargets","lang":"ts","dir":"packages/@aws-cdk/aws-autoscaling-hooktargets/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-autoscaling","lang":"ts","dir":"packages/@aws-cdk/aws-autoscaling/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-autoscalingplans","lang":"ts","dir":"packages/@aws-cdk/aws-autoscalingplans/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-backup","lang":"ts","dir":"packages/@aws-cdk/aws-backup/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-batch","lang":"ts","dir":"packages/@aws-cdk/aws-batch/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-budgets","lang":"ts","dir":"packages/@aws-cdk/aws-budgets/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-cassandra","lang":"ts","dir":"packages/@aws-cdk/aws-cassandra/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ce","lang":"ts","dir":"packages/@aws-cdk/aws-ce/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/dns_validated_certificate_handler","lang":"js","dir":"packages/@aws-cdk/aws-certificatemanager/lambda-packages/dns_validated_certificate_handler/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-certificatemanager","lang":"ts","dir":"packages/@aws-cdk/aws-certificatemanager/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-chatbot","lang":"ts","dir":"packages/@aws-cdk/aws-chatbot/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-cloud9","lang":"ts","dir":"packages/@aws-cdk/aws-cloud9/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-cloudformation","lang":"ts","dir":"packages/@aws-cdk/aws-cloudformation/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-cloudfront-origins","lang":"ts","dir":"packages/@aws-cdk/aws-cloudfront-origins/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-cloudfront","lang":"ts","dir":"packages/@aws-cdk/aws-cloudfront/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-cloudtrail","lang":"ts","dir":"packages/@aws-cdk/aws-cloudtrail/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-cloudwatch-actions","lang":"ts","dir":"packages/@aws-cdk/aws-cloudwatch-actions/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-cloudwatch","lang":"ts","dir":"packages/@aws-cdk/aws-cloudwatch/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-codeartifact","lang":"ts","dir":"packages/@aws-cdk/aws-codeartifact/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-codebuild","lang":"ts","dir":"packages/@aws-cdk/aws-codebuild/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-codecommit","lang":"ts","dir":"packages/@aws-cdk/aws-codecommit/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-codedeploy","lang":"js","dir":"packages/@aws-cdk/aws-codedeploy/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-codeguruprofiler","lang":"ts","dir":"packages/@aws-cdk/aws-codeguruprofiler/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-codegurureviewer","lang":"ts","dir":"packages/@aws-cdk/aws-codegurureviewer/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-codepipeline-actions","lang":"ts","dir":"packages/@aws-cdk/aws-codepipeline-actions/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-codepipeline","lang":"ts","dir":"packages/@aws-cdk/aws-codepipeline/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-codestar","lang":"ts","dir":"packages/@aws-cdk/aws-codestar/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-codestarconnections","lang":"ts","dir":"packages/@aws-cdk/aws-codestarconnections/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-codestarnotifications","lang":"ts","dir":"packages/@aws-cdk/aws-codestarnotifications/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-cognito","lang":"ts","dir":"packages/@aws-cdk/aws-cognito/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-config","lang":"ts","dir":"packages/@aws-cdk/aws-config/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-connect","lang":"ts","dir":"packages/@aws-cdk/aws-connect/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-cur","lang":"ts","dir":"packages/@aws-cdk/aws-cur/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-customerprofiles","lang":"ts","dir":"packages/@aws-cdk/aws-customerprofiles/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-databrew","lang":"ts","dir":"packages/@aws-cdk/aws-databrew/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-datapipeline","lang":"ts","dir":"packages/@aws-cdk/aws-datapipeline/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-datasync","lang":"ts","dir":"packages/@aws-cdk/aws-datasync/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-dax","lang":"ts","dir":"packages/@aws-cdk/aws-dax/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-detective","lang":"ts","dir":"packages/@aws-cdk/aws-detective/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-devopsguru","lang":"ts","dir":"packages/@aws-cdk/aws-devopsguru/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-directoryservice","lang":"ts","dir":"packages/@aws-cdk/aws-directoryservice/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-dlm","lang":"ts","dir":"packages/@aws-cdk/aws-dlm/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-dms","lang":"ts","dir":"packages/@aws-cdk/aws-dms/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-docdb","lang":"ts","dir":"packages/@aws-cdk/aws-docdb/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-global-lambda-coordinator","lang":"js","dir":"packages/@aws-cdk/aws-dynamodb-global/lambda-packages/aws-global-table-coordinator/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@aws-cdk/aws-dynamodb-global","lang":"ts","dir":"packages/@aws-cdk/aws-dynamodb-global/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-dynamodb","lang":"ts","dir":"packages/@aws-cdk/aws-dynamodb/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ec2","lang":"ts","dir":"packages/@aws-cdk/aws-ec2/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ecr-assets","lang":"ts","dir":"packages/@aws-cdk/aws-ecr-assets/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ecr","lang":"ts","dir":"packages/@aws-cdk/aws-ecr/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ecs-patterns","lang":"js","dir":"packages/@aws-cdk/aws-ecs-patterns/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ecs","lang":"ts","dir":"packages/@aws-cdk/aws-ecs/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-efs","lang":"ts","dir":"packages/@aws-cdk/aws-efs/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-eks-legacy","lang":"ts","dir":"packages/@aws-cdk/aws-eks-legacy/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-eks","lang":"ts","dir":"packages/@aws-cdk/aws-eks/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-elasticache","lang":"ts","dir":"packages/@aws-cdk/aws-elasticache/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-elasticbeanstalk","lang":"ts","dir":"packages/@aws-cdk/aws-elasticbeanstalk/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-elasticloadbalancing","lang":"ts","dir":"packages/@aws-cdk/aws-elasticloadbalancing/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-elasticloadbalancingv2-actions","lang":"ts","dir":"packages/@aws-cdk/aws-elasticloadbalancingv2-actions/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-elasticloadbalancingv2-targets","lang":"ts","dir":"packages/@aws-cdk/aws-elasticloadbalancingv2-targets/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-elasticloadbalancingv2","lang":"ts","dir":"packages/@aws-cdk/aws-elasticloadbalancingv2/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-elasticsearch","lang":"ts","dir":"packages/@aws-cdk/aws-elasticsearch/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-emr","lang":"ts","dir":"packages/@aws-cdk/aws-emr/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-emrcontainers","lang":"ts","dir":"packages/@aws-cdk/aws-emrcontainers/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-events-targets","lang":"js","dir":"packages/@aws-cdk/aws-events-targets/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-events","lang":"ts","dir":"packages/@aws-cdk/aws-events/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-eventschemas","lang":"ts","dir":"packages/@aws-cdk/aws-eventschemas/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-evidently","lang":"ts","dir":"packages/@aws-cdk/aws-evidently/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-finspace","lang":"ts","dir":"packages/@aws-cdk/aws-finspace/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-fis","lang":"ts","dir":"packages/@aws-cdk/aws-fis/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-fms","lang":"ts","dir":"packages/@aws-cdk/aws-fms/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-frauddetector","lang":"ts","dir":"packages/@aws-cdk/aws-frauddetector/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-fsx","lang":"ts","dir":"packages/@aws-cdk/aws-fsx/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-gamelift","lang":"ts","dir":"packages/@aws-cdk/aws-gamelift/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-globalaccelerator-endpoints","lang":"ts","dir":"packages/@aws-cdk/aws-globalaccelerator-endpoints/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-globalaccelerator","lang":"ts","dir":"packages/@aws-cdk/aws-globalaccelerator/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-glue","lang":"ts","dir":"packages/@aws-cdk/aws-glue/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-greengrass","lang":"ts","dir":"packages/@aws-cdk/aws-greengrass/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-greengrassv2","lang":"ts","dir":"packages/@aws-cdk/aws-greengrassv2/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-groundstation","lang":"ts","dir":"packages/@aws-cdk/aws-groundstation/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-guardduty","lang":"ts","dir":"packages/@aws-cdk/aws-guardduty/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-healthlake","lang":"ts","dir":"packages/@aws-cdk/aws-healthlake/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-iam","lang":"ts","dir":"packages/@aws-cdk/aws-iam/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-imagebuilder","lang":"ts","dir":"packages/@aws-cdk/aws-imagebuilder/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-inspector","lang":"ts","dir":"packages/@aws-cdk/aws-inspector/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-iot-actions","lang":"js","dir":"packages/@aws-cdk/aws-iot-actions/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-iot","lang":"ts","dir":"packages/@aws-cdk/aws-iot/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-iot1click","lang":"ts","dir":"packages/@aws-cdk/aws-iot1click/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-iotanalytics","lang":"ts","dir":"packages/@aws-cdk/aws-iotanalytics/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-iotcoredeviceadvisor","lang":"ts","dir":"packages/@aws-cdk/aws-iotcoredeviceadvisor/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-iotevents","lang":"ts","dir":"packages/@aws-cdk/aws-iotevents/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-iotfleethub","lang":"ts","dir":"packages/@aws-cdk/aws-iotfleethub/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-iotsitewise","lang":"ts","dir":"packages/@aws-cdk/aws-iotsitewise/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-iotthingsgraph","lang":"ts","dir":"packages/@aws-cdk/aws-iotthingsgraph/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-iotwireless","lang":"ts","dir":"packages/@aws-cdk/aws-iotwireless/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ivs","lang":"ts","dir":"packages/@aws-cdk/aws-ivs/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-kendra","lang":"ts","dir":"packages/@aws-cdk/aws-kendra/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-kinesis","lang":"ts","dir":"packages/@aws-cdk/aws-kinesis/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-kinesisanalytics-flink","lang":"ts","dir":"packages/@aws-cdk/aws-kinesisanalytics-flink/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-kinesisanalytics","lang":"ts","dir":"packages/@aws-cdk/aws-kinesisanalytics/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-kinesisfirehose-destinations","lang":"ts","dir":"packages/@aws-cdk/aws-kinesisfirehose-destinations/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-kinesisfirehose","lang":"ts","dir":"packages/@aws-cdk/aws-kinesisfirehose/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-kms","lang":"ts","dir":"packages/@aws-cdk/aws-kms/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lakeformation","lang":"ts","dir":"packages/@aws-cdk/aws-lakeformation/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lambda-destinations","lang":"ts","dir":"packages/@aws-cdk/aws-lambda-destinations/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lambda-event-sources","lang":"ts","dir":"packages/@aws-cdk/aws-lambda-event-sources/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lambda-go","lang":"ts","dir":"packages/@aws-cdk/aws-lambda-go/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lambda-nodejs","lang":"ts","dir":"packages/@aws-cdk/aws-lambda-nodejs/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lambda-python","lang":"ts","dir":"packages/@aws-cdk/aws-lambda-python/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lambda","lang":"ts","dir":"packages/@aws-cdk/aws-lambda/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lex","lang":"ts","dir":"packages/@aws-cdk/aws-lex/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-licensemanager","lang":"ts","dir":"packages/@aws-cdk/aws-licensemanager/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lightsail","lang":"ts","dir":"packages/@aws-cdk/aws-lightsail/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-location","lang":"ts","dir":"packages/@aws-cdk/aws-location/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-logs-destinations","lang":"ts","dir":"packages/@aws-cdk/aws-logs-destinations/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-logs","lang":"ts","dir":"packages/@aws-cdk/aws-logs/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lookoutequipment","lang":"ts","dir":"packages/@aws-cdk/aws-lookoutequipment/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lookoutmetrics","lang":"ts","dir":"packages/@aws-cdk/aws-lookoutmetrics/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-lookoutvision","lang":"ts","dir":"packages/@aws-cdk/aws-lookoutvision/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-macie","lang":"ts","dir":"packages/@aws-cdk/aws-macie/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-managedblockchain","lang":"ts","dir":"packages/@aws-cdk/aws-managedblockchain/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-mediaconnect","lang":"ts","dir":"packages/@aws-cdk/aws-mediaconnect/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-mediaconvert","lang":"ts","dir":"packages/@aws-cdk/aws-mediaconvert/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-medialive","lang":"ts","dir":"packages/@aws-cdk/aws-medialive/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-mediapackage","lang":"ts","dir":"packages/@aws-cdk/aws-mediapackage/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-mediastore","lang":"ts","dir":"packages/@aws-cdk/aws-mediastore/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-memorydb","lang":"ts","dir":"packages/@aws-cdk/aws-memorydb/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-msk","lang":"ts","dir":"packages/@aws-cdk/aws-msk/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-mwaa","lang":"ts","dir":"packages/@aws-cdk/aws-mwaa/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-neptune","lang":"ts","dir":"packages/@aws-cdk/aws-neptune/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-networkfirewall","lang":"ts","dir":"packages/@aws-cdk/aws-networkfirewall/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-networkmanager","lang":"ts","dir":"packages/@aws-cdk/aws-networkmanager/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-nimblestudio","lang":"ts","dir":"packages/@aws-cdk/aws-nimblestudio/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-opensearchservice","lang":"ts","dir":"packages/@aws-cdk/aws-opensearchservice/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-opsworks","lang":"ts","dir":"packages/@aws-cdk/aws-opsworks/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-opsworkscm","lang":"ts","dir":"packages/@aws-cdk/aws-opsworkscm/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-panorama","lang":"ts","dir":"packages/@aws-cdk/aws-panorama/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-pinpoint","lang":"ts","dir":"packages/@aws-cdk/aws-pinpoint/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-pinpointemail","lang":"ts","dir":"packages/@aws-cdk/aws-pinpointemail/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-qldb","lang":"ts","dir":"packages/@aws-cdk/aws-qldb/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-quicksight","lang":"ts","dir":"packages/@aws-cdk/aws-quicksight/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ram","lang":"ts","dir":"packages/@aws-cdk/aws-ram/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-rds","lang":"ts","dir":"packages/@aws-cdk/aws-rds/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-redshift","lang":"ts","dir":"packages/@aws-cdk/aws-redshift/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-refactorspaces","lang":"ts","dir":"packages/@aws-cdk/aws-refactorspaces/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-rekognition","lang":"ts","dir":"packages/@aws-cdk/aws-rekognition/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-resiliencehub","lang":"ts","dir":"packages/@aws-cdk/aws-resiliencehub/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-resourcegroups","lang":"ts","dir":"packages/@aws-cdk/aws-resourcegroups/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-robomaker","lang":"ts","dir":"packages/@aws-cdk/aws-robomaker/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-route53-patterns","lang":"ts","dir":"packages/@aws-cdk/aws-route53-patterns/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-route53-targets","lang":"ts","dir":"packages/@aws-cdk/aws-route53-targets/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-route53","lang":"ts","dir":"packages/@aws-cdk/aws-route53/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-route53recoverycontrol","lang":"ts","dir":"packages/@aws-cdk/aws-route53recoverycontrol/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-route53recoveryreadiness","lang":"ts","dir":"packages/@aws-cdk/aws-route53recoveryreadiness/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-route53resolver","lang":"ts","dir":"packages/@aws-cdk/aws-route53resolver/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-rum","lang":"ts","dir":"packages/@aws-cdk/aws-rum/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-s3-assets","lang":"ts","dir":"packages/@aws-cdk/aws-s3-assets/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-s3-deployment","lang":"ts","dir":"packages/@aws-cdk/aws-s3-deployment/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-s3-notifications","lang":"ts","dir":"packages/@aws-cdk/aws-s3-notifications/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-s3","lang":"ts","dir":"packages/@aws-cdk/aws-s3/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-s3objectlambda","lang":"ts","dir":"packages/@aws-cdk/aws-s3objectlambda/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-s3outposts","lang":"ts","dir":"packages/@aws-cdk/aws-s3outposts/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-sagemaker","lang":"ts","dir":"packages/@aws-cdk/aws-sagemaker/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-sam","lang":"ts","dir":"packages/@aws-cdk/aws-sam/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-sdb","lang":"ts","dir":"packages/@aws-cdk/aws-sdb/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-secretsmanager","lang":"ts","dir":"packages/@aws-cdk/aws-secretsmanager/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-securityhub","lang":"ts","dir":"packages/@aws-cdk/aws-securityhub/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-servicecatalog","lang":"ts","dir":"packages/@aws-cdk/aws-servicecatalog/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-servicecatalogappregistry","lang":"ts","dir":"packages/@aws-cdk/aws-servicecatalogappregistry/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-servicediscovery","lang":"ts","dir":"packages/@aws-cdk/aws-servicediscovery/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ses-actions","lang":"ts","dir":"packages/@aws-cdk/aws-ses-actions/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ses","lang":"ts","dir":"packages/@aws-cdk/aws-ses/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-signer","lang":"ts","dir":"packages/@aws-cdk/aws-signer/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-sns-subscriptions","lang":"ts","dir":"packages/@aws-cdk/aws-sns-subscriptions/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-sns","lang":"ts","dir":"packages/@aws-cdk/aws-sns/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-sqs","lang":"ts","dir":"packages/@aws-cdk/aws-sqs/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ssm","lang":"ts","dir":"packages/@aws-cdk/aws-ssm/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ssmcontacts","lang":"ts","dir":"packages/@aws-cdk/aws-ssmcontacts/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-ssmincidents","lang":"ts","dir":"packages/@aws-cdk/aws-ssmincidents/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-sso","lang":"ts","dir":"packages/@aws-cdk/aws-sso/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-stepfunctions-tasks","lang":"ts","dir":"packages/@aws-cdk/aws-stepfunctions-tasks/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-stepfunctions","lang":"ts","dir":"packages/@aws-cdk/aws-stepfunctions/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-synthetics","lang":"ts","dir":"packages/@aws-cdk/aws-synthetics/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-timestream","lang":"ts","dir":"packages/@aws-cdk/aws-timestream/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-transfer","lang":"ts","dir":"packages/@aws-cdk/aws-transfer/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-waf","lang":"ts","dir":"packages/@aws-cdk/aws-waf/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-wafregional","lang":"ts","dir":"packages/@aws-cdk/aws-wafregional/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-wafv2","lang":"ts","dir":"packages/@aws-cdk/aws-wafv2/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-wisdom","lang":"ts","dir":"packages/@aws-cdk/aws-wisdom/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-workspaces","lang":"ts","dir":"packages/@aws-cdk/aws-workspaces/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/aws-xray","lang":"ts","dir":"packages/@aws-cdk/aws-xray/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/cdk-assets-schema","lang":"ts","dir":"packages/@aws-cdk/cdk-assets-schema/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/cfnspec","lang":"ts","dir":"packages/@aws-cdk/cfnspec/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/cloud-assembly-schema","lang":"ts","dir":"packages/@aws-cdk/cloud-assembly-schema/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/cloudformation-diff","lang":"ts","dir":"packages/@aws-cdk/cloudformation-diff/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/cloudformation-include","lang":"ts","dir":"packages/@aws-cdk/cloudformation-include/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/core","lang":"ts","dir":"packages/@aws-cdk/core/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/custom-resources","lang":"js","dir":"packages/@aws-cdk/custom-resources/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/cx-api","lang":"ts","dir":"packages/@aws-cdk/cx-api/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/example-construct-library","lang":"ts","dir":"packages/@aws-cdk/example-construct-library/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/lambda-layer-awscli","lang":"ts","dir":"packages/@aws-cdk/lambda-layer-awscli/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/lambda-layer-kubectl","lang":"ts","dir":"packages/@aws-cdk/lambda-layer-kubectl/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/lambda-layer-node-proxy-agent","lang":"ts","dir":"packages/@aws-cdk/lambda-layer-node-proxy-agent/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/pipelines","lang":"ts","dir":"packages/@aws-cdk/pipelines/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/region-info","lang":"ts","dir":"packages/@aws-cdk/region-info/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/yaml-cfn","lang":"ts","dir":"packages/@aws-cdk/yaml-cfn/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@monocdk-experiment/rewrite-imports","lang":"ts","dir":"packages/@monocdk-experiment/rewrite-imports/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"aws-cdk-migration","lang":"ts","dir":"packages/aws-cdk-migration/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"aws-cdk","lang":"ts","dir":"packages/aws-cdk/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"cdk-assets","lang":"ts","dir":"packages/cdk-assets/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"cdk-dasm","lang":"ts","dir":"packages/cdk-dasm/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"decdk","lang":"ts","dir":"packages/decdk/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/cdk-release","lang":"ts","dir":"tools/@aws-cdk/cdk-release/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/cfn2ts","lang":"js","dir":"tools/@aws-cdk/cfn2ts/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@aws-cdk/eslint-plugin","lang":"js","dir":"tools/@aws-cdk/eslint-plugin/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/generate-examples","lang":"ts","dir":"tools/@aws-cdk/generate-examples/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/individual-pkg-gen","lang":"ts","dir":"tools/@aws-cdk/individual-pkg-gen/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/pkglint","lang":"ts","dir":"tools/@aws-cdk/pkglint/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/prlint","lang":"ts","dir":"tools/@aws-cdk/prlint/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@aws-cdk/yarn-cling","lang":"ts","dir":"tools/@aws-cdk/yarn-cling/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"Validate augmentation schema for ","suites":[],"updatePoint":{"line":25,"column":52},"line":25,"code":"  test(`Validate augmentation schema for ${resource}`, resourceAugmentationTest(resource));","file":"augmentation.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"dropTypelessAttributes works correctly","suites":[],"updatePoint":{"line":4,"column":44},"line":4,"code":"test('dropTypelessAttributes works correctly', () => {\n  const spec: schema.Specification = {\n    Fingerprint: 'some-fingerprint',\n    PropertyTypes: {\n      'CDK::Test::Property': {\n        Properties: {\n          Type: ({\n            PrimitiveType: 'String',\n          } as schema.ScalarProperty), // ts is being weird and doesn't correctly match the type\n        },\n      },\n    },\n    ResourceTypes: {\n      'CDK::Test::Resource': {\n        Attributes: {\n          Attribute1: ({\n            PrimitiveType: 'String',\n          } as schema.PrimitiveAttribute), // ts is being weird and doesn't correctly match the type\n          Attribute2: ({} as schema.PrimitiveAttribute),\n        },\n        Documentation: 'https://documentation-url/cdk/test/resource',\n        Properties: {\n          ResourceArn: ({\n            PrimitiveType: 'String',\n          } as schema.PrimitiveProperty), // ts is being weird and doesn't correctly match the type\n        },\n      },\n    },\n  };\n\n  massageSpec(spec);\n\n  expect(spec).toEqual({\n    Fingerprint: 'some-fingerprint',\n    PropertyTypes: {\n      'CDK::Test::Property': {\n        Properties: {\n          Type: ({\n            PrimitiveType: 'String',\n          } as schema.ScalarProperty), // ts is being weird and doesn't correctly match the type\n        },\n      },\n    },\n    ResourceTypes: {\n      'CDK::Test::Resource': {\n        Attributes: {\n          Attribute1: ({\n            PrimitiveType: 'String',\n          }),\n        },\n        Documentation: 'https://documentation-url/cdk/test/resource',\n        Properties: {\n          ResourceArn: {\n            PrimitiveType: 'String',\n          },\n        },\n      },\n    },\n  });\n});","file":"build.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"spot-check DynamoDB metrics","suites":[],"updatePoint":{"line":3,"column":33},"line":3,"code":"test('spot-check DynamoDB metrics', () => {\n  const metrics = cfnspec.cannedMetricsForService('AWS::DynamoDB');\n  expect(metrics.length).toBeGreaterThan(0);\n\n  const resLatency = metrics.find(m => m.metricName === 'SuccessfulRequestLatency');\n  expect(resLatency).toBeTruthy();\n\n  expect(resLatency?.dimensions).toEqual([['Operation', 'TableName']]);\n});","file":"canned-metrics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"spot-check MediaStore metrics","suites":[],"updatePoint":{"line":13,"column":35},"line":13,"code":"test('spot-check MediaStore metrics', () => {\n  const metrics = cfnspec.cannedMetricsForService('AWS::MediaStore');\n  expect(metrics.length).toBeGreaterThan(0);\n});","file":"canned-metrics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"Validate canned metrics for ","suites":[],"updatePoint":{"line":23,"column":48},"line":23,"code":"  test(`Validate canned metrics for ${namespace}`, () => {\n    const metrics = cfnspec.cannedMetricsForService(namespace);\n\n    // Check that there are no duplicates in these list (duplicates may occur because of duplicate\n    // dimensions, but those have readly been combined).\n    const uniqueMetricNames = new Set(metrics.map(m => `${m.namespace}/${m.metricName}`));\n    expect(uniqueMetricNames.size).toEqual(metrics.length);\n  });","file":"canned-metrics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"spot-check Bucket statefulness","suites":[],"updatePoint":{"line":3,"column":36},"line":3,"code":"test('spot-check Bucket statefulness', () => {\n  const anno = cfnspec.cfnLintAnnotations('AWS::S3::Bucket');\n  expect(anno.stateful).toBeTruthy();\n  expect(anno.mustBeEmptyToDelete).toBeTruthy();\n});","file":"cfnlint-annotations.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"spot-check Table statefulness","suites":[],"updatePoint":{"line":9,"column":35},"line":9,"code":"test('spot-check Table statefulness', () => {\n  const anno = cfnspec.cfnLintAnnotations('AWS::DynamoDB::Table');\n  expect(anno.stateful).toBeTruthy();\n  expect(anno.mustBeEmptyToDelete).toBeFalsy();\n});","file":"cfnlint-annotations.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"spot-check MediaStore metrics","suites":[],"updatePoint":{"line":15,"column":35},"line":15,"code":"test('spot-check MediaStore metrics', () => {\n  const anno = cfnspec.cfnLintAnnotations('AWS::MediaStore::Thingy');\n  expect(anno.stateful).toBeFalsy();\n});","file":"cfnlint-annotations.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"spot-check resource docs","suites":[],"updatePoint":{"line":3,"column":30},"line":3,"code":"test('spot-check resource docs', () => {\n  const bucketDocs = cfnspec.typeDocs('AWS::S3::Bucket');\n\n  expect(bucketDocs.description).toBeTruthy();\n  expect(bucketDocs.properties.BucketName).toBeTruthy();\n});","file":"docs.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"spot-check property type docs","suites":[],"updatePoint":{"line":10,"column":35},"line":10,"code":"test('spot-check property type docs', () => {\n  const destDocs = cfnspec.typeDocs('AWS::S3::Bucket.Destination');\n\n  expect(destDocs.description).toBeTruthy();\n  expect(destDocs.properties.Format).toBeTruthy();\n});","file":"docs.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"filteredSpecification(/^AWS::S3::.*/)","suites":[],"updatePoint":{"line":4,"column":43},"line":4,"code":"test('filteredSpecification(/^AWS::S3::.*/)', () => {\n  const filteredSpec = filteredSpecification(/^AWS::S3::.*/);\n  expect(filteredSpec).not.toEqual(specification);\n  expect(filteredSpec.ResourceTypes).not.toEqual({});\n});","file":"filtered-specification.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"filteredSpecification(s => s.startsWith(\"AWS::S3::\")","suites":[],"updatePoint":{"line":10,"column":58},"line":10,"code":"test('filteredSpecification(s => s.startsWith(\"AWS::S3::\")', () => {\n  const filteredSpec = filteredSpecification(s => s.startsWith('AWS::S3::'));\n  expect(filteredSpec).not.toEqual(specification);\n  expect(filteredSpec.ResourceTypes).not.toEqual({});\n});","file":"filtered-specification.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"namespaces() includes some namespaces","suites":[],"updatePoint":{"line":3,"column":43},"line":3,"code":"test('namespaces() includes some namespaces', () => {\n  expect(namespaces().length).toBeGreaterThan(10);\n});","file":"namespaces.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"can combine two independent records","suites":[],"updatePoint":{"line":11,"column":41},"line":11,"code":"test('can combine two independent records', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a' },\n    },\n    '002': {\n      type: 'fragment',\n      data: { b: 'b' },\n    },\n  })).toEqual({\n    a: 'a',\n    b: 'b',\n  });\n});","file":"patch-set.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"can combine two records with same value","suites":[],"updatePoint":{"line":27,"column":45},"line":27,"code":"test('can combine two records with same value', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a', b: 'b' },\n    },\n    '002': {\n      type: 'fragment',\n      data: { b: 'b', c: 'c' },\n    },\n  })).toEqual({\n    a: 'a',\n    b: 'b',\n    c: 'c',\n  });\n});","file":"patch-set.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"cannot combine two records with conflicting values","suites":[],"updatePoint":{"line":44,"column":56},"line":44,"code":"test('cannot combine two records with conflicting values', () => {\n  expect(() => evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a' },\n    },\n    '002': {\n      type: 'fragment',\n      data: { a: 'x' },\n    },\n  })).toThrow(/Conflict/);\n});","file":"patch-set.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"can apply json patches to records","suites":[],"updatePoint":{"line":57,"column":39},"line":57,"code":"test('can apply json patches to records', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a' },\n    },\n    '002': {\n      type: 'patch',\n      data: {\n        patch: {\n          operations: [{\n            op: 'move',\n            from: '/a',\n            path: '/b',\n          }],\n        },\n      },\n    },\n  })).toEqual({\n    b: 'a',\n  });\n});","file":"patch-set.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"can apply json patches in nested context","suites":[],"updatePoint":{"line":80,"column":46},"line":80,"code":"test('can apply json patches in nested context', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { nested: { a: 'a' } },\n    },\n    '002': {\n      type: 'patch',\n      data: {\n        nested: {\n          patch: {\n            operations: [{\n              op: 'move',\n              from: '/a',\n              path: '/b',\n            }],\n          },\n        },\n      },\n    },\n  })).toEqual({\n    nested: { b: 'a' },\n  });\n});","file":"patch-set.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"relative json patch paths can reference from the root","suites":[],"updatePoint":{"line":105,"column":59},"line":105,"code":"test('relative json patch paths can reference from the root', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a', nested: { b: 'b' } },\n    },\n    '002': {\n      type: 'patch',\n      data: {\n        nested: {\n          patch: {\n            operations: [{\n              op: 'move',\n              from: '$/a',\n              path: '/a',\n            }],\n          },\n        },\n      },\n    },\n  })).toEqual({\n    nested: { a: 'a', b: 'b' },\n  });\n});","file":"patch-set.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"can nest sub-patch sets","suites":[],"updatePoint":{"line":130,"column":29},"line":130,"code":"test('can nest sub-patch sets', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a' },\n    },\n    '002': {\n      type: 'set',\n      sources: {\n        '001': {\n          type: 'fragment',\n          data: { b: 'b' },\n        },\n        '002': {\n          type: 'fragment',\n          data: { c: 'c' },\n        },\n      },\n    },\n  })).toEqual({\n    a: 'a',\n    b: 'b',\n    c: 'c',\n  });\n});","file":"patch-set.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"spot-check IAM identity tags","suites":[],"updatePoint":{"line":4,"column":34},"line":4,"code":"test('spot-check IAM identity tags', () => {\n  const prop = propertySpecification('AWS::IAM::Role', 'Policies');\n  expect(prop.ScrutinyType).toEqual(PropertyScrutinyType.InlineIdentityPolicies);\n});","file":"scrutiny.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"IAM AssumeRolePolicy","suites":[],"updatePoint":{"line":9,"column":26},"line":9,"code":"test('IAM AssumeRolePolicy', () => {\n  // AssumeRolePolicyDocument is a resource policy, because it applies to the Role itself!\n  const prop = propertySpecification('AWS::IAM::Role', 'AssumeRolePolicyDocument');\n  expect(prop.ScrutinyType).toEqual(PropertyScrutinyType.InlineResourcePolicy);\n});","file":"scrutiny.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"spot-check IAM resource tags","suites":[],"updatePoint":{"line":15,"column":34},"line":15,"code":"test('spot-check IAM resource tags', () => {\n  const prop = propertySpecification('AWS::KMS::Key', 'KeyPolicy');\n  expect(prop.ScrutinyType).toEqual(PropertyScrutinyType.InlineResourcePolicy);\n});","file":"scrutiny.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"spot-check resource policy resources","suites":[],"updatePoint":{"line":20,"column":42},"line":20,"code":"test('spot-check resource policy resources', () => {\n  expect(resourceSpecification('AWS::S3::BucketPolicy').ScrutinyType).toEqual(ResourceScrutinyType.ResourcePolicyResource);\n});","file":"scrutiny.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"spot-check no misclassified tags","suites":[],"updatePoint":{"line":24,"column":38},"line":24,"code":"test('spot-check no misclassified tags', () => {\n  const prop = propertySpecification('AWS::SNS::Subscription', 'DeliveryPolicy');\n  expect(prop.ScrutinyType).toEqual(PropertyScrutinyType.None);\n});","file":"scrutiny.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"check Lambda permission resource scrutiny","suites":[],"updatePoint":{"line":29,"column":47},"line":29,"code":"test('check Lambda permission resource scrutiny', () => {\n  expect(resourceSpecification('AWS::Lambda::Permission').ScrutinyType).toEqual(ResourceScrutinyType.LambdaPermission);\n});","file":"scrutiny.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"check role managedpolicyarns","suites":[],"updatePoint":{"line":33,"column":34},"line":33,"code":"test('check role managedpolicyarns', () => {\n  const prop = propertySpecification('AWS::IAM::Role', 'ManagedPolicyArns');\n  expect(prop.ScrutinyType).toEqual(PropertyScrutinyType.ManagedPolicies);\n});","file":"scrutiny.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"check securityGroup scrutinies","suites":[],"updatePoint":{"line":38,"column":36},"line":38,"code":"test('check securityGroup scrutinies', () => {\n  const inProp = propertySpecification('AWS::EC2::SecurityGroup', 'SecurityGroupIngress');\n  expect(inProp.ScrutinyType).toEqual(PropertyScrutinyType.IngressRules);\n\n  const eProp = propertySpecification('AWS::EC2::SecurityGroup', 'SecurityGroupEgress');\n  expect(eProp.ScrutinyType).toEqual(PropertyScrutinyType.EgressRules);\n});","file":"scrutiny.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"check securityGroupRule scrutinies","suites":[],"updatePoint":{"line":46,"column":40},"line":46,"code":"test('check securityGroupRule scrutinies', () => {\n  const inRes = resourceSpecification('AWS::EC2::SecurityGroupIngress');\n  expect(inRes.ScrutinyType).toEqual(ResourceScrutinyType.IngressRuleResource);\n\n  const eRes = resourceSpecification('AWS::EC2::SecurityGroupEgress');\n  expect(eRes.ScrutinyType).toEqual(ResourceScrutinyType.EgressRuleResource);\n});","file":"scrutiny.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"error if Type and PrimitiveType are both absent","suites":["single-valued type"],"updatePoint":{"line":4,"column":55},"line":4,"code":"  test('error if Type and PrimitiveType are both absent', () => {\n    expect(errorsFor(resourceTypeProperty({}))).toEqual([\n      expect.stringContaining(\"must have exactly one of 'Type', 'PrimitiveType'\"),\n    ]);\n  });","file":"validate-cfn.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"error if referenced type does not exist","suites":["single-valued type"],"updatePoint":{"line":10,"column":47},"line":10,"code":"  test('error if referenced type does not exist', () => {\n    expect(errorsFor(resourceTypeProperty({\n      Type: 'Xyz',\n    }))).toEqual([\n      expect.stringContaining(\"unknown property type name 'Xyz'\"),\n    ]);\n  });","file":"validate-cfn.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"error if Type and PrimitiveType are both present","suites":["single-valued type"],"updatePoint":{"line":18,"column":56},"line":18,"code":"  test('error if Type and PrimitiveType are both present', () => {\n    expect(errorsFor(resourceTypeProperty({\n      Type: 'Asdf',\n      PrimitiveType: 'String',\n    }))).toEqual([\n      expect.stringContaining(\"must have exactly one of 'Type', 'PrimitiveType'\"),\n    ]);\n  });","file":"validate-cfn.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"error if ItemType is present","suites":["single-valued type"],"updatePoint":{"line":27,"column":36},"line":27,"code":"  test('error if ItemType is present', () => {\n    expect(errorsFor(resourceTypeProperty({\n      PrimitiveType: 'String',\n      ItemType: 'Asdf',\n    }))).toEqual([\n      expect.stringContaining(\"only 'List' or 'Map' types\"),\n    ]);\n  });","file":"validate-cfn.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"error if PrimitiveItemType is present and Type is not a collection","suites":["single-valued type"],"updatePoint":{"line":36,"column":74},"line":36,"code":"  test('error if PrimitiveItemType is present and Type is not a collection', () => {\n    expect(errorsFor(resourceTypeProperty({\n      PrimitiveType: 'String',\n      PrimitiveItemType: 'Asdf',\n    }))).toEqual([\n      expect.stringContaining(\"only 'List' or 'Map' types\"),\n    ]);\n  });","file":"validate-cfn.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"error if ItemType or PrimitiveItemType are both present","suites":["collection type"],"updatePoint":{"line":47,"column":63},"line":47,"code":"  test('error if ItemType or PrimitiveItemType are both present', () => {\n    expect(errorsFor(resourceTypeProperty({\n      Type: 'List',\n      PrimitiveItemType: 'String',\n      ItemType: 'Asdf',\n    }))).toEqual([\n      expect.stringContaining(\"must have exactly one of 'ItemType', 'PrimitiveItemType'\"),\n    ]);\n  });","file":"validate-cfn.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"error if ItemType or PrimitiveItemType are both absent","suites":["collection type"],"updatePoint":{"line":57,"column":62},"line":57,"code":"  test('error if ItemType or PrimitiveItemType are both absent', () => {\n    expect(errorsFor(resourceTypeProperty({\n      Type: 'List',\n    }))).toEqual([\n      expect.stringContaining(\"must have exactly one of 'ItemType', 'PrimitiveItemType'\"),\n    ]);\n  });","file":"validate-cfn.test.ts","skipped":false,"dir":"packages/@aws-cdk/cfnspec/test"},{"name":"when there is no difference","suites":[],"updatePoint":{"line":12,"column":33},"line":12,"code":"test('when there is no difference', () => {\n  const bucketName = 'ShineyBucketName';\n  const currentTemplate = {\n    Resources: {\n      BucketPolicyResource: BUCKET_POLICY_RESOURCE,\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: bucketName,\n        },\n      },\n    },\n  };\n  // Making a JSON-clone, because === is cheating!\n  const newTemplate = JSON.parse(JSON.stringify(currentTemplate));\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(0);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"when a resource is created","suites":[],"updatePoint":{"line":32,"column":32},"line":32,"code":"test('when a resource is created', () => {\n  const currentTemplate = { Resources: {} };\n\n  const newTemplate = { Resources: { BucketResource: { Type: 'AWS::S3::Bucket' } } };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.isAddition).toBeTruthy();\n  expect(difference?.newResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.changeImpact).toBe(ResourceImpact.WILL_CREATE);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"when a resource is deleted (no DeletionPolicy)","suites":[],"updatePoint":{"line":47,"column":52},"line":47,"code":"test('when a resource is deleted (no DeletionPolicy)', () => {\n  const currentTemplate = {\n    Resources: {\n      BucketResource: { Type: 'AWS::S3::Bucket' },\n      BucketPolicyResource: BUCKET_POLICY_RESOURCE,\n    },\n  };\n\n  const newTemplate = {\n    Resources: {\n      BucketResource: { Type: 'AWS::S3::Bucket' },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketPolicyResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.isRemoval).toBeTruthy();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::BucketPolicy');\n  expect(difference?.changeImpact).toBe(ResourceImpact.WILL_DESTROY);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"when a resource is deleted (DeletionPolicy=Retain)","suites":[],"updatePoint":{"line":71,"column":56},"line":71,"code":"test('when a resource is deleted (DeletionPolicy=Retain)', () => {\n  const currentTemplate = {\n    Resources: {\n      BucketResource: { Type: 'AWS::S3::Bucket' },\n      BucketPolicyResource: {\n        Type: 'AWS::S3::BucketPolicy',\n        DeletionPolicy: 'Retain',\n        Properties: {\n          PolicyDocument: POLICY_DOCUMENT,\n          Bucket: { Ref: 'BucketResource' },\n        },\n      },\n    },\n  };\n\n  const newTemplate = {\n    Resources: { BucketResource: { Type: 'AWS::S3::Bucket' } },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketPolicyResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.isRemoval).toBeTruthy();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::BucketPolicy');\n  expect(difference?.changeImpact).toBe(ResourceImpact.WILL_ORPHAN);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"when a property changes","suites":[],"updatePoint":{"line":100,"column":29},"line":100,"code":"test('when a property changes', () => {\n  const bucketName = 'ShineyBucketName';\n  const currentTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: bucketName,\n        },\n      },\n    },\n  };\n\n  const newBucketName = `${bucketName}-v2`;\n  const newTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: newBucketName,\n        },\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.propertyUpdates).toEqual({\n    BucketName: { oldValue: bucketName, newValue: newBucketName, changeImpact: ResourceImpact.WILL_REPLACE, isDifferent: true },\n  });\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"change in dependencies counts as a simple update","suites":[],"updatePoint":{"line":142,"column":54},"line":142,"code":"test('change in dependencies counts as a simple update', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource'],\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource', 'SomeOtherResource'],\n      },\n    },\n  };\n  const differences = diffTemplate(currentTemplate, newTemplate);\n\n  // THEN\n  expect(differences.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference?.changeImpact).toBe(ResourceImpact.WILL_UPDATE);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"when a property is deleted","suites":[],"updatePoint":{"line":170,"column":32},"line":170,"code":"test('when a property is deleted', () => {\n  const bucketName = 'ShineyBucketName';\n  const currentTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: bucketName,\n        },\n      },\n    },\n  };\n\n  const newTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.propertyUpdates).toEqual({\n    BucketName: { oldValue: bucketName, newValue: undefined, changeImpact: ResourceImpact.WILL_REPLACE, isDifferent: true },\n  });\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"when a property is added","suites":[],"updatePoint":{"line":208,"column":30},"line":208,"code":"test('when a property is added', () => {\n  const bucketName = 'ShineyBucketName';\n  const currentTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n      },\n    },\n  };\n\n  const newTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: bucketName,\n        },\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.propertyUpdates).toEqual({\n    BucketName: { oldValue: undefined, newValue: bucketName, changeImpact: ResourceImpact.WILL_REPLACE, isDifferent: true },\n  });\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"when a resource type changed","suites":[],"updatePoint":{"line":246,"column":34},"line":246,"code":"test('when a resource type changed', () => {\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::IAM::Policy',\n        Properties: {\n          PolicyName: 'PolicyName',\n        },\n      },\n    },\n  };\n\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: 'BucketName',\n        },\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBe(undefined);\n  expect(difference?.oldResourceType).toEqual('AWS::IAM::Policy');\n  expect(difference?.newResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.changeImpact).toBe(ResourceImpact.WILL_REPLACE);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"resource replacement is tracked through references","suites":[],"updatePoint":{"line":279,"column":56},"line":279,"code":"test('resource replacement is tracked through references', () => {\n  // If a resource is replaced, then that change shows that references are\n  // going to change. This may lead to replacement of downstream resources\n  // if the reference is used in an immutable property, and so on.\n\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: { BucketName: 'Name1' }, // Immutable prop\n      },\n      Queue: {\n        Type: 'AWS::SQS::Queue',\n        Properties: { QueueName: { Ref: 'Bucket' } }, // Immutable prop\n      },\n      Topic: {\n        Type: 'AWS::SNS::Topic',\n        Properties: { TopicName: { Ref: 'Queue' } }, // Immutable prop\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: { BucketName: 'Name2' },\n      },\n      Queue: {\n        Type: 'AWS::SQS::Queue',\n        Properties: { QueueName: { Ref: 'Bucket' } },\n      },\n      Topic: {\n        Type: 'AWS::SNS::Topic',\n        Properties: { TopicName: { Ref: 'Queue' } },\n      },\n    },\n  };\n  const differences = diffTemplate(currentTemplate, newTemplate);\n\n  // THEN\n  expect(differences.resources.differenceCount).toBe(3);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"adding and removing quotes from a numeric property causes no changes","suites":[],"updatePoint":{"line":325,"column":74},"line":325,"code":"test('adding and removing quotes from a numeric property causes no changes', () => {\n  const currentTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          CorsConfiguration: {\n            CorsRules: [\n              {\n                AllowedMethods: [\n                  'GET',\n                ],\n                AllowedOrigins: [\n                  '*',\n                ],\n                MaxAge: 10,\n              },\n            ],\n          },\n        },\n      },\n    },\n  };\n\n  const newTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          CorsConfiguration: {\n            CorsRules: [\n              {\n                AllowedMethods: [\n                  'GET',\n                ],\n                AllowedOrigins: [\n                  '*',\n                ],\n                MaxAge: '10',\n              },\n            ],\n          },\n        },\n      },\n    },\n  };\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"versions are correctly detected as not numbers","suites":[],"updatePoint":{"line":378,"column":52},"line":378,"code":"test('versions are correctly detected as not numbers', () => {\n  const currentTemplate = {\n    Resources: {\n      ImageBuilderComponent: {\n        Type: 'AWS::ImageBuilder::Component',\n        Properties: {\n          Platform: 'Linux',\n          Version: '0.0.1',\n        },\n      },\n    },\n  };\n  const newTemplate = {\n    Resources: {\n      ImageBuilderComponent: {\n        Type: 'AWS::ImageBuilder::Component',\n        Properties: {\n          Platform: 'Linux',\n          Version: '0.0.2',\n        },\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"single element arrays are equivalent to the single element in DependsOn expressions","suites":[],"updatePoint":{"line":406,"column":89},"line":406,"code":"test('single element arrays are equivalent to the single element in DependsOn expressions', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource'],\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: 'SomeResource',\n      },\n    },\n  };\n\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"array equivalence is independent of element order in DependsOn expressions","suites":[],"updatePoint":{"line":434,"column":80},"line":434,"code":"test('array equivalence is independent of element order in DependsOn expressions', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource', 'AnotherResource'],\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['AnotherResource', 'SomeResource'],\n      },\n    },\n  };\n\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"arrays of different length are considered unequal in DependsOn expressions","suites":[],"updatePoint":{"line":462,"column":80},"line":462,"code":"test('arrays of different length are considered unequal in DependsOn expressions', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource', 'AnotherResource', 'LastResource'],\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['AnotherResource', 'SomeResource'],\n      },\n    },\n  };\n\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"arrays that differ only in element order are considered unequal outside of DependsOn expressions","suites":[],"updatePoint":{"line":490,"column":102},"line":490,"code":"test('arrays that differ only in element order are considered unequal outside of DependsOn expressions', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        BucketName: { 'Fn::Select': [0, ['name1', 'name2']] },\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        BucketName: { 'Fn::Select': [0, ['name2', 'name1']] },\n      },\n    },\n  };\n\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"boolean properties are considered equal with their stringified counterparts","suites":[],"updatePoint":{"line":518,"column":81},"line":518,"code":"test('boolean properties are considered equal with their stringified counterparts', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          PublicAccessBlockConfiguration: {\n            BlockPublicAcls: 'true',\n          },\n        },\n      },\n    },\n  };\n  const newTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          PublicAccessBlockConfiguration: {\n            BlockPublicAcls: true,\n          },\n        },\n      },\n    },\n  };\n\n  // WHEN\n  const differences = diffTemplate(currentTemplate, newTemplate);\n\n  // THEN\n  expect(differences.differenceCount).toBe(0);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"when a property changes including equivalent DependsOn","suites":[],"updatePoint":{"line":552,"column":60},"line":552,"code":"test('when a property changes including equivalent DependsOn', () => {\n  // GIVEN\n  const bucketName = 'ShineyBucketName';\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource'],\n        BucketName: bucketName,\n      },\n    },\n  };\n\n  // WHEN\n  const newBucketName = `${bucketName}-v2`;\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource'],\n        BucketName: newBucketName,\n      },\n    },\n  };\n\n  // THEN\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"reports a change when a string property with a number-like format changes from '%s' to '%s'","suites":[],"line":585,"code":"test.each([\n  ['0.31.1-prod', '0.31.2-prod'],\n  ['8.0.5.5.4-identifier', '8.0.5.5.5-identifier'],\n  ['1.1.1.1', '1.1.1.2'],\n  ['1.2.3', '1.2.4'],\n  ['2.2.2.2', '2.2.3.2'],\n  ['3.3.3.3', '3.4.3.3'],\n  ['2021-10-23T06:07:08.000Z', '2021-10-23T09:10:11.123Z'],\n])(\"reports a change when a string property with a number-like format changes from '%s' to '%s'\", (oldValue, newValue) => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          Tags: [oldValue],\n        },\n      },\n    },\n  };\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          Tags: [newValue],\n        },\n      },\n    },\n  };\n  // WHEN\n  const differences = diffTemplate(currentTemplate, newTemplate);\n\n  // THEN\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.propertyUpdates).toEqual({\n    Tags: { oldValue: [oldValue], newValue: [newValue], changeImpact: ResourceImpact.WILL_UPDATE, isDifferent: true },\n  });\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"when a property with a number-like format doesn't change","suites":[],"updatePoint":{"line":629,"column":63},"line":629,"code":"test('when a property with a number-like format doesn\\'t change', () => {\n  const tags = ['0.31.1-prod', '8.0.5.5.4-identifier', '1.1.1.1', '1.2.3'];\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          Tags: tags,\n        },\n      },\n    },\n  };\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          Tags: tags,\n        },\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(0);\n  expect(differences.resources.differenceCount).toBe(0);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).toBeUndefined();\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"handles a resource changing its Type","suites":[],"updatePoint":{"line":659,"column":42},"line":659,"code":"test('handles a resource changing its Type', () => {\n  const currentTemplate = {\n    Resources: {\n      FunctionApi: {\n        Type: 'AWS::Serverless::Api',\n        Properties: {\n          StageName: 'prod',\n        },\n      },\n    },\n  };\n  const newTemplate = {\n    Resources: {\n      FunctionApi: {\n        Type: 'AWS::ApiGateway::RestApi',\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.FunctionApi;\n  expect(difference).toEqual({\n    isAddition: false,\n    isRemoval: false,\n    newValue: { Type: 'AWS::ApiGateway::RestApi' },\n    oldValue: { Properties: { StageName: 'prod' }, Type: 'AWS::Serverless::Api' },\n    otherDiffs: {},\n    propertyDiffs: {},\n    resourceTypes: { newType: 'AWS::ApiGateway::RestApi', oldType: 'AWS::Serverless::Api' },\n  });\n});","file":"diff-template.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"adding of positive statements","suites":["broadening is"],"updatePoint":{"line":5,"column":37},"line":5,"code":"  test('adding of positive statements', () => {\n    // WHEN\n    const diff = diffTemplate({}, template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 'sqs:SendMessage',\n          Resource: '*',\n          Principal: { Service: 'sns.amazonaws.com' },\n        }),\n      }),\n    }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });","file":"iam/broadening.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"permissions diff can be printed","suites":["broadening is"],"updatePoint":{"line":23,"column":39},"line":23,"code":"  test('permissions diff can be printed', () => {\n    // GIVEN\n    const diff = diffTemplate({}, template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 'sqs:SendMessage',\n          Resource: '*',\n          Principal: { Service: 'sns.amazonaws.com' },\n        }),\n      }),\n    }));\n\n    // WHEN\n    // Behave like process.stderr, but have a 'columns' property to trigger the column width calculation\n    const stdErrMostly = Object.create(process.stderr, {\n      columns: { value: 80 },\n    });\n    formatSecurityChanges(stdErrMostly, diff);\n\n    // THEN: does not throw\n    expect(true).toBeTruthy();\n  });","file":"iam/broadening.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"adding of positive statements to an existing policy","suites":["broadening is"],"updatePoint":{"line":48,"column":59},"line":48,"code":"  test('adding of positive statements to an existing policy', () => {\n    // WHEN\n    const diff = diffTemplate(template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }), template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n          {\n            Effect: 'Allow',\n            Action: 'sqs:LookAtMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });","file":"iam/broadening.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"removal of not-statements","suites":["broadening is"],"updatePoint":{"line":86,"column":33},"line":86,"code":"  test('removal of not-statements', () => {\n    // WHEN\n    const diff = diffTemplate(template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 'sqs:SendMessage',\n          Resource: '*',\n          NotPrincipal: { Service: 'sns.amazonaws.com' },\n        }),\n      }),\n    }), {});\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });","file":"iam/broadening.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"changing of resource target","suites":["broadening is"],"updatePoint":{"line":104,"column":35},"line":104,"code":"  test('changing of resource target', () => {\n    // WHEN\n    const diff = diffTemplate(template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }), template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyOtherQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });","file":"iam/broadening.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"addition of ingress rules","suites":["broadening is"],"updatePoint":{"line":136,"column":33},"line":136,"code":"  test('addition of ingress rules', () => {\n    // WHEN\n    const diff = diffTemplate(\n      template({\n      }),\n      template({\n        SG: resource('AWS::EC2::SecurityGroup', {\n          SecurityGroupIngress: [\n            {\n              CidrIp: '1.2.3.4/8',\n              FromPort: 80,\n              ToPort: 80,\n              IpProtocol: 'tcp',\n            },\n          ],\n        }),\n      }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });","file":"iam/broadening.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"addition of egress rules","suites":["broadening is"],"updatePoint":{"line":158,"column":32},"line":158,"code":"  test('addition of egress rules', () => {\n    // WHEN\n    const diff = diffTemplate(\n      template({\n      }),\n      template({\n        SG: resource('AWS::EC2::SecurityGroup', {\n          SecurityGroupEgress: [\n            {\n              DestinationSecurityGroupId: { 'Fn::GetAtt': ['ThatOtherGroup', 'GroupId'] },\n              FromPort: 80,\n              ToPort: 80,\n              IpProtocol: 'tcp',\n            },\n          ],\n        }),\n      }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });","file":"iam/broadening.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"removal of positive statements from an existing policy","suites":["broadening is not"],"updatePoint":{"line":182,"column":62},"line":182,"code":"  test('removal of positive statements from an existing policy', () => {\n    // WHEN\n    const diff = diffTemplate(template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n          {\n            Effect: 'Allow',\n            Action: 'sqs:LookAtMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }), template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(false);\n  });","file":"iam/broadening.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"shows new AssumeRolePolicyDocument","suites":[],"updatePoint":{"line":4,"column":40},"line":4,"code":"test('shows new AssumeRolePolicyDocument', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    MyRole: role({\n      AssumeRolePolicyDocument: poldoc({\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: { Service: 'lambda.amazonaws.com' },\n      }),\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyRole.Arn}'] },\n        principals: { not: false, values: ['Service:lambda.amazonaws.com'] },\n        actions: { not: false, values: ['sts:AssumeRole'] },\n      },\n    ],\n  });\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"implicitly knows principal of identity policy for all resource types","suites":[],"updatePoint":{"line":29,"column":74},"line":29,"code":"test('implicitly knows principal of identity policy for all resource types', () => {\n  for (const attr of ['Roles', 'Users', 'Groups']) {\n    // WHEN\n    const diff = diffTemplate({}, template({\n      MyPolicy: policy({\n        [attr]: [{ Ref: 'MyRole' }],\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 's3:DoThatThing',\n          Resource: '*',\n        }),\n      }),\n    }));\n\n    // THEN\n    expect(diff.iamChanges._toJson()).toEqual({\n      statementAdditions: [\n        {\n          effect: 'Allow',\n          resources: { not: false, values: ['*'] },\n          principals: { not: false, values: ['AWS:${MyRole}'] },\n          actions: { not: false, values: ['s3:DoThatThing'] },\n        },\n      ],\n    });\n  }\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"policies on an identity object","suites":[],"updatePoint":{"line":57,"column":36},"line":57,"code":"test('policies on an identity object', () => {\n  for (const resourceType of ['Role', 'User', 'Group']) {\n    // WHEN\n    const diff = diffTemplate({}, template({\n      MyIdentity: resource(`AWS::IAM::${resourceType}`, {\n        Policies: [\n          {\n            PolicyName: 'Polly',\n            PolicyDocument: poldoc({\n              Effect: 'Allow',\n              Action: 's3:DoThatThing',\n              Resource: '*',\n            }),\n          },\n        ],\n      }),\n    }));\n\n    // THEN\n    expect(diff.iamChanges._toJson()).toEqual({\n      statementAdditions: [\n        {\n          effect: 'Allow',\n          resources: { not: false, values: ['*'] },\n          principals: { not: false, values: ['AWS:${MyIdentity}'] },\n          actions: { not: false, values: ['s3:DoThatThing'] },\n        },\n      ],\n    });\n  }\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"if policy is attached to multiple roles all are shown","suites":[],"updatePoint":{"line":89,"column":59},"line":89,"code":"test('if policy is attached to multiple roles all are shown', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    MyPolicy: policy({\n      Roles: [{ Ref: 'MyRole' }, { Ref: 'ThyRole' }],\n      PolicyDocument: poldoc({\n        Effect: 'Allow',\n        Action: 's3:DoThatThing',\n        Resource: '*',\n      }),\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['*'] },\n        principals: { not: false, values: ['AWS:${MyRole}'] },\n        actions: { not: false, values: ['s3:DoThatThing'] },\n      },\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['*'] },\n        principals: { not: false, values: ['AWS:${ThyRole}'] },\n        actions: { not: false, values: ['s3:DoThatThing'] },\n      },\n    ],\n  });\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"correctly parses Lambda permissions","suites":[],"updatePoint":{"line":121,"column":41},"line":121,"code":"test('correctly parses Lambda permissions', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    MyPermission: resource('AWS::Lambda::Permission', {\n      Action: 'lambda:InvokeFunction',\n      FunctionName: { Ref: 'MyFunction' },\n      Principal: 's3.amazonaws.com',\n      SourceAccount: { Ref: 'AWS::AccountId' },\n      SourceArn: { 'Fn::GetAtt': ['MyBucketF68F3FF0', 'Arn'] },\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyFunction}'] },\n        principals: { not: false, values: ['Service:s3.amazonaws.com'] },\n        actions: { not: false, values: ['lambda:InvokeFunction'] },\n        condition: {\n          StringEquals: { 'AWS:SourceAccount': '${AWS::AccountId}' },\n          ArnLike: { 'AWS:SourceArn': '${MyBucketF68F3FF0.Arn}' },\n        },\n      },\n    ],\n  });\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"implicitly knows resource of (queue) resource policy even if * given","suites":[],"updatePoint":{"line":150,"column":74},"line":150,"code":"test('implicitly knows resource of (queue) resource policy even if * given', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n      Queues: [{ Ref: 'MyQueue' }],\n      PolicyDocument: poldoc({\n        Effect: 'Allow',\n        Action: 'sqs:SendMessage',\n        Resource: '*',\n        Principal: { Service: 'sns.amazonaws.com' },\n      }),\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyQueue}'] },\n        principals: { not: false, values: ['Service:sns.amazonaws.com'] },\n        actions: { not: false, values: ['sqs:SendMessage'] },\n      },\n    ],\n  });\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"finds sole statement removals","suites":[],"updatePoint":{"line":177,"column":35},"line":177,"code":"test('finds sole statement removals', () => {\n  // WHEN\n  const diff = diffTemplate(template({\n    BucketPolicy: resource('AWS::S3::BucketPolicy', {\n      Bucket: { Ref: 'MyBucket' },\n      PolicyDocument: poldoc({\n        Effect: 'Allow',\n        Action: 's3:PutObject',\n        Resource: '*',\n        Principal: { AWS: 'me' },\n      }),\n    }),\n  }), {});\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementRemovals: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyBucket}'] },\n        principals: { not: false, values: ['AWS:me'] },\n        actions: { not: false, values: ['s3:PutObject'] },\n      },\n    ],\n  });\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"finds one of many statement removals","suites":[],"updatePoint":{"line":204,"column":42},"line":204,"code":"test('finds one of many statement removals', () => {\n  // WHEN\n  const diff = diffTemplate(\n    template({\n      BucketPolicy: resource('AWS::S3::BucketPolicy', {\n        Bucket: { Ref: 'MyBucket' },\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 's3:PutObject',\n          Resource: '*',\n          Principal: { AWS: 'me' },\n        }, {\n          Effect: 'Allow',\n          Action: 's3:LookAtObject',\n          Resource: '*',\n          Principal: { AWS: 'me' },\n        }),\n      }),\n    }),\n    template({\n      BucketPolicy: resource('AWS::S3::BucketPolicy', {\n        Bucket: { Ref: 'MyBucket' },\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 's3:LookAtObject',\n          Resource: '*',\n          Principal: { AWS: 'me' },\n        }),\n      }),\n    }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementRemovals: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyBucket}'] },\n        principals: { not: false, values: ['AWS:me'] },\n        actions: { not: false, values: ['s3:PutObject'] },\n      },\n    ],\n  });\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"finds policy attachments","suites":[],"updatePoint":{"line":248,"column":30},"line":248,"code":"test('finds policy attachments', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    SomeRole: resource('AWS::IAM::Role', {\n      ManagedPolicyArns: ['arn:policy'],\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    managedPolicyAdditions: [\n      {\n        identityArn: '${SomeRole}',\n        managedPolicyArn: 'arn:policy',\n      },\n    ],\n  });\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"finds policy removals","suites":[],"updatePoint":{"line":267,"column":27},"line":267,"code":"test('finds policy removals', () => {\n  // WHEN\n  const diff = diffTemplate(\n    template({\n      SomeRole: resource('AWS::IAM::Role', {\n        ManagedPolicyArns: ['arn:policy', 'arn:policy2'],\n      }),\n    }),\n    template({\n      SomeRole: resource('AWS::IAM::Role', {\n        ManagedPolicyArns: ['arn:policy2'],\n      }),\n    }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    managedPolicyRemovals: [\n      {\n        identityArn: '${SomeRole}',\n        managedPolicyArn: 'arn:policy',\n      },\n    ],\n  });\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"queuepolicy queue change counts as removal+addition","suites":[],"updatePoint":{"line":292,"column":57},"line":292,"code":"test('queuepolicy queue change counts as removal+addition', () => {\n  // WHEN\n  const diff = diffTemplate(template({\n    QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n      Queues: [{ Ref: 'MyQueue1' }],\n      PolicyDocument: poldoc({\n        Effect: 'Allow',\n        Action: 'sqs:SendMessage',\n        Resource: '*',\n        Principal: { Service: 'sns.amazonaws.com' },\n      }),\n    }),\n  }), template({\n    QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n      Queues: [{ Ref: 'MyQueue2' }],\n      PolicyDocument: poldoc({\n        Effect: 'Allow',\n        Action: 'sqs:SendMessage',\n        Resource: '*',\n        Principal: { Service: 'sns.amazonaws.com' },\n      }),\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyQueue2}'] },\n        principals: { not: false, values: ['Service:sns.amazonaws.com'] },\n        actions: { not: false, values: ['sqs:SendMessage'] },\n      },\n    ],\n    statementRemovals: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyQueue1}'] },\n        principals: { not: false, values: ['Service:sns.amazonaws.com'] },\n        actions: { not: false, values: ['sqs:SendMessage'] },\n      },\n    ],\n  });\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"supports Fn::If in the top-level property value of Role","suites":[],"updatePoint":{"line":337,"column":61},"line":337,"code":"test('supports Fn::If in the top-level property value of Role', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    MyRole: role({\n      AssumeRolePolicyDocument: poldoc({\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: { Service: 'lambda.amazonaws.com' },\n      }),\n      ManagedPolicyArns: {\n        'Fn::If': [\n          'SomeCondition',\n          ['then-managed-policy-arn'],\n          ['else-managed-policy-arn'],\n        ],\n      },\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    managedPolicyAdditions: [\n      {\n        identityArn: '${MyRole}',\n        managedPolicyArn: '{\"Fn::If\":[\"SomeCondition\",[\"then-managed-policy-arn\"],[\"else-managed-policy-arn\"]]}',\n      },\n    ],\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        principals: { not: false, values: ['Service:lambda.amazonaws.com'] },\n        actions: { not: false, values: ['sts:AssumeRole'] },\n        resources: {\n          not: false,\n          values: ['${MyRole.Arn}'],\n        },\n      },\n    ],\n  });\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"supports Fn::If in the elements of an array-typed property of Role","suites":[],"updatePoint":{"line":378,"column":72},"line":378,"code":"test('supports Fn::If in the elements of an array-typed property of Role', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    MyRole: role({\n      AssumeRolePolicyDocument: poldoc({\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: { Service: 'lambda.amazonaws.com' },\n      }),\n      Policies: [\n        {\n          'Fn::If': [\n            'SomeCondition',\n            {\n              PolicyName: 'S3',\n              PolicyDocument: poldoc({\n                Effect: 'Allow',\n                Action: 's3:GetObject',\n                Resource: '*',\n              }),\n            },\n            {\n              Ref: 'AWS::NoValue',\n            },\n          ],\n        },\n      ],\n    }),\n  }));\n\n  // THEN\n  const changedStatements = diff.iamChanges.summarizeStatements();\n\n  // there are 2 rows of changes\n  // (one for the AssumeRolePolicyDocument,\n  // one for the Policies),\n  // plus a row of headers\n  expect(changedStatements.length).toBe(3);\n\n  const changedPolicies = changedStatements[2];\n  const resourceColumn = 1, principalColumn = 4;\n\n  expect(changedPolicies[resourceColumn]).toContain('{\"Fn::If\":[\"SomeCondition\",{\"PolicyName\":\"S3\",\"PolicyDocument\":{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"s3:GetObject\",\"Resource\":\"*\"}]}}]}');\n  expect(changedPolicies[principalColumn]).toContain('AWS:${MyRole}');\n});","file":"iam/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"can parse all positive fields","suites":[],"updatePoint":{"line":4,"column":35},"line":4,"code":"test('can parse all positive fields', () => {\n  const statement = new Statement({\n    Sid: 'Sid',\n    Effect: 'Allow',\n    Resource: ['resource'],\n    Action: ['action'],\n    Principal: [{ AWS: 'arn' }],\n    Condition: { StringEquals: { 'Amzn-This': 'That' } },\n  });\n\n  expect(statement.sid).toEqual('Sid');\n  expect(statement.effect).toEqual('Allow');\n  expect(statement.resources.values).toEqual(['resource']);\n  expect(statement.actions.values).toEqual(['action']);\n  expect(statement.principals.values).toEqual(['AWS:arn']);\n  expect(statement.condition).toEqual({ StringEquals: { 'Amzn-This': 'That' } });\n\n  expect(statement.resources.not).toBe(false);\n  expect(statement.actions.not).toBe(false);\n  expect(statement.principals.not).toBe(false);\n});","file":"iam/statement.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"parses strings as singleton lists","suites":[],"updatePoint":{"line":26,"column":39},"line":26,"code":"test('parses strings as singleton lists', () => {\n  const statement = new Statement({\n    Resource: 'resource',\n  });\n\n  expect(statement.resources.values).toEqual(['resource']);\n});","file":"iam/statement.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"correctly parses NotFields","suites":[],"updatePoint":{"line":34,"column":32},"line":34,"code":"test('correctly parses NotFields', () => {\n  const statement = new Statement({\n    NotResource: ['resource'],\n    NotAction: ['action'],\n    NotPrincipal: [{ AWS: 'arn' }],\n  });\n\n  expect(statement.resources.not).toBe(true);\n  expect(statement.actions.not).toBe(true);\n  expect(statement.principals.not).toBe(true);\n});","file":"iam/statement.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"parse all LambdaPermission fields","suites":[],"updatePoint":{"line":46,"column":39},"line":46,"code":"test('parse all LambdaPermission fields', () => {\n  const statement = parseLambdaPermission({\n    Action: 'lambda:CallMeMaybe',\n    FunctionName: 'Function',\n    Principal: '*',\n    SourceAccount: '123456789012',\n    SourceArn: 'arn',\n  });\n\n  expect(statement.actions.values).toEqual(['lambda:CallMeMaybe']);\n  expect(statement.resources.values).toEqual(['Function']);\n  expect(statement.principals.values).toEqual(['*']);\n  expect(statement.condition).toEqual({\n    ArnLike: { 'AWS:SourceArn': 'arn' },\n    StringEquals: { 'AWS:SourceAccount': '123456789012' },\n  });\n});","file":"iam/statement.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"parse lambda eventsourcetoken","suites":[],"updatePoint":{"line":64,"column":35},"line":64,"code":"test('parse lambda eventsourcetoken', () => {\n  const statement = parseLambdaPermission({\n    Action: 'lambda:CallMeMaybe',\n    FunctionName: 'Function',\n    EventSourceToken: 'token',\n    Principal: '*',\n  });\n\n  expect(statement.condition).toEqual({\n    StringEquals: { 'lambda:EventSourceToken': 'token' },\n  });\n});","file":"iam/statement.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"stringify complex condition","suites":[],"updatePoint":{"line":77,"column":33},"line":77,"code":"test('stringify complex condition', () => {\n  // WHEN\n  const stringified = renderCondition({\n    StringEquals: { 'AWS:SourceAccount': '${AWS::AccountId}' },\n    ArnLike: { 'AWS:SourceArn': '${MyBucket.Arn}' },\n  }).split('\\n');\n\n  // THEN\n  expect(stringified).toEqual([\n    '\"StringEquals\": {',\n    '  \"AWS:SourceAccount\": \"${AWS::AccountId}\"',\n    '},',\n    '\"ArnLike\": {',\n    '  \"AWS:SourceArn\": \"${MyBucket.Arn}\"',\n    '}',\n  ]);\n});","file":"iam/statement.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"an Allow statement with a NotPrincipal is negative","suites":[],"updatePoint":{"line":95,"column":56},"line":95,"code":"test('an Allow statement with a NotPrincipal is negative', () => {\n  // WHEN\n  const statement = new Statement({\n    Effect: 'Allow',\n    Resource: 'resource',\n    NotPrincipal: { AWS: 'me' },\n  });\n\n  // THEN\n  expect(statement.isNegativeStatement).toBe(true);\n});","file":"iam/statement.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"a Deny statement with a NotPrincipal is positive","suites":[],"updatePoint":{"line":107,"column":54},"line":107,"code":"test('a Deny statement with a NotPrincipal is positive', () => {\n  // In effect, this is a roundabout way of saying only the given Principal\n  // should be allowed (\"everyone who's not me can't do this\").\n\n  // WHEN\n  const statement = new Statement({\n    Effect: 'Deny',\n    Resource: 'resource',\n    NotPrincipal: { AWS: 'me' },\n  });\n\n  // THEN\n  expect(statement.isNegativeStatement).toBe(false);\n});","file":"iam/statement.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"equality is reflexive","suites":[],"updatePoint":{"line":122,"column":27},"line":122,"code":"test('equality is reflexive', () => {\n  fc.assert(fc.property(\n    arbitraryStatement, (statement) => {\n      return new Statement(statement).equal(new Statement(statement));\n    },\n  ));\n});","file":"iam/statement.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"equality is symmetric","suites":[],"updatePoint":{"line":130,"column":27},"line":130,"code":"test('equality is symmetric', () => {\n  fc.assert(fc.property(\n    twoArbitraryStatements, (s) => {\n      const a = new Statement(s.statement1);\n      const b = new Statement(s.statement2);\n\n      fc.pre(a.equal(b));\n      return b.equal(a);\n    },\n  ));\n});","file":"iam/statement.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"detect addition of all types of rules","suites":[],"updatePoint":{"line":4,"column":43},"line":4,"code":"test('detect addition of all types of rules', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    SG: resource('AWS::EC2::SecurityGroup', {\n      SecurityGroupIngress: [\n        {\n          CidrIp: '1.2.3.4/8',\n          FromPort: 80,\n          ToPort: 80,\n          IpProtocol: 'tcp',\n        },\n      ],\n      SecurityGroupEgress: [\n        {\n          DestinationSecurityGroupId: { 'Fn::GetAtt': ['ThatOtherGroup', 'GroupId'] },\n          FromPort: 80,\n          ToPort: 80,\n          IpProtocol: 'tcp',\n        },\n      ],\n    }),\n    InRule: resource('AWS::EC2::SecurityGroupIngress', {\n      GroupId: { 'Fn::GetAtt': ['SG', 'GroupId'] },\n      FromPort: -1,\n      ToPort: -1,\n      IpProtocol: 'icmp',\n      SourcePrefixListId: 'pl-1234',\n    }),\n    OutRule: resource('AWS::EC2::SecurityGroupEgress', {\n      GroupId: { 'Fn::GetAtt': ['SG', 'GroupId'] },\n      FromPort: -1,\n      ToPort: -1,\n      IpProtocol: 'udp',\n      CidrIp: '7.8.9.0/24',\n    }),\n  }));\n\n  // THEN\n  expect(diff.securityGroupChanges.toJson()).toEqual({\n    ingressRuleAdditions: [\n      {\n        groupId: '${SG.GroupId}',\n        ipProtocol: 'tcp',\n        fromPort: 80,\n        toPort: 80,\n        peer: { kind: 'cidr-ip', ip: '1.2.3.4/8' },\n      },\n      {\n        groupId: '${SG.GroupId}',\n        ipProtocol: 'icmp',\n        fromPort: -1,\n        toPort: -1,\n        peer: { kind: 'prefix-list', prefixListId: 'pl-1234' },\n      },\n    ],\n    egressRuleAdditions: [\n      {\n        groupId: '${SG.GroupId}',\n        ipProtocol: 'tcp',\n        fromPort: 80,\n        toPort: 80,\n        peer: { kind: 'security-group', securityGroupId: '${ThatOtherGroup.GroupId}' },\n      },\n      {\n        groupId: '${SG.GroupId}',\n        ipProtocol: 'udp',\n        fromPort: -1,\n        toPort: -1,\n        peer: { kind: 'cidr-ip', ip: '7.8.9.0/24' },\n      },\n    ],\n  });\n});","file":"network/detect-changes.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"can parse cidr-ip","suites":[],"updatePoint":{"line":4,"column":23},"line":4,"code":"test('can parse cidr-ip', () => {\n  const rule = new SecurityGroupRule({\n    GroupId: 'sg-1234',\n    IpProtocol: 'tcp',\n    FromPort: 10,\n    ToPort: 20,\n    CidrIp: '1.2.3.4/8',\n  });\n\n  expect(rule.groupId).toEqual('sg-1234');\n  expect(rule.ipProtocol).toEqual('tcp');\n  expect(rule.fromPort).toEqual(10);\n  expect(rule.toPort).toEqual(20);\n\n  const peer = rule.peer!;\n  if (peer.kind !== 'cidr-ip') { throw new Error('Fail'); }\n  expect(peer.ip).toEqual('1.2.3.4/8');\n});","file":"network/rule.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"can parse cidr-ip 6","suites":[],"updatePoint":{"line":23,"column":25},"line":23,"code":"test('can parse cidr-ip 6', () => {\n  const rule = new SecurityGroupRule({\n    CidrIpv6: '::/0',\n  });\n\n  const peer = rule.peer!;\n  if (peer.kind !== 'cidr-ip') { throw new Error('Fail'); }\n  expect(peer.ip).toEqual('::/0');\n});","file":"network/rule.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"can parse securityGroup","suites":[],"updatePoint":{"line":33,"column":29},"line":33,"code":"test('can parse securityGroup', () => {\n  for (const key of ['DestinationSecurityGroupId', 'SourceSecurityGroupId']) {\n    const rule = new SecurityGroupRule({\n      [key]: 'sg-1234',\n    });\n\n    const peer = rule.peer!;\n    if (peer.kind !== 'security-group') { throw new Error('Fail'); }\n    expect(peer.securityGroupId).toEqual('sg-1234');\n  }\n});","file":"network/rule.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"can parse prefixlist","suites":[],"updatePoint":{"line":45,"column":26},"line":45,"code":"test('can parse prefixlist', () => {\n  for (const key of ['DestinationPrefixListId', 'SourcePrefixListId']) {\n    const rule = new SecurityGroupRule({\n      [key]: 'pl-1',\n    });\n\n    const peer = rule.peer!;\n    if (peer.kind !== 'prefix-list') { throw new Error('Fail'); }\n    expect(peer.prefixListId).toEqual('pl-1');\n  }\n});","file":"network/rule.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"equality is reflexive","suites":[],"updatePoint":{"line":57,"column":27},"line":57,"code":"test('equality is reflexive', () => {\n  fc.assert(fc.property(\n    arbitraryRule, (statement) => {\n      return new SecurityGroupRule(statement).equal(new SecurityGroupRule(statement));\n    },\n  ));\n});","file":"network/rule.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"equality is symmetric","suites":[],"updatePoint":{"line":65,"column":27},"line":65,"code":"test('equality is symmetric', () => {\n  fc.assert(fc.property(\n    twoArbitraryRules, (s) => {\n      const a = new SecurityGroupRule(s.rule1);\n      const b = new SecurityGroupRule(s.rule2);\n\n      fc.pre(a.equal(b));\n      return b.equal(a);\n    },\n  ));\n});","file":"network/rule.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"resolves Ref","suites":[],"updatePoint":{"line":3,"column":18},"line":3,"code":"test('resolves Ref', () =>\n  expect(renderIntrinsics({ Ref: 'SomeLogicalId' })).toEqual('${SomeLogicalId}'));","file":"render-intrinsics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"resolves Fn::GetAtt","suites":[],"updatePoint":{"line":6,"column":25},"line":6,"code":"test('resolves Fn::GetAtt', () =>\n  expect(renderIntrinsics({ 'Fn::GetAtt': ['SomeLogicalId', 'Attribute'] })).toEqual('${SomeLogicalId.Attribute}'));","file":"render-intrinsics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"resolves Fn::Join","suites":[],"updatePoint":{"line":9,"column":23},"line":9,"code":"test('resolves Fn::Join', () =>\n  expect(renderIntrinsics({ 'Fn::Join': ['/', ['a', 'b', 'c']] })).toEqual('a/b/c'));","file":"render-intrinsics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"removes AWS::NoValue from Fn::Join","suites":[],"updatePoint":{"line":12,"column":40},"line":12,"code":"test('removes AWS::NoValue from Fn::Join', () =>\n  expect(renderIntrinsics({ 'Fn::Join': ['/', ['a', { Ref: 'AWS::NoValue' }, 'b', 'c']] })).toEqual('a/b/c'));","file":"render-intrinsics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"does not resolve Fn::Join if the second argument is not a list literal","suites":[],"updatePoint":{"line":15,"column":76},"line":15,"code":"test('does not resolve Fn::Join if the second argument is not a list literal', () =>\n  expect(renderIntrinsics({ 'Fn::Join': ['/', { Ref: 'ListParameter' }] })).toEqual('{\"Fn::Join\":[\"/\",\"${ListParameter}\"]}'));","file":"render-intrinsics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"deep resolves intrinsics in object","suites":[],"updatePoint":{"line":18,"column":40},"line":18,"code":"test('deep resolves intrinsics in object', () =>\n  expect(renderIntrinsics({\n    Deeper1: { Ref: 'SomeLogicalId' },\n    Deeper2: 'Do not replace',\n  })).toEqual({\n    Deeper1: '${SomeLogicalId}',\n    Deeper2: 'Do not replace',\n  }));","file":"render-intrinsics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"deep resolves intrinsics in array","suites":[],"updatePoint":{"line":27,"column":39},"line":27,"code":"test('deep resolves intrinsics in array', () =>\n  expect(renderIntrinsics([\n    { Ref: 'SomeLogicalId' },\n    'Do not replace',\n  ])).toEqual([\n    '${SomeLogicalId}',\n    'Do not replace',\n  ]));","file":"render-intrinsics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"removes NoValue from object","suites":[],"updatePoint":{"line":36,"column":33},"line":36,"code":"test('removes NoValue from object', () =>\n  expect(renderIntrinsics({\n    Deeper1: { Ref: 'SomeLogicalId' },\n    Deeper2: { Ref: 'AWS::NoValue' },\n  })).toEqual({\n    Deeper1: '${SomeLogicalId}',\n  }));","file":"render-intrinsics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"removes NoValue from array","suites":[],"updatePoint":{"line":44,"column":32},"line":44,"code":"test('removes NoValue from array', () =>\n  expect(renderIntrinsics([\n    { Ref: 'SomeLogicalId' },\n    { Ref: 'AWS::NoValue' },\n  ])).toEqual([\n    '${SomeLogicalId}',\n  ]));","file":"render-intrinsics.test.ts","skipped":false,"dir":"packages/@aws-cdk/cloudformation-diff/test"},{"name":"creates a CFN WaitConditionHandle resource","suites":["Example Resource","created with default properties"],"updatePoint":{"line":45,"column":52},"line":45,"code":"    test('creates a CFN WaitConditionHandle resource', () => {\n      // you can simply assert that a resource of a given type\n      // was generated in the resulting template\n      Template.fromStack(stack).resourceCountIs('AWS::CloudFormation::WaitConditionHandle', 1);\n    });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"with count = 0 and timeout = 10","suites":["Example Resource","created with default properties","creates a CFN WaitCondition resource"],"updatePoint":{"line":52,"column":43},"line":52,"code":"      test('with count = 0 and timeout = 10', () => {\n        // you can also assert the properties of the resulting resource\n        Template.fromStack(stack).hasResourceProperties('AWS::CloudFormation::WaitCondition', {\n          'Count': 0,\n          'Timeout': '10',\n          'Handle': {\n            // Don't be afraid of using the generated logical IDs in your tests!\n            // While they look random, they are actually only dependent on the\n            // path constructs have in the tree.\n            // Since changing logical IDs as the library changes actually causes\n            // problems for their customers (their CloudFormation resources will be replaced),\n            // it's good for the unit tests to verify that the logical IDs are stable.\n            'Ref': 'ExampleResourceWaitConditionHandle9C53A8D3',\n          },\n          // this is how you can check a given property is _not_ set\n          'RandomProperty': Match.absent(),\n        });\n      });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"with retention policy = Retain","suites":["Example Resource","created with default properties","creates a CFN WaitCondition resource"],"updatePoint":{"line":71,"column":42},"line":71,"code":"      test('with retention policy = Retain', () => {\n        // hasResource asserts _all_ properties of a resource,\n        // while hasResourceProperties only those within the 'Property' block\n        Template.fromStack(stack).hasResource('AWS::CloudFormation::WaitCondition', {\n          'DeletionPolicy': 'Retain',\n          'UpdateReplacePolicy': 'Retain',\n        // by default, haveResource and haveResourceLike only assert the properties of a resource -\n        // here's how you make them look at the entire resource definition\n        });\n      });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"returns true from addToResourcePolicy","suites":["Example Resource","created with default properties","creates a CFN WaitCondition resource"],"updatePoint":{"line":83,"column":47},"line":83,"code":"    test('returns true from addToResourcePolicy', () => {\n      const result = exampleResource.addToRolePolicy(new iam.PolicyStatement({\n        actions: ['kms:*'],\n        resources: ['*'],\n      }));\n\n      expect(result).toBe(true);\n    });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"correctly adds s3:Get* permissions when grantRead() is called","suites":["Example Resource","created with default properties","creates a CFN WaitCondition resource"],"updatePoint":{"line":92,"column":71},"line":92,"code":"    test('correctly adds s3:Get* permissions when grantRead() is called', () => {\n      const role = new iam.Role(stack, 'Role', {\n        assumedBy: new iam.AnyPrincipal(),\n      });\n\n      exampleResource.grantRead(role);\n\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        'PolicyDocument': {\n          'Statement': [\n            {\n              'Action': 's3:Get*',\n              'Effect': 'Allow',\n              'Resource': {\n                'Fn::Join': ['', [\n                  'arn:',\n                  { 'Ref': 'AWS::Partition' },\n                  ':cloudformation:',\n                  { 'Ref': 'AWS::Region' },\n                  ':',\n                  { 'Ref': 'AWS::AccountId' },\n                  ':wait-condition/',\n                  { 'Ref': 'ExampleResourceAC53F4AE' },\n                ]],\n              },\n            },\n          ],\n        },\n      });\n    });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"onEvent adds an Event Rule","suites":["Example Resource","created with default properties","creates a CFN WaitCondition resource"],"updatePoint":{"line":123,"column":36},"line":123,"code":"    test('onEvent adds an Event Rule', () => {\n      exampleResource.onEvent('MyEvent');\n\n      Template.fromStack(stack).hasResourceProperties('AWS::Events::Rule', {\n        EventPattern: {\n          detail: {\n            'example-resource-name': [EXAMPLE_RESOURCE_NAME],\n          },\n        },\n      });\n    });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"metricCount returns a metric with correct dimensions","suites":["Example Resource","created with default properties","creates a CFN WaitCondition resource"],"updatePoint":{"line":135,"column":62},"line":135,"code":"    test('metricCount returns a metric with correct dimensions', () => {\n      const countMetric = exampleResource.metricCount();\n\n      new cloudwatch.Alarm(stack, 'Alarm', {\n        metric: countMetric,\n        threshold: 10,\n        evaluationPeriods: 2,\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::CloudWatch::Alarm', {\n        EvaluationPeriods: 2,\n        Dimensions: [\n          {\n            Name: 'ExampleResource',\n            Value: EXAMPLE_RESOURCE_NAME,\n          },\n        ],\n        MetricName: 'Count',\n        Namespace: 'AWS/ExampleResource',\n      });\n    });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"allows manipulating its connections object","suites":["Example Resource","created with a VPC"],"updatePoint":{"line":169,"column":52},"line":169,"code":"    test('allows manipulating its connections object', () => {\n      exampleResource.connections.allowToAnyIpv4(ec2.Port.allTcp());\n    });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"correctly fills out the subnetIds property of the created VPC endpoint","suites":["Example Resource","created with a VPC"],"updatePoint":{"line":173,"column":80},"line":173,"code":"    test('correctly fills out the subnetIds property of the created VPC endpoint', () => {\n      Template.fromStack(stack).hasResourceProperties('AWS::EC2::VPCEndpoint', {\n        'SubnetIds': [\n          { 'Ref': 'VpcPrivateSubnet1Subnet536B997A' },\n          { 'Ref': 'VpcPrivateSubnet2Subnet3788AAA1' },\n        ],\n      });\n    });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"throws when accessing connections","suites":["Example Resource","imported by name"],"updatePoint":{"line":191,"column":43},"line":191,"code":"    test('throws when accessing connections', () => {\n      expect(() => exampleResource.connections).toThrow();\n    });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"has the same name as it was imported with","suites":["Example Resource","imported by name"],"updatePoint":{"line":195,"column":51},"line":195,"code":"    test('has the same name as it was imported with', () => {\n      expect(exampleResource.exampleResourceName).toEqual('my-example-resource-name');\n    });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"renders the correct ARN for Example Resource","suites":["Example Resource","imported by name"],"updatePoint":{"line":199,"column":54},"line":199,"code":"    test('renders the correct ARN for Example Resource', () => {\n      // We can't simply compare the value we get from exampleResource.exampleResourceArn,\n      // as it will contain unresolved late-bound values\n      // (what we in the CDK call Tokens).\n      // So, use a utility method on Stack that allows you to resolve those Tokens\n      // into their correct values.\n      const arn = stack.resolve(exampleResource.exampleResourceArn);\n      expect(arn).toEqual({\n        'Fn::Join': ['', [\n          'arn:',\n          { 'Ref': 'AWS::Partition' },\n          ':cloudformation:',\n          { 'Ref': 'AWS::Region' },\n          ':',\n          { 'Ref': 'AWS::AccountId' },\n          ':wait-condition/my-example-resource-name',\n        ]],\n      });\n    });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"returns false from addToResourcePolicy","suites":["Example Resource","imported by name"],"updatePoint":{"line":219,"column":48},"line":219,"code":"    test('returns false from addToResourcePolicy', () => {\n      const result = exampleResource.addToRolePolicy(new iam.PolicyStatement({\n        actions: ['kms:*'],\n        resources: ['*'],\n      }));\n\n      expect(result).toEqual(false);\n    });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"cannot be created with a physical name containing illegal characters","suites":["Example Resource","imported by name"],"updatePoint":{"line":229,"column":76},"line":229,"code":"  test('cannot be created with a physical name containing illegal characters', () => {\n    // this is how we write tests that expect an exception to be thrown\n    expect(() => {\n      new er.ExampleResource(stack, 'ExampleResource', {\n        waitConditionHandleName: 'a-1234',\n      });\n    // it's not enough to know an exception was thrown -\n    // we have to verify that its message is what we expected\n    }).toThrow(/waitConditionHandleName must be non-empty and contain only letters and underscores, got: 'a-1234'/);\n  });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"does not fail validation if the physical name is a late-bound value","suites":["Example Resource","imported by name"],"updatePoint":{"line":240,"column":75},"line":240,"code":"  test('does not fail validation if the physical name is a late-bound value', () => {\n    const parameter = new core.CfnParameter(stack, 'Parameter');\n\n    // no assertion necessary - the lack of an exception being thrown is all we need in this case\n    new er.ExampleResource(stack, 'ExampleResource', {\n      waitConditionHandleName: parameter.valueAsString,\n    });\n  });","file":"example-resource.test.ts","skipped":false,"dir":"packages/@aws-cdk/example-construct-library/test"},{"name":"correctly rewrites naked \"import\"","suites":[],"updatePoint":{"line":4,"column":41},"line":4,"code":"  test('correctly rewrites naked \"import\"', () => {\n    const output = rewriteMonoPackageImports(`\n    // something before\n    import '@aws-cdk/aws-s3/hello';\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    // something before\n    import 'aws-cdk-lib/aws-s3/hello';\n    // something after\n\n    console.log('Look! I did something!');`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"correctly rewrites naked \"require\"","suites":[],"updatePoint":{"line":20,"column":42},"line":20,"code":"  test('correctly rewrites naked \"require\"', () => {\n    const output = rewriteMonoPackageImports(`\n    // something before\n    require('@aws-cdk/aws-s3/hello');\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    // something before\n    require('aws-cdk-lib/aws-s3/hello');\n    // something after\n\n    console.log('Look! I did something!');`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"correctly rewrites \"import from\"","suites":[],"updatePoint":{"line":36,"column":40},"line":36,"code":"  test('correctly rewrites \"import from\"', () => {\n    const output = rewriteMonoPackageImports(`\n    // something before\n    import * as s3 from '@aws-cdk/aws-s3';\n    import * as cfndiff from '@aws-cdk/cloudformation-diff';\n    import { Stack } from \"@aws-cdk/core\";\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    // something before\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    import * as cfndiff from '@aws-cdk/cloudformation-diff';\n    import { Stack } from \"aws-cdk-lib\";\n    // something after\n\n    console.log('Look! I did something!');`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"correctly rewrites \"import = require\"","suites":[],"updatePoint":{"line":56,"column":45},"line":56,"code":"  test('correctly rewrites \"import = require\"', () => {\n    const output = rewriteMonoPackageImports(`\n    // something before\n    import s3 = require('@aws-cdk/aws-s3');\n    import cfndiff = require('@aws-cdk/cloudformation-diff');\n    import { Stack } = require(\"@aws-cdk/core\");\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    // something before\n    import s3 = require('aws-cdk-lib/aws-s3');\n    import cfndiff = require('@aws-cdk/cloudformation-diff');\n    import { Stack } = require(\"aws-cdk-lib\");\n    // something after\n\n    console.log('Look! I did something!');`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"correctly rewrites Cfn imports","suites":[],"updatePoint":{"line":76,"column":38},"line":76,"code":"  test('correctly rewrites Cfn imports', () => {\n    // Codestar example\n    const codestar = rewriteMonoPackageImports(`\n    // something before\n    import * as codestar from './codestar.generated';\n    import { CfnY } from '../codestar.generated';\n    import { CfnX } from '../lib/codestar.generated';\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts', {\n      rewriteCfnImports: true,\n      packageUnscopedName: 'aws-codestar',\n    });\n\n    expect(codestar).toBe(`\n    // something before\n    import * as codestar from 'aws-cdk-lib/aws-codestar';\n    import { CfnY } from 'aws-cdk-lib/aws-codestar';\n    import { CfnX } from 'aws-cdk-lib/aws-codestar';\n    // something after\n\n    console.log('Look! I did something!');`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"correctly rewrites Cfn imports from an alpha module","suites":[],"updatePoint":{"line":100,"column":59},"line":100,"code":"  test('correctly rewrites Cfn imports from an alpha module', () => {\n    const customModules = {\n      '@aws-cdk/aws-kinesisfirehose': 'aws-kinesisfirehose-alpha',\n    };\n    const output = rewriteMonoPackageImports(`\n    // something before\n    import * as firehose from '@aws-cdk/aws-kinesisfirehose';\n    import { CfnDeliveryStream } from '@aws-cdk/aws-kinesisfirehose';\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts', {\n      rewriteCfnImports: true,\n      customModules: customModules,\n    });\n\n    expect(output).toBe(`\n    // something before\n    import * as firehose from 'aws-kinesisfirehose-alpha';\n    import { CfnDeliveryStream } from 'aws-cdk-lib/aws-kinesisfirehose';\n    // something after\n\n    console.log('Look! I did something!');`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"parses ts code snippet","suites":[],"updatePoint":{"line":126,"column":30},"line":126,"code":"  test('parses ts code snippet', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as s3 from '@aws-cdk/aws-s3';\n    import { Stack } from \"@aws-cdk/core\";\n    \\`\\`\\`\n    Some more README text.`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    import { Stack } from \"aws-cdk-lib\";\n    \\`\\`\\`\n    Some more README text.`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"parses typescript code snippet","suites":[],"updatePoint":{"line":144,"column":38},"line":144,"code":"  test('parses typescript code snippet', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`typescript\n    import * as s3 from '@aws-cdk/aws-s3';\n    import { Stack } from \"@aws-cdk/core\";\n    \\`\\`\\`\n    Some more README text.`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`typescript\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    import { Stack } from \"aws-cdk-lib\";\n    \\`\\`\\`\n    Some more README text.`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"parses text code snippet","suites":[],"updatePoint":{"line":162,"column":32},"line":162,"code":"  test('parses text code snippet', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`text\n    import * as s3 from '@aws-cdk/aws-s3';\n    import { Stack } from \"@aws-cdk/core\";\n    \\`\\`\\`\n    Some more README text.`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`text\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    import { Stack } from \"aws-cdk-lib\";\n    \\`\\`\\`\n    Some more README text.`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"ignores non ts|typescript|text code snippet","suites":[],"updatePoint":{"line":180,"column":51},"line":180,"code":"  test('ignores non ts|typescript|text code snippet', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`java\n    import * as s3 from '@aws-cdk/aws-s3';\n    \\`\\`\\`\n    Some more README text.`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`java\n    import * as s3 from '@aws-cdk/aws-s3';\n    \\`\\`\\`\n    Some more README text.`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"parses multiple snippets","suites":[],"updatePoint":{"line":196,"column":32},"line":196,"code":"  test('parses multiple snippets', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as s3 from '@aws-cdk/aws-s3';\n    \\`\\`\\`\n    Some more README text.\n    \\`\\`\\`ts\n    import { CfnDeliveryStream } from '@aws-cdk/aws-kinesisfirehose';\n    \\`\\`\\``, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    \\`\\`\\`\n    Some more README text.\n    \\`\\`\\`ts\n    import { CfnDeliveryStream } from 'aws-cdk-lib/aws-kinesisfirehose';\n    \\`\\`\\``);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"import declaration","suites":["constructs imports","namespace imports"],"updatePoint":{"line":221,"column":28},"line":221,"code":"    test('import declaration', () => {\n      const output = rewriteMonoPackageImports(`\n      import * as core from '@aws-cdk/core';\n      class FooBar extends core.Construct {\n        private readonly foo: core.Construct;\n        private doStuff() { return new core.Construct(); }\n      }`, 'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n      expect(output).toBe(`\n      import * as constructs from 'constructs';\n      import * as core from 'aws-cdk-lib';\n      class FooBar extends constructs.Construct {\n        private readonly foo: constructs.Construct;\n        private doStuff() { return new constructs.Construct(); }\n      }`);\n    });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"import equals declaration","suites":["constructs imports","namespace imports"],"updatePoint":{"line":238,"column":35},"line":238,"code":"    test('import equals declaration', () => {\n      const output = rewriteMonoPackageImports(`\n      import core = require('@aws-cdk/core');\n      class FooBar extends core.Construct {\n        private readonly foo: core.Construct;\n        private doStuff() { return new core.Construct(); }\n      }`, 'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n      expect(output).toBe(`\n      import * as constructs from 'constructs';\n      import core = require('aws-cdk-lib');\n      class FooBar extends constructs.Construct {\n        private readonly foo: constructs.Construct;\n        private doStuff() { return new constructs.Construct(); }\n      }`);\n    });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"no constructs imports","suites":["constructs imports","named imports"],"updatePoint":{"line":257,"column":31},"line":257,"code":"    test('no constructs imports', () => {\n      const output = rewriteMonoPackageImports(`\n      import { Stack, StackProps } from '@aws-cdk/core';\n      class FooBar extends Stack { }`,\n      'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n      expect(output).toBe(`\n      import { Stack, StackProps } from 'aws-cdk-lib';\n      class FooBar extends Stack { }`);\n    });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"all constructs imports","suites":["constructs imports","named imports"],"updatePoint":{"line":268,"column":32},"line":268,"code":"    test('all constructs imports', () => {\n      const output = rewriteMonoPackageImports(`\n      import { IConstruct, Construct } from '@aws-cdk/core';\n      class FooBar implements IConstruct extends Construct { }`,\n      'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n      expect(output).toBe(`\n      import { IConstruct, Construct } from 'constructs';\n      class FooBar implements IConstruct extends Construct { }`);\n    });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"mixed constructs and core imports","suites":["constructs imports","named imports"],"updatePoint":{"line":279,"column":43},"line":279,"code":"    test('mixed constructs and core imports', () => {\n      const output = rewriteMonoPackageImports(`\n      import { Stack, Construct, IConstruct, StackProps } from '@aws-cdk/core';\n      class FooBar implements IConstruct extends Construct { }`,\n      'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n      expect(output).toBe(`\n      import { Construct, IConstruct } from 'constructs';\n      import { Stack, StackProps } from 'aws-cdk-lib';\n      class FooBar implements IConstruct extends Construct { }`);\n    });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"exhaustive test","suites":["constructs imports","named imports"],"updatePoint":{"line":292,"column":23},"line":292,"code":"  test('exhaustive test', () => {\n    const output = rewriteMonoPackageImports(`\n    import * as core1 from '@aws-cdk/core';\n    // a comment of some kind\n    import core2 = require('@aws-cdk/core');\n    import { Stack } from '@aws-cdk/core';\n    // more comments\n    import { Construct as CoreConstruct } from '@aws-cdk/core';\n    import { IConstruct, Stack, StackProps } from '@aws-cdk/core';\n    import * as s3 from '@aws-cdk/aws-s3';\n\n    class FooBar implements core1.IConstruct {\n      readonly foo1: core2.Construct;\n      public static bar1() { return CoreConstruct(); }\n      public static bar2() { return new class implements IConstruct {}; }\n    }`, 'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n    expect(output).toBe(`\n    import * as constructs from 'constructs';\n    import { IConstruct } from 'constructs';\n    import * as core1 from 'aws-cdk-lib';\n    // a comment of some kind\n    import core2 = require('aws-cdk-lib');\n    import { Stack } from 'aws-cdk-lib';\n    // more comments\n    import { Construct as CoreConstruct } from 'constructs';\n    import { Stack, StackProps } from 'aws-cdk-lib';\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n\n    class FooBar implements constructs.IConstruct {\n      readonly foo1: constructs.Construct;\n      public static bar1() { return CoreConstruct(); }\n      public static bar2() { return new class implements IConstruct {}; }\n    }`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"does not rewrite constructs imports unless the option is explicitly set","suites":["constructs imports","named imports"],"updatePoint":{"line":328,"column":79},"line":328,"code":"  test('does not rewrite constructs imports unless the option is explicitly set', () => {\n    const output = rewriteMonoPackageImports(`\n    import * as core1 from '@aws-cdk/core';\n    // a comment of some kind\n    import { Stack } from '@aws-cdk/core';\n    // more comments\n    import { Construct as CoreConstruct } from '@aws-cdk/core';\n    import { IConstruct, Stack, StackProps } from '@aws-cdk/core';\n    import * as s3 from '@aws-cdk/aws-s3';\n\n    class FooBar implements core1.IConstruct {\n      readonly foo1: CoreConstruct;\n      public static bar2() { return new class implements IConstruct {}; }\n    }`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    import * as core1 from 'aws-cdk-lib';\n    // a comment of some kind\n    import { Stack } from 'aws-cdk-lib';\n    // more comments\n    import { Construct as CoreConstruct } from 'aws-cdk-lib';\n    import { IConstruct, Stack, StackProps } from 'aws-cdk-lib';\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n\n    class FooBar implements core1.IConstruct {\n      readonly foo1: CoreConstruct;\n      public static bar2() { return new class implements IConstruct {}; }\n    }`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"puts constructs imports after shebang lines","suites":["constructs imports","named imports"],"updatePoint":{"line":358,"column":51},"line":358,"code":"  test('puts constructs imports after shebang lines', () => {\n    const output = rewriteMonoPackageImports(`\n    #!/usr/bin/env node\n    import * as core from '@aws-cdk/core';\n    class FooBar extends core.Construct {\n      private readonly foo: core.Construct;\n      private doStuff() { return new core.Construct(); }\n    }`, 'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n    expect(output).toBe(`\n    #!/usr/bin/env node\n    import * as constructs from 'constructs';\n    import * as core from 'aws-cdk-lib';\n    class FooBar extends constructs.Construct {\n      private readonly foo: constructs.Construct;\n      private doStuff() { return new constructs.Construct(); }\n    }`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"supports rewriteReadmeImports","suites":["constructs imports","named imports"],"updatePoint":{"line":377,"column":37},"line":377,"code":"  test('supports rewriteReadmeImports', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as s3 from '@aws-cdk/aws-s3';\n    import * as core from \"@aws-cdk/core\";\n    import { Construct, Stack } from \"@aws-cdk/core\";\n    class Foo extends core.Construct {\n      public bar() { return new Construct(); }\n    }\n    \\`\\`\\`\n    Some more README text.`, 'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as constructs from 'constructs';\n    import { Construct } from 'constructs';\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    import * as core from \"aws-cdk-lib\";\n    import { Stack } from \"aws-cdk-lib\";\n    class Foo extends constructs.Construct {\n      public bar() { return new Construct(); }\n    }\n    \\`\\`\\`\n    Some more README text.`);\n  });","file":"rewrite.test.ts","skipped":false,"dir":"packages/aws-cdk-migration/test"},{"name":"default account cache uses CDK_HOME","suites":[],"updatePoint":{"line":21,"column":41},"line":21,"code":"test('default account cache uses CDK_HOME', () => {\n  process.env.CDK_HOME = '/banana';\n  const cache = new AccountAccessKeyCache();\n  expect((cache as any).cacheFile).toContain('/banana/');\n});","file":"account-cache.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"account cache does not fail when given a nonwritable directory","suites":[],"updatePoint":{"line":27,"column":68},"line":27,"code":"test('account cache does not fail when given a nonwritable directory', async () => {\n  const accessError = new Error('Oh no');\n  (accessError as any).code = 'EACCES';\n\n  return withMocked(fs, 'mkdirs', async (mkdirs) => {\n    // Have to do this because mkdirs has 2 overloads and it confuses TypeScript\n    (mkdirs as unknown as jest.Mock<Promise<void>, [any]>).mockRejectedValue(accessError);\n\n    const cache = new AccountAccessKeyCache('/abc/xyz');\n    await cache.fetch('xyz', () => Promise.resolve({ accountId: 'asdf', partition: 'swa' }));\n\n    // No exception\n  });\n});","file":"account-cache.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"get(k) when cache is empty","suites":[],"updatePoint":{"line":42,"column":32},"line":42,"code":"test('get(k) when cache is empty', async () => {\n  const { cacheDir, cacheFile, cache } = await makeCache();\n  try {\n    expect(await cache.get('foo')).toBeUndefined();\n    expect(await fs.pathExists(cacheFile)).toBeFalsy();\n  } finally {\n    await nukeCache(cacheDir);\n  }\n});","file":"account-cache.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"put(k,v) and then get(k)","suites":[],"updatePoint":{"line":52,"column":30},"line":52,"code":"test('put(k,v) and then get(k)', async () => {\n  const { cacheDir, cacheFile, cache } = await makeCache();\n\n  try {\n    await cache.put('key', { accountId: 'value', partition: 'aws' });\n    await cache.put('boo', { accountId: 'bar', partition: 'aws' });\n    expect(await cache.get('key')).toEqual({ accountId: 'value', partition: 'aws' });\n\n    // create another cache instance on the same file, should still work\n    const cache2 = new AccountAccessKeyCache(cacheFile);\n    expect(await cache2.get('boo')).toEqual({ accountId: 'bar', partition: 'aws' });\n\n    // whitebox: read the file\n    expect(await fs.readJson(cacheFile)).toEqual({\n      key: { accountId: 'value', partition: 'aws' },\n      boo: { accountId: 'bar', partition: 'aws' },\n    });\n  } finally {\n    await nukeCache(cacheDir);\n  }\n});","file":"account-cache.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"fetch(k, resolver) can be used to \"atomically\" get + resolve + put","suites":[],"updatePoint":{"line":74,"column":72},"line":74,"code":"test('fetch(k, resolver) can be used to \"atomically\" get + resolve + put', async () => {\n  const { cacheDir, cache } = await makeCache();\n\n  try {\n    expect(await cache.get('foo')).toBeUndefined();\n    expect(await cache.fetch('foo', async () => ({ accountId: 'bar', partition: 'aws' }))).toEqual({ accountId: 'bar', partition: 'aws' });\n    expect(await cache.get('foo')).toEqual({ accountId: 'bar', partition: 'aws' });\n  } finally {\n    await nukeCache(cacheDir);\n  }\n});","file":"account-cache.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"cache is nuked if it exceeds  entries","suites":[],"updatePoint":{"line":86,"column":79},"line":86,"code":"test(`cache is nuked if it exceeds ${AccountAccessKeyCache.MAX_ENTRIES} entries`, async () => {\n\n  const { cacheDir, cacheFile, cache } = await makeCache();\n\n  try {\n    for (let i = 0; i < AccountAccessKeyCache.MAX_ENTRIES; ++i) {\n      await cache.put(`key${i}`, { accountId: `value${i}`, partition: 'aws' });\n    }\n\n    // verify all values are on disk\n    const otherCache = new AccountAccessKeyCache(cacheFile);\n    for (let i = 0; i < AccountAccessKeyCache.MAX_ENTRIES; ++i) {\n      expect(await otherCache.get(`key${i}`)).toEqual({ accountId: `value${i}`, partition: 'aws' });\n    }\n\n    // add another value\n    await cache.put('nuke-me', { accountId: 'genesis', partition: 'aws' });\n\n    // now, we expect only `nuke-me` to exist on disk\n    expect(await otherCache.get('nuke-me')).toEqual({ accountId: 'genesis', partition: 'aws' });\n    for (let i = 0; i < AccountAccessKeyCache.MAX_ENTRIES; ++i) {\n      expect(await otherCache.get(`key${i}`)).toBeUndefined();\n    }\n  } finally {\n    await nukeCache(cacheDir);\n  }\n},\n// This makes a lot of promises, so it can queue for a while...\n30_000);","file":"account-cache.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"cache pretends to be empty if cache file does not contain JSON","suites":[],"updatePoint":{"line":116,"column":68},"line":116,"code":"test('cache pretends to be empty if cache file does not contain JSON', async() => {\n  const { cacheDir, cacheFile, cache } = await makeCache();\n  try {\n    await fs.writeFile(cacheFile, '');\n\n    await expect(cache.get('abc')).resolves.toEqual(undefined);\n  } finally {\n    await nukeCache(cacheDir);\n  }\n});","file":"account-cache.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do bootstrap","suites":[],"updatePoint":{"line":68,"column":18},"line":68,"code":"test('do bootstrap', async () => {\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, { toolkitStackName: 'mockStack' });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(changeSetTemplate.Conditions.UsePublicAccessBlockConfiguration['Fn::Equals'][0]).toBe('true');\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do bootstrap using custom bucket name","suites":[],"updatePoint":{"line":82,"column":43},"line":82,"code":"test('do bootstrap using custom bucket name', async () => {\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    parameters: {\n      bucketName: 'foobar',\n    },\n  });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBe('foobar');\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(changeSetTemplate.Conditions.UsePublicAccessBlockConfiguration['Fn::Equals'][0]).toBe('true');\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do bootstrap using KMS CMK","suites":[],"updatePoint":{"line":101,"column":32},"line":101,"code":"test('do bootstrap using KMS CMK', async () => {\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    parameters: {\n      kmsKeyId: 'myKmsKey',\n    },\n  });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBe('myKmsKey');\n  expect(changeSetTemplate.Conditions.UsePublicAccessBlockConfiguration['Fn::Equals'][0]).toBe('true');\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"bootstrap disable bucket Public Access Block Configuration","suites":[],"updatePoint":{"line":120,"column":64},"line":120,"code":"test('bootstrap disable bucket Public Access Block Configuration', async () => {\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    parameters: {\n      publicAccessBlockConfiguration: false,\n    },\n  });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(changeSetTemplate.Conditions.UsePublicAccessBlockConfiguration['Fn::Equals'][0]).toBe('false');\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do bootstrap with custom tags for toolkit stack","suites":[],"updatePoint":{"line":139,"column":53},"line":139,"code":"test('do bootstrap with custom tags for toolkit stack', async () => {\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    tags: [{ Key: 'Foo', Value: 'Bar' }],\n  });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(changeSetTemplate.Conditions.UsePublicAccessBlockConfiguration['Fn::Equals'][0]).toBe('true');\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passing trusted accounts to the old bootstrapping results in an error","suites":[],"updatePoint":{"line":156,"column":75},"line":156,"code":"test('passing trusted accounts to the old bootstrapping results in an error', async () => {\n  await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    parameters: {\n      trustedAccounts: ['0123456789012'],\n    },\n  }))\n    .rejects\n    .toThrow('--trust can only be passed for the modern bootstrap experience.');\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passing CFN execution policies to the old bootstrapping results in an error","suites":[],"updatePoint":{"line":167,"column":81},"line":167,"code":"test('passing CFN execution policies to the old bootstrapping results in an error', async () => {\n  await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    parameters: {\n      cloudFormationExecutionPolicies: ['arn:aws:iam::aws:policy/AdministratorAccess'],\n    },\n  }))\n    .rejects\n    .toThrow('--cloudformation-execution-policies can only be passed for the modern bootstrap experience.');\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"even if the bootstrap stack is in a rollback state, can still retry bootstrapping it","suites":[],"updatePoint":{"line":178,"column":90},"line":178,"code":"test('even if the bootstrap stack is in a rollback state, can still retry bootstrapping it', async () => {\n  (cfnMocks.describeStacks! as jest.Mock)\n    .mockReset()\n    // First two calls, the stack exists with a 'rollback complete' status\n    // (first is for version checking, second is in deploy-stack.ts)\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'UPDATE_ROLLBACK_COMPLETE',\n          StackStatusReason: 'It is magic',\n          Outputs: [\n            { OutputKey: 'BucketName', OutputValue: 'bucket' },\n            { OutputKey: 'BucketDomainName', OutputValue: 'aws.com' },\n          ],\n        },\n      ],\n    }))\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'UPDATE_ROLLBACK_COMPLETE',\n          StackStatusReason: 'It is magic',\n          Outputs: [\n            { OutputKey: 'BucketName', OutputValue: 'bucket' },\n            { OutputKey: 'BucketDomainName', OutputValue: 'aws.com' },\n          ],\n        },\n      ],\n    }))\n    // Third call, stack has been created\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'CREATE_COMPLETE',\n          StackStatusReason: 'It is magic',\n          EnableTerminationProtection: false,\n        },\n      ],\n    }));\n\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, { toolkitStackName: 'mockStack' });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"even if the bootstrap stack failed to create, can still retry bootstrapping it","suites":[],"updatePoint":{"line":230,"column":84},"line":230,"code":"test('even if the bootstrap stack failed to create, can still retry bootstrapping it', async () => {\n  (cfnMocks.describeStacks! as jest.Mock)\n    .mockReset()\n    // First two calls, the stack exists with a 'rollback complete' status\n    // (first is for version checking, second is in deploy-stack.ts)\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'ROLLBACK_COMPLETE',\n          StackStatusReason: 'It is magic',\n          Outputs: [\n            { OutputKey: 'BucketName', OutputValue: 'bucket' },\n          ],\n        } as AWS.CloudFormation.Stack,\n      ],\n    }))\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'ROLLBACK_COMPLETE',\n          StackStatusReason: 'It is magic',\n          Outputs: [\n            { OutputKey: 'BucketName', OutputValue: 'bucket' },\n          ],\n        },\n      ],\n    }))\n    // Third call, we just did a delete and want to see it gone\n    .mockImplementationOnce(() => ({ Stacks: [] }))\n    // Fourth call, stack has been created\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'CREATE_COMPLETE',\n          StackStatusReason: 'It is magic',\n          EnableTerminationProtection: false,\n        },\n      ],\n    }));\n\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, { toolkitStackName: 'mockStack' });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n  expect(cfnMocks.deleteStack).toHaveBeenCalled();\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"stack is not termination protected by default","suites":[],"updatePoint":{"line":283,"column":51},"line":283,"code":"test('stack is not termination protected by default', async () => {\n  // WHEN\n  await bootstrapper.bootstrapEnvironment(env, sdk);\n\n  // THEN\n  expect(executed).toBeTruthy();\n  expect(protectedTermination).toBeFalsy();\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"stack is termination protected when set","suites":[],"updatePoint":{"line":292,"column":45},"line":292,"code":"test('stack is termination protected when set', async () => {\n  // WHEN\n  await bootstrapper.bootstrapEnvironment(env, sdk, {\n    terminationProtection: true,\n  });\n\n  // THEN\n  expect(executed).toBeTruthy();\n  expect(protectedTermination).toBeTruthy();\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do showTemplate YAML","suites":[],"updatePoint":{"line":303,"column":26},"line":303,"code":"test('do showTemplate YAML', async () => {\n  process.stdout.write = jest.fn().mockImplementationOnce((template) => {\n    // THEN\n    expect(parse(template)).toHaveProperty('Description', 'The CDK Toolkit Stack. It was created by `cdk bootstrap` and manages resources necessary for managing your Cloud Applications with AWS CDK.');\n  });\n\n  // WHEN\n  await bootstrapper.showTemplate(false);\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do showTemplate JSON","suites":[],"updatePoint":{"line":313,"column":26},"line":313,"code":"test('do showTemplate JSON', async () => {\n  process.stdout.write = jest.fn().mockImplementationOnce((template) => {\n    // THEN\n    expect(JSON.parse(template)).toHaveProperty('Description', 'The CDK Toolkit Stack. It was created by `cdk bootstrap` and manages resources necessary for managing your Cloud Applications with AWS CDK.');\n  });\n\n  // WHEN\n  await bootstrapper.showTemplate(true);\n});","file":"api/bootstrap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passes the bucket name as a CFN parameter","suites":["Bootstrapping v2"],"updatePoint":{"line":62,"column":49},"line":62,"code":"  test('passes the bucket name as a CFN parameter', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        bucketName: 'my-bucket-name',\n        cloudFormationExecutionPolicies: ['arn:policy'],\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        FileAssetsBucketName: 'my-bucket-name',\n        PublicAccessBlockConfiguration: 'true',\n      }),\n    }));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passes the KMS key ID as a CFN parameter","suites":["Bootstrapping v2"],"updatePoint":{"line":78,"column":48},"line":78,"code":"  test('passes the KMS key ID as a CFN parameter', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        cloudFormationExecutionPolicies: ['arn:policy'],\n        kmsKeyId: 'my-kms-key-id',\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        FileAssetsBucketKmsKeyId: 'my-kms-key-id',\n        PublicAccessBlockConfiguration: 'true',\n      }),\n    }));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passes false to PublicAccessBlockConfiguration","suites":["Bootstrapping v2"],"updatePoint":{"line":94,"column":54},"line":94,"code":"  test('passes false to PublicAccessBlockConfiguration', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        cloudFormationExecutionPolicies: ['arn:policy'],\n        publicAccessBlockConfiguration: false,\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        PublicAccessBlockConfiguration: 'false',\n      }),\n    }));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passes true to PermissionsBoundary","suites":["Bootstrapping v2"],"updatePoint":{"line":109,"column":42},"line":109,"code":"  test('passes true to PermissionsBoundary', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        examplePermissionsBoundary: true,\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        InputPermissionsBoundary: 'cdk-hnb659fds-permissions-boundary',\n      }),\n    }));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passes value to PermissionsBoundary","suites":["Bootstrapping v2"],"updatePoint":{"line":123,"column":43},"line":123,"code":"  test('passes value to PermissionsBoundary', async () => {\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'InputPermissionsBoundary',\n          ParameterValue: 'existing-pb',\n        },\n      ],\n    });\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        customPermissionsBoundary: 'permissions-boundary-name',\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        InputPermissionsBoundary: 'permissions-boundary-name',\n      }),\n    }));\n    expect(stderrMock.mock.calls).toEqual(expect.arrayContaining([\n      expect.arrayContaining([\n        expect.stringMatching(/Changing permissions boundary from existing-pb to permissions-boundary-name/),\n      ]),\n    ]));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"permission boundary switch message does not appear","suites":["Bootstrapping v2"],"updatePoint":{"line":150,"column":58},"line":150,"code":"  test('permission boundary switch message does not appear', async () => {\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'InputPermissionsBoundary',\n          ParameterValue: '',\n        },\n      ],\n    });\n    await bootstrapper.bootstrapEnvironment(env, sdk);\n\n    expect(stderrMock.mock.calls).toEqual(expect.arrayContaining([\n      expect.not.arrayContaining([\n        expect.stringMatching(/Changing permissions boundary/),\n      ]),\n    ]));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"adding new permissions boundary","suites":["Bootstrapping v2"],"updatePoint":{"line":168,"column":39},"line":168,"code":"  test('adding new permissions boundary', async () => {\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'InputPermissionsBoundary',\n          ParameterValue: '',\n        },\n      ],\n    });\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        customPermissionsBoundary: 'permissions-boundary-name',\n      },\n    });\n\n    expect(stderrMock.mock.calls).toEqual(expect.arrayContaining([\n      expect.arrayContaining([\n        expect.stringMatching(/Adding new permissions boundary permissions-boundary-name/),\n      ]),\n    ]));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"removing existing permissions boundary","suites":["Bootstrapping v2"],"updatePoint":{"line":190,"column":46},"line":190,"code":"  test('removing existing permissions boundary', async () => {\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'InputPermissionsBoundary',\n          ParameterValue: 'permissions-boundary-name',\n        },\n      ],\n    });\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {},\n    });\n\n    expect(stderrMock.mock.calls).toEqual(expect.arrayContaining([\n      expect.arrayContaining([\n        expect.stringMatching(/Removing existing permissions boundary permissions-boundary-name/),\n      ]),\n    ]));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passing trusted accounts without CFN managed policies results in an error","suites":["Bootstrapping v2"],"updatePoint":{"line":210,"column":81},"line":210,"code":"  test('passing trusted accounts without CFN managed policies results in an error', async () => {\n    await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        trustedAccounts: ['123456789012'],\n      },\n    }))\n      .rejects\n      .toThrow(/--cloudformation-execution-policies/);\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passing trusted accounts without CFN managed policies on the existing stack results in an error","suites":["Bootstrapping v2"],"updatePoint":{"line":220,"column":103},"line":220,"code":"  test('passing trusted accounts without CFN managed policies on the existing stack results in an error', async () => {\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'CloudFormationExecutionPolicies',\n          ParameterValue: '',\n        },\n      ],\n    });\n\n    await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        trustedAccounts: ['123456789012'],\n      },\n    }))\n      .rejects\n      .toThrow(/--cloudformation-execution-policies/);\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passing no CFN managed policies without trusted accounts is okay","suites":["Bootstrapping v2"],"updatePoint":{"line":239,"column":72},"line":239,"code":"  test('passing no CFN managed policies without trusted accounts is okay', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {},\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        CloudFormationExecutionPolicies: '',\n      }),\n    }));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passing trusted accounts for lookup generates the correct stack parameter","suites":["Bootstrapping v2"],"updatePoint":{"line":251,"column":81},"line":251,"code":"  test('passing trusted accounts for lookup generates the correct stack parameter', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        trustedAccountsForLookup: ['123456789012'],\n        cloudFormationExecutionPolicies: ['aws://foo'],\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        TrustedAccountsForLookup: '123456789012',\n      }),\n    }));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"allow adding trusted account if there was already a policy on the stack","suites":["Bootstrapping v2"],"updatePoint":{"line":266,"column":79},"line":266,"code":"  test('allow adding trusted account if there was already a policy on the stack', async () => {\n    // GIVEN\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'CloudFormationExecutionPolicies',\n          ParameterValue: 'arn:aws:something',\n        },\n      ],\n    });\n\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        trustedAccounts: ['123456789012'],\n      },\n    });\n    // Did not throw\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Do not allow downgrading bootstrap stack version","suites":["Bootstrapping v2"],"updatePoint":{"line":285,"column":56},"line":285,"code":"  test('Do not allow downgrading bootstrap stack version', async () => {\n    // GIVEN\n    mockTheToolkitInfo({\n      Outputs: [\n        {\n          OutputKey: 'BootstrapVersion',\n          OutputValue: '999',\n        },\n      ],\n    });\n\n    await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        cloudFormationExecutionPolicies: ['arn:policy'],\n      },\n    })).resolves.toEqual(expect.objectContaining({ noOp: true }));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Do not allow overwriting bootstrap stack from a different vendor","suites":["Bootstrapping v2"],"updatePoint":{"line":303,"column":72},"line":303,"code":"  test('Do not allow overwriting bootstrap stack from a different vendor', async () => {\n    // GIVEN\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'BootstrapVariant',\n          ParameterValue: 'JoeSchmoe',\n        },\n      ],\n    });\n\n    await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n    })).resolves.toEqual(expect.objectContaining({ noOp: true }));\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"bootstrap template has the right exports","suites":["Bootstrapping v2"],"updatePoint":{"line":318,"column":48},"line":318,"code":"  test('bootstrap template has the right exports', async () => {\n    let template: any;\n    mockDeployStack.mockImplementation((args: DeployStackOptions) => {\n      template = args.stack.template;\n    });\n\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        cloudFormationExecutionPolicies: ['arn:policy'],\n      },\n    });\n\n    const exports = Object.values(template.Outputs ?? {})\n      .filter((o: any) => o.Export !== undefined)\n      .map((o: any) => o.Export.Name);\n\n    expect(exports).toEqual([\n      // This used to be used by aws-s3-assets\n      { 'Fn::Sub': 'CdkBootstrap-${Qualifier}-FileAssetKeyArn' },\n    ]);\n  });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"stack is not termination protected by default","suites":["Bootstrapping v2","termination protection"],"updatePoint":{"line":341,"column":55},"line":341,"code":"    test('stack is not termination protected by default', async () => {\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        parameters: {\n          cloudFormationExecutionPolicies: ['arn:policy'],\n        },\n      });\n\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        stack: expect.objectContaining({\n          terminationProtection: false,\n        }),\n      }));\n    });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"stack is termination protected when option is set","suites":["Bootstrapping v2","termination protection"],"updatePoint":{"line":355,"column":59},"line":355,"code":"    test('stack is termination protected when option is set', async () => {\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        terminationProtection: true,\n        parameters: {\n          cloudFormationExecutionPolicies: ['arn:policy'],\n        },\n      });\n\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        stack: expect.objectContaining({\n          terminationProtection: true,\n        }),\n      }));\n    });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"termination protection is left alone when option is not given","suites":["Bootstrapping v2","termination protection"],"updatePoint":{"line":370,"column":71},"line":370,"code":"    test('termination protection is left alone when option is not given', async () => {\n      mockTheToolkitInfo({\n        EnableTerminationProtection: true,\n      });\n\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        parameters: {\n          cloudFormationExecutionPolicies: ['arn:policy'],\n        },\n      });\n\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        stack: expect.objectContaining({\n          terminationProtection: true,\n        }),\n      }));\n    });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"termination protection can be switched off","suites":["Bootstrapping v2","termination protection"],"updatePoint":{"line":388,"column":52},"line":388,"code":"    test('termination protection can be switched off', async () => {\n      mockTheToolkitInfo({\n        EnableTerminationProtection: true,\n      });\n\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        terminationProtection: false,\n        parameters: {\n          cloudFormationExecutionPolicies: ['arn:policy'],\n        },\n      });\n\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        stack: expect.objectContaining({\n          terminationProtection: false,\n        }),\n      }));\n    });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"(new stack) createCustomerMasterKey=%p => parameter becomes %p ","suites":["Bootstrapping v2","KMS key"],"line":409,"code":"    test.each([\n      // Default case\n      [undefined, 'AWS_MANAGED_KEY'],\n      // Create a new key\n      [true, ''],\n      // Don't create a new key\n      [false, 'AWS_MANAGED_KEY'],\n    ])('(new stack) createCustomerMasterKey=%p => parameter becomes %p ', async (createCustomerMasterKey, paramKeyId) => {\n      // GIVEN: no existing stack\n\n      // WHEN\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        parameters: {\n          createCustomerMasterKey,\n          cloudFormationExecutionPolicies: ['arn:booh'],\n        },\n      });\n\n      // THEN\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        parameters: expect.objectContaining({\n          FileAssetsBucketKmsKeyId: paramKeyId,\n        }),\n      }));\n    });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"(upgrading) current param %p, createCustomerMasterKey=%p => parameter becomes %p ","suites":["Bootstrapping v2","KMS key"],"line":435,"code":"    test.each([\n      // Old bootstrap stack being upgraded to new one\n      [undefined, undefined, 'AWS_MANAGED_KEY'],\n      // There is a value, user doesn't request a change\n      ['arn:aws:key', undefined, undefined],\n      // Switch off existing key\n      ['arn:aws:key', false, 'AWS_MANAGED_KEY'],\n      // Switch on existing key\n      ['AWS_MANAGED_KEY', true, ''],\n    ])('(upgrading) current param %p, createCustomerMasterKey=%p => parameter becomes %p ', async (currentKeyId, createCustomerMasterKey, paramKeyId) => {\n      // GIVEN\n      mockTheToolkitInfo({\n        Parameters: currentKeyId ? [\n          {\n            ParameterKey: 'FileAssetsBucketKmsKeyId',\n            ParameterValue: currentKeyId,\n          },\n        ] : undefined,\n      });\n\n      // WHEN\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        parameters: {\n          createCustomerMasterKey,\n          cloudFormationExecutionPolicies: ['arn:booh'],\n        },\n      });\n\n      // THEN\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        parameters: expect.objectContaining({\n          FileAssetsBucketKmsKeyId: paramKeyId,\n        }),\n      }));\n    });","file":"api/bootstrap2.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do not throw when selecting stack without errors","suites":[],"updatePoint":{"line":9,"column":54},"line":9,"code":"test('do not throw when selecting stack without errors', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const selected = await cxasm.selectStacks( { patterns: ['withouterrorsNODEPATH'] }, {\n    defaultBehavior: DefaultSelection.AllStacks,\n  });\n  selected.processMetadataMessages();\n\n  // THEN\n  expect(selected.firstStack.template.resource).toBe('noerrorresource');\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do throw when selecting stack with errors","suites":[],"updatePoint":{"line":23,"column":47},"line":23,"code":"test('do throw when selecting stack with errors', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const selected = await cxasm.selectStacks({ patterns: ['witherrors'] }, {\n    defaultBehavior: DefaultSelection.AllStacks,\n  });\n\n  // THEN\n  expect(() => selected.processMetadataMessages()).toThrow(/Found errors/);\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"select all top level stacks in the presence of nested assemblies","suites":[],"updatePoint":{"line":36,"column":70},"line":36,"code":"test('select all top level stacks in the presence of nested assemblies', async () => {\n  // GIVEN\n  const cxasm = await testNestedCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ allTopLevel: true, patterns: [] }, { defaultBehavior: DefaultSelection.AllStacks });\n\n  // THEN\n  expect(x.stackCount).toBe(2);\n  expect(x.stackIds).toContain('witherrors');\n  expect(x.stackIds).toContain('withouterrors');\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"select stacks by glob pattern","suites":[],"updatePoint":{"line":49,"column":35},"line":49,"code":"test('select stacks by glob pattern', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: ['with*'] }, { defaultBehavior: DefaultSelection.AllStacks });\n\n  // THEN\n  expect(x.stackCount).toBe(2);\n  expect(x.stackIds).toContain('witherrors');\n  expect(x.stackIds).toContain('withouterrors');\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"select behavior: all","suites":[],"updatePoint":{"line":62,"column":26},"line":62,"code":"test('select behavior: all', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.AllStacks });\n\n  // THEN\n  expect(x.stackCount).toBe(2);\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"select behavior: none","suites":[],"updatePoint":{"line":73,"column":27},"line":73,"code":"test('select behavior: none', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.None });\n\n  // THEN\n  expect(x.stackCount).toBe(0);\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"select behavior: single","suites":[],"updatePoint":{"line":84,"column":29},"line":84,"code":"test('select behavior: single', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  await expect(cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.OnlySingle }))\n    .rejects.toThrow('Since this app includes more than a single stack, specify which stacks to use (wildcards are supported) or specify `--all`');\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"stack list error contains node paths","suites":[],"updatePoint":{"line":93,"column":42},"line":93,"code":"test('stack list error contains node paths', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  await expect(cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.OnlySingle }))\n    .rejects.toThrow('withouterrorsNODEPATH');\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"select behavior: repeat","suites":[],"updatePoint":{"line":102,"column":29},"line":102,"code":"test('select behavior: repeat', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: ['withouterrorsNODEPATH', 'withouterrorsNODEPATH'] }, {\n    defaultBehavior: DefaultSelection.AllStacks,\n  });\n\n  // THEN\n  expect(x.stackCount).toBe(1);\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"select behavior with nested assemblies: all","suites":[],"updatePoint":{"line":115,"column":49},"line":115,"code":"test('select behavior with nested assemblies: all', async () => {\n  // GIVEN\n  const cxasm = await testNestedCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.AllStacks });\n\n  // THEN\n  expect(x.stackCount).toBe(3);\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"select behavior with nested assemblies: none","suites":[],"updatePoint":{"line":126,"column":50},"line":126,"code":"test('select behavior with nested assemblies: none', async () => {\n  // GIVEN\n  const cxasm = await testNestedCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.None });\n\n  // THEN\n  expect(x.stackCount).toBe(0);\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"select behavior with nested assemblies: single","suites":[],"updatePoint":{"line":137,"column":52},"line":137,"code":"test('select behavior with nested assemblies: single', async () => {\n  // GIVEN\n  const cxasm = await testNestedCloudAssembly();\n\n  // WHEN\n  await expect(cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.OnlySingle }))\n    .rejects.toThrow('Since this app includes more than a single stack, specify which stacks to use (wildcards are supported) or specify `--all`');\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"select behavior with nested assemblies: repeat","suites":[],"updatePoint":{"line":146,"column":52},"line":146,"code":"test('select behavior with nested assemblies: repeat', async() => {\n  // GIVEN\n  const cxasm = await testNestedCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: ['deeply/hidden/withouterrors', 'nested'] }, {\n    defaultBehavior: DefaultSelection.AllStacks,\n  });\n\n  // THEN\n  expect(x.stackCount).toBe(2);\n});","file":"api/cloud-assembly.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"is generated for relocatable stacks from old frameworks","suites":["AWS::CDK::Metadata"],"updatePoint":{"line":9,"column":63},"line":9,"code":"  test('is generated for relocatable stacks from old frameworks', async () => {\n    await withFakeCurrentCxVersion('2.0.0', async () => {\n      const cx = await testCloudExecutable({ env: `aws://${cxapi.UNKNOWN_ACCOUNT}/${cxapi.UNKNOWN_REGION}`, versionReporting: true });\n      const cxasm = await cx.synthesize();\n\n      const result = cxasm.stackById('withouterrors').firstStack;\n      const metadata = result.template.Resources && result.template.Resources.CDKMetadata;\n      expect(metadata).toEqual({\n        Type: 'AWS::CDK::Metadata',\n        Properties: {\n          // eslint-disable-next-line @typescript-eslint/no-require-imports\n          Modules: `${require('../../package.json').name}=${require('../../package.json').version}`,\n        },\n        Condition: 'CDKMetadataAvailable',\n      });\n\n      expect(result.template.Conditions?.CDKMetadataAvailable).toBeDefined();\n    });\n  });","file":"api/cloud-executable.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"is generated for stacks in supported regions from old frameworks","suites":["AWS::CDK::Metadata"],"updatePoint":{"line":29,"column":72},"line":29,"code":"  test('is generated for stacks in supported regions from old frameworks', async () => {\n    await withFakeCurrentCxVersion('2.0.0', async () => {\n      const cx = await testCloudExecutable({ env: 'aws://012345678912/us-east-1', versionReporting: true });\n      const cxasm = await cx.synthesize();\n\n      const result = cxasm.stackById('withouterrors').firstStack;\n      const metadata = result.template.Resources && result.template.Resources.CDKMetadata;\n      expect(metadata).toEqual({\n        Type: 'AWS::CDK::Metadata',\n        Properties: {\n          // eslint-disable-next-line @typescript-eslint/no-require-imports\n          Modules: `${require('../../package.json').name}=${require('../../package.json').version}`,\n        },\n      });\n    });\n  });","file":"api/cloud-executable.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"is not generated for stacks in unsupported regions from old frameworks","suites":["AWS::CDK::Metadata"],"updatePoint":{"line":46,"column":78},"line":46,"code":"  test('is not generated for stacks in unsupported regions from old frameworks', async () => {\n    await withFakeCurrentCxVersion('2.0.0', async () => {\n      const cx = await testCloudExecutable({ env: 'aws://012345678912/bermuda-triangle-1337', versionReporting: true });\n      const cxasm = await cx.synthesize();\n\n      const result = cxasm.stackById('withouterrors').firstStack;\n      const metadata = result.template.Resources && result.template.Resources.CDKMetadata;\n      expect(metadata).toBeUndefined();\n    });\n  });","file":"api/cloud-executable.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"is not generated for new frameworks","suites":["AWS::CDK::Metadata"],"updatePoint":{"line":57,"column":43},"line":57,"code":"  test('is not generated for new frameworks', async () => {\n    await withFakeCurrentCxVersion('8.0.0', async () => {\n      const cx = await testCloudExecutable({ env: 'aws://012345678912/us-east-1', versionReporting: true });\n      const cxasm = await cx.synthesize();\n\n      const result = cxasm.stackById('withouterrors').firstStack;\n      const metadata = result.template.Resources && result.template.Resources.CDKMetadata;\n      expect(metadata).toBeUndefined();\n    });\n  });","file":"api/cloud-executable.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"stop executing if context providers are not making progress","suites":["AWS::CDK::Metadata"],"updatePoint":{"line":69,"column":65},"line":69,"code":"test('stop executing if context providers are not making progress', async () => {\n  registerContextProvider(cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER, {\n    async getValue(_: { [key: string]: any }): Promise<any> {\n      return 'foo';\n    },\n  });\n\n  const cloudExecutable = new MockCloudExecutable({\n    stacks: [{\n      stackName: 'thestack',\n      template: { resource: 'noerrorresource' },\n    }],\n    // Always return the same missing keys, synthesis should still finish.\n    missing: [\n      { key: 'abcdef', props: { account: '1324', region: 'us-east-1' }, provider: cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER },\n    ],\n  });\n  const cxasm = await cloudExecutable.synthesize();\n\n  // WHEN\n  await cxasm.selectStacks({ patterns: ['thestack'] }, { defaultBehavior: DefaultSelection.AllStacks });\n\n  // THEN: the test finishes normally});\n});","file":"api/cloud-executable.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"fails if lookups are disabled and missing context is synthesized","suites":["AWS::CDK::Metadata"],"updatePoint":{"line":94,"column":70},"line":94,"code":"test('fails if lookups are disabled and missing context is synthesized', async () => {\n  // GIVEN\n  const cloudExecutable = new MockCloudExecutable({\n    stacks: [{\n      stackName: 'thestack',\n      template: { resource: 'noerrorresource' },\n    }],\n    // Always return the same missing keys, synthesis should still finish.\n    missing: [\n      { key: 'abcdef', props: { account: '1324', region: 'us-east-1' }, provider: cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER },\n    ],\n  });\n  cloudExecutable.configuration.settings.set(['lookups'], false);\n\n  // WHEN\n  await expect(cloudExecutable.synthesize()).rejects.toThrow(/Context lookups have been disabled/);\n});","file":"api/cloud-executable.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passes through hotswap=true to deployStack()","suites":[],"updatePoint":{"line":61,"column":50},"line":61,"code":"test('passes through hotswap=true to deployStack()', async () => {\n  // WHEN\n  await deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n    }),\n    hotswap: HotswapMode.FALL_BACK,\n  });\n\n  // THEN\n  expect(deployStack).toHaveBeenCalledWith(expect.objectContaining({\n    hotswap: HotswapMode.FALL_BACK,\n  }));\n});","file":"api/cloudformation-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"placeholders are substituted in CloudFormation execution role","suites":[],"updatePoint":{"line":76,"column":67},"line":76,"code":"test('placeholders are substituted in CloudFormation execution role', async () => {\n  await deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n      properties: {\n        cloudFormationExecutionRoleArn: 'bloop:${AWS::Region}:${AWS::AccountId}',\n      },\n    }),\n  });\n\n  expect(deployStack).toHaveBeenCalledWith(expect.objectContaining({\n    roleArn: 'bloop:here:123456789012',\n  }));\n});","file":"api/cloudformation-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"role with placeholders is assumed if assumerole is given","suites":[],"updatePoint":{"line":91,"column":62},"line":91,"code":"test('role with placeholders is assumed if assumerole is given', async () => {\n  const mockForEnvironment = jest.fn().mockImplementation(() => { return { sdk: sdkProvider.sdk }; });\n  sdkProvider.forEnvironment = mockForEnvironment;\n\n  await deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n      properties: {\n        assumeRoleArn: 'bloop:${AWS::Region}:${AWS::AccountId}',\n      },\n    }),\n  });\n\n  expect(mockForEnvironment).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.objectContaining({\n    assumeRoleArn: 'bloop:here:123456789012',\n  }));\n});","file":"api/cloudformation-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deployment fails if bootstrap stack is missing","suites":[],"updatePoint":{"line":109,"column":52},"line":109,"code":"test('deployment fails if bootstrap stack is missing', async () => {\n  await expect(deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n      properties: {\n        assumeRoleArn: 'bloop:${AWS::Region}:${AWS::AccountId}',\n        requiresBootstrapStackVersion: 99,\n      },\n    }),\n  })).rejects.toThrow(/requires a bootstrap stack/);\n});","file":"api/cloudformation-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deployment fails if bootstrap stack is too old","suites":[],"updatePoint":{"line":121,"column":52},"line":121,"code":"test('deployment fails if bootstrap stack is too old', async () => {\n  mockSuccessfulBootstrapStackLookup({\n    BootstrapVersion: 5,\n  });\n\n  await expect(deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n      properties: {\n        assumeRoleArn: 'bloop:${AWS::Region}:${AWS::AccountId}',\n        requiresBootstrapStackVersion: 99,\n      },\n    }),\n  })).rejects.toThrow(/requires bootstrap stack version '99', found '5'/);\n});","file":"api/cloudformation-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"if toolkit stack cannot be found but SSM parameter name is present deployment succeeds","suites":[],"updatePoint":{"line":137,"column":92},"line":137,"code":"test('if toolkit stack cannot be found but SSM parameter name is present deployment succeeds', async () => {\n  // FIXME: Mocking a successful bootstrap stack lookup here should not be necessary.\n  // This should fail and return a placeholder failure object.\n  mockSuccessfulBootstrapStackLookup({\n    BootstrapVersion: 2,\n  });\n\n  let requestedParameterName: string;\n  sdkProvider.stubSSM({\n    getParameter(request) {\n      requestedParameterName = request.Name;\n      return {\n        Parameter: {\n          Value: '99',\n        },\n      };\n    },\n  });\n\n  await deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n      properties: {\n        assumeRoleArn: 'bloop:${AWS::Region}:${AWS::AccountId}',\n        requiresBootstrapStackVersion: 99,\n        bootstrapStackVersionSsmParameter: '/some/parameter',\n      },\n    }),\n  });\n\n  expect(requestedParameterName!).toEqual('/some/parameter');\n});","file":"api/cloudformation-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"readCurrentTemplateWithNestedStacks() can handle non-Resources in the template","suites":[],"updatePoint":{"line":170,"column":84},"line":170,"code":"test('readCurrentTemplateWithNestedStacks() can handle non-Resources in the template', async () => {\n  const cfnStack = new FakeCloudformationStack({\n    stackName: 'ParentOfStackWithOutputAndParameter',\n    stackId: 'StackId',\n  });\n  CloudFormationStack.lookup = (async (_, stackName: string) => {\n    switch (stackName) {\n      case 'ParentOfStackWithOutputAndParameter':\n        cfnStack.template = async () => ({\n          Resources: {\n            NestedStack: {\n              Type: 'AWS::CloudFormation::Stack',\n              Properties: {\n                TemplateURL: 'https://www.magic-url.com',\n              },\n              Metadata: {\n                'aws:asset:path': 'one-output-one-param-stack.nested.template.json',\n              },\n            },\n          },\n        });\n        break;\n\n      case 'NestedStack':\n        cfnStack.template = async () => ({\n          Resources: {\n            NestedResource: {\n              Type: 'AWS::Something',\n              Properties: {\n                Property: 'old-value',\n              },\n            },\n          },\n          Parameters: {\n            NestedParam: {\n              Type: 'String',\n            },\n          },\n          Outputs: {\n            NestedOutput: {\n              Value: {\n                Ref: 'NestedResource',\n              },\n            },\n          },\n        });\n        break;\n\n      default:\n        throw new Error('unknown stack name ' + stackName + ' found');\n    }\n\n    return cfnStack;\n  });\n\n  const rootStack = testStack({\n    stackName: 'ParentOfStackWithOutputAndParameter',\n    template: {\n      Resources: {\n        NestedStack: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-output-one-param-stack.nested.template.json',\n          },\n        },\n      },\n    },\n  });\n\n  pushStackResourceSummaries('ParentOfStackWithOutputAndParameter',\n    stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n    ),\n  );\n\n  // WHEN\n  const deployedTemplate = await deployments.readCurrentTemplateWithNestedStacks(rootStack);\n\n  // THEN\n  expect(deployedTemplate).toEqual({\n    Resources: {\n      NestedStack: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              NestedResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'old-value',\n                },\n              },\n            },\n            Outputs: {\n              NestedOutput: {\n                Value: {\n                  Ref: 'NestedResource',\n                },\n              },\n            },\n            Parameters: {\n              NestedParam: {\n                Type: 'String',\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-output-one-param-stack.nested.template.json',\n        },\n      },\n    },\n  });\n\n  expect(rootStack.template).toEqual({\n    Resources: {\n      NestedStack: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              NestedResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'new-value',\n                },\n              },\n            },\n            Outputs: {\n              NestedOutput: {\n                Value: {\n                  Ref: 'NestedResource',\n                },\n              },\n            },\n            Parameters: {\n              NestedParam: {\n                Type: 'Number',\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-output-one-param-stack.nested.template.json',\n        },\n      },\n    },\n  });\n});","file":"api/cloudformation-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"readCurrentTemplateWithNestedStacks() with a 3-level nested + sibling structure works","suites":[],"updatePoint":{"line":325,"column":91},"line":325,"code":"test('readCurrentTemplateWithNestedStacks() with a 3-level nested + sibling structure works', async () => {\n  const cfnStack = new FakeCloudformationStack({\n    stackName: 'MultiLevelRoot',\n    stackId: 'StackId',\n  });\n  CloudFormationStack.lookup = (async (_, stackName: string) => {\n    switch (stackName) {\n      case 'MultiLevelRoot':\n        cfnStack.template = async () => ({\n          Resources: {\n            NestedStack: {\n              Type: 'AWS::CloudFormation::Stack',\n              Properties: {\n                TemplateURL: 'https://www.magic-url.com',\n              },\n              Metadata: {\n                'aws:asset:path': 'one-resource-two-stacks-stack.nested.template.json',\n              },\n            },\n          },\n        });\n        break;\n\n      case 'NestedStack':\n        cfnStack.template = async () => ({\n          Resources: {\n            SomeResource: {\n              Type: 'AWS::Something',\n              Properties: {\n                Property: 'old-value',\n              },\n            },\n            GrandChildStackA: {\n              Type: 'AWS::CloudFormation::Stack',\n              Properties: {\n                TemplateURL: 'https://www.magic-url.com',\n              },\n              Metadata: {\n                'aws:asset:path': 'one-resource-stack.nested.template.json',\n              },\n            },\n            GrandChildStackB: {\n              Type: 'AWS::CloudFormation::Stack',\n              Properties: {\n                TemplateURL: 'https://www.magic-url.com',\n              },\n              Metadata: {\n                'aws:asset:path': 'one-resource-stack.nested.template.json',\n              },\n            },\n          },\n        });\n        break;\n\n      case 'GrandChildStackA':\n        cfnStack.template = async () => ({\n          Resources: {\n            SomeResource: {\n              Type: 'AWS::Something',\n              Properties: {\n                Property: 'old-value',\n              },\n            },\n          },\n        });\n        break;\n\n      case 'GrandChildStackB':\n        cfnStack.template = async () => ({\n          Resources: {\n            SomeResource: {\n              Type: 'AWS::Something',\n              Properties: {\n                Property: 'old-value',\n              },\n            },\n          },\n        });\n        break;\n\n      default:\n        throw new Error('unknown stack name ' + stackName + ' found in deployments.test.ts');\n    }\n\n    return cfnStack;\n  });\n\n  const rootStack = testStack({\n    stackName: 'MultiLevelRoot',\n    template: {\n      Resources: {\n        NestedStack: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-two-stacks-stack.nested.template.json',\n          },\n        },\n      },\n    },\n  });\n\n  pushStackResourceSummaries('MultiLevelRoot',\n    stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n    ),\n  );\n  pushStackResourceSummaries('NestedStack',\n    stackSummaryOf('GrandChildStackA', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackA/abcd',\n    ),\n    stackSummaryOf('GrandChildStackB', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackB/abcd',\n    ),\n  );\n  pushStackResourceSummaries('GrandChildStackA',\n    stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildA/abcd',\n    ),\n  );\n  pushStackResourceSummaries('GrandChildStackB',\n    stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildB/abcd',\n    ),\n  );\n\n  // WHEN\n  const deployedTemplate = await deployments.readCurrentTemplateWithNestedStacks(rootStack);\n\n  // THEN\n  expect(deployedTemplate).toEqual({\n    Resources: {\n      NestedStack: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              GrandChildStackA: {\n                Type: 'AWS::CloudFormation::Stack',\n                Properties: {\n                  TemplateURL: 'https://www.magic-url.com',\n                  NestedTemplate: {\n                    Resources: {\n                      SomeResource: {\n                        Type: 'AWS::Something',\n                        Properties: {\n                          Property: 'old-value',\n                        },\n                      },\n                    },\n                  },\n                },\n                Metadata: {\n                  'aws:asset:path': 'one-resource-stack.nested.template.json',\n                },\n              },\n              GrandChildStackB: {\n                Type: 'AWS::CloudFormation::Stack',\n                Properties: {\n                  TemplateURL: 'https://www.magic-url.com',\n                  NestedTemplate: {\n                    Resources: {\n                      SomeResource: {\n                        Type: 'AWS::Something',\n                        Properties: {\n                          Property: 'old-value',\n                        },\n                      },\n                    },\n                  },\n                },\n                Metadata: {\n                  'aws:asset:path': 'one-resource-stack.nested.template.json',\n                },\n              },\n              SomeResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'old-value',\n                },\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-resource-two-stacks-stack.nested.template.json',\n        },\n      },\n    },\n  });\n\n  expect(rootStack.template).toEqual({\n    Resources: {\n      NestedStack: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              GrandChildStackA: {\n                Type: 'AWS::CloudFormation::Stack',\n                Properties: {\n                  TemplateURL: 'https://www.magic-url.com',\n                  NestedTemplate: {\n                    Resources: {\n                      SomeResource: {\n                        Type: 'AWS::Something',\n                        Properties: {\n                          Property: 'new-value',\n                        },\n                      },\n                    },\n                  },\n                },\n                Metadata: {\n                  'aws:asset:path': 'one-resource-stack.nested.template.json',\n                },\n              },\n              GrandChildStackB: {\n                Type: 'AWS::CloudFormation::Stack',\n                Properties: {\n                  TemplateURL: 'https://www.magic-url.com',\n                  NestedTemplate: {\n                    Resources: {\n                      SomeResource: {\n                        Type: 'AWS::Something',\n                        Properties: {\n                          Property: 'new-value',\n                        },\n                      },\n                    },\n                  },\n                },\n                Metadata: {\n                  'aws:asset:path': 'one-resource-stack.nested.template.json',\n                },\n              },\n              SomeResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'new-value',\n                },\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-resource-two-stacks-stack.nested.template.json',\n        },\n      },\n    },\n  });\n});","file":"api/cloudformation-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"readCurrentTemplateWithNestedStacks() on an undeployed parent stack with an (also undeployed) nested stack works","suites":[],"updatePoint":{"line":582,"column":118},"line":582,"code":"test('readCurrentTemplateWithNestedStacks() on an undeployed parent stack with an (also undeployed) nested stack works', async () => {\n  // GIVEN\n  const cfnStack = new FakeCloudformationStack({\n    stackName: 'UndeployedParent',\n    stackId: 'StackId',\n  });\n  CloudFormationStack.lookup = (async (_cfn, _stackName: string) => {\n    cfnStack.template = async () => ({});\n\n    return cfnStack;\n  });\n  const rootStack = testStack({\n    stackName: 'UndeployedParent',\n    template: {\n      Resources: {\n        NestedStack: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-one-stack-stack.nested.template.json',\n          },\n        },\n      },\n    },\n  });\n\n  // WHEN\n  const deployedTemplate = await deployments.readCurrentTemplateWithNestedStacks(rootStack);\n\n  // THEN\n  expect(deployedTemplate).toEqual({\n    Resources: {\n      NestedStack: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          NestedTemplate: {\n            Resources: {\n              NestedStack: {\n                Type: 'AWS::CloudFormation::Stack',\n                Properties: {\n                  NestedTemplate: {},\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  });\n});","file":"api/cloudformation-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"readCurrentTemplateWithNestedStacks() caches calls to listStackResources()","suites":[],"updatePoint":{"line":635,"column":80},"line":635,"code":"test('readCurrentTemplateWithNestedStacks() caches calls to listStackResources()', async () => {\n  // GIVEN\n  const cfnStack = new FakeCloudformationStack({\n    stackName: 'CachingRoot',\n    stackId: 'StackId',\n  });\n  CloudFormationStack.lookup = (async (_cfn, _stackName: string) => {\n    cfnStack.template = async () => ({\n      Resources:\n      {\n        NestedStackA: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-stack.nested.template.json',\n          },\n        },\n        NestedStackB: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-stack.nested.template.json',\n          },\n        },\n      },\n    });\n\n    return cfnStack;\n  });\n\n  const rootStack = testStack({\n    stackName: 'CachingRoot',\n    template: {\n      Resources: {\n        NestedStackA: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-stack.nested.template.json',\n          },\n        },\n        NestedStackB: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-stack.nested.template.json',\n          },\n        },\n      },\n    },\n  });\n\n  pushStackResourceSummaries('CachingRoot',\n    stackSummaryOf('NestedStackA', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/one-resource-stack/abcd',\n    ),\n    stackSummaryOf('NestedStackB', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/one-resource-stack/abcd',\n    ),\n  );\n\n  // WHEN\n  await deployments.readCurrentTemplateWithNestedStacks(rootStack);\n\n  // THEN\n  expect(numberOfTimesListStackResourcesWasCalled).toEqual(1);\n});","file":"api/cloudformation-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"readCurrentTemplateWithNestedStacks() succesfully ignores stacks without metadata","suites":[],"updatePoint":{"line":711,"column":87},"line":711,"code":"test('readCurrentTemplateWithNestedStacks() succesfully ignores stacks without metadata', async () => {\n  // GIVEN\n  const cfnStack = new FakeCloudformationStack({\n    stackName: 'MetadataRoot',\n    stackId: 'StackId',\n  });\n  CloudFormationStack.lookup = (async (_, stackName: string) => {\n    if (stackName === 'MetadataRoot') {\n      cfnStack.template = async () => ({\n        Resources: {\n          WithMetadata: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-resource-stack.nested.template.json',\n            },\n          },\n        },\n      });\n\n    } else {\n      cfnStack.template = async () => ({\n        Resources: {\n          SomeResource: {\n            Type: 'AWS::Something',\n            Properties: {\n              Property: 'old-value',\n            },\n          },\n        },\n      });\n    }\n\n    return cfnStack;\n  });\n\n  const rootStack = testStack({\n    stackName: 'MetadataRoot',\n    template: {\n      Resources: {\n        WithoutMetadata: {\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Type: 'AWS::CloudFormation::Stack',\n        },\n        WithEmptyMetadata: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {},\n        },\n        WithMetadata: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-stack.nested.template.json',\n          },\n        },\n      },\n    },\n  });\n\n  pushStackResourceSummaries('MetadataRoot', stackSummaryOf('WithMetadata', 'AWS::CloudFormation::Stack',\n    'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/one-resource-stack/abcd',\n  ));\n\n  // WHEN\n  const deployedTemplate = await deployments.readCurrentTemplateWithNestedStacks(rootStack);\n\n  // THEN\n  expect(deployedTemplate).toEqual({\n    Resources: {\n      WithMetadata: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              SomeResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'old-value',\n                },\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-resource-stack.nested.template.json',\n        },\n      },\n    },\n  });\n\n  expect(rootStack.template).toEqual({\n    Resources: {\n      WithoutMetadata: { // Unchanged\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n        },\n      },\n      WithEmptyMetadata: { // Unchanged\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n        },\n        Metadata: {},\n      },\n      WithMetadata: { // Changed\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              SomeResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'new-value',\n                },\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-resource-stack.nested.template.json',\n        },\n      },\n    },\n  });\n});","file":"api/cloudformation-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls tryHotswapDeployment() if 'hotswap' is `HotswapMode.CLASSIC`","suites":[],"updatePoint":{"line":88,"column":72},"line":88,"code":"test(\"calls tryHotswapDeployment() if 'hotswap' is `HotswapMode.CLASSIC`\", async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: HotswapMode.FALL_BACK,\n    extraUserAgent: 'extra-user-agent',\n  });\n\n  // THEN\n  expect(tryHotswapDeployment).toHaveBeenCalled();\n  // check that the extra User-Agent is honored\n  expect(sdk.appendCustomUserAgent).toHaveBeenCalledWith('extra-user-agent');\n  // check that the fallback has been called if hotswapping failed\n  expect(sdk.appendCustomUserAgent).toHaveBeenCalledWith('cdk-hotswap/fallback');\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls tryHotswapDeployment() if 'hotswap' is `HotswapMode.HOTSWAP_ONLY`","suites":[],"updatePoint":{"line":104,"column":77},"line":104,"code":"test(\"calls tryHotswapDeployment() if 'hotswap' is `HotswapMode.HOTSWAP_ONLY`\", async () => {\n  cfnMocks.describeStacks = jest.fn()\n    // we need the first call to return something in the Stacks prop,\n    // otherwise the access to `stackId` will fail\n    .mockImplementation(() => ({\n      Stacks: [\n        {\n          StackStatus: 'CREATE_COMPLETE',\n          StackStatusReason: 'It is magic',\n          EnableTerminationProtection: false,\n        },\n      ],\n    }));\n  sdk.stubCloudFormation(cfnMocks as any);\n  // WHEN\n  const deployStackResult = await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: HotswapMode.HOTSWAP_ONLY,\n    extraUserAgent: 'extra-user-agent',\n    force: true, // otherwise, deployment would be skipped\n  });\n\n  // THEN\n  expect(deployStackResult.noOp).toEqual(true);\n  expect(tryHotswapDeployment).toHaveBeenCalled();\n  // check that the extra User-Agent is honored\n  expect(sdk.appendCustomUserAgent).toHaveBeenCalledWith('extra-user-agent');\n  // check that the fallback has not been called if hotswapping failed\n  expect(sdk.appendCustomUserAgent).not.toHaveBeenCalledWith('cdk-hotswap/fallback');\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"correctly passes CFN parameters when hotswapping","suites":[],"updatePoint":{"line":135,"column":54},"line":135,"code":"test('correctly passes CFN parameters when hotswapping', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: HotswapMode.FALL_BACK,\n    parameters: {\n      A: 'A-value',\n      B: 'B=value',\n      C: undefined,\n      D: '',\n    },\n  });\n\n  // THEN\n  expect(tryHotswapDeployment).toHaveBeenCalledWith(expect.anything(), { A: 'A-value', B: 'B=value' }, expect.anything(), expect.anything(), HotswapMode.FALL_BACK);\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"call CreateStack when method=direct and the stack doesnt exist yet","suites":[],"updatePoint":{"line":152,"column":72},"line":152,"code":"test('call CreateStack when method=direct and the stack doesnt exist yet', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'direct' },\n  });\n\n  // THEN\n  expect(cfnMocks.createStack).toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"call UpdateStack when method=direct and the stack exists already","suites":[],"updatePoint":{"line":163,"column":70},"line":163,"code":"test('call UpdateStack when method=direct and the stack exists already', async () => {\n  // WHEN\n  givenStackExists();\n\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'direct' },\n    force: true,\n  });\n\n  // THEN\n  expect(cfnMocks.updateStack).toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call tryHotswapDeployment() if 'hotswap' is false","suites":[],"updatePoint":{"line":177,"column":64},"line":177,"code":"test(\"does not call tryHotswapDeployment() if 'hotswap' is false\", async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: undefined,\n  });\n\n  // THEN\n  expect(tryHotswapDeployment).not.toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"rollback still defaults to enabled even if 'hotswap' is enabled","suites":[],"updatePoint":{"line":188,"column":69},"line":188,"code":"test(\"rollback still defaults to enabled even if 'hotswap' is enabled\", async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: HotswapMode.FALL_BACK,\n    rollback: undefined,\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalledWith(expect.objectContaining({\n    DisableRollback: true,\n  }));\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"rollback defaults to enabled if 'hotswap' is undefined","suites":[],"updatePoint":{"line":202,"column":60},"line":202,"code":"test(\"rollback defaults to enabled if 'hotswap' is undefined\", async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: undefined,\n    rollback: undefined,\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalledTimes(1);\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalledWith(expect.objectContaining({\n    DisableRollback: expect.anything(),\n  }));\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do deploy executable change set with 0 changes","suites":[],"updatePoint":{"line":217,"column":52},"line":217,"code":"test('do deploy executable change set with 0 changes', async () => {\n  // WHEN\n  const ret = await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(ret.noOp).toBeFalsy();\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"correctly passes CFN parameters, ignoring ones with empty values","suites":[],"updatePoint":{"line":228,"column":70},"line":228,"code":"test('correctly passes CFN parameters, ignoring ones with empty values', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    parameters: {\n      A: 'A-value',\n      B: 'B=value',\n      C: undefined,\n      D: '',\n    },\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    Parameters: [\n      { ParameterKey: 'A', ParameterValue: 'A-value' },\n      { ParameterKey: 'B', ParameterValue: 'B=value' },\n    ],\n  }));\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"reuse previous parameters if requested","suites":[],"updatePoint":{"line":249,"column":44},"line":249,"code":"test('reuse previous parameters if requested', async () => {\n  // GIVEN\n  givenStackExists({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'TheValue' },\n      { ParameterKey: 'HasDefault', ParameterValue: 'TheOldValue' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_WITH_PARAMETERS,\n    parameters: {\n      OtherParameter: 'SomeValue',\n    },\n    usePreviousParameters: true,\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    Parameters: [\n      { ParameterKey: 'HasValue', UsePreviousValue: true },\n      { ParameterKey: 'HasDefault', UsePreviousValue: true },\n      { ParameterKey: 'OtherParameter', ParameterValue: 'SomeValue' },\n    ],\n  }));\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"output written to stdout","suites":["ci=true"],"updatePoint":{"line":285,"column":32},"line":285,"code":"  test('output written to stdout', async () => {\n    // GIVEN\n\n    await deployStack({\n      ...standardDeployStackArguments(),\n    });\n\n    // THEN\n    expect(stderrMock.mock.calls).toEqual([]);\n    expect(stdoutMock.mock.calls).not.toEqual([]);\n  });","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do not reuse previous parameters if not requested","suites":["ci=true"],"updatePoint":{"line":298,"column":55},"line":298,"code":"test('do not reuse previous parameters if not requested', async () => {\n  // GIVEN\n  givenStackExists({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'TheValue' },\n      { ParameterKey: 'HasDefault', ParameterValue: 'TheOldValue' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_WITH_PARAMETERS,\n    parameters: {\n      HasValue: 'SomeValue',\n      OtherParameter: 'SomeValue',\n    },\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'SomeValue' },\n      { ParameterKey: 'OtherParameter', ParameterValue: 'SomeValue' },\n    ],\n  }));\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throw exception if not enough parameters supplied","suites":["ci=true"],"updatePoint":{"line":326,"column":55},"line":326,"code":"test('throw exception if not enough parameters supplied', async () => {\n  // GIVEN\n  givenStackExists({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'TheValue' },\n      { ParameterKey: 'HasDefault', ParameterValue: 'TheOldValue' },\n    ],\n  });\n\n  // WHEN\n  await expect(deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_WITH_PARAMETERS,\n    parameters: {\n      OtherParameter: 'SomeValue',\n    },\n  })).rejects.toThrow(/CloudFormation Parameters are missing a value/);\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deploy is skipped if template did not change","suites":["ci=true"],"updatePoint":{"line":345,"column":50},"line":345,"code":"test('deploy is skipped if template did not change', async () => {\n  // GIVEN\n  givenStackExists();\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).not.toBeCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deploy is skipped if parameters are the same","suites":["ci=true"],"updatePoint":{"line":358,"column":50},"line":358,"code":"test('deploy is skipped if parameters are the same', async () => {\n  // GIVEN\n  givenTemplateIs(FAKE_STACK_WITH_PARAMETERS.template);\n  givenStackExists({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'HasValue' },\n      { ParameterKey: 'HasDefault', ParameterValue: 'HasDefault' },\n      { ParameterKey: 'OtherParameter', ParameterValue: 'OtherParameter' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_WITH_PARAMETERS,\n    parameters: {},\n    usePreviousParameters: true,\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).not.toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deploy is not skipped if parameters are different","suites":["ci=true"],"updatePoint":{"line":381,"column":55},"line":381,"code":"test('deploy is not skipped if parameters are different', async () => {\n  // GIVEN\n  givenTemplateIs(FAKE_STACK_WITH_PARAMETERS.template);\n  givenStackExists({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'HasValue' },\n      { ParameterKey: 'HasDefault', ParameterValue: 'HasDefault' },\n      { ParameterKey: 'OtherParameter', ParameterValue: 'OtherParameter' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_WITH_PARAMETERS,\n    parameters: {\n      HasValue: 'NewValue',\n    },\n    usePreviousParameters: true,\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'NewValue' },\n      { ParameterKey: 'HasDefault', UsePreviousValue: true },\n      { ParameterKey: 'OtherParameter', UsePreviousValue: true },\n    ],\n  }));\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"if existing stack failed to create, it is deleted and recreated","suites":["ci=true"],"updatePoint":{"line":412,"column":69},"line":412,"code":"test('if existing stack failed to create, it is deleted and recreated', async () => {\n  // GIVEN\n  givenStackExists(\n    { StackStatus: 'ROLLBACK_COMPLETE' }, // This is for the initial check\n    { StackStatus: 'DELETE_COMPLETE' }, // Poll the successful deletion\n    { StackStatus: 'CREATE_COMPLETE' }, // Poll the recreation\n  );\n  givenTemplateIs({\n    DifferentThan: 'TheDefault',\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.deleteStack).toHaveBeenCalled();\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    ChangeSetType: 'CREATE',\n  }));\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"if existing stack failed to create, it is deleted and recreated even if the template did not change","suites":["ci=true"],"updatePoint":{"line":435,"column":105},"line":435,"code":"test('if existing stack failed to create, it is deleted and recreated even if the template did not change', async () => {\n  // GIVEN\n  givenStackExists(\n    { StackStatus: 'ROLLBACK_COMPLETE' }, // This is for the initial check\n    { StackStatus: 'DELETE_COMPLETE' }, // Poll the successful deletion\n    { StackStatus: 'CREATE_COMPLETE' }, // Poll the recreation\n  );\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.deleteStack).toHaveBeenCalled();\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    ChangeSetType: 'CREATE',\n  }));\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deploy not skipped if template did not change and --force is applied","suites":["ci=true"],"updatePoint":{"line":455,"column":74},"line":455,"code":"test('deploy not skipped if template did not change and --force is applied', async () => {\n  // GIVEN\n  givenStackExists();\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    force: true,\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deploy is skipped if template and tags did not change","suites":["ci=true"],"updatePoint":{"line":469,"column":59},"line":469,"code":"test('deploy is skipped if template and tags did not change', async () => {\n  // GIVEN\n  givenStackExists({\n    Tags: [\n      { Key: 'Key1', Value: 'Value1' },\n      { Key: 'Key2', Value: 'Value2' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    tags: [\n      { Key: 'Key1', Value: 'Value1' },\n      { Key: 'Key2', Value: 'Value2' },\n    ],\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).not.toBeCalled();\n  expect(cfnMocks.executeChangeSet).not.toBeCalled();\n  expect(cfnMocks.describeStacks).toHaveBeenCalledWith({ StackName: 'withouterrors' });\n  expect(cfnMocks.getTemplate).toHaveBeenCalledWith({ StackName: 'withouterrors', TemplateStage: 'Original' });\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deploy not skipped if template did not change but tags changed","suites":["ci=true"],"updatePoint":{"line":494,"column":68},"line":494,"code":"test('deploy not skipped if template did not change but tags changed', async () => {\n  // GIVEN\n  givenStackExists({\n    Tags: [\n      { Key: 'Key', Value: 'Value' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    stack: FAKE_STACK,\n    sdk,\n    sdkProvider,\n    resolvedEnvironment: mockResolvedEnvironment(),\n    tags: [\n      {\n        Key: 'Key',\n        Value: 'NewValue',\n      },\n    ],\n    toolkitInfo: ToolkitInfo.bootstraplessDeploymentsOnly(sdk),\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.describeChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.describeStacks).toHaveBeenCalledWith({ StackName: 'withouterrors' });\n  expect(cfnMocks.getTemplate).toHaveBeenCalledWith({ StackName: 'withouterrors', TemplateStage: 'Original' });\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deployStack reports no change if describeChangeSet returns specific error","suites":["ci=true"],"updatePoint":{"line":525,"column":79},"line":525,"code":"test('deployStack reports no change if describeChangeSet returns specific error', async () => {\n  cfnMocks.describeChangeSet?.mockImplementation(() => ({\n    Status: 'FAILED',\n    StatusReason: 'No updates are to be performed.',\n  }));\n\n  // WHEN\n  const deployResult = await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(deployResult.noOp).toEqual(true);\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deploy not skipped if template did not change but one tag removed","suites":["ci=true"],"updatePoint":{"line":540,"column":71},"line":540,"code":"test('deploy not skipped if template did not change but one tag removed', async () => {\n  // GIVEN\n  givenStackExists({\n    Tags: [\n      { Key: 'Key1', Value: 'Value1' },\n      { Key: 'Key2', Value: 'Value2' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    tags: [\n      { Key: 'Key1', Value: 'Value1' },\n    ],\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.describeChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.describeStacks).toHaveBeenCalledWith({ StackName: 'withouterrors' });\n  expect(cfnMocks.getTemplate).toHaveBeenCalledWith({ StackName: 'withouterrors', TemplateStage: 'Original' });\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deploy is not skipped if stack is in a _FAILED state","suites":["ci=true"],"updatePoint":{"line":565,"column":58},"line":565,"code":"test('deploy is not skipped if stack is in a _FAILED state', async () => {\n  // GIVEN\n  givenStackExists({\n    StackStatus: 'DELETE_FAILED',\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    usePreviousParameters: true,\n  }).catch(() => {});\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"existing stack in UPDATE_ROLLBACK_COMPLETE state can be updated","suites":["ci=true"],"updatePoint":{"line":581,"column":69},"line":581,"code":"test('existing stack in UPDATE_ROLLBACK_COMPLETE state can be updated', async () => {\n  // GIVEN\n  givenStackExists(\n    { StackStatus: 'UPDATE_ROLLBACK_COMPLETE' }, // This is for the initial check\n    { StackStatus: 'UPDATE_COMPLETE' }, // Poll the update\n  );\n  givenTemplateIs({ changed: 123 });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.deleteStack).not.toHaveBeenCalled();\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    ChangeSetType: 'UPDATE',\n  }));\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deploy not skipped if template changed","suites":["ci=true"],"updatePoint":{"line":601,"column":44},"line":601,"code":"test('deploy not skipped if template changed', async () => {\n  // GIVEN\n  givenStackExists();\n  givenTemplateIs({ changed: 123 });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"not executed and no error if --no-execute is given","suites":["ci=true"],"updatePoint":{"line":615,"column":56},"line":615,"code":"test('not executed and no error if --no-execute is given', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'change-set', execute: false },\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"empty change set is deleted if --execute is given","suites":["ci=true"],"updatePoint":{"line":626,"column":55},"line":626,"code":"test('empty change set is deleted if --execute is given', async () => {\n  cfnMocks.describeChangeSet?.mockImplementation(() => ({\n    Status: 'FAILED',\n    StatusReason: 'No updates are to be performed.',\n  }));\n\n  // GIVEN\n  givenStackExists();\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'change-set', execute: true },\n    force: true, // Necessary to bypass \"skip deploy\"\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalled();\n\n  //the first deletion is for any existing cdk change sets, the second is for the deleting the new empty change set\n  expect(cfnMocks.deleteChangeSet).toHaveBeenCalledTimes(2);\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"empty change set is not deleted if --no-execute is given","suites":["ci=true"],"updatePoint":{"line":650,"column":62},"line":650,"code":"test('empty change set is not deleted if --no-execute is given', async () => {\n  cfnMocks.describeChangeSet?.mockImplementation(() => ({\n    Status: 'FAILED',\n    StatusReason: 'No updates are to be performed.',\n  }));\n\n  // GIVEN\n  givenStackExists();\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'change-set', execute: false },\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalled();\n\n  //the first deletion is for any existing cdk change sets\n  expect(cfnMocks.deleteChangeSet).toHaveBeenCalledTimes(1);\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"use S3 url for stack deployment if present in Stack Artifact","suites":["ci=true"],"updatePoint":{"line":673,"column":66},"line":673,"code":"test('use S3 url for stack deployment if present in Stack Artifact', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: testStack({\n      stackName: 'withouterrors',\n      properties: {\n        stackTemplateAssetObjectUrl: 'https://use-me-use-me/',\n      },\n    }),\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    TemplateURL: 'https://use-me-use-me/',\n  }));\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"use REST API S3 url with substituted placeholders if manifest url starts with s3://","suites":["ci=true"],"updatePoint":{"line":692,"column":89},"line":692,"code":"test('use REST API S3 url with substituted placeholders if manifest url starts with s3://', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: testStack({\n      stackName: 'withouterrors',\n      properties: {\n        stackTemplateAssetObjectUrl: 's3://use-me-use-me-${AWS::AccountId}/object',\n      },\n    }),\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    TemplateURL: 'https://s3.bermuda-triangle-1337.amazonaws.com/use-me-use-me-123456789/object',\n  }));\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"changeset is created when stack exists in REVIEW_IN_PROGRESS status","suites":["ci=true"],"updatePoint":{"line":711,"column":73},"line":711,"code":"test('changeset is created when stack exists in REVIEW_IN_PROGRESS status', async () => {\n  // GIVEN\n  givenStackExists({\n    StackStatus: 'REVIEW_IN_PROGRESS',\n    Tags: [\n      { Key: 'Key1', Value: 'Value1' },\n      { Key: 'Key2', Value: 'Value2' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'change-set', execute: false },\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(\n    expect.objectContaining({\n      ChangeSetType: 'CREATE',\n      StackName: 'withouterrors',\n    }),\n  );\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"changeset is updated when stack exists in CREATE_COMPLETE status","suites":["ci=true"],"updatePoint":{"line":737,"column":70},"line":737,"code":"test('changeset is updated when stack exists in CREATE_COMPLETE status', async () => {\n  // GIVEN\n  givenStackExists({\n    Tags: [\n      { Key: 'Key1', Value: 'Value1' },\n      { Key: 'Key2', Value: 'Value2' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'change-set', execute: false },\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(\n    expect.objectContaining({\n      ChangeSetType: 'UPDATE',\n      StackName: 'withouterrors',\n    }),\n  );\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deploy with termination protection enabled","suites":["ci=true"],"updatePoint":{"line":762,"column":48},"line":762,"code":"test('deploy with termination protection enabled', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_TERMINATION_PROTECTION,\n  });\n\n  // THEN\n  expect(cfnMocks.updateTerminationProtection).toHaveBeenCalledWith(expect.objectContaining({\n    EnableTerminationProtection: true,\n  }));\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"updateTerminationProtection not called when termination protection is undefined","suites":["ci=true"],"updatePoint":{"line":775,"column":85},"line":775,"code":"test('updateTerminationProtection not called when termination protection is undefined', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.updateTerminationProtection).not.toHaveBeenCalled();\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"updateTerminationProtection called when termination protection is undefined and stack has termination protection","suites":["ci=true"],"updatePoint":{"line":785,"column":118},"line":785,"code":"test('updateTerminationProtection called when termination protection is undefined and stack has termination protection', async () => {\n  // GIVEN\n  givenStackExists({\n    EnableTerminationProtection: true,\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.updateTerminationProtection).toHaveBeenCalledWith(expect.objectContaining({\n    EnableTerminationProtection: false,\n  }));\n});","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"by default, we do not disable rollback (and also do not pass the flag)","suites":["disable rollback"],"updatePoint":{"line":803,"column":78},"line":803,"code":"  test('by default, we do not disable rollback (and also do not pass the flag)', async () => {\n    // WHEN\n    await deployStack({\n      ...standardDeployStackArguments(),\n    });\n\n    // THEN\n    expect(cfnMocks.executeChangeSet).toHaveBeenCalledTimes(1);\n    expect(cfnMocks.executeChangeSet).not.toHaveBeenCalledWith(expect.objectContaining({\n      DisableRollback: expect.anything(),\n    }));\n  });","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"rollback can be disabled by setting rollback: false","suites":["disable rollback"],"updatePoint":{"line":816,"column":59},"line":816,"code":"  test('rollback can be disabled by setting rollback: false', async () => {\n    // WHEN\n    await deployStack({\n      ...standardDeployStackArguments(),\n      rollback: false,\n    });\n\n    // THEN\n    expect(cfnMocks.executeChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n      DisableRollback: true,\n    }));\n  });","file":"api/deploy-stack.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"cli throws when manifest version > schema version","suites":[],"updatePoint":{"line":63,"column":55},"line":63,"code":"test('cli throws when manifest version > schema version', async () => {\n\n  const app = createApp();\n  const currentSchemaVersion = cxschema.Manifest.version();\n  const mockManifestVersion = semver.inc(currentSchemaVersion, 'major');\n\n  // this mock will cause the framework to use a greater schema version than the real one,\n  // and should cause the CLI to fail.\n  const mockVersionNumber = ImportMock.mockFunction(cxschema.Manifest, 'version', mockManifestVersion);\n  try {\n    app.synth();\n  } finally {\n    mockVersionNumber.restore();\n  }\n\n  const expectedError = 'This CDK CLI is not compatible with the CDK library used by your application. Please upgrade the CLI to the latest version.'\n    + `\\n(Cloud assembly schema version mismatch: Maximum schema version supported is ${currentSchemaVersion}, but found ${mockManifestVersion})`;\n\n  config.settings.set(['app'], 'cdk.out');\n\n  await expect(execProgram(sdkProvider, config)).rejects.toEqual(new Error(expectedError));\n\n}, TEN_SECOND_TIMEOUT);","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"cli does not throw when manifest version = schema version","suites":[],"updatePoint":{"line":87,"column":63},"line":87,"code":"test('cli does not throw when manifest version = schema version', async () => {\n\n  const app = createApp();\n  app.synth();\n\n  config.settings.set(['app'], 'cdk.out');\n\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n\n}, TEN_SECOND_TIMEOUT);","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"cli does not throw when manifest version < schema version","suites":[],"updatePoint":{"line":99,"column":63},"line":99,"code":"test('cli does not throw when manifest version < schema version', async () => {\n\n  const app = createApp();\n  const currentSchemaVersion = cxschema.Manifest.version();\n\n  app.synth();\n\n  config.settings.set(['app'], 'cdk.out');\n\n  // this mock will cause the cli to think its exepcted schema version is\n  // greater that the version created in the manifest, which is what we are testing for.\n  const mockVersionNumber = ImportMock.mockFunction(cxschema.Manifest, 'version', semver.inc(currentSchemaVersion, 'major'));\n  try {\n    const { lock } = await execProgram(sdkProvider, config);\n    await lock.release();\n  } finally {\n    mockVersionNumber.restore();\n  }\n\n}, TEN_SECOND_TIMEOUT);","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"validates --app key is present","suites":[],"updatePoint":{"line":120,"column":36},"line":120,"code":"test('validates --app key is present', async () => {\n  // GIVEN no config key for `app`\n  await expect(execProgram(sdkProvider, config)).rejects.toThrow(\n    '--app is required either in command-line, in cdk.json or in ~/.cdk.json',\n  );\n\n});","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"bypasses synth when app points to a cloud assembly","suites":[],"updatePoint":{"line":128,"column":56},"line":128,"code":"test('bypasses synth when app points to a cloud assembly', async () => {\n  // GIVEN\n  config.settings.set(['app'], 'cdk.out');\n  writeOutputAssembly();\n\n  // WHEN\n  const { assembly: cloudAssembly, lock } = await execProgram(sdkProvider, config);\n  expect(cloudAssembly.artifacts).toEqual([]);\n  expect(cloudAssembly.directory).toEqual('cdk.out');\n\n  await lock.release();\n});","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"the application set in --app is executed","suites":[],"updatePoint":{"line":141,"column":46},"line":141,"code":"test('the application set in --app is executed', async () => {\n  // GIVEN\n  config.settings.set(['app'], 'cloud-executable');\n  mockSpawn({\n    commandLine: 'cloud-executable',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n});","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"the application set in --app is executed as-is if it contains a filename that does not exist","suites":[],"updatePoint":{"line":154,"column":98},"line":154,"code":"test('the application set in --app is executed as-is if it contains a filename that does not exist', async () => {\n  // GIVEN\n  config.settings.set(['app'], 'does-not-exist');\n  mockSpawn({\n    commandLine: 'does-not-exist',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n});","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"the application set in --app is executed with arguments","suites":[],"updatePoint":{"line":167,"column":61},"line":167,"code":"test('the application set in --app is executed with arguments', async () => {\n  // GIVEN\n  config.settings.set(['app'], 'cloud-executable an-arg');\n  mockSpawn({\n    commandLine: 'cloud-executable an-arg',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n});","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"application set in --app as `*.js` always uses handler on windows","suites":[],"updatePoint":{"line":180,"column":71},"line":180,"code":"test('application set in --app as `*.js` always uses handler on windows', async () => {\n  // GIVEN\n  sinon.stub(process, 'platform').value('win32');\n  config.settings.set(['app'], 'windows.js');\n  mockSpawn({\n    commandLine: process.execPath + ' windows.js',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n});","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"application set in --app is `*.js` and executable","suites":[],"updatePoint":{"line":194,"column":55},"line":194,"code":"test('application set in --app is `*.js` and executable', async () => {\n  // GIVEN\n  config.settings.set(['app'], 'executable-app.js');\n  mockSpawn({\n    commandLine: 'executable-app.js',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n});","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"cli throws when the `build` script fails","suites":[],"updatePoint":{"line":207,"column":46},"line":207,"code":"test('cli throws when the `build` script fails', async () => {\n  // GIVEN\n  config.settings.set(['build'], 'fake-command');\n  mockSpawn({\n    commandLine: 'fake-command',\n    exitCode: 127,\n  });\n\n  // WHEN\n  await expect(execProgram(sdkProvider, config)).rejects.toEqual(new Error('Subprocess exited with error 127'));\n}, TEN_SECOND_TIMEOUT);","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"cli does not throw when the `build` script succeeds","suites":[],"updatePoint":{"line":219,"column":57},"line":219,"code":"test('cli does not throw when the `build` script succeeds', async () => {\n  // GIVEN\n  config.settings.set(['build'], 'real command');\n  config.settings.set(['app'], 'executable-app.js');\n  mockSpawn({\n    commandLine: 'real command', // `build` key is not split on whitespace\n    exitCode: 0,\n  },\n  {\n    commandLine: 'executable-app.js',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n}, TEN_SECOND_TIMEOUT);","file":"api/exec.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p mode","suites":[],"line":17,"code":"describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test(`A new Resolver being added to the Stack returns undefined in CLASSIC mode and\n        returns a noOp in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls the updateResolver() API when it receives only a mapping template difference in a Unit Resolver', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ApiId: 'apiId',\n            FieldName: 'myField',\n            TypeName: 'Query',\n            DataSourceName: 'my-datasource',\n            Kind: 'UNIT',\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf(\n        'AppSyncResolver',\n        'AWS::AppSync::Resolver',\n        'arn:aws:appsync:us-east-1:111111111111:apis/apiId/types/Query/resolvers/myField',\n      ),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ApiId: 'apiId',\n              FieldName: 'myField',\n              TypeName: 'Query',\n              DataSourceName: 'my-datasource',\n              Kind: 'UNIT',\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateResolver).toHaveBeenCalledWith({\n      apiId: 'apiId',\n      dataSourceName: 'my-datasource',\n      typeName: 'Query',\n      fieldName: 'myField',\n      kind: 'UNIT',\n      requestMappingTemplate: '## new request template',\n      responseMappingTemplate: '## original response template',\n    });\n  });\n\n  test('does not call the updateResolver() API when it receives only a mapping template difference in a Pipeline Resolver', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ApiId: 'apiId',\n            FieldName: 'myField',\n            TypeName: 'Query',\n            DataSourceName: 'my-datasource',\n            Kind: 'PIPELINE',\n            PipelineConfig: ['function1'],\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ApiId: 'apiId',\n              FieldName: 'myField',\n              TypeName: 'Query',\n              DataSourceName: 'my-datasource',\n              Kind: 'PIPELINE',\n              PipelineConfig: ['function1'],\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });\n\n  test(`when it receives a change that is not a mapping template difference in a Resolver, it does not call the updateResolver() API in CLASSIC mode\n        but does call the updateResolver() API in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ResponseMappingTemplate: '## original response template',\n            RequestMappingTemplate: '## original request template',\n            FieldName: 'oldField',\n            ApiId: 'apiId',\n            TypeName: 'Query',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf(\n        'AppSyncResolver',\n        'AWS::AppSync::Resolver',\n        'arn:aws:appsync:us-east-1:111111111111:apis/apiId/types/Query/resolvers/myField',\n      ),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ResponseMappingTemplate: '## original response template',\n              RequestMappingTemplate: '## new request template',\n              FieldName: 'newField',\n              ApiId: 'apiId',\n              TypeName: 'Query',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).toHaveBeenCalledWith({\n        apiId: 'apiId',\n        typeName: 'Query',\n        fieldName: 'oldField',\n        requestMappingTemplate: '## new request template',\n        responseMappingTemplate: '## original response template',\n      });\n    }\n  });\n\n  test('does not call the updateResolver() API when a resource with type that is not AWS::AppSync::Resolver but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::NotAResolver',\n          Properties: {\n            RequestMappingTemplate: '## original template',\n            FieldName: 'oldField',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::NotAResolver',\n            Properties: {\n              RequestMappingTemplate: '## new template',\n              FieldName: 'newField',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls the updateFunction() API when it receives only a mapping template difference in a Function', async () => {\n    // GIVEN\n    const mockListFunctions = jest.fn().mockReturnValue({ functions: [{ name: 'my-function', functionId: 'functionId' }] });\n    hotswapMockSdkProvider.stubAppSync({ listFunctions: mockListFunctions, updateFunction: mockUpdateFunction });\n\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::FunctionConfiguration',\n          Properties: {\n            Name: 'my-function',\n            ApiId: 'apiId',\n            DataSourceName: 'my-datasource',\n            FunctionVersion: '2018-05-29',\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::FunctionConfiguration',\n            Properties: {\n              Name: 'my-function',\n              ApiId: 'apiId',\n              DataSourceName: 'my-datasource',\n              FunctionVersion: '2018-05-29',\n              RequestMappingTemplate: '## original request template',\n              ResponseMappingTemplate: '## new response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateFunction).toHaveBeenCalledWith({\n      apiId: 'apiId',\n      dataSourceName: 'my-datasource',\n      functionId: 'functionId',\n      functionVersion: '2018-05-29',\n      name: 'my-function',\n      requestMappingTemplate: '## original request template',\n      responseMappingTemplate: '## new response template',\n    });\n  });\n\n  test(`when it receives a change that is not a mapping template difference in a Function, it does not call the updateFunction() API in CLASSIC mode\n        but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    const mockListFunctions = jest.fn().mockReturnValue({ functions: [{ name: 'my-function', functionId: 'functionId' }] });\n    hotswapMockSdkProvider.stubAppSync({ listFunctions: mockListFunctions, updateFunction: mockUpdateFunction });\n\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::FunctionConfiguration',\n          Properties: {\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n            Name: 'my-function',\n            ApiId: 'apiId',\n            DataSourceName: 'my-datasource',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::FunctionConfiguration',\n            Properties: {\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n              ApiId: 'apiId',\n              Name: 'my-function',\n              DataSourceName: 'new-datasource',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateFunction).toHaveBeenCalledWith({\n        apiId: 'apiId',\n        dataSourceName: 'my-datasource',\n        functionId: 'functionId',\n        name: 'my-function',\n        requestMappingTemplate: '## new request template',\n        responseMappingTemplate: '## original response template',\n      });\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });\n\n  test('does not call the updateFunction() API when a resource with type that is not AWS::AppSync::FunctionConfiguration but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::NotAFunctionConfiguration',\n          Properties: {\n            RequestMappingTemplate: '## original template',\n            Name: 'my-function',\n            DataSourceName: 'my-datasource',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::NotAFunctionConfiguration',\n            Properties: {\n              RequestMappingTemplate: '## new template',\n              Name: 'my-resolver',\n              DataSourceName: 'my-datasource',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });\n});","file":"api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"A new Resolver being added to the Stack returns undefined in CLASSIC mode and\n        returns a noOp in HOTSWAP_ONLY mode","suites":[],"updatePoint":{"line":19,"column":43},"line":18,"code":"  test(`A new Resolver being added to the Stack returns undefined in CLASSIC mode and\n        returns a noOp in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateResolver() API when it receives only a mapping template difference in a Unit Resolver","suites":[],"updatePoint":{"line":52,"column":109},"line":52,"code":"  test('calls the updateResolver() API when it receives only a mapping template difference in a Unit Resolver', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ApiId: 'apiId',\n            FieldName: 'myField',\n            TypeName: 'Query',\n            DataSourceName: 'my-datasource',\n            Kind: 'UNIT',\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf(\n        'AppSyncResolver',\n        'AWS::AppSync::Resolver',\n        'arn:aws:appsync:us-east-1:111111111111:apis/apiId/types/Query/resolvers/myField',\n      ),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ApiId: 'apiId',\n              FieldName: 'myField',\n              TypeName: 'Query',\n              DataSourceName: 'my-datasource',\n              Kind: 'UNIT',\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateResolver).toHaveBeenCalledWith({\n      apiId: 'apiId',\n      dataSourceName: 'my-datasource',\n      typeName: 'Query',\n      fieldName: 'myField',\n      kind: 'UNIT',\n      requestMappingTemplate: '## new request template',\n      responseMappingTemplate: '## original response template',\n    });\n  });","file":"api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the updateResolver() API when it receives only a mapping template difference in a Pipeline Resolver","suites":[],"updatePoint":{"line":118,"column":121},"line":118,"code":"  test('does not call the updateResolver() API when it receives only a mapping template difference in a Pipeline Resolver', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ApiId: 'apiId',\n            FieldName: 'myField',\n            TypeName: 'Query',\n            DataSourceName: 'my-datasource',\n            Kind: 'PIPELINE',\n            PipelineConfig: ['function1'],\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ApiId: 'apiId',\n              FieldName: 'myField',\n              TypeName: 'Query',\n              DataSourceName: 'my-datasource',\n              Kind: 'PIPELINE',\n              PipelineConfig: ['function1'],\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"when it receives a change that is not a mapping template difference in a Resolver, it does not call the updateResolver() API in CLASSIC mode\n        but does call the updateResolver() API in HOTSWAP_ONLY mode","suites":[],"updatePoint":{"line":184,"column":67},"line":183,"code":"  test(`when it receives a change that is not a mapping template difference in a Resolver, it does not call the updateResolver() API in CLASSIC mode\n        but does call the updateResolver() API in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ResponseMappingTemplate: '## original response template',\n            RequestMappingTemplate: '## original request template',\n            FieldName: 'oldField',\n            ApiId: 'apiId',\n            TypeName: 'Query',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf(\n        'AppSyncResolver',\n        'AWS::AppSync::Resolver',\n        'arn:aws:appsync:us-east-1:111111111111:apis/apiId/types/Query/resolvers/myField',\n      ),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ResponseMappingTemplate: '## original response template',\n              RequestMappingTemplate: '## new request template',\n              FieldName: 'newField',\n              ApiId: 'apiId',\n              TypeName: 'Query',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).toHaveBeenCalledWith({\n        apiId: 'apiId',\n        typeName: 'Query',\n        fieldName: 'oldField',\n        requestMappingTemplate: '## new request template',\n        responseMappingTemplate: '## original response template',\n      });\n    }\n  });","file":"api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the updateResolver() API when a resource with type that is not AWS::AppSync::Resolver but has the same properties is changed","suites":[],"updatePoint":{"line":253,"column":146},"line":253,"code":"  test('does not call the updateResolver() API when a resource with type that is not AWS::AppSync::Resolver but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::NotAResolver',\n          Properties: {\n            RequestMappingTemplate: '## original template',\n            FieldName: 'oldField',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::NotAResolver',\n            Properties: {\n              RequestMappingTemplate: '## new template',\n              FieldName: 'newField',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateFunction() API when it receives only a mapping template difference in a Function","suites":[],"updatePoint":{"line":303,"column":104},"line":303,"code":"  test('calls the updateFunction() API when it receives only a mapping template difference in a Function', async () => {\n    // GIVEN\n    const mockListFunctions = jest.fn().mockReturnValue({ functions: [{ name: 'my-function', functionId: 'functionId' }] });\n    hotswapMockSdkProvider.stubAppSync({ listFunctions: mockListFunctions, updateFunction: mockUpdateFunction });\n\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::FunctionConfiguration',\n          Properties: {\n            Name: 'my-function',\n            ApiId: 'apiId',\n            DataSourceName: 'my-datasource',\n            FunctionVersion: '2018-05-29',\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::FunctionConfiguration',\n            Properties: {\n              Name: 'my-function',\n              ApiId: 'apiId',\n              DataSourceName: 'my-datasource',\n              FunctionVersion: '2018-05-29',\n              RequestMappingTemplate: '## original request template',\n              ResponseMappingTemplate: '## new response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateFunction).toHaveBeenCalledWith({\n      apiId: 'apiId',\n      dataSourceName: 'my-datasource',\n      functionId: 'functionId',\n      functionVersion: '2018-05-29',\n      name: 'my-function',\n      requestMappingTemplate: '## original request template',\n      responseMappingTemplate: '## new response template',\n    });\n  });","file":"api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"when it receives a change that is not a mapping template difference in a Function, it does not call the updateFunction() API in CLASSIC mode\n        but does in HOTSWAP_ONLY mode","suites":[],"updatePoint":{"line":364,"column":37},"line":363,"code":"  test(`when it receives a change that is not a mapping template difference in a Function, it does not call the updateFunction() API in CLASSIC mode\n        but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    const mockListFunctions = jest.fn().mockReturnValue({ functions: [{ name: 'my-function', functionId: 'functionId' }] });\n    hotswapMockSdkProvider.stubAppSync({ listFunctions: mockListFunctions, updateFunction: mockUpdateFunction });\n\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::FunctionConfiguration',\n          Properties: {\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n            Name: 'my-function',\n            ApiId: 'apiId',\n            DataSourceName: 'my-datasource',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::FunctionConfiguration',\n            Properties: {\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n              ApiId: 'apiId',\n              Name: 'my-function',\n              DataSourceName: 'new-datasource',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateFunction).toHaveBeenCalledWith({\n        apiId: 'apiId',\n        dataSourceName: 'my-datasource',\n        functionId: 'functionId',\n        name: 'my-function',\n        requestMappingTemplate: '## new request template',\n        responseMappingTemplate: '## original response template',\n      });\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the updateFunction() API when a resource with type that is not AWS::AppSync::FunctionConfiguration but has the same properties is changed","suites":[],"updatePoint":{"line":430,"column":159},"line":430,"code":"  test('does not call the updateFunction() API when a resource with type that is not AWS::AppSync::FunctionConfiguration but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::NotAFunctionConfiguration',\n          Properties: {\n            RequestMappingTemplate: '## original template',\n            Name: 'my-function',\n            DataSourceName: 'my-datasource',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::NotAFunctionConfiguration',\n            Properties: {\n              RequestMappingTemplate: '## new template',\n              Name: 'my-resolver',\n              DataSourceName: 'my-datasource',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p mode","suites":[],"line":15,"code":"describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('returns undefined when a new CodeBuild Project is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls the updateProject() API when it receives only a source difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });\n\n  test('calls the updateProject() API when it receives only a source version difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n            SourceVersion: 'v1',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n              SourceVersion: 'v2',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      sourceVersion: 'v2',\n    });\n  });\n\n  test('calls the updateProject() API when it receives only an environment difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n            Environment: {\n              ComputeType: 'BUILD_GENERAL1_SMALL',\n              EnvironmentVariables: [\n                {\n                  Name: 'SUPER_IMPORTANT_ENV_VAR',\n                  Type: 'PLAINTEXT',\n                  Value: 'super cool value',\n                },\n                {\n                  Name: 'SECOND_IMPORTANT_ENV_VAR',\n                  Type: 'PLAINTEXT',\n                  Value: 'yet another super cool value',\n                },\n              ],\n              Image: 'aws/codebuild/standard:1.0',\n              ImagePullCredentialsType: 'CODEBUILD',\n              PrivilegedMode: false,\n              Type: 'LINUX_CONTAINER',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n              Environment: {\n                ComputeType: 'BUILD_GENERAL1_SMALL',\n                EnvironmentVariables: [\n                  {\n                    Name: 'SUPER_IMPORTANT_ENV_VAR',\n                    Type: 'PLAINTEXT',\n                    Value: 'changed value',\n                  },\n                  {\n                    Name: 'NEW_IMPORTANT_ENV_VAR',\n                    Type: 'PLAINTEXT',\n                    Value: 'new value',\n                  },\n                ],\n                Image: 'aws/codebuild/standard:1.0',\n                ImagePullCredentialsType: 'CODEBUILD',\n                PrivilegedMode: false,\n                Type: 'LINUX_CONTAINER',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      environment: {\n        computeType: 'BUILD_GENERAL1_SMALL',\n        environmentVariables: [\n          {\n            name: 'SUPER_IMPORTANT_ENV_VAR',\n            type: 'PLAINTEXT',\n            value: 'changed value',\n          },\n          {\n            name: 'NEW_IMPORTANT_ENV_VAR',\n            type: 'PLAINTEXT',\n            value: 'new value',\n          },\n        ],\n        image: 'aws/codebuild/standard:1.0',\n        imagePullCredentialsType: 'CODEBUILD',\n        privilegedMode: false,\n        type: 'LINUX_CONTAINER',\n      },\n    });\n  });\n\n  test(\"correctly evaluates the project's name when it references a different resource from the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: {\n              'Fn::Join': ['-', [\n                { Ref: 'Bucket' },\n                'project',\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'mybucket'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: {\n                'Fn::Join': ['-', [\n                  { Ref: 'Bucket' },\n                  'project',\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'mybucket-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });\n\n  test(\"correctly falls back to taking the project's name from the current stack if it can't evaluate it in the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n        AssetBucketParam: { Type: 'String' },\n      },\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: { Ref: 'Param1' },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n          AssetBucketParam: { Type: 'String' },\n        },\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: { Ref: 'Param1' },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetBucketParam: 'asset-bucket' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });\n\n  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the project's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: { 'Fn::Sub': '${Param1}' },\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: { 'Fn::Sub': '${Param1}' },\n                Type: 'CODEPIPELINE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });\n\n  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the project's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                Type: 'S3',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });\n\n  test('calls the updateProject() API when it receives a difference in a CodeBuild project with no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'current-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'current-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'mock-project-resource-id'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'mock-project-resource-id',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });\n\n  test('does not call the updateProject() API when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            ConcurrentBuildLimit: 1,\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              ConcurrentBuildLimit: 2,\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });\n\n  test(`when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project alongside a hotswappable change,\n        it does not call the updateProject() API in CLASSIC mode, but it does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            ConcurrentBuildLimit: 1,\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              ConcurrentBuildLimit: 2,\n            },\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'mock-project-resource-id'));\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateProject).toHaveBeenCalledWith({\n        name: 'mock-project-resource-id',\n        source: {\n          type: 'NO_SOURCE',\n          buildspec: 'new-spec',\n        },\n      });\n    }\n  });\n  test('does not call the updateProject() API when a resource with type that is not AWS::CodeBuild::Project but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::NotCodeBuild::NotAProject',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::NotCodeBuild::NotAProject',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });\n});","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns undefined when a new CodeBuild Project is added to the Stack","suites":[],"updatePoint":{"line":16,"column":76},"line":16,"code":"  test('returns undefined when a new CodeBuild Project is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateProject() API when it receives only a source difference in a CodeBuild project","suites":[],"updatePoint":{"line":46,"column":102},"line":46,"code":"  test('calls the updateProject() API when it receives only a source difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateProject() API when it receives only a source version difference in a CodeBuild project","suites":[],"updatePoint":{"line":99,"column":110},"line":99,"code":"  test('calls the updateProject() API when it receives only a source version difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n            SourceVersion: 'v1',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n              SourceVersion: 'v2',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      sourceVersion: 'v2',\n    });\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateProject() API when it receives only an environment difference in a CodeBuild project","suites":[],"updatePoint":{"line":151,"column":108},"line":151,"code":"  test('calls the updateProject() API when it receives only an environment difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n            Environment: {\n              ComputeType: 'BUILD_GENERAL1_SMALL',\n              EnvironmentVariables: [\n                {\n                  Name: 'SUPER_IMPORTANT_ENV_VAR',\n                  Type: 'PLAINTEXT',\n                  Value: 'super cool value',\n                },\n                {\n                  Name: 'SECOND_IMPORTANT_ENV_VAR',\n                  Type: 'PLAINTEXT',\n                  Value: 'yet another super cool value',\n                },\n              ],\n              Image: 'aws/codebuild/standard:1.0',\n              ImagePullCredentialsType: 'CODEBUILD',\n              PrivilegedMode: false,\n              Type: 'LINUX_CONTAINER',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n              Environment: {\n                ComputeType: 'BUILD_GENERAL1_SMALL',\n                EnvironmentVariables: [\n                  {\n                    Name: 'SUPER_IMPORTANT_ENV_VAR',\n                    Type: 'PLAINTEXT',\n                    Value: 'changed value',\n                  },\n                  {\n                    Name: 'NEW_IMPORTANT_ENV_VAR',\n                    Type: 'PLAINTEXT',\n                    Value: 'new value',\n                  },\n                ],\n                Image: 'aws/codebuild/standard:1.0',\n                ImagePullCredentialsType: 'CODEBUILD',\n                PrivilegedMode: false,\n                Type: 'LINUX_CONTAINER',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      environment: {\n        computeType: 'BUILD_GENERAL1_SMALL',\n        environmentVariables: [\n          {\n            name: 'SUPER_IMPORTANT_ENV_VAR',\n            type: 'PLAINTEXT',\n            value: 'changed value',\n          },\n          {\n            name: 'NEW_IMPORTANT_ENV_VAR',\n            type: 'PLAINTEXT',\n            value: 'new value',\n          },\n        ],\n        image: 'aws/codebuild/standard:1.0',\n        imagePullCredentialsType: 'CODEBUILD',\n        privilegedMode: false,\n        type: 'LINUX_CONTAINER',\n      },\n    });\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"correctly evaluates the project's name when it references a different resource from the template","suites":[],"updatePoint":{"line":257,"column":104},"line":257,"code":"  test(\"correctly evaluates the project's name when it references a different resource from the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: {\n              'Fn::Join': ['-', [\n                { Ref: 'Bucket' },\n                'project',\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'mybucket'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: {\n                'Fn::Join': ['-', [\n                  { Ref: 'Bucket' },\n                  'project',\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'mybucket-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"correctly falls back to taking the project's name from the current stack if it can't evaluate it in the template","suites":[],"updatePoint":{"line":327,"column":120},"line":327,"code":"  test(\"correctly falls back to taking the project's name from the current stack if it can't evaluate it in the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n        AssetBucketParam: { Type: 'String' },\n      },\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: { Ref: 'Param1' },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n          AssetBucketParam: { Type: 'String' },\n        },\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: { Ref: 'Param1' },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetBucketParam: 'asset-bucket' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"will not perform a hotswap deployment if it cannot find a Ref target (outside the project's name)","suites":[],"updatePoint":{"line":389,"column":105},"line":389,"code":"  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the project's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: { 'Fn::Sub': '${Param1}' },\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: { 'Fn::Sub': '${Param1}' },\n                Type: 'CODEPIPELINE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the project's name)","suites":[],"updatePoint":{"line":439,"column":128},"line":439,"code":"  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the project's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                Type: 'S3',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateProject() API when it receives a difference in a CodeBuild project with no name","suites":[],"updatePoint":{"line":492,"column":103},"line":492,"code":"  test('calls the updateProject() API when it receives a difference in a CodeBuild project with no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'current-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'current-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'mock-project-resource-id'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'mock-project-resource-id',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the updateProject() API when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project","suites":[],"updatePoint":{"line":544,"column":155},"line":544,"code":"  test('does not call the updateProject() API when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            ConcurrentBuildLimit: 1,\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              ConcurrentBuildLimit: 2,\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project alongside a hotswappable change,\n        it does not call the updateProject() API in CLASSIC mode, but it does in HOTSWAP_ONLY mode","suites":[],"updatePoint":{"line":596,"column":98},"line":595,"code":"  test(`when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project alongside a hotswappable change,\n        it does not call the updateProject() API in CLASSIC mode, but it does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            ConcurrentBuildLimit: 1,\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              ConcurrentBuildLimit: 2,\n            },\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'mock-project-resource-id'));\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateProject).toHaveBeenCalledWith({\n        name: 'mock-project-resource-id',\n        source: {\n          type: 'NO_SOURCE',\n          buildspec: 'new-spec',\n        },\n      });\n    }\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the updateProject() API when a resource with type that is not AWS::CodeBuild::Project but has the same properties is changed","suites":[],"updatePoint":{"line":653,"column":146},"line":653,"code":"  test('does not call the updateProject() API when a resource with type that is not AWS::CodeBuild::Project but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::NotCodeBuild::NotAProject',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::NotCodeBuild::NotAProject',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/code-build-projects-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p mode","suites":[],"line":33,"code":"describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('should call registerTaskDefinition and updateService for a difference only in the TaskDefinition with a Family property', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        { image: 'image2' },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });\n\n  test('any other TaskDefinition property change besides ContainerDefinition cannot be hotswapped in CLASSIC mode but does not block HOTSWAP_ONLY mode deployments', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Cpu: '256',\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n              Cpu: '512',\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n        cpu: '256', // this uses the old value because a new value could cause a service replacement\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });\n\n  test('deleting any other TaskDefinition property besides ContainerDefinition results in a full deployment in CLASSIC mode and a hotswap deployment in HOTSWAP_ONLY mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Cpu: '256',\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n        cpu: '256', // this uses the old value because a new value could cause a service replacement\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });\n\n  test('should call registerTaskDefinition and updateService for a difference only in the TaskDefinition without a Family property', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('TaskDef', 'AWS::ECS::TaskDefinition',\n        'arn:aws:ecs:region:account:task-definition/my-task-def:2'),\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        { image: 'image2' },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });\n\n  test('a difference just in a TaskDefinition, without any services using it, is not hotswappable in FALL_BACK mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('TaskDef', 'AWS::ECS::TaskDefinition',\n        'arn:aws:ecs:region:account:task-definition/my-task-def:2'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n      });\n\n      expect(mockUpdateService).not.toHaveBeenCalledWith();\n    }\n  });\n\n  test('if anything besides an ECS Service references the changed TaskDefinition, hotswapping is not possible in CLASSIC mode but is possible in HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n        Function: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Environment: {\n              Variables: {\n                TaskDefRevArn: { Ref: 'TaskDef' },\n              },\n            },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n          Function: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Environment: {\n                Variables: {\n                  TaskDefRevArn: { Ref: 'TaskDef' },\n                },\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });\n\n  test('should call registerTaskDefinition with certain properties not lowercased', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Volumes: [\n              {\n                DockerVolumeConfiguration: {\n                  DriverOpts: { Option1: 'option1' },\n                  Labels: { Label1: 'label1' },\n                },\n              },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                {\n                  Image: 'image2',\n                  DockerLabels: { Label1: 'label1' },\n                  FirelensConfiguration: {\n                    Options: { Name: 'cloudwatch' },\n                  },\n                  LogConfiguration: {\n                    Options: { Option1: 'option1' },\n                  },\n                },\n              ],\n              Volumes: [\n                {\n                  DockerVolumeConfiguration: {\n                    DriverOpts: { Option1: 'option1' },\n                    Labels: { Label1: 'label1' },\n                  },\n                },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        {\n          image: 'image2',\n          dockerLabels: { Label1: 'label1' },\n          firelensConfiguration: {\n            options: {\n              Name: 'cloudwatch',\n            },\n          },\n          logConfiguration: {\n            options: { Option1: 'option1' },\n          },\n        },\n      ],\n      volumes: [\n        {\n          dockerVolumeConfiguration: {\n            driverOpts: { Option1: 'option1' },\n            labels: { Label1: 'label1' },\n          },\n        },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });\n});","file":"api/hotswap/ecs-services-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"should call registerTaskDefinition and updateService for a difference only in the TaskDefinition with a Family property","suites":[],"updatePoint":{"line":34,"column":127},"line":34,"code":"  test('should call registerTaskDefinition and updateService for a difference only in the TaskDefinition with a Family property', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        { image: 'image2' },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });","file":"api/hotswap/ecs-services-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"any other TaskDefinition property change besides ContainerDefinition cannot be hotswapped in CLASSIC mode but does not block HOTSWAP_ONLY mode deployments","suites":[],"updatePoint":{"line":108,"column":162},"line":108,"code":"  test('any other TaskDefinition property change besides ContainerDefinition cannot be hotswapped in CLASSIC mode but does not block HOTSWAP_ONLY mode deployments', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Cpu: '256',\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n              Cpu: '512',\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n        cpu: '256', // this uses the old value because a new value could cause a service replacement\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });","file":"api/hotswap/ecs-services-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deleting any other TaskDefinition property besides ContainerDefinition results in a full deployment in CLASSIC mode and a hotswap deployment in HOTSWAP_ONLY mode","suites":[],"updatePoint":{"line":195,"column":169},"line":195,"code":"  test('deleting any other TaskDefinition property besides ContainerDefinition results in a full deployment in CLASSIC mode and a hotswap deployment in HOTSWAP_ONLY mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Cpu: '256',\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n        cpu: '256', // this uses the old value because a new value could cause a service replacement\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });","file":"api/hotswap/ecs-services-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"should call registerTaskDefinition and updateService for a difference only in the TaskDefinition without a Family property","suites":[],"updatePoint":{"line":281,"column":130},"line":281,"code":"  test('should call registerTaskDefinition and updateService for a difference only in the TaskDefinition without a Family property', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('TaskDef', 'AWS::ECS::TaskDefinition',\n        'arn:aws:ecs:region:account:task-definition/my-task-def:2'),\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        { image: 'image2' },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });","file":"api/hotswap/ecs-services-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"a difference just in a TaskDefinition, without any services using it, is not hotswappable in FALL_BACK mode","suites":[],"updatePoint":{"line":355,"column":115},"line":355,"code":"  test('a difference just in a TaskDefinition, without any services using it, is not hotswappable in FALL_BACK mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('TaskDef', 'AWS::ECS::TaskDefinition',\n        'arn:aws:ecs:region:account:task-definition/my-task-def:2'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n      });\n\n      expect(mockUpdateService).not.toHaveBeenCalledWith();\n    }\n  });","file":"api/hotswap/ecs-services-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"if anything besides an ECS Service references the changed TaskDefinition, hotswapping is not possible in CLASSIC mode but is possible in HOTSWAP_ONLY","suites":[],"updatePoint":{"line":418,"column":157},"line":418,"code":"  test('if anything besides an ECS Service references the changed TaskDefinition, hotswapping is not possible in CLASSIC mode but is possible in HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n        Function: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Environment: {\n              Variables: {\n                TaskDefRevArn: { Ref: 'TaskDef' },\n              },\n            },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n          Function: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Environment: {\n                Variables: {\n                  TaskDefRevArn: { Ref: 'TaskDef' },\n                },\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });","file":"api/hotswap/ecs-services-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"should call registerTaskDefinition with certain properties not lowercased","suites":[],"updatePoint":{"line":522,"column":81},"line":522,"code":"  test('should call registerTaskDefinition with certain properties not lowercased', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Volumes: [\n              {\n                DockerVolumeConfiguration: {\n                  DriverOpts: { Option1: 'option1' },\n                  Labels: { Label1: 'label1' },\n                },\n              },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                {\n                  Image: 'image2',\n                  DockerLabels: { Label1: 'label1' },\n                  FirelensConfiguration: {\n                    Options: { Name: 'cloudwatch' },\n                  },\n                  LogConfiguration: {\n                    Options: { Option1: 'option1' },\n                  },\n                },\n              ],\n              Volumes: [\n                {\n                  DockerVolumeConfiguration: {\n                    DriverOpts: { Option1: 'option1' },\n                    Labels: { Label1: 'label1' },\n                  },\n                },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        {\n          image: 'image2',\n          dockerLabels: { Label1: 'label1' },\n          firelensConfiguration: {\n            options: {\n              Name: 'cloudwatch',\n            },\n          },\n          logConfiguration: {\n            options: { Option1: 'option1' },\n          },\n        },\n      ],\n      volumes: [\n        {\n          dockerVolumeConfiguration: {\n            driverOpts: { Option1: 'option1' },\n            labels: { Label1: 'label1' },\n          },\n        },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });","file":"api/hotswap/ecs-services-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p mode","suites":[],"line":24,"code":"describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('returns a deployStackResult with noOp=true when it receives an empty set of changes', async () => {\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, setup.cdkStackArtifactOf());\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toBeTruthy();\n    expect(deployStackResult?.stackArn).toEqual(setup.STACK_ID);\n  });\n\n  test('A change to only a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        SomethingElse: {\n          Type: 'AWS::CloudFormation::SomethingElse',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          SomethingElse: {\n            Type: 'AWS::CloudFormation::SomethingElse',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test('A change to both a hotswappable resource and a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n        SomethingElse: {\n          Type: 'AWS::CloudFormation::SomethingElse',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n          SomethingElse: {\n            Type: 'AWS::CloudFormation::SomethingElse',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });\n\n  test('changes only to CDK::Metadata result in a noOp', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        MetaData: {\n          Type: 'AWS::CDK::Metadata',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          MetaData: {\n            Type: 'AWS::CDK::Metadata',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toEqual(true);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n  });\n\n  test('resource deletions require full deployments for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf();\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test('can correctly reference AWS::Partition in hotswappable changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': [\n                '',\n                [\n                  { Ref: 'AWS::Partition' },\n                  '-',\n                  'my-function',\n                ],\n              ],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'new-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': [\n                  '',\n                  [\n                    { Ref: 'AWS::Partition' },\n                    '-',\n                    'my-function',\n                  ],\n                ],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'aws-my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('can correctly reference AWS::URLSuffix in hotswappable changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': ['', [\n                'my-function-',\n                { Ref: 'AWS::URLSuffix' },\n                '-',\n                { Ref: 'AWS::URLSuffix' },\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': ['', [\n                  'my-function-',\n                  { Ref: 'AWS::URLSuffix' },\n                  '-',\n                  { Ref: 'AWS::URLSuffix' },\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function-amazonaws.com-amazonaws.com',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockGetEndpointSuffix).toHaveBeenCalledTimes(1);\n\n    // the User-Agent is set correctly\n    expect(hotswapMockSdkProvider.mockSdkProvider.sdk.appendCustomUserAgent)\n      .toHaveBeenCalledWith('cdk-hotswap/success-lambda');\n    expect(hotswapMockSdkProvider.mockSdkProvider.sdk.removeCustomUserAgent)\n      .toHaveBeenCalledWith('cdk-hotswap/success-lambda');\n  });\n\n  test('changing the type of a deployed resource always results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        SharedLogicalId: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'new-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          SharedLogicalId: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test('A change to both a hotswappable resource and a stack output results in a full deployment for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n      Outputs: {\n        SomeOutput: {\n          Value: 'old-value',\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n        Outputs: {\n          SomeOutput: {\n            Value: 'new-value',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });\n\n  test('Multiple CfnEvaluationException will not cause unhandled rejections', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func1: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            Environment: {\n              key: 'old',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n        Func2: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            Environment: {\n              key: 'old',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func1: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              Environment: {\n                key: { Ref: 'ErrorResource' },\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n          Func2: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              Environment: {\n                key: { Ref: 'ErrorResource' },\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    await expect(deployStackResult).rejects.toThrowError(CfnEvaluationException);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n  });\n\n  test('deleting a resource and making a hotswappable change results in full deployments for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n    }\n  });\n});","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns a deployStackResult with noOp=true when it receives an empty set of changes","suites":[],"updatePoint":{"line":25,"column":91},"line":25,"code":"  test('returns a deployStackResult with noOp=true when it receives an empty set of changes', async () => {\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, setup.cdkStackArtifactOf());\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toBeTruthy();\n    expect(deployStackResult?.stackArn).toEqual(setup.STACK_ID);\n  });","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"A change to only a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY","suites":[],"updatePoint":{"line":35,"column":121},"line":35,"code":"  test('A change to only a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        SomethingElse: {\n          Type: 'AWS::CloudFormation::SomethingElse',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          SomethingElse: {\n            Type: 'AWS::CloudFormation::SomethingElse',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"A change to both a hotswappable resource and a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY","suites":[],"updatePoint":{"line":80,"column":149},"line":80,"code":"  test('A change to both a hotswappable resource and a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n        SomethingElse: {\n          Type: 'AWS::CloudFormation::SomethingElse',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n          SomethingElse: {\n            Type: 'AWS::CloudFormation::SomethingElse',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"changes only to CDK::Metadata result in a noOp","suites":[],"updatePoint":{"line":154,"column":54},"line":154,"code":"  test('changes only to CDK::Metadata result in a noOp', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        MetaData: {\n          Type: 'AWS::CDK::Metadata',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          MetaData: {\n            Type: 'AWS::CDK::Metadata',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toEqual(true);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n  });","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"resource deletions require full deployments for HOTSWAP and a noOp for HOTSWAP_ONLY","suites":[],"updatePoint":{"line":189,"column":91},"line":189,"code":"  test('resource deletions require full deployments for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf();\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can correctly reference AWS::Partition in hotswappable changes","suites":[],"updatePoint":{"line":220,"column":70},"line":220,"code":"  test('can correctly reference AWS::Partition in hotswappable changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': [\n                '',\n                [\n                  { Ref: 'AWS::Partition' },\n                  '-',\n                  'my-function',\n                ],\n              ],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'new-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': [\n                  '',\n                  [\n                    { Ref: 'AWS::Partition' },\n                    '-',\n                    'my-function',\n                  ],\n                ],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'aws-my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can correctly reference AWS::URLSuffix in hotswappable changes","suites":[],"updatePoint":{"line":289,"column":70},"line":289,"code":"  test('can correctly reference AWS::URLSuffix in hotswappable changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': ['', [\n                'my-function-',\n                { Ref: 'AWS::URLSuffix' },\n                '-',\n                { Ref: 'AWS::URLSuffix' },\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': ['', [\n                  'my-function-',\n                  { Ref: 'AWS::URLSuffix' },\n                  '-',\n                  { Ref: 'AWS::URLSuffix' },\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function-amazonaws.com-amazonaws.com',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockGetEndpointSuffix).toHaveBeenCalledTimes(1);\n\n    // the User-Agent is set correctly\n    expect(hotswapMockSdkProvider.mockSdkProvider.sdk.appendCustomUserAgent)\n      .toHaveBeenCalledWith('cdk-hotswap/success-lambda');\n    expect(hotswapMockSdkProvider.mockSdkProvider.sdk.removeCustomUserAgent)\n      .toHaveBeenCalledWith('cdk-hotswap/success-lambda');\n  });","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"changing the type of a deployed resource always results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY","suites":[],"updatePoint":{"line":361,"column":124},"line":361,"code":"  test('changing the type of a deployed resource always results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        SharedLogicalId: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'new-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          SharedLogicalId: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"A change to both a hotswappable resource and a stack output results in a full deployment for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY","suites":[],"updatePoint":{"line":411,"column":150},"line":411,"code":"  test('A change to both a hotswappable resource and a stack output results in a full deployment for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n      Outputs: {\n        SomeOutput: {\n          Value: 'old-value',\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n        Outputs: {\n          SomeOutput: {\n            Value: 'new-value',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Multiple CfnEvaluationException will not cause unhandled rejections","suites":[],"updatePoint":{"line":483,"column":75},"line":483,"code":"  test('Multiple CfnEvaluationException will not cause unhandled rejections', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func1: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            Environment: {\n              key: 'old',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n        Func2: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            Environment: {\n              key: 'old',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func1: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              Environment: {\n                key: { Ref: 'ErrorResource' },\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n          Func2: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              Environment: {\n                key: { Ref: 'ErrorResource' },\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    await expect(deployStackResult).rejects.toThrowError(CfnEvaluationException);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n  });","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deleting a resource and making a hotswappable change results in full deployments for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY","suites":[],"updatePoint":{"line":569,"column":142},"line":569,"code":"  test('deleting a resource and making a hotswappable change results in full deployments for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n    }\n  });","file":"api/hotswap/hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p mode","suites":[],"line":33,"code":"describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ImageUri: 'current-image',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ImageUri: 'new-image',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ImageUri: 'new-image',\n    });\n  });\n\n  test('calls the getFunction() API with a delay of 5', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ImageUri: 'current-image',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ImageUri: 'new-image',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(mockMakeRequest).toHaveBeenCalledWith('getFunction', { FunctionName: 'my-function' });\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 5,\n      }),\n    }));\n  });\n});","file":"api/hotswap/lambda-functions-docker-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateLambdaCode() API when it receives only a code difference in a Lambda function","suites":[],"updatePoint":{"line":34,"column":101},"line":34,"code":"  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ImageUri: 'current-image',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ImageUri: 'new-image',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ImageUri: 'new-image',\n    });\n  });","file":"api/hotswap/lambda-functions-docker-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the getFunction() API with a delay of 5","suites":[],"updatePoint":{"line":82,"column":53},"line":82,"code":"  test('calls the getFunction() API with a delay of 5', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ImageUri: 'current-image',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ImageUri: 'new-image',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(mockMakeRequest).toHaveBeenCalledWith('getFunction', { FunctionName: 'my-function' });\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 5,\n      }),\n    }));\n  });","file":"api/hotswap/lambda-functions-docker-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p mode","suites":[],"line":30,"code":"describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('returns undefined when a new Lambda function is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test(\"correctly evaluates the function's name when it references a different resource from the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': ['-', [\n                'lambda',\n                { Ref: 'Bucket' },\n                'function',\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'mybucket'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': ['-', [\n                  'lambda',\n                  { Ref: 'Bucket' },\n                  'function',\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'lambda-mybucket-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test(\"correctly falls back to taking the function's name from the current stack if it can't evaluate it in the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n        AssetBucketParam: { Type: 'String' },\n      },\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { Ref: 'AssetBucketParam' },\n              S3Key: 'current-key',\n            },\n            FunctionName: { Ref: 'Param1' },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-function'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n          AssetBucketParam: { Type: 'String' },\n        },\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { Ref: 'AssetBucketParam' },\n                S3Key: 'new-key',\n              },\n              FunctionName: { Ref: 'Param1' },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetBucketParam: 'asset-bucket' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'asset-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the function's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { 'Fn::Sub': '${Param1}' },\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { 'Fn::Sub': '${Param1}' },\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });\n\n  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the function's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });\n\n  test('calls the updateLambdaCode() API when it receives a code difference in a Lambda function with no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'current-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'current-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'mock-function-resource-id'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'mock-function-resource-id',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('does not call the updateLambdaCode() API when it receives a change that is not a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            PackageType: 'Zip',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              PackageType: 'Image',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test(`when it receives a non-hotswappable change that includes a code difference in a Lambda function, it does not call the updateLambdaCode()\n        API in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n            PackageType: 'Zip',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n              PackageType: 'Image',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n    }\n  });\n\n  test('does not call the updateLambdaCode() API when a resource with type that is not AWS::Lambda::Function but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::NotLambda::NotAFunction',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::NotLambda::NotAFunction',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls getFunction() after function code is updated with delay 1', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(mockMakeRequest).toHaveBeenCalledWith('getFunction', { FunctionName: 'my-function' });\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 1,\n      }),\n    }));\n  });\n\n  test('calls getFunction() after function code is updated and VpcId is empty string with delay 1', async () => {\n    // GIVEN\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({\n      VpcConfig: {\n        VpcId: '',\n      },\n    });\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 1,\n      }),\n    }));\n  });\n\n  test('calls getFunction() after function code is updated on a VPC function with delay 5', async () => {\n    // GIVEN\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({\n      VpcConfig: {\n        VpcId: 'abc',\n      },\n    });\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 5,\n      }),\n    }));\n  });\n\n  test('calls the updateLambdaConfiguration() API when it receives difference in Description field of a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Description: 'Old Description',\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Description: 'New Description',\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Description: 'New Description',\n    });\n  });\n\n  test('calls the updateLambdaConfiguration() API when it receives difference in Environment field of a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Environment: {\n              Variables: {\n                Key1: 'Value1',\n                Key2: 'Value2',\n              },\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Environment: {\n                Variables: {\n                  Key1: 'Value1',\n                  Key2: 'Value2',\n                  NewKey: 'NewValue',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Environment: {\n        Variables: {\n          Key1: 'Value1',\n          Key2: 'Value2',\n          NewKey: 'NewValue',\n        },\n      },\n    });\n  });\n\n  test('calls both updateLambdaCode() and updateLambdaConfiguration() API when it receives both code and configuration change', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n            Description: 'Old Description',\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'new-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n              Description: 'New Description',\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Description: 'New Description',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('Lambda hotswap works properly with changes of environment variables and description with tokens', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        EventBus: {\n          Type: 'AWS::Events::EventBus',\n          Properties: {\n            Name: 'my-event-bus',\n          },\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Environment: {\n              Variables: {\n                token: { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                literal: 'oldValue',\n              },\n            },\n            Description: {\n              'Fn::Join': ['', [\n                'oldValue',\n                { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('EventBus', 'AWS::Events::EventBus', 'my-event-bus'),\n    );\n\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          EventBus: {\n            Type: 'AWS::Events::EventBus',\n            Properties: {\n              Name: 'my-event-bus',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Environment: {\n                Variables: {\n                  token: { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                  literal: 'newValue',\n                },\n              },\n              Description: {\n                'Fn::Join': ['', [\n                  'newValue',\n                  { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Environment: {\n        Variables: {\n          token: 'arn:aws:events:here:123456789012:event-bus/my-event-bus',\n          literal: 'newValue',\n        },\n      },\n      Description: 'newValuearn:aws:events:here:123456789012:event-bus/my-event-bus',\n    });\n  });\n\n  test('S3ObjectVersion is hotswappable', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Key: 'current-key',\n              S3ObjectVersion: 'current-obj',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Key: 'new-key',\n                S3ObjectVersion: 'new-obj',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Key: 'new-key',\n      S3ObjectVersion: 'new-obj',\n    });\n  });\n});","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns undefined when a new Lambda function is added to the Stack","suites":[],"updatePoint":{"line":31,"column":74},"line":31,"code":"  test('returns undefined when a new Lambda function is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateLambdaCode() API when it receives only a code difference in a Lambda function","suites":[],"updatePoint":{"line":60,"column":101},"line":60,"code":"  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"correctly evaluates the function's name when it references a different resource from the template","suites":[],"updatePoint":{"line":111,"column":105},"line":111,"code":"  test(\"correctly evaluates the function's name when it references a different resource from the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': ['-', [\n                'lambda',\n                { Ref: 'Bucket' },\n                'function',\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'mybucket'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': ['-', [\n                  'lambda',\n                  { Ref: 'Bucket' },\n                  'function',\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'lambda-mybucket-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"correctly falls back to taking the function's name from the current stack if it can't evaluate it in the template","suites":[],"updatePoint":{"line":181,"column":121},"line":181,"code":"  test(\"correctly falls back to taking the function's name from the current stack if it can't evaluate it in the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n        AssetBucketParam: { Type: 'String' },\n      },\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { Ref: 'AssetBucketParam' },\n              S3Key: 'current-key',\n            },\n            FunctionName: { Ref: 'Param1' },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-function'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n          AssetBucketParam: { Type: 'String' },\n        },\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { Ref: 'AssetBucketParam' },\n                S3Key: 'new-key',\n              },\n              FunctionName: { Ref: 'Param1' },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetBucketParam: 'asset-bucket' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'asset-bucket',\n      S3Key: 'new-key',\n    });\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"will not perform a hotswap deployment if it cannot find a Ref target (outside the function's name)","suites":[],"updatePoint":{"line":241,"column":106},"line":241,"code":"  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the function's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { 'Fn::Sub': '${Param1}' },\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { 'Fn::Sub': '${Param1}' },\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the function's name)","suites":[],"updatePoint":{"line":291,"column":129},"line":291,"code":"  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the function's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateLambdaCode() API when it receives a code difference in a Lambda function with no name","suites":[],"updatePoint":{"line":344,"column":109},"line":344,"code":"  test('calls the updateLambdaCode() API when it receives a code difference in a Lambda function with no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'current-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'current-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'mock-function-resource-id'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'mock-function-resource-id',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the updateLambdaCode() API when it receives a change that is not a code difference in a Lambda function","suites":[],"updatePoint":{"line":394,"column":125},"line":394,"code":"  test('does not call the updateLambdaCode() API when it receives a change that is not a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            PackageType: 'Zip',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              PackageType: 'Image',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"when it receives a non-hotswappable change that includes a code difference in a Lambda function, it does not call the updateLambdaCode()\n        API in CLASSIC mode but does in HOTSWAP_ONLY mode","suites":[],"updatePoint":{"line":446,"column":57},"line":445,"code":"  test(`when it receives a non-hotswappable change that includes a code difference in a Lambda function, it does not call the updateLambdaCode()\n        API in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n            PackageType: 'Zip',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n              PackageType: 'Image',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n    }\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the updateLambdaCode() API when a resource with type that is not AWS::Lambda::Function but has the same properties is changed","suites":[],"updatePoint":{"line":503,"column":147},"line":503,"code":"  test('does not call the updateLambdaCode() API when a resource with type that is not AWS::Lambda::Function but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::NotLambda::NotAFunction',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::NotLambda::NotAFunction',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls getFunction() after function code is updated with delay 1","suites":[],"updatePoint":{"line":558,"column":71},"line":558,"code":"  test('calls getFunction() after function code is updated with delay 1', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(mockMakeRequest).toHaveBeenCalledWith('getFunction', { FunctionName: 'my-function' });\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 1,\n      }),\n    }));\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls getFunction() after function code is updated and VpcId is empty string with delay 1","suites":[],"updatePoint":{"line":610,"column":97},"line":610,"code":"  test('calls getFunction() after function code is updated and VpcId is empty string with delay 1', async () => {\n    // GIVEN\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({\n      VpcConfig: {\n        VpcId: '',\n      },\n    });\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 1,\n      }),\n    }));\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls getFunction() after function code is updated on a VPC function with delay 5","suites":[],"updatePoint":{"line":669,"column":89},"line":669,"code":"  test('calls getFunction() after function code is updated on a VPC function with delay 5', async () => {\n    // GIVEN\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({\n      VpcConfig: {\n        VpcId: 'abc',\n      },\n    });\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 5,\n      }),\n    }));\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateLambdaConfiguration() API when it receives difference in Description field of a Lambda function","suites":[],"updatePoint":{"line":728,"column":119},"line":728,"code":"  test('calls the updateLambdaConfiguration() API when it receives difference in Description field of a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Description: 'Old Description',\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Description: 'New Description',\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Description: 'New Description',\n    });\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateLambdaConfiguration() API when it receives difference in Environment field of a Lambda function","suites":[],"updatePoint":{"line":780,"column":119},"line":780,"code":"  test('calls the updateLambdaConfiguration() API when it receives difference in Environment field of a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Environment: {\n              Variables: {\n                Key1: 'Value1',\n                Key2: 'Value2',\n              },\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Environment: {\n                Variables: {\n                  Key1: 'Value1',\n                  Key2: 'Value2',\n                  NewKey: 'NewValue',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Environment: {\n        Variables: {\n          Key1: 'Value1',\n          Key2: 'Value2',\n          NewKey: 'NewValue',\n        },\n      },\n    });\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls both updateLambdaCode() and updateLambdaConfiguration() API when it receives both code and configuration change","suites":[],"updatePoint":{"line":849,"column":125},"line":849,"code":"  test('calls both updateLambdaCode() and updateLambdaConfiguration() API when it receives both code and configuration change', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n            Description: 'Old Description',\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'new-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n              Description: 'New Description',\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Description: 'New Description',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'new-key',\n    });\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Lambda hotswap works properly with changes of environment variables and description with tokens","suites":[],"updatePoint":{"line":906,"column":103},"line":906,"code":"  test('Lambda hotswap works properly with changes of environment variables and description with tokens', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        EventBus: {\n          Type: 'AWS::Events::EventBus',\n          Properties: {\n            Name: 'my-event-bus',\n          },\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Environment: {\n              Variables: {\n                token: { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                literal: 'oldValue',\n              },\n            },\n            Description: {\n              'Fn::Join': ['', [\n                'oldValue',\n                { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('EventBus', 'AWS::Events::EventBus', 'my-event-bus'),\n    );\n\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          EventBus: {\n            Type: 'AWS::Events::EventBus',\n            Properties: {\n              Name: 'my-event-bus',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Environment: {\n                Variables: {\n                  token: { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                  literal: 'newValue',\n                },\n              },\n              Description: {\n                'Fn::Join': ['', [\n                  'newValue',\n                  { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Environment: {\n        Variables: {\n          token: 'arn:aws:events:here:123456789012:event-bus/my-event-bus',\n          literal: 'newValue',\n        },\n      },\n      Description: 'newValuearn:aws:events:here:123456789012:event-bus/my-event-bus',\n    });\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"S3ObjectVersion is hotswappable","suites":[],"updatePoint":{"line":1003,"column":39},"line":1003,"code":"  test('S3ObjectVersion is hotswappable', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Key: 'current-key',\n              S3ObjectVersion: 'current-obj',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Key: 'new-key',\n                S3ObjectVersion: 'new-obj',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Key: 'new-key',\n      S3ObjectVersion: 'new-obj',\n    });\n  });","file":"api/hotswap/lambda-functions-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"these tests do not depend on the hotswap type","suites":[],"line":23,"code":"describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('these tests do not depend on the hotswap type', (hotswapMode) => {\n  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Node.js code)', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'exports.handler = () => {return true}',\n            },\n            Runtime: 'nodejs14.x',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const newCode = 'exports.handler = () => {return false}';\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: newCode,\n              },\n              Runtime: 'nodejs14.x',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ZipFile: expect.any(Buffer),\n    });\n  });\n\n  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Python code)', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'def handler(event, context):\\n  return True',\n            },\n            Runtime: 'python3.9',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: 'def handler(event, context):\\n  return False',\n              },\n              Runtime: 'python3.9',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ZipFile: expect.any(Buffer),\n    });\n  });\n\n  test('throw a CfnEvaluationException when it receives an unsupported function runtime', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'def handler(event:, context:) true end',\n            },\n            Runtime: 'ruby2.7',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: 'def handler(event:, context:) false end',\n              },\n              Runtime: 'ruby2.7',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const tryHotswap = hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    await expect(tryHotswap).rejects.toThrow('runtime ruby2.7 is unsupported, only node.js and python runtimes are currently supported.');\n  });\n});","file":"api/hotswap/lambda-functions-inline-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Node.js code)","suites":[],"updatePoint":{"line":24,"column":123},"line":24,"code":"  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Node.js code)', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'exports.handler = () => {return true}',\n            },\n            Runtime: 'nodejs14.x',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const newCode = 'exports.handler = () => {return false}';\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: newCode,\n              },\n              Runtime: 'nodejs14.x',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ZipFile: expect.any(Buffer),\n    });\n  });","file":"api/hotswap/lambda-functions-inline-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Python code)","suites":[],"updatePoint":{"line":69,"column":122},"line":69,"code":"  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Python code)', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'def handler(event, context):\\n  return True',\n            },\n            Runtime: 'python3.9',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: 'def handler(event, context):\\n  return False',\n              },\n              Runtime: 'python3.9',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ZipFile: expect.any(Buffer),\n    });\n  });","file":"api/hotswap/lambda-functions-inline-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throw a CfnEvaluationException when it receives an unsupported function runtime","suites":[],"updatePoint":{"line":113,"column":87},"line":113,"code":"  test('throw a CfnEvaluationException when it receives an unsupported function runtime', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'def handler(event:, context:) true end',\n            },\n            Runtime: 'ruby2.7',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: 'def handler(event:, context:) false end',\n              },\n              Runtime: 'ruby2.7',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const tryHotswap = hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    await expect(tryHotswap).rejects.toThrow('runtime ruby2.7 is unsupported, only node.js and python runtimes are currently supported.');\n  });","file":"api/hotswap/lambda-functions-inline-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p mode","suites":[],"line":24,"code":"describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('hotswaps a Version if it points to a changed Function, even if it itself is unchanged', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });\n\n  test('hotswaps a Version if it points to a changed Function, even if it itself is replaced', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version1: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version2: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });\n\n  test('hotswaps a Version and an Alias if the Function they point to changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version1: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n        Alias: {\n          Type: 'AWS::Lambda::Alias',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n            FunctionVersion: { 'Fn::GetAtt': ['Version1', 'Version'] },\n            Name: 'dev',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version2: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n          Alias: {\n            Type: 'AWS::Lambda::Alias',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n              FunctionVersion: { 'Fn::GetAtt': ['Version2', 'Version'] },\n              Name: 'dev',\n            },\n          },\n        },\n      },\n    });\n    mockPublishVersion.mockReturnValue({\n      Version: 'v2',\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateAlias).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      FunctionVersion: 'v2',\n      Name: 'dev',\n    });\n  });\n});","file":"api/hotswap/lambda-versions-aliases-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"hotswaps a Version if it points to a changed Function, even if it itself is unchanged","suites":[],"updatePoint":{"line":25,"column":93},"line":25,"code":"  test('hotswaps a Version if it points to a changed Function, even if it itself is unchanged', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });","file":"api/hotswap/lambda-versions-aliases-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"hotswaps a Version if it points to a changed Function, even if it itself is replaced","suites":[],"updatePoint":{"line":80,"column":92},"line":80,"code":"  test('hotswaps a Version if it points to a changed Function, even if it itself is replaced', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version1: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version2: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });","file":"api/hotswap/lambda-versions-aliases-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"hotswaps a Version and an Alias if the Function they point to changed","suites":[],"updatePoint":{"line":135,"column":77},"line":135,"code":"  test('hotswaps a Version and an Alias if the Function they point to changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version1: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n        Alias: {\n          Type: 'AWS::Lambda::Alias',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n            FunctionVersion: { 'Fn::GetAtt': ['Version1', 'Version'] },\n            Name: 'dev',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version2: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n          Alias: {\n            Type: 'AWS::Lambda::Alias',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n              FunctionVersion: { 'Fn::GetAtt': ['Version2', 'Version'] },\n              Name: 'dev',\n            },\n          },\n        },\n      },\n    });\n    mockPublishVersion.mockReturnValue({\n      Version: 'v2',\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateAlias).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      FunctionVersion: 'v2',\n      Name: 'dev',\n    });\n  });","file":"api/hotswap/lambda-versions-aliases-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p mode","suites":[],"line":12,"code":"describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('can hotswap a lambda function in a 1-level nested stack', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('hotswappable changes do not override hotswappable changes in their ancestors', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('TwoLevelLambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'TwoLevelLambdaRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-one-stack-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'child-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          GrandChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('TwoLevelLambdaRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n    );\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'TwoLevelLambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'child-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'current-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('hotswappable changes in nested stacks do not override hotswappable changes in their parent stack', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('SiblingLambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'SiblingLambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('SiblingLambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    const cdkStackArtifact = testStack({ stackName: 'SiblingLambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'root-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'current-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test(`non-hotswappable changes in nested stacks result in a full deployment, even if their parent contains a hotswappable change in CLASSIC mode,\n        but perform a hotswap deployment in HOTSWAP_ONLY`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NonHotswappableRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NonHotswappableRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              PackageType: 'Image',\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('NonHotswappableRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    const cdkStackArtifact = testStack({ stackName: 'NonHotswappableRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });\n\n  test(`deleting a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackDeletionRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackDeletionRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('NestedStackDeletionRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    delete rootStack.template.Resources.NestedStack;\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackDeletionRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });\n\n  test(`creating a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackCreationRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackCreationRoot',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    rootStack.template.Resources.NestedStack = {\n      Type: 'AWS::CloudFormation::Stack',\n      Properties: {\n        TemplateURL: 'https://www.magic-url.com',\n      },\n      Metadata: {\n        'aws:asset:path': 'one-lambda-stack.nested.template.json',\n      },\n    };\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackCreationRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });\n\n  test(`attempting to hotswap a newly created nested stack with the same logical ID as a resource with a different type results in a full deployment in CLASSIC mode\n        and a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackTypeChangeRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackTypeChangeRoot',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          FutureNestedStack: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'spooky-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    rootStack.template.Resources.FutureNestedStack = {\n      Type: 'AWS::CloudFormation::Stack',\n      Properties: {\n        TemplateURL: 'https://www.magic-url.com',\n      },\n      Metadata: {\n        'aws:asset:path': 'one-lambda-stack.nested.template.json',\n      },\n    };\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackTypeChangeRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });\n\n  test('multi-sibling + 3-layer nested stack structure is hotswappable', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('MultiLayerRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const lambdaFunctionResource = {\n      Type: 'AWS::Lambda::Function',\n      Properties: {\n        Code: {\n          S3Bucket: 'current-bucket',\n          S3Key: 'current-key',\n        },\n      },\n      Metadata: {\n        'aws:asset:path': 'old-path',\n      },\n    };\n\n    const rootStack = testStack({\n      stackName: 'MultiLayerRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-two-stacks-stack.nested.template.json',\n            },\n          },\n          Func: lambdaFunctionResource,\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          GrandChildStackA: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-stack.nested.template.json',\n            },\n          },\n          GrandChildStackB: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-stack.nested.template.json',\n            },\n          },\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStackA',\n      template: {\n        Resources: {\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStackB',\n      template: {\n        Resources: {\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('MultiLayerRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'root-function'),\n    );\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStackA', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackA/abcd',\n      ),\n      setup.stackSummaryOf('GrandChildStackB', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackB/abcd',\n      ),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'child-function'),\n    );\n    setup.pushNestedStackResourceSummaries('GrandChildStackA',\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'grandchild-A-function'),\n    );\n    setup.pushNestedStackResourceSummaries('GrandChildStackB',\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'grandchild-B-function'),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Key = 'new-key';\n    const cdkStackArtifact = testStack({ stackName: 'MultiLayerRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'root-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'child-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'grandchild-A-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'grandchild-B-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('can hotswap a lambda function in a 1-level nested stack with asset parameters', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n              Parameters: {\n                referencetoS3BucketParam: {\n                  Ref: 'S3BucketParam',\n                },\n                referencetoS3KeyParam: {\n                  Ref: 'S3KeyParam',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n        Parameters: {\n          S3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          S3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n      S3BucketParam: 'bucket-param-value',\n      S3KeyParam: 'key-param-value',\n    });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'bucket-param-value',\n      S3Key: 'key-param-value',\n    });\n  });\n\n  test('can hotswap a lambda function in a 2-level nested stack with asset parameters', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n              Parameters: {\n                referencetoGrandChildS3BucketParam: {\n                  Ref: 'GrandChildS3BucketParam',\n                },\n                referencetoGrandChildS3KeyParam: {\n                  Ref: 'GrandChildS3KeyParam',\n                },\n                referencetoChildS3BucketParam: {\n                  Ref: 'ChildS3BucketParam',\n                },\n                referencetoChildS3KeyParam: {\n                  Ref: 'ChildS3KeyParam',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-one-stack-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n        Parameters: {\n          GrandChildS3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          GrandChildS3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          ChildS3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          ChildS3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          GrandChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n    );\n\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStack/abcd',\n      ),\n    );\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n      GrandChildS3BucketParam: 'child-bucket-param-value',\n      GrandChildS3KeyParam: 'child-key-param-value',\n      ChildS3BucketParam: 'bucket-param-value',\n      ChildS3KeyParam: 'key-param-value',\n    });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'bucket-param-value',\n      S3Key: 'key-param-value',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'child-bucket-param-value',\n      S3Key: 'child-key-param-value',\n    });\n  });\n\n  test('looking up objects in nested stacks works', async () => {\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    mockPublishVersion = jest.fn();\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n      publishVersion: mockPublishVersion,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-version-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });\n});","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can hotswap a lambda function in a 1-level nested stack","suites":[],"updatePoint":{"line":13,"column":63},"line":13,"code":"  test('can hotswap a lambda function in a 1-level nested stack', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"hotswappable changes do not override hotswappable changes in their ancestors","suites":[],"updatePoint":{"line":80,"column":84},"line":80,"code":"  test('hotswappable changes do not override hotswappable changes in their ancestors', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('TwoLevelLambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'TwoLevelLambdaRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-one-stack-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'child-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          GrandChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('TwoLevelLambdaRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n    );\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'TwoLevelLambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'child-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'current-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"hotswappable changes in nested stacks do not override hotswappable changes in their parent stack","suites":[],"updatePoint":{"line":186,"column":104},"line":186,"code":"  test('hotswappable changes in nested stacks do not override hotswappable changes in their parent stack', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('SiblingLambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'SiblingLambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('SiblingLambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    const cdkStackArtifact = testStack({ stackName: 'SiblingLambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'root-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'current-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"non-hotswappable changes in nested stacks result in a full deployment, even if their parent contains a hotswappable change in CLASSIC mode,\n        but perform a hotswap deployment in HOTSWAP_ONLY","suites":[],"updatePoint":{"line":273,"column":56},"line":272,"code":"  test(`non-hotswappable changes in nested stacks result in a full deployment, even if their parent contains a hotswappable change in CLASSIC mode,\n        but perform a hotswap deployment in HOTSWAP_ONLY`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NonHotswappableRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NonHotswappableRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              PackageType: 'Image',\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('NonHotswappableRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    const cdkStackArtifact = testStack({ stackName: 'NonHotswappableRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deleting a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode","suites":[],"updatePoint":{"line":367,"column":64},"line":366,"code":"  test(`deleting a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackDeletionRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackDeletionRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('NestedStackDeletionRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    delete rootStack.template.Resources.NestedStack;\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackDeletionRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"creating a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode","suites":[],"updatePoint":{"line":460,"column":64},"line":459,"code":"  test(`creating a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackCreationRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackCreationRoot',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    rootStack.template.Resources.NestedStack = {\n      Type: 'AWS::CloudFormation::Stack',\n      Properties: {\n        TemplateURL: 'https://www.magic-url.com',\n      },\n      Metadata: {\n        'aws:asset:path': 'one-lambda-stack.nested.template.json',\n      },\n    };\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackCreationRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"attempting to hotswap a newly created nested stack with the same logical ID as a resource with a different type results in a full deployment in CLASSIC mode\n        and a hotswap deployment in HOTSWAP_ONLY mode","suites":[],"updatePoint":{"line":527,"column":53},"line":526,"code":"  test(`attempting to hotswap a newly created nested stack with the same logical ID as a resource with a different type results in a full deployment in CLASSIC mode\n        and a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackTypeChangeRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackTypeChangeRoot',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          FutureNestedStack: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'spooky-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    rootStack.template.Resources.FutureNestedStack = {\n      Type: 'AWS::CloudFormation::Stack',\n      Properties: {\n        TemplateURL: 'https://www.magic-url.com',\n      },\n      Metadata: {\n        'aws:asset:path': 'one-lambda-stack.nested.template.json',\n      },\n    };\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackTypeChangeRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"multi-sibling + 3-layer nested stack structure is hotswappable","suites":[],"updatePoint":{"line":606,"column":70},"line":606,"code":"  test('multi-sibling + 3-layer nested stack structure is hotswappable', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('MultiLayerRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const lambdaFunctionResource = {\n      Type: 'AWS::Lambda::Function',\n      Properties: {\n        Code: {\n          S3Bucket: 'current-bucket',\n          S3Key: 'current-key',\n        },\n      },\n      Metadata: {\n        'aws:asset:path': 'old-path',\n      },\n    };\n\n    const rootStack = testStack({\n      stackName: 'MultiLayerRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-two-stacks-stack.nested.template.json',\n            },\n          },\n          Func: lambdaFunctionResource,\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          GrandChildStackA: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-stack.nested.template.json',\n            },\n          },\n          GrandChildStackB: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-stack.nested.template.json',\n            },\n          },\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStackA',\n      template: {\n        Resources: {\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStackB',\n      template: {\n        Resources: {\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('MultiLayerRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'root-function'),\n    );\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStackA', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackA/abcd',\n      ),\n      setup.stackSummaryOf('GrandChildStackB', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackB/abcd',\n      ),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'child-function'),\n    );\n    setup.pushNestedStackResourceSummaries('GrandChildStackA',\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'grandchild-A-function'),\n    );\n    setup.pushNestedStackResourceSummaries('GrandChildStackB',\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'grandchild-B-function'),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Key = 'new-key';\n    const cdkStackArtifact = testStack({ stackName: 'MultiLayerRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'root-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'child-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'grandchild-A-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'grandchild-B-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can hotswap a lambda function in a 1-level nested stack with asset parameters","suites":[],"updatePoint":{"line":741,"column":85},"line":741,"code":"  test('can hotswap a lambda function in a 1-level nested stack with asset parameters', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n              Parameters: {\n                referencetoS3BucketParam: {\n                  Ref: 'S3BucketParam',\n                },\n                referencetoS3KeyParam: {\n                  Ref: 'S3KeyParam',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n        Parameters: {\n          S3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          S3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n      S3BucketParam: 'bucket-param-value',\n      S3KeyParam: 'key-param-value',\n    });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'bucket-param-value',\n      S3Key: 'key-param-value',\n    });\n  });","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can hotswap a lambda function in a 2-level nested stack with asset parameters","suites":[],"updatePoint":{"line":829,"column":85},"line":829,"code":"  test('can hotswap a lambda function in a 2-level nested stack with asset parameters', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n              Parameters: {\n                referencetoGrandChildS3BucketParam: {\n                  Ref: 'GrandChildS3BucketParam',\n                },\n                referencetoGrandChildS3KeyParam: {\n                  Ref: 'GrandChildS3KeyParam',\n                },\n                referencetoChildS3BucketParam: {\n                  Ref: 'ChildS3BucketParam',\n                },\n                referencetoChildS3KeyParam: {\n                  Ref: 'ChildS3KeyParam',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-one-stack-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n        Parameters: {\n          GrandChildS3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          GrandChildS3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          ChildS3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          ChildS3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          GrandChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n    );\n\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStack/abcd',\n      ),\n    );\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n      GrandChildS3BucketParam: 'child-bucket-param-value',\n      GrandChildS3KeyParam: 'child-key-param-value',\n      ChildS3BucketParam: 'bucket-param-value',\n      ChildS3KeyParam: 'key-param-value',\n    });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'bucket-param-value',\n      S3Key: 'key-param-value',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'child-bucket-param-value',\n      S3Key: 'child-key-param-value',\n    });\n  });","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looking up objects in nested stacks works","suites":[],"updatePoint":{"line":972,"column":49},"line":972,"code":"  test('looking up objects in nested stacks works', async () => {\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    mockPublishVersion = jest.fn();\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n      publishVersion: mockPublishVersion,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-version-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });","file":"api/hotswap/nested-stacks-hotswap.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p mode","suites":[],"line":25,"code":"describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('calls the lambdaInvoke() API when it receives only an asset difference in an S3 bucket deployment and evaluates CFN expressions in S3 Deployment Properties', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: 'a-lambda-arn',\n            SourceBucketNames: ['src-bucket'],\n            SourceObjectKeys: ['src-key-old'],\n            DestinationBucketName: 'dest-bucket',\n            DestinationBucketKeyPrefix: 'my-key/some-old-prefix',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: 'a-lambda-arn',\n              SourceBucketNames: ['src-bucket'],\n              SourceObjectKeys: {\n                'Fn::Split': [\n                  '-',\n                  'key1-key2-key3',\n                ],\n              },\n              DestinationBucketName: 'dest-bucket',\n              DestinationBucketKeyPrefix: 'my-key/some-new-prefix',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n\n    expect(mockLambdaInvoke).toHaveBeenCalledWith({\n      FunctionName: 'a-lambda-arn',\n      Payload: JSON.stringify({\n        ...payloadWithoutCustomResProps,\n        ResourceProperties: {\n          SourceBucketNames: ['src-bucket'],\n          SourceObjectKeys: ['key1', 'key2', 'key3'],\n          DestinationBucketName: 'dest-bucket',\n          DestinationBucketKeyPrefix: 'my-key/some-new-prefix',\n        },\n      }),\n    });\n  });\n\n  test('does not call the invoke() API when a resource with type that is not Custom::CDKBucketDeployment but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::NotCDKBucketDeployment',\n          Properties: {\n            SourceObjectKeys: ['src-key-old'],\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::NotCDKBucketDeployment',\n            Properties: {\n              SourceObjectKeys: ['src-key-new'],\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    }\n  });\n\n  test('does not call the invokeLambda() api if the updated Policy has no Roles in CLASSIC mode but does in HOTSWAP_ONLY mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        WebsiteBucketParamOld: { Type: 'String' },\n        WebsiteBucketParamNew: { Type: 'String' },\n      },\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: 'a-lambda-arn',\n            SourceObjectKeys: ['src-key-old'],\n            SourceBucketNames: ['src-bucket'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        },\n        Policy: {\n          Type: 'AWS::IAM::Policy',\n          Properties: {\n            PolicyName: 'my-policy',\n            PolicyDocument: {\n              Statement: [\n                {\n                  Action: ['s3:GetObject*'],\n                  Effect: 'Allow',\n                  Resource: {\n                    Ref: 'WebsiteBucketParamOld',\n                  },\n                },\n              ],\n            },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          WebsiteBucketParamOld: { Type: 'String' },\n          WebsiteBucketParamNew: { Type: 'String' },\n        },\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: 'a-lambda-arn',\n              SourceObjectKeys: ['src-key-new'],\n              SourceBucketNames: ['src-bucket'],\n              DestinationBucketName: 'dest-bucket',\n            },\n          },\n          Policy: {\n            Type: 'AWS::IAM::Policy',\n            Properties: {\n              PolicyName: 'my-policy',\n              PolicyDocument: {\n                Statement: [\n                  {\n                    Action: ['s3:GetObject*'],\n                    Effect: 'Allow',\n                    Resource: {\n                      Ref: 'WebsiteBucketParamNew',\n                    },\n                  },\n                ],\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'a-lambda-arn',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceObjectKeys: ['src-key-new'],\n            SourceBucketNames: ['src-bucket'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        }),\n      });\n    }\n  });\n\n  test('throws an error when the serviceToken fails evaluation in the template', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: {\n              Ref: 'BadLamba',\n            },\n            SourceBucketNames: ['src-bucket'],\n            SourceObjectKeys: ['src-key-old'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: {\n                Ref: 'BadLamba',\n              },\n              SourceBucketNames: ['src-bucket'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'dest-bucket',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'BadLamba' could not be found for evaluation/);\n\n    expect(mockLambdaInvoke).not.toHaveBeenCalled();\n  });\n\n  describe('old-style synthesis', () => {\n    const parameters = {\n      WebsiteBucketParamOld: { Type: 'String' },\n      WebsiteBucketParamNew: { Type: 'String' },\n      DifferentBucketParamNew: { Type: 'String' },\n    };\n\n    const serviceRole = {\n      Type: 'AWS::IAM::Role',\n      Properties: {\n        AssumeRolePolicyDocument: {\n          Statement: [\n            {\n              Action: 'sts:AssumeRole',\n              Effect: 'Allow',\n              Principal: {\n                Service: 'lambda.amazonaws.com',\n              },\n            },\n          ],\n          Version: '2012-10-17',\n        },\n      },\n    };\n\n    const policyOld = {\n      Type: 'AWS::IAM::Policy',\n      Properties: {\n        PolicyName: 'my-policy-old',\n        Roles: [\n          { Ref: 'ServiceRole' },\n        ],\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: ['s3:GetObject*'],\n              Effect: 'Allow',\n              Resource: {\n                Ref: 'WebsiteBucketParamOld',\n              },\n            },\n          ],\n        },\n      },\n    };\n\n    const policyNew = {\n      Type: 'AWS::IAM::Policy',\n      Properties: {\n        PolicyName: 'my-policy-new',\n        Roles: [\n          { Ref: 'ServiceRole' },\n        ],\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: ['s3:GetObject*'],\n              Effect: 'Allow',\n              Resource: {\n                Ref: 'WebsiteBucketParamNew',\n              },\n            },\n          ],\n        },\n      },\n    };\n\n    const policy2Old = {\n      Type: 'AWS::IAM::Policy',\n      Properties: {\n        PolicyName: 'my-policy-old-2',\n        Roles: [\n          { Ref: 'ServiceRole' },\n        ],\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: ['s3:GetObject*'],\n              Effect: 'Allow',\n              Resource: {\n                Ref: 'WebsiteBucketParamOld',\n              },\n            },\n          ],\n        },\n      },\n    };\n\n    const policy2New = {\n      Type: 'AWS::IAM::Policy',\n      Properties: {\n        PolicyName: 'my-policy-new-2',\n        Roles: [\n          { Ref: 'ServiceRole2' },\n        ],\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: ['s3:GetObject*'],\n              Effect: 'Allow',\n              Resource: {\n                Ref: 'DifferentBucketParamOld',\n              },\n            },\n          ],\n        },\n      },\n    };\n\n    const deploymentLambda = {\n      Type: 'AWS::Lambda::Function',\n      Role: {\n        'Fn::GetAtt': [\n          'ServiceRole',\n          'Arn',\n        ],\n      },\n    };\n\n    const s3DeploymentOld = {\n      Type: 'Custom::CDKBucketDeployment',\n      Properties: {\n        ServiceToken: {\n          'Fn::GetAtt': [\n            'S3DeploymentLambda',\n            'Arn',\n          ],\n        },\n        SourceBucketNames: ['src-bucket-old'],\n        SourceObjectKeys: ['src-key-old'],\n        DestinationBucketName: 'WebsiteBucketOld',\n      },\n    };\n\n    const s3DeploymentNew = {\n      Type: 'Custom::CDKBucketDeployment',\n      Properties: {\n        ServiceToken: {\n          'Fn::GetAtt': [\n            'S3DeploymentLambda',\n            'Arn',\n          ],\n        },\n        SourceBucketNames: ['src-bucket-new'],\n        SourceObjectKeys: ['src-key-new'],\n        DestinationBucketName: 'WebsiteBucketNew',\n      },\n    };\n\n    beforeEach(() => {\n      setup.pushStackResourceSummaries(\n        setup.stackSummaryOf('S3DeploymentLambda', 'AWS::Lambda::Function', 'my-deployment-lambda'),\n        setup.stackSummaryOf('ServiceRole', 'AWS::IAM::Role', 'my-service-role'),\n      );\n    });\n\n    test('calls the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment and an IAM Policy difference using old-style synthesis', async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          Parameters: parameters,\n          ServiceRole: serviceRole,\n          Policy: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            Parameters: parameters,\n            ServiceRole: serviceRole,\n            Policy: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { WebsiteBucketParamOld: 'WebsiteBucketOld', WebsiteBucketParamNew: 'WebsiteBucketNew' });\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'WebsiteBucketNew',\n          },\n        }),\n      });\n    });\n\n    test(`does not call the lambdaInvoke() API when the difference in the S3 deployment is referred to in one IAM policy change but not another\n          in CLASSIC mode but does in HOTSWAP_ONLY`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            Policy2: {\n              Properties: {\n                Roles: [\n                  { Ref: 'ServiceRole' },\n                  'different-role',\n                ],\n                PolicyDocument: {\n                  Statement: [\n                    {\n                      Action: ['s3:GetObject*'],\n                      Effect: 'Allow',\n                      Resource: {\n                        'Fn::GetAtt': [\n                          'DifferentBucketNew',\n                          'Arn',\n                        ],\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });\n\n    test(`does not call the lambdaInvoke() API when the lambda that references the role is referred to by something other than an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          Endpoint: {\n            Type: 'AWS::Lambda::Permission',\n            Properties: {\n              Action: 'lambda:InvokeFunction',\n              FunctionName: {\n                'Fn::GetAtt': [\n                  'S3DeploymentLambda',\n                  'Arn',\n                ],\n              },\n              Principal: 'apigateway.amazonaws.com',\n            },\n          },\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            Endpoint: {\n              Type: 'AWS::Lambda::Permission',\n              Properties: {\n                Action: 'lambda:InvokeFunction',\n                FunctionName: {\n                  'Fn::GetAtt': [\n                    'S3DeploymentLambda',\n                    'Arn',\n                  ],\n                },\n                Principal: 'apigateway.amazonaws.com',\n              },\n            },\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });\n\n    test('calls the lambdaInvoke() API when it receives an asset difference in two S3 bucket deployments and IAM Policy differences using old-style synthesis', async () => {\n      // GIVEN\n      const s3Deployment2Old = {\n        Type: 'Custom::CDKBucketDeployment',\n        Properties: {\n          ServiceToken: {\n            'Fn::GetAtt': [\n              'S3DeploymentLambda2',\n              'Arn',\n            ],\n          },\n          SourceBucketNames: ['src-bucket-old'],\n          SourceObjectKeys: ['src-key-old'],\n          DestinationBucketName: 'DifferentBucketOld',\n        },\n      };\n\n      const s3Deployment2New = {\n        Type: 'Custom::CDKBucketDeployment',\n        Properties: {\n          ServiceToken: {\n            'Fn::GetAtt': [\n              'S3DeploymentLambda2',\n              'Arn',\n            ],\n          },\n          SourceBucketNames: ['src-bucket-new'],\n          SourceObjectKeys: ['src-key-new'],\n          DestinationBucketName: 'DifferentBucketNew',\n        },\n      };\n\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          ServiceRole2: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3DeploymentLambda2: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          S3Deployment2: s3Deployment2Old,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            Parameters: parameters,\n            ServiceRole: serviceRole,\n            ServiceRole2: serviceRole,\n            Policy1: policyNew,\n            Policy2: policy2New,\n            S3DeploymentLambda: deploymentLambda,\n            S3DeploymentLambda2: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            S3Deployment2: s3Deployment2New,\n          },\n        },\n      });\n\n      // WHEN\n      setup.pushStackResourceSummaries(\n        setup.stackSummaryOf('S3DeploymentLambda2', 'AWS::Lambda::Function', 'my-deployment-lambda-2'),\n        setup.stackSummaryOf('ServiceRole2', 'AWS::IAM::Role', 'my-service-role-2'),\n      );\n\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n        WebsiteBucketParamOld: 'WebsiteBucketOld',\n        WebsiteBucketParamNew: 'WebsiteBucketNew',\n        DifferentBucketParamNew: 'WebsiteBucketNew',\n      });\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'WebsiteBucketNew',\n          },\n        }),\n      });\n\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda-2',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'DifferentBucketNew',\n          },\n        }),\n      });\n    });\n\n    test(`does not call the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment that references two different policies\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            Policy2: {\n              Properties: {\n                Roles: [\n                  { Ref: 'ServiceRole' },\n                ],\n                PolicyDocument: {\n                  Statement: [\n                    {\n                      Action: ['s3:GetObject*'],\n                      Effect: 'Allow',\n                      Resource: {\n                        'Fn::GetAtt': [\n                          'DifferentBucketNew',\n                          'Arn',\n                        ],\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });\n\n    test(`does not call the lambdaInvoke() API when a policy is referenced by a resource that is not an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          NotADeployment: {\n            Type: 'AWS::Not::S3Deployment',\n            Properties: {\n              Prop: {\n                Ref: 'ServiceRole',\n              },\n            },\n          },\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            NotADeployment: {\n              Type: 'AWS::Not::S3Deployment',\n              Properties: {\n                Prop: {\n                  Ref: 'ServiceRole',\n                },\n              },\n            },\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });\n  });\n});","file":"api/hotswap/s3-bucket-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the lambdaInvoke() API when it receives only an asset difference in an S3 bucket deployment and evaluates CFN expressions in S3 Deployment Properties","suites":[],"updatePoint":{"line":26,"column":163},"line":26,"code":"  test('calls the lambdaInvoke() API when it receives only an asset difference in an S3 bucket deployment and evaluates CFN expressions in S3 Deployment Properties', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: 'a-lambda-arn',\n            SourceBucketNames: ['src-bucket'],\n            SourceObjectKeys: ['src-key-old'],\n            DestinationBucketName: 'dest-bucket',\n            DestinationBucketKeyPrefix: 'my-key/some-old-prefix',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: 'a-lambda-arn',\n              SourceBucketNames: ['src-bucket'],\n              SourceObjectKeys: {\n                'Fn::Split': [\n                  '-',\n                  'key1-key2-key3',\n                ],\n              },\n              DestinationBucketName: 'dest-bucket',\n              DestinationBucketKeyPrefix: 'my-key/some-new-prefix',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n\n    expect(mockLambdaInvoke).toHaveBeenCalledWith({\n      FunctionName: 'a-lambda-arn',\n      Payload: JSON.stringify({\n        ...payloadWithoutCustomResProps,\n        ResourceProperties: {\n          SourceBucketNames: ['src-bucket'],\n          SourceObjectKeys: ['key1', 'key2', 'key3'],\n          DestinationBucketName: 'dest-bucket',\n          DestinationBucketKeyPrefix: 'my-key/some-new-prefix',\n        },\n      }),\n    });\n  });","file":"api/hotswap/s3-bucket-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the invoke() API when a resource with type that is not Custom::CDKBucketDeployment but has the same properties is changed","suites":[],"updatePoint":{"line":84,"column":143},"line":84,"code":"  test('does not call the invoke() API when a resource with type that is not Custom::CDKBucketDeployment but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::NotCDKBucketDeployment',\n          Properties: {\n            SourceObjectKeys: ['src-key-old'],\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::NotCDKBucketDeployment',\n            Properties: {\n              SourceObjectKeys: ['src-key-new'],\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/s3-bucket-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the invokeLambda() api if the updated Policy has no Roles in CLASSIC mode but does in HOTSWAP_ONLY mode","suites":[],"updatePoint":{"line":127,"column":125},"line":127,"code":"  test('does not call the invokeLambda() api if the updated Policy has no Roles in CLASSIC mode but does in HOTSWAP_ONLY mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        WebsiteBucketParamOld: { Type: 'String' },\n        WebsiteBucketParamNew: { Type: 'String' },\n      },\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: 'a-lambda-arn',\n            SourceObjectKeys: ['src-key-old'],\n            SourceBucketNames: ['src-bucket'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        },\n        Policy: {\n          Type: 'AWS::IAM::Policy',\n          Properties: {\n            PolicyName: 'my-policy',\n            PolicyDocument: {\n              Statement: [\n                {\n                  Action: ['s3:GetObject*'],\n                  Effect: 'Allow',\n                  Resource: {\n                    Ref: 'WebsiteBucketParamOld',\n                  },\n                },\n              ],\n            },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          WebsiteBucketParamOld: { Type: 'String' },\n          WebsiteBucketParamNew: { Type: 'String' },\n        },\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: 'a-lambda-arn',\n              SourceObjectKeys: ['src-key-new'],\n              SourceBucketNames: ['src-bucket'],\n              DestinationBucketName: 'dest-bucket',\n            },\n          },\n          Policy: {\n            Type: 'AWS::IAM::Policy',\n            Properties: {\n              PolicyName: 'my-policy',\n              PolicyDocument: {\n                Statement: [\n                  {\n                    Action: ['s3:GetObject*'],\n                    Effect: 'Allow',\n                    Resource: {\n                      Ref: 'WebsiteBucketParamNew',\n                    },\n                  },\n                ],\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'a-lambda-arn',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceObjectKeys: ['src-key-new'],\n            SourceBucketNames: ['src-bucket'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        }),\n      });\n    }\n  });","file":"api/hotswap/s3-bucket-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws an error when the serviceToken fails evaluation in the template","suites":[],"updatePoint":{"line":227,"column":78},"line":227,"code":"  test('throws an error when the serviceToken fails evaluation in the template', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: {\n              Ref: 'BadLamba',\n            },\n            SourceBucketNames: ['src-bucket'],\n            SourceObjectKeys: ['src-key-old'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: {\n                Ref: 'BadLamba',\n              },\n              SourceBucketNames: ['src-bucket'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'dest-bucket',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'BadLamba' could not be found for evaluation/);\n\n    expect(mockLambdaInvoke).not.toHaveBeenCalled();\n  });","file":"api/hotswap/s3-bucket-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment and an IAM Policy difference using old-style synthesis","suites":["old-style synthesis"],"updatePoint":{"line":426,"column":157},"line":426,"code":"    test('calls the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment and an IAM Policy difference using old-style synthesis', async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          Parameters: parameters,\n          ServiceRole: serviceRole,\n          Policy: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            Parameters: parameters,\n            ServiceRole: serviceRole,\n            Policy: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { WebsiteBucketParamOld: 'WebsiteBucketOld', WebsiteBucketParamNew: 'WebsiteBucketNew' });\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'WebsiteBucketNew',\n          },\n        }),\n      });\n    });","file":"api/hotswap/s3-bucket-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the lambdaInvoke() API when the difference in the S3 deployment is referred to in one IAM policy change but not another\n          in CLASSIC mode but does in HOTSWAP_ONLY","suites":["old-style synthesis"],"updatePoint":{"line":469,"column":50},"line":468,"code":"    test(`does not call the lambdaInvoke() API when the difference in the S3 deployment is referred to in one IAM policy change but not another\n          in CLASSIC mode but does in HOTSWAP_ONLY`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            Policy2: {\n              Properties: {\n                Roles: [\n                  { Ref: 'ServiceRole' },\n                  'different-role',\n                ],\n                PolicyDocument: {\n                  Statement: [\n                    {\n                      Action: ['s3:GetObject*'],\n                      Effect: 'Allow',\n                      Resource: {\n                        'Fn::GetAtt': [\n                          'DifferentBucketNew',\n                          'Arn',\n                        ],\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });","file":"api/hotswap/s3-bucket-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the lambdaInvoke() API when the lambda that references the role is referred to by something other than an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode","suites":["old-style synthesis"],"updatePoint":{"line":543,"column":55},"line":542,"code":"    test(`does not call the lambdaInvoke() API when the lambda that references the role is referred to by something other than an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          Endpoint: {\n            Type: 'AWS::Lambda::Permission',\n            Properties: {\n              Action: 'lambda:InvokeFunction',\n              FunctionName: {\n                'Fn::GetAtt': [\n                  'S3DeploymentLambda',\n                  'Arn',\n                ],\n              },\n              Principal: 'apigateway.amazonaws.com',\n            },\n          },\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            Endpoint: {\n              Type: 'AWS::Lambda::Permission',\n              Properties: {\n                Action: 'lambda:InvokeFunction',\n                FunctionName: {\n                  'Fn::GetAtt': [\n                    'S3DeploymentLambda',\n                    'Arn',\n                  ],\n                },\n                Principal: 'apigateway.amazonaws.com',\n              },\n            },\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });","file":"api/hotswap/s3-bucket-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the lambdaInvoke() API when it receives an asset difference in two S3 bucket deployments and IAM Policy differences using old-style synthesis","suites":["old-style synthesis"],"updatePoint":{"line":619,"column":157},"line":619,"code":"    test('calls the lambdaInvoke() API when it receives an asset difference in two S3 bucket deployments and IAM Policy differences using old-style synthesis', async () => {\n      // GIVEN\n      const s3Deployment2Old = {\n        Type: 'Custom::CDKBucketDeployment',\n        Properties: {\n          ServiceToken: {\n            'Fn::GetAtt': [\n              'S3DeploymentLambda2',\n              'Arn',\n            ],\n          },\n          SourceBucketNames: ['src-bucket-old'],\n          SourceObjectKeys: ['src-key-old'],\n          DestinationBucketName: 'DifferentBucketOld',\n        },\n      };\n\n      const s3Deployment2New = {\n        Type: 'Custom::CDKBucketDeployment',\n        Properties: {\n          ServiceToken: {\n            'Fn::GetAtt': [\n              'S3DeploymentLambda2',\n              'Arn',\n            ],\n          },\n          SourceBucketNames: ['src-bucket-new'],\n          SourceObjectKeys: ['src-key-new'],\n          DestinationBucketName: 'DifferentBucketNew',\n        },\n      };\n\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          ServiceRole2: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3DeploymentLambda2: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          S3Deployment2: s3Deployment2Old,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            Parameters: parameters,\n            ServiceRole: serviceRole,\n            ServiceRole2: serviceRole,\n            Policy1: policyNew,\n            Policy2: policy2New,\n            S3DeploymentLambda: deploymentLambda,\n            S3DeploymentLambda2: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            S3Deployment2: s3Deployment2New,\n          },\n        },\n      });\n\n      // WHEN\n      setup.pushStackResourceSummaries(\n        setup.stackSummaryOf('S3DeploymentLambda2', 'AWS::Lambda::Function', 'my-deployment-lambda-2'),\n        setup.stackSummaryOf('ServiceRole2', 'AWS::IAM::Role', 'my-service-role-2'),\n      );\n\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n        WebsiteBucketParamOld: 'WebsiteBucketOld',\n        WebsiteBucketParamNew: 'WebsiteBucketNew',\n        DifferentBucketParamNew: 'WebsiteBucketNew',\n      });\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'WebsiteBucketNew',\n          },\n        }),\n      });\n\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda-2',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'DifferentBucketNew',\n          },\n        }),\n      });\n    });","file":"api/hotswap/s3-bucket-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment that references two different policies\n          in CLASSIC mode but does in HOTSWAP_ONLY mode","suites":["old-style synthesis"],"updatePoint":{"line":720,"column":55},"line":719,"code":"    test(`does not call the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment that references two different policies\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            Policy2: {\n              Properties: {\n                Roles: [\n                  { Ref: 'ServiceRole' },\n                ],\n                PolicyDocument: {\n                  Statement: [\n                    {\n                      Action: ['s3:GetObject*'],\n                      Effect: 'Allow',\n                      Resource: {\n                        'Fn::GetAtt': [\n                          'DifferentBucketNew',\n                          'Arn',\n                        ],\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });","file":"api/hotswap/s3-bucket-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the lambdaInvoke() API when a policy is referenced by a resource that is not an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode","suites":["old-style synthesis"],"updatePoint":{"line":793,"column":55},"line":792,"code":"    test(`does not call the lambdaInvoke() API when a policy is referenced by a resource that is not an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          NotADeployment: {\n            Type: 'AWS::Not::S3Deployment',\n            Properties: {\n              Prop: {\n                Ref: 'ServiceRole',\n              },\n            },\n          },\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            NotADeployment: {\n              Type: 'AWS::Not::S3Deployment',\n              Properties: {\n                Prop: {\n                  Ref: 'ServiceRole',\n                },\n              },\n            },\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });","file":"api/hotswap/s3-bucket-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p mode","suites":[],"line":15,"code":"describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('returns undefined when a new StateMachine is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls the updateStateMachine() API when it receives only a definitionString change without Fn::Join in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '{ Prop: \"new-value\" }',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });\n\n  test('calls the updateStateMachine() API when it receives only a definitionString change with Fn::Join in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '\\n',\n                [\n                  '{',\n                  '  \"StartAt\" : \"SuccessState\"',\n                  '  \"States\" : {',\n                  '    \"SuccessState\": {',\n                  '      \"Type\": \"Pass\"',\n                  '      \"Result\": \"Success\"',\n                  '      \"End\": true',\n                  '    }',\n                  '  }',\n                  '}',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '\\n',\n                  [\n                    '{',\n                    '  \"StartAt\": \"SuccessState\",',\n                    '  \"States\": {',\n                    '    \"SuccessState\": {',\n                    '      \"Type\": \"Succeed\"',\n                    '    }',\n                    '  }',\n                    '}',\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: JSON.stringify({\n        StartAt: 'SuccessState',\n        States: {\n          SuccessState: {\n            Type: 'Succeed',\n          },\n        },\n      }, null, 2),\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });\n\n  test('calls the updateStateMachine() API when it receives a change to the definitionString in a state machine that has no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ \"Prop\" : \"old-value\" }',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ \"Prop\" : \"new-value\" }',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '{ \"Prop\" : \"new-value\" }',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });\n\n  test(`does not call the updateStateMachine() API when it receives a change to a property that is not the definitionString in a state machine\n        alongside a hotswappable change in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ \"Prop\" : \"old-value\" }',\n            LoggingConfiguration: { // non-definitionString property\n              IncludeExecutionData: true,\n            },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ \"Prop\" : \"new-value\" }',\n              LoggingConfiguration: {\n                IncludeExecutionData: false,\n              },\n            },\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n        definition: '{ \"Prop\" : \"new-value\" }',\n        stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      });\n    }\n  });\n\n  test('does not call the updateStateMachine() API when a resource has a DefinitionString property but is not an AWS::StepFunctions::StateMachine is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::NotStepFunctions::NotStateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::NotStepFunctions::NotStateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });\n\n  test('can correctly hotswap old style synth changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: { AssetParam1: { Type: 'String' } },\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: { Ref: 'AssetParam1' },\n            StateMachineName: 'machine-name',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: { AssetParam2: { Type: String } },\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: { Ref: 'AssetParam2' },\n              StateMachineName: 'machine-name',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetParam2: 'asset-param-2' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: 'asset-param-2',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:machine-name',\n    });\n  });\n\n  test('calls the updateStateMachine() API when it receives a change to the definitionString that uses Attributes in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '\\n',\n                [\n                  '{',\n                  '  \"StartAt\" : \"SuccessState\"',\n                  '  \"States\" : {',\n                  '    \"SuccessState\": {',\n                  '      \"Type\": \"Succeed\"',\n                  '    }',\n                  '  }',\n                  '}',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '\"Resource\": ',\n                    { 'Fn::GetAtt': ['Func', 'Arn'] },\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'),\n    );\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '\"Resource\": arn:aws:lambda:here:123456789012:function:my-func',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });\n\n  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the state machine's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '',\n                [\n                  '{ Prop: \"old-value\" }, ',\n                  '{ \"Param\" : ',\n                  { 'Fn::Sub': '${Param1}' },\n                  ' }',\n                ],\n              ],\n            },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'my-machine'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '{ Prop: \"new-value\" }, ',\n                    '{ \"Param\" : ',\n                    { 'Fn::Sub': '${Param1}' },\n                    ' }',\n                  ],\n                ],\n              },\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });\n\n  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the state machines's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '',\n                [\n                  '{ Prop: \"old-value\" }, ',\n                  '{ \"S3Bucket\" : ',\n                  { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                  ' }',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '{ Prop: \"new-value\" }, ',\n                    '{ \"S3Bucket\" : ',\n                    { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                    ' }',\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });\n\n  test('knows how to handle attributes of the AWS::Events::EventBus resource', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        EventBus: {\n          Type: 'AWS::Events::EventBus',\n          Properties: {\n            Name: 'my-event-bus',\n          },\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': ['', [\n                '{\"EventBus1Arn\":\"',\n                { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                '\",\"EventBus1Name\":\"',\n                { 'Fn::GetAtt': ['EventBus', 'Name'] },\n                '\",\"EventBus1Ref\":\"',\n                { Ref: 'EventBus' },\n                '\"}',\n              ]],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('EventBus', 'AWS::Events::EventBus', 'my-event-bus'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          EventBus: {\n            Type: 'AWS::Events::EventBus',\n            Properties: {\n              Name: 'my-event-bus',\n            },\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': ['', [\n                  '{\"EventBus2Arn\":\"',\n                  { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                  '\",\"EventBus2Name\":\"',\n                  { 'Fn::GetAtt': ['EventBus', 'Name'] },\n                  '\",\"EventBus2Ref\":\"',\n                  { Ref: 'EventBus' },\n                  '\"}',\n                ]],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    const result = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    expect(result).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      definition: JSON.stringify({\n        EventBus2Arn: 'arn:aws:events:here:123456789012:event-bus/my-event-bus',\n        EventBus2Name: 'my-event-bus',\n        EventBus2Ref: 'my-event-bus',\n      }),\n    });\n  });\n\n  test('knows how to handle attributes of the AWS::DynamoDB::Table resource', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Table: {\n          Type: 'AWS::DynamoDB::Table',\n          Properties: {\n            KeySchema: [{\n              AttributeName: 'name',\n              KeyType: 'HASH',\n            }],\n            AttributeDefinitions: [{\n              AttributeName: 'name',\n              AttributeType: 'S',\n            }],\n            BillingMode: 'PAY_PER_REQUEST',\n          },\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{}',\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Table', 'AWS::DynamoDB::Table', 'my-dynamodb-table'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Table: {\n            Type: 'AWS::DynamoDB::Table',\n            Properties: {\n              KeySchema: [{\n                AttributeName: 'name',\n                KeyType: 'HASH',\n              }],\n              AttributeDefinitions: [{\n                AttributeName: 'name',\n                AttributeType: 'S',\n              }],\n              BillingMode: 'PAY_PER_REQUEST',\n            },\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': ['', [\n                  '{\"TableName\":\"',\n                  { Ref: 'Table' },\n                  '\",\"TableArn\":\"',\n                  { 'Fn::GetAtt': ['Table', 'Arn'] },\n                  '\"}',\n                ]],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    const result = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    expect(result).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      definition: JSON.stringify({\n        TableName: 'my-dynamodb-table',\n        TableArn: 'arn:aws:dynamodb:here:123456789012:table/my-dynamodb-table',\n      }),\n    });\n  });\n\n  test('does not explode if the DependsOn changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n            StateMachineName: 'my-machine',\n          },\n          DependsOn: ['abc'],\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"old-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n          DependsOn: ['xyz'],\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toEqual(true);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n  });\n});","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns undefined when a new StateMachine is added to the Stack","suites":[],"updatePoint":{"line":16,"column":71},"line":16,"code":"  test('returns undefined when a new StateMachine is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateStateMachine() API when it receives only a definitionString change without Fn::Join in a state machine","suites":[],"updatePoint":{"line":46,"column":126},"line":46,"code":"  test('calls the updateStateMachine() API when it receives only a definitionString change without Fn::Join in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '{ Prop: \"new-value\" }',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateStateMachine() API when it receives only a definitionString change with Fn::Join in a state machine","suites":[],"updatePoint":{"line":84,"column":123},"line":84,"code":"  test('calls the updateStateMachine() API when it receives only a definitionString change with Fn::Join in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '\\n',\n                [\n                  '{',\n                  '  \"StartAt\" : \"SuccessState\"',\n                  '  \"States\" : {',\n                  '    \"SuccessState\": {',\n                  '      \"Type\": \"Pass\"',\n                  '      \"Result\": \"Success\"',\n                  '      \"End\": true',\n                  '    }',\n                  '  }',\n                  '}',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '\\n',\n                  [\n                    '{',\n                    '  \"StartAt\": \"SuccessState\",',\n                    '  \"States\": {',\n                    '    \"SuccessState\": {',\n                    '      \"Type\": \"Succeed\"',\n                    '    }',\n                    '  }',\n                    '}',\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: JSON.stringify({\n        StartAt: 'SuccessState',\n        States: {\n          SuccessState: {\n            Type: 'Succeed',\n          },\n        },\n      }, null, 2),\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateStateMachine() API when it receives a change to the definitionString in a state machine that has no name","suites":[],"updatePoint":{"line":159,"column":128},"line":159,"code":"  test('calls the updateStateMachine() API when it receives a change to the definitionString in a state machine that has no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ \"Prop\" : \"old-value\" }',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ \"Prop\" : \"new-value\" }',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '{ \"Prop\" : \"new-value\" }',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the updateStateMachine() API when it receives a change to a property that is not the definitionString in a state machine\n        alongside a hotswappable change in CLASSIC mode but does in HOTSWAP_ONLY mode","suites":[],"updatePoint":{"line":197,"column":85},"line":196,"code":"  test(`does not call the updateStateMachine() API when it receives a change to a property that is not the definitionString in a state machine\n        alongside a hotswappable change in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ \"Prop\" : \"old-value\" }',\n            LoggingConfiguration: { // non-definitionString property\n              IncludeExecutionData: true,\n            },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ \"Prop\" : \"new-value\" }',\n              LoggingConfiguration: {\n                IncludeExecutionData: false,\n              },\n            },\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n        definition: '{ \"Prop\" : \"new-value\" }',\n        stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      });\n    }\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not call the updateStateMachine() API when a resource has a DefinitionString property but is not an AWS::StepFunctions::StateMachine is changed","suites":[],"updatePoint":{"line":250,"column":156},"line":250,"code":"  test('does not call the updateStateMachine() API when a resource has a DefinitionString property but is not an AWS::StepFunctions::StateMachine is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::NotStepFunctions::NotStateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::NotStepFunctions::NotStateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can correctly hotswap old style synth changes","suites":[],"updatePoint":{"line":293,"column":53},"line":293,"code":"  test('can correctly hotswap old style synth changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: { AssetParam1: { Type: 'String' } },\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: { Ref: 'AssetParam1' },\n            StateMachineName: 'machine-name',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: { AssetParam2: { Type: String } },\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: { Ref: 'AssetParam2' },\n              StateMachineName: 'machine-name',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetParam2: 'asset-param-2' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: 'asset-param-2',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:machine-name',\n    });\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls the updateStateMachine() API when it receives a change to the definitionString that uses Attributes in a state machine","suites":[],"updatePoint":{"line":334,"column":132},"line":334,"code":"  test('calls the updateStateMachine() API when it receives a change to the definitionString that uses Attributes in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '\\n',\n                [\n                  '{',\n                  '  \"StartAt\" : \"SuccessState\"',\n                  '  \"States\" : {',\n                  '    \"SuccessState\": {',\n                  '      \"Type\": \"Succeed\"',\n                  '    }',\n                  '  }',\n                  '}',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '\"Resource\": ',\n                    { 'Fn::GetAtt': ['Func', 'Arn'] },\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'),\n    );\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '\"Resource\": arn:aws:lambda:here:123456789012:function:my-func',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"will not perform a hotswap deployment if it cannot find a Ref target (outside the state machine's name)","suites":[],"updatePoint":{"line":404,"column":111},"line":404,"code":"  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the state machine's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '',\n                [\n                  '{ Prop: \"old-value\" }, ',\n                  '{ \"Param\" : ',\n                  { 'Fn::Sub': '${Param1}' },\n                  ' }',\n                ],\n              ],\n            },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'my-machine'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '{ Prop: \"new-value\" }, ',\n                    '{ \"Param\" : ',\n                    { 'Fn::Sub': '${Param1}' },\n                    ' }',\n                  ],\n                ],\n              },\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the state machines's name)","suites":[],"updatePoint":{"line":462,"column":135},"line":462,"code":"  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the state machines's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '',\n                [\n                  '{ Prop: \"old-value\" }, ',\n                  '{ \"S3Bucket\" : ',\n                  { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                  ' }',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '{ Prop: \"new-value\" }, ',\n                    '{ \"S3Bucket\" : ',\n                    { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                    ' }',\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"knows how to handle attributes of the AWS::Events::EventBus resource","suites":[],"updatePoint":{"line":525,"column":76},"line":525,"code":"  test('knows how to handle attributes of the AWS::Events::EventBus resource', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        EventBus: {\n          Type: 'AWS::Events::EventBus',\n          Properties: {\n            Name: 'my-event-bus',\n          },\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': ['', [\n                '{\"EventBus1Arn\":\"',\n                { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                '\",\"EventBus1Name\":\"',\n                { 'Fn::GetAtt': ['EventBus', 'Name'] },\n                '\",\"EventBus1Ref\":\"',\n                { Ref: 'EventBus' },\n                '\"}',\n              ]],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('EventBus', 'AWS::Events::EventBus', 'my-event-bus'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          EventBus: {\n            Type: 'AWS::Events::EventBus',\n            Properties: {\n              Name: 'my-event-bus',\n            },\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': ['', [\n                  '{\"EventBus2Arn\":\"',\n                  { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                  '\",\"EventBus2Name\":\"',\n                  { 'Fn::GetAtt': ['EventBus', 'Name'] },\n                  '\",\"EventBus2Ref\":\"',\n                  { Ref: 'EventBus' },\n                  '\"}',\n                ]],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    const result = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    expect(result).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      definition: JSON.stringify({\n        EventBus2Arn: 'arn:aws:events:here:123456789012:event-bus/my-event-bus',\n        EventBus2Name: 'my-event-bus',\n        EventBus2Ref: 'my-event-bus',\n      }),\n    });\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"knows how to handle attributes of the AWS::DynamoDB::Table resource","suites":[],"updatePoint":{"line":601,"column":75},"line":601,"code":"  test('knows how to handle attributes of the AWS::DynamoDB::Table resource', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Table: {\n          Type: 'AWS::DynamoDB::Table',\n          Properties: {\n            KeySchema: [{\n              AttributeName: 'name',\n              KeyType: 'HASH',\n            }],\n            AttributeDefinitions: [{\n              AttributeName: 'name',\n              AttributeType: 'S',\n            }],\n            BillingMode: 'PAY_PER_REQUEST',\n          },\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{}',\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Table', 'AWS::DynamoDB::Table', 'my-dynamodb-table'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Table: {\n            Type: 'AWS::DynamoDB::Table',\n            Properties: {\n              KeySchema: [{\n                AttributeName: 'name',\n                KeyType: 'HASH',\n              }],\n              AttributeDefinitions: [{\n                AttributeName: 'name',\n                AttributeType: 'S',\n              }],\n              BillingMode: 'PAY_PER_REQUEST',\n            },\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': ['', [\n                  '{\"TableName\":\"',\n                  { Ref: 'Table' },\n                  '\",\"TableArn\":\"',\n                  { 'Fn::GetAtt': ['Table', 'Arn'] },\n                  '\"}',\n                ]],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    const result = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    expect(result).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      definition: JSON.stringify({\n        TableName: 'my-dynamodb-table',\n        TableArn: 'arn:aws:dynamodb:here:123456789012:table/my-dynamodb-table',\n      }),\n    });\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not explode if the DependsOn changes","suites":[],"updatePoint":{"line":680,"column":49},"line":680,"code":"  test('does not explode if the DependsOn changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n            StateMachineName: 'my-machine',\n          },\n          DependsOn: ['abc'],\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"old-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n          DependsOn: ['xyz'],\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toEqual(true);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n  });","file":"api/hotswap/state-machine-hotswap-deployments.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"correctly caches calls to the CloudFormation API","suites":["Lazy ListStackResources"],"updatePoint":{"line":7,"column":56},"line":7,"code":"  test('correctly caches calls to the CloudFormation API', async () => {\n    // GIVEN\n    const listStackResMock: jest.Mock<AWS.CloudFormation.ListStackResourcesOutput, AWS.CloudFormation.ListStackResourcesInput[]> = jest.fn();\n    const mockSdk = new MockSdk();\n    mockSdk.stubCloudFormation({\n      listStackResources: listStackResMock,\n    });\n    listStackResMock.mockReturnValue({\n      StackResourceSummaries: [],\n      NextToken: undefined,\n    });\n    const res = new LazyListStackResources(mockSdk, 'StackName');\n\n    // WHEN\n    void res.listStackResources();\n    void res.listStackResources();\n    void res.listStackResources();\n    const result = await res.listStackResources();\n\n    // THEN\n    expect(result.length).toBe(0);\n    expect(listStackResMock).toHaveBeenCalledTimes(1);\n  });","file":"api/lazy-list-stack-resources.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"add log groups from lambda function","suites":[],"updatePoint":{"line":19,"column":41},"line":19,"code":"test('add log groups from lambda function', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-function'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['/aws/lambda/my-function']);\n});","file":"api/logs/find-cloudwatch-logs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"add log groups from lambda function without physical name","suites":[],"updatePoint":{"line":42,"column":63},"line":42,"code":"test('add log groups from lambda function without physical name', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-function'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['/aws/lambda/my-function']);\n});","file":"api/logs/find-cloudwatch-logs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"empty template","suites":[],"updatePoint":{"line":62,"column":20},"line":62,"code":"test('empty template', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {},\n  });\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual([]);\n});","file":"api/logs/find-cloudwatch-logs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"add log groups from ECS Task Definitions","suites":[],"updatePoint":{"line":75,"column":46},"line":75,"code":"test('add log groups from ECS Task Definitions', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        LogGroup: {\n          Type: 'AWS::Logs::LogGroup',\n          Properties: {\n            LogGroupName: 'log_group',\n          },\n        },\n        Def: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'app',\n            ContainerDefinitions: [\n              {\n                LogConfiguration: {\n                  LogDriver: 'awslogs',\n                  Options: {\n                    'awslogs-group': { Ref: 'LogGroup' },\n                  },\n                },\n              },\n            ],\n          },\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('LogGroup', 'AWS::Logs::LogGroup', 'log_group'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['log_group']);\n});","file":"api/logs/find-cloudwatch-logs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"add log groups from State Machines","suites":[],"updatePoint":{"line":114,"column":40},"line":114,"code":"test('add log groups from State Machines', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        LogGroup: {\n          Type: 'AWS::Logs::LogGroup',\n          Properties: {\n            LogGroupName: 'log_group',\n          },\n        },\n        Def: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            LoggingConfiguration: {\n              Destinations: [\n                {\n                  CloudWatchLogsLogGroup: {\n                    LogGroupArn: {\n                      'Fn::GetAtt': ['LogGroup', 'Arn'],\n                    },\n                  },\n                },\n              ],\n            },\n          },\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('LogGroup', 'AWS::Logs::LogGroup', 'log_group'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['log_group']);\n});","file":"api/logs/find-cloudwatch-logs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"excluded log groups are not added","suites":[],"updatePoint":{"line":153,"column":39},"line":153,"code":"test('excluded log groups are not added', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        LogGroup: {\n          Type: 'AWS::Logs::LogGroup',\n          Properties: {\n            LogGroupName: 'log_group',\n          },\n        },\n        LogGroup2: {\n          Type: 'AWS::Logs::LogGroup',\n          Properties: {\n            LogGroupName: 'log_group2',\n          },\n        },\n        Def: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            PojectName: 'project',\n            LogsConfig: {\n              CloudWatchLogs: {\n                GroupName: { Ref: 'LogGroup' },\n              },\n            },\n          },\n        },\n        FlowLog: {\n          Type: 'AWS::EC2::FlowLog',\n          Properties: {\n            LogDestination: { Ref: 'LogGroup' },\n          },\n        },\n        FlowLog2: {\n          Type: 'AWS::EC2::FlowLog',\n          Properties: {\n            LogDestination: {\n              'Fn::GetAtt': ['LogGroup2', 'Arn'],\n            },\n          },\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('LogGroup', 'AWS::Logs::LogGroup', 'log_group'));\n  pushStackResourceSummaries(stackSummaryOf('LogGroup2', 'AWS::Logs::LogGroup', 'log_group2'));\n  pushStackResourceSummaries(stackSummaryOf('FlowLog', 'AWS::EC2::FlowLog', 'flow_log'));\n  pushStackResourceSummaries(stackSummaryOf('FlowLog2', 'AWS::EC2::FlowLog', 'flow_log2'));\n  pushStackResourceSummaries(stackSummaryOf('Def', 'AWS::CodeBuild:Project', 'project'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual([]);\n});","file":"api/logs/find-cloudwatch-logs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"unassociated log groups are added","suites":[],"updatePoint":{"line":211,"column":39},"line":211,"code":"test('unassociated log groups are added', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        LogGroup: {\n          Type: 'AWS::Logs::LogGroup',\n          Properties: {\n            LogGroupName: 'log_group',\n          },\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('LogGroup', 'AWS::Logs::LogGroup', 'log_group'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['log_group']);\n});","file":"api/logs/find-cloudwatch-logs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"log groups without physical names are added","suites":[],"updatePoint":{"line":234,"column":49},"line":234,"code":"test('log groups without physical names are added', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        LogGroup: {\n          Type: 'AWS::Logs::LogGroup',\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('LogGroup', 'AWS::Logs::LogGroup', 'log_group'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['log_group']);\n});","file":"api/logs/find-cloudwatch-logs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"process events","suites":[],"updatePoint":{"line":21,"column":20},"line":21,"code":"test('process events', async () => {\n  // GIVEN\n  const eventDate = new Date(T0 + 102 * 1000);\n  sdk.stubCloudWatchLogs({\n    filterLogEvents() {\n      return {\n        events: [event(102, 'message', eventDate)],\n      };\n    },\n  });\n  monitor.addLogGroups(\n    {\n      name: 'name',\n      account: '11111111111',\n      region: 'us-east-1',\n    },\n    sdk,\n    ['loggroup'],\n  );\n  // WHEN\n  monitor.activate();\n  // need time for the log processing to occur\n  await sleep(1000);\n\n  // THEN\n  const expectedLocaleTimeString = eventDate.toLocaleTimeString();\n  expect(stderrMock).toHaveBeenCalledTimes(1);\n  expect(stderrMock.mock.calls[0][0]).toContain(\n    `[${blue('loggroup')}] ${yellow(expectedLocaleTimeString)} message`,\n  );\n});","file":"api/logs/logs-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"process truncated events","suites":[],"updatePoint":{"line":53,"column":30},"line":53,"code":"test('process truncated events', async () => {\n  // GIVEN\n  const eventDate = new Date(T0 + 102 * 1000);\n  const events: AWS.CloudWatchLogs.FilteredLogEvents = [];\n  for (let i = 0; i < 100; i++) {\n    events.push(event(102+i, 'message' + i, eventDate));\n  }\n\n  sdk.stubCloudWatchLogs({\n    filterLogEvents() {\n      return {\n        events,\n        nextToken: 'some-token',\n      };\n    },\n  });\n  monitor.addLogGroups(\n    {\n      name: 'name',\n      account: '11111111111',\n      region: 'us-east-1',\n    },\n    sdk,\n    ['loggroup'],\n  );\n  // WHEN\n  monitor.activate();\n  // need time for the log processing to occur\n  await sleep(1000);\n\n  // THEN\n  const expectedLocaleTimeString = eventDate.toLocaleTimeString();\n  expect(stderrMock).toHaveBeenCalledTimes(101);\n  expect(stderrMock.mock.calls[0][0]).toContain(\n    `[${blue('loggroup')}] ${yellow(expectedLocaleTimeString)} message`,\n  );\n  expect(stderrMock.mock.calls[100][0]).toContain(\n    `[${blue('loggroup')}] ${yellow(expectedLocaleTimeString)} >>> \\`watch\\` shows only the first 100 log messages - the rest have been truncated...`,\n  );\n});","file":"api/logs/logs-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"uses default credentials by default","suites":["with intercepted network calls","when CDK does not AssumeRole"],"updatePoint":{"line":90,"column":45},"line":90,"code":"    test('uses default credentials by default', async () => {\n      // WHEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          default: { aws_access_key_id: 'access', $account: '11111', $fakeStsOptions: { partition: 'aws-here' } },\n        },\n        config: {\n          default: { region: 'eu-bla-5' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // THEN\n      expect(provider.defaultRegion).toEqual('eu-bla-5');\n      await expect(provider.defaultAccount()).resolves.toEqual({ accountId: uniq('11111'), partition: 'aws-here' });\n\n      // Ask for a different region\n      const sdk = (await provider.forEnvironment({ ...env(uniq('11111')), region: 'rgn' }, Mode.ForReading)).sdk;\n      expect(sdkConfig(sdk).credentials!.accessKeyId).toEqual(uniq('access'));\n      expect(sdk.currentRegion).toEqual('rgn');\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws if profile credentials are not for the right account","suites":["with intercepted network calls","when CDK does not AssumeRole"],"updatePoint":{"line":113,"column":69},"line":113,"code":"    test('throws if profile credentials are not for the right account', async () => {\n      // WHEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          'profile boo': { aws_access_key_id: 'access', $account: '11111' },\n        },\n      });\n      const provider = await providerFromProfile('boo');\n\n      await expect(provider.forEnvironment(env(uniq('some_account_#')), Mode.ForReading)).rejects.toThrow('Need to perform AWS calls');\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"use profile acct/region if agnostic env requested","suites":["with intercepted network calls","when CDK does not AssumeRole"],"updatePoint":{"line":126,"column":59},"line":126,"code":"    test('use profile acct/region if agnostic env requested', async () => {\n      // WHEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          default: { aws_access_key_id: 'access', $account: '11111' },\n        },\n        config: {\n          default: { region: 'eu-bla-5' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // THEN\n      const sdk = (await provider.forEnvironment(cxapi.EnvironmentUtils.make(cxapi.UNKNOWN_ACCOUNT, cxapi.UNKNOWN_REGION), Mode.ForReading)).sdk;\n      expect(sdkConfig(sdk).credentials!.accessKeyId).toEqual(uniq('access'));\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('11111'));\n      expect(sdk.currentRegion).toEqual('eu-bla-5');\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passing profile skips EnvironmentCredentials","suites":["with intercepted network calls","when CDK does not AssumeRole"],"updatePoint":{"line":146,"column":54},"line":146,"code":"    test('passing profile skips EnvironmentCredentials', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          foo: { aws_access_key_id: 'access', $account: '11111' },\n        },\n      });\n      const provider = await providerFromProfile('foo');\n\n      const environmentCredentialsPrototype = (new AWS.EnvironmentCredentials('AWS')).constructor.prototype;\n\n      await withMocked(environmentCredentialsPrototype, 'refresh', async (refresh) => {\n        refresh.mockImplementation((callback: (err?: Error) => void) => callback(new Error('This function should not have been called')));\n\n        // WHEN\n        expect((await provider.defaultAccount())?.accountId).toEqual(uniq('11111'));\n\n        expect(refresh).not.toHaveBeenCalled();\n      });\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"supports profile spread over config_file and credentials_file","suites":["with intercepted network calls","when CDK does not AssumeRole"],"updatePoint":{"line":168,"column":71},"line":168,"code":"    test('supports profile spread over config_file and credentials_file', async () => {\n      // WHEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          foo: { aws_access_key_id: 'fooccess', $account: '22222' },\n        },\n        config: {\n          'default': { region: 'eu-bla-5' },\n          'profile foo': { region: 'eu-west-1' },\n        },\n      });\n      const provider = await SdkProvider.withAwsCliCompatibleDefaults({ ...defaultCredOptions, profile: 'foo' });\n\n      // THEN\n      expect(provider.defaultRegion).toEqual('eu-west-1');\n      await expect(provider.defaultAccount()).resolves.toEqual({ accountId: uniq('22222'), partition: 'aws' });\n\n      const sdk = (await provider.forEnvironment(env(uniq('22222')), Mode.ForReading)).sdk;\n      expect(sdkConfig(sdk).credentials!.accessKeyId).toEqual(uniq('fooccess'));\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"supports profile only in config_file","suites":["with intercepted network calls","when CDK does not AssumeRole"],"updatePoint":{"line":190,"column":46},"line":190,"code":"    test('supports profile only in config_file', async () => {\n      // WHEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          'default': { region: 'eu-bla-5' },\n          'profile foo': { aws_access_key_id: 'fooccess', $account: '22222' },\n        },\n      });\n      const provider = await providerFromProfile('foo');\n\n      // THEN\n      expect(provider.defaultRegion).toEqual('eu-bla-5'); // Fall back to default config\n      await expect(provider.defaultAccount()).resolves.toEqual({ accountId: uniq('22222'), partition: 'aws' });\n\n      const sdk = (await provider.forEnvironment(env(uniq('22222')), Mode.ForReading)).sdk;\n      expect(sdkConfig(sdk).credentials!.accessKeyId).toEqual(uniq('fooccess'));\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can assume-role configured in config","suites":["with intercepted network calls","when CDK does not AssumeRole"],"updatePoint":{"line":209,"column":46},"line":209,"code":"    test('can assume-role configured in config', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          assumer: { aws_access_key_id: 'assumer', $account: '11111' },\n        },\n        config: {\n          'default': { region: 'eu-bla-5' },\n          'profile assumer': { region: 'us-east-2' },\n          'profile assumable': {\n            role_arn: 'arn:aws:iam::66666:role/Assumable',\n            source_profile: 'assumer',\n            $account: '66666',\n            $fakeStsOptions: { allowedAccounts: ['11111'] },\n          },\n        },\n      });\n      const provider = await providerFromProfile('assumable');\n\n      // WHEN\n      const sdk = (await provider.forEnvironment(env(uniq('66666')), Mode.ForReading)).sdk;\n\n      // THEN\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('66666'));\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can assume role even if [default] profile is missing","suites":["with intercepted network calls","when CDK does not AssumeRole"],"updatePoint":{"line":236,"column":62},"line":236,"code":"    test('can assume role even if [default] profile is missing', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          assumer: { aws_access_key_id: 'assumer', $account: '22222' },\n          assumable: { role_arn: 'arn:aws:iam::12356789012:role/Assumable', source_profile: 'assumer', $account: '22222' },\n        },\n        config: {\n          'profile assumable': { region: 'eu-bla-5' },\n        },\n      });\n\n      // WHEN\n      const provider = await providerFromProfile('assumable');\n\n      // THEN\n      expect((await provider.defaultAccount())?.accountId).toEqual(uniq('22222'));\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"mfa_serial in profile will ask user for token","suites":["with intercepted network calls","when CDK does not AssumeRole"],"updatePoint":{"line":256,"column":55},"line":256,"code":"    test('mfa_serial in profile will ask user for token', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          assumer: { aws_access_key_id: 'assumer', $account: '66666' },\n        },\n        config: {\n          'default': { region: 'eu-bla-5' },\n          'profile assumer': { region: 'us-east-2' },\n          'profile mfa-role': {\n            role_arn: 'arn:aws:iam::66666:role/Assumable',\n            source_profile: 'assumer',\n            mfa_serial: 'arn:aws:iam::account:mfa/user',\n            $account: '66666',\n          },\n        },\n      });\n      const provider = await providerFromProfile('mfa-role');\n\n      const promptlyMockCalls = (promptly.prompt as jest.Mock).mock.calls.length;\n\n      // THEN\n      const sdk = (await provider.forEnvironment(env(uniq('66666')), Mode.ForReading)).sdk;\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('66666'));\n      expect(fakeSts.assumedRoles[0]).toEqual(expect.objectContaining({\n        roleArn: 'arn:aws:iam::66666:role/Assumable',\n        serialNumber: 'arn:aws:iam::account:mfa/user',\n        tokenCode: '1234',\n      }));\n\n      // Mock response was set to fail to make sure we don't call STS\n      // Make sure the MFA mock was called during this test\n      expect((promptly.prompt as jest.Mock).mock.calls.length).toBe(promptlyMockCalls + 1);\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"error we get from assuming a role is useful","suites":["with intercepted network calls","when CDK AssumeRoles"],"updatePoint":{"line":300,"column":53},"line":300,"code":"    test('error we get from assuming a role is useful', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // WHEN\n      const promise = provider.forEnvironment(env(uniq('88888')), Mode.ForReading, {\n        assumeRoleArn: 'doesnotexist.role.arn',\n      });\n\n      // THEN - error message contains both a helpful hint and the underlying AssumeRole message\n      await expect(promise).rejects.toThrow('(re)-bootstrap the environment');\n      await expect(promise).rejects.toThrow('doesnotexist.role.arn');\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"assuming a role sanitizes the username into the session name","suites":["with intercepted network calls","when CDK AssumeRoles"],"updatePoint":{"line":320,"column":70},"line":320,"code":"    test('assuming a role sanitizes the username into the session name', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '11111' },\n        },\n      });\n\n      await withMocked(os, 'userInfo', async (userInfo) => {\n        userInfo.mockReturnValue({ username: 'skl', uid: 1, gid: 1, homedir: '/here', shell: '/bin/sh' });\n\n        // WHEN\n        const provider = await providerFromProfile(undefined);\n\n        const sdk = (await provider.forEnvironment(env(uniq('88888')), Mode.ForReading, { assumeRoleArn: 'arn:aws:role' })).sdk as SDK;\n        await sdk.currentAccount();\n\n        // THEN\n        expect(fakeSts.assumedRoles[0]).toEqual(expect.objectContaining({\n          roleSessionName: 'aws-cdk-sk@l',\n        }));\n      });\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"assuming a role does not fail when OS username cannot be read","suites":["with intercepted network calls","when CDK AssumeRoles"],"updatePoint":{"line":345,"column":71},"line":345,"code":"    test('assuming a role does not fail when OS username cannot be read', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '11111' },\n        },\n      });\n\n      await withMocked(os, 'userInfo', async (userInfo) => {\n        userInfo.mockImplementation(() => {\n          // SystemError thrown as documented: https://nodejs.org/docs/latest-v16.x/api/os.html#osuserinfooptions\n          throw new Error('SystemError on Linux: uv_os_get_passwd returned ENOENT. See #19401 issue.');\n        });\n\n        // WHEN\n        const provider = await providerFromProfile(undefined);\n\n        const sdk = (await provider.forEnvironment(env(uniq('88888')), Mode.ForReading, { assumeRoleArn: 'arn:aws:role' })).sdk as SDK;\n        await sdk.currentAccount();\n\n        // THEN\n        expect(fakeSts.assumedRoles[0]).toEqual(expect.objectContaining({\n          roleSessionName: 'aws-cdk-noname',\n        }));\n      });\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"even if current credentials are for the wrong account, we will still use them to AssumeRole","suites":["with intercepted network calls","when CDK AssumeRoles"],"updatePoint":{"line":373,"column":101},"line":373,"code":"    test('even if current credentials are for the wrong account, we will still use them to AssumeRole', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '11111' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // WHEN\n      const sdk = (await provider.forEnvironment(env(uniq('88888')), Mode.ForReading, { assumeRoleArn: 'arn:aws:role' })).sdk as SDK;\n\n      // THEN\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('88888'));\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"if AssumeRole fails but current credentials are for the right account, we will still use them","suites":["with intercepted network calls","when CDK AssumeRoles"],"updatePoint":{"line":390,"column":103},"line":390,"code":"    test('if AssumeRole fails but current credentials are for the right account, we will still use them', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '88888' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // WHEN - assumeRole fails because the role can only be assumed from account 11111\n      const sdk = (await provider.forEnvironment(env(uniq('88888')), Mode.ForReading, { assumeRoleArn: 'arn:aws:role' })).sdk as SDK;\n\n      // THEN\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('88888'));\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"if AssumeRole fails because of ExpiredToken, then fail completely","suites":["with intercepted network calls","when CDK AssumeRoles"],"updatePoint":{"line":407,"column":75},"line":407,"code":"    test('if AssumeRole fails because of ExpiredToken, then fail completely', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '88888' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // WHEN - assumeRole fails with a specific error\n      await expect(async () => {\n        await provider.forEnvironment(env(uniq('88888')), Mode.ForReading, { assumeRoleArn: '<FAIL:ExpiredToken>' });\n      }).rejects.toThrow(/ExpiredToken/);\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not use plugins if current credentials are for expected account","suites":["with intercepted network calls","Plugins"],"updatePoint":{"line":425,"column":78},"line":425,"code":"    test('does not use plugins if current credentials are for expected account', async () => {\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '11111' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n      await provider.forEnvironment(env(uniq('11111')), Mode.ForReading);\n      expect(pluginQueried).toEqual(false);\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"uses plugin for account 99999","suites":["with intercepted network calls","Plugins"],"updatePoint":{"line":437,"column":39},"line":437,"code":"    test('uses plugin for account 99999', async () => {\n      const provider = await providerFromProfile(undefined);\n      await provider.forEnvironment(env(uniq('99999')), Mode.ForReading);\n      expect(pluginQueried).toEqual(true);\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can assume role with credentials from plugin","suites":["with intercepted network calls","Plugins"],"updatePoint":{"line":443,"column":54},"line":443,"code":"    test('can assume role with credentials from plugin', async () => {\n      fakeSts.registerRole(uniq('99999'), 'arn:aws:iam::99999:role/Assumable');\n\n      const provider = await providerFromProfile(undefined);\n      await provider.forEnvironment(env(uniq('99999')), Mode.ForReading, {\n        assumeRoleArn: 'arn:aws:iam::99999:role/Assumable',\n      });\n\n      expect(fakeSts.assumedRoles[0]).toEqual(expect.objectContaining({\n        roleArn: 'arn:aws:iam::99999:role/Assumable',\n      }));\n      expect(pluginQueried).toEqual(true);\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"even if AssumeRole fails but current credentials are from a plugin, we will still use them","suites":["with intercepted network calls","Plugins"],"updatePoint":{"line":457,"column":100},"line":457,"code":"    test('even if AssumeRole fails but current credentials are from a plugin, we will still use them', async () => {\n      const provider = await providerFromProfile(undefined);\n      const sdk = (await provider.forEnvironment(env(uniq('99999')), Mode.ForReading, { assumeRoleArn: 'does:not:exist' })).sdk;\n\n      // THEN\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('99999'));\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"plugins are still queried even if current credentials are expired (or otherwise invalid)","suites":["with intercepted network calls","Plugins"],"updatePoint":{"line":465,"column":98},"line":465,"code":"    test('plugins are still queried even if current credentials are expired (or otherwise invalid)', async () => {\n      // GIVEN\n      process.env.AWS_ACCESS_KEY_ID = `${uid}akid`;\n      process.env.AWS_SECRET_ACCESS_KEY = 'sekrit';\n      const provider = await providerFromProfile(undefined);\n\n      // WHEN\n      await provider.forEnvironment(env(uniq('99999')), Mode.ForReading);\n\n      // THEN\n      expect(pluginQueried).toEqual(true);\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can assume role with ecs credentials","suites":["with intercepted network calls","support for credential_source"],"updatePoint":{"line":480,"column":46},"line":480,"code":"    test('can assume role with ecs credentials', async () => {\n      return withMocked(AWS.ECSCredentials.prototype, 'needsRefresh', async (needsRefresh) => {\n        // GIVEN\n        prepareCreds({\n          config: {\n            'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'EcsContainer', $account: '22222' },\n          },\n        });\n        const provider = await providerFromProfile('ecs');\n\n        // WHEN\n        await provider.defaultAccount();\n\n        // THEN\n        expect(needsRefresh).toHaveBeenCalled();\n      });\n\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can assume role with ec2 credentials","suites":["with intercepted network calls","support for credential_source"],"updatePoint":{"line":499,"column":46},"line":499,"code":"    test('can assume role with ec2 credentials', async () => {\n      return withMocked(AWS.EC2MetadataCredentials.prototype, 'needsRefresh', async (needsRefresh) => {\n        // GIVEN\n        prepareCreds({\n          config: {\n            'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'Ec2InstanceMetadata', $account: '22222' },\n          },\n        });\n        const provider = await providerFromProfile('ecs');\n\n        // WHEN\n        await provider.defaultAccount();\n\n        // THEN\n        expect(needsRefresh).toHaveBeenCalled();\n\n      });\n\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can assume role with env credentials","suites":["with intercepted network calls","support for credential_source"],"updatePoint":{"line":519,"column":46},"line":519,"code":"    test('can assume role with env credentials', async () => {\n      return withMocked(AWS.EnvironmentCredentials.prototype, 'needsRefresh', async (needsRefresh) => {\n        // GIVEN\n        prepareCreds({\n          config: {\n            'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'Environment', $account: '22222' },\n          },\n        });\n        const provider = await providerFromProfile('ecs');\n\n        // WHEN\n        await provider.defaultAccount();\n\n        // THEN\n        expect(needsRefresh).toHaveBeenCalled();\n      });\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"assume fails with unsupported credential_source","suites":["with intercepted network calls","support for credential_source"],"updatePoint":{"line":537,"column":57},"line":537,"code":"    test('assume fails with unsupported credential_source', async () => {\n      // GIVEN\n      prepareCreds({\n        config: {\n          'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'unsupported', $account: '22222' },\n        },\n      });\n      const provider = await providerFromProfile('ecs');\n\n      // WHEN\n      const account = await provider.defaultAccount();\n\n      // THEN\n      expect(account?.accountId).toEqual(undefined);\n    });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"defaultAccount returns undefined if STS call fails","suites":["with intercepted network calls","support for credential_source"],"updatePoint":{"line":554,"column":58},"line":554,"code":"  test('defaultAccount returns undefined if STS call fails', async () => {\n    // GIVEN\n    process.env.AWS_ACCESS_KEY_ID = `${uid}akid`;\n    process.env.AWS_SECRET_ACCESS_KEY = 'sekrit';\n\n    // WHEN\n    const provider = await providerFromProfile(undefined);\n\n    // THEN\n    await expect(provider.defaultAccount()).resolves.toBe(undefined);\n  });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"defaultAccount returns undefined, event if STS call fails with ExpiredToken","suites":["with intercepted network calls","support for credential_source"],"updatePoint":{"line":566,"column":83},"line":566,"code":"  test('defaultAccount returns undefined, event if STS call fails with ExpiredToken', async () => {\n    // GIVEN\n    process.env.AWS_ACCESS_KEY_ID = `${uid}'<FAIL:ExpiredToken>'`;\n    process.env.AWS_SECRET_ACCESS_KEY = 'sekrit';\n\n    // WHEN\n    const provider = await providerFromProfile(undefined);\n\n    // THEN\n    await expect(provider.defaultAccount()).resolves.toBe(undefined);\n  });","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"even when using a profile to assume another profile, STS calls goes through the proxy","suites":["with intercepted network calls","support for credential_source"],"updatePoint":{"line":579,"column":91},"line":579,"code":"test('even when using a profile to assume another profile, STS calls goes through the proxy', async () => {\n  prepareCreds({\n    credentials: {\n      assumer: { aws_access_key_id: 'assumer' },\n    },\n    config: {\n      'default': { region: 'eu-bla-5' },\n      'profile assumable': { role_arn: 'arn:aws:iam::66666:role/Assumable', source_profile: 'assumer', $account: '66666' },\n      'profile assumer': { region: 'us-east-2' },\n    },\n  });\n\n  // Messy mocking\n  let called = false;\n  jest.mock('proxy-agent', () => {\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\n    class FakeAgent extends require('https').Agent {\n      public addRequest(_: any, __: any) {\n        // FIXME: this error takes 6 seconds to be completely handled. It\n        // might be retries in the SDK somewhere, or something about the Node\n        // event loop. I've spent an hour trying to figure it out and I can't,\n        // and I gave up. We'll just have to live with this until someone gets\n        // inspired.\n        const error = new Error('ABORTED BY TEST');\n        (error as any).code = 'RequestAbortedError';\n        (error as any).retryable = false;\n        called = true;\n        throw error;\n      }\n    }\n    return FakeAgent;\n  });\n\n  // WHEN\n  const provider = await SdkProvider.withAwsCliCompatibleDefaults({\n    ...defaultCredOptions,\n    profile: 'assumable',\n    httpOptions: {\n      proxyAddress: 'http://DOESNTMATTER/',\n    },\n  });\n\n  await provider.defaultAccount();\n\n  // THEN -- the fake proxy agent got called, we don't care about the result\n  expect(called).toEqual(true);\n});","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"default useragent is reasonable","suites":["with intercepted network calls","support for credential_source"],"updatePoint":{"line":627,"column":37},"line":627,"code":"test('default useragent is reasonable', () => {\n  expect(defaultCliUserAgent()).toContain('aws-cdk/');\n});","file":"api/sdk-provider.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"prints 0/4 progress report, when addActivity is called with an \"IN_PROGRESS\" ResourceStatus","suites":[],"updatePoint":{"line":14,"column":97},"line":14,"code":"test('prints 0/4 progress report, when addActivity is called with an \"IN_PROGRESS\" ResourceStatus', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 3,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n  });\n\n  expect(output[0].trim()).toStrictEqual(`stack-name | 0/4 | ${HUMAN_TIME} | ${reset('IN_PROGRESS         ')} | AWS::CloudFormation::Stack | ${reset(bold('stack1'))}`);\n});","file":"api/stack-activity-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"prints 1/4 progress report, when addActivity is called with an \"UPDATE_COMPLETE\" ResourceStatus","suites":[],"updatePoint":{"line":38,"column":101},"line":38,"code":"test('prints 1/4 progress report, when addActivity is called with an \"UPDATE_COMPLETE\" ResourceStatus', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 3,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_COMPLETE',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n  });\n\n  expect(output[0].trim()).toStrictEqual(`stack-name | 1/4 | ${HUMAN_TIME} | ${green('UPDATE_COMPLETE     ')} | AWS::CloudFormation::Stack | ${green(bold('stack1'))}`);\n});","file":"api/stack-activity-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"prints 1/4 progress report, when addActivity is called with an \"UPDATE_COMPLETE_CLEAN_IN_PROGRESS\" ResourceStatus","suites":[],"updatePoint":{"line":62,"column":119},"line":62,"code":"test('prints 1/4 progress report, when addActivity is called with an \"UPDATE_COMPLETE_CLEAN_IN_PROGRESS\" ResourceStatus', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 3,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_COMPLETE_CLEANUP_IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n  });\n\n  expect(output[0].trim()).toStrictEqual(`stack-name | 1/4 | ${HUMAN_TIME} | ${green('UPDATE_COMPLETE_CLEA')} | AWS::CloudFormation::Stack | ${green(bold('stack1'))}`);\n});","file":"api/stack-activity-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"prints 1/4 progress report, when addActivity is called with an \"ROLLBACK_COMPLETE_CLEAN_IN_PROGRESS\" ResourceStatus","suites":[],"updatePoint":{"line":86,"column":121},"line":86,"code":"test('prints 1/4 progress report, when addActivity is called with an \"ROLLBACK_COMPLETE_CLEAN_IN_PROGRESS\" ResourceStatus', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 3,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n  });\n\n  expect(output[0].trim()).toStrictEqual(`stack-name | 1/4 | ${HUMAN_TIME} | ${yellow('ROLLBACK_COMPLETE_CL')} | AWS::CloudFormation::Stack | ${yellow(bold('stack1'))}`);\n});","file":"api/stack-activity-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"prints 0/4 progress report, when addActivity is called with an \"UPDATE_FAILED\" ResourceStatus","suites":[],"updatePoint":{"line":110,"column":99},"line":110,"code":"test('prints 0/4 progress report, when addActivity is called with an \"UPDATE_FAILED\" ResourceStatus', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 3,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_FAILED',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n  });\n\n  expect(output[0].trim()).toStrictEqual(`stack-name | 0/4 | ${HUMAN_TIME} | ${red('UPDATE_FAILED       ')} | AWS::CloudFormation::Stack | ${red(bold('stack1'))}`);\n});","file":"api/stack-activity-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not print \"Failed Resources:\" list, when all deployments are successful","suites":[],"updatePoint":{"line":134,"column":82},"line":134,"code":"test('does not print \"Failed Resources:\" list, when all deployments are successful', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 1,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_COMPLETE',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack2',\n        ResourceStatus: 'UPDATE_COMPLETE',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n    historyActivityPrinter.stop();\n  });\n\n  expect(output.length).toStrictEqual(3);\n  expect(output[0].trim()).toStrictEqual(`stack-name | 0/2 | ${HUMAN_TIME} | ${reset('IN_PROGRESS         ')} | AWS::CloudFormation::Stack | ${reset(bold('stack1'))}`);\n  expect(output[1].trim()).toStrictEqual(`stack-name | 1/2 | ${HUMAN_TIME} | ${green('UPDATE_COMPLETE     ')} | AWS::CloudFormation::Stack | ${green(bold('stack1'))}`);\n  expect(output[2].trim()).toStrictEqual(`stack-name | 2/2 | ${HUMAN_TIME} | ${green('UPDATE_COMPLETE     ')} | AWS::CloudFormation::Stack | ${green(bold('stack2'))}`);\n});","file":"api/stack-activity-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"prints \"Failed Resources:\" list, when at least one deployment fails","suites":[],"updatePoint":{"line":184,"column":73},"line":184,"code":"test('prints \"Failed Resources:\" list, when at least one deployment fails', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 1,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_FAILED',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n    historyActivityPrinter.stop();\n  });\n\n  expect(output.length).toStrictEqual(4);\n  expect(output[0].trim()).toStrictEqual(`stack-name | 0/2 | ${HUMAN_TIME} | ${reset('IN_PROGRESS         ')} | AWS::CloudFormation::Stack | ${reset(bold('stack1'))}`);\n  expect(output[1].trim()).toStrictEqual(`stack-name | 0/2 | ${HUMAN_TIME} | ${red('UPDATE_FAILED       ')} | AWS::CloudFormation::Stack | ${red(bold('stack1'))}`);\n  expect(output[2].trim()).toStrictEqual('Failed resources:');\n  expect(output[3].trim()).toStrictEqual(`stack-name | ${HUMAN_TIME} | ${red('UPDATE_FAILED       ')} | AWS::CloudFormation::Stack | ${red(bold('stack1'))}`);\n});","file":"api/stack-activity-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"print failed resources because of hook failures","suites":[],"updatePoint":{"line":224,"column":53},"line":224,"code":"test('print failed resources because of hook failures', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 1,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n        HookStatus: 'HOOK_COMPLETE_FAILED',\n        HookType: 'hook1',\n        HookStatusReason: 'stack1 must obey certain rules',\n      },\n    });\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_FAILED',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n        ResourceStatusReason: 'The following hook(s) failed: hook1',\n      },\n    });\n    historyActivityPrinter.stop();\n  });\n\n  expect(output.length).toStrictEqual(4);\n  expect(output[0].trim()).toStrictEqual(`stack-name | 0/2 | ${HUMAN_TIME} | ${reset('IN_PROGRESS         ')} | AWS::CloudFormation::Stack | ${reset(bold('stack1'))}`);\n  expect(output[1].trim()).toStrictEqual(`stack-name | 0/2 | ${HUMAN_TIME} | ${red('UPDATE_FAILED       ')} | AWS::CloudFormation::Stack | ${red(bold('stack1'))} ${red(bold('The following hook(s) failed: hook1 : stack1 must obey certain rules'))}`);\n  expect(output[2].trim()).toStrictEqual('Failed resources:');\n  expect(output[3].trim()).toStrictEqual(`stack-name | ${HUMAN_TIME} | ${red('UPDATE_FAILED       ')} | AWS::CloudFormation::Stack | ${red(bold('stack1'))} ${red(bold('The following hook(s) failed: hook1 : stack1 must obey certain rules'))}`);\n});","file":"api/stack-activity-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"failure to read SSM parameter results in upgrade message for existing bootstrap stack under v5","suites":[],"updatePoint":{"line":10,"column":100},"line":10,"code":"test('failure to read SSM parameter results in upgrade message for existing bootstrap stack under v5', async () => {\n  // GIVEN\n  const toolkitInfo = ToolkitInfo.fromStack(mockBootstrapStack(mockSdk, {\n    Outputs: [{ OutputKey: 'BootstrapVersion', OutputValue: '4' }],\n  }), mockSdk);\n\n  mockSdk.stubSsm({\n    getParameter() {\n      throw errorWithCode('AccessDeniedException', 'Computer says no');\n    },\n  });\n\n  // THEN\n  await expect(toolkitInfo.validateVersion(99, '/abc')).rejects.toThrow(/This CDK deployment requires bootstrap stack version/);\n});","file":"api/toolkit-info.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"failure to read SSM parameter results in exception passthrough for existing bootstrap stack v5 or higher","suites":[],"updatePoint":{"line":26,"column":110},"line":26,"code":"test('failure to read SSM parameter results in exception passthrough for existing bootstrap stack v5 or higher', async () => {\n  // GIVEN\n  const toolkitInfo = ToolkitInfo.fromStack(mockBootstrapStack(mockSdk, {\n    Outputs: [{ OutputKey: 'BootstrapVersion', OutputValue: '5' }],\n  }), mockSdk);\n\n  mockSdk.stubSsm({\n    getParameter() {\n      throw errorWithCode('AccessDeniedException', 'Computer says no');\n    },\n  });\n\n  // THEN\n  await expect(toolkitInfo.validateVersion(99, '/abc')).rejects.toThrow(/Computer says no/);\n});","file":"api/toolkit-info.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"validating version with explicit SSM parameter succeeds","suites":["validateversion without bootstrap stack"],"updatePoint":{"line":48,"column":63},"line":48,"code":"  test('validating version with explicit SSM parameter succeeds', async () => {\n    // GIVEN\n    mockSdk.stubSsm({\n      getParameter() {\n        return { Parameter: { Value: '10' } };\n      },\n    });\n\n    // THEN\n    await expect(toolkitInfo.validateVersion(8, '/abc')).resolves.toBeUndefined();\n  });","file":"api/toolkit-info.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"validating version without explicit SSM parameter fails","suites":["validateversion without bootstrap stack"],"updatePoint":{"line":60,"column":63},"line":60,"code":"  test('validating version without explicit SSM parameter fails', async () => {\n    // WHEN\n    await expect(toolkitInfo.validateVersion(8, undefined)).rejects.toThrow(/This deployment requires a bootstrap stack with a known name/);\n  });","file":"api/toolkit-info.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"validating version with access denied error gives upgrade hint","suites":["validateversion without bootstrap stack"],"updatePoint":{"line":65,"column":70},"line":65,"code":"  test('validating version with access denied error gives upgrade hint', async () => {\n    // GIVEN\n    mockSdk.stubSsm({\n      getParameter() {\n        throw errorWithCode('AccessDeniedException', 'Computer says no');\n      },\n    });\n\n    // WHEN\n    await expect(toolkitInfo.validateVersion(8, '/abc')).rejects.toThrow(/This CDK deployment requires bootstrap stack version/);\n  });","file":"api/toolkit-info.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"validating version with missing parameter gives bootstrap hint","suites":["validateversion without bootstrap stack"],"updatePoint":{"line":77,"column":70},"line":77,"code":"  test('validating version with missing parameter gives bootstrap hint', async () => {\n    // GIVEN\n    mockSdk.stubSsm({\n      getParameter() {\n        throw errorWithCode('ParameterNotFound', 'Wut?');\n      },\n    });\n\n    // WHEN\n    await expect(toolkitInfo.validateVersion(8, '/abc')).rejects.toThrow(/Has the environment been bootstrapped?/);\n  });","file":"api/toolkit-info.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"displayLines writes maximum lines based on rows if there are more lines than rows","suites":["Rewritable Block Tests"],"updatePoint":{"line":12,"column":89},"line":12,"code":"  test('displayLines writes maximum lines based on rows if there are more lines than rows', () => {\n    const lines = Array.from(Array(100).keys()).map(line => line.toString());\n    const output = stderr.inspectSync(() => {\n      block.displayLines(lines);\n    });\n\n    expect(output.length).toEqual(block.height!);\n  });","file":"api/util/display.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"displayLines writes maximum lines based on lines length if there are less lines than rows","suites":["Rewritable Block Tests"],"updatePoint":{"line":21,"column":97},"line":21,"code":"  test('displayLines writes maximum lines based on lines length if there are less lines than rows', () => {\n    const lines = Array.from(Array(45).keys()).map(line => line.toString());\n    const output = stderr.inspectSync(() => {\n      block.displayLines(lines);\n    });\n\n    expect(output.length).toEqual(46);\n  });","file":"api/util/display.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"displayLines writes maximum lines based on lines length if rows is undefined","suites":["Rewritable Block Tests"],"updatePoint":{"line":30,"column":84},"line":30,"code":"  test('displayLines writes maximum lines based on lines length if rows is undefined', () => {\n    const lines = Array.from(Array(5).keys()).map(line => line.toString());\n    process.stderr.rows = undefined as any;\n    const output = stderr.inspectSync(() => {\n      block.displayLines(lines);\n    });\n\n    expect(output.length).toEqual(6);\n  });","file":"api/util/display.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"display accounts for newlines in output","suites":["Rewritable Block Tests"],"updatePoint":{"line":40,"column":47},"line":40,"code":"  test('display accounts for newlines in output', () => {\n    const output = stderr.inspectSync(() => {\n      block.displayLines(['before\\nafter']);\n    });\n    expect(output.length).toEqual(3); // cursorup + 2 lines\n  });","file":"api/util/display.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"removeEmptyLines only removes trailing lines","suites":["Rewritable Block Tests"],"updatePoint":{"line":47,"column":52},"line":47,"code":"  test('removeEmptyLines only removes trailing lines', () => {\n    stderr.inspectSync(() => {\n      block.displayLines(Array.from(Array(5).keys()).map(x => `${x}`));\n    });\n    stderr.inspectSync(() => {\n      // Leaves 3 empty lines\n      block.displayLines(Array.from(Array(2).keys()).map(x => `${x}`));\n    });\n\n    const output = stderr.inspectSync(() => {\n      block.removeEmptyLines();\n    });\n    const expectedEmptyLines = 3;\n    expect(JSON.stringify(output)).toEqual(JSON.stringify([`\\u001b[${expectedEmptyLines}A`]));\n  });","file":"api/util/display.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"convert to manifest and parameters","suites":["file assets"],"updatePoint":{"line":18,"column":42},"line":18,"code":"  test('convert to manifest and parameters', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        sourceHash: 'source-hash',\n        path: __filename,\n        id: 'SomeStackSomeResource4567',\n        packaging: 'file',\n        s3BucketParameter: 'BucketParameter',\n        s3KeyParameter: 'KeyParameter',\n        artifactHashParameter: 'ArtifactHashParameter',\n      },\n    ]);\n\n    // WHEN\n    const params = await addMetadataAssetsToManifest(stack, assets, toolkit);\n\n    // THEN\n    expect(params).toEqual({\n      BucketParameter: 'MockToolkitBucketName',\n      KeyParameter: 'assets/SomeStackSomeResource4567/||source-hash.js',\n      ArtifactHashParameter: 'source-hash',\n    });\n\n    expect(assets.toManifest('.').entries).toEqual([\n      expect.objectContaining({\n        destination: {\n          bucketName: 'MockToolkitBucketName',\n          objectKey: 'assets/SomeStackSomeResource4567/source-hash.js',\n        },\n        source: {\n          packaging: 'file',\n          path: __filename,\n        },\n      }),\n    ]);\n  });","file":"assets.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"hash and ID the same => only one path component","suites":["file assets"],"updatePoint":{"line":56,"column":55},"line":56,"code":"  test('hash and ID the same => only one path component', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        sourceHash: 'source-hash',\n        path: __filename,\n        id: 'source-hash',\n        packaging: 'file',\n        s3BucketParameter: 'BucketParameter',\n        s3KeyParameter: 'KeyParameter',\n        artifactHashParameter: 'ArtifactHashParameter',\n      },\n    ]);\n\n    // WHEN\n    await addMetadataAssetsToManifest(stack, assets, toolkit);\n\n    // THEN\n    expect(assets.toManifest('.').entries).toEqual([\n      expect.objectContaining({\n        destination: {\n          bucketName: 'MockToolkitBucketName',\n          objectKey: 'assets/source-hash.js',\n        },\n      }),\n    ]);\n  });","file":"assets.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"reuse","suites":["file assets"],"updatePoint":{"line":84,"column":13},"line":84,"code":"  test('reuse', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        path: __filename,\n        id: 'SomeStackSomeResource4567',\n        packaging: 'file',\n        s3BucketParameter: 'BucketParameter',\n        s3KeyParameter: 'KeyParameter',\n        artifactHashParameter: 'ArtifactHashParameter',\n        sourceHash: 'boom',\n      },\n    ]);\n\n    // WHEN\n    const params = await addMetadataAssetsToManifest(stack, assets, toolkit, ['SomeStackSomeResource4567']);\n\n    // THEN\n    expect(params).toEqual({\n    });\n\n    expect(assets.toManifest('.').entries).toEqual([]);\n  });","file":"assets.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"parameter and no repository name (old)","suites":["docker assets"],"updatePoint":{"line":110,"column":46},"line":110,"code":"  test('parameter and no repository name (old)', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        id: 'Stack:Construct/ABC123',\n        imageNameParameter: 'MyParameter',\n        packaging: 'container-image',\n        path: '/foo',\n        sourceHash: '0123456789abcdef',\n      },\n    ]);\n    mockFn(toolkit.prepareEcrRepository).mockResolvedValue({ repositoryUri: 'docker.uri' });\n\n    // WHEN\n    const params = await addMetadataAssetsToManifest(stack, assets, toolkit);\n\n    // THEN\n    expect(toolkit.prepareEcrRepository).toHaveBeenCalledWith('cdk/stack-construct-abc123');\n    expect(params).toEqual({\n      MyParameter: 'docker.uri:0123456789abcdef',\n    });\n    expect(assets.toManifest('.').entries).toEqual([\n      expect.objectContaining({\n        type: 'docker-image',\n        destination: {\n          imageTag: '0123456789abcdef',\n          repositoryName: 'cdk/stack-construct-abc123',\n        },\n        source: {\n          directory: '/foo',\n        },\n      }),\n    ]);\n  });","file":"assets.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"if parameter is left out then repo and tag are required","suites":["docker assets"],"updatePoint":{"line":145,"column":63},"line":145,"code":"  test('if parameter is left out then repo and tag are required', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        id: 'Stack:Construct/ABC123',\n        packaging: 'container-image',\n        path: '/foo',\n        sourceHash: '0123456789abcdef',\n      },\n    ]);\n\n    await expect(addMetadataAssetsToManifest(stack, assets, toolkit)).rejects.toThrow('Invalid Docker image asset');\n  });","file":"assets.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"no parameter and repo/tag name (new)","suites":["docker assets"],"updatePoint":{"line":159,"column":44},"line":159,"code":"  test('no parameter and repo/tag name (new)', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        id: 'Stack:Construct/ABC123',\n        repositoryName: 'reponame',\n        imageTag: '12345',\n        packaging: 'container-image',\n        path: '/foo',\n        sourceHash: '0123456789abcdef',\n      },\n    ]);\n    mockFn(toolkit.prepareEcrRepository).mockResolvedValue({ repositoryUri: 'docker.uri' });\n\n    // WHEN\n    const params = await addMetadataAssetsToManifest(stack, assets, toolkit);\n\n    // THEN\n    expect(toolkit.prepareEcrRepository).toHaveBeenCalledWith('reponame');\n    expect(params).toEqual({}); // No parameters!\n    expect(assets.toManifest('.').entries).toEqual([\n      expect.objectContaining({\n        type: 'docker-image',\n        destination: {\n          imageTag: '12345',\n          repositoryName: 'reponame',\n        },\n        source: {\n          directory: '/foo',\n        },\n      }),\n    ]);\n  });","file":"assets.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"reuse","suites":["docker assets"],"updatePoint":{"line":193,"column":13},"line":193,"code":"  test('reuse', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        path: __dirname,\n        id: 'SomeStackSomeResource4567',\n        packaging: 'container-image',\n        imageNameParameter: 'asdf',\n        sourceHash: 'source-hash',\n      },\n    ]);\n\n    // WHEN\n    const params = await addMetadataAssetsToManifest(stack, assets, toolkit, ['SomeStackSomeResource4567']);\n\n    // THEN\n    expect(params).toEqual({\n    });\n\n    expect(assets.toManifest('.').entries).toEqual([]);\n  });","file":"assets.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"the 'waiters' API is available in the current AWS SDK","suites":[],"updatePoint":{"line":14,"column":59},"line":14,"code":"test(\"the 'waiters' API is available in the current AWS SDK\", () => {\n  const waiters = (ecsService as any).api?.waiters;\n\n  expect(waiters).not.toBeUndefined();\n  expect(typeof waiters).toBe('object');\n});","file":"aws-sdk-non-public-apis.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"the 'ResourceWaiter' API is available in the current AWS SDK","suites":[],"updatePoint":{"line":21,"column":66},"line":21,"code":"test(\"the 'ResourceWaiter' API is available in the current AWS SDK\", () => {\n  const resourceWaiter = new (AWS as any).ResourceWaiter(ecsService, 'servicesStable');\n\n  // make sure the 'wait' method is available\n  expect(typeof resourceWaiter.wait).toBe('function');\n});","file":"aws-sdk-non-public-apis.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"build","suites":["buildAllStackAssets"],"updatePoint":{"line":15,"column":13},"line":15,"code":"  test('build', async () => {\n    // GIVEN\n    const buildStackAssets = jest.fn(() => sleep(1));\n\n    // WHEN/THEN\n    await expect(buildAllStackAssets(toPublish, { buildStackAssets }))\n      .resolves\n      .toBeUndefined();\n\n    expect(buildStackAssets).toBeCalledTimes(3);\n    expect(buildStackAssets).toBeCalledWith(A);\n    expect(buildStackAssets).toBeCalledWith(B);\n    expect(buildStackAssets).toBeCalledWith(C);\n  });","file":"build.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors","suites":["buildAllStackAssets"],"updatePoint":{"line":30,"column":14},"line":30,"code":"  test('errors', async () => {\n    // GIVEN\n    const buildStackAssets = async () => { throw new Error('Message'); };\n\n    // WHEN/THEN\n    await expect(buildAllStackAssets(toPublish, { buildStackAssets }))\n      .rejects\n      .toThrow('Building Assets Failed: Error: Message, Error: Message, Error: Message');\n  });","file":"build.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"exits with 0 when everything is OK","suites":["`cdk docs`"],"updatePoint":{"line":29,"column":42},"line":29,"code":"  test('exits with 0 when everything is OK', async () => {\n    const result = await realHandler({ args: argv } as any);\n    expect(result).toBe(0);\n  });","file":"cdk-docs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"exits with 0 when opening the browser fails","suites":["`cdk docs`"],"updatePoint":{"line":34,"column":51},"line":34,"code":"  test('exits with 0 when opening the browser fails', async () => {\n    mockery.registerMock('child_process', {\n      exec(_: string, cb: (err: Error, stdout?: string, stderr?: string) => void) {\n        cb(new Error('TEST'));\n      },\n    });\n    const result = await realHandler({ args: argv } as any);\n    expect(result).toBe(0);\n  });","file":"cdk-docs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"exits with 0 when everything is OK","suites":["`cdk doctor`"],"updatePoint":{"line":20,"column":42},"line":20,"code":"  test('exits with 0 when everything is OK', async () => {\n    const argv: any = {};\n    const result = await realHandler({ args: argv } as any);\n    expect(result).toBe(0);\n  });","file":"cdk-doctor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"lookup role is used","suites":["readCurrentTemplate"],"updatePoint":{"line":179,"column":27},"line":179,"code":"  test('lookup role is used', async () => {\n    // GIVEN\n    let requestedParameterName: string;\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter(request) {\n        requestedParameterName = request.Name;\n        return {\n          Parameter: {\n            Value: '6',\n          },\n        };\n      },\n    });\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      deployments: new Deployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-C'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(requestedParameterName!).toEqual('/bootstrap/parameter');\n    expect(mockForEnvironment.mock.calls.length).toEqual(2);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: 'bloop-lookup:here:123456789012',\n    });\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"fallback to deploy role if bootstrap stack version is not valid","suites":["readCurrentTemplate"],"updatePoint":{"line":213,"column":71},"line":213,"code":"  test('fallback to deploy role if bootstrap stack version is not valid', async () => {\n    // GIVEN\n    let requestedParameterName: string;\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter(request) {\n        requestedParameterName = request.Name;\n        return {\n          Parameter: {\n            Value: '1',\n          },\n        };\n      },\n    });\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      deployments: new Deployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-C'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(flatten(stderrMock.mock.calls)).toEqual(expect.arrayContaining([\n      expect.stringMatching(/Could not assume bloop-lookup:here:123456789012/),\n      expect.stringMatching(/please upgrade to bootstrap version >= 5/),\n    ]));\n    expect(requestedParameterName!).toEqual('/bootstrap/parameter');\n    expect(mockForEnvironment.mock.calls.length).toEqual(3);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: 'bloop-lookup:here:123456789012',\n    });\n    expect(mockForEnvironment.mock.calls[1][2]).toEqual({\n      assumeRoleArn: 'bloop:here:123456789012',\n    });\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"fallback to deploy role if bootstrap version parameter not found","suites":["readCurrentTemplate"],"updatePoint":{"line":254,"column":72},"line":254,"code":"  test('fallback to deploy role if bootstrap version parameter not found', async () => {\n    // GIVEN\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter() {\n        throw new Error('not found');\n      },\n    });\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      deployments: new Deployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-C'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(flatten(stderrMock.mock.calls)).toEqual(expect.arrayContaining([\n      expect.stringMatching(/Could not assume bloop-lookup:here:123456789012/),\n      expect.stringMatching(/please upgrade to bootstrap version >= 5/),\n    ]));\n    expect(mockForEnvironment.mock.calls.length).toEqual(3);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: 'bloop-lookup:here:123456789012',\n    });\n    expect(mockForEnvironment.mock.calls[1][2]).toEqual({\n      assumeRoleArn: 'bloop:here:123456789012',\n    });\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"fallback to deploy role if forEnvironment throws","suites":["readCurrentTemplate"],"updatePoint":{"line":288,"column":56},"line":288,"code":"  test('fallback to deploy role if forEnvironment throws', async () => {\n    // GIVEN\n    // throw error first for the 'prepareSdkWithLookupRoleFor' call and succeed for the rest\n    mockForEnvironment = jest.fn().mockImplementationOnce(() => { throw new Error('error'); })\n      .mockImplementation(() => { return { sdk: mockCloudExecutable.sdkProvider.sdk, didAssumeRole: true };});\n    mockCloudExecutable.sdkProvider.forEnvironment = mockForEnvironment;\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter() {\n        return { };\n      },\n    });\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      deployments: new Deployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-C'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(mockCloudExecutable.sdkProvider.sdk.ssm).not.toHaveBeenCalled();\n    expect(flatten(stderrMock.mock.calls)).toEqual(expect.arrayContaining([\n      expect.stringMatching(/Could not assume bloop-lookup:here:123456789012/),\n      expect.stringMatching(/please upgrade to bootstrap version >= 5/),\n    ]));\n    expect(mockForEnvironment.mock.calls.length).toEqual(3);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: 'bloop-lookup:here:123456789012',\n    });\n    expect(mockForEnvironment.mock.calls[1][2]).toEqual({\n      assumeRoleArn: 'bloop:here:123456789012',\n    });\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"dont lookup bootstrap version parameter if default credentials are used","suites":["readCurrentTemplate"],"updatePoint":{"line":327,"column":79},"line":327,"code":"  test('dont lookup bootstrap version parameter if default credentials are used', async () => {\n    // GIVEN\n    mockForEnvironment = jest.fn().mockImplementation(() => { return { sdk: mockCloudExecutable.sdkProvider.sdk, didAssumeRole: false }; });\n    mockCloudExecutable.sdkProvider.forEnvironment = mockForEnvironment;\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      deployments: new Deployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter() {\n        return { };\n      },\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-C'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(flatten(stderrMock.mock.calls)).toEqual(expect.arrayContaining([\n      expect.stringMatching(/please upgrade to bootstrap version >= 5/),\n    ]));\n    expect(mockCloudExecutable.sdkProvider.sdk.ssm).not.toHaveBeenCalled();\n    expect(mockForEnvironment.mock.calls.length).toEqual(3);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: 'bloop-lookup:here:123456789012',\n    });\n    expect(mockForEnvironment.mock.calls[1][2]).toEqual({\n      assumeRoleArn: 'bloop:here:123456789012',\n    });\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do not print warnings if lookup role not provided in stack artifact","suites":["readCurrentTemplate"],"updatePoint":{"line":363,"column":75},"line":363,"code":"  test('do not print warnings if lookup role not provided in stack artifact', async () => {\n    // GIVEN\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter() {\n        return {};\n      },\n    });\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      deployments: new Deployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-A'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(flatten(stderrMock.mock.calls)).not.toEqual(expect.arrayContaining([\n      expect.stringMatching(/Could not assume/),\n      expect.stringMatching(/please upgrade to bootstrap version/),\n    ]));\n    expect(mockCloudExecutable.sdkProvider.sdk.ssm).not.toHaveBeenCalled();\n    expect(mockForEnvironment.mock.calls.length).toEqual(2);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: undefined,\n      assumeRoleExternalId: undefined,\n    });\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"fails when no valid stack names are given","suites":["deploy"],"updatePoint":{"line":398,"column":49},"line":398,"code":"  test('fails when no valid stack names are given', async () => {\n    // GIVEN\n    const toolkit = defaultToolkitSetup();\n\n    // WHEN\n    await expect(() => toolkit.deploy({\n      selector: { patterns: ['Test-Stack-D'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    })).rejects.toThrow('No stacks match the name(s) Test-Stack-D');\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passes through the 'hotswap' option to CloudFormationDeployments.deployStack()","suites":["deploy","with hotswap deployment"],"updatePoint":{"line":410,"column":88},"line":410,"code":"    test(\"passes through the 'hotswap' option to CloudFormationDeployments.deployStack()\", async () => {\n      // GIVEN\n      const mockCfnDeployments = instanceMockFrom(Deployments);\n      mockCfnDeployments.deployStack.mockReturnValue(Promise.resolve({\n        noOp: false,\n        outputs: {},\n        stackArn: 'stackArn',\n        stackArtifact: instanceMockFrom(cxapi.CloudFormationStackArtifact),\n      }));\n      const cdkToolkit = new CdkToolkit({\n        cloudExecutable,\n        configuration: cloudExecutable.configuration,\n        sdkProvider: cloudExecutable.sdkProvider,\n        deployments: mockCfnDeployments,\n      });\n\n      // WHEN\n      await cdkToolkit.deploy({\n        selector: { patterns: ['Test-Stack-A-Display-Name'] },\n        requireApproval: RequireApproval.Never,\n        hotswap: HotswapMode.FALL_BACK,\n      });\n\n      // THEN\n      expect(mockCfnDeployments.deployStack).toHaveBeenCalledWith(expect.objectContaining({\n        hotswap: HotswapMode.FALL_BACK,\n      }));\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"without options","suites":["deploy","makes correct CloudFormation calls"],"updatePoint":{"line":441,"column":25},"line":441,"code":"    test('without options', async () => {\n      // GIVEN\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.deploy({\n        selector: { patterns: ['Test-Stack-A', 'Test-Stack-B'] },\n        hotswap: HotswapMode.FULL_DEPLOYMENT,\n      });\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"with stacks all stacks specified as double wildcard","suites":["deploy","makes correct CloudFormation calls"],"updatePoint":{"line":452,"column":61},"line":452,"code":"    test('with stacks all stacks specified as double wildcard', async () => {\n      // GIVEN\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.deploy({\n        selector: { patterns: ['**'] },\n        hotswap: HotswapMode.FULL_DEPLOYMENT,\n      });\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"with one stack specified","suites":["deploy","makes correct CloudFormation calls"],"updatePoint":{"line":463,"column":34},"line":463,"code":"    test('with one stack specified', async () => {\n      // GIVEN\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.deploy({\n        selector: { patterns: ['Test-Stack-A-Display-Name'] },\n        hotswap: HotswapMode.FULL_DEPLOYMENT,\n      });\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"with stacks all stacks specified as wildcard","suites":["deploy","makes correct CloudFormation calls"],"updatePoint":{"line":474,"column":54},"line":474,"code":"    test('with stacks all stacks specified as wildcard', async () => {\n      // GIVEN\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.deploy({\n        selector: { patterns: ['*'] },\n        hotswap: HotswapMode.FULL_DEPLOYMENT,\n      });\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"with sns notification arns","suites":["deploy","makes correct CloudFormation calls"],"updatePoint":{"line":485,"column":36},"line":485,"code":"    test('with sns notification arns', async () => {\n      // GIVEN\n      const notificationArns = [\n        'arn:aws:sns:us-east-2:444455556666:MyTopic',\n        'arn:aws:sns:eu-west-1:111155556666:my-great-topic',\n      ];\n      const toolkit = new CdkToolkit({\n        cloudExecutable,\n        configuration: cloudExecutable.configuration,\n        sdkProvider: cloudExecutable.sdkProvider,\n        deployments: new FakeCloudFormation({\n          'Test-Stack-A': { Foo: 'Bar' },\n          'Test-Stack-B': { Baz: 'Zinga!' },\n        }, notificationArns),\n      });\n\n      // WHEN\n      await toolkit.deploy({\n        selector: { patterns: ['Test-Stack-A', 'Test-Stack-B'] },\n        notificationArns,\n        hotswap: HotswapMode.FULL_DEPLOYMENT,\n      });\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"fail with incorrect sns notification arns","suites":["deploy","makes correct CloudFormation calls"],"updatePoint":{"line":509,"column":51},"line":509,"code":"    test('fail with incorrect sns notification arns', async () => {\n      // GIVEN\n      const notificationArns = ['arn:::cfn-my-cool-topic'];\n      const toolkit = new CdkToolkit({\n        cloudExecutable,\n        configuration: cloudExecutable.configuration,\n        sdkProvider: cloudExecutable.sdkProvider,\n        deployments: new FakeCloudFormation({\n          'Test-Stack-A': { Foo: 'Bar' },\n        }, notificationArns),\n      });\n\n      // WHEN\n      await expect(() =>\n        toolkit.deploy({\n          selector: { patterns: ['Test-Stack-A'] },\n          notificationArns,\n          hotswap: HotswapMode.FULL_DEPLOYMENT,\n        }),\n      ).rejects.toThrow('Notification arn arn:::cfn-my-cool-topic is not a valid arn for an SNS topic');\n\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"globless bootstrap uses environment without question","suites":["deploy","makes correct CloudFormation calls"],"updatePoint":{"line":532,"column":62},"line":532,"code":"    test('globless bootstrap uses environment without question', async () => {\n    // GIVEN\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.bootstrap(['aws://56789/south-pole'], bootstrapper, {});\n\n      // THEN\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledWith({\n        account: '56789',\n        region: 'south-pole',\n        name: 'aws://56789/south-pole',\n      }, expect.anything(), expect.anything());\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledTimes(1);\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"globby bootstrap uses whats in the stacks","suites":["deploy","makes correct CloudFormation calls"],"updatePoint":{"line":548,"column":51},"line":548,"code":"    test('globby bootstrap uses whats in the stacks', async () => {\n      // GIVEN\n      const toolkit = defaultToolkitSetup();\n      cloudExecutable.configuration.settings.set(['app'], 'something');\n\n      // WHEN\n      await toolkit.bootstrap(['aws://*/bermuda-triangle-1'], bootstrapper, {});\n\n      // THEN\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledWith({\n        account: '123456789012',\n        region: 'bermuda-triangle-1',\n        name: 'aws://123456789012/bermuda-triangle-1',\n      }, expect.anything(), expect.anything());\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledTimes(1);\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"bootstrap can be invoked without the --app argument","suites":["deploy","makes correct CloudFormation calls"],"updatePoint":{"line":565,"column":61},"line":565,"code":"    test('bootstrap can be invoked without the --app argument', async () => {\n      // GIVEN\n      cloudExecutable.configuration.settings.clear();\n      const mockSynthesize = jest.fn();\n      cloudExecutable.synthesize = mockSynthesize;\n\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.bootstrap(['aws://123456789012/west-pole'], bootstrapper, {});\n\n      // THEN\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledWith({\n        account: '123456789012',\n        region: 'west-pole',\n        name: 'aws://123456789012/west-pole',\n      }, expect.anything(), expect.anything());\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledTimes(1);\n\n      expect(cloudExecutable.hasApp).toEqual(false);\n      expect(mockSynthesize).not.toHaveBeenCalled();\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"destroy correct stack","suites":["destroy"],"updatePoint":{"line":591,"column":29},"line":591,"code":"  test('destroy correct stack', async () => {\n    const toolkit = defaultToolkitSetup();\n\n    await expect(() => {\n      return toolkit.destroy({\n        selector: { patterns: ['Test-Stack-A/Test-Stack-C'] },\n        exclusively: true,\n        force: true,\n        fromDeploy: true,\n      });\n    }).resolves;\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"fails when no 'watch' settings are found","suites":["watch"],"updatePoint":{"line":606,"column":48},"line":606,"code":"  test(\"fails when no 'watch' settings are found\", async () => {\n    const toolkit = defaultToolkitSetup();\n\n    await expect(() => {\n      return toolkit.watch({\n        selector: { patterns: [] },\n        hotswap: HotswapMode.HOTSWAP_ONLY,\n      });\n    }).rejects.toThrow(\"Cannot use the 'watch' command without specifying at least one directory to monitor. \" +\n      'Make sure to add a \"watch\" key to your cdk.json');\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"observes only the root directory by default","suites":["watch"],"updatePoint":{"line":618,"column":51},"line":618,"code":"  test('observes only the root directory by default', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    const includeArgs = fakeChokidarWatch.includeArgs;\n    expect(includeArgs.length).toBe(1);\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"allows providing a single string in 'watch.include'","suites":["watch"],"updatePoint":{"line":631,"column":59},"line":631,"code":"  test(\"allows providing a single string in 'watch.include'\", async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {\n      include: 'my-dir',\n    });\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    expect(fakeChokidarWatch.includeArgs).toStrictEqual(['my-dir']);\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"allows providing an array of strings in 'watch.include'","suites":["watch"],"updatePoint":{"line":645,"column":63},"line":645,"code":"  test(\"allows providing an array of strings in 'watch.include'\", async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {\n      include: ['my-dir1', '**/my-dir2/*'],\n    });\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    expect(fakeChokidarWatch.includeArgs).toStrictEqual(['my-dir1', '**/my-dir2/*']);\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"ignores the output dir, dot files, dot directories, and node_modules by default","suites":["watch"],"updatePoint":{"line":659,"column":87},"line":659,"code":"  test('ignores the output dir, dot files, dot directories, and node_modules by default', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    cloudExecutable.configuration.settings.set(['output'], 'cdk.out');\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    expect(fakeChokidarWatch.excludeArgs).toStrictEqual([\n      'cdk.out/**',\n      '**/.*',\n      '**/.*/**',\n      '**/node_modules/**',\n    ]);\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"allows providing a single string in 'watch.exclude'","suites":["watch"],"updatePoint":{"line":677,"column":59},"line":677,"code":"  test(\"allows providing a single string in 'watch.exclude'\", async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {\n      exclude: 'my-dir',\n    });\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    const excludeArgs = fakeChokidarWatch.excludeArgs;\n    expect(excludeArgs.length).toBe(5);\n    expect(excludeArgs[0]).toBe('my-dir');\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"allows providing an array of strings in 'watch.exclude'","suites":["watch"],"updatePoint":{"line":693,"column":63},"line":693,"code":"  test(\"allows providing an array of strings in 'watch.exclude'\", async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {\n      exclude: ['my-dir1', '**/my-dir2'],\n    });\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    const excludeArgs = fakeChokidarWatch.excludeArgs;\n    expect(excludeArgs.length).toBe(6);\n    expect(excludeArgs[0]).toBe('my-dir1');\n    expect(excludeArgs[1]).toBe('**/my-dir2');\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"allows watching with deploy concurrency","suites":["watch"],"updatePoint":{"line":710,"column":47},"line":710,"code":"  test('allows watching with deploy concurrency', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    const toolkit = defaultToolkitSetup();\n    const cdkDeployMock = jest.fn();\n    toolkit.deploy = cdkDeployMock;\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      concurrency: 3,\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n    fakeChokidarWatcherOn.readyCallback();\n\n    expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ concurrency: 3 }));\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p mode","suites":["watch"],"line":726,"code":"  describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n    test('passes through the correct hotswap mode to deployStack()', async () => {\n      cloudExecutable.configuration.settings.set(['watch'], {});\n      const toolkit = defaultToolkitSetup();\n      const cdkDeployMock = jest.fn();\n      toolkit.deploy = cdkDeployMock;\n\n      await toolkit.watch({ selector: { patterns: [] }, hotswap: hotswapMode });\n      fakeChokidarWatcherOn.readyCallback();\n\n      expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ hotswap: hotswapMode }));\n    });\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"passes through the correct hotswap mode to deployStack()","suites":["watch"],"updatePoint":{"line":727,"column":66},"line":727,"code":"    test('passes through the correct hotswap mode to deployStack()', async () => {\n      cloudExecutable.configuration.settings.set(['watch'], {});\n      const toolkit = defaultToolkitSetup();\n      const cdkDeployMock = jest.fn();\n      toolkit.deploy = cdkDeployMock;\n\n      await toolkit.watch({ selector: { patterns: [] }, hotswap: hotswapMode });\n      fakeChokidarWatcherOn.readyCallback();\n\n      expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ hotswap: hotswapMode }));\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"respects HotswapMode.HOTSWAP_ONLY","suites":["watch"],"updatePoint":{"line":740,"column":41},"line":740,"code":"  test('respects HotswapMode.HOTSWAP_ONLY', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    const toolkit = defaultToolkitSetup();\n    const cdkDeployMock = jest.fn();\n    toolkit.deploy = cdkDeployMock;\n\n    await toolkit.watch({ selector: { patterns: [] }, hotswap: HotswapMode.HOTSWAP_ONLY });\n    fakeChokidarWatcherOn.readyCallback();\n\n    expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ hotswap: HotswapMode.HOTSWAP_ONLY }));\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"respects HotswapMode.FALL_BACK","suites":["watch"],"updatePoint":{"line":752,"column":38},"line":752,"code":"  test('respects HotswapMode.FALL_BACK', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    const toolkit = defaultToolkitSetup();\n    const cdkDeployMock = jest.fn();\n    toolkit.deploy = cdkDeployMock;\n\n    await toolkit.watch({ selector: { patterns: [] }, hotswap: HotswapMode.FALL_BACK });\n    fakeChokidarWatcherOn.readyCallback();\n\n    expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ hotswap: HotswapMode.FALL_BACK }));\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"respects HotswapMode.FULL_DEPLOYMENT","suites":["watch"],"updatePoint":{"line":764,"column":44},"line":764,"code":"  test('respects HotswapMode.FULL_DEPLOYMENT', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    const toolkit = defaultToolkitSetup();\n    const cdkDeployMock = jest.fn();\n    toolkit.deploy = cdkDeployMock;\n\n    await toolkit.watch({ selector: { patterns: [] }, hotswap: HotswapMode.FULL_DEPLOYMENT });\n    fakeChokidarWatcherOn.readyCallback();\n\n    expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ hotswap: HotswapMode.FULL_DEPLOYMENT }));\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not trigger a 'deploy' before the 'ready' event has fired","suites":["watch","with file change events"],"updatePoint":{"line":791,"column":72},"line":791,"code":"    test(\"does not trigger a 'deploy' before the 'ready' event has fired\", async () => {\n      await fakeChokidarWatcherOn.fileEventCallback('add', 'my-file');\n\n      expect(cdkDeployMock).not.toHaveBeenCalled();\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"an initial 'deploy' is triggered, without any file changes","suites":["watch","with file change events","when the 'ready' event has already fired"],"updatePoint":{"line":805,"column":70},"line":805,"code":"      test(\"an initial 'deploy' is triggered, without any file changes\", async () => {\n        expect(cdkDeployMock).toHaveBeenCalledTimes(1);\n      });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does trigger a 'deploy' for a file change","suites":["watch","with file change events","when the 'ready' event has already fired"],"updatePoint":{"line":809,"column":53},"line":809,"code":"      test(\"does trigger a 'deploy' for a file change\", async () => {\n        await fakeChokidarWatcherOn.fileEventCallback('add', 'my-file');\n\n        expect(cdkDeployMock).toHaveBeenCalledTimes(2);\n      });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"triggers a 'deploy' twice for two file changes","suites":["watch","with file change events","when the 'ready' event has already fired"],"updatePoint":{"line":815,"column":58},"line":815,"code":"      test(\"triggers a 'deploy' twice for two file changes\", async () => {\n        await Promise.all([\n          fakeChokidarWatcherOn.fileEventCallback('add', 'my-file1'),\n          fakeChokidarWatcherOn.fileEventCallback('change', 'my-file2'),\n        ]);\n\n        expect(cdkDeployMock).toHaveBeenCalledTimes(3);\n      });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"batches file changes that happen during 'deploy'","suites":["watch","with file change events","when the 'ready' event has already fired"],"updatePoint":{"line":824,"column":60},"line":824,"code":"      test(\"batches file changes that happen during 'deploy'\", async () => {\n        await Promise.all([\n          fakeChokidarWatcherOn.fileEventCallback('add', 'my-file1'),\n          fakeChokidarWatcherOn.fileEventCallback('change', 'my-file2'),\n          fakeChokidarWatcherOn.fileEventCallback('unlink', 'my-file3'),\n          fakeChokidarWatcherOn.fileEventCallback('add', 'my-file4'),\n        ]);\n\n        expect(cdkDeployMock).toHaveBeenCalledTimes(3);\n      });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"successful synth outputs hierarchical stack ids","suites":["synth"],"updatePoint":{"line":839,"column":55},"line":839,"code":"  test('successful synth outputs hierarchical stack ids', async () => {\n    const toolkit = defaultToolkitSetup();\n    await toolkit.synth([], false, false);\n\n    // Separate tests as colorizing hampers detection\n    expect(stderrMock.mock.calls[1][0]).toMatch('Test-Stack-A-Display-Name');\n    expect(stderrMock.mock.calls[1][0]).toMatch('Test-Stack-B');\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"with no stdout option","suites":["synth"],"updatePoint":{"line":848,"column":29},"line":848,"code":"  test('with no stdout option', async () => {\n    // GIVE\n    const toolkit = defaultToolkitSetup();\n\n    // THEN\n    await toolkit.synth(['Test-Stack-A-Display-Name'], false, true);\n    expect(mockData.mock.calls.length).toEqual(0);\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"causes synth to fail if autoValidate=true","suites":["synth","stack with error and flagged for validation"],"updatePoint":{"line":876,"column":51},"line":876,"code":"    test('causes synth to fail if autoValidate=true', async() => {\n      const toolkit = defaultToolkitSetup();\n      const autoValidate = true;\n      await expect(toolkit.synth([], false, true, autoValidate)).rejects.toBeDefined();\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"causes synth to succeed if autoValidate=false","suites":["synth","stack with error and flagged for validation"],"updatePoint":{"line":882,"column":55},"line":882,"code":"    test('causes synth to succeed if autoValidate=false', async() => {\n      const toolkit = defaultToolkitSetup();\n      const autoValidate = false;\n      await toolkit.synth([], false, true, autoValidate);\n      expect(mockData.mock.calls.length).toEqual(0);\n    });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"stack has error and was explicitly selected","suites":["synth","stack with error and flagged for validation"],"updatePoint":{"line":890,"column":51},"line":890,"code":"  test('stack has error and was explicitly selected', async() => {\n    cloudExecutable = new MockCloudExecutable({\n      stacks: [\n        MockStack.MOCK_STACK_A,\n        MockStack.MOCK_STACK_B,\n      ],\n      nestedAssemblies: [{\n        stacks: [\n          { properties: { validateOnSynth: false }, ...MockStack.MOCK_STACK_WITH_ERROR },\n        ],\n      }],\n    });\n\n    const toolkit = defaultToolkitSetup();\n\n    await expect(toolkit.synth(['Test-Stack-A/witherrors'], false, true)).rejects.toBeDefined();\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"stack has error, is not flagged for validation and was not explicitly selected","suites":["synth","stack with error and flagged for validation"],"updatePoint":{"line":908,"column":86},"line":908,"code":"  test('stack has error, is not flagged for validation and was not explicitly selected', async () => {\n    cloudExecutable = new MockCloudExecutable({\n      stacks: [\n        MockStack.MOCK_STACK_A,\n        MockStack.MOCK_STACK_B,\n      ],\n      nestedAssemblies: [{\n        stacks: [\n          { properties: { validateOnSynth: false }, ...MockStack.MOCK_STACK_WITH_ERROR },\n        ],\n      }],\n    });\n\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.synth([], false, true);\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"stack has dependency and was explicitly selected","suites":["synth","stack with error and flagged for validation"],"updatePoint":{"line":926,"column":56},"line":926,"code":"  test('stack has dependency and was explicitly selected', async () => {\n    cloudExecutable = new MockCloudExecutable({\n      stacks: [\n        MockStack.MOCK_STACK_C,\n        MockStack.MOCK_STACK_D,\n      ],\n    });\n\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.synth([MockStack.MOCK_STACK_D.stackName], true, false);\n\n    expect(mockData.mock.calls.length).toEqual(1);\n    expect(mockData.mock.calls[0][0]).toBeDefined();\n  });","file":"cdk-toolkit.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"runs","suites":["context --list"],"updatePoint":{"line":6,"column":12},"line":6,"code":"  test('runs', async() => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n\n    // WHEN\n    await realHandler({\n      configuration,\n      args: {},\n    } as any);\n  });","file":"commands/context-command.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can remove a context key","suites":["context --reset"],"updatePoint":{"line":24,"column":32},"line":24,"code":"  test('can remove a context key', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n    configuration.context.set('baz', 'quux');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n      baz: 'quux',\n    });\n\n    // WHEN\n    await realHandler({\n      configuration,\n      args: { reset: 'foo' },\n    } as any);\n\n    // THEN\n    expect(configuration.context.all).toEqual({\n      baz: 'quux',\n    });\n  });","file":"commands/context-command.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can remove a context key using number","suites":["context --reset"],"updatePoint":{"line":47,"column":45},"line":47,"code":"  test('can remove a context key using number', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n    configuration.context.set('baz', 'quux');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n      baz: 'quux',\n    });\n\n    // WHEN\n    await realHandler({\n      configuration,\n      args: { reset: '1' },\n    } as any);\n\n    // THEN\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n  });","file":"commands/context-command.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can reset matched pattern","suites":["context --reset"],"updatePoint":{"line":70,"column":33},"line":70,"code":"  test('can reset matched pattern', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n    configuration.context.set('match-a', 'baz');\n    configuration.context.set('match-b', 'qux');\n\n    expect(configuration.context.all).toEqual({\n      'foo': 'bar',\n      'match-a': 'baz',\n      'match-b': 'qux',\n    });\n\n    // WHEN\n    await realHandler({\n      configuration,\n      args: { reset: 'match-*' },\n    } as any);\n\n    // THEN\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n  });","file":"commands/context-command.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"prefers an exact match","suites":["context --reset"],"updatePoint":{"line":95,"column":30},"line":95,"code":"  test('prefers an exact match', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n    configuration.context.set('fo*', 'baz');\n\n    expect(configuration.context.all).toEqual({\n      'foo': 'bar',\n      'fo*': 'baz',\n    });\n\n    // WHEN\n    await realHandler({\n      configuration,\n      args: { reset: 'fo*' },\n    } as any);\n\n    // THEN\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n  });","file":"commands/context-command.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"doesn't throw when at least one match is reset","suites":["context --reset"],"updatePoint":{"line":118,"column":55},"line":118,"code":"  test('doesn\\'t throw when at least one match is reset', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    const readOnlySettings = new Settings({\n      'foo': 'bar',\n      'match-a': 'baz',\n    }, true);\n    configuration.context = new Context(readOnlySettings, new Settings());\n    configuration.context.set('match-b', 'quux');\n\n    // When\n    await expect(realHandler({\n      configuration,\n      args: { reset: 'match-*' },\n    } as any));\n\n    // Then\n    expect(configuration.context.all).toEqual({\n      'foo': 'bar',\n      'match-a': 'baz',\n    });\n  });","file":"commands/context-command.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws when key not found","suites":["context --reset"],"updatePoint":{"line":141,"column":33},"line":141,"code":"  test('throws when key not found', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n\n    // THEN\n    await expect(realHandler({\n      configuration,\n      args: { reset: 'baz' },\n    } as any)).rejects.toThrow(/No context value matching key/);\n  });","file":"commands/context-command.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Doesn't throw when key not found and --force is set","suites":["context --reset"],"updatePoint":{"line":157,"column":60},"line":157,"code":"  test('Doesn\\'t throw when key not found and --force is set', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n\n    // THEN\n    await expect(realHandler({\n      configuration,\n      args: { reset: 'baz', force: true },\n    } as any));\n  });","file":"commands/context-command.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws when no key of index found","suites":["context --reset"],"updatePoint":{"line":173,"column":41},"line":173,"code":"  test('throws when no key of index found', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n\n    // THEN\n    await expect(realHandler({\n      configuration,\n      args: { reset: '2' },\n    } as any)).rejects.toThrow(/No context key with number/);\n  });","file":"commands/context-command.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws when resetting read-only values","suites":["context --reset"],"updatePoint":{"line":189,"column":46},"line":189,"code":"  test('throws when resetting read-only values', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    const readOnlySettings = new Settings({\n      foo: 'bar',\n    }, true);\n    configuration.context = new Context(readOnlySettings);\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n\n    // THEN\n    await expect(realHandler({\n      configuration,\n      args: { reset: 'foo' },\n    } as any)).rejects.toThrow(/Cannot reset readonly context value with key/);\n  });","file":"commands/context-command.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws when no matches could be reset","suites":["context --reset"],"updatePoint":{"line":208,"column":45},"line":208,"code":"  test('throws when no matches could be reset', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    const readOnlySettings = new Settings({\n      'foo': 'bar',\n      'match-a': 'baz',\n      'match-b': 'quux',\n    }, true);\n    configuration.context = new Context(readOnlySettings);\n\n    expect(configuration.context.all).toEqual({\n      'foo': 'bar',\n      'match-a': 'baz',\n      'match-b': 'quux',\n    });\n\n    // THEN\n    await expect(realHandler({\n      configuration,\n      args: { reset: 'match-*' },\n    } as any)).rejects.toThrow(/None of the matched context values could be reset/);\n  });","file":"commands/context-command.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"calls DescribeImages on the request","suites":[],"updatePoint":{"line":22,"column":41},"line":22,"code":"test('calls DescribeImages on the request', async () => {\n  // GIVEN\n  let request: aws.EC2.DescribeImagesRequest;\n  AWS.mock('EC2', 'describeImages', (params: aws.EC2.DescribeImagesRequest, cb: AwsCallback<aws.EC2.DescribeImagesResult>) => {\n    request = params;\n    return cb(null, { Images: [{ ImageId: 'ami-1234' }] });\n  });\n\n  // WHEN\n  await new AmiContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'asdf',\n    owners: ['some-owner'],\n    filters: {\n      'some-filter': ['filtered'],\n    },\n  });\n\n  // THEN\n  expect(request!).toEqual({\n    Owners: ['some-owner'],\n    Filters: [\n      {\n        Name: 'some-filter',\n        Values: ['filtered'],\n      },\n    ],\n  } as aws.EC2.DescribeImagesRequest);\n});","file":"context-providers/amis.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns the most recent AMI matching the criteria","suites":[],"updatePoint":{"line":52,"column":55},"line":52,"code":"test('returns the most recent AMI matching the criteria', async () => {\n  // GIVEN\n  AWS.mock('EC2', 'describeImages', (_: aws.EC2.DescribeImagesRequest, cb: AwsCallback<aws.EC2.DescribeImagesResult>) => {\n    return cb(null, {\n      Images: [\n        {\n          ImageId: 'ami-1234',\n          CreationDate: '2016-06-22T08:39:59.000Z',\n        },\n        {\n          ImageId: 'ami-5678',\n          CreationDate: '2019-06-22T08:39:59.000Z',\n        },\n      ],\n    });\n  });\n\n  // WHEN\n  const result = await new AmiContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'asdf',\n    filters: {},\n  });\n\n  // THEN\n  expect(result).toBe('ami-5678');\n});","file":"context-providers/amis.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up the requested (symmetric) VPC","suites":[],"updatePoint":{"line":22,"column":44},"line":22,"code":"test('looks up the requested (symmetric) VPC', async () => {\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true, CidrBlock: '1.1.1.1/24' },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false, CidrBlock: '1.1.2.1/24' },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ SubnetId: 'sub-789012' }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n\n  });\n\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Public',\n        type: 'Public',\n        subnets: [\n          {\n            subnetId: 'sub-123456',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-123456',\n            cidr: '1.1.1.1/24',\n          },\n        ],\n      },\n      {\n        name: 'Private',\n        type: 'Private',\n        subnets: [\n          {\n            subnetId: 'sub-789012',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-789012',\n            cidr: '1.1.2.1/24',\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: 'gw-abcdef',\n  });\n});","file":"context-providers/asymmetric-vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws when no such VPC is found","suites":[],"updatePoint":{"line":120,"column":38},"line":120,"code":"test('throws when no such VPC is found', async () => {\n  AWS.mock('EC2', 'describeVpcs', (params: aws.EC2.DescribeVpcsRequest, cb: AwsCallback<aws.EC2.DescribeVpcsResult>) => {\n    expect(params.Filters).toEqual([{ Name: 'foo', Values: ['bar'] }]);\n    return cb(null, {});\n  });\n\n  await expect(new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  })).rejects.toThrow(/Could not find any VPCs matching/);\n});","file":"context-providers/asymmetric-vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws when multiple VPCs are found","suites":[],"updatePoint":{"line":134,"column":41},"line":134,"code":"test('throws when multiple VPCs are found', async () => {\n  // GIVEN\n  AWS.mock('EC2', 'describeVpcs', (params: aws.EC2.DescribeVpcsRequest, cb: AwsCallback<aws.EC2.DescribeVpcsResult>) => {\n    expect(params.Filters).toEqual([{ Name: 'foo', Values: ['bar'] }]);\n    return cb(null, { Vpcs: [{ VpcId: 'vpc-1' }, { VpcId: 'vpc-2' }] });\n  });\n\n  // WHEN\n  await expect(new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  })).rejects.toThrow(/Found 2 VPCs matching/);\n});","file":"context-providers/asymmetric-vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"uses the VPC main route table when a subnet has no specific association","suites":[],"updatePoint":{"line":150,"column":77},"line":150,"code":"test('uses the VPC main route table when a subnet has no specific association', async () => {\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true, CidrBlock: '1.1.1.1/24' },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false, CidrBlock: '1.1.2.1/24' },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ Main: true }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n  });\n\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Public',\n        type: 'Public',\n        subnets: [\n          {\n            subnetId: 'sub-123456',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-123456',\n            cidr: '1.1.1.1/24',\n          },\n        ],\n      },\n      {\n        name: 'Private',\n        type: 'Private',\n        subnets: [\n          {\n            subnetId: 'sub-789012',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-789012',\n            cidr: '1.1.2.1/24',\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: 'gw-abcdef',\n  });\n});","file":"context-providers/asymmetric-vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Recognize public subnet by route table","suites":[],"updatePoint":{"line":247,"column":44},"line":247,"code":"test('Recognize public subnet by route table', async () => {\n  // GIVEN\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '10.0.2.0/26',\n            Origin: 'CreateRoute',\n            State: 'active',\n            VpcPeeringConnectionId: 'pcx-xxxxxx',\n          },\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Public',\n        type: 'Public',\n        subnets: [\n          {\n            subnetId: 'sub-123456',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-123456',\n            cidr: undefined,\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: undefined,\n  });\n});","file":"context-providers/asymmetric-vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Recognize isolated subnet by route table","suites":[],"updatePoint":{"line":321,"column":46},"line":321,"code":"test('Recognize isolated subnet by route table', async () => {\n  // GIVEN\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Isolated',\n        type: 'Isolated',\n        subnets: [\n          {\n            subnetId: 'sub-123456',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-123456',\n            cidr: undefined,\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: undefined,\n  });\n});","file":"context-providers/asymmetric-vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Recognize private subnet by route table","suites":[],"updatePoint":{"line":383,"column":45},"line":383,"code":"test('Recognize private subnet by route table', async () => {\n  // GIVEN\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '10.0.2.0/26',\n            Origin: 'CreateRoute',\n            State: 'active',\n            VpcPeeringConnectionId: 'pcx-xxxxxx',\n          },\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Private',\n        type: 'Private',\n        subnets: [\n          {\n            subnetId: 'sub-123456',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-123456',\n            cidr: undefined,\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: undefined,\n  });\n});","file":"context-providers/asymmetric-vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"works for asymmetric subnets (not spanning the same Availability Zones)","suites":[],"updatePoint":{"line":457,"column":77},"line":457,"code":"test('works for asymmetric subnets (not spanning the same Availability Zones)', async () => {\n  // GIVEN\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'pri-sub-in-1b', AvailabilityZone: 'us-west-1b', MapPublicIpOnLaunch: false, CidrBlock: '1.1.1.1/24' },\n      { SubnetId: 'pub-sub-in-1c', AvailabilityZone: 'us-west-1c', MapPublicIpOnLaunch: true, CidrBlock: '1.1.2.1/24' },\n      { SubnetId: 'pub-sub-in-1b', AvailabilityZone: 'us-west-1b', MapPublicIpOnLaunch: true, CidrBlock: '1.1.3.1/24' },\n      { SubnetId: 'pub-sub-in-1a', AvailabilityZone: 'us-west-1a', MapPublicIpOnLaunch: true, CidrBlock: '1.1.4.1/24' },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'pri-sub-in-1b' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ Main: true }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Private',\n        type: 'Private',\n        subnets: [\n          {\n            subnetId: 'pri-sub-in-1b',\n            availabilityZone: 'us-west-1b',\n            routeTableId: 'rtb-123456',\n            cidr: '1.1.1.1/24',\n          },\n        ],\n      },\n      {\n        name: 'Public',\n        type: 'Public',\n        subnets: [\n          {\n            subnetId: 'pub-sub-in-1a',\n            availabilityZone: 'us-west-1a',\n            routeTableId: 'rtb-789012',\n            cidr: '1.1.4.1/24',\n          },\n          {\n            subnetId: 'pub-sub-in-1b',\n            availabilityZone: 'us-west-1b',\n            routeTableId: 'rtb-789012',\n            cidr: '1.1.3.1/24',\n          },\n          {\n            subnetId: 'pub-sub-in-1c',\n            availabilityZone: 'us-west-1c',\n            routeTableId: 'rtb-789012',\n            cidr: '1.1.2.1/24',\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: undefined,\n  });\n});","file":"context-providers/asymmetric-vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"allows specifying the subnet group name tag","suites":[],"updatePoint":{"line":558,"column":49},"line":558,"code":"test('allows specifying the subnet group name tag', async () => {\n  // GIVEN\n  mockVpcLookup({\n    subnets: [\n      {\n        SubnetId: 'pri-sub-in-1b',\n        AvailabilityZone: 'us-west-1b',\n        MapPublicIpOnLaunch: false,\n        Tags: [\n          { Key: 'Tier', Value: 'restricted' },\n        ],\n      },\n      {\n        SubnetId: 'pub-sub-in-1c',\n        AvailabilityZone: 'us-west-1c',\n        MapPublicIpOnLaunch: true,\n        Tags: [\n          { Key: 'Tier', Value: 'connectivity' },\n        ],\n      },\n      {\n        SubnetId: 'pub-sub-in-1b',\n        AvailabilityZone: 'us-west-1b',\n        MapPublicIpOnLaunch: true,\n        Tags: [\n          { Key: 'Tier', Value: 'connectivity' },\n        ],\n      },\n      {\n        SubnetId: 'pub-sub-in-1a',\n        AvailabilityZone: 'us-west-1a',\n        MapPublicIpOnLaunch: true,\n        Tags: [\n          { Key: 'Tier', Value: 'connectivity' },\n        ],\n      },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'pri-sub-in-1b' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ Main: true }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n    subnetGroupNameTag: 'Tier',\n  });\n\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'restricted',\n        type: 'Private',\n        subnets: [\n          {\n            subnetId: 'pri-sub-in-1b',\n            availabilityZone: 'us-west-1b',\n            routeTableId: 'rtb-123456',\n            cidr: undefined,\n          },\n        ],\n      },\n      {\n        name: 'connectivity',\n        type: 'Public',\n        subnets: [\n          {\n            subnetId: 'pub-sub-in-1a',\n            availabilityZone: 'us-west-1a',\n            routeTableId: 'rtb-789012',\n            cidr: undefined,\n          },\n          {\n            subnetId: 'pub-sub-in-1b',\n            availabilityZone: 'us-west-1b',\n            routeTableId: 'rtb-789012',\n            cidr: undefined,\n          },\n          {\n            subnetId: 'pub-sub-in-1c',\n            availabilityZone: 'us-west-1c',\n            routeTableId: 'rtb-789012',\n            cidr: undefined,\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: undefined,\n  });\n});","file":"context-providers/asymmetric-vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors are reported into the context value","suites":[],"updatePoint":{"line":12,"column":48},"line":12,"code":"test('errors are reported into the context value', async () => {\n  // GIVEN\n  contextproviders.registerContextProvider(TEST_PROVIDER, {\n    async getValue(_: {[key: string]: any}): Promise<any> {\n      throw new Error('Something went wrong');\n    },\n  });\n  const context = new Context();\n\n  // WHEN\n  await contextproviders.provideContextValues([\n    { key: 'asdf', props: { account: '1234', region: 'us-east-1' }, provider: TEST_PROVIDER },\n  ], context, mockSDK);\n\n  // THEN - error is now in context\n\n  // NOTE: error key is inlined here because it's part of the CX-API\n  // compatibility surface.\n  expect(context.get('asdf').$providerError).toBe('Something went wrong');\n});","file":"context-providers/generic.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"lookup role ARN is resolved","suites":[],"updatePoint":{"line":33,"column":33},"line":33,"code":"test('lookup role ARN is resolved', async () => {\n  // GIVEN\n  contextproviders.registerContextProvider(TEST_PROVIDER, {\n    async getValue(args: {[key: string]: any}): Promise<any> {\n      if (args.lookupRoleArn == null) {\n        throw new Error('No lookupRoleArn');\n      }\n\n      if (args.lookupRoleArn.includes('${AWS::Partition}')) {\n        throw new Error('Partition not resolved');\n      }\n\n      return 'some resolved value';\n    },\n  });\n  const context = new Context();\n\n  // WHEN\n  await contextproviders.provideContextValues([\n    {\n      key: 'asdf',\n      props: {\n        account: '1234',\n        region: 'us-east-1',\n        lookupRoleArn: 'arn:${AWS::Partition}:iam::280619947791:role/cdk-hnb659fds-lookup-role-280619947791-us-east-1',\n      },\n      provider: TEST_PROVIDER,\n    },\n  ], context, mockSDK);\n\n  // THEN - Value gets resolved\n  expect(context.get('asdf')).toEqual('some resolved value');\n});","file":"context-providers/generic.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors are marked transient","suites":[],"updatePoint":{"line":67,"column":33},"line":67,"code":"test('errors are marked transient', async () => {\n  // GIVEN\n  contextproviders.registerContextProvider(TEST_PROVIDER, {\n    async getValue(_: {[key: string]: any}): Promise<any> {\n      throw new Error('Something went wrong');\n    },\n  });\n  const context = new Context();\n\n  // WHEN\n  await contextproviders.provideContextValues([\n    { key: 'asdf', props: { account: '1234', region: 'us-east-1' }, provider: TEST_PROVIDER },\n  ], context, mockSDK);\n\n  // THEN - error is marked transient\n  expect(context.get('asdf')[TRANSIENT_CONTEXT_KEY]).toBeTruthy();\n});","file":"context-providers/generic.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"context provider can be registered using PluginHost","suites":[],"updatePoint":{"line":85,"column":57},"line":85,"code":"test('context provider can be registered using PluginHost', async () => {\n  let called = false;\n\n  // GIVEN\n  PluginHost.instance.registerContextProviderAlpha('prov', {\n    async getValue(_: {[key: string]: any}): Promise<any> {\n      called = true;\n      return '';\n    },\n  });\n  const context = new Context();\n\n  // WHEN\n  await contextproviders.provideContextValues([\n    { key: 'asdf', props: { account: '1234', region: 'us-east-1', pluginName: 'prov' }, provider: PLUGIN_PROVIDER },\n  ], context, mockSDK);\n\n  // THEN - error is marked transient\n  expect(called).toEqual(true);\n});","file":"context-providers/generic.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"plugin context provider can be called without account/region","suites":[],"updatePoint":{"line":106,"column":66},"line":106,"code":"test('plugin context provider can be called without account/region', async () => {\n  // GIVEN\n  PluginHost.instance.registerContextProviderAlpha('prov', {\n    async getValue(_: {[key: string]: any}): Promise<any> {\n      return 'yay';\n    },\n  });\n  const context = new Context();\n\n  // WHEN\n  await contextproviders.provideContextValues([\n    { key: 'asdf', props: { banana: 'yellow', pluginName: 'prov' } as any, provider: PLUGIN_PROVIDER },\n  ], context, mockSDK);\n\n  // THEN - error is marked transient\n  expect(context.get('asdf')).toEqual('yay');\n});","file":"context-providers/generic.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up the requested Key - single result","suites":[],"updatePoint":{"line":16,"column":48},"line":16,"code":"test('looks up the requested Key - single result', async () => {\n  // GIVEN\n  const provider = new KeyContextProviderPlugin(mockSDK);\n\n  AWS.mock('KMS', 'listAliases', (params: aws.KMS.ListAliasesRequest, cb: AwsCallback<aws.KMS.ListAliasesResponse>) => {\n    expect(params.KeyId).toBeUndefined();\n    return cb(null, {\n      Aliases: [\n        {\n          AliasName: 'alias/foo',\n          TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789000',\n        },\n      ],\n    });\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    aliasName: 'alias/foo',\n  });\n\n  // THEN\n  expect(result).toEqual({\n    keyId: '1234abcd-12ab-34cd-56ef-123456789000',\n  });\n});","file":"context-providers/keys.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up the requested Key - multiple results","suites":[],"updatePoint":{"line":45,"column":51},"line":45,"code":"test('looks up the requested Key - multiple results', async () => {\n  // GIVEN\n  const provider = new KeyContextProviderPlugin(mockSDK);\n\n  AWS.mock('KMS', 'listAliases', (params: aws.KMS.ListAliasesRequest, cb: AwsCallback<aws.KMS.ListAliasesResponse>) => {\n    expect(params.KeyId).toBeUndefined();\n    return cb(null, {\n      Aliases: [\n        {\n          AliasName: 'alias/bar',\n          TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789000',\n        },\n        {\n          AliasName: 'alias/foo',\n          TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789001',\n        },\n        {\n          AliasName: 'alias/fooBar',\n          TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789002',\n        },\n      ],\n    });\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    aliasName: 'alias/foo',\n  });\n\n  // THEN\n  expect(result).toEqual({\n    keyId: '1234abcd-12ab-34cd-56ef-123456789001',\n  });\n});","file":"context-providers/keys.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up the requested Key - multiple results with pagination","suites":[],"updatePoint":{"line":82,"column":67},"line":82,"code":"test('looks up the requested Key - multiple results with pagination', async () => {\n  // GIVEN\n  const provider = new KeyContextProviderPlugin(mockSDK);\n\n  AWS.mock('KMS', 'listAliases', (params: aws.KMS.ListAliasesRequest, cb: AwsCallback<aws.KMS.ListAliasesResponse>) => {\n    if (!params.Marker) {\n      return cb(null, {\n        Truncated: true,\n        NextMarker: 'nextMarker',\n        Aliases: [\n          {\n            AliasName: 'alias/key1',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789000',\n          },\n          {\n            AliasName: 'alias/key2',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789001',\n          },\n          {\n            AliasName: 'alias/key3',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789002',\n          },\n        ],\n      });\n    } else if (params.Marker == 'nextMarker') {\n      return cb(null, {\n        Aliases: [\n          {\n            AliasName: 'alias/key4',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789003',\n          },\n          {\n            AliasName: 'alias/foo',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789004',\n          },\n          {\n            AliasName: 'alias/key5',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789005',\n          },\n        ],\n      });\n    }\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    aliasName: 'alias/foo',\n  });\n\n  // THEN\n  expect(result).toEqual({\n    keyId: '1234abcd-12ab-34cd-56ef-123456789004',\n  });\n});","file":"context-providers/keys.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throw exception - no key found","suites":[],"updatePoint":{"line":139,"column":36},"line":139,"code":"test('throw exception - no key found', async () => {\n  // GIVEN\n  const provider = new KeyContextProviderPlugin(mockSDK);\n\n  AWS.mock('KMS', 'listAliases', (params: aws.KMS.ListAliasesRequest, cb: AwsCallback<aws.KMS.ListAliasesResponse>) => {\n    expect(params.KeyId).toBeUndefined();\n    return cb(null, {\n    });\n  });\n\n  // WHEN\n  await expect(provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    aliasName: 'alias/foo',\n  })).rejects.toThrow(/Could not find any key with alias named/);\n\n});","file":"context-providers/keys.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"describeTags yields tags by chunk","suites":["utilities"],"updatePoint":{"line":20,"column":41},"line":20,"code":"  test('describeTags yields tags by chunk', async () => {\n    const resourceTags: Record<string, aws.ELBv2.TagDescription> = {};\n    for (const resourceArn of [...Array(100)].map((_, i) => `arn:load-balancer-${i}`)) {\n      resourceTags[resourceArn] = {\n        ResourceArn: resourceArn,\n        Tags: [\n          { Key: 'name', Value: resourceArn },\n        ],\n      };\n    };\n\n    AWS.mock('ELBv2', 'describeTags', (_params: aws.ELBv2.DescribeTagsInput, cb: AwsCallback<aws.ELBv2.DescribeTagsOutput>) => {\n      expect(_params.ResourceArns.length).toBeLessThanOrEqual(20);\n\n      cb(null, {\n        TagDescriptions: _params.ResourceArns.map(resourceArn => ({\n          ResourceArn: resourceArn,\n          Tags: [\n            { Key: 'name', Value: resourceArn },\n          ],\n        })),\n      });\n    });\n\n    const elbv2 = (await mockSDK.forEnvironment()).sdk.elbv2();\n\n    const resourceTagsOut: Record<string, aws.ELBv2.TagDescription> = {};\n    for await (const tagDescription of describeTags(elbv2, Object.keys(resourceTags))) {\n      resourceTagsOut[tagDescription.ResourceArn!] = tagDescription;\n    }\n\n    expect(resourceTagsOut).toEqual(resourceTags);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"describeListenersByLoadBalancerArn traverses pages","suites":["utilities"],"updatePoint":{"line":54,"column":58},"line":54,"code":"  test('describeListenersByLoadBalancerArn traverses pages', async () => {\n    // arn:listener-0, arn:listener-1, ..., arn:listener-99\n    const listenerArns = [...Array(100)].map((_, i) => `arn:listener-${i}`);\n    expect(listenerArns[0]).toEqual('arn:listener-0');\n\n    AWS.mock('ELBv2', 'describeListeners', (_params: aws.ELBv2.DescribeListenersInput, cb: AwsCallback<aws.ELBv2.DescribeListenersOutput>) => {\n      const start = parseInt(_params.Marker ?? '0');\n      const end = start + 10;\n      const slice = listenerArns.slice(start, end);\n\n      cb(null, {\n        Listeners: slice.map(arn => ({\n          ListenerArn: arn,\n        })),\n        NextMarker: end < listenerArns.length ? end.toString() : undefined,\n      });\n    });\n\n    const elbv2 = (await mockSDK.forEnvironment()).sdk.elbv2();\n\n    const listenerArnsFromPages = Array<string>();\n    for await (const listener of describeListenersByLoadBalancerArn(elbv2, ['arn:load-balancer'])) {\n      listenerArnsFromPages.push(listener.ListenerArn!);\n    }\n\n    expect(listenerArnsFromPages).toEqual(listenerArns);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"describeLoadBalancers traverses pages","suites":["utilities"],"updatePoint":{"line":82,"column":45},"line":82,"code":"  test('describeLoadBalancers traverses pages', async () => {\n    const loadBalancerArns = [...Array(100)].map((_, i) => `arn:load-balancer-${i}`);\n    expect(loadBalancerArns[0]).toEqual('arn:load-balancer-0');\n\n    AWS.mock('ELBv2', 'describeLoadBalancers', (_params: aws.ELBv2.DescribeLoadBalancersInput, cb: AwsCallback<aws.ELBv2.DescribeLoadBalancersOutput>) => {\n      const start = parseInt(_params.Marker ?? '0');\n      const end = start + 10;\n      const slice = loadBalancerArns.slice(start, end);\n\n      cb(null, {\n        LoadBalancers: slice.map(loadBalancerArn => ({\n          LoadBalancerArn: loadBalancerArn,\n        })),\n        NextMarker: end < loadBalancerArns.length ? end.toString() : undefined,\n      });\n    });\n\n    const elbv2 = (await mockSDK.forEnvironment()).sdk.elbv2();\n    const loadBalancerArnsFromPages = (await describeLoadBalancers(elbv2, {})).map(l => l.LoadBalancerArn!);\n\n    expect(loadBalancerArnsFromPages).toEqual(loadBalancerArns);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"all tags match","suites":["utilities","tagsMatch"],"updatePoint":{"line":106,"column":24},"line":106,"code":"    test('all tags match', () => {\n      const tagDescription = {\n        ResourceArn: 'arn:whatever',\n        Tags: [{ Key: 'some', Value: 'tag' }],\n      };\n\n      const requiredTags = [\n        { key: 'some', value: 'tag' },\n      ];\n\n      expect(tagsMatch(tagDescription, requiredTags)).toEqual(true);\n    });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"extra tags match","suites":["utilities","tagsMatch"],"updatePoint":{"line":119,"column":26},"line":119,"code":"    test('extra tags match', () => {\n      const tagDescription = {\n        ResourceArn: 'arn:whatever',\n        Tags: [\n          { Key: 'some', Value: 'tag' },\n          { Key: 'other', Value: 'tag2' },\n        ],\n      };\n\n      const requiredTags = [\n        { key: 'some', value: 'tag' },\n      ];\n\n      expect(tagsMatch(tagDescription, requiredTags)).toEqual(true);\n    });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"no tags matches no tags","suites":["utilities","tagsMatch"],"updatePoint":{"line":135,"column":33},"line":135,"code":"    test('no tags matches no tags', () => {\n      const tagDescription = {\n        ResourceArn: 'arn:whatever',\n        Tags: [],\n      };\n\n      expect(tagsMatch(tagDescription, [])).toEqual(true);\n    });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"one tag matches of several","suites":["utilities","tagsMatch"],"updatePoint":{"line":144,"column":36},"line":144,"code":"    test('one tag matches of several', () => {\n      const tagDescription = {\n        ResourceArn: 'arn:whatever',\n        Tags: [{ Key: 'some', Value: 'tag' }],\n      };\n\n      const requiredTags = [\n        { key: 'some', value: 'tag' },\n        { key: 'other', value: 'value' },\n      ];\n\n      expect(tagsMatch(tagDescription, requiredTags)).toEqual(false);\n    });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"undefined tag does not error","suites":["utilities","tagsMatch"],"updatePoint":{"line":158,"column":38},"line":158,"code":"    test('undefined tag does not error', () => {\n      const tagDescription = {\n        ResourceArn: 'arn:whatever',\n        Tags: [{ Key: 'some' }],\n      };\n\n      const requiredTags = [\n        { key: 'some', value: 'tag' },\n        { key: 'other', value: 'value' },\n      ];\n\n      expect(tagsMatch(tagDescription, requiredTags)).toEqual(false);\n    });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors when no matches are found","suites":["load balancer context provider plugin"],"updatePoint":{"line":175,"column":40},"line":175,"code":"  test('errors when no matches are found', async () => {\n    // GIVEN\n    const provider = new LoadBalancerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n        loadBalancerArn: 'arn:load-balancer1',\n      }),\n    ).rejects.toThrow(/No load balancers found/i);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors when multiple load balancers match","suites":["load balancer context provider plugin"],"updatePoint":{"line":194,"column":49},"line":194,"code":"  test('errors when multiple load balancers match', async () => {\n    // GIVEN\n    const provider = new LoadBalancerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [\n        {\n          IpAddressType: 'ipv4',\n          LoadBalancerArn: 'arn:load-balancer1',\n          DNSName: 'dns1.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n          Type: 'application',\n        },\n        {\n          IpAddressType: 'ipv4',\n          LoadBalancerArn: 'arn:load-balancer2',\n          DNSName: 'dns2.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n          Type: 'application',\n        },\n      ],\n      describeTagsExpected: { ResourceArns: ['arn:load-balancer1', 'arn:load-balancer2'] },\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer1',\n          Tags: [\n            { Key: 'some', Value: 'tag' },\n          ],\n        },\n        {\n          ResourceArn: 'arn:load-balancer2',\n          Tags: [\n            { Key: 'some', Value: 'tag' },\n          ],\n        },\n      ],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n        loadBalancerTags: [\n          { key: 'some', value: 'tag' },\n        ],\n      }),\n    ).rejects.toThrow(/Multiple load balancers found/i);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up by arn","suites":["load balancer context provider plugin"],"updatePoint":{"line":249,"column":23},"line":249,"code":"  test('looks up by arn', async () => {\n    // GIVEN\n    const provider = new LoadBalancerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeLoadBalancersExpected: { LoadBalancerArns: ['arn:load-balancer1'] },\n      loadBalancers: [\n        {\n          IpAddressType: 'ipv4',\n          LoadBalancerArn: 'arn:load-balancer1',\n          DNSName: 'dns.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n          Type: 'application',\n        },\n      ],\n    });\n\n    // WHEN\n    const result = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      loadBalancerArn: 'arn:load-balancer1',\n    });\n\n    // THEN\n    expect(result.ipAddressType).toEqual('ipv4');\n    expect(result.loadBalancerArn).toEqual('arn:load-balancer1');\n    expect(result.loadBalancerCanonicalHostedZoneId).toEqual('Z1234');\n    expect(result.loadBalancerDnsName).toEqual('dns.example.com');\n    expect(result.securityGroupIds).toEqual(['sg-1234']);\n    expect(result.vpcId).toEqual('vpc-1234');\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up by tags","suites":["load balancer context provider plugin"],"updatePoint":{"line":285,"column":24},"line":285,"code":"  test('looks up by tags', async() => {\n    // GIVEN\n    const provider = new LoadBalancerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [\n        {\n          IpAddressType: 'ipv4',\n          LoadBalancerArn: 'arn:load-balancer1',\n          DNSName: 'dns1.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n          Type: 'application',\n        },\n        {\n          IpAddressType: 'ipv4',\n          LoadBalancerArn: 'arn:load-balancer2',\n          DNSName: 'dns2.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n          Type: 'application',\n        },\n      ],\n      describeTagsExpected: { ResourceArns: ['arn:load-balancer1', 'arn:load-balancer2'] },\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer1',\n          Tags: [\n            { Key: 'some', Value: 'tag' },\n          ],\n        },\n        {\n          ResourceArn: 'arn:load-balancer2',\n          Tags: [\n            { Key: 'some', Value: 'tag' },\n            { Key: 'second', Value: 'tag2' },\n          ],\n        },\n      ],\n    });\n\n    // WHEN\n    const result = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      loadBalancerTags: [\n        { key: 'some', value: 'tag' },\n        { key: 'second', value: 'tag2' },\n      ],\n    });\n\n    expect(result.loadBalancerArn).toEqual('arn:load-balancer2');\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"filters by type","suites":["load balancer context provider plugin"],"updatePoint":{"line":342,"column":23},"line":342,"code":"  test('filters by type', async () => {\n    // GIVEN\n    const provider = new LoadBalancerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [\n        {\n          IpAddressType: 'ipv4',\n          Type: 'network',\n          LoadBalancerArn: 'arn:load-balancer1',\n          DNSName: 'dns1.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n        },\n        {\n          IpAddressType: 'ipv4',\n          Type: 'application',\n          LoadBalancerArn: 'arn:load-balancer2',\n          DNSName: 'dns2.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n        },\n      ],\n\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer1',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n        {\n          ResourceArn: 'arn:load-balancer2',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n      ],\n    });\n\n    // WHEN\n    const loadBalancer = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerTags: [{ key: 'some', value: 'tag' }],\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n    });\n\n    expect(loadBalancer.loadBalancerArn).toEqual('arn:load-balancer2');\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors when no associated load balancers match","suites":["load balancer listener context provider plugin"],"updatePoint":{"line":393,"column":54},"line":393,"code":"  test('errors when no associated load balancers match', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n        loadBalancerTags: [{ key: 'some', value: 'tag' }],\n      }),\n    ).rejects.toThrow(/No associated load balancers found/i);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors when no listeners match","suites":["load balancer listener context provider plugin"],"updatePoint":{"line":412,"column":38},"line":412,"code":"  test('errors when no listeners match', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [\n        {\n          LoadBalancerArn: 'arn:load-balancer',\n          Type: 'application',\n        },\n      ],\n      listeners: [\n        {\n          LoadBalancerArn: 'arn:load-balancer',\n          ListenerArn: 'arn:listener',\n          Port: 80,\n          Protocol: 'HTTP',\n        },\n      ],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n        loadBalancerArn: 'arn:load-balancer',\n        listenerPort: 443,\n        listenerProtocol: cxschema.LoadBalancerListenerProtocol.HTTPS,\n      }),\n    ).rejects.toThrow(/No load balancer listeners found/i);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors when multiple listeners match","suites":["load balancer listener context provider plugin"],"updatePoint":{"line":446,"column":44},"line":446,"code":"  test('errors when multiple listeners match', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [\n        {\n          LoadBalancerArn: 'arn:load-balancer',\n          Type: 'application',\n        },\n        {\n          LoadBalancerArn: 'arn:load-balancer2',\n          Type: 'application',\n        },\n      ],\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n        {\n          ResourceArn: 'arn:load-balancer2',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n      ],\n      listeners: [\n        {\n          LoadBalancerArn: 'arn:load-balancer',\n          ListenerArn: 'arn:listener',\n          Port: 80,\n          Protocol: 'HTTP',\n        },\n        {\n          LoadBalancerArn: 'arn:load-balancer2',\n          ListenerArn: 'arn:listener2',\n          Port: 80,\n          Protocol: 'HTTP',\n        },\n      ],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n        loadBalancerTags: [{ key: 'some', value: 'tag' }],\n        listenerPort: 80,\n        listenerProtocol: cxschema.LoadBalancerListenerProtocol.HTTP,\n      }),\n    ).rejects.toThrow(/Multiple load balancer listeners/i);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up by listener arn","suites":["load balancer listener context provider plugin"],"updatePoint":{"line":500,"column":32},"line":500,"code":"  test('looks up by listener arn', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeListenersExpected: { ListenerArns: ['arn:listener-arn'] },\n      listeners: [\n        {\n          ListenerArn: 'arn:listener-arn',\n          LoadBalancerArn: 'arn:load-balancer-arn',\n          Port: 999,\n        },\n      ],\n      describeLoadBalancersExpected: { LoadBalancerArns: ['arn:load-balancer-arn'] },\n      loadBalancers: [\n        {\n          LoadBalancerArn: 'arn:load-balancer-arn',\n          SecurityGroups: ['sg-1234', 'sg-2345'],\n          Type: 'application',\n        },\n      ],\n    });\n\n    // WHEN\n    const listener = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      listenerArn: 'arn:listener-arn',\n    });\n\n    // THEN\n    expect(listener.listenerArn).toEqual('arn:listener-arn');\n    expect(listener.listenerPort).toEqual(999);\n    expect(listener.securityGroupIds).toEqual(['sg-1234', 'sg-2345']);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up by associated load balancer arn","suites":["load balancer listener context provider plugin"],"updatePoint":{"line":537,"column":48},"line":537,"code":"  test('looks up by associated load balancer arn', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeLoadBalancersExpected: { LoadBalancerArns: ['arn:load-balancer-arn1'] },\n      loadBalancers: [\n        {\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          SecurityGroups: ['sg-1234'],\n          Type: 'application',\n        },\n      ],\n\n      describeListenersExpected: { LoadBalancerArn: 'arn:load-balancer-arn1' },\n      listeners: [\n        {\n          // This one\n          ListenerArn: 'arn:listener-arn1',\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          Port: 80,\n        },\n      ],\n    });\n\n    // WHEN\n    const listener = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      loadBalancerArn: 'arn:load-balancer-arn1',\n    });\n\n    // THEN\n    expect(listener.listenerArn).toEqual('arn:listener-arn1');\n    expect(listener.listenerPort).toEqual(80);\n    expect(listener.securityGroupIds).toEqual(['sg-1234']);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up by associated load balancer tags","suites":["load balancer listener context provider plugin"],"updatePoint":{"line":576,"column":49},"line":576,"code":"  test('looks up by associated load balancer tags', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeLoadBalancersExpected: { LoadBalancerArns: undefined },\n      loadBalancers: [\n        {\n          // This one should have the wrong tags\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          SecurityGroups: ['sg-1234', 'sg-2345'],\n          Type: 'application',\n        },\n        {\n          // Expecting this one\n          LoadBalancerArn: 'arn:load-balancer-arn2',\n          SecurityGroups: ['sg-3456', 'sg-4567'],\n          Type: 'application',\n        },\n      ],\n\n      describeTagsExpected: { ResourceArns: ['arn:load-balancer-arn1', 'arn:load-balancer-arn2'] },\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer-arn1',\n          Tags: [],\n        },\n        {\n          // Expecting this one\n          ResourceArn: 'arn:load-balancer-arn2',\n          Tags: [\n            { Key: 'some', Value: 'tag' },\n          ],\n        },\n      ],\n\n      describeListenersExpected: { LoadBalancerArn: 'arn:load-balancer-arn2' },\n      listeners: [\n        {\n          // This one\n          ListenerArn: 'arn:listener-arn1',\n          LoadBalancerArn: 'arn:load-balancer-arn2',\n          Port: 80,\n        },\n        {\n          ListenerArn: 'arn:listener-arn2',\n          LoadBalancerArn: 'arn:load-balancer-arn2',\n          Port: 999,\n        },\n      ],\n    });\n\n    // WHEN\n    const listener = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      loadBalancerTags: [\n        { key: 'some', value: 'tag' },\n      ],\n      listenerPort: 999,\n    });\n\n    // THEN\n    expect(listener.listenerArn).toEqual('arn:listener-arn2');\n    expect(listener.listenerPort).toEqual(999);\n    expect(listener.securityGroupIds).toEqual(['sg-3456', 'sg-4567']);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up by listener port and proto","suites":["load balancer listener context provider plugin"],"updatePoint":{"line":645,"column":43},"line":645,"code":"  test('looks up by listener port and proto', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    AWS.mock('ELBv2', 'describeLoadBalancers', (_params: aws.ELBv2.DescribeLoadBalancersInput, cb: AwsCallback<aws.ELBv2.DescribeLoadBalancersOutput>) => {\n      expect(_params).toEqual({});\n      cb(null, {\n        LoadBalancers: [\n          {\n            // Shouldn't have any matching listeners\n            IpAddressType: 'ipv4',\n            LoadBalancerArn: 'arn:load-balancer1',\n            DNSName: 'dns1.example.com',\n            CanonicalHostedZoneId: 'Z1234',\n            SecurityGroups: ['sg-1234'],\n            VpcId: 'vpc-1234',\n            Type: 'application',\n          },\n          {\n            // Should have a matching listener\n            IpAddressType: 'ipv4',\n            LoadBalancerArn: 'arn:load-balancer2',\n            DNSName: 'dns2.example.com',\n            CanonicalHostedZoneId: 'Z1234',\n            SecurityGroups: ['sg-2345'],\n            VpcId: 'vpc-1234',\n            Type: 'application',\n          },\n        ],\n      });\n    });\n\n    AWS.mock('ELBv2', 'describeTags', (_params: aws.ELBv2.DescribeTagsInput, cb: AwsCallback<aws.ELBv2.DescribeTagsOutput>) => {\n      cb(null, {\n        TagDescriptions: [\n          {\n            ResourceArn: 'arn:load-balancer1',\n            Tags: [{ Key: 'some', Value: 'tag' }],\n          },\n          {\n            ResourceArn: 'arn:load-balancer2',\n            Tags: [{ Key: 'some', Value: 'tag' }],\n          },\n        ],\n      });\n    });\n\n    AWS.mock('ELBv2', 'describeListeners', (params: aws.ELBv2.DescribeListenersInput, cb: AwsCallback<aws.ELBv2.DescribeListenersOutput>) => {\n      if (params.LoadBalancerArn === 'arn:load-balancer1') {\n        cb(null, {\n          Listeners: [\n            {\n            // Wrong port, wrong protocol => no match\n              ListenerArn: 'arn:listener-arn1',\n              LoadBalancerArn: 'arn:load-balancer1',\n              Protocol: 'HTTP',\n              Port: 80,\n            },\n            {\n            // Wrong protocol, right port => no match\n              ListenerArn: 'arn:listener-arn3',\n              LoadBalancerArn: 'arn:load-balancer1',\n              Protocol: 'HTTPS',\n              Port: 443,\n            },\n            {\n            // Wrong port, right protocol => no match\n              ListenerArn: 'arn:listener-arn4',\n              LoadBalancerArn: 'arn:load-balancer1',\n              Protocol: 'TCP',\n              Port: 999,\n            },\n          ],\n        });\n      } else if (params.LoadBalancerArn === 'arn:load-balancer2') {\n        cb(null, {\n          Listeners: [\n            {\n            // Wrong port, wrong protocol => no match\n              ListenerArn: 'arn:listener-arn5',\n              LoadBalancerArn: 'arn:load-balancer2',\n              Protocol: 'HTTP',\n              Port: 80,\n            },\n            {\n            // Right port, right protocol => match\n              ListenerArn: 'arn:listener-arn6',\n              LoadBalancerArn: 'arn:load-balancer2',\n              Port: 443,\n              Protocol: 'TCP',\n            },\n          ],\n        });\n      } else {\n        cb(new Error(`Unexpected request: ${JSON.stringify(params)}'`), {});\n      }\n    });\n\n    // WHEN\n    const listener = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      loadBalancerTags: [{ key: 'some', value: 'tag' }],\n      listenerProtocol: cxschema.LoadBalancerListenerProtocol.TCP,\n      listenerPort: 443,\n    });\n\n    // THEN\n    expect(listener.listenerArn).toEqual('arn:listener-arn6');\n    expect(listener.listenerPort).toEqual(443);\n    expect(listener.securityGroupIds).toEqual(['sg-2345']);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"filters by associated load balancer type","suites":["load balancer listener context provider plugin"],"updatePoint":{"line":759,"column":48},"line":759,"code":"  test('filters by associated load balancer type', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeLoadBalancersExpected: { LoadBalancerArns: undefined },\n      loadBalancers: [\n        {\n          // This one has wrong type => no match\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          SecurityGroups: [],\n          Type: 'application',\n        },\n        {\n          // Right type => match\n          LoadBalancerArn: 'arn:load-balancer-arn2',\n          SecurityGroups: [],\n          Type: 'network',\n        },\n      ],\n\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer-arn1',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n        {\n          ResourceArn: 'arn:load-balancer-arn2',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n      ],\n\n      describeListenersExpected: { LoadBalancerArn: 'arn:load-balancer-arn2' },\n      listeners: [\n        {\n          ListenerArn: 'arn:listener-arn2',\n          LoadBalancerArn: 'arn:load-balancer-arn2',\n          Port: 443,\n        },\n      ],\n    });\n\n    // WHEN\n    const listener = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.NETWORK,\n      loadBalancerTags: [{ key: 'some', value: 'tag' }],\n      listenerPort: 443,\n    });\n\n    // THEN\n    expect(listener.listenerArn).toEqual('arn:listener-arn2');\n    expect(listener.listenerPort).toEqual(443);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors when associated load balancer is wrong type","suites":["load balancer listener context provider plugin"],"updatePoint":{"line":815,"column":58},"line":815,"code":"  test('errors when associated load balancer is wrong type', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeListenersExpected: { ListenerArns: ['arn:listener-arn1'] },\n      listeners: [\n        {\n          ListenerArn: 'arn:listener-arn1',\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          Port: 443,\n        },\n      ],\n\n      describeLoadBalancersExpected: { LoadBalancerArns: ['arn:load-balancer-arn1'] },\n      loadBalancers: [\n        {\n          // This one has wrong type => no match\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          SecurityGroups: [],\n          Type: 'application',\n        },\n      ],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.NETWORK,\n        listenerArn: 'arn:listener-arn1',\n      }),\n    ).rejects.toThrow(/no associated load balancer found/i);\n  });","file":"context-providers/load-balancers.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors when no matches are found","suites":["security group context provider plugin"],"updatePoint":{"line":19,"column":40},"line":19,"code":"  test('errors when no matches are found', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      cb(null, { SecurityGroups: [] });\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        securityGroupId: 'sg-1234',\n      }),\n    ).rejects.toThrow(/No security groups found/i);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up by security group id","suites":["security group context provider plugin"],"updatePoint":{"line":37,"column":37},"line":37,"code":"  test('looks up by security group id', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({ GroupIds: ['sg-1234'] });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '0.0.0.0/0' },\n                ],\n              },\n              {\n                IpProtocol: '-1',\n                Ipv6Ranges: [\n                  { CidrIpv6: '::/0' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n\n    // WHEN\n    const res = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      securityGroupId: 'sg-1234',\n    });\n\n    // THEN\n    expect(res.securityGroupId).toEqual('sg-1234');\n    expect(res.allowAllOutbound).toEqual(true);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up by security group id and vpc id","suites":["security group context provider plugin"],"updatePoint":{"line":78,"column":48},"line":78,"code":"  test('looks up by security group id and vpc id', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({\n        GroupIds: ['sg-1234'],\n        Filters: [\n          {\n            Name: 'vpc-id',\n            Values: ['vpc-1234567'],\n          },\n        ],\n      });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '0.0.0.0/0' },\n                ],\n              },\n              {\n                IpProtocol: '-1',\n                Ipv6Ranges: [\n                  { CidrIpv6: '::/0' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n\n    // WHEN\n    const res = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      securityGroupId: 'sg-1234',\n      vpcId: 'vpc-1234567',\n    });\n\n    // THEN\n    expect(res.securityGroupId).toEqual('sg-1234');\n    expect(res.allowAllOutbound).toEqual(true);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up by security group name","suites":["security group context provider plugin"],"updatePoint":{"line":128,"column":39},"line":128,"code":"  test('looks up by security group name', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({\n        Filters: [\n          {\n            Name: 'group-name',\n            Values: ['my-security-group'],\n          },\n        ],\n      });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '0.0.0.0/0' },\n                ],\n              },\n              {\n                IpProtocol: '-1',\n                Ipv6Ranges: [\n                  { CidrIpv6: '::/0' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n\n    // WHEN\n    const res = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      securityGroupName: 'my-security-group',\n    });\n\n    // THEN\n    expect(res.securityGroupId).toEqual('sg-1234');\n    expect(res.allowAllOutbound).toEqual(true);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up by security group name and vpc id","suites":["security group context provider plugin"],"updatePoint":{"line":176,"column":50},"line":176,"code":"  test('looks up by security group name and vpc id', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({\n        Filters: [\n          {\n            Name: 'vpc-id',\n            Values: ['vpc-1234567'],\n          },\n          {\n            Name: 'group-name',\n            Values: ['my-security-group'],\n          },\n        ],\n      });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '0.0.0.0/0' },\n                ],\n              },\n              {\n                IpProtocol: '-1',\n                Ipv6Ranges: [\n                  { CidrIpv6: '::/0' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n\n    // WHEN\n    const res = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      securityGroupName: 'my-security-group',\n      vpcId: 'vpc-1234567',\n    });\n\n    // THEN\n    expect(res.securityGroupId).toEqual('sg-1234');\n    expect(res.allowAllOutbound).toEqual(true);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"detects non all-outbound egress","suites":["security group context provider plugin"],"updatePoint":{"line":229,"column":39},"line":229,"code":"  test('detects non all-outbound egress', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({ GroupIds: ['sg-1234'] });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '10.0.0.0/16' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n\n    // WHEN\n    const res = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      securityGroupId: 'sg-1234',\n    });\n\n    // THEN\n    expect(res.securityGroupId).toEqual('sg-1234');\n    expect(res.allowAllOutbound).toEqual(false);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors when more than one security group is found","suites":["security group context provider plugin"],"updatePoint":{"line":264,"column":57},"line":264,"code":"  test('errors when more than one security group is found', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({ GroupIds: ['sg-1234'] });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '10.0.0.0/16' },\n                ],\n              },\n            ],\n          },\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '10.0.0.0/16' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        securityGroupId: 'sg-1234',\n      }),\n    ).rejects.toThrow(/\\More than one security groups found matching/i);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors when securityGroupId and securityGroupName are specified both","suites":["security group context provider plugin"],"updatePoint":{"line":307,"column":76},"line":307,"code":"  test('errors when securityGroupId and securityGroupName are specified both', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        securityGroupId: 'sg-1234',\n        securityGroupName: 'my-security-group',\n      }),\n    ).rejects.toThrow(/\\'securityGroupId\\' and \\'securityGroupName\\' can not be specified both when looking up a security group/i);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"errors when neither securityGroupId nor securityGroupName are specified","suites":["security group context provider plugin"],"updatePoint":{"line":322,"column":79},"line":322,"code":"  test('errors when neither securityGroupId nor securityGroupName are specified', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n      }),\n    ).rejects.toThrow(/\\'securityGroupId\\' or \\'securityGroupName\\' must be specified to look up a security group/i);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"identifies allTrafficEgress from SecurityGroup permissions","suites":["security group context provider plugin"],"updatePoint":{"line":335,"column":66},"line":335,"code":"  test('identifies allTrafficEgress from SecurityGroup permissions', () => {\n    expect(\n      hasAllTrafficEgress({\n        IpPermissionsEgress: [\n          {\n            IpProtocol: '-1',\n            IpRanges: [\n              { CidrIp: '0.0.0.0/0' },\n            ],\n          },\n          {\n            IpProtocol: '-1',\n            Ipv6Ranges: [\n              { CidrIpv6: '::/0' },\n            ],\n          },\n        ],\n      }),\n    ).toBe(true);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"identifies allTrafficEgress from SecurityGroup permissions when combined","suites":["security group context provider plugin"],"updatePoint":{"line":356,"column":80},"line":356,"code":"  test('identifies allTrafficEgress from SecurityGroup permissions when combined', () => {\n    expect(\n      hasAllTrafficEgress({\n        IpPermissionsEgress: [\n          {\n            IpProtocol: '-1',\n            IpRanges: [\n              { CidrIp: '0.0.0.0/0' },\n            ],\n            Ipv6Ranges: [\n              { CidrIpv6: '::/0' },\n            ],\n          },\n        ],\n      }),\n    ).toBe(true);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"identifies lacking allTrafficEgress from SecurityGroup permissions","suites":["security group context provider plugin"],"updatePoint":{"line":374,"column":74},"line":374,"code":"  test('identifies lacking allTrafficEgress from SecurityGroup permissions', () => {\n    expect(\n      hasAllTrafficEgress({\n        IpPermissionsEgress: [\n          {\n            IpProtocol: '-1',\n            IpRanges: [\n              { CidrIp: '10.0.0.0/16' },\n            ],\n          },\n        ],\n      }),\n    ).toBe(false);\n\n    expect(\n      hasAllTrafficEgress({\n        IpPermissions: [\n          {\n            IpProtocol: 'TCP',\n            IpRanges: [\n              { CidrIp: '0.0.0.0/0' },\n            ],\n          },\n        ],\n      }),\n    ).toBe(false);\n  });","file":"context-providers/security-groups.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"looks up the requested VPC","suites":[],"updatePoint":{"line":18,"column":32},"line":18,"code":"test('looks up the requested VPC', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ SubnetId: 'sub-789012' }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: ['sub-789012'],\n    privateSubnetNames: ['Private'],\n    privateSubnetRouteTableIds: ['rtb-789012'],\n    publicSubnetIds: ['sub-123456'],\n    publicSubnetNames: ['Public'],\n    publicSubnetRouteTableIds: ['rtb-123456'],\n    vpnGatewayId: 'gw-abcdef',\n    subnetGroups: undefined,\n  });\n});","file":"context-providers/vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws when no such VPC is found","suites":[],"updatePoint":{"line":97,"column":38},"line":97,"code":"test('throws when no such VPC is found', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  AWS.mock('EC2', 'describeVpcs', (params: aws.EC2.DescribeVpcsRequest, cb: AwsCallback<aws.EC2.DescribeVpcsResult>) => {\n    expect(params.Filters).toEqual([{ Name: 'foo', Values: ['bar'] }]);\n    return cb(null, {});\n  });\n\n  // WHEN\n  await expect(provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  })).rejects.toThrow(/Could not find any VPCs matching/);\n});","file":"context-providers/vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws when subnet with subnetGroupNameTag not found","suites":[],"updatePoint":{"line":115,"column":58},"line":115,"code":"test('throws when subnet with subnetGroupNameTag not found', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ SubnetId: 'sub-789012' }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n  });\n\n  // WHEN\n  await expect(provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    subnetGroupNameTag: 'DOES_NOT_EXIST',\n    filter,\n  })).rejects.toThrow(/Invalid subnetGroupNameTag: Subnet .* does not have an associated tag with Key='DOES_NOT_EXIST'/);\n});","file":"context-providers/vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not throw when subnet with subnetGroupNameTag is found","suites":[],"updatePoint":{"line":175,"column":65},"line":175,"code":"test('does not throw when subnet with subnetGroupNameTag is found', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true, Tags: [{ Key: 'DOES_EXIST', Value: 'SubnetName1' }] },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false, Tags: [{ Key: 'DOES_EXIST', Value: 'SubnetName2' }] },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ SubnetId: 'sub-789012' }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    subnetGroupNameTag: 'DOES_EXIST',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: ['sub-789012'],\n    privateSubnetNames: ['SubnetName2'],\n    privateSubnetRouteTableIds: ['rtb-789012'],\n    publicSubnetIds: ['sub-123456'],\n    publicSubnetNames: ['SubnetName1'],\n    publicSubnetRouteTableIds: ['rtb-123456'],\n    vpnGatewayId: 'gw-abcdef',\n    subnetGroups: undefined,\n  });\n});","file":"context-providers/vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws when multiple VPCs are found","suites":[],"updatePoint":{"line":254,"column":41},"line":254,"code":"test('throws when multiple VPCs are found', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  AWS.mock('EC2', 'describeVpcs', (params: aws.EC2.DescribeVpcsRequest, cb: AwsCallback<aws.EC2.DescribeVpcsResult>) => {\n    expect(params.Filters).toEqual([{ Name: 'foo', Values: ['bar'] }]);\n    return cb(null, { Vpcs: [{ VpcId: 'vpc-1' }, { VpcId: 'vpc-2' }] });\n  });\n\n  // WHEN\n  await expect(provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  })).rejects.toThrow(/Found 2 VPCs matching/);\n});","file":"context-providers/vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"uses the VPC main route table when a subnet has no specific association","suites":[],"updatePoint":{"line":272,"column":77},"line":272,"code":"test('uses the VPC main route table when a subnet has no specific association', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ Main: true }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: ['sub-789012'],\n    privateSubnetNames: ['Private'],\n    privateSubnetRouteTableIds: ['rtb-789012'],\n    publicSubnetIds: ['sub-123456'],\n    publicSubnetNames: ['Public'],\n    publicSubnetRouteTableIds: ['rtb-123456'],\n    vpnGatewayId: 'gw-abcdef',\n    subnetGroups: undefined,\n  });\n});","file":"context-providers/vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Recognize public subnet by route table","suites":[],"updatePoint":{"line":350,"column":44},"line":350,"code":"test('Recognize public subnet by route table', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '10.0.2.0/26',\n            Origin: 'CreateRoute',\n            State: 'active',\n            VpcPeeringConnectionId: 'pcx-xxxxxx',\n          },\n          {\n            DestinationCidrBlock: '10.0.1.0/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: ['sub-123456'],\n    publicSubnetNames: ['Public'],\n    publicSubnetRouteTableIds: ['rtb-123456'],\n    vpnGatewayId: undefined,\n    subnetGroups: undefined,\n  });\n});","file":"context-providers/vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Recognize private subnet by route table","suites":[],"updatePoint":{"line":414,"column":45},"line":414,"code":"test('Recognize private subnet by route table', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '10.0.2.0/26',\n            Origin: 'CreateRoute',\n            State: 'active',\n            VpcPeeringConnectionId: 'pcx-xxxxxx',\n          },\n          {\n            DestinationCidrBlock: '10.0.1.0/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: ['sub-123456'],\n    privateSubnetNames: ['Private'],\n    privateSubnetRouteTableIds: ['rtb-123456'],\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    vpnGatewayId: undefined,\n    subnetGroups: undefined,\n  });\n});","file":"context-providers/vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Recognize isolated subnet by route table","suites":[],"updatePoint":{"line":478,"column":46},"line":478,"code":"test('Recognize isolated subnet by route table', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '10.0.1.0/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: ['sub-123456'],\n    isolatedSubnetNames: ['Isolated'],\n    isolatedSubnetRouteTableIds: ['rtb-123456'],\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    vpnGatewayId: undefined,\n    subnetGroups: undefined,\n  });\n});","file":"context-providers/vpcs.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"load context from both files if available","suites":[],"updatePoint":{"line":27,"column":47},"line":27,"code":"test('load context from both files if available', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.context.json', { foo: 'bar' });\n  await fs.writeJSON('cdk.json', { context: { boo: 'far' } });\n\n  // WHEN\n  const config = await new Configuration({ readUserContext: false }).load();\n\n  // THEN\n  expect(config.context.get('foo')).toBe('bar');\n  expect(config.context.get('boo')).toBe('far');\n});","file":"context.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deleted context disappears from new file","suites":[],"updatePoint":{"line":40,"column":46},"line":40,"code":"test('deleted context disappears from new file', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.context.json', { foo: 'bar' });\n  await fs.writeJSON('cdk.json', { context: { foo: 'bar' } });\n  const config = await new Configuration({ readUserContext: false }).load();\n\n  // WHEN\n  config.context.unset('foo');\n  await config.saveContext();\n\n  // THEN\n  expect(await fs.readJSON('cdk.context.json')).toEqual({});\n  expect(await fs.readJSON('cdk.json')).toEqual({ context: { foo: 'bar' } });\n});","file":"context.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"clear deletes from new file","suites":[],"updatePoint":{"line":55,"column":33},"line":55,"code":"test('clear deletes from new file', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.context.json', { foo: 'bar' });\n  await fs.writeJSON('cdk.json', { context: { boo: 'far' } });\n  const config = await new Configuration({ readUserContext: false }).load();\n\n  // WHEN\n  config.context.clear();\n  await config.saveContext();\n\n  // THEN\n  expect(await fs.readJSON('cdk.context.json')).toEqual({});\n  expect(await fs.readJSON('cdk.json')).toEqual({ context: { boo: 'far' } });\n});","file":"context.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"context is preserved in the location from which it is read","suites":[],"updatePoint":{"line":70,"column":64},"line":70,"code":"test('context is preserved in the location from which it is read', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.json', { context: { 'boo:boo': 'far' } });\n  const config = await new Configuration({ readUserContext: false }).load();\n\n  // WHEN\n  expect(config.context.all).toEqual({ 'boo:boo': 'far' });\n  await config.saveContext();\n\n  // THEN\n  expect(await fs.readJSON('cdk.context.json')).toEqual({});\n  expect(await fs.readJSON('cdk.json')).toEqual({ context: { 'boo:boo': 'far' } });\n});","file":"context.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"surive no context in old file","suites":[],"updatePoint":{"line":84,"column":35},"line":84,"code":"test('surive no context in old file', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.json', { });\n  await fs.writeJSON('cdk.context.json', { boo: 'far' });\n  const config = await new Configuration({ readUserContext: false }).load();\n\n  // WHEN\n  expect(config.context.all).toEqual({ boo: 'far' });\n  await config.saveContext();\n\n  // THEN\n  expect(await fs.readJSON('cdk.context.json')).toEqual({ boo: 'far' });\n});","file":"context.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"command line context is merged with stored context","suites":[],"updatePoint":{"line":98,"column":56},"line":98,"code":"test('command line context is merged with stored context', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.context.json', { boo: 'far' });\n  const config = await new Configuration({\n    readUserContext: false,\n    commandLineArguments: {\n      context: ['foo=bar'],\n      _: ['command'],\n    } as any,\n  }).load();\n\n  // WHEN\n  expect(config.context.all).toEqual({ foo: 'bar', boo: 'far' });\n});","file":"context.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can save and load","suites":[],"updatePoint":{"line":113,"column":23},"line":113,"code":"test('can save and load', async () => {\n  // GIVEN\n  const config1 = await new Configuration({ readUserContext: false }).load();\n  config1.context.set('some_key', 'some_value');\n  await config1.saveContext();\n  expect(config1.context.get('some_key')).toEqual('some_value');\n\n  // WHEN\n  const config2 = await new Configuration({ readUserContext: false }).load();\n\n  // THEN\n  expect(config2.context.get('some_key')).toEqual('some_value');\n});","file":"context.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"transient values arent saved to disk","suites":[],"updatePoint":{"line":127,"column":42},"line":127,"code":"test('transient values arent saved to disk', async () => {\n  // GIVEN\n  const config1 = await new Configuration({ readUserContext: false }).load();\n  config1.context.set('some_key', { [TRANSIENT_CONTEXT_KEY]: true, value: 'some_value' });\n  await config1.saveContext();\n  expect(config1.context.get('some_key').value).toEqual('some_value');\n\n  // WHEN\n  const config2 = await new Configuration({ readUserContext: false }).load();\n\n  // THEN\n  expect(config2.context.get('some_key')).toEqual(undefined);\n});","file":"context.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"diff can diff multiple stacks","suites":["non-nested stacks"],"updatePoint":{"line":69,"column":37},"line":69,"code":"  test('diff can diff multiple stacks', async () => {\n    // GIVEN\n    const buffer = new StringWritable();\n\n    // WHEN\n    const exitCode = await toolkit.diff({\n      stackNames: ['B'],\n      stream: buffer,\n    });\n\n    // THEN\n    const plainTextOutput = buffer.data.replace(/\\x1B\\[[0-?]*[ -/]*[@-~]/g, '');\n    expect(plainTextOutput).toContain('Stack A');\n    expect(plainTextOutput).toContain('Stack B');\n\n    expect(exitCode).toBe(0);\n  });","file":"diff.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"exits with 1 with diffs and fail set to true","suites":["non-nested stacks"],"updatePoint":{"line":87,"column":52},"line":87,"code":"  test('exits with 1 with diffs and fail set to true', async () => {\n    // GIVEN\n    const buffer = new StringWritable();\n\n    // WHEN\n    const exitCode = await toolkit.diff({\n      stackNames: ['A'],\n      stream: buffer,\n      fail: true,\n    });\n\n    // THEN\n    expect(exitCode).toBe(1);\n  });","file":"diff.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws an error if no valid stack names given","suites":["non-nested stacks"],"updatePoint":{"line":102,"column":53},"line":102,"code":"  test('throws an error if no valid stack names given', async () => {\n    const buffer = new StringWritable();\n\n    // WHEN\n    await expect(() => toolkit.diff({\n      stackNames: ['X', 'Y', 'Z'],\n      stream: buffer,\n    })).rejects.toThrow('No stacks match the name(s) X,Y,Z');\n  });","file":"diff.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"exits with 1 with diff in first stack, but not in second stack and fail set to true","suites":["non-nested stacks"],"updatePoint":{"line":112,"column":91},"line":112,"code":"  test('exits with 1 with diff in first stack, but not in second stack and fail set to true', async () => {\n    // GIVEN\n    const buffer = new StringWritable();\n\n    // WHEN\n    const exitCode = await toolkit.diff({\n      stackNames: ['A', 'D'],\n      stream: buffer,\n      fail: true,\n    });\n\n    // THEN\n    expect(exitCode).toBe(1);\n  });","file":"diff.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws an error during diffs on stack with error metadata","suites":["non-nested stacks"],"updatePoint":{"line":127,"column":65},"line":127,"code":"  test('throws an error during diffs on stack with error metadata', async () => {\n    const buffer = new StringWritable();\n\n    // WHEN\n    await expect(() => toolkit.diff({\n      stackNames: ['C'],\n      stream: buffer,\n    })).rejects.toThrow(/Found errors/);\n  });","file":"diff.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"diff can diff nested stacks","suites":["nested stacks"],"updatePoint":{"line":229,"column":35},"line":229,"code":"  test('diff can diff nested stacks', async () => {\n    // GIVEN\n    const buffer = new StringWritable();\n\n    // WHEN\n    const exitCode = await toolkit.diff({\n      stackNames: ['Parent'],\n      stream: buffer,\n    });\n\n    // THEN\n    const plainTextOutput = buffer.data.replace(/\\x1B\\[[0-?]*[ -/]*[@-~]/g, '')\n      .replace(/[ \\t]+$/mg, '');\n    expect(plainTextOutput.trim()).toEqual(`Stack Parent\nResources\n[~] AWS::CloudFormation::Stack AdditionChild\n  [~] Resources\n      [~] .SomeResource:\n          [+] Added: .Properties\n[~] AWS::CloudFormation::Stack DeletionChild\n  [~] Resources\n      [~] .SomeResource:\n          [-] Removed: .Properties\n[~] AWS::CloudFormation::Stack ChangedChild\n  [~] Resources\n      [~] .SomeResource:\n          [~] .Properties:\n              [~] .Prop:\n                  [-] old-value\n                  [+] new-value`);\n\n    expect(exitCode).toBe(0);\n  });","file":"diff.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"discovers importable resources","suites":[],"updatePoint":{"line":78,"column":36},"line":78,"code":"test('discovers importable resources', async () => {\n  givenCurrentStack(STACK_WITH_QUEUE.stackName, {\n    Resources: {},\n  });\n\n  const importer = new ResourceImporter(STACK_WITH_QUEUE, deployments);\n  const { additions } = await importer.discoverImportableResources();\n  expect(additions).toEqual([\n    expect.objectContaining({\n      logicalId: 'MyQueue',\n    }),\n  ]);\n});","file":"import.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"by default, its an error if there are non-addition changes in the template","suites":[],"updatePoint":{"line":92,"column":80},"line":92,"code":"test('by default, its an error if there are non-addition changes in the template', async () => {\n  givenCurrentStack(STACK_WITH_QUEUE.stackName, {\n    Resources: {\n      SomethingThatDisappeared: {\n        Type: 'AWS::S3::Bucket',\n      },\n    },\n  });\n\n  const importer = new ResourceImporter(STACK_WITH_QUEUE, deployments);\n  await expect(importer.discoverImportableResources()).rejects.toThrow(/No resource updates or deletes/);\n\n  // But the error can be silenced\n  await expect(importer.discoverImportableResources(true)).resolves.toBeTruthy();\n});","file":"import.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"asks human for resource identifiers","suites":[],"updatePoint":{"line":108,"column":41},"line":108,"code":"test('asks human for resource identifiers', async () => {\n  // GIVEN\n  givenCurrentStack(STACK_WITH_QUEUE.stackName, { Resources: {} });\n  const importer = new ResourceImporter(STACK_WITH_QUEUE, deployments);\n  const { additions } = await importer.discoverImportableResources();\n\n  // WHEN\n  promptlyPrompt.mockResolvedValue('TheQueueName');\n  const importable = await importer.askForResourceIdentifiers(additions);\n\n  // THEN\n  expect(importable.resourceMap).toEqual({\n    MyQueue: {\n      QueueName: 'TheQueueName',\n    },\n  });\n  expect(importable.importResources).toEqual([\n    expect.objectContaining({\n      logicalId: 'MyQueue',\n    }),\n  ]);\n});","file":"import.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"asks human to confirm automic import if identifier is in template","suites":[],"updatePoint":{"line":131,"column":71},"line":131,"code":"test('asks human to confirm automic import if identifier is in template', async () => {\n  // GIVEN\n  givenCurrentStack(STACK_WITH_NAMED_QUEUE.stackName, { Resources: {} });\n  const importer = new ResourceImporter(STACK_WITH_NAMED_QUEUE, deployments);\n  const { additions } = await importer.discoverImportableResources();\n\n  // WHEN\n  promptlyConfirm.mockResolvedValue(true);\n  const importable = await importer.askForResourceIdentifiers(additions);\n\n  // THEN\n  expect(importable.resourceMap).toEqual({\n    MyQueue: {\n      QueueName: 'TheQueueName',\n    },\n  });\n  expect(importable.importResources).toEqual([\n    expect.objectContaining({\n      logicalId: 'MyQueue',\n    }),\n  ]);\n});","file":"import.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"asks human to confirm automic import if identifier is in template","suites":[],"updatePoint":{"line":154,"column":71},"line":154,"code":"test('asks human to confirm automic import if identifier is in template', async () => {\n  // GIVEN\n  givenCurrentStack(STACK_WITH_QUEUE.stackName, { Resources: {} });\n  const importer = new ResourceImporter(STACK_WITH_QUEUE, deployments);\n  const { additions } = await importer.discoverImportableResources();\n  const importMap: ImportMap = {\n    importResources: additions,\n    resourceMap: {\n      MyQueue: { QueueName: 'TheQueueName' },\n    },\n  };\n\n  // WHEN\n  await importer.importResources(importMap, {\n    stack: STACK_WITH_QUEUE,\n  });\n\n  expect(createChangeSetInput?.ResourcesToImport).toEqual([\n    {\n      LogicalResourceId: 'MyQueue',\n      ResourceIdentifier: { QueueName: 'TheQueueName' },\n      ResourceType: 'AWS::SQS::Queue',\n    },\n  ]);\n});","file":"import.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"only use one identifier if multiple are in template","suites":[],"updatePoint":{"line":180,"column":57},"line":180,"code":"test('only use one identifier if multiple are in template', async () => {\n  // GIVEN\n  const stack = stackWithGlobalTable({\n    TableName: 'TheTableName',\n    TableArn: 'ThisFieldDoesntExistInReality',\n    TableStreamArn: 'NorDoesThisOne',\n  });\n\n  // WHEN\n  promptlyConfirm.mockResolvedValue(true); // Confirm yes/no\n  await importTemplateFromClean(stack);\n\n  // THEN\n  expect(createChangeSetInput?.ResourcesToImport).toEqual([\n    {\n      LogicalResourceId: 'MyTable',\n      ResourceIdentifier: { TableName: 'TheTableName' },\n      ResourceType: 'AWS::DynamoDB::GlobalTable',\n    },\n  ]);\n});","file":"import.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"only ask user for one identifier if multiple possible ones are possible","suites":[],"updatePoint":{"line":202,"column":77},"line":202,"code":"test('only ask user for one identifier if multiple possible ones are possible', async () => {\n  // GIVEN -- no identifiers in template, so ask user\n  const stack = stackWithGlobalTable({});\n\n  // WHEN\n  promptlyPrompt.mockResolvedValue('Banana');\n  const importable = await importTemplateFromClean(stack);\n\n  // THEN -- only asked once\n  expect(promptlyPrompt).toHaveBeenCalledTimes(1);\n  expect(importable.resourceMap).toEqual({\n    MyTable: { TableName: 'Banana' },\n  });\n});","file":"import.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"ask identifier if the value in the template is a CFN intrinsic","suites":[],"updatePoint":{"line":217,"column":68},"line":217,"code":"test('ask identifier if the value in the template is a CFN intrinsic', async () => {\n  // GIVEN -- identifier in template is a CFN intrinsic so it doesn't count\n  const stack = stackWithQueue({\n    QueueName: { Ref: 'SomeParam' },\n  });\n\n  // WHEN\n  promptlyPrompt.mockResolvedValue('Banana');\n  const importable = await importTemplateFromClean(stack);\n\n  // THEN\n  expect(importable.resourceMap).toEqual({\n    MyQueue: { QueueName: 'Banana' },\n  });\n});","file":"import.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"take compound identifiers from the template if found","suites":[],"updatePoint":{"line":233,"column":58},"line":233,"code":"test('take compound identifiers from the template if found', async () => {\n  // GIVEN\n  const stack = stackWithKeySigningKey({\n    HostedZoneId: 'z-123',\n    Name: 'KeyName',\n  });\n\n  // WHEN\n  promptlyConfirm.mockResolvedValue(true);\n  await importTemplateFromClean(stack);\n\n  // THEN\n  expect(createChangeSetInput?.ResourcesToImport).toEqual([\n    {\n      LogicalResourceId: 'MyKSK',\n      ResourceIdentifier: { HostedZoneId: 'z-123', Name: 'KeyName' },\n      ResourceType: 'AWS::Route53::KeySigningKey',\n    },\n  ]);\n});","file":"import.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"ask user for compound identifiers if not found","suites":[],"updatePoint":{"line":254,"column":52},"line":254,"code":"test('ask user for compound identifiers if not found', async () => {\n  // GIVEN\n  const stack = stackWithKeySigningKey({});\n\n  // WHEN\n  promptlyPrompt.mockReturnValue('Banana');\n  await importTemplateFromClean(stack);\n\n  // THEN\n  expect(createChangeSetInput?.ResourcesToImport).toEqual([\n    {\n      LogicalResourceId: 'MyKSK',\n      ResourceIdentifier: { HostedZoneId: 'Banana', Name: 'Banana' },\n      ResourceType: 'AWS::Route53::KeySigningKey',\n    },\n  ]);\n});","file":"import.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do not ask for second part of compound identifier if the user skips the first","suites":[],"updatePoint":{"line":272,"column":83},"line":272,"code":"test('do not ask for second part of compound identifier if the user skips the first', async () => {\n  // GIVEN\n  const stack = stackWithKeySigningKey({});\n\n  // WHEN\n  promptlyPrompt.mockReturnValue('');\n  const importMap = await importTemplateFromClean(stack);\n\n  // THEN\n  expect(importMap.resourceMap).toEqual({});\n});","file":"import.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"verify \"future flags\" are added to cdk.json","suites":["constructs version"],"updatePoint":{"line":141,"column":51},"line":141,"code":"  test('verify \"future flags\" are added to cdk.json', async () => {\n\n    for (const templ of await availableInitTemplates()) {\n      for (const lang of templ.languages) {\n        await withTempDir(async tmpDir => {\n          await cliInit(templ.name, lang,\n            /* canUseNetwork */ false,\n            /* generateOnly */ true,\n            tmpDir);\n\n          // ok if template doesn't have a cdk.json file (e.g. the \"lib\" template)\n          if (!await fs.pathExists(path.join(tmpDir, 'cdk.json'))) {\n            return;\n          }\n\n          const config = await fs.readJson(path.join(tmpDir, 'cdk.json'));\n          const context = config.context || {};\n          for (const [key, actual] of Object.entries(context)) {\n            expect(key in cxapi.NEW_PROJECT_CONTEXT).toBeTruthy();\n            expect(cxapi.NEW_PROJECT_CONTEXT[key]).toEqual(actual);\n          }\n\n          // assert that expired future flags are not part of the cdk.json\n          Object.keys(context).forEach(k => {\n            expect(cxapi.CURRENT_VERSION_EXPIRED_FLAGS.includes(k)).toEqual(false);\n          });\n        });\n      }\n    }\n  },\n  // This is a lot to test, and it can be slow-ish, especially when ran with other tests.\n  30_000);","file":"init.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"when no version number is present (e.g., local development), the v2 templates are chosen by default","suites":["constructs version"],"updatePoint":{"line":175,"column":105},"line":175,"code":"test('when no version number is present (e.g., local development), the v2 templates are chosen by default', async () => {\n  expect((await availableInitTemplates()).length).toBeGreaterThan(0);\n});","file":"init.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"correct format","suites":["cli notices"],"updatePoint":{"line":96,"column":24},"line":96,"code":"    test('correct format', () => {\n      const result = formatNotices([BASIC_NOTICE])[0];\n      expect(result).toEqual(`16603\tToggling off auto_delete_objects for Bucket empties the bucket\n\n\tOverview: If a stack is deployed with an S3 bucket with\n\t          auto_delete_objects=True, and then re-deployed with\n\t          auto_delete_objects=False, all the objects in the bucket\n\t          will be deleted.\n\n\tAffected versions: cli: <=1.126.0\n\n\tMore information at: https://github.com/aws/aws-cdk/issues/16603\n`);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"multiple affect versions","suites":["cli notices"],"updatePoint":{"line":111,"column":34},"line":111,"code":"    test('multiple affect versions', () => {\n      const result = formatNotices([MULTIPLE_AFFECTED_VERSIONS_NOTICE])[0];\n      expect(result).toEqual(`17061\tError when building EKS cluster with monocdk import\n\n\tOverview: When using monocdk/aws-eks to build a stack containing an\n\t          EKS cluster, error is thrown about missing\n\t          lambda-layer-node-proxy-agent/layer/package.json.\n\n\tAffected versions: cli: <1.130.0 >=1.126.0\n\n\tMore information at: https://github.com/aws/aws-cdk/issues/17061\n`);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"correctly filter notices on cli","suites":["cli notices"],"updatePoint":{"line":127,"column":41},"line":127,"code":"    test('correctly filter notices on cli', () => {\n      const notices = [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE];\n      expect(filterNotices(notices, {\n        cliVersion: '1.0.0',\n      })).toEqual([BASIC_NOTICE]);\n\n      expect(filterNotices(notices, {\n        cliVersion: '1.129.0',\n      })).toEqual([MULTIPLE_AFFECTED_VERSIONS_NOTICE]);\n\n      expect(filterNotices(notices, {\n        cliVersion: '1.126.0',\n      })).toEqual(notices);\n\n      expect(filterNotices(notices, {\n        cliVersion: '1.130.0',\n      })).toEqual([]);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"correctly filter notices on framework","suites":["cli notices"],"updatePoint":{"line":146,"column":47},"line":146,"code":"    test('correctly filter notices on framework', () => {\n      const notices = [FRAMEWORK_2_1_0_AFFECTED_NOTICE];\n\n      expect(filterNotices(notices, {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/built-with-2_12_0'),\n      })).toEqual([]);\n\n      expect(filterNotices(notices, {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/built-with-1_144_0'),\n      })).toEqual([FRAMEWORK_2_1_0_AFFECTED_NOTICE]);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"correctly filter notices on arbitrary modules","suites":["cli notices"],"updatePoint":{"line":158,"column":55},"line":158,"code":"    test('correctly filter notices on arbitrary modules', () => {\n      const notices = [NOTICE_FOR_APIGATEWAYV2];\n\n      // module-level match\n      expect(filterNotices(notices, {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/experimental-module'),\n      })).toEqual([NOTICE_FOR_APIGATEWAYV2]);\n\n      // no apigatewayv2 in the tree\n      expect(filterNotices(notices, {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/built-with-2_12_0'),\n      })).toEqual([]);\n\n      // module name mismatch: apigateway != apigatewayv2\n      expect(filterNotices([NOTICE_FOR_APIGATEWAY], {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/experimental-module'),\n      })).toEqual([]);\n\n      // construct-level match\n      expect(filterNotices([NOTICE_FOR_APIGATEWAYV2_CFN_STAGE], {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/experimental-module'),\n      })).toEqual([NOTICE_FOR_APIGATEWAYV2_CFN_STAGE]);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns data when download succeeds","suites":["cli notices"],"updatePoint":{"line":187,"column":45},"line":187,"code":"    test('returns data when download succeeds', async () => {\n      const result = await mockCall(200, {\n        notices: [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE],\n      });\n\n      expect(result).toEqual([BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE]);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns appropriate error when the server returns an unexpected status code","suites":["cli notices"],"updatePoint":{"line":195,"column":85},"line":195,"code":"    test('returns appropriate error when the server returns an unexpected status code', async () => {\n      const result = mockCall(500, {\n        notices: [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE],\n      });\n\n      await expect(result).rejects.toThrow(/500/);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns appropriate error when the server returns an unexpected structure","suites":["cli notices"],"updatePoint":{"line":203,"column":83},"line":203,"code":"    test('returns appropriate error when the server returns an unexpected structure', async () => {\n      const result = mockCall(200, {\n        foo: [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE],\n      });\n\n      await expect(result).rejects.toThrow(/key is missing/);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns appropriate error when the server returns invalid json","suites":["cli notices"],"updatePoint":{"line":211,"column":72},"line":211,"code":"    test('returns appropriate error when the server returns invalid json', async () => {\n      const result = mockCall(200, '-09aiskjkj838');\n\n      await expect(result).rejects.toThrow(/Failed to parse/);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns appropriate error when HTTPS call throws","suites":["cli notices"],"updatePoint":{"line":217,"column":58},"line":217,"code":"    test('returns appropriate error when HTTPS call throws', async () => {\n      const mockGet = jest.spyOn(https, 'get')\n        .mockImplementation(() => { throw new Error('No connection'); });\n\n      const result = dataSource.fetch();\n\n      await expect(result).rejects.toThrow(/No connection/);\n\n      mockGet.mockRestore();\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns appropriate error when the request has an error","suites":["cli notices"],"updatePoint":{"line":228,"column":65},"line":228,"code":"    test('returns appropriate error when the request has an error', async () => {\n      nock('https://cli.cdk.dev-tools.aws.dev')\n        .get('/notices.json')\n        .replyWithError('DNS resolution failed');\n\n      const result = dataSource.fetch();\n\n      await expect(result).rejects.toThrow(/DNS resolution failed/);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns appropriate error when the connection stays idle for too long","suites":["cli notices"],"updatePoint":{"line":238,"column":79},"line":238,"code":"    test('returns appropriate error when the connection stays idle for too long', async () => {\n      nock('https://cli.cdk.dev-tools.aws.dev')\n        .get('/notices.json')\n        .delayConnection(3500)\n        .reply(200, {\n          notices: [BASIC_NOTICE],\n        });\n\n      const result = dataSource.fetch();\n\n      await expect(result).rejects.toThrow(/timed out/);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"returns empty array when the request takes too long to finish","suites":["cli notices"],"updatePoint":{"line":251,"column":71},"line":251,"code":"    test('returns empty array when the request takes too long to finish', async () => {\n      nock('https://cli.cdk.dev-tools.aws.dev')\n        .get('/notices.json')\n        .delayBody(3500)\n        .reply(200, {\n          notices: [BASIC_NOTICE],\n        });\n\n      const result = dataSource.fetch();\n\n      await expect(result).rejects.toThrow(/timed out/);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"retrieves data from the delegate cache when the file is empty","suites":["cli notices"],"updatePoint":{"line":282,"column":71},"line":282,"code":"    test('retrieves data from the delegate cache when the file is empty', async () => {\n      const dataSource = dataSourceWithDelegateReturning(freshData);\n\n      const notices = await dataSource.fetch();\n\n      expect(notices).toEqual(freshData);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"retrieves data from the file when the data is still valid","suites":["cli notices"],"updatePoint":{"line":290,"column":67},"line":290,"code":"    test('retrieves data from the file when the data is still valid', async () => {\n      fs.writeJsonSync(fileName, {\n        notices: cachedData,\n        expiration: Date.now() + 10000,\n      });\n      const dataSource = dataSourceWithDelegateReturning(freshData);\n\n      const notices = await dataSource.fetch();\n\n      expect(notices).toEqual(cachedData);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"retrieves data from the delegate when the data is expired","suites":["cli notices"],"updatePoint":{"line":302,"column":67},"line":302,"code":"    test('retrieves data from the delegate when the data is expired', async () => {\n      fs.writeJsonSync(fileName, {\n        notices: cachedData,\n        expiration: 0,\n      });\n      const dataSource = dataSourceWithDelegateReturning(freshData);\n\n      const notices = await dataSource.fetch();\n\n      expect(notices).toEqual(freshData);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"retrieves data from the delegate when the file cannot be read","suites":["cli notices"],"updatePoint":{"line":314,"column":71},"line":314,"code":"    test('retrieves data from the delegate when the file cannot be read', async () => {\n      const debugSpy = jest.spyOn(logging, 'debug');\n\n      if (fs.existsSync('does-not-exist.json')) {\n        fs.unlinkSync('does-not-exist.json');\n      }\n\n      const dataSource = dataSourceWithDelegateReturning(freshData, 'does-not-exist.json');\n\n      const notices = await dataSource.fetch();\n\n      expect(notices).toEqual(freshData);\n      expect(debugSpy).not.toHaveBeenCalled();\n\n      debugSpy.mockRestore();\n\n      if (fs.existsSync('does-not-exist.json')) {\n        fs.unlinkSync('does-not-exist.json');\n      }\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"retrieved data from the delegate when it is configured to ignore the cache","suites":["cli notices"],"updatePoint":{"line":335,"column":84},"line":335,"code":"    test('retrieved data from the delegate when it is configured to ignore the cache', async () => {\n      fs.writeJsonSync(fileName, {\n        notices: cachedData,\n        expiration: Date.now() + 10000,\n      });\n      const dataSource = dataSourceWithDelegateReturning(freshData, fileName, true);\n\n      const notices = await dataSource.fetch();\n\n      expect(notices).toEqual(freshData);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"error in delegate gets turned into empty result by cached source","suites":["cli notices"],"updatePoint":{"line":347,"column":74},"line":347,"code":"    test('error in delegate gets turned into empty result by cached source', async () => {\n      // GIVEN\n      const delegate = {\n        fetch: jest.fn().mockRejectedValue(new Error('fetching failed')),\n      };\n      const dataSource = new CachedDataSource(fileName, delegate, true);\n\n      // WHEN\n      const notices = await dataSource.fetch();\n\n      // THEN\n      expect(notices).toEqual([]);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not show anything when there are no notices","suites":["cli notices"],"updatePoint":{"line":372,"column":58},"line":372,"code":"    test('does not show anything when there are no notices', async () => {\n      const dataSource = createDataSource();\n      dataSource.fetch.mockResolvedValue([]);\n\n      const result = await generateMessage(dataSource, {\n        acknowledgedIssueNumbers: [],\n        outdir: '/tmp',\n      });\n\n      expect(result).toEqual('');\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"shows notices that pass the filter","suites":["cli notices"],"updatePoint":{"line":384,"column":44},"line":384,"code":"    test('shows notices that pass the filter', async () => {\n      const dataSource = createDataSource();\n      dataSource.fetch.mockResolvedValue([BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE]);\n\n      const result = await generateMessage(dataSource, {\n        acknowledgedIssueNumbers: [17061],\n        outdir: '/tmp',\n      });\n\n      expect(result).toEqual(`\nNOTICES         (What's this? https://github.com/aws/aws-cdk/wiki/CLI-Notices)\n\n16603\tToggling off auto_delete_objects for Bucket empties the bucket\n\n\tOverview: If a stack is deployed with an S3 bucket with\n\t          auto_delete_objects=True, and then re-deployed with\n\t          auto_delete_objects=False, all the objects in the bucket\n\t          will be deleted.\n\n\tAffected versions: cli: <=1.126.0\n\n\tMore information at: https://github.com/aws/aws-cdk/issues/16603\n\n\nIf you dont want to see a notice anymore, use \"cdk acknowledge <id>\". For example, \"cdk acknowledge 16603\".`);\n    });","file":"notices.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"%p is in range: %p","suites":[],"line":4,"code":"test.each([\n  ['2.1', false],\n  ['2.2', true],\n  ['2', false],\n  ['3', true],\n  ['4', false],\n  ['4.3', true],\n  ['4.3', true],\n  ['4.2.294-220.533.amzn2.x86_64', true],\n])('%p is in range: %p', (version, expected) => {\n  expect(isVersionBetween(version, '2.1.0.6', '4.9.2')).toEqual(expected);\n});","file":"platform-warnings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"writer lock excludes other locks","suites":[],"updatePoint":{"line":10,"column":38},"line":10,"code":"test('writer lock excludes other locks', async () => {\n  // GIVEN\n  const lock = new RWLock(testDir());\n  const w = await lock.acquireWrite();\n\n  // WHEN\n  try {\n    await expect(lock.acquireWrite()).rejects.toThrow(/currently synthing/);\n    await expect(lock.acquireRead()).rejects.toThrow(/currently synthing/);\n  } finally {\n    await w.release();\n  }\n});","file":"rwlock.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"reader lock allows other readers but not writers","suites":[],"updatePoint":{"line":24,"column":54},"line":24,"code":"test('reader lock allows other readers but not writers', async () => {\n  // GIVEN\n  const lock = new RWLock(testDir());\n  const r = await lock.acquireRead();\n\n  // WHEN\n  try {\n    await expect(lock.acquireWrite()).rejects.toThrow(/currently reading/);\n\n    const r2 = await lock.acquireRead();\n    await r2.release();\n  } finally {\n    await r.release();\n  }\n});","file":"rwlock.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can convert writer to reader lock","suites":[],"updatePoint":{"line":40,"column":39},"line":40,"code":"test('can convert writer to reader lock', async () => {\n  // GIVEN\n  const lock = new RWLock(testDir());\n  const w = await lock.acquireWrite();\n\n  // WHEN\n  const r = await w.convertToReaderLock();\n  try {\n    const r2 = await lock.acquireRead();\n    await r2.release();\n  } finally {\n    await r.release();\n  }\n});","file":"rwlock.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"does not wrap lines","suites":[],"updatePoint":{"line":5,"column":27},"line":5,"code":"  test('does not wrap lines', () => {\n    const longString = 'Long string is long!'.repeat(1_024);\n    expect(toYAML({ longString })).toEqual(`longString: ${longString}\\n`);\n  });","file":"serialize.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can delete values from Context object","suites":[],"updatePoint":{"line":4,"column":43},"line":4,"code":"test('can delete values from Context object', () => {\n  // GIVEN\n  const settings1 = new Settings({ foo: 'bar' });\n  const settings2 = new Settings({ boo: 'baz' });\n  const context = new Context(settings1, settings2);\n\n  // WHEN\n  context.unset('foo');\n\n  // THEN\n  expect(context.all).toEqual({ boo: 'baz' });\n  expect(settings1.all).toEqual({});\n  expect(settings2.all).toEqual({ boo: 'baz' });\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can set values in Context object","suites":[],"updatePoint":{"line":19,"column":38},"line":19,"code":"test('can set values in Context object', () => {\n  // GIVEN\n  const settings1 = new Settings();\n  const settings2 = new Settings();\n  const context = new Context(settings1, settings2);\n\n  // WHEN\n  context.set('foo', 'bar');\n\n  // THEN\n  expect(context.all).toEqual({ foo: 'bar' });\n  expect(settings1.all).toEqual({ foo: 'bar' });\n  expect(settings2.all).toEqual({});\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can set values in Context object if first is immutable","suites":[],"updatePoint":{"line":34,"column":60},"line":34,"code":"test('can set values in Context object if first is immutable', () => {\n  // GIVEN\n  const settings1 = new Settings();\n  const settings2 = new Settings();\n  const context = new Context(settings1.makeReadOnly(), settings2);\n\n  // WHEN\n  context.set('foo', 'bar');\n\n  // THEN\n  expect(context.all).toEqual({ foo: 'bar' });\n  expect(settings1.all).toEqual({ });\n  expect(settings2.all).toEqual({ foo: 'bar' });\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can clear all values in all objects","suites":[],"updatePoint":{"line":49,"column":41},"line":49,"code":"test('can clear all values in all objects', () => {\n  // GIVEN\n  const settings1 = new Settings({ foo: 'bar' });\n  const settings2 = new Settings({ foo: 'snar', boo: 'gar' });\n  const context = new Context(settings1, settings2);\n\n  // WHEN\n  context.clear();\n\n  // THEN\n  expect(context.all).toEqual({});\n  expect(settings1.all).toEqual({ });\n  expect(settings2.all).toEqual({});\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can parse string context from command line arguments","suites":[],"updatePoint":{"line":64,"column":58},"line":64,"code":"test('can parse string context from command line arguments', () => {\n  // GIVEN\n  const settings1 = Settings.fromCommandLineArguments({ context: ['foo=bar'], _: [Command.DEPLOY] });\n  const settings2 = Settings.fromCommandLineArguments({ context: ['foo='], _: [Command.DEPLOY] });\n\n  // THEN\n  expect(settings1.get(['context']).foo).toEqual( 'bar');\n  expect(settings2.get(['context']).foo).toEqual( '');\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can parse string context from command line arguments with equals sign in value","suites":[],"updatePoint":{"line":74,"column":84},"line":74,"code":"test('can parse string context from command line arguments with equals sign in value', () => {\n  // GIVEN\n  const settings1 = Settings.fromCommandLineArguments({ context: ['foo==bar='], _: [Command.DEPLOY] });\n  const settings2 = Settings.fromCommandLineArguments({ context: ['foo=bar='], _: [Command.DEPLOY] });\n\n  // THEN\n  expect(settings1.get(['context']).foo).toEqual( '=bar=');\n  expect(settings2.get(['context']).foo).toEqual( 'bar=');\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"bundling stacks defaults to an empty list","suites":[],"updatePoint":{"line":84,"column":47},"line":84,"code":"test('bundling stacks defaults to an empty list', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.LIST],\n  });\n\n  // THEN\n  expect(settings.get(['bundlingStacks'])).toEqual([]);\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"bundling stacks defaults to ** for deploy","suites":[],"updatePoint":{"line":94,"column":47},"line":94,"code":"test('bundling stacks defaults to ** for deploy', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.DEPLOY],\n  });\n\n  // THEN\n  expect(settings.get(['bundlingStacks'])).toEqual(['**']);\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"bundling stacks defaults to ** for watch","suites":[],"updatePoint":{"line":104,"column":46},"line":104,"code":"test('bundling stacks defaults to ** for watch', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.WATCH],\n  });\n\n  // THEN\n  expect(settings.get(['bundlingStacks'])).toEqual(['**']);\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"bundling stacks with deploy exclusively","suites":[],"updatePoint":{"line":114,"column":45},"line":114,"code":"test('bundling stacks with deploy exclusively', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.DEPLOY],\n    exclusively: true,\n    STACKS: ['cool-stack'],\n  });\n\n  // THEN\n  expect(settings.get(['bundlingStacks'])).toEqual(['cool-stack']);\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"bundling stacks with watch exclusively","suites":[],"updatePoint":{"line":126,"column":44},"line":126,"code":"test('bundling stacks with watch exclusively', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.WATCH],\n    exclusively: true,\n    STACKS: ['cool-stack'],\n  });\n\n  // THEN\n  expect(settings.get(['bundlingStacks'])).toEqual(['cool-stack']);\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"should include outputs-file in settings","suites":[],"updatePoint":{"line":138,"column":45},"line":138,"code":"test('should include outputs-file in settings', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.DEPLOY],\n    outputsFile: 'my-outputs-file.json',\n  });\n\n  // THEN\n  expect(settings.get(['outputsFile'])).toEqual('my-outputs-file.json');\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"providing a build arg","suites":[],"updatePoint":{"line":149,"column":27},"line":149,"code":"test('providing a build arg', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.SYNTH],\n    build: 'mvn package',\n  });\n\n  // THEN\n  expect(settings.get(['build'])).toEqual('mvn package');\n});","file":"settings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"tree matches predicate","suites":["some"],"updatePoint":{"line":83,"column":30},"line":83,"code":"  test('tree matches predicate', () => {\n    expect(some(tree, node => node.constructInfo?.fqn === '@aws-cdk/aws-s3.Bucket')).toBe(true);\n  });","file":"tree.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"tree does not match predicate","suites":["some"],"updatePoint":{"line":87,"column":37},"line":87,"code":"  test('tree does not match predicate', () => {\n    expect(some(tree, node => node.constructInfo?.fqn === '@aws-cdk/aws-lambda.Function')).toBe(false);\n  });","file":"tree.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"childless tree","suites":["some"],"updatePoint":{"line":91,"column":22},"line":91,"code":"  test('childless tree', () => {\n    const childless = {\n      id: 'App',\n      path: '',\n      constructInfo: {\n        fqn: 'aws-cdk-lib.App',\n        version: '1.162.0',\n      },\n    };\n\n    expect(some(childless, node => node.path.length > 0)).toBe(false);\n  });","file":"tree.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can find tree","suites":["loadTreeFromDir"],"updatePoint":{"line":106,"column":21},"line":106,"code":"  test('can find tree', () => {\n    const tree = loadTreeFromDir(path.join(__dirname, 'cloud-assembly-trees/built-with-1_144_0'));\n    expect(tree.id).toEqual('App');\n  });","file":"tree.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"cannot find tree","suites":["loadTreeFromDir"],"updatePoint":{"line":111,"column":24},"line":111,"code":"  test('cannot find tree', () => {\n    const tree = loadTreeFromDir(path.join(__dirname, 'cloud-assembly-trees/foo'));\n    expect(tree).toEqual({});\n  });","file":"tree.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"load settings from both files if available","suites":[],"updatePoint":{"line":13,"column":48},"line":13,"code":"test('load settings from both files if available', async () => {\n  // GIVEN\n  const GIVEN_CONFIG: Map<string, any> = new Map([\n    [PROJECT_CONFIG, {\n      project: 'foobar',\n    }],\n    [USER_CONFIG, {\n      project: 'foo',\n      test: 'bar',\n    }],\n  ]);\n\n  // WHEN\n  mockedFs.pathExists.mockImplementation(path => {\n    return GIVEN_CONFIG.has(path);\n  });\n  mockedFs.readJSON.mockImplementation(path => {\n    return GIVEN_CONFIG.get(path);\n  });\n\n  const config = await new Configuration().load();\n\n  // THEN\n  expect(config.settings.get(['project'])).toBe('foobar');\n  expect(config.settings.get(['test'])).toBe('bar');\n});","file":"usersettings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"load context from all 3 files if available","suites":[],"updatePoint":{"line":40,"column":48},"line":40,"code":"test('load context from all 3 files if available', async () => {\n  // GIVEN\n  const GIVEN_CONFIG: Map<string, any> = new Map([\n    [PROJECT_CONFIG, {\n      context: {\n        project: 'foobar',\n      },\n    }],\n    [PROJECT_CONTEXT, {\n      foo: 'bar',\n    }],\n    [USER_CONFIG, {\n      context: {\n        test: 'bar',\n      },\n    }],\n  ]);\n\n  // WHEN\n  mockedFs.pathExists.mockImplementation(path => {\n    return GIVEN_CONFIG.has(path);\n  });\n  mockedFs.readJSON.mockImplementation(path => {\n    return GIVEN_CONFIG.get(path);\n  });\n\n  const config = await new Configuration().load();\n\n  // THEN\n  expect(config.context.get('project')).toBe('foobar');\n  expect(config.context.get('foo')).toBe('bar');\n  expect(config.context.get('test')).toBe('bar');\n});","file":"usersettings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"throws an error if the `build` key is specified in the user config","suites":[],"updatePoint":{"line":74,"column":72},"line":74,"code":"test('throws an error if the `build` key is specified in the user config', async () => {\n  // GIVEN\n  const GIVEN_CONFIG: Map<string, any> = new Map([\n    [USER_CONFIG, {\n      build: 'foobar',\n    }],\n  ]);\n\n  // WHEN\n  mockedFs.pathExists.mockImplementation(path => {\n    return GIVEN_CONFIG.has(path);\n  });\n  mockedFs.readJSON.mockImplementation(path => {\n    return GIVEN_CONFIG.get(path);\n  });\n\n  // THEN\n  await expect(new Configuration().load()).rejects.toEqual(new Error('The `build` key cannot be specified in the user config (~/.cdk.json), specify it in the project config (cdk.json) instead'));\n});","file":"usersettings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Can specify the `quiet` key in the user config","suites":[],"updatePoint":{"line":94,"column":52},"line":94,"code":"test('Can specify the `quiet` key in the user config', async () => {\n  // GIVEN\n  const GIVEN_CONFIG: Map<string, any> = new Map([\n    [USER_CONFIG, {\n      quiet: true,\n    }],\n  ]);\n\n  // WHEN\n  mockedFs.pathExists.mockImplementation(path => {\n    return GIVEN_CONFIG.has(path);\n  });\n  mockedFs.readJSON.mockImplementation(path => {\n    return GIVEN_CONFIG.get(path);\n  });\n\n  // THEN\n  const config = await new Configuration().load();\n\n  expect(config.settings.get(['quiet'])).toBe(true);\n});","file":"usersettings.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"applyDefaults() works","suites":[],"updatePoint":{"line":4,"column":27},"line":4,"code":"test('applyDefaults() works', () => {\n  const given = { a: 1 };\n  const defaults = { a: 2, b: 2 };\n\n  const output = applyDefaults(given, defaults);\n\n  expect(output).toEqual({ a: 1, b: 2 });\n});","file":"util/applydefaults.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"flatten combines arrays","suites":[],"updatePoint":{"line":4,"column":29},"line":4,"code":"test('flatten combines arrays', () => {\n  const output = flatten([\n    ['a', 'b'],\n    [],\n    ['c'],\n  ]);\n\n  expect(output).toEqual(['a', 'b', 'c']);\n});","file":"util/arrays.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"flatMap maps and combines","suites":[],"updatePoint":{"line":14,"column":31},"line":14,"code":"test('flatMap maps and combines', () => {\n  const input = ['A', 'B', 'C'];\n  const output = flatMap(input, x => [x.toLowerCase()]);\n\n  expect(output).toEqual(['a', 'b', 'c']);\n});","file":"util/arrays.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"partition splits the collection in twain","suites":[],"updatePoint":{"line":21,"column":46},"line":21,"code":"test('partition splits the collection in twain', () => {\n  const xs = [1, 2, 3, 4, 5];\n  const evens = partition(xs, x => x % 2 === 0);\n\n  expect(evens).toEqual([2, 4]);\n  expect(xs).toEqual([1, 3, 5]);\n});","file":"util/arrays.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"on an EC2 instance, region lookup queries IMDS","suites":[],"updatePoint":{"line":18,"column":52},"line":18,"code":"test('on an EC2 instance, region lookup queries IMDS', async () => {\n  return withMockedClassSingleton(AWS, 'MetadataService', async (mdService) => {\n    mdService.request\n      // First call for a token\n      .mockImplementationOnce((_1, _2, cb) => { cb(undefined as any, 'token'); })\n      // Second call for the region\n      .mockImplementationOnce((_1, _2, cb) => { cb(undefined as any, JSON.stringify({ region: 'some-region' })); });\n\n    const region = await AwsCliCompatible.region({ ec2instance: true });\n    expect(region).toEqual('some-region');\n  });\n});","file":"util/awscli-compatible.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Use web identity when available","suites":[],"updatePoint":{"line":31,"column":37},"line":31,"code":"test('Use web identity when available', async () => {\n\n  // Scrub some environment variables that are maybe set for Ecs Credentials\n  delete process.env.ECS_CONTAINER_METADATA_URI_V4;\n  delete process.env.ECS_CONTAINER_METADATA_URI;\n  delete process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI;\n\n  // create and configure the web identity token file\n  process.env.AWS_WEB_IDENTITY_TOKEN_FILE = 'some-value';\n  process.env.AWS_ROLE_ARN = 'some-value';\n\n  // create the chain\n  const providers = (await AwsCliCompatible.credentialChain()).providers;\n\n  // make sure the web identity provider is in the chain\n  const webIdentify = (providers[5] as Function)();\n  expect(webIdentify).toBeInstanceOf(AWS.TokenFileWebIdentityCredentials);\n});","file":"util/awscli-compatible.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"A non-existent stack pretends to have an empty template","suites":[],"updatePoint":{"line":31,"column":61},"line":31,"code":"test('A non-existent stack pretends to have an empty template', async () => {\n  // GIVEN\n  describeStackMock.mockImplementation(() => ({ Stacks: [] })); // No stacks exist\n\n  // WHEN\n  const stack = await CloudFormationStack.lookup(cfn, 'Dummy');\n\n  // THEN\n  expect(await stack.template()).toEqual({});\n});","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Retrieving a processed template passes 'Processed' to CloudFormation","suites":[],"updatePoint":{"line":42,"column":74},"line":42,"code":"test(\"Retrieving a processed template passes 'Processed' to CloudFormation\", async () => {\n  // GIVEN\n  describeStackMock.mockImplementation(() => ({\n    Stacks: [\n      {\n        StackName: 'Dummy',\n      },\n    ],\n  }));\n  getTemplateMock.mockImplementation(() => ({\n    TemplateBody: '{}',\n  }));\n\n  // WHEN\n  const retrieveProcessedTemplate = true;\n  const cloudFormationStack = await CloudFormationStack.lookup(cfn, 'Dummy', retrieveProcessedTemplate);\n  await cloudFormationStack.template();\n\n  // THEN\n  expect(getTemplateMock).toHaveBeenCalledWith({\n    StackName: 'Dummy',\n    TemplateStage: 'Processed',\n  });\n});","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"given override, always use the override (parameter has a default: %p, parameter previously supplied: %p)","suites":[],"line":67,"code":"test.each([\n  [false, false],\n  [false, true],\n  [true, false],\n  [true, true],\n])('given override, always use the override (parameter has a default: %p, parameter previously supplied: %p)',\n  (haveDefault, havePrevious) => {\n    expect(makeParams(haveDefault, havePrevious, true)).toEqual({\n      apiParameters: [USE_OVERRIDE],\n      changed: true,\n    });\n  });","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"no default, no prev, no override => error","suites":[],"updatePoint":{"line":80,"column":47},"line":80,"code":"test('no default, no prev, no override => error', () => {\n  expect(() => makeParams(false, false, false)).toThrow(/missing a value: TheParameter/);\n});","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"no default, yes prev, no override => use previous","suites":[],"updatePoint":{"line":84,"column":55},"line":84,"code":"test('no default, yes prev, no override => use previous', () => {\n  expect(makeParams(false, true, false)).toEqual({\n    apiParameters: [USE_PREVIOUS],\n    changed: false,\n  });\n});","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"default, no prev, no override => empty param set (and obviously changes to be applied)","suites":[],"updatePoint":{"line":91,"column":92},"line":91,"code":"test('default, no prev, no override => empty param set (and obviously changes to be applied)', () => {\n  expect(makeParams(true, false, false)).toEqual({\n    apiParameters: [],\n    changed: true,\n  });\n});","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"default, prev, no override => use previous","suites":[],"updatePoint":{"line":98,"column":48},"line":98,"code":"test('default, prev, no override => use previous', () => {\n  expect(makeParams(true, true, false)).toEqual({\n    apiParameters: [USE_PREVIOUS],\n    changed: false,\n  });\n});","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"if a parameter is retrieved from SSM, the parameters always count as changed","suites":[],"updatePoint":{"line":105,"column":82},"line":105,"code":"test('if a parameter is retrieved from SSM, the parameters always count as changed', () => {\n  const params = TemplateParameters.fromTemplate({\n    Parameters: {\n      Foo: {\n        Type: 'AWS::SSM::Parameter::Name',\n        Default: '/Some/Key',\n      },\n    },\n  });\n  const oldValues = { Foo: '/Some/Key' };\n\n  // If we don't pass a new value\n  expect(params.updateExisting({}, oldValues).hasChanges(oldValues)).toEqual('ssm');\n\n  // If we do pass a new value but it's the same as the old one\n  expect(params.updateExisting({ Foo: '/Some/Key' }, oldValues).hasChanges(oldValues)).toEqual('ssm');\n});","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"if a parameter is retrieved from SSM, the parameters doesnt count as changed if it has the magic marker","suites":[],"updatePoint":{"line":123,"column":109},"line":123,"code":"test('if a parameter is retrieved from SSM, the parameters doesnt count as changed if it has the magic marker', () => {\n  const params = TemplateParameters.fromTemplate({\n    Parameters: {\n      Foo: {\n        Type: 'AWS::SSM::Parameter::Name',\n        Default: '/Some/Key',\n        Description: `blabla ${SSMPARAM_NO_INVALIDATE}`,\n      },\n    },\n  });\n  const oldValues = { Foo: '/Some/Key' };\n\n  // If we don't pass a new value\n  expect(params.updateExisting({}, oldValues).hasChanges(oldValues)).toEqual(false);\n\n  // If we do pass a new value but it's the same as the old one\n  expect(params.updateExisting({ Foo: '/Some/Key' }, oldValues).hasChanges(oldValues)).toEqual(false);\n\n  // If we do pass a new value and it's different\n  expect(params.updateExisting({ Foo: '/OTHER/Key' }, oldValues).hasChanges(oldValues)).toEqual(true);\n});","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"empty string is a valid update value","suites":[],"updatePoint":{"line":145,"column":42},"line":145,"code":"test('empty string is a valid update value', () => {\n  const params = TemplateParameters.fromTemplate({\n    Parameters: {\n      Foo: { Type: 'String', Default: 'Foo' },\n    },\n  });\n\n  expect(params.updateExisting({ Foo: '' }, { Foo: 'ThisIsOld' }).apiParameters).toEqual([\n    { ParameterKey: 'Foo', ParameterValue: '' },\n  ]);\n});","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"unknown parameter in overrides, pass it anyway","suites":[],"updatePoint":{"line":157,"column":52},"line":157,"code":"test('unknown parameter in overrides, pass it anyway', () => {\n  // Not sure if we really want this. It seems like it would be nice\n  // to not pass parameters that aren't expected, given that CFN will\n  // just error out. But maybe we want to be warned of typos...\n  const params = TemplateParameters.fromTemplate({\n    Parameters: {\n      Foo: { Type: 'String', Default: 'Foo' },\n    },\n  });\n\n  expect(params.updateExisting({ Bar: 'Bar' }, {}).apiParameters).toEqual([\n    { ParameterKey: 'Bar', ParameterValue: 'Bar' },\n  ]);\n});","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"if an unsupplied parameter reverts to its default, it can still be dirty","suites":[],"updatePoint":{"line":172,"column":78},"line":172,"code":"test('if an unsupplied parameter reverts to its default, it can still be dirty', () => {\n  // GIVEN\n  const templateParams = TemplateParameters.fromTemplate({\n    Parameters: {\n      Foo: { Type: 'String', Default: 'Foo' },\n    },\n  });\n\n  // WHEN\n  const stackParams = templateParams.supplyAll({});\n\n  // THEN\n  expect(stackParams.hasChanges({ Foo: 'NonStandard' })).toEqual(true);\n  expect(stackParams.hasChanges({ Foo: 'Foo' })).toEqual(false);\n});","file":"util/cloudformation.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"no banner on empty msg list","suites":[],"updatePoint":{"line":5,"column":33},"line":5,"code":"test('no banner on empty msg list', () =>\n  expect(formatAsBanner([])).toEqual([]));","file":"util/console-formatters.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"banner works as expected","suites":[],"updatePoint":{"line":8,"column":30},"line":8,"code":"test('banner works as expected', () =>\n  expect(formatAsBanner(['msg1', 'msg2'])).toEqual([\n    '************',\n    '*** msg1 ***',\n    '*** msg2 ***',\n    '************',\n  ]));","file":"util/console-formatters.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"banner works for formatted msgs","suites":[],"updatePoint":{"line":16,"column":37},"line":16,"code":"test('banner works for formatted msgs', () =>\n  expect(formatAsBanner([\n    'hello msg1',\n    chalk.yellow('hello msg2'),\n    chalk.bold('hello msg3'),\n  ])).toEqual([\n    '******************',\n    '*** hello msg1 ***',\n    `*** ${chalk.yellow('hello msg2')} ***`,\n    `*** ${chalk.bold('hello msg3')} ***`,\n    '******************',\n  ]));","file":"util/console-formatters.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deepSet can set deeply","suites":[],"updatePoint":{"line":5,"column":28},"line":5,"code":"test('deepSet can set deeply', () => {\n  const obj = {};\n  deepSet(obj, ['a', 'b'], 3);\n  expect(obj).toEqual({ a: { b: 3 } });\n});","file":"util/objects.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deepGet can get deeply","suites":[],"updatePoint":{"line":11,"column":28},"line":11,"code":"test('deepGet can get deeply', () => {\n  const obj = { a: { b: 3 } };\n  expect(deepGet(obj, ['a', 'b'])).toBe(3);\n});","file":"util/objects.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deepGet can return an array","suites":[],"updatePoint":{"line":16,"column":33},"line":16,"code":"test('deepGet can return an array', () => {\n  const obj = { a: [1, 2, 3] };\n  expect(deepGet(obj, ['a'])).toEqual([1, 2, 3]);\n});","file":"util/objects.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"changing deepClones copy leaves the original intact","suites":[],"updatePoint":{"line":21,"column":57},"line":21,"code":"test('changing deepClones copy leaves the original intact', () => {\n  const original = { a: [{ b: 3 }] };\n  const copy = deepClone(original);\n  copy.a[0].c = 5;\n\n  expect(original).toEqual({ a: [{ b: 3 }] });\n});","file":"util/objects.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deepMerge merges objects","suites":[],"updatePoint":{"line":29,"column":30},"line":29,"code":"test('deepMerge merges objects', () => {\n  const original = { a: { b: 3 } };\n  deepMerge(original, { a: { c: 4 } });\n\n  expect(original).toEqual({ a: { b: 3, c: 4 } });\n});","file":"util/objects.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deepMerge overwrites non-objects","suites":[],"updatePoint":{"line":36,"column":38},"line":36,"code":"test('deepMerge overwrites non-objects', () => {\n  const original = { a: [] };\n  deepMerge(original, { a: { b: 3 } });\n\n  expect(original).toEqual({ a: { b: 3 } });\n});","file":"util/objects.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"deepMerge does not overwrite if rightmost is \"undefined\"","suites":[],"updatePoint":{"line":43,"column":62},"line":43,"code":"test('deepMerge does not overwrite if rightmost is \"undefined\"', () => {\n  const original = { a: 1 };\n  deepMerge(original, { a: undefined });\n\n  expect(original).toEqual({ a: 1 });\n});","file":"util/objects.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"objects are split at the right place","suites":["splitBySize"],"updatePoint":{"line":51,"column":44},"line":51,"code":"  test('objects are split at the right place', () => {\n    fc.assert(\n      fc.property(fc.object(), fc.integer({ min: 2 }), (data, size) => {\n        const [first, second] = splitBySize(data, size);\n\n        expect(Buffer.from(JSON.stringify(first)).length).toBeLessThanOrEqual(size);\n        expect(merge(first, second)).toEqual(data);\n      }),\n    );\n\n    function merge(fst: any, snd: any) {\n      return { ...(fst ?? {}), ...(snd ?? {}) };\n    }\n  });","file":"util/objects.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"parallelPromises","suites":[],"updatePoint":{"line":4,"column":22},"line":4,"code":"test('parallelPromises', async () => {\n  const N = 4;\n  const J = 100;\n\n  let jobsDone = 0;\n  let concurrent = 0;\n  let maxConcurrent = 0;\n\n  const jobs = range(J).map(() => async () => {\n    concurrent += 1;\n    maxConcurrent = Math.max(concurrent, maxConcurrent);\n    await sleep(Math.round(Math.random() * 100));\n    concurrent -= 1;\n    jobsDone += 1;\n  });\n\n  await parallelPromises(N, jobs);\n\n  expect(maxConcurrent).toBeLessThanOrEqual(N);\n  expect(maxConcurrent).toBeGreaterThan(1);\n  expect(jobsDone).toEqual(J);\n});","file":"util/parallel.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"continue to the next page if it exists","suites":[],"updatePoint":{"line":13,"column":44},"line":13,"code":"test('continue to the next page if it exists', async () => {\n  await testMonitorWithEventCalls([\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(102)],\n        NextToken: 'some-token',\n      };\n    },\n    (request) => {\n      expect(request.NextToken).toBe('some-token');\n      return {\n        StackEvents: [event(101)],\n      };\n    },\n  ]);\n\n  // Printer sees them in chronological order\n  expect(printer.eventIds).toEqual(['101', '102']);\n});","file":"util/stack-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do not page further if we already saw the last event","suites":[],"updatePoint":{"line":34,"column":58},"line":34,"code":"test('do not page further if we already saw the last event', async () => {\n  await testMonitorWithEventCalls([\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(101)],\n      };\n    },\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(102), event(101)],\n        NextToken: 'some-token',\n      };\n    },\n    (request) => {\n      // Did not use the token\n      expect(request.NextToken).toBeUndefined();\n      return {};\n    },\n  ]);\n\n  // Seen in chronological order\n  expect(printer.eventIds).toEqual(['101', '102']);\n});","file":"util/stack-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do not page further if the last event is too old","suites":[],"updatePoint":{"line":60,"column":54},"line":60,"code":"test('do not page further if the last event is too old', async () => {\n  await testMonitorWithEventCalls([\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(101), event(95)],\n        NextToken: 'some-token',\n      };\n    },\n    (request) => {\n      // Start again from the top\n      expect(request.NextToken).toBeUndefined();\n      return {};\n    },\n  ]);\n\n  // Seen only the new one\n  expect(printer.eventIds).toEqual(['101']);\n});","file":"util/stack-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do a final request after the monitor is stopped","suites":[],"updatePoint":{"line":80,"column":53},"line":80,"code":"test('do a final request after the monitor is stopped', async () => {\n  await testMonitorWithEventCalls([\n    // Before stop\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(101)],\n      };\n    },\n  ],\n  // After stop\n  [\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(102), event(101)],\n      };\n    },\n  ]);\n\n  // Seen both\n  expect(printer.eventIds).toEqual(['101', '102']);\n});","file":"util/stack-monitor.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"empty string","suites":["validate sns arns"],"updatePoint":{"line":5,"column":20},"line":5,"code":"  test('empty string', () => {\n    const arn = '';\n    expect(validateSnsTopicArn(arn)).toEqual(false);\n  });","file":"util/validate-notification-arn.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"colon in topic name","suites":["validate sns arns"],"updatePoint":{"line":10,"column":27},"line":10,"code":"  test('colon in topic name', () => {\n    const arn = 'arn:aws:sns:eu-west-1:abc:foo';\n    expect(validateSnsTopicArn(arn)).toEqual(false);\n  });","file":"util/validate-notification-arn.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"missing :aws: in arn","suites":["validate sns arns"],"updatePoint":{"line":15,"column":28},"line":15,"code":"  test('missing :aws: in arn', () => {\n    const arn = 'arn:sns:eu-west-1:foobar';\n    expect(validateSnsTopicArn(arn)).toEqual(false);\n  });","file":"util/validate-notification-arn.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"dash in topic name","suites":["validate sns arns"],"updatePoint":{"line":20,"column":26},"line":20,"code":"  test('dash in topic name', () => {\n    const arn = 'arn:aws:sns:eu-west-1:123456789876:foo-bar';\n    expect(validateSnsTopicArn(arn)).toEqual(true);\n  });","file":"util/validate-notification-arn.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"underscore in topic name","suites":["validate sns arns"],"updatePoint":{"line":25,"column":32},"line":25,"code":"  test('underscore in topic name', () => {\n    const arn = 'arn:aws:sns:eu-west-1:123456789876:foo-bar_baz';\n    expect(validateSnsTopicArn(arn)).toEqual(true);\n  });","file":"util/validate-notification-arn.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"valid","suites":["rangeFromSemver","bracket"],"updatePoint":{"line":6,"column":15},"line":6,"code":"    test('valid', () => {\n      expect(rangeFromSemver('1.2.3', 'bracket')).toEqual('1.2.3');\n      expect(rangeFromSemver('^1.2.3', 'bracket')).toEqual('[1.2.3,2.0.0)');\n    });","file":"util/version-range.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"valid","suites":["rangeFromSemver","pep"],"updatePoint":{"line":13,"column":15},"line":13,"code":"    test('valid', () => {\n      expect(rangeFromSemver('1.2.3', 'pep')).toEqual('==1.2.3');\n      expect(rangeFromSemver('^1.2.3', 'pep')).toEqual('>=1.2.3,<2.0.0');\n    });","file":"util/version-range.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"invalid","suites":["rangeFromSemver","pep"],"updatePoint":{"line":19,"column":15},"line":19,"code":"  test('invalid', () => {\n    expect(() => rangeFromSemver('1.2', 'bracket')).toThrow();\n    expect(() => rangeFromSemver('~1.2.3', 'bracket')).toThrow();\n    expect(() => rangeFromSemver('1.2.3-1.4.5', 'bracket')).toThrow();\n    expect(() => rangeFromSemver('>2.4.5', 'bracket')).toThrow();\n    expect(() => rangeFromSemver('2.*', 'bracket')).toThrow();\n  });","file":"util/version-range.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"initialization fails on unwritable directory","suites":[],"updatePoint":{"line":24,"column":50},"line":24,"code":"test('initialization fails on unwritable directory', () => {\n  const cacheFile = tmpfile();\n  sinon.stub(fs, 'mkdirsSync').withArgs(path.dirname(cacheFile)).throws('Cannot make directory');\n  expect(() => new VersionCheckTTL(cacheFile)).toThrow(/not writable/);\n});","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"cache file responds correctly when file is not present","suites":[],"updatePoint":{"line":30,"column":60},"line":30,"code":"test('cache file responds correctly when file is not present', async () => {\n  const cache = new VersionCheckTTL(tmpfile(), 1);\n  expect(await cache.hasExpired()).toBeTruthy();\n});","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"cache file honours the specified TTL","suites":[],"updatePoint":{"line":35,"column":42},"line":35,"code":"test('cache file honours the specified TTL', async () => {\n  const cache = new VersionCheckTTL(tmpfile(), 1);\n  await cache.update();\n  expect(await cache.hasExpired()).toBeFalsy();\n  await setTimeout(1001); // Just above 1 sec in ms\n  expect(await cache.hasExpired()).toBeTruthy();\n});","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Skip version check if cache has not expired","suites":[],"updatePoint":{"line":43,"column":49},"line":43,"code":"test('Skip version check if cache has not expired', async () => {\n  const cache = new VersionCheckTTL(tmpfile(), 100);\n  await cache.update();\n  expect(await latestVersionIfHigher('0.0.0', cache)).toBeNull();\n});","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Return later version when exists & skip recent re-check","suites":[],"updatePoint":{"line":49,"column":61},"line":49,"code":"test('Return later version when exists & skip recent re-check', async () => {\n  const cache = new VersionCheckTTL(tmpfile(), 100);\n  const result = await latestVersionIfHigher('0.0.0', cache);\n  expect(result).not.toBeNull();\n  expect((result as string).length).toBeGreaterThan(0);\n\n  const result2 = await latestVersionIfHigher('0.0.0', cache);\n  expect(result2).toBeNull();\n});","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Return null if version is higher than npm","suites":[],"updatePoint":{"line":59,"column":47},"line":59,"code":"test('Return null if version is higher than npm', async () => {\n  const cache = new VersionCheckTTL(tmpfile(), 100);\n  const result = await latestVersionIfHigher('100.100.100', cache);\n  expect(result).toBeNull();\n});","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Version specified is stored in the TTL file","suites":[],"updatePoint":{"line":65,"column":49},"line":65,"code":"test('Version specified is stored in the TTL file', async () => {\n  const cacheFile = tmpfile();\n  const cache = new VersionCheckTTL(cacheFile, 1);\n  await cache.update('1.1.1');\n  const storedVersion = fs.readFileSync(cacheFile, 'utf8');\n  expect(storedVersion).toBe('1.1.1');\n});","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"No Version specified for storage in the TTL file","suites":[],"updatePoint":{"line":73,"column":54},"line":73,"code":"test('No Version specified for storage in the TTL file', async () => {\n  const cacheFile = tmpfile();\n  const cache = new VersionCheckTTL(cacheFile, 1);\n  await cache.update();\n  const storedVersion = fs.readFileSync(cacheFile, 'utf8');\n  expect(storedVersion).toBe('');\n});","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Skip version check if environment variable is set","suites":[],"updatePoint":{"line":81,"column":55},"line":81,"code":"test('Skip version check if environment variable is set', async () => {\n  sinon.stub(process, 'stdout').value({ ...process.stdout, isTTY: true });\n  sinon.stub(process, 'env').value({ ...process.env, CDK_DISABLE_VERSION_CHECK: '1' });\n  const printStub = sinon.stub(logging, 'print');\n  await displayVersionMessage();\n  expect(printStub.called).toEqual(false);\n});","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Prints a message when a new version is available","suites":["version message"],"updatePoint":{"line":99,"column":56},"line":99,"code":"  test('Prints a message when a new version is available', async () => {\n    // Given the current version is 1.0.0 and the latest version is 1.1.0\n    const currentVersion = '1.0.0';\n    jest.spyOn(npm, 'getLatestVersionFromNpm').mockResolvedValue('1.1.0');\n    const printSpy = jest.spyOn(logging, 'print');\n\n    // When displayVersionMessage is called\n    await displayVersionMessage(currentVersion, new VersionCheckTTL(tmpfile(), 0));\n\n    // Then the new version message is printed to stdout\n    expect(printSpy).toHaveBeenCalledWith(expect.stringContaining('1.1.0'));\n  });","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Includes major upgrade documentation when available","suites":["version message"],"updatePoint":{"line":112,"column":59},"line":112,"code":"  test('Includes major upgrade documentation when available', async() => {\n    // Given the current version is 1.0.0 and the latest version is 2.0.0\n    const currentVersion = '1.0.0';\n    jest.spyOn(npm, 'getLatestVersionFromNpm').mockResolvedValue('2.0.0');\n    const printSpy = jest.spyOn(logging, 'print');\n\n    // When displayVersionMessage is called\n    await displayVersionMessage(currentVersion, new VersionCheckTTL(tmpfile(), 0));\n\n    // Then the V1 -> V2 documentation is printed\n    expect(printSpy).toHaveBeenCalledWith(expect.stringContaining('Information about upgrading from version 1.x to version 2.x is available here: https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html'));\n  });","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Does not include major upgrade documentation when unavailable","suites":["version message"],"updatePoint":{"line":125,"column":69},"line":125,"code":"  test('Does not include major upgrade documentation when unavailable', async() => {\n    // Given current version is 99.0.0 and the latest version is 100.0.0\n    const currentVersion = '99.0.0';\n    jest.spyOn(npm, 'getLatestVersionFromNpm').mockResolvedValue('100.0.0');\n    const printSpy = jest.spyOn(logging, 'print');\n\n    // When displayVersionMessage is called\n    await displayVersionMessage(currentVersion, new VersionCheckTTL(tmpfile(), 0));\n\n    // Then no upgrade documentation is printed\n    expect(printSpy).toHaveBeenCalledWith(expect.stringContaining('100.0.0'));\n    expect(printSpy).not.toHaveBeenCalledWith(expect.stringContaining('Information about upgrading from 99.x to 100.x'));\n  });","file":"version.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"stack depends on the asset publishing step","suites":["with some stacks and assets"],"updatePoint":{"line":25,"column":50},"line":25,"code":"  test('stack depends on the asset publishing step', () => {\n    const graph = new WorkGraphBuilder(true).build(assembly.artifacts);\n\n    expect(assertableNode(graph.node('stack2'))).toEqual(expect.objectContaining({\n      type: 'stack',\n      dependencies: expect.arrayContaining(['F1:D1-publish']),\n    } as StackNode));\n  });","file":"work-graph-builder.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"asset publishing step depends on asset building step","suites":["with some stacks and assets"],"updatePoint":{"line":34,"column":60},"line":34,"code":"  test('asset publishing step depends on asset building step', () => {\n    const graph = new WorkGraphBuilder(true).build(assembly.artifacts);\n\n    expect(graph.node('F1:D1-publish')).toEqual(expect.objectContaining({\n      type: 'asset-publish',\n      dependencies: new Set(['F1:D1-build']),\n    } as Partial<AssetPublishNode>));\n  });","file":"work-graph-builder.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"with prebuild off, asset building inherits dependencies from their parent stack","suites":["with some stacks and assets"],"updatePoint":{"line":43,"column":87},"line":43,"code":"  test('with prebuild off, asset building inherits dependencies from their parent stack', () => {\n    const graph = new WorkGraphBuilder(false).build(assembly.artifacts);\n\n    expect(graph.node('F1:D1-build')).toEqual(expect.objectContaining({\n      type: 'asset-build',\n      dependencies: new Set(['stack0', 'stack1']),\n    } as Partial<AssetBuildNode>));\n  });","file":"work-graph-builder.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"with prebuild on, assets only have their own dependencies","suites":["with some stacks and assets"],"updatePoint":{"line":52,"column":65},"line":52,"code":"  test('with prebuild on, assets only have their own dependencies', () => {\n    const graph = new WorkGraphBuilder(true).build(assembly.artifacts);\n\n    expect(graph.node('F1:D1-build')).toEqual(expect.objectContaining({\n      type: 'asset-build',\n      dependencies: new Set(['stack0']),\n    } as Partial<AssetBuildNode>));\n  });","file":"work-graph-builder.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"tree metadata is ignored","suites":["with some stacks and assets"],"updatePoint":{"line":62,"column":30},"line":62,"code":"test('tree metadata is ignored', async () => {\n  rootBuilder.addArtifact('tree', {\n    type: cxschema.ArtifactType.CDK_TREE,\n    properties: {\n      file: 'doesnotexist.json',\n    } as cxschema.TreeArtifactProperties,\n  });\n\n  const assembly = rootBuilder.buildAssembly();\n\n  const graph = new WorkGraphBuilder(true).build(assembly.artifacts);\n  expect(graph.ready().length).toEqual(0);\n});","file":"work-graph-builder.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can handle nested assemblies","suites":["with some stacks and assets"],"updatePoint":{"line":76,"column":34},"line":76,"code":"test('can handle nested assemblies', async () => {\n  addSomeStacksAndAssets(rootBuilder);\n  const nested = rootBuilder.createNestedAssembly('nested', 'Nested Assembly');\n  addSomeStacksAndAssets(nested);\n  nested.buildAssembly();\n\n  const assembly = rootBuilder.buildAssembly();\n\n  let workDone = 0;\n  const graph = new WorkGraphBuilder(true).build(assembly.artifacts);\n  await graph.doParallel(10, {\n    deployStack: async () => { workDone += 1; },\n    buildAsset: async () => { },\n    publishAsset: async () => { workDone += 1; },\n  });\n\n  expect(workDone).toEqual(8);\n});","file":"work-graph-builder.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"dependencies on unselected artifacts are silently ignored","suites":["with some stacks and assets"],"updatePoint":{"line":95,"column":63},"line":95,"code":"test('dependencies on unselected artifacts are silently ignored', async () => {\n  addStack(rootBuilder, 'stackA', {\n    environment: 'aws://222222/us-east-1',\n  });\n  addStack(rootBuilder, 'stackB', {\n    dependencies: ['stackA'],\n    environment: 'aws://222222/us-east-1',\n  });\n\n  const asm = rootBuilder.buildAssembly();\n  const graph = new WorkGraphBuilder(true).build([asm.getStackArtifact('stackB')]);\n  expect(graph.ready()[0]).toEqual(expect.objectContaining({\n    id: 'stackB',\n    dependencies: new Set(),\n  }));\n});","file":"work-graph-builder.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"assets with shared contents between dependant stacks","suites":["tests that use assets"],"updatePoint":{"line":126,"column":60},"line":126,"code":"  test('assets with shared contents between dependant stacks', async () => {\n    addStack(rootBuilder, 'StackA', {\n      environment: 'aws://11111/us-east-1',\n      dependencies: ['StackA.assets'],\n    });\n    addAssets(rootBuilder, 'StackA.assets', { files });\n\n    addStack(rootBuilder, 'StackB', {\n      environment: 'aws://11111/us-east-1',\n      dependencies: ['StackB.assets', 'StackA'],\n    });\n    addAssets(rootBuilder, 'StackB.assets', { files });\n\n    const assembly = rootBuilder.buildAssembly();\n\n    const traversal: string[] = [];\n    const graph = new WorkGraphBuilder(true).build(assembly.artifacts);\n    await graph.doParallel(1, {\n      deployStack: async (node) => { traversal.push(node.id); },\n      buildAsset: async (node) => { traversal.push(node.id); },\n      publishAsset: async (node) => { traversal.push(node.id); },\n    });\n\n    expect(traversal).toHaveLength(4); // 1 asset build, 1 asset publish, 2 stacks\n    expect(traversal).toEqual([\n      'work-graph-builder.test.js:D1-build',\n      'work-graph-builder.test.js:D1-publish',\n      'StackA',\n      'StackB',\n    ]);\n  });","file":"work-graph-builder.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"a more complex way to make a cycle","suites":["tests that use assets"],"updatePoint":{"line":158,"column":42},"line":158,"code":"  test('a more complex way to make a cycle', async () => {\n    // A -> B -> C | A and C share an asset. The asset will have a dependency on B, that is not a *direct* reverse dependency, and will cause a cycle.\n    addStack(rootBuilder, 'StackA', { environment, dependencies: ['StackA.assets', 'StackB'] });\n    addAssets(rootBuilder, 'StackA.assets', { files });\n\n    addStack(rootBuilder, 'StackB', { environment, dependencies: ['StackC'] });\n\n    addStack(rootBuilder, 'StackC', { environment, dependencies: ['StackC.assets'] });\n    addAssets(rootBuilder, 'StackC.assets', { files });\n\n    const assembly = rootBuilder.buildAssembly();\n    const graph = new WorkGraphBuilder(true).build(assembly.artifacts);\n\n    // THEN\n    expect(graph.findCycle()).toBeUndefined();\n  });","file":"work-graph-builder.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Success - Concurrency: $concurrency - $scenario","suites":["WorkGraph"],"line":46,"code":"  test.each([\n    // Concurrency 1\n    { scenario: 'No Stacks', concurrency: 1, toDeploy: [], expected: [] },\n    { scenario: 'A', concurrency: 1, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }]), expected: ['A'] },\n    { scenario: 'A, B', concurrency: 1, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }, { id: 'B', type: 'stack' }]), expected: ['A', 'B'] },\n    { scenario: 'A -> B', concurrency: 1, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }, { id: 'B', type: 'stack', stackDependencies: ['A'] }]), expected: ['A', 'B'] },\n    { scenario: '[unsorted] A -> B', concurrency: 1, toDeploy: createArtifacts([{ id: 'B', type: 'stack', stackDependencies: ['A'] }, { id: 'A', type: 'stack' }]), expected: ['A', 'B'] },\n    { scenario: 'A -> B -> C', concurrency: 1, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }, { id: 'B', type: 'stack', stackDependencies: ['A'] }, { id: 'C', type: 'stack', stackDependencies: ['B'] }]), expected: ['A', 'B', 'C'] },\n    { scenario: 'A -> B, A -> C', concurrency: 1, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }, { id: 'B', type: 'stack', stackDependencies: ['A'] }, { id: 'C', type: 'stack', stackDependencies: ['A'] }]), expected: ['A', 'B', 'C'] },\n    {\n      scenario: 'A (slow), B',\n      concurrency: 1,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', name: SLOW },\n        { id: 'B', type: 'stack' },\n      ]),\n      expected: ['A', 'B'],\n    },\n    {\n      scenario: 'A -> B, C -> D',\n      concurrency: 1,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack' },\n        { id: 'B', type: 'stack', stackDependencies: ['A'] },\n        { id: 'C', type: 'stack' },\n        { id: 'D', type: 'stack', stackDependencies: ['C'] },\n      ]),\n      expected: ['A', 'C', 'B', 'D'],\n    },\n    {\n      scenario: 'A (slow) -> B, C -> D',\n      concurrency: 1,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', name: SLOW },\n        { id: 'B', type: 'stack', stackDependencies: ['A'] },\n        { id: 'C', type: 'stack' },\n        { id: 'D', type: 'stack', stackDependencies: ['C'] },\n      ]),\n      expected: ['A', 'C', 'B', 'D'],\n    },\n    // With Assets\n    {\n      scenario: 'A -> a',\n      concurrency: 1,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', assetDependencies: ['a'] },\n        { id: 'a', type: 'asset' },\n      ]),\n      expected: ['a-build', 'a-publish', 'A'],\n    },\n    {\n      scenario: 'A -> [a, B]',\n      concurrency: 1,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', stackDependencies: ['B'], assetDependencies: ['a'] },\n        { id: 'B', type: 'stack' },\n        { id: 'a', type: 'asset', name: SLOW },\n      ]),\n      expected: ['B', 'a-build', 'a-publish', 'A'],\n    },\n    {\n      scenario: 'A -> a, B -> b',\n      concurrency: 1,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', assetDependencies: ['a'] },\n        { id: 'B', type: 'stack', assetDependencies: ['b'] },\n        { id: 'a', type: 'asset' },\n        { id: 'b', type: 'asset' },\n      ]),\n      expected: ['a-build', 'b-build', 'a-publish', 'b-publish', 'A', 'B'],\n    },\n    {\n      scenario: 'A, B -> b -> A',\n      concurrency: 1,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack' },\n        { id: 'B', type: 'stack', assetDependencies: ['b'] },\n        { id: 'b', type: 'asset', stackDependencies: ['A'] },\n      ]),\n      expected: ['A', 'b-build', 'b-publish', 'B'],\n    },\n\n    // Concurrency 2\n    { scenario: 'No Stacks', concurrency: 2, toDeploy: [], expected: [] },\n    { scenario: 'A', concurrency: 2, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }]), expected: ['A'] },\n    { scenario: 'A, B', concurrency: 2, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }, { id: 'B', type: 'stack' }]), expected: ['A', 'B'] },\n    { scenario: 'A -> B', concurrency: 2, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }, { id: 'B', type: 'stack', stackDependencies: ['A'] }]), expected: ['A', 'B'] },\n    { scenario: '[unsorted] A -> B', concurrency: 2, toDeploy: createArtifacts([{ id: 'B', type: 'stack', stackDependencies: ['A'] }, { id: 'A', type: 'stack' }]), expected: ['A', 'B'] },\n    { scenario: 'A -> B -> C', concurrency: 2, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }, { id: 'B', type: 'stack', stackDependencies: ['A'] }, { id: 'C', type: 'stack', stackDependencies: ['B'] }]), expected: ['A', 'B', 'C'] },\n    { scenario: 'A -> B, A -> C', concurrency: 2, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }, { id: 'B', type: 'stack', stackDependencies: ['A'] }, { id: 'C', type: 'stack', stackDependencies: ['A'] }]), expected: ['A', 'B', 'C'] },\n    {\n      scenario: 'A, B',\n      concurrency: 2,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', name: SLOW },\n        { id: 'B', type: 'stack' },\n      ]),\n      expected: ['B', 'A'],\n    },\n    {\n      scenario: 'A -> B, C -> D',\n      concurrency: 2,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack' },\n        { id: 'B', type: 'stack', stackDependencies: ['A'] },\n        { id: 'C', type: 'stack' },\n        { id: 'D', type: 'stack', stackDependencies: ['C'] },\n      ]),\n      expected: ['A', 'C', 'B', 'D'],\n    },\n    {\n      scenario: 'A (slow) -> B, C -> D',\n      concurrency: 2,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', name: SLOW },\n        { id: 'B', type: 'stack', stackDependencies: ['A'] },\n        { id: 'C', type: 'stack' },\n        { id: 'D', type: 'stack', stackDependencies: ['C'] },\n      ]),\n      expected: ['C', 'D', 'A', 'B'],\n    },\n    {\n      scenario: 'A -> B, A not selected',\n      concurrency: 1,\n      toDeploy: createArtifacts([\n        { id: 'B', type: 'stack', stackDependencies: ['A'] },\n      ]),\n      expected: ['B'],\n    },\n    // With Assets\n    {\n      scenario: 'A -> a',\n      concurrency: 2,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', assetDependencies: ['a'] },\n        { id: 'a', type: 'asset' },\n      ]),\n      expected: ['a-build', 'a-publish', 'A'],\n    },\n    {\n      scenario: 'A -> [a, B]',\n      concurrency: 2,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', stackDependencies: ['B'], assetDependencies: ['a'] },\n        { id: 'B', type: 'stack', name: SLOW },\n        { id: 'a', type: 'asset' },\n      ]),\n      expected: ['a-build', 'a-publish', 'B', 'A'],\n    },\n    {\n      scenario: 'A -> a, B -> b',\n      concurrency: 2,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', assetDependencies: ['a'] },\n        { id: 'B', type: 'stack', assetDependencies: ['b'] },\n        { id: 'a', type: 'asset' },\n        { id: 'b', type: 'asset' },\n      ]),\n      expected: ['a-build', 'b-build', 'a-publish', 'b-publish', 'A', 'B'],\n    },\n    {\n      scenario: 'A, B -> b -> A',\n      concurrency: 2,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack' },\n        { id: 'B', type: 'stack', assetDependencies: ['b'] },\n        { id: 'b', type: 'asset', stackDependencies: ['A'] },\n      ]),\n      expected: ['A', 'b-build', 'b-publish', 'B'],\n    },\n    {\n      scenario: 'A, B -> [b, c], b -> A',\n      concurrency: 2,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', name: SLOW },\n        { id: 'B', type: 'stack', assetDependencies: ['b', 'c'] },\n        { id: 'b', type: 'asset', stackDependencies: ['A'] },\n        { id: 'c', type: 'asset' },\n      ]),\n      expected: ['c-build', 'c-publish', 'A', 'b-build', 'b-publish', 'B'],\n    },\n  ])('Success - Concurrency: $concurrency - $scenario', async ({ concurrency, expected, toDeploy }) => {\n    const graph = new WorkGraph();\n    addTestArtifactsToGraph(toDeploy, graph);\n\n    await graph.doParallel(concurrency, callbacks);\n\n    expect(actionedAssets).toStrictEqual(expected);\n  });","file":"work-graph.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"can remove unnecessary assets","suites":["WorkGraph"],"updatePoint":{"line":236,"column":37},"line":236,"code":"  test('can remove unnecessary assets', async () => {\n    const graph = new WorkGraph();\n    addTestArtifactsToGraph([\n      { id: 'a', type: 'asset' },\n      { id: 'b', type: 'asset' },\n      { id: 'A', type: 'stack', assetDependencies: ['a', 'b'] },\n    ], graph);\n\n    // Remove 'b' from the graph\n    await graph.removeUnnecessaryAssets(node => Promise.resolve(node.id.startsWith('b')));\n    await graph.doParallel(1, callbacks);\n\n    // We expect to only see 'a' and 'A'\n    expect(actionedAssets).toEqual(['a-build', 'a-publish', 'A']);\n  });","file":"work-graph.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Failure - Concurrency: $concurrency - $scenario","suites":["WorkGraph"],"line":253,"code":"  test.each([\n    // Concurrency 1\n    { scenario: 'A (error)', concurrency: 1, toDeploy: createArtifacts([{ id: 'A', type: 'stack', displayName: 'A' }]), expectedError: 'A', expectedStacks: [] },\n    { scenario: 'A (error), B', concurrency: 1, toDeploy: createArtifacts([{ id: 'A', type: 'stack', displayName: 'A' }, { id: 'B', type: 'stack' }]), expectedError: 'A', expectedStacks: [] },\n    { scenario: 'A, B (error)', concurrency: 1, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }, { id: 'B', type: 'stack', displayName: 'B' }]), expectedError: 'B', expectedStacks: ['A'] },\n    { scenario: 'A (error) -> B', concurrency: 1, toDeploy: createArtifacts([{ id: 'A', type: 'stack', displayName: 'A' }, { id: 'B', type: 'stack', stackDependencies: ['A'] }]), expectedError: 'A', expectedStacks: [] },\n    { scenario: '[unsorted] A (error) -> B', concurrency: 1, toDeploy: createArtifacts([{ id: 'B', type: 'stack', stackDependencies: ['A'] }, { id: 'A', type: 'stack', displayName: 'A' }]), expectedError: 'A', expectedStacks: [] },\n    {\n      scenario: 'A (error) -> B, C -> D',\n      concurrency: 1,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', displayName: 'A' },\n        { id: 'B', type: 'stack', stackDependencies: ['A'] },\n        { id: 'C', type: 'stack' },\n        { id: 'D', type: 'stack', stackDependencies: ['C'] },\n      ]),\n      expectedError: 'A',\n      expectedStacks: [],\n    },\n    {\n      scenario: 'A -> B, C (error) -> D',\n      concurrency: 1,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack' },\n        { id: 'B', type: 'stack', stackDependencies: ['A'] },\n        { id: 'C', type: 'stack', displayName: 'C', name: SLOW },\n        { id: 'D', type: 'stack', stackDependencies: ['C'] },\n      ]),\n      expectedError: 'C',\n      expectedStacks: ['A'],\n    },\n\n    // Concurrency 2\n    { scenario: 'A (error)', concurrency: 2, toDeploy: createArtifacts([{ id: 'A', type: 'stack', displayName: 'A' }]), expectedError: 'A', expectedStacks: [] },\n    { scenario: 'A (error), B', concurrency: 2, toDeploy: createArtifacts([{ id: 'A', type: 'stack', displayName: 'A' }, { id: 'B', type: 'stack' }]), expectedError: 'A', expectedStacks: ['B'] },\n    { scenario: 'A, B (error)', concurrency: 2, toDeploy: createArtifacts([{ id: 'A', type: 'stack' }, { id: 'B', type: 'stack', displayName: 'B' }]), expectedError: 'B', expectedStacks: ['A'] },\n    { scenario: 'A (error) -> B', concurrency: 2, toDeploy: createArtifacts([{ id: 'A', type: 'stack', displayName: 'A' }, { id: 'B', type: 'stack', stackDependencies: ['A'] }]), expectedError: 'A', expectedStacks: [] },\n    { scenario: '[unsorted] A (error) -> B', concurrency: 2, toDeploy: createArtifacts([{ id: 'B', type: 'stack', stackDependencies: ['A'] }, { id: 'A', type: 'stack', displayName: 'A' }]), expectedError: 'A', expectedStacks: [] },\n    {\n      scenario: 'A (error) -> B, C -> D',\n      concurrency: 2,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', displayName: 'A' },\n        { id: 'B', type: 'stack', stackDependencies: ['A'] },\n        { id: 'C', type: 'stack' },\n        { id: 'D', type: 'stack', stackDependencies: ['C'] },\n      ]),\n      expectedError: 'A',\n      expectedStacks: ['C'],\n    },\n    {\n      scenario: 'A -> B, C (error) -> D',\n      concurrency: 2,\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack' },\n        { id: 'B', type: 'stack', stackDependencies: ['A'] },\n        { id: 'C', type: 'stack', displayName: 'C', name: SLOW },\n        { id: 'D', type: 'stack', stackDependencies: ['C'] },\n      ]),\n      expectedError: 'C',\n      expectedStacks: ['A', 'B'],\n    },\n  ])('Failure - Concurrency: $concurrency - $scenario', async ({ concurrency, expectedError, toDeploy, expectedStacks }) => {\n    const graph = new WorkGraph();\n    addTestArtifactsToGraph(toDeploy, graph);\n\n    await expect(graph.doParallel(concurrency, callbacks)).rejects.toThrowError(expectedError);\n\n    expect(actionedAssets).toStrictEqual(expectedStacks);\n  });","file":"work-graph.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"Failure - Graph Circular Dependencies - $scenario","suites":["WorkGraph"],"line":325,"code":"  test.each([\n    {\n      scenario: 'A -> A',\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', stackDependencies: ['A'] },\n      ]),\n      expectedError: 'A -> A',\n    },\n    {\n      scenario: 'A -> B, B -> A',\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack', stackDependencies: ['B'] },\n        { id: 'B', type: 'stack', stackDependencies: ['A'] },\n      ]),\n      expectedError: 'A -> B -> A',\n    },\n    {\n      scenario: 'A, B -> C, C -> D, D -> B',\n      toDeploy: createArtifacts([\n        { id: 'A', type: 'stack' }, // Add a node to visit first so the infinite loop occurs deeper in the traversal callstack.\n        { id: 'B', type: 'stack', stackDependencies: ['C'] },\n        { id: 'C', type: 'stack', stackDependencies: ['D'] },\n        { id: 'D', type: 'stack', stackDependencies: ['B'] },\n      ]),\n      expectedError: 'B -> C -> D -> B',\n    },\n  ])('Failure - Graph Circular Dependencies - $scenario', async ({ toDeploy, expectedError }) => {\n    const graph = new WorkGraph();\n    addTestArtifactsToGraph(toDeploy, graph);\n\n    await expect(graph.doParallel(1, callbacks)).rejects.toThrowError(new RegExp(`Unable to make progress.*${expectedError}`));\n  });","file":"work-graph.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"quote the word \"ON\"","suites":[],"updatePoint":{"line":7,"column":25},"line":7,"code":"test('quote the word \"ON\"', () => {\n  // NON NEGOTIABLE! If not quoted, will be interpreted as the boolean TRUE\n\n  // eslint-disable-next-line no-console\n  const output = toYAML({\n    notABoolean: 'ON',\n  });\n\n  expect(output.trim()).toEqual(`notABoolean: ${q}ON${q}`);\n});","file":"yaml.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"quote number-like strings with a leading 0","suites":[],"updatePoint":{"line":18,"column":48},"line":18,"code":"test('quote number-like strings with a leading 0', () => {\n  const output = toYAML({\n    leadingZero: '012345',\n  });\n\n  expect(output.trim()).toEqual(`leadingZero: ${q}012345${q}`);\n});","file":"yaml.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"do not quote octal numbers that arent really octal","suites":[],"updatePoint":{"line":26,"column":56},"line":26,"code":"test('do not quote octal numbers that arent really octal', () => {\n  // This is a contentious one, and something that might have changed in YAML1.2 vs YAML1.1\n  //\n  // One could make the argument that a sequence of characters that couldn't ever\n  // be an octal value doesn't need to be quoted, and pyyaml parses it correctly.\n  //\n  // However, CloudFormation's parser interprets it as a decimal number (eating the\n  // leading 0) if it's unquoted, so that's the behavior we're testing for.\n\n  const output = toYAML({\n    leadingZero: '0123456789',\n  });\n\n  expect(output.trim()).toEqual(`leadingZero: ${q}0123456789${q}`);\n});","file":"yaml.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"validate that our YAML correctly emits quoted colons in a list","suites":[],"updatePoint":{"line":42,"column":68},"line":42,"code":"test('validate that our YAML correctly emits quoted colons in a list', () => {\n  // Must be quoted otherwise it's not valid YAML.\n  //\n  // 'yaml' fails this.\n\n  const output = toYAML({\n    colons: ['arn', ':', 'aws'],\n  });\n\n  expect(output.trim()).toEqual([\n    'colons:',\n    '  - arn',\n    `  - ${q}:${q}`,\n    '  - aws',\n  ].join('\\n'));\n});","file":"yaml.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"validate emission of very long lines","suites":[],"updatePoint":{"line":59,"column":42},"line":59,"code":"test('validate emission of very long lines', () => {\n  const template = {\n    Field: ' very long line that starts with a space. very long line that starts with a space. start on a new line',\n  };\n\n  const output = toYAML(template);\n\n  const parsed = deserializeStructure(output);\n\n  expect(template).toEqual(parsed);\n});","file":"yaml.test.ts","skipped":false,"dir":"packages/aws-cdk/test"},{"name":"zipDirectory can take a directory and produce a zip from it","suites":[],"updatePoint":{"line":18,"column":65},"line":18,"code":"test('zipDirectory can take a directory and produce a zip from it', async () => {\n  const stagingDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive'));\n  const extractDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive.extract'));\n  try {\n    const zipFile = path.join(stagingDir, 'output.zip');\n    const originalDir = path.join(__dirname, 'test-archive');\n    await zipDirectory(originalDir, zipFile, logger);\n\n    // unzip and verify that the resulting tree is the same\n    await exec(`unzip ${zipFile}`, { cwd: extractDir });\n\n    await expect(exec(`diff -bur ${originalDir} ${extractDir}`)).resolves.toBeTruthy();\n\n    // inspect the zip file to check that dates are reset\n    const zip = await fs.readFile(zipFile);\n    const zipData = await jszip.loadAsync(zip);\n    const dates = Object.values(zipData.files).map(file => file.date.toISOString());\n    expect(dates[0]).toBe('1980-01-01T00:00:00.000Z');\n    expect(new Set(dates).size).toBe(1);\n\n    // check that mode is preserved\n    const stat = await fs.stat(path.join(extractDir, 'executable.txt'));\n    // eslint-disable-next-line no-bitwise\n    const isExec = (stat.mode & constants.S_IXUSR) || (stat.mode & constants.S_IXGRP) || (stat.mode & constants.S_IXOTH);\n    expect(isExec).toBeTruthy();\n  } finally {\n    rmRfSync(stagingDir);\n    rmRfSync(extractDir);\n  }\n});","file":"archive.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"md5 hash of a zip stays consistent across invocations","suites":[],"updatePoint":{"line":49,"column":59},"line":49,"code":"test('md5 hash of a zip stays consistent across invocations', async () => {\n  const stagingDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive'));\n  const zipFile1 = path.join(stagingDir, 'output.zip');\n  const zipFile2 = path.join(stagingDir, 'output.zip');\n  const originalDir = path.join(__dirname, 'test-archive');\n  await zipDirectory(originalDir, zipFile1, logger);\n  await new Promise(ok => setTimeout(ok, 2000)); // wait 2s\n  await zipDirectory(originalDir, zipFile2, logger);\n\n  const hash1 = contentHash(await fs.readFile(zipFile1));\n  const hash2 = contentHash(await fs.readFile(zipFile2));\n\n  expect(hash1).toEqual(hash2);\n});","file":"archive.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"zipDirectory follows symlinks","suites":[],"updatePoint":{"line":64,"column":35},"line":64,"code":"test('zipDirectory follows symlinks', async () => {\n  const stagingDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive'));\n  const extractDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive.follow'));\n  try {\n    // First MAKE the symlink we're going to follow. We can't check it into git, because\n    // CodeBuild/CodePipeline (I forget which) is going to replace symlinks with a textual\n    // representation of its target upon checkout, for security reasons. So, to make sure\n    // the symlink exists, we need to create it at build time.\n    const symlinkPath = path.join(__dirname, 'test-archive-follow', 'data', 'linked');\n    const symlinkTarget = '../linked';\n\n    if (await pathExists(symlinkPath)) {\n      await fs.unlink(symlinkPath);\n    }\n    await fs.symlink(symlinkTarget, symlinkPath, 'dir');\n\n    const originalDir = path.join(__dirname, 'test-archive-follow', 'data');\n    const zipFile = path.join(stagingDir, 'output.zip');\n\n    await expect(zipDirectory(originalDir, zipFile, logger)).resolves.toBeUndefined();\n    await expect(exec(`unzip ${zipFile}`, { cwd: extractDir })).resolves.toBeDefined();\n    await expect(exec(`diff -bur ${originalDir} ${extractDir}`)).resolves.toBeDefined();\n  } finally {\n    rmRfSync(stagingDir);\n    rmRfSync(extractDir);\n  }\n});","file":"archive.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"pass destination properties to AWS client","suites":[],"updatePoint":{"line":218,"column":47},"line":218,"code":"test('pass destination properties to AWS client', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, throwOnError: false });\n\n  await pub.publish();\n\n  expect(aws.ecrClient).toHaveBeenCalledWith(expect.objectContaining({\n    region: 'us-north-50',\n    assumeRoleArn: 'arn:aws:role',\n  }));\n});","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"Do nothing if docker image already exists","suites":["with a complete manifest"],"updatePoint":{"line":235,"column":49},"line":235,"code":"  test('Do nothing if docker image already exists', async () => {\n    aws.mockEcr.describeImages = mockedApiResult({ /* No error == image exists */ });\n\n    await pub.publish();\n\n    expect(aws.mockEcr.describeImages).toHaveBeenCalledWith(expect.objectContaining({\n      imageIds: [{ imageTag: 'abcdef' }],\n      repositoryName: 'repo',\n    }));\n  });","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"Displays an error if the ECR repository cannot be found","suites":["with a complete manifest"],"updatePoint":{"line":246,"column":63},"line":246,"code":"  test('Displays an error if the ECR repository cannot be found', async () => {\n    aws.mockEcr.describeImages = mockedApiFailure('RepositoryNotFoundException', 'Repository not Found');\n\n    await expect(pub.publish()).rejects.toThrow('Error publishing: Repository not Found');\n  });","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"successful run does not need to query account ID","suites":["with a complete manifest"],"updatePoint":{"line":252,"column":56},"line":252,"code":"  test('successful run does not need to query account ID', async () => {\n    aws.mockEcr.describeImages = mockedApiResult({ /* No error == image exists */ });\n    await pub.publish();\n    expect(aws.discoverCurrentAccount).not.toHaveBeenCalled();\n  });","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"upload docker image if not uploaded yet but exists locally","suites":["with a complete manifest"],"updatePoint":{"line":258,"column":66},"line":258,"code":"  test('upload docker image if not uploaded yet but exists locally', async () => {\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'] },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:abcdef'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:abcdef'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"build and upload docker image if not exists anywhere","suites":["with a complete manifest"],"updatePoint":{"line":279,"column":60},"line":279,"code":"  test('build and upload docker image if not exists anywhere', async () => {\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '.'], cwd: absoluteDockerPath },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:abcdef'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:abcdef'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"build with networkMode option","suites":["with a complete manifest"],"updatePoint":{"line":301,"column":37},"line":301,"code":"  test('build with networkMode option', async () => {\n    pub = new AssetPublishing(AssetManifest.fromPath('/default-network/cdk.out'), { aws });\n    const defaultNetworkDockerpath = '/default-network/cdk.out/dockerdir';\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '--network', 'default', '.'], cwd: defaultNetworkDockerpath },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:nopqr'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:nopqr'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"build with platform option","suites":["with a complete manifest"],"updatePoint":{"line":325,"column":34},"line":325,"code":"  test('build with platform option', async () => {\n    pub = new AssetPublishing(AssetManifest.fromPath('/platform-arm64/cdk.out'), { aws });\n    const defaultNetworkDockerpath = '/platform-arm64/cdk.out/dockerdir';\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '--platform', 'linux/arm64', '.'], cwd: defaultNetworkDockerpath },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:nopqr'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:nopqr'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"build with cache option","suites":["with a complete manifest"],"updatePoint":{"line":349,"column":31},"line":349,"code":"  test('build with cache option', async () => {\n    pub = new AssetPublishing(AssetManifest.fromPath('/cache/cdk.out'), { aws });\n    const defaultNetworkDockerpath = '/cache/cdk.out/dockerdir';\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '--cache-from', 'type=registry,ref=abcdef', '--cache-to', 'type=inline', '.'], cwd: defaultNetworkDockerpath },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:nopqr'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:nopqr'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"build with multiple cache from option","suites":["with a complete manifest"],"updatePoint":{"line":373,"column":45},"line":373,"code":"  test('build with multiple cache from option', async () => {\n    pub = new AssetPublishing(AssetManifest.fromPath('/cache-from-multiple/cdk.out'), { aws });\n    const defaultNetworkDockerpath = '/cache-from-multiple/cdk.out/dockerdir';\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      {\n        commandLine: [\n          'docker', 'build', '--tag', 'cdkasset-theasset', '--cache-from', 'type=registry,ref=cache:ref', '--cache-from', 'type=registry,ref=cache:main', '--cache-from', 'type=gha', '.',\n        ],\n        cwd: defaultNetworkDockerpath,\n      },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:nopqr'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:nopqr'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"build with cache to complex option","suites":["with a complete manifest"],"updatePoint":{"line":402,"column":42},"line":402,"code":"  test('build with cache to complex option', async () => {\n    pub = new AssetPublishing(AssetManifest.fromPath('/cache-to-complex/cdk.out'), { aws });\n    const defaultNetworkDockerpath = '/cache-to-complex/cdk.out/dockerdir';\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '--cache-to', 'type=registry,ref=cache:main,mode=max,compression=zstd', '.'], cwd: defaultNetworkDockerpath },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:nopqr'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:nopqr'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"upload externally generated Docker image","suites":["external assets"],"updatePoint":{"line":434,"column":48},"line":434,"code":"  test('upload externally generated Docker image', async () => {\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['sometool'], stdout: externalTag, cwd: '/external/cdk.out' },\n      { commandLine: ['docker', 'tag', externalTag, '12345.amazonaws.com/repo:ghijkl'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:ghijkl'] },\n    );\n\n    await pub.publish();\n\n    expect(aws.ecrClient).toHaveBeenCalledWith(expect.objectContaining({\n      region: 'us-north-50',\n      assumeRoleArn: 'arn:aws:role',\n    }));\n    expectAllSpawns();\n  });","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"correctly identify Docker directory if path is absolute","suites":["external assets"],"updatePoint":{"line":459,"column":61},"line":459,"code":"test('correctly identify Docker directory if path is absolute', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/abs/cdk.out'), { aws });\n\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    // Only care about the 'build' command line\n    { commandLine: ['docker', 'login'], prefix: true },\n    { commandLine: ['docker', 'inspect'], exitCode: 1, prefix: true },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '.'], cwd: absoluteDockerPath },\n    { commandLine: ['docker', 'tag'], prefix: true },\n    { commandLine: ['docker', 'push'], prefix: true },\n  );\n\n  await pub.publish();\n\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  expectAllSpawns();\n});","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"when external credentials are present, explicit Docker config directories are used","suites":["external assets"],"updatePoint":{"line":484,"column":88},"line":484,"code":"test('when external credentials are present, explicit Docker config directories are used', async () => {\n  // Setup -- Mock that we have CDK credentials, and mock fs operations.\n  jest.spyOn(dockercreds, 'cdkCredentialsConfig').mockReturnValue({ version: '0.1', domainCredentials: {} });\n  jest.spyOn(fs, 'mkdtempSync').mockImplementationOnce(() => '/tmp/mockedTempDir');\n  jest.spyOn(fs, 'writeFileSync').mockImplementation(jest.fn());\n\n  let pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    // Initally use the first created directory with the CDK credentials\n    { commandLine: ['docker', '--config', '/tmp/mockedTempDir', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n    { commandLine: ['docker', '--config', '/tmp/mockedTempDir', 'build', '--tag', 'cdkasset-theasset', '.'], cwd: absoluteDockerPath },\n    { commandLine: ['docker', '--config', '/tmp/mockedTempDir', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:abcdef'] },\n    // Prior to push, revert to the default config directory\n    { commandLine: ['docker', 'login'], prefix: true },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:abcdef'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n});","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"logging in only once for two assets","suites":["external assets"],"updatePoint":{"line":513,"column":41},"line":513,"code":"test('logging in only once for two assets', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/multi/cdk.out'), { aws, throwOnError: false });\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset1'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset1', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset1', '12345.amazonaws.com/repo:theAsset1'] },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:theAsset1'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset2'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset2', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset2', '12345.amazonaws.com/repo:theAsset2'] },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:theAsset2'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n});","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"logging in twice for two repository domains (containing account id & region)","suites":["external assets"],"updatePoint":{"line":540,"column":82},"line":540,"code":"test('logging in twice for two repository domains (containing account id & region)', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/multi/cdk.out'), { aws, throwOnError: false });\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n\n  let repoIdx = 12345;\n  aws.mockEcr.describeRepositories = jest.fn().mockReturnValue({\n    promise: jest.fn().mockImplementation(() => Promise.resolve({\n      repositories: [\n        // Usually looks like: 012345678910.dkr.ecr.us-west-2.amazonaws.com/aws-cdk/assets\n        { repositoryUri: `${repoIdx++}.amazonaws.com/aws-cdk/assets` },\n      ],\n    })),\n  });\n\n  let proxyIdx = 12345;\n  aws.mockEcr.getAuthorizationToken = jest.fn().mockReturnValue({\n    promise: jest.fn().mockImplementation(() => Promise.resolve({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: `https://${proxyIdx++}.proxy.com/` },\n      ],\n    })),\n  });\n\n  const expectAllSpawns = mockSpawn(\n    { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://12345.proxy.com/'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset1'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset1', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset1', '12345.amazonaws.com/aws-cdk/assets:theAsset1'] },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/aws-cdk/assets:theAsset1'] },\n    { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://12346.proxy.com/'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset2'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset2', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset2', '12346.amazonaws.com/aws-cdk/assets:theAsset2'] },\n    { commandLine: ['docker', 'push', '12346.amazonaws.com/aws-cdk/assets:theAsset2'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n});","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"building only","suites":["external assets"],"updatePoint":{"line":582,"column":19},"line":582,"code":"test('building only', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/multi/cdk.out'), {\n    aws,\n    throwOnError: false,\n    buildAssets: true,\n    publishAssets: false,\n  });\n\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset1'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset1', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset1', '12345.amazonaws.com/repo:theAsset1'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset2'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset2', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset2', '12345.amazonaws.com/repo:theAsset2'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n});","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"publishing only","suites":["external assets"],"updatePoint":{"line":613,"column":21},"line":613,"code":"test('publishing only', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/multi/cdk.out'), {\n    aws,\n    throwOnError: false,\n    buildAssets: false,\n    publishAssets: true,\n  });\n\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/aws-cdk/assets:theAsset1'] },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/aws-cdk/assets:theAsset2'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n});","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"overriding the docker command","suites":["external assets"],"updatePoint":{"line":640,"column":35},"line":640,"code":"test('overriding the docker command', async () => {\n  process.env.CDK_DOCKER = 'custom';\n\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, throwOnError: false });\n\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    { commandLine: ['custom', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n    { commandLine: ['custom', 'inspect', 'cdkasset-theasset'] },\n    { commandLine: ['custom', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:abcdef'] },\n    { commandLine: ['custom', 'push', '12345.amazonaws.com/repo:abcdef'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n});","file":"docker-images.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"pass destination properties to AWS client","suites":[],"updatePoint":{"line":100,"column":47},"line":100,"code":"test('pass destination properties to AWS client', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, throwOnError: false });\n  aws.mockS3.listObjectsV2 = mockedApiResult({});\n\n  await pub.publish();\n\n  expect(aws.s3Client).toHaveBeenCalledWith(expect.objectContaining({\n    region: 'us-north-50',\n    assumeRoleArn: 'arn:aws:role',\n  }));\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"Do nothing if file already exists","suites":[],"updatePoint":{"line":112,"column":39},"line":112,"code":"test('Do nothing if file already exists', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key' }] });\n  aws.mockS3.upload = mockUpload();\n  await pub.publish();\n\n  expect(aws.mockS3.listObjectsV2).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Prefix: 'some_key',\n    MaxKeys: 1,\n  }));\n  expect(aws.mockS3.upload).not.toHaveBeenCalled();\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"tiny file does not count as cache hit","suites":[],"updatePoint":{"line":127,"column":43},"line":127,"code":"test('tiny file does not count as cache hit', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key', Size: 5 }] });\n  aws.mockS3.upload = mockUpload();\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalled();\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"upload file if new (list returns other key)","suites":[],"updatePoint":{"line":138,"column":49},"line":138,"code":"test('upload file if new (list returns other key)', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key',\n    ContentType: 'application/octet-stream',\n  }));\n\n  // We'll just have to assume the contents are correct\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"upload with server side encryption AES256 header","suites":[],"updatePoint":{"line":155,"column":54},"line":155,"code":"test('upload with server side encryption AES256 header', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.getBucketEncryption = mockedApiResult({\n    ServerSideEncryptionConfiguration: {\n      Rules: [\n        {\n          ApplyServerSideEncryptionByDefault: {\n            SSEAlgorithm: 'AES256',\n          },\n          BucketKeyEnabled: false,\n        },\n      ],\n    },\n  });\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key',\n    ContentType: 'application/octet-stream',\n    ServerSideEncryption: 'AES256',\n  }));\n\n  // We'll just have to assume the contents are correct\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"upload with server side encryption aws:kms header and key id","suites":[],"updatePoint":{"line":185,"column":66},"line":185,"code":"test('upload with server side encryption aws:kms header and key id', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.getBucketEncryption = mockedApiResult({\n    ServerSideEncryptionConfiguration: {\n      Rules: [\n        {\n          ApplyServerSideEncryptionByDefault: {\n            SSEAlgorithm: 'aws:kms',\n            KMSMasterKeyID: 'the-key-id',\n          },\n          BucketKeyEnabled: false,\n        },\n      ],\n    },\n  });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key',\n    ContentType: 'application/octet-stream',\n    ServerSideEncryption: 'aws:kms',\n    SSEKMSKeyId: 'the-key-id',\n  }));\n\n  // We'll just have to assume the contents are correct\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"will only read bucketEncryption once even for multiple assets","suites":[],"updatePoint":{"line":218,"column":67},"line":218,"code":"test('will only read bucketEncryption once even for multiple assets', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/types/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledTimes(2);\n  expect(aws.mockS3.getBucketEncryption).toHaveBeenCalledTimes(1);\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"no server side encryption header if access denied for bucket encryption","suites":[],"updatePoint":{"line":230,"column":77},"line":230,"code":"test('no server side encryption header if access denied for bucket encryption', async () => {\n  const progressListener = new FakeListener();\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, progressListener });\n\n  aws.mockS3.getBucketEncryption = mockedApiFailure('AccessDenied', 'Access Denied');\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.not.objectContaining({\n    ServerSideEncryption: 'aws:kms',\n  }));\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.not.objectContaining({\n    ServerSideEncryption: 'AES256',\n  }));\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"correctly looks up content type","suites":[],"updatePoint":{"line":250,"column":37},"line":250,"code":"test('correctly looks up content type', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/types/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key.txt',\n    ContentType: 'text/plain',\n  }));\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key.png',\n    ContentType: 'image/png',\n  }));\n\n  // We'll just have to assume the contents are correct\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"upload file if new (list returns no key)","suites":[],"updatePoint":{"line":273,"column":46},"line":273,"code":"test('upload file if new (list returns no key)', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: undefined });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key',\n  }));\n\n  // We'll just have to assume the contents are correct\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"successful run does not need to query account ID","suites":[],"updatePoint":{"line":289,"column":54},"line":289,"code":"test('successful run does not need to query account ID', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: undefined });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.discoverCurrentAccount).not.toHaveBeenCalled();\n  expect(aws.discoverTargetAccount).not.toHaveBeenCalled();\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"correctly identify asset path if path is absolute","suites":[],"updatePoint":{"line":301,"column":55},"line":301,"code":"test('correctly identify asset path if path is absolute', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/abs/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: undefined });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(true).toBeTruthy(); // No exception, satisfy linter\n});","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"do nothing if file exists already","suites":["external assets"],"updatePoint":{"line":318,"column":41},"line":318,"code":"  test('do nothing if file exists already', async () => {\n    aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key' }] });\n\n    await pub.publish();\n\n    expect(aws.mockS3.listObjectsV2).toHaveBeenCalledWith(expect.objectContaining({\n      Bucket: 'some_external_bucket',\n      Prefix: 'some_key',\n      MaxKeys: 1,\n    }));\n  });","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"upload external asset correctly","suites":["external assets"],"updatePoint":{"line":330,"column":39},"line":330,"code":"  test('upload external asset correctly', async () => {\n    aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: undefined });\n    aws.mockS3.upload = mockUpload('ZIP_FILE_THAT_IS_DEFINITELY_NOT_EMPTY');\n    const expectAllSpawns = mockSpawn({ commandLine: ['sometool'], stdout: ABS_PATH });\n\n    await pub.publish();\n\n    expect(aws.s3Client).toHaveBeenCalledWith(expect.objectContaining({\n      region: 'us-north-50',\n      assumeRoleArn: 'arn:aws:role',\n    }));\n\n    expectAllSpawns();\n  });","file":"files.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"Can list manifest","suites":[],"updatePoint":{"line":37,"column":23},"line":37,"code":"test('Can list manifest', () => {\n  const manifest = AssetManifest.fromPath('/simple/cdk.out');\n  expect(manifest.list().join('\\n')).toEqual(`\nasset1 file {\\\"path\\\":\\\"S1\\\"}\n   asset1:dest1 {\\\"bucketName\\\":\\\"D1\\\",\\\"objectKey\\\":\\\"X\\\"}\n   asset1:dest2 {\\\"bucketName\\\":\\\"D2\\\",\\\"objectKey\\\":\\\"X\\\"}\nasset2 docker-image {\\\"directory\\\":\\\"S2\\\"}\n   asset2:dest1 {\\\"repositoryName\\\":\\\"D3\\\",\\\"imageTag\\\":\\\"X\\\"}\n   asset2:dest2 {\\\"repositoryName\\\":\\\"D4\\\",\\\"imageTag\\\":\\\"X\\\"}\n`.trim());\n});","file":"manifest.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":".entries() iterates over all destinations","suites":[],"updatePoint":{"line":49,"column":47},"line":49,"code":"test('.entries() iterates over all destinations', () => {\n  const manifest = AssetManifest.fromPath('/simple/cdk.out');\n\n  expect(manifest.entries).toEqual([\n    new FileManifestEntry(new DestinationIdentifier('asset1', 'dest1'), { path: 'S1' }, { bucketName: 'D1', objectKey: 'X' }),\n    new FileManifestEntry(new DestinationIdentifier('asset1', 'dest2'), { path: 'S1' }, { bucketName: 'D2', objectKey: 'X' }),\n    new DockerImageManifestEntry(new DestinationIdentifier('asset2', 'dest1'), { directory: 'S2' }, { repositoryName: 'D3', imageTag: 'X' }),\n    new DockerImageManifestEntry(new DestinationIdentifier('asset2', 'dest2'), { directory: 'S2' }, { repositoryName: 'D4', imageTag: 'X' }),\n  ]);\n});","file":"manifest.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"can select by asset ID","suites":[],"updatePoint":{"line":60,"column":28},"line":60,"code":"test('can select by asset ID', () => {\n  const manifest = AssetManifest.fromPath('/simple/cdk.out');\n\n  const subset = manifest.select([DestinationPattern.parse('asset2')]);\n\n  expect(subset.entries.map(e => f(e.genericDestination, 'repositoryName'))).toEqual(['D3', 'D4']);\n});","file":"manifest.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"can select by asset ID + destination ID","suites":[],"updatePoint":{"line":68,"column":45},"line":68,"code":"test('can select by asset ID + destination ID', () => {\n  const manifest = AssetManifest.fromPath('/simple/cdk.out');\n\n  const subset = manifest.select([\n    DestinationPattern.parse('asset1:dest1'),\n    DestinationPattern.parse('asset2:dest2'),\n  ]);\n\n  expect(subset.entries.map(e => f(e.genericDestination, 'repositoryName', 'bucketName'))).toEqual(['D1', 'D4']);\n});","file":"manifest.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"can select by destination ID","suites":[],"updatePoint":{"line":79,"column":34},"line":79,"code":"test('can select by destination ID', () => {\n  const manifest = AssetManifest.fromPath('/simple/cdk.out');\n\n  const subset = manifest.select([\n    DestinationPattern.parse(':dest1'),\n  ]);\n\n  expect(subset.entries.map(e => f(e.genericDestination, 'repositoryName', 'bucketName'))).toEqual(['D1', 'D3']);\n});","file":"manifest.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"empty string is not a valid pattern","suites":[],"updatePoint":{"line":89,"column":41},"line":89,"code":"test('empty string is not a valid pattern', () => {\n  expect(() => {\n    DestinationPattern.parse('');\n  }).toThrow(/Empty string is not a valid destination identifier/);\n});","file":"manifest.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"pattern must have two components","suites":[],"updatePoint":{"line":95,"column":38},"line":95,"code":"test('pattern must have two components', () => {\n  expect(() => {\n    DestinationPattern.parse('a:b:c');\n  }).toThrow(/Asset identifier must contain at most 2/);\n});","file":"manifest.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"parse ASSET:* the same as ASSET and ASSET:","suites":[],"updatePoint":{"line":101,"column":48},"line":101,"code":"test('parse ASSET:* the same as ASSET and ASSET:', () => {\n  expect(DestinationPattern.parse('a:*')).toEqual(DestinationPattern.parse('a'));\n  expect(DestinationPattern.parse('a:*')).toEqual(DestinationPattern.parse('a:'));\n});","file":"manifest.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"parse *:DEST the same as :DEST","suites":[],"updatePoint":{"line":106,"column":36},"line":106,"code":"test('parse *:DEST the same as :DEST', () => {\n  expect(DestinationPattern.parse('*:a')).toEqual(DestinationPattern.parse(':a'));\n});","file":"manifest.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"check that placeholders are replaced","suites":[],"updatePoint":{"line":55,"column":42},"line":55,"code":"test('check that placeholders are replaced', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n  aws.mockS3.getBucketLocation = mockedApiResult({});\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key-current_account-current_region' }] });\n  aws.mockEcr.describeImages = mockedApiResult({ /* No error == image exists */ });\n\n  await pub.publish();\n\n  expect(aws.s3Client).toHaveBeenCalledWith(expect.objectContaining({\n    assumeRoleArn: 'arn:aws:role-current_account',\n  }));\n\n  expect(aws.ecrClient).toHaveBeenCalledWith(expect.objectContaining({\n    region: 'explicit_region',\n    assumeRoleArn: 'arn:aws:role-current_account',\n  }));\n\n  expect(aws.mockS3.listObjectsV2).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket-current_account-current_region',\n    Prefix: 'some_key-current_account-current_region',\n    MaxKeys: 1,\n  }));\n\n  expect(aws.mockEcr.describeImages).toHaveBeenCalledWith(expect.objectContaining({\n    imageIds: [{ imageTag: 'abcdef' }],\n    repositoryName: 'repo-current_account-explicit_region',\n  }));\n});","file":"placeholders.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"Can be overridden by CDK_DOCKER_CREDS_FILE","suites":["cdkCredentialsConfigFile"],"updatePoint":{"line":25,"column":50},"line":25,"code":"  test('Can be overridden by CDK_DOCKER_CREDS_FILE', () => {\n    const credsFile = '/tmp/insertfilenamehere_cdk_config.json';\n    process.env.CDK_DOCKER_CREDS_FILE = credsFile;\n\n    expect(cdkCredentialsConfigFile()).toEqual(credsFile);\n  });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"Uses homedir if no process env is set","suites":["cdkCredentialsConfigFile"],"updatePoint":{"line":32,"column":45},"line":32,"code":"  test('Uses homedir if no process env is set', () => {\n    expect(cdkCredentialsConfigFile()).toEqual(path.join(os.userInfo().homedir, '.cdk', 'cdk-docker-creds.json'));\n  });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"returns undefined if no config exists","suites":["cdkCredentialsConfig"],"updatePoint":{"line":41,"column":45},"line":41,"code":"  test('returns undefined if no config exists', () => {\n    expect(cdkCredentialsConfig()).toBeUndefined();\n  });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"returns parsed config if it exists","suites":["cdkCredentialsConfig"],"updatePoint":{"line":45,"column":42},"line":45,"code":"  test('returns parsed config if it exists', () => {\n    mockfs({\n      [credsFile]: JSON.stringify({\n        version: '0.1',\n        domainCredentials: {\n          'test1.example.com': { secretsManagerSecretId: 'mySecret' },\n          'test2.example.com': { ecrRepository: 'arn:aws:ecr:bar' },\n        },\n      }),\n    });\n\n    const config = cdkCredentialsConfig();\n    expect(config).toBeDefined();\n    expect(config?.version).toEqual('0.1');\n    expect(config?.domainCredentials['test1.example.com']?.secretsManagerSecretId).toEqual('mySecret');\n    expect(config?.domainCredentials['test2.example.com']?.ecrRepository).toEqual('arn:aws:ecr:bar');\n  });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"throws on unknown domain","suites":["fetchDockerLoginCredentials"],"updatePoint":{"line":92,"column":32},"line":92,"code":"  test('throws on unknown domain', async () => {\n    await expect(fetchDockerLoginCredentials(aws, config, 'unknowndomain.example.com')).rejects.toThrow(/unknown domain/);\n  });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"throws on misconfigured domain (no ECR or SM)","suites":["fetchDockerLoginCredentials"],"updatePoint":{"line":96,"column":53},"line":96,"code":"  test('throws on misconfigured domain (no ECR or SM)', async () => {\n    await expect(fetchDockerLoginCredentials(aws, config, 'misconfigured.example.com')).rejects.toThrow(/unknown credential type/);\n  });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"does not throw on correctly configured raw domain","suites":["fetchDockerLoginCredentials"],"updatePoint":{"line":100,"column":57},"line":100,"code":"  test('does not throw on correctly configured raw domain', async () => {\n    mockSecretWithSecretString({ username: 'secretUser', secret: 'secretPass' });\n\n    await expect(fetchDockerLoginCredentials(aws, config, 'https://secret.example.com/v1/')).resolves.toBeTruthy();\n  });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"returns the credentials sucessfully if configured correctly - domain","suites":["fetchDockerLoginCredentials","SecretsManager"],"updatePoint":{"line":107,"column":78},"line":107,"code":"    test('returns the credentials sucessfully if configured correctly - domain', async () => {\n      mockSecretWithSecretString({ username: 'secretUser', secret: 'secretPass' });\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'secret.example.com');\n\n      expect(creds).toEqual({ Username: 'secretUser', Secret: 'secretPass' });\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"returns the credentials successfully if configured correctly - raw domain","suites":["fetchDockerLoginCredentials","SecretsManager"],"updatePoint":{"line":115,"column":83},"line":115,"code":"    test('returns the credentials successfully if configured correctly - raw domain', async () => {\n      mockSecretWithSecretString({ username: 'secretUser', secret: 'secretPass' });\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'https://secret.example.com');\n\n      expect(creds).toEqual({ Username: 'secretUser', Secret: 'secretPass' });\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"throws when SecretsManager returns an error","suites":["fetchDockerLoginCredentials","SecretsManager"],"updatePoint":{"line":123,"column":53},"line":123,"code":"    test('throws when SecretsManager returns an error', async () => {\n      const errMessage = \"Secrets Manager can't find the specified secret.\";\n      aws.mockSecretsManager.getSecretValue = mockedApiFailure('ResourceNotFoundException', errMessage);\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'secret.example.com')).rejects.toThrow(errMessage);\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"supports assuming a role","suites":["fetchDockerLoginCredentials","SecretsManager"],"updatePoint":{"line":130,"column":34},"line":130,"code":"    test('supports assuming a role', async () => {\n      mockSecretWithSecretString({ username: 'secretUser', secret: 'secretPass' });\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'secretwithrole.example.com');\n\n      expect(creds).toEqual({ Username: 'secretUser', Secret: 'secretPass' });\n      expect(aws.secretsManagerClient).toHaveBeenCalledWith({ assumeRoleArn: 'arn:aws:iam::0123456789012:role/my-role' });\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"supports configuring the secret fields","suites":["fetchDockerLoginCredentials","SecretsManager"],"updatePoint":{"line":139,"column":48},"line":139,"code":"    test('supports configuring the secret fields', async () => {\n      mockSecretWithSecretString({ name: 'secretUser', apiKey: '01234567' });\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'secretwithcustomfields.example.com');\n\n      expect(creds).toEqual({ Username: 'secretUser', Secret: '01234567' });\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"throws when secret does not have the correct fields - key/value","suites":["fetchDockerLoginCredentials","SecretsManager"],"updatePoint":{"line":147,"column":73},"line":147,"code":"    test('throws when secret does not have the correct fields - key/value', async () => {\n      mockSecretWithSecretString({ principal: 'foo', credential: 'bar' });\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'secret.example.com')).rejects.toThrow(/malformed secret string/);\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"throws when secret does not have the correct fields - plaintext","suites":["fetchDockerLoginCredentials","SecretsManager"],"updatePoint":{"line":153,"column":73},"line":153,"code":"    test('throws when secret does not have the correct fields - plaintext', async () => {\n      mockSecretWithSecretString('myAPIKey');\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'secret.example.com')).rejects.toThrow(/malformed secret string/);\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"returns the credentials successfully","suites":["fetchDockerLoginCredentials","ECR getAuthorizationToken"],"updatePoint":{"line":161,"column":46},"line":161,"code":"    test('returns the credentials successfully', async () => {\n      mockEcrAuthorizationData(Buffer.from('myFoo:myBar', 'utf-8').toString('base64'));\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'ecr.example.com');\n\n      expect(creds).toEqual({ Username: 'myFoo', Secret: 'myBar' });\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"throws if ECR errors","suites":["fetchDockerLoginCredentials","ECR getAuthorizationToken"],"updatePoint":{"line":169,"column":30},"line":169,"code":"    test('throws if ECR errors', async () => {\n      aws.mockEcr.getAuthorizationToken = mockedApiFailure('ServerException', 'uhoh');\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'ecr.example.com')).rejects.toThrow(/uhoh/);\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"supports assuming a role","suites":["fetchDockerLoginCredentials","ECR getAuthorizationToken"],"updatePoint":{"line":175,"column":34},"line":175,"code":"    test('supports assuming a role', async () => {\n      mockEcrAuthorizationData(Buffer.from('myFoo:myBar', 'utf-8').toString('base64'));\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'ecrwithrole.example.com');\n\n      expect(creds).toEqual({ Username: 'myFoo', Secret: 'myBar' });\n      expect(aws.ecrClient).toHaveBeenCalledWith({ assumeRoleArn: 'arn:aws:iam::0123456789012:role/my-role' });\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"throws if ECR returns no authData","suites":["fetchDockerLoginCredentials","ECR getAuthorizationToken"],"updatePoint":{"line":184,"column":43},"line":184,"code":"    test('throws if ECR returns no authData', async () => {\n      aws.mockEcr.getAuthorizationToken = mockedApiResult({ authorizationData: [] });\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'ecr.example.com')).rejects.toThrow(/No authorization data received from ECR/);\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"throws if ECR authData is in an incorrect format","suites":["fetchDockerLoginCredentials","ECR getAuthorizationToken"],"updatePoint":{"line":190,"column":58},"line":190,"code":"    test('throws if ECR authData is in an incorrect format', async () => {\n      mockEcrAuthorizationData('notabase64encodedstring');\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'ecr.example.com')).rejects.toThrow(/unexpected ECR authData format/);\n    });","file":"private/docker-credentials.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"returns true when image inspect command does not throw","suites":["Docker","exists"],"updatePoint":{"line":25,"column":64},"line":25,"code":"    test('returns true when image inspect command does not throw', async () => {\n      const spy = makeShellExecuteMock(() => undefined);\n\n      const imageExists = await docker.exists('foo');\n\n      expect(imageExists).toBe(true);\n      expect(spy.mock.calls[0][0]).toEqual(['inspect', 'foo']);\n    });","file":"private/docker.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"throws when an arbitrary error is caught","suites":["Docker","exists"],"updatePoint":{"line":34,"column":50},"line":34,"code":"    test('throws when an arbitrary error is caught', async () => {\n      makeShellExecuteMock(() => {\n        throw new Error();\n      });\n\n      await expect(docker.exists('foo')).rejects.toThrow();\n    });","file":"private/docker.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"throws when the error is a shell failure but the exit code is unrecognized","suites":["Docker","exists"],"updatePoint":{"line":42,"column":84},"line":42,"code":"    test('throws when the error is a shell failure but the exit code is unrecognized', async () => {\n      makeShellExecuteMock(() => {\n        throw new (class extends Error implements ProcessFailedError {\n          public readonly code = 'PROCESS_FAILED'\n          public readonly exitCode = 47\n          public readonly signal = null\n\n          constructor() {\n            super('foo');\n          }\n        });\n      });\n\n      await expect(docker.exists('foo')).rejects.toThrow();\n    });","file":"private/docker.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"returns false when the error is a shell failure and the exit code is 1 (Docker)","suites":["Docker","exists"],"updatePoint":{"line":58,"column":89},"line":58,"code":"    test('returns false when the error is a shell failure and the exit code is 1 (Docker)', async () => {\n      makeShellExecuteMock(() => {\n        throw new (class extends Error implements ProcessFailedError {\n          public readonly code = 'PROCESS_FAILED'\n          public readonly exitCode = 1\n          public readonly signal = null\n\n          constructor() {\n            super('foo');\n          }\n        });\n      });\n\n      const imageExists = await docker.exists('foo');\n\n      expect(imageExists).toBe(false);\n    });","file":"private/docker.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"returns false when the error is a shell failure and the exit code is 125 (Podman)","suites":["Docker","exists"],"updatePoint":{"line":76,"column":91},"line":76,"code":"    test('returns false when the error is a shell failure and the exit code is 125 (Podman)', async () => {\n      makeShellExecuteMock(() => {\n        throw new (class extends Error implements ProcessFailedError {\n          public readonly code = 'PROCESS_FAILED'\n          public readonly exitCode = 125\n          public readonly signal = null\n\n          constructor() {\n            super('foo');\n          }\n        });\n      });\n\n      const imageExists = await docker.exists('foo');\n\n      expect(imageExists).toBe(false);\n    });","file":"private/docker.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"test listener","suites":[],"updatePoint":{"line":49,"column":19},"line":49,"code":"test('test listener', async () => {\n  const progressListener = new FakeListener();\n\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, progressListener });\n  await pub.publish();\n\n  const allMessages = progressListener.messages.join('\\n');\n\n  // Log mentions asset/destination ids\n  expect(allMessages).toContain('theAsset:theDestination1');\n  expect(allMessages).toContain('theAsset:theDestination2');\n});","file":"progress.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"test publishing in parallel","suites":[],"updatePoint":{"line":62,"column":33},"line":62,"code":"test('test publishing in parallel', async () => {\n  const progressListener = new FakeListener();\n\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, progressListener, publishInParallel: true });\n  await pub.publish();\n\n  const allMessages = progressListener.messages.join('\\n');\n\n  // Log mentions asset/destination ids\n  expect(allMessages).toContain('theAsset:theDestination1');\n  expect(allMessages).toContain('theAsset:theDestination2');\n});","file":"progress.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"test abort","suites":[],"updatePoint":{"line":75,"column":16},"line":75,"code":"test('test abort', async () => {\n  const progressListener = new FakeListener(true);\n\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, progressListener });\n  await pub.publish();\n\n  const allMessages = progressListener.messages.join('\\n');\n\n  // We never get to asset 2\n  expect(allMessages).not.toContain('theAsset:theDestination2');\n});","file":"progress.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"critical section","suites":[],"updatePoint":{"line":3,"column":22},"line":3,"code":"test('critical section', async () => {\n  // GIVEN\n  const criticalSection = createCriticalSection();\n\n  // WHEN\n  const arr = new Array<string>();\n  void criticalSection(async () => {\n    await new Promise(res => setTimeout(res, 500));\n    arr.push('first');\n  });\n  await criticalSection(async () => {\n    arr.push('second');\n  });\n\n  // THEN\n  expect(arr).toEqual([\n    'first',\n    'second',\n  ]);\n});","file":"util.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"exceptions in critical sections","suites":[],"updatePoint":{"line":24,"column":37},"line":24,"code":"test('exceptions in critical sections', async () => {\n  // GIVEN\n  const criticalSection = createCriticalSection();\n\n  // WHEN/THEN\n  await expect(() => criticalSection(async () => {\n    throw new Error('Thrown');\n  })).rejects.toThrow('Thrown');\n});","file":"util.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"Take a zipped upload","suites":[],"updatePoint":{"line":43,"column":26},"line":43,"code":"test('Take a zipped upload', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath(bockfs.path('/simple/cdk.out')), { aws });\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key',\n    ContentType: 'application/zip',\n  }));\n});","file":"zipping.test.ts","skipped":false,"dir":"packages/cdk-assets/test"},{"name":"skips bump if skip.bump is set","suites":[],"updatePoint":{"line":12,"column":36},"line":12,"code":"test('skips bump if skip.bump is set', async () => {\n  const currentVersion = { stableVersion: '1.1.1', alphaVersion: '1.1.1-alpha.0' };\n  const bumpedVersion = await bump({ releaseAs: 'major', versionFile: 'version.json', skip: { bump: true } }, currentVersion);\n\n  expect(bumpedVersion).toEqual(currentVersion);\n});","file":"bump.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"does a prerelease bump with provided tag if given","suites":["stable versions"],"updatePoint":{"line":21,"column":57},"line":21,"code":"  test('does a prerelease bump with provided tag if given', async () => {\n    const currentVersion = { stableVersion: '1.2.3' };\n    const bumpedVersion = await bump({ releaseAs: 'minor', versionFile: 'version.json', prerelease: 'rc' }, currentVersion);\n\n    expect(bumpedVersion.stableVersion).toEqual('1.3.0-rc.0');\n  });","file":"bump.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"does a normal bump if no prerelease tag is given","suites":["stable versions"],"updatePoint":{"line":28,"column":56},"line":28,"code":"  test('does a normal bump if no prerelease tag is given', async () => {\n    const currentVersion = { stableVersion: '1.2.3' };\n    const bumpedVersion = await bump({ releaseAs: 'minor', versionFile: 'version.json' }, currentVersion);\n\n    expect(bumpedVersion.stableVersion).toEqual('1.3.0');\n  });","file":"bump.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"writes output to version file","suites":["stable versions"],"updatePoint":{"line":35,"column":37},"line":35,"code":"  test('writes output to version file', async () => {\n    const currentVersion = { stableVersion: '1.2.3' };\n    await bump({ releaseAs: 'minor', versionFile: 'version.json' }, currentVersion);\n\n    const versionPath = path.join(process.cwd(), 'version.json');\n    const version = '{\\n  \"version\": \"1.3.0\"\\n}';\n    expect(mockWriteFile).toBeCalledWith(expect.any(Object), versionPath, version);\n  });","file":"bump.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"long-running prerelease: bumps existing alpha counter as a prerelease","suites":["alpha versions"],"updatePoint":{"line":48,"column":77},"line":48,"code":"  test('long-running prerelease: bumps existing alpha counter as a prerelease', async () => {\n    const currentVersion = { stableVersion: '1.2.0-rc.4', alphaVersion: '1.2.0-alpha.0' };\n    const bumpedVersion = await bump({ releaseAs: 'minor', versionFile: 'version.json', prerelease: 'rc' }, currentVersion);\n\n    expect(bumpedVersion).toEqual({\n      stableVersion: '1.2.0-rc.5',\n      alphaVersion: '1.2.0-alpha.1',\n    });\n  });","file":"bump.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"one-off prerelease: alpha is a prerelease of stable release with crazy alpha tag","suites":["alpha versions"],"updatePoint":{"line":58,"column":88},"line":58,"code":"  test('one-off prerelease: alpha is a prerelease of stable release with crazy alpha tag', async () => {\n    const currentVersion = { stableVersion: '1.2.0', alphaVersion: '1.2.0-alpha.0' };\n    const bumpedVersion = await bump({ releaseAs: 'minor', versionFile: 'version.json', prerelease: 'rc' }, currentVersion);\n\n    expect(bumpedVersion).toEqual({\n      stableVersion: '1.3.0-rc.0',\n      alphaVersion: '1.3.0-alpha.999',\n    });\n  });","file":"bump.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"normal release: alpha is a prerelease of stable release with realistic alpha tag","suites":["alpha versions"],"updatePoint":{"line":68,"column":88},"line":68,"code":"  test('normal release: alpha is a prerelease of stable release with realistic alpha tag', async () => {\n    const currentVersion = { stableVersion: '1.2.0', alphaVersion: '1.2.0-alpha.0' };\n    const bumpedVersion = await bump({ releaseAs: 'minor', versionFile: 'version.json' }, currentVersion);\n\n    expect(bumpedVersion).toEqual({\n      stableVersion: '1.3.0',\n      alphaVersion: '1.3.0-alpha.0',\n    });\n  });","file":"bump.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"writes output to version file","suites":["alpha versions"],"updatePoint":{"line":78,"column":37},"line":78,"code":"  test('writes output to version file', async () => {\n    const currentVersion = { stableVersion: '1.2.0', alphaVersion: '1.1.0-alpha.0' };\n    await bump({ releaseAs: 'minor', versionFile: 'version.json' }, currentVersion);\n\n    const versionPath = path.join(process.cwd(), 'version.json');\n    const version = '{\\n  \"version\": \"1.3.0\",\\n  \"alphaVersion\": \"1.3.0-alpha.0\"\\n}';\n    expect(mockWriteFile).toBeCalledWith(expect.any(Object), versionPath, version);\n  });","file":"bump.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"does nothing if skip.changelog is set","suites":["writeChangelogs"],"updatePoint":{"line":34,"column":45},"line":34,"code":"  test('does nothing if skip.changelog is set', async () => {\n    const changelogResult = await writeChangelogs({ ...defaultWriteChangelogOpts, skip: { changelog: true } });\n\n    expect(changelogResult).toEqual([]);\n  });","file":"changelog.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"defaults experimentalChangesTreatment to \"include\"","suites":["writeChangelogs"],"updatePoint":{"line":40,"column":58},"line":40,"code":"  test('defaults experimentalChangesTreatment to \"include\"', async () => {\n    const changelogResultDefault = await writeChangelogs({\n      ...defaultWriteChangelogOpts, experimentalChangesTreatment: undefined,\n    });\n    const changelogResultInclude = await writeChangelogs({\n      ...defaultWriteChangelogOpts, experimentalChangesTreatment: ExperimentalChangesTreatment.INCLUDE,\n    });\n\n    expect(changelogResultDefault).toEqual(changelogResultInclude);\n  });","file":"changelog.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"if experimentalChangesTreatment is \"include\", includes experimental changes","suites":["writeChangelogs"],"updatePoint":{"line":51,"column":83},"line":51,"code":"  test('if experimentalChangesTreatment is \"include\", includes experimental changes', async () => {\n    const changelogResult = await writeChangelogs({\n      ...defaultWriteChangelogOpts, experimentalChangesTreatment: ExperimentalChangesTreatment.INCLUDE,\n    });\n\n    expect(changelogResult.length).toEqual(1);\n    expect(changelogResult[0].filePath).toEqual('CHANGELOG.md');\n    expect(changelogResult[0].fileContents.trim()).toBe(\n      `## [1.24.0](https://github.com/aws/aws-cdk/compare/v1.23.0...v1.24.0)\n\n### Features\n\n* **aws-experimental:** new experimental feat\n* **aws-stable:** new stable feat`);\n  });","file":"changelog.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"if changelogExperimentalChanges is \"strip\", excludes experimental changes","suites":["writeChangelogs"],"updatePoint":{"line":67,"column":81},"line":67,"code":"  test('if changelogExperimentalChanges is \"strip\", excludes experimental changes', async () => {\n    const changelogResult = await writeChangelogs({\n      ...defaultWriteChangelogOpts, experimentalChangesTreatment: ExperimentalChangesTreatment.STRIP,\n    });\n\n    expect(changelogResult.length).toEqual(1);\n    expect(changelogResult[0].filePath).toEqual('CHANGELOG.md');\n    expect(changelogResult[0].fileContents.trim()).toBe(\n      `## [1.24.0](https://github.com/aws/aws-cdk/compare/v1.23.0...v1.24.0)\n\n### Features\n\n* **aws-stable:** new stable feat`);\n  });","file":"changelog.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"throws if alpha versions are not present","suites":["writeChangelogs","experimentalChangesTreatment is SEPARATE"],"updatePoint":{"line":92,"column":50},"line":92,"code":"    test('throws if alpha versions are not present', async () => {\n      await expect(writeChangelogs({\n        ...defaultSeparateChangelogOpts,\n        currentVersion: { stableVersion: '1.23.0' },\n        newVersion: { stableVersion: '1.24.0' },\n      }))\n        .rejects\n        .toThrow(/without alpha package versions/);\n\n      await expect(writeChangelogs({ ...defaultSeparateChangelogOpts, newVersion: { stableVersion: '1.24.0' } }))\n        .rejects\n        .toThrow(/without alpha package versions/);\n\n      await expect(writeChangelogs({ ...defaultSeparateChangelogOpts, currentVersion: { stableVersion: '1.23.0' } }))\n        .rejects\n        .toThrow(/without alpha package versions/);\n    });","file":"changelog.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"throws if alpha changelog file is not present","suites":["writeChangelogs","experimentalChangesTreatment is SEPARATE"],"updatePoint":{"line":110,"column":55},"line":110,"code":"    test('throws if alpha changelog file is not present', async () => {\n      await expect(writeChangelogs({ ...defaultSeparateChangelogOpts, alphaChangelogFile: undefined }))\n        .rejects\n        .toThrow(/alphaChangelogFile must be specified/);\n    });","file":"changelog.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"excludes experimental changes and writes to the alpha changelog","suites":["writeChangelogs","experimentalChangesTreatment is SEPARATE"],"updatePoint":{"line":116,"column":73},"line":116,"code":"    test('excludes experimental changes and writes to the alpha changelog', async () => {\n      const changelogResult = await writeChangelogs(defaultSeparateChangelogOpts);\n\n      const mainResult = changelogResult.find(r => r.filePath === 'CHANGELOG.md');\n      const alphaResult = changelogResult.find(r => r.filePath === 'CHANGELOG.alpha.md');\n      expect(mainResult?.fileContents.trim()).toBe(\n        `## [1.24.0](https://github.com/aws/aws-cdk/compare/v1.23.0...v1.24.0)\n\n### Features\n\n* **aws-stable:** new stable feat`);\n      expect(alphaResult?.fileContents.trim()).toBe(\n        `## [1.24.0-alpha.0](https://github.com/aws/aws-cdk/compare/v1.23.0-alpha.0...v1.24.0-alpha.0)\n\n### Features\n\n* **aws-experimental:** new experimental feat`);\n    });","file":"changelog.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"correctly handles 'BREAKING CHANGES'","suites":["changelog"],"updatePoint":{"line":138,"column":44},"line":138,"code":"  test(\"correctly handles 'BREAKING CHANGES'\", async () => {\n    const commits: ConventionalCommit[] = [\n      buildCommit({\n        type: 'feat',\n        subject: 'super important feature',\n        notes: [\n          {\n            title: 'BREAKING CHANGE',\n            text: 'this is a breaking change',\n          },\n        ],\n      }),\n      buildCommit({\n        type: 'fix',\n        scope: 'scope',\n        subject: 'hairy bugfix',\n      }),\n      buildCommit({\n        type: 'chore',\n        subject: 'this commit should not be rendered in the Changelog',\n      }),\n    ];\n\n    const changelogContents = await invokeChangelogFrom1_23_0to1_24_0(args, commits);\n\n    expect(changelogContents).toBe(\n      `## [1.24.0](https://github.com/aws/aws-cdk/compare/v1.23.0...v1.24.0)\n\n###  BREAKING CHANGES TO EXPERIMENTAL FEATURES\n\n* this is a breaking change\n\n### Features\n\n* super important feature\n\n\n### Bug Fixes\n\n* **scope:** hairy bugfix\n\n`);\n  });","file":"changelog.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"makes it so that no Git commits are queried if Changelog generation is skipped","suites":["getConventionalCommitsFromGitHistory"],"updatePoint":{"line":26,"column":86},"line":26,"code":"  test('makes it so that no Git commits are queried if Changelog generation is skipped', async () => {\n    const commits = await getConventionalCommitsFromGitHistory({ ...args, skip: { changelog: true } }, '3.9.2');\n\n    expect(commits).toHaveLength(0);\n    expect(gitRawCommits).not.toHaveBeenCalled();\n  });","file":"conventional-commits.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"skips commits without types","suites":["getConventionalCommitsFromGitHistory"],"updatePoint":{"line":33,"column":35},"line":33,"code":"  test('skips commits without types', async () => {\n    const commitMessages = ['some commit without a type', 'chore(cdk-release): do trivial stuff'];\n    gitRawCommits.mockImplementation(() => mockGitCommits(commitMessages));\n\n    const commits = await getConventionalCommitsFromGitHistory(args, '3.9.2');\n\n    expect(commits).toHaveLength(1);\n  });","file":"conventional-commits.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"if no options are provided, returns all commits","suites":["filterCommits"],"updatePoint":{"line":50,"column":55},"line":50,"code":"  test('if no options are provided, returns all commits', () => {\n    const filteredCommits = filterCommits(commits);\n\n    expect(filteredCommits).toEqual(commits);\n  });","file":"conventional-commits.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"excludePackages removes commits matching scope","suites":["filterCommits"],"updatePoint":{"line":56,"column":54},"line":56,"code":"  test('excludePackages removes commits matching scope', () => {\n    const filteredCommits = filterCommits(commits, { excludePackages: ['@aws-cdk/aws-experimental'] });\n\n    expect(filteredCommits.length).toEqual(2);\n    expect(filteredCommits.map(c => c.scope)).not.toContain('aws-experimental');\n  });","file":"conventional-commits.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"excludePackages removes commits matching specific variants of the scope","suites":["filterCommits"],"updatePoint":{"line":63,"column":79},"line":63,"code":"  test('excludePackages removes commits matching specific variants of the scope', () => {\n    const experimentalCommits = [\n      commitWithScope('aws-experimental'),\n      commitWithScope('awsexperimental'),\n      commitWithScope('experimental'),\n      commitWithScope('aws.experimental'),\n    ];\n\n    const filteredCommits = filterCommits(experimentalCommits, { excludePackages: ['@aws-cdk/aws-experimental'] });\n\n    expect(filteredCommits.length).toEqual(1);\n    expect(filteredCommits[0].scope).toEqual('aws.experimental');\n  });","file":"conventional-commits.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"includePackages only includes commits matching scope","suites":["filterCommits"],"updatePoint":{"line":77,"column":60},"line":77,"code":"  test('includePackages only includes commits matching scope', () => {\n    const filteredCommits = filterCommits(commits, { includePackages: ['@aws-cdk/aws-stable'] });\n\n    expect(filteredCommits.length).toEqual(1);\n    expect(filteredCommits[0].scope).toEqual('aws-stable');\n  });","file":"conventional-commits.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"includePackages includes commits matching variants of the scope","suites":["filterCommits"],"updatePoint":{"line":84,"column":71},"line":84,"code":"  test('includePackages includes commits matching variants of the scope', () => {\n    const stableCommits = [\n      commitWithScope('aws-stable'),\n      commitWithScope('awsstable'),\n      commitWithScope('stable'),\n      commitWithScope('notstable'),\n    ];\n\n    const filteredCommits = filterCommits(stableCommits, { includePackages: ['@aws-cdk/aws-stable'] });\n\n    expect(filteredCommits.length).toEqual(3);\n    expect(filteredCommits.map(c => c.scope)).not.toContain('notstable');\n  });","file":"conventional-commits.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"excludes criteria are run after includes","suites":["filterCommits"],"updatePoint":{"line":98,"column":48},"line":98,"code":"  test('excludes criteria are run after includes', () => {\n    const filteredCommits = filterCommits(commits, {\n      includePackages: ['@aws-cdk/aws-stable', '@aws-cdk/aws-experimental'],\n      excludePackages: ['@aws-cdk/aws-experimental'],\n    });\n\n    expect(filteredCommits.length).toEqual(1);\n    expect(filteredCommits[0].scope).toEqual('aws-stable');\n  });","file":"conventional-commits.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"scope variants take alpha packages into account","suites":["filterCommits"],"updatePoint":{"line":108,"column":55},"line":108,"code":"  test('scope variants take alpha packages into account', () => {\n    expect(createScopeVariations(['@aws-cdk/aws-batch-alpha'])).toContain('batch');\n  });","file":"conventional-commits.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"without alpha releases, only the stable changelog is returned","suites":[],"updatePoint":{"line":21,"column":67},"line":21,"code":"test('without alpha releases, only the stable changelog is returned', async () => {\n  mockReadVersion.mockImplementation((_) => { return { stableVersion: '1.2.3' }; });\n  mockChangelogOnceForVersion('1.2.3', 'foo');\n\n  await createReleaseNotes(DEFAULT_OPTS);\n\n  expectReleaseNotes('foo');\n});","file":"release-notes.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"with alpha releases the contents of both are returned as separate sections","suites":[],"updatePoint":{"line":30,"column":80},"line":30,"code":"test('with alpha releases the contents of both are returned as separate sections', async () => {\n  mockReadVersion.mockImplementation((_) => { return { stableVersion: '1.2.3', alphaVersion: '1.2.3-alpha' }; });\n  mockChangelogOnceForVersion('1.2.3', 'foo'); // stable\n  mockChangelogOnceForVersion('1.2.3-alpha', 'bar'); // alpha\n\n  await createReleaseNotes({ ...DEFAULT_OPTS, alphaChangelogFile: 'CHANGELOG.alpha.md' });\n\n  expectReleaseNotes([\n    'foo',\n    '---',\n    '## Alpha modules (1.2.3-alpha)',\n    'bar',\n  ]);\n});","file":"release-notes.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"throws if no matching version is found in the changelog","suites":[],"updatePoint":{"line":45,"column":61},"line":45,"code":"test('throws if no matching version is found in the changelog', async () => {\n  mockReadVersion.mockImplementation((_) => { return { stableVersion: '1.2.3' }; });\n  mockChangelogOnceForVersion('4.5.6', 'foo');\n\n  await expect(createReleaseNotes(DEFAULT_OPTS))\n    .rejects\n    .toThrow(/No changelog entry found for version 1.2.3 in CHANGELOG.md/);\n});","file":"release-notes.test.ts","skipped":false,"dir":"tools/@aws-cdk/cdk-release/test"},{"name":"base case","suites":["createModuleDefinitionFromCfnNamespace"],"updatePoint":{"line":6,"column":17},"line":6,"code":"  test('base case', () => {\n    const module = createModuleDefinitionFromCfnNamespace('AWS::EC2');\n\n    expect(module).toEqual({\n      namespace: 'AWS::EC2',\n      moduleName: 'aws-ec2',\n      moduleFamily: 'AWS',\n      moduleBaseName: 'EC2',\n      packageName: '@aws-cdk/aws-ec2',\n      dotnetPackage: 'Amazon.CDK.AWS.EC2',\n      javaGroupId: 'software.amazon.awscdk',\n      javaPackage: 'services.ec2',\n      javaArtifactId: 'ec2',\n      pythonDistName: 'aws-cdk.aws-ec2',\n      pythonModuleName: 'aws_cdk.aws_ec2',\n      submoduleName: 'aws_ec2',\n    });\n  });","file":"libary-creation.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"Serverless is special-cased to SAM","suites":["createModuleDefinitionFromCfnNamespace"],"updatePoint":{"line":25,"column":42},"line":25,"code":"  test('Serverless is special-cased to SAM', () => {\n    const module = createModuleDefinitionFromCfnNamespace('AWS::Serverless');\n\n    expect(module).toEqual({\n      namespace: 'AWS::Serverless',\n      moduleName: 'aws-sam',\n      moduleFamily: 'AWS',\n      moduleBaseName: 'SAM',\n      packageName: '@aws-cdk/aws-sam',\n      dotnetPackage: 'Amazon.CDK.AWS.SAM',\n      javaGroupId: 'software.amazon.awscdk',\n      javaPackage: 'services.sam',\n      javaArtifactId: 'sam',\n      pythonDistName: 'aws-cdk.aws-sam',\n      pythonModuleName: 'aws_cdk.aws_sam',\n      submoduleName: 'aws_sam',\n    });\n  });","file":"libary-creation.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"Java artifacts use different package/artifact when module family is not AWS","suites":["createModuleDefinitionFromCfnNamespace"],"updatePoint":{"line":44,"column":83},"line":44,"code":"  test('Java artifacts use different package/artifact when module family is not AWS', () => {\n    const module = createModuleDefinitionFromCfnNamespace('Alexa::ASK');\n\n    expect(module).toEqual({\n      namespace: 'Alexa::ASK',\n      moduleName: 'alexa-ask',\n      moduleFamily: 'Alexa',\n      moduleBaseName: 'ASK',\n      packageName: '@aws-cdk/alexa-ask',\n      dotnetPackage: 'Amazon.CDK.Alexa.ASK',\n      javaGroupId: 'software.amazon.awscdk',\n      javaPackage: 'alexa.ask',\n      javaArtifactId: 'alexa-ask',\n      pythonDistName: 'aws-cdk.alexa-ask',\n      pythonModuleName: 'aws_cdk.alexa_ask',\n      submoduleName: 'alexa_ask',\n    });\n  });","file":"libary-creation.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"library name is valid","suites":["createLibraryReadme"],"updatePoint":{"line":78,"column":29},"line":78,"code":"  test('library name is valid', async () => {\n    tempDir = fs.mkdtempSync(path.join(__dirname, 'temp'));\n    const readmePath = path.join(tempDir, 'README.md');\n    await createLibraryReadme('Alexa::ASK', readmePath);\n\n    const readme = fs.readFileSync(readmePath, { encoding: 'utf8' });\n    expect(readme).toContain(\"import * as alexa_ask from '@aws-cdk/alexa-ask';\");\n  });","file":"libary-creation.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"feature table is rendered","suites":["FeatureStabilityRule"],"updatePoint":{"line":20,"column":33},"line":20,"code":"  test('feature table is rendered', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          features: [\n            { name: 'Experimental Feature', stability: 'Experimental' },\n            { name: 'Stable Feature', stability: 'Stable' },\n            { name: 'Dev Preview Feature', stability: 'Developer Preview' },\n            { name: 'Not Implemented Feature', stability: 'Not Implemented' },\n          ],\n        },\n        'README.md': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n    const rule = new rules.FeatureStabilityRule();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(true);\n    pkgJson.applyFixes();\n    const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n    expect(fixedContents).toMatch(/Experimental Feature\\s* \\| \\!\\[Experimental\\]/);\n    expect(fixedContents).toMatch(/Dev Preview Feature\\s* \\| \\!\\[Developer Preview\\]/);\n    expect(fixedContents).toMatch(/Stable Feature\\s* \\| \\!\\[Stable\\]/);\n    expect(fixedContents).toMatch(/Not Implemented Feature\\s* \\| \\!\\[Not Implemented\\]/);\n    expect(fixedContents).not.toMatch(/CFN Resources/);\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"CFN Resources is rendered","suites":["FeatureStabilityRule"],"updatePoint":{"line":50,"column":33},"line":50,"code":"  test('CFN Resources is rendered', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          'cdk-build': { cloudformation: 'Foo::Bar' },\n          'features': [],\n        },\n        'README.md': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.FeatureStabilityRule();\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n    expect(pkgJson.hasReports).toBe(true);\n    pkgJson.applyFixes();\n    const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n\n    expect(fixedContents).toMatch(/CFN Resources | \\!\\[Stable\\]/);\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"CFN Resources","suites":["FeatureStabilityRule","banner notices"],"updatePoint":{"line":73,"column":23},"line":73,"code":"    test('CFN Resources', async () => {\n      fakeModule = new FakeModule({\n        files: {\n          'package.json': {\n            'cdk-build': { cloudformation: 'Foo::Bar' },\n            'features': [],\n          },\n          'README.md': '',\n        },\n      });\n      const dirPath = await fakeModule.tmpdir();\n      const rule = new rules.FeatureStabilityRule();\n\n      const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n      rule.validate(pkgJson);\n      pkgJson.applyFixes();\n\n      const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n      expect(fixedContents).toMatch(/> \\*\\*CFN Resources:\\*\\*/);\n    });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"experimental","suites":["FeatureStabilityRule","banner notices"],"updatePoint":{"line":94,"column":22},"line":94,"code":"    test('experimental', async () => {\n      fakeModule = new FakeModule({\n        files: {\n          'package.json': {\n            features: [\n              { name: 'Feature', stability: 'Experimental' },\n            ],\n          },\n          'README.md': '',\n        },\n      });\n      const dirPath = await fakeModule.tmpdir();\n      const rule = new rules.FeatureStabilityRule();\n\n      const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n      rule.validate(pkgJson);\n      pkgJson.applyFixes();\n\n      const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n      expect(fixedContents).toMatch(/> \\*\\*Experimental:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Developer Preview:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Stable:\\*\\*/);\n    });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"developer preview","suites":["FeatureStabilityRule","banner notices"],"updatePoint":{"line":118,"column":27},"line":118,"code":"    test('developer preview', async () => {\n      fakeModule = new FakeModule({\n        files: {\n          'package.json': {\n            features: [\n              { name: 'Feature', stability: 'Developer Preview' },\n            ],\n          },\n          'README.md': '',\n        },\n      });\n      const dirPath = await fakeModule.tmpdir();\n      const rule = new rules.FeatureStabilityRule();\n\n      const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n      rule.validate(pkgJson);\n      pkgJson.applyFixes();\n\n      const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n      expect(fixedContents).toMatch(/> \\*\\*Developer Preview:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Experimental:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Stable:\\*\\*/);\n    });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"stable","suites":["FeatureStabilityRule","banner notices"],"updatePoint":{"line":142,"column":16},"line":142,"code":"    test('stable', async () => {\n      fakeModule = new FakeModule({\n        files: {\n          'package.json': {\n            features: [\n              { name: 'Feature', stability: 'Stable' },\n            ],\n          },\n          'README.md': '',\n        },\n      });\n      const dirPath = await fakeModule.tmpdir();\n      const rule = new rules.FeatureStabilityRule();\n\n      const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n      rule.validate(pkgJson);\n      pkgJson.applyFixes();\n\n      const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n      expect(fixedContents).toMatch(/> \\*\\*Stable:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Experimental:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Developer Preview:\\*\\*/);\n    });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"skip if package private","suites":["FeatureStabilityRule","banner notices"],"updatePoint":{"line":167,"column":31},"line":167,"code":"  test('skip if package private', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          private: true,\n          features: [\n            { name: 'Experimental Feature', stability: 'Experimental' },\n          ],\n        },\n        'README.md': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n    const rule = new rules.FeatureStabilityRule();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"skip if features is not specified","suites":["FeatureStabilityRule","banner notices"],"updatePoint":{"line":188,"column":41},"line":188,"code":"  test('skip if features is not specified', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {},\n        'README.md': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n    const rule = new rules.FeatureStabilityRule();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"skip if README.md is missing","suites":["FeatureStabilityRule","banner notices"],"updatePoint":{"line":204,"column":36},"line":204,"code":"  test('skip if README.md is missing', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          features: [\n            { name: 'Experimental Feature', stability: 'Experimental' },\n          ],\n        },\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n    const rule = new rules.FeatureStabilityRule();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"errors when attribution missing for bundled dependencies","suites":["ThirdPartyAttributions"],"updatePoint":{"line":237,"column":64},"line":237,"code":"  test('errors when attribution missing for bundled dependencies', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          bundledDependencies: ['dep1', 'dep2'],\n        },\n        'node_modules/dep1/package.json': {},\n        'node_modules/dep2/package.json': {},\n        'NOTICE': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(true);\n    expect(pkgJson.reports.length).toEqual(2);\n    for (const report of pkgJson.reports) {\n      expect(report.ruleName).toEqual('license/3p-attributions');\n      expect(report.message).toContain('Missing attribution');\n    }\n    expect(pkgJson.reports[0].message).toContain('dep1');\n    expect(pkgJson.reports[1].message).toContain('dep2');\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"errors when there are excessive attributions","suites":["ThirdPartyAttributions"],"updatePoint":{"line":265,"column":52},"line":265,"code":"  test('errors when there are excessive attributions', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          bundledDependencies: ['dep1'],\n        },\n        'node_modules/dep1/package.json': {},\n        'NOTICE': [\n          '** dep1 - https://link-somewhere',\n          '** dep2 - https://link-elsewhere',\n          '** dep3-rev - https://link-elsewhere',\n        ].join('\\n'),\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(true);\n    expect(pkgJson.reports.length).toEqual(2);\n    for (const report of pkgJson.reports) {\n      expect(report.ruleName).toEqual('license/3p-attributions');\n      expect(report.message).toContain('Unnecessary attribution');\n    }\n    expect(pkgJson.reports[0].message).toContain('dep2');\n    expect(pkgJson.reports[1].message).toContain('dep3-rev');\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"passes when attribution is present","suites":["ThirdPartyAttributions"],"updatePoint":{"line":296,"column":42},"line":296,"code":"  test('passes when attribution is present', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          bundledDependencies: ['dep1', 'dep2'],\n        },\n        'node_modules/dep1/package.json': {},\n        'node_modules/dep2/package.json': {},\n        'NOTICE': [\n          '** dep1 - https://link-somewhere',\n          '** dep2 - https://link-elsewhere',\n        ].join('\\n'),\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"passes when attribution for transitive bundled deps are present","suites":["ThirdPartyAttributions"],"updatePoint":{"line":320,"column":71},"line":320,"code":"  test('passes when attribution for transitive bundled deps are present', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          bundledDependencies: ['dep1'],\n        },\n        'node_modules/dep1/package.json': {\n          dependencies: { dep2: '1.2.3' },\n        },\n        'node_modules/dep2/package.json': {},\n        'NOTICE': [\n          '** dep1 - https://link-somewhere',\n          '** dep2 - https://link-elsewhere',\n        ].join('\\n'),\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"fails when attribution for transitive bundled deps are missing","suites":["ThirdPartyAttributions"],"updatePoint":{"line":346,"column":70},"line":346,"code":"  test('fails when attribution for transitive bundled deps are missing', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          bundledDependencies: ['dep1'],\n        },\n        'node_modules/dep1/package.json': {\n          dependencies: { dep2: '1.2.3' },\n        },\n        'node_modules/dep2/package.json': {},\n        'NOTICE': [\n          '** dep1 - https://link-somewhere',\n        ].join('\\n'),\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(true);\n    expect(pkgJson.reports.length).toEqual(1);\n    expect(pkgJson.reports[0].ruleName).toEqual('license/3p-attributions');\n    expect(pkgJson.reports[0].message).toContain('Missing attribution');\n    expect(pkgJson.reports[0].message).toContain('dep2');\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"skipped when no bundled dependencies","suites":["ThirdPartyAttributions"],"updatePoint":{"line":375,"column":44},"line":375,"code":"  test('skipped when no bundled dependencies', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n        },\n        'NOTICE': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"skipped for private packages","suites":["ThirdPartyAttributions"],"updatePoint":{"line":393,"column":36},"line":393,"code":"  test('skipped for private packages', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          private: true,\n          bundledDependencies: ['dep1', 'dep2'],\n        },\n        'node_modules/dep1/package.json': {},\n        'node_modules/dep2/package.json': {},\n        'NOTICE': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });","file":"rules.test.ts","skipped":false,"dir":"tools/@aws-cdk/pkglint/test"},{"name":"disallow variations to \"BREAKING CHANGE:\"","suites":["breaking changes format"],"updatePoint":{"line":38,"column":49},"line":38,"code":"  test('disallow variations to \"BREAKING CHANGE:\"', async () => {\n    const issue: Subset<linter.GitHubPr> = {\n      number: 1,\n      title: 'chore: some title',\n      body: 'BREAKING CHANGES:',\n      labels: [{ name: 'pr-linter/exempt-test' }, { name: 'pr-linter/exempt-readme' }],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow(/'BREAKING CHANGE: ', variations are not allowed/);\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"the first breaking change should immediately follow \"BREAKING CHANGE:\"","suites":["breaking changes format"],"updatePoint":{"line":52,"column":78},"line":52,"code":"  test('the first breaking change should immediately follow \"BREAKING CHANGE:\"', async () => {\n    const issue = {\n      number: 1,\n      title: 'chore(cdk-build-tools): some title',\n      body: `BREAKING CHANGE:\\x20\n             * **module:** another change`,\n      labels: [{ name: 'pr-linter/exempt-test' }, { name: 'pr-linter/exempt-readme' }],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow(/description of the first breaking change should immediately follow/);\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"invalid title","suites":["breaking changes format"],"updatePoint":{"line":67,"column":21},"line":67,"code":"  test('invalid title', async () => {\n    const issue = {\n      number: 1,\n      title: 'chore(): some title',\n      body: 'BREAKING CHANGE: this breaking change',\n      labels: [{ name: 'pr-linter/exempt-test' }, { name: 'pr-linter/exempt-readme' }],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow(/The title of this pull request must specify the module name that the first breaking change should be associated to./);\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"valid title","suites":["breaking changes format"],"updatePoint":{"line":81,"column":19},"line":81,"code":"  test('valid title', async () => {\n    const issue = {\n      number: 1,\n      title: 'chore(cdk-build-tools): some title',\n      body: 'BREAKING CHANGE: this breaking change',\n      labels: [{ name: 'pr-linter/exempt-test' }, { name: 'pr-linter/exempt-readme' }],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    expect(await prLinter.validatePullRequestTarget(SHA)).resolves; // not throw\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"valid scope","suites":["commit message format"],"updatePoint":{"line":97,"column":19},"line":97,"code":"  test('valid scope', async () => {\n    const issue = {\n      number: 1,\n      title: 'chore(s3): some title',\n      body: '',\n      labels: [],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    expect(await prLinter.validatePullRequestTarget(SHA)).resolves;\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"invalid scope with aws- prefix","suites":["commit message format"],"updatePoint":{"line":111,"column":38},"line":111,"code":"  test('invalid scope with aws- prefix', async () => {\n    const issue = {\n      number: 1,\n      title: 'fix(aws-s3): some title',\n      body: '',\n      labels: [{ name: 'pr-linter/exempt-test' }, { name: 'pr-linter/exempt-integ-test' }],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow(/The title of the pull request should omit 'aws-' from the name of modified packages. Use 's3' instead of 'aws-s3'./);\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"valid scope with aws- in summary and body","suites":["commit message format"],"updatePoint":{"line":125,"column":49},"line":125,"code":"  test('valid scope with aws- in summary and body', async () => {\n    const issue = {\n      number: 1,\n      title: 'docs(s3): something aws-s3',\n      body: 'something aws-s3',\n      labels: [],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    expect(await prLinter.validatePullRequestTarget(SHA)).resolves;\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"valid with missing scope","suites":["commit message format"],"updatePoint":{"line":139,"column":32},"line":139,"code":"  test('valid with missing scope', async () => {\n    const issue = {\n      number: 1,\n      title: 'docs: something aws-s3',\n      body: '',\n      labels: [],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    expect(await prLinter.validatePullRequestTarget(SHA)).resolves;\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"valid with aws-cdk-lib as a scope","suites":["commit message format"],"updatePoint":{"line":153,"column":41},"line":153,"code":"  test('valid with aws-cdk-lib as a scope', async () => {\n    const issue = {\n      number: 1,\n      title: 'fix(aws-cdk-lib): some title',\n      body: '',\n      labels: [{ name: 'pr-linter/exempt-test' }, { name: 'pr-linter/exempt-integ-test' }],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    expect(await prLinter.validatePullRequestTarget(SHA)).resolves;\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"valid scope for packages that dont use aws- prefix","suites":["commit message format"],"line":167,"code":"  test.each(['core', 'prlint', 'awslint'])('valid scope for packages that dont use aws- prefix', async (scope) => {\n    const issue = {\n      number: 1,\n      title: `chore(${scope}): some title`,\n      body: '',\n      labels: [],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    expect(await prLinter.validatePullRequestTarget(SHA)).resolves;\n  })","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"breaking change in stable module","suites":["ban breaking changes in stable modules"],"updatePoint":{"line":183,"column":40},"line":183,"code":"  test('breaking change in stable module', async () => {\n    const issue = {\n      number: 1,\n      title: 'chore(s3): some title',\n      body: 'BREAKING CHANGE: this breaking change',\n      labels: [{ name: 'pr-linter/exempt-test' }, { name: 'pr-linter/exempt-readme' }],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow('Breaking changes in stable modules [s3] is disallowed.');\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"breaking changes multiple in stable modules","suites":["ban breaking changes in stable modules"],"updatePoint":{"line":197,"column":51},"line":197,"code":"  test('breaking changes multiple in stable modules', async () => {\n    const issue = {\n      number: 1,\n      title: 'chore(lambda): some title',\n      body: `\n        BREAKING CHANGE: this breaking change\n        continued message\n        * **ecs**: further breaking in ecs\n      `,\n      labels: [{ name: 'pr-linter/exempt-test' }, { name: 'pr-linter/exempt-readme' }],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow('Breaking changes in stable modules [lambda, ecs] is disallowed.');\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"unless exempt-breaking-change label added","suites":["ban breaking changes in stable modules"],"updatePoint":{"line":215,"column":49},"line":215,"code":"  test('unless exempt-breaking-change label added', async () => {\n    const issue = {\n      number: 1,\n      title: 'chore(lambda): some title',\n      body: `\n        BREAKING CHANGE: this breaking change\n        continued message\n      `,\n      labels: [{ name: 'pr-linter/exempt-breaking-change' }],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    expect(await prLinter.validatePullRequestTarget(SHA)).resolves; // not throw\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"with additional \"closes\" footer","suites":["ban breaking changes in stable modules"],"updatePoint":{"line":232,"column":39},"line":232,"code":"  test('with additional \"closes\" footer', async () => {\n    const issue = {\n      number: 1,\n      title: 'chore(s3): some title',\n      body: `\n        description of the commit\n\n        closes #123456789\n\n        BREAKING CHANGE: this breaking change\n      `,\n      labels: [{ name: 'pr-linter/exempt-test' }, { name: 'pr-linter/exempt-readme' }],\n      user: {\n        login: 'author',\n      },\n    };\n    const prLinter = configureMock(issue, undefined);\n    await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow('Breaking changes in stable modules [s3] is disallowed.');\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"integ files changed","suites":["integration tests required on features"],"updatePoint":{"line":254,"column":27},"line":254,"code":"  test('integ files changed', async () => {\n    const issue = {\n      number: 1,\n      title: 'feat(s3): some title',\n      body: `\n        description of the commit\n\n        closes #123456789\n      `,\n      labels: [],\n      user: {\n        login: 'author',\n      },\n    };\n    const files = [\n      {\n        filename: 'integ.some-integ-test.ts'\n      },\n      {\n        filename: 'test/some-integ-test.integ.snapshot/integ.some-test.expected.json'\n      },\n      {\n        filename: 'README.md'\n      }\n    ];\n    const prLinter = configureMock(issue, files);\n    expect(await prLinter.validatePullRequestTarget(SHA)).resolves;\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"integ files not changed in feat","suites":["integration tests required on features"],"updatePoint":{"line":283,"column":39},"line":283,"code":"  test('integ files not changed in feat', async () => {\n    const issue = {\n      number: 1,\n      title: 'feat(s3): some title',\n      body: `\n        description of the commit\n\n        closes #123456789\n      `,\n      labels: [],\n      user: {\n        login: 'author',\n      },\n    };\n    const files = [\n      {\n        filename: 'some-test.test.ts'\n      },\n      {\n        filename: 'test/some-integ-test.integ.snapshot/integ.some-test.expected.json'\n      },\n      {\n        filename: 'README.md'\n      }\n    ];\n    const prLinter = configureMock(issue, files);\n    await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow(\n      'The pull request linter fails with the following errors:' +\n      '\\n\\n\\t Features must contain a change to an integration test file and the resulting snapshot.' +\n      '\\n\\n<b>PRs must pass status checks before we can provide a meaningful review.</b>\\n\\n' +\n      'If you would like to request an exemption from the status checks or clarification on feedback,' +\n      ' please leave a comment on this PR containing `Exemption Request` and/or `Clarification Request`.'\n      );\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"integ snapshots not changed in feat","suites":["integration tests required on features"],"updatePoint":{"line":318,"column":43},"line":318,"code":"  test('integ snapshots not changed in feat', async () => {\n    const issue = {\n      number: 1,\n      title: 'feat(s3): some title',\n      body: `\n        description of the commit\n\n        closes #123456789\n      `,\n      labels: [],\n      user: {\n        login: 'author',\n      },\n    };\n    const files = [\n      {\n        filename: 'some-test.test.ts'\n      },\n      {\n        filename: 'integ.some-test.ts'\n      },\n      {\n        filename: 'README.md'\n      }\n    ];\n    const prLinter = configureMock(issue, files);\n    await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow(\n      'The pull request linter fails with the following errors:' +\n      '\\n\\n\\t Features must contain a change to an integration test file and the resulting snapshot.' +\n      '\\n\\n<b>PRs must pass status checks before we can provide a meaningful review.</b>\\n\\n' +\n      'If you would like to request an exemption from the status checks or clarification on feedback,' +\n      ' please leave a comment on this PR containing `Exemption Request` and/or `Clarification Request`.'\n      );\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"integ files not changed in fix","suites":["integration tests required on features"],"updatePoint":{"line":353,"column":38},"line":353,"code":"  test('integ files not changed in fix', async () => {\n    const issue = {\n      number: 1,\n      title: 'fix(s3): some title',\n      body: `\n        description of the commit\n\n        closes #123456789\n      `,\n      labels: [],\n      user: {\n        login: 'author',\n      },\n    };\n    const files = [\n      {\n        filename: 'some-test.test.ts'\n      },\n      {\n        filename: 'test/some-integ-test.integ.snapshot/integ.some-test.expected.json'\n      },\n      {\n        filename: 'README.md'\n      }\n    ];\n    const prLinter = configureMock(issue, files);\n    await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow(\n      'The pull request linter fails with the following errors:' +\n      '\\n\\n\\t Fixes must contain a change to an integration test file and the resulting snapshot.' +\n      '\\n\\n<b>PRs must pass status checks before we can provide a meaningful review.</b>\\n\\n' +\n      'If you would like to request an exemption from the status checks or clarification on feedback,' +\n      ' please leave a comment on this PR containing `Exemption Request` and/or `Clarification Request`.'\n      );\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"integ snapshots not changed in fix","suites":["integration tests required on features"],"updatePoint":{"line":388,"column":42},"line":388,"code":"  test('integ snapshots not changed in fix', async () => {\n    const issue = {\n      number: 1,\n      title: 'fix(s3): some title',\n      body: `\n        description of the commit\n\n        closes #123456789\n      `,\n      labels: [],\n      user: {\n        login: 'author',\n      },\n    };\n    const files = [\n      {\n        filename: 'some-test.test.ts'\n      },\n      {\n        filename: 'integ.some-test.ts'\n      },\n      {\n        filename: 'README.md'\n      }\n    ];\n    const prLinter = configureMock(issue, files);\n    await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow(\n      'The pull request linter fails with the following errors:' +\n      '\\n\\n\\t Fixes must contain a change to an integration test file and the resulting snapshot.' +\n      '\\n\\n<b>PRs must pass status checks before we can provide a meaningful review.</b>\\n\\n' +\n      'If you would like to request an exemption from the status checks or clarification on feedback,' +\n      ' please leave a comment on this PR containing `Exemption Request` and/or `Clarification Request`.'\n      );\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"integ files not changed, pr exempt","suites":["integration tests required on features"],"updatePoint":{"line":423,"column":42},"line":423,"code":"  test('integ files not changed, pr exempt', async () => {\n    const issue = {\n      number: 1,\n      title: 'feat(s3): some title',\n      body: `\n        description of the commit\n\n        closes #123456789\n      `,\n      labels: [{ name: 'pr-linter/exempt-integ-test' }],\n      user: {\n        login: 'author',\n      },\n    };\n    const files = [\n      {\n        filename: 'some-test.test.ts'\n      },\n      {\n        filename: 'README.md'\n      }\n    ];\n    const prLinter = configureMock(issue, files);\n    expect(await prLinter.validatePullRequestTarget(SHA)).resolves;\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"integ files not changed, not a feature","suites":["integration tests required on features"],"updatePoint":{"line":449,"column":46},"line":449,"code":"  test('integ files not changed, not a feature', async () => {\n    const issue = {\n      number: 1,\n      title: 'chore(s3): some title',\n      body: `\n        description of the commit\n\n        closes #123456789\n      `,\n      labels: [],\n      user: {\n        login: 'author',\n      },\n    };\n    const files = [\n      {\n        filename: 'some-test.test.ts'\n      },\n      {\n        filename: 'readme.md'\n      }\n    ];\n    const prlinter = configureMock(issue, files);\n    expect(await prlinter.validatePullRequestTarget(SHA)).resolves;\n  });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"no label throws error","suites":["integration tests required on features","CLI file changed"],"updatePoint":{"line":491,"column":31},"line":491,"code":"    test('no label throws error', async () => {\n      const prLinter = configureMock(issue, files);\n      await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow(/CLI code has changed. A maintainer must/);\n    });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"with label no error","suites":["integration tests required on features","CLI file changed"],"updatePoint":{"line":496,"column":29},"line":496,"code":"    test('with label no error', async () => {\n      labels.push({ name: 'pr-linter/cli-integ-tested' });\n      const prLinter = configureMock(issue, files);\n      await prLinter.validatePullRequestTarget(SHA);\n      // THEN: no exception\n    });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"with aws-cdk-automation author","suites":["integration tests required on features","CLI file changed"],"updatePoint":{"line":503,"column":40},"line":503,"code":"    test('with aws-cdk-automation author', async () => {\n      // GIVEN: Remove exemption\n      labels.pop();\n      // Verify no labels added\n      expect(labels).toEqual([]);\n      issue.user.login = 'aws-cdk-automation';\n\n      // WHEN\n      const prLinter = configureMock(issue, files);\n      await prLinter.validatePullRequestTarget(SHA);\n      // THEN: no exception\n    })","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"needs a review","suites":["integration tests required on features","assess needs review from status event"],"updatePoint":{"line":532,"column":24},"line":532,"code":"    test('needs a review', async () => {\n      // WHEN\n      const prLinter = configureMock(pr);\n      await prLinter.validateStatusEvent(pr as any, {\n        sha: SHA,\n        context: linter.CODE_BUILD_CONTEXT,\n        state: 'success',\n      } as any);\n\n      // THEN\n      expect(mockAddLabel.mock.calls[0][0]).toEqual({\n        \"issue_number\": 1234,\n        \"labels\": [\"pr/needs-review\"],\n        \"owner\": \"aws\",\n        \"repo\": \"aws-cdk\",\n      });\n      expect(mockRemoveLabel.mock.calls).toEqual([]);\n    });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"does not need a review because of request changes","suites":["integration tests required on features","assess needs review from status event"],"updatePoint":{"line":551,"column":59},"line":551,"code":"    test('does not need a review because of request changes', async () => {\n      // GIVEN\n      mockListReviews.mockImplementation(() => {\n        return {\n          data: [{ id: 1111122222, user: { login: 'aws-cdk-automation' }, state: 'CHANGES_REQUESTED' }]\n        }\n      });\n      (pr as any).labels = [\n        {\n          name: 'pr/needs-review',\n        }\n      ];\n\n      // WHEN\n      const prLinter = configureMock(pr);\n      await prLinter.validateStatusEvent(pr as any, {\n        sha: SHA,\n        context: linter.CODE_BUILD_CONTEXT,\n        state: 'success',\n      } as any);\n\n      // THEN\n      expect(mockRemoveLabel.mock.calls[0][0]).toEqual({\n        \"issue_number\": 1234,\n        \"name\": \"pr/needs-review\",\n        \"owner\": \"aws\",\n        \"repo\": \"aws-cdk\",\n      });\n      expect(mockAddLabel.mock.calls).toEqual([]);\n    });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"needs a review because of exemption request","suites":["integration tests required on features","assess needs review from status event"],"updatePoint":{"line":582,"column":53},"line":582,"code":"    test('needs a review because of exemption request', async () => {\n      // GIVEN\n      mockListReviews.mockImplementation(() => {\n        return {\n          data: [{ id: 1111122222, user: { login: 'aws-cdk-automation' }, state: 'CHANGES_REQUESTED' }]\n        }\n      });\n      (pr as any).labels = [\n        {\n          name: 'pr-linter/exemption-requested',\n        }\n      ];\n\n      // WHEN\n      const prLinter = configureMock(pr);\n      await prLinter.validateStatusEvent(pr as any, {\n        sha: SHA,\n        context: linter.CODE_BUILD_CONTEXT,\n        state: 'success',\n      } as any);\n\n      // THEN\n      expect(mockAddLabel.mock.calls[0][0]).toEqual({\n        \"issue_number\": 1234,\n        \"labels\": [\"pr/needs-review\"],\n        \"owner\": \"aws\",\n        \"repo\": \"aws-cdk\",\n      });\n      expect(mockRemoveLabel.mock.calls).toEqual([]);\n    });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"does not need a review if member has requested changes","suites":["integration tests required on features","assess needs review from status event"],"updatePoint":{"line":613,"column":64},"line":613,"code":"    test('does not need a review if member has requested changes', async () => {\n      // GIVEN\n      mockListReviews.mockImplementation(() => {\n        return {\n          data: [\n            { id: 1111122222, user: { login: 'aws-cdk-automation' }, state: 'CHANGES_REQUESTED' },\n            { id: 1111122223, user: { login: 'someuser' }, author_association: 'MEMBER', state: 'CHANGES_REQUESTED' },\n          ]\n        }\n      });\n      (pr as any).labels = [\n        {\n          name: 'pr-linter/exemption-requested',\n        },\n        {\n          name: 'pr/needs-review',\n        }\n      ];\n\n      // WHEN\n      const prLinter = configureMock(pr);\n      await prLinter.validateStatusEvent(pr as any, {\n        sha: SHA,\n        context: linter.CODE_BUILD_CONTEXT,\n        state: 'success',\n      } as any);\n\n      // THEN\n      expect(mockRemoveLabel.mock.calls[0][0]).toEqual({\n        \"issue_number\": 1234,\n        \"name\": \"pr/needs-review\",\n        \"owner\": \"aws\",\n        \"repo\": \"aws-cdk\",\n      });\n      expect(mockAddLabel.mock.calls).toEqual([]);\n    });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"does not need a review if member has approved","suites":["integration tests required on features","assess needs review from status event"],"updatePoint":{"line":650,"column":55},"line":650,"code":"    test('does not need a review if member has approved', async () => {\n      // GIVEN\n      mockListReviews.mockImplementation(() => {\n        return {\n          data: [\n            { id: 1111122223, user: { login: 'someuser' }, author_association: 'MEMBER', state: 'APPROVED' },\n          ]\n        }\n      });\n      (pr as any).labels = [\n        {\n          name: 'pr/needs-review',\n        }\n      ];\n\n      // WHEN\n      const prLinter = configureMock(pr);\n      await prLinter.validateStatusEvent(pr as any, {\n        sha: SHA,\n        context: linter.CODE_BUILD_CONTEXT,\n        state: 'success',\n      } as any);\n\n      // THEN\n      expect(mockRemoveLabel.mock.calls[0][0]).toEqual({\n        \"issue_number\": 1234,\n        \"name\": \"pr/needs-review\",\n        \"owner\": \"aws\",\n        \"repo\": \"aws-cdk\",\n      });\n      expect(mockAddLabel.mock.calls).toEqual([]);\n    });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"review happens even if linter fails","suites":["integration tests required on features","assess needs review from status event"],"updatePoint":{"line":683,"column":45},"line":683,"code":"    test('review happens even if linter fails', async () => {\n      // GIVEN\n      mockListReviews.mockImplementation(() => {\n        return {\n          data: [\n            { id: 1111122222, user: { login: 'aws-cdk-automation' }, state: 'CHANGES_REQUESTED' },\n            { id: 1111122223, user: { login: 'someuser' }, author_association: 'MEMBER', state: 'CHANGES_REQUESTED' },\n          ]\n        }\n      });\n      (pr as any).title = 'blah';\n      (pr as any).labels = [\n        {\n          name: 'pr-linter/exemption-requested',\n        },\n        {\n          name: 'pr/needs-review',\n        }\n      ];\n\n      // WHEN\n      const prLinter = configureMock(pr);\n      await expect(prLinter.validatePullRequestTarget(SHA)).rejects.toThrow();\n\n      // THEN\n      expect(mockRemoveLabel.mock.calls[0][0]).toEqual({\n        \"issue_number\": 1234,\n        \"name\": \"pr/needs-review\",\n        \"owner\": \"aws\",\n        \"repo\": \"aws-cdk\",\n      });\n      expect(mockAddLabel.mock.calls).toEqual([]);\n    });","file":"lint.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"single fuzzy match","suites":["findModulePath"],"updatePoint":{"line":17,"column":26},"line":17,"code":"  test('single fuzzy match', () => {\n    expect(relative(findModulePath('lambda'))).toEqual('packages/aws-cdk-lib');\n    expect(relative(findModulePath('s3'))).toEqual('packages/aws-cdk-lib');\n    expect(relative(findModulePath('gamelift'))).toEqual('packages/@aws-cdk/aws-gamelift-alpha');\n    expect(relative(findModulePath('cdk-build-tools'))).toEqual('tools/@aws-cdk/cdk-build-tools');\n  });","file":"module.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"multiple fuzzy matches","suites":["findModulePath"],"updatePoint":{"line":24,"column":30},"line":24,"code":"  test('multiple fuzzy matches', () => {\n    // also matches 'packages/aws-cdk' and 'tools/eslint-plugin-cdk'\n    expect(relative(findModulePath('cdk'))).toEqual('packages/cdk');\n  });","file":"module.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"no matches","suites":["findModulePath"],"updatePoint":{"line":29,"column":18},"line":29,"code":"  test('no matches', () => {\n    expect(() => findModulePath('doesnotexist')).toThrow(/No module/);\n  });","file":"module.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"happy","suites":["moduleStability"],"updatePoint":{"line":39,"column":13},"line":39,"code":"  test('happy', () => {\n    expect(moduleStability(absolute('packages/aws-cdk-lib'))).toEqual('stable');\n\n    // The list of experimental modules is constantly changing. Comment out the assertion.\n    // expect(moduleStability(absolute('packages/@aws-cdk/aws-apigatewayv2'))).toEqual('experimental');\n\n    expect(moduleStability(absolute('tools/@aws-cdk/cdk-build-tools'))).toBeUndefined();\n  });","file":"module.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"error","suites":["moduleStability"],"updatePoint":{"line":48,"column":13},"line":48,"code":"  test('error', () => {\n    expect(() => moduleStability(absolute('tools'))).toThrow(/no package.json found/);\n  });","file":"module.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"no breakages","suites":["breakingModules"],"updatePoint":{"line":4,"column":20},"line":4,"code":"  test('no breakages', () => {\n    const title = 'feat(m1): this is not a breaking change';\n    const body = 'a regular description';\n\n    expect(breakingModules(title, body)).toEqual([]);\n  });","file":"parser.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"main module breaks","suites":["breakingModules"],"updatePoint":{"line":11,"column":26},"line":11,"code":"  test('main module breaks', () => {\n    const title = 'feat(m1): this is a breaking change';\n    const body = `\n    a breaking change description\n    BREAKING CHANGE: unintended breaking change\n    `;\n\n    expect(breakingModules(title, body)).toEqual(['m1']);\n  });","file":"parser.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"multiple breaking changes","suites":["breakingModules"],"updatePoint":{"line":21,"column":33},"line":21,"code":"  test('multiple breaking changes', () => {\n    const title = 'feat(m1): this is a breaking change';\n    const body = `\n    a breaking change description\n    BREAKING CHANGE: unintended breaking change\n    continued message\n    * **m2**: Another breaking change here\n    continuing again\n    `;\n\n    expect(breakingModules(title, body)).toEqual(['m1', 'm2']);\n  });","file":"parser.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"additional footer","suites":["breakingModules"],"updatePoint":{"line":34,"column":25},"line":34,"code":"  test('additional footer', () => {\n    const title = 'feat(m1): this is a breaking change';\n    const body = `\n    a breaking change description\n    closes #123456789\n    BREAKING CHANGE: unintended breaking change\n    `;\n\n    expect(breakingModules(title, body)).toEqual(['m1']);\n  });","file":"parser.test.ts","skipped":false,"dir":"tools/@aws-cdk/prlint/test"},{"name":"generate lock for fixture directory","suites":[],"updatePoint":{"line":4,"column":41},"line":4,"code":"test('generate lock for fixture directory', async () => {\n  const lockFile = await generateShrinkwrap({\n    packageJsonFile: path.join(__dirname, 'test-fixture', 'jsii', 'package.json'),\n    hoist: false,\n  });\n\n  expect(lockFile).toEqual({\n    lockfileVersion: 1,\n    name: 'jsii',\n    requires: true,\n    version: '1.1.1',\n    dependencies: {\n      'cdk': {\n        version: '2.2.2',\n      },\n      'aws-cdk': {\n        dependencies: {\n          'aws-cdk-lib': {\n            integrity: 'sha512-pineapple',\n            resolved: 'https://registry.bla.com/stuff',\n            version: '2.3.999',\n          },\n        },\n        integrity: 'sha512-banana',\n        requires: {\n          'aws-cdk-lib': '^2.3.4',\n        },\n        resolved: 'https://registry.bla.com/stuff',\n        version: '1.2.999',\n      },\n    },\n  });\n});","file":"cling.test.ts","skipped":false,"dir":"tools/@aws-cdk/yarn-cling/test"},{"name":"generate hoisted lock for fixture directory","suites":[],"updatePoint":{"line":38,"column":49},"line":38,"code":"test('generate hoisted lock for fixture directory', async () => {\n  const lockFile = await generateShrinkwrap({\n    packageJsonFile: path.join(__dirname, 'test-fixture', 'jsii', 'package.json'),\n    hoist: true,\n  });\n\n  expect(lockFile).toEqual({\n    lockfileVersion: 1,\n    name: 'jsii',\n    requires: true,\n    version: '1.1.1',\n    dependencies: {\n      'cdk': {\n        version: '2.2.2',\n      },\n      'aws-cdk': {\n        integrity: 'sha512-banana',\n        requires: {\n          'aws-cdk-lib': '^2.3.4',\n        },\n        resolved: 'https://registry.bla.com/stuff',\n        version: '1.2.999',\n      },\n      'aws-cdk-lib': {\n        integrity: 'sha512-pineapple',\n        resolved: 'https://registry.bla.com/stuff',\n        version: '2.3.999',\n      },\n    },\n  });\n});","file":"cling.test.ts","skipped":false,"dir":"tools/@aws-cdk/yarn-cling/test"},{"name":"fail when requires cannot be satisfied","suites":[],"updatePoint":{"line":70,"column":44},"line":70,"code":"test('fail when requires cannot be satisfied', async () => {\n  const lockFile = {\n    lockfileVersion: 1,\n    name: 'jsii',\n    requires: true,\n    version: '1.1.1',\n    dependencies: {\n      jsii: {\n        version: '2.2.2',\n        requires: {\n          cdk: '^3.3.3', // <- this needs to be adjusted\n        },\n      },\n      cdk: {\n        version: '4.4.4',\n      },\n    },\n  };\n\n  expect(() => checkRequiredVersions(lockFile)).toThrow(/This can never/);\n});","file":"cling.test.ts","skipped":false,"dir":"tools/@aws-cdk/yarn-cling/test"},{"name":"nonconflicting tree gets flattened","suites":[],"updatePoint":{"line":6,"column":40},"line":6,"code":"test('nonconflicting tree gets flattened', () => {\n  // GIVEN\n  const tree: DependencyTree = pkg('*', {\n    stringutil: {\n      version: '1.0.0',\n      dependencies: {\n        leftpad: { version: '2.0.0' },\n      },\n    },\n    numutil: {\n      version: '3.0.0',\n      dependencies: {\n        isodd: { version: '4.0.0' },\n      },\n    },\n  });\n\n  // WHEN\n  hoistDependencies(tree);\n\n  // THEN\n  expect(renderTree(tree)).toEqual([\n    'isodd=4.0.0',\n    'leftpad=2.0.0',\n    'numutil=3.0.0',\n    'stringutil=1.0.0',\n  ]);\n});","file":"hoisting.test.ts","skipped":false,"dir":"tools/@aws-cdk/yarn-cling/test"},{"name":"matching versions get deduped","suites":[],"updatePoint":{"line":35,"column":35},"line":35,"code":"test('matching versions get deduped', () => {\n  // GIVEN\n  const tree: DependencyTree = pkg('*', {\n    stringutil: {\n      version: '1.0.0',\n      dependencies: {\n        leftpad: { version: '2.0.0' },\n      },\n    },\n    numutil: {\n      version: '3.0.0',\n      dependencies: {\n        leftpad: { version: '2.0.0' },\n        isodd: { version: '4.0.0' },\n      },\n    },\n  });\n\n  // WHEN\n  hoistDependencies(tree);\n\n  // THEN\n  expect(renderTree(tree)).toEqual([\n    'isodd=4.0.0',\n    'leftpad=2.0.0',\n    'numutil=3.0.0',\n    'stringutil=1.0.0',\n  ]);\n});","file":"hoisting.test.ts","skipped":false,"dir":"tools/@aws-cdk/yarn-cling/test"},{"name":"conflicting versions get left in place","suites":[],"updatePoint":{"line":65,"column":44},"line":65,"code":"test('conflicting versions get left in place', () => {\n  // GIVEN\n  const tree: DependencyTree = pkg('*', {\n    stringutil: {\n      version: '1.0.0',\n      dependencies: {\n        leftpad: { version: '2.0.0' },\n      },\n    },\n    numutil: {\n      version: '3.0.0',\n      dependencies: {\n        leftpad: { version: '5.0.0' },\n        isodd: { version: '4.0.0' },\n      },\n    },\n  });\n\n  // WHEN\n  hoistDependencies(tree);\n\n  // THEN\n  expect(renderTree(tree)).toEqual([\n    'isodd=4.0.0',\n    'leftpad=2.0.0',\n    'numutil=3.0.0',\n    'numutil.leftpad=5.0.0',\n    'stringutil=1.0.0',\n  ]);\n});","file":"hoisting.test.ts","skipped":false,"dir":"tools/@aws-cdk/yarn-cling/test"},{"name":"dependencies of deduped packages are not hoisted into useless positions","suites":[],"updatePoint":{"line":96,"column":77},"line":96,"code":"test('dependencies of deduped packages are not hoisted into useless positions', () => {\n  // GIVEN\n  const tree: DependencyTree = pkg('*', {\n    stringutil: pkg('1.0.0', {\n      leftpad: pkg('2.0.0', {\n        spacemaker: pkg('3.0.0'),\n      }),\n    }),\n    leftpad: pkg('2.0.0', {\n      spacemaker: pkg('3.0.0'),\n    }),\n    spacemaker: pkg('4.0.0'),\n  });\n\n  // WHEN\n  hoistDependencies(tree);\n\n  // THEN\n  expect(renderTree(tree)).toEqual([\n    'leftpad=2.0.0',\n    'leftpad.spacemaker=3.0.0',\n    'spacemaker=4.0.0',\n    'stringutil=1.0.0',\n  ]);\n});","file":"hoisting.test.ts","skipped":false,"dir":"tools/@aws-cdk/yarn-cling/test"},{"name":"dont hoist into a parent if it would cause an incorrect version there","suites":[],"updatePoint":{"line":122,"column":75},"line":122,"code":"test('dont hoist into a parent if it would cause an incorrect version there', () => {\n  // GIVEN\n  const tree: DependencyTree = pkg('*', {\n    stringutil: pkg('1.0.0', {\n      spacemaker: pkg('10.0.0'),\n      leftPad: pkg('2.0.0', {\n        spacemaker: pkg('3.0.0'),\n      }),\n    }),\n    leftPad: pkg('1.0.0'), // Prevents previous leftPad from being hoisted\n  });\n\n  // WHEN\n  hoistDependencies(tree);\n\n  // THEN\n  expect(renderTree(tree)).toEqual([\n    'leftPad=1.0.0',\n    'spacemaker=10.0.0',\n    'stringutil=1.0.0',\n    'stringutil.leftPad=2.0.0',\n    'stringutil.leftPad.spacemaker=3.0.0',\n  ]);\n});","file":"hoisting.test.ts","skipped":false,"dir":"tools/@aws-cdk/yarn-cling/test"},{"name":"order of hoisting shouldnt produce a broken situation","suites":[],"updatePoint":{"line":147,"column":59},"line":147,"code":"test('order of hoisting shouldnt produce a broken situation', () => {\n  // GIVEN\n  const tree: DependencyTree = pkg('*', {\n    stringutil: pkg('1.0.0', {\n      wrapper: pkg('100.0.0', {\n        leftPad: pkg('2.0.0', {\n          spacemaker: pkg('3.0.0'),\n        }),\n      }),\n      spacemaker: pkg('4.0.0'), // Prevents spacemaker from being hoisted here, but then leftPad also shouldn't be\n    }),\n  });\n\n  // WHEN\n  hoistDependencies(tree);\n\n  // THEN\n  /* // Both answers are fine but the current algorithm picks the 2nd\n  expect(renderTree(tree)).toEqual([\n    'leftPad=2.0.0',\n    'spacemaker=3.0.0',\n    'stringutil=1.0.0',\n    'stringutil.spacemaker=4.0.0',\n    'wrapper=100.0.0',\n  ]);\n  */\n  expect(renderTree(tree)).toEqual([\n    'leftPad=2.0.0',\n    'leftPad.spacemaker=3.0.0',\n    'spacemaker=4.0.0',\n    'stringutil=1.0.0',\n    'wrapper=100.0.0',\n  ]);\n});","file":"hoisting.test.ts","skipped":false,"dir":"tools/@aws-cdk/yarn-cling/test"}]}