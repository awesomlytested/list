{"repo":"solidjs/solid","url":"https://github.com/solidjs/solid","branch":"main","configs":[{"package":"solid-js","lang":"ts","dir":"packages/solid/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"solid-js/store","lang":"ts","dir":"packages/solid/store/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"solid-js/web","lang":"js","dir":"packages/solid/web/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"test-integration","lang":"ts","dir":"packages/test-integration/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"simple mapArray","suites":["Map operator"],"updatePoint":{"line":4,"column":23},"line":4,"code":"  test(\"simple mapArray\", () => {\n    createRoot(() => {\n      const [s, set] = createSignal([1, 2, 3, 4]),\n        r = createMemo(mapArray(s, v => v * 2));\n      expect(r()).toEqual([2, 4, 6, 8]);\n      set([3, 4, 5]);\n      expect(r()).toEqual([6, 8, 10]);\n    });\n  });","file":"array.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"show fallback","suites":["Map operator"],"updatePoint":{"line":14,"column":21},"line":14,"code":"  test(\"show fallback\", () => {\n    createRoot(() => {\n      const [s, set] = createSignal([1, 2, 3, 4]),\n        double = mapArray<number, number | string>(s, v => v * 2, {\n          fallback: () => \"Empty\"\n        }),\n        r = createMemo(double);\n      expect(r()).toEqual([2, 4, 6, 8]);\n      set([]);\n      expect(r()).toEqual([\"Empty\"]);\n      set([3, 4, 5]);\n      expect(r()).toEqual([6, 8, 10]);\n    });\n  });","file":"array.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple indexArray","suites":["Index operator"],"updatePoint":{"line":31,"column":25},"line":31,"code":"  test(\"simple indexArray\", () => {\n    createRoot(() => {\n      const [s, set] = createSignal([1, 2, 3, 4]),\n        r = createMemo(indexArray(s, v => v() * 2));\n      expect(r()).toEqual([2, 4, 6, 8]);\n    });\n  });","file":"array.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"show fallback","suites":["Index operator"],"updatePoint":{"line":40,"column":21},"line":40,"code":"  test(\"show fallback\", () => {\n    createRoot(() => {\n      const [s, set] = createSignal([1, 2, 3, 4]),\n        double = indexArray<number, number | string>(s, v => v() * 2, {\n          fallback: () => \"Empty\"\n        }),\n        r = createMemo(double);\n      expect(r()).toEqual([2, 4, 6, 8]);\n      set([]);\n      expect(r()).toEqual([\"Empty\"]);\n      set([3, 4, 5]);\n      expect(r()).toEqual([6, 8, 10]);\n    });\n  });","file":"array.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"create simple component","suites":["CreateComponent"],"updatePoint":{"line":27,"column":31},"line":27,"code":"  test(\"create simple component\", () => {\n    createRoot(() => {\n      const out = createComponent(Comp, {\n        greeting: \"Hi\",\n        get name() {\n          return \"dynamic\";\n        }\n      });\n      expect(out).toBe(\"Hi dynamic\");\n    });\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple set","suites":["Set Default Props"],"updatePoint":{"line":41,"column":18},"line":41,"code":"  test(\"simple set\", () => {\n    let props: SimplePropTypes = {\n        get a() {\n          return \"ji\";\n        },\n        b: null,\n        c: \"j\"\n      },\n      defaults: SimplePropTypes = { a: \"yy\", b: \"ggg\", d: \"DD\" };\n    props = mergeProps(defaults, props);\n    expect(props.a).toBe(\"ji\");\n    expect(props.b).toBe(null);\n    expect(props.c).toBe(\"j\");\n    expect(props.d).toBe(\"DD\");\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple set","suites":["Clone Props"],"updatePoint":{"line":59,"column":18},"line":59,"code":"  test(\"simple set\", () => {\n    let reactive = false;\n    const props: SimplePropTypes = {\n      get a() {\n        reactive = true;\n        return \"ji\";\n      },\n      b: null,\n      c: \"j\"\n    };\n    const newProps = mergeProps({}, props);\n    expect(reactive).toBe(false);\n    expect(newProps.a).toBe(\"ji\");\n    expect(reactive).toBe(true);\n    expect(newProps.b).toBe(null);\n    expect(newProps.c).toBe(\"j\");\n    expect(newProps.d).toBe(undefined);\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple set","suites":["Merge Signal"],"updatePoint":{"line":91,"column":18},"line":91,"code":"  test(\"simple set\", () => {\n    const [s, set] = createSignal<SimplePropTypes>({\n        get a() {\n          return \"ji\";\n        },\n        b: null,\n        c: \"j\"\n      }),\n      defaults: SimplePropTypes = { a: \"yy\", b: \"ggg\", d: \"DD\" };\n    const props = mergeProps(defaults, s);\n    const res: string[] = [];\n    createRoot(() => {\n      createComputed(() => {\n        res.push(props.a as string);\n      });\n    });\n    expect(props.a).toBe(\"ji\");\n    expect(props.b).toBe(null);\n    expect(props.c).toBe(\"j\");\n    expect(props.d).toBe(\"DD\");\n    set({ a: \"h\" });\n    expect(props.a).toBe(\"h\");\n    expect(props.b).toBe(\"ggg\");\n    expect(props.c).toBeUndefined();\n    expect(props.d).toBe(\"DD\");\n    expect(res[0]).toBe(\"ji\");\n    expect(res[1]).toBe(\"h\");\n    expect(res.length).toBe(2);\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"SplitProps in two","suites":["SplitProps Props"],"updatePoint":{"line":123,"column":25},"line":123,"code":"  test(\"SplitProps in two\", () => {\n    createRoot(() => {\n      const out = createComponent(Comp2, {\n        greeting: \"Hi\",\n        get name() {\n          return \"dynamic\";\n        }\n      });\n      expect(out).toBe(\"Hi dynamic\");\n    });\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"creating some","suites":["createUniqueId"],"updatePoint":{"line":137,"column":21},"line":137,"code":"  test(\"creating some\", () => {\n    const id1 = createUniqueId();\n    const id2 = createUniqueId();\n\n    expect(id1).toBeDefined();\n    expect(id2).toBeDefined();\n    expect(id1).not.toEqual(id2);\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Reactive graph serialization","suites":["Dev features"],"updatePoint":{"line":12,"column":36},"line":12,"code":"  test(\"Reactive graph serialization\", () => {\n    let owner: ReturnType<typeof getOwner>, set1: (v: number) => number, setState1: any;\n\n    const SNAPSHOTS = [\n      `{\"s1773325850\":5,\"s1773325850-1\":5,\"c-1\":{\"explicit\":6},\"CustomComponent:c-2\":{\"s533736025\":{\"firstName\":\"John\",\"lastName\":\"Smith\"}}}`,\n      `{\"s1773325850\":7,\"s1773325850-1\":5,\"c-1\":{\"explicit\":6},\"CustomComponent:c-2\":{\"s533736025\":{\"firstName\":\"Matt\",\"lastName\":\"Smith\",\"middleInitial\":\"R.\"}}}`\n    ];\n    const CustomComponent = () => {\n      const [state, setState] = createStore({ firstName: \"John\", lastName: \"Smith\" });\n      setState1 = setState;\n      return \"\";\n    }\n    createRoot(() => {\n      owner = getOwner();\n      const [s, set] = createSignal(5);\n      const [s2] = createSignal(5);\n      createEffect(() => {\n        const [s] = createSignal(6, { name: \"explicit\" });\n      });\n      createComponent(CustomComponent, {});\n      set1 = set;\n    });\n    expect(JSON.stringify(DEV.serializeGraph(owner!))).toBe(SNAPSHOTS[0]);\n    set1!(7);\n    setState1({ middleInitial: \"R.\", firstName: \"Matt\" });\n    expect(JSON.stringify(DEV.serializeGraph(owner!))).toBe(SNAPSHOTS[1]);\n  });","file":"dev.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"AfterUpdate Hook","suites":["Dev features"],"updatePoint":{"line":40,"column":24},"line":40,"code":"  test(\"AfterUpdate Hook\", () => {\n    let triggered = 0;\n    let set1: (v: number) => number, setState1: any;\n    global._$afterUpdate = () => triggered++;\n    createRoot(() => {\n      const [s, set] = createSignal(5);\n      const [s2] = createSignal(5);\n      createEffect(() => {\n        const [s] = createSignal(6, { name: \"explicit\" });\n      });\n      const [state, setState] = createStore({ firstName: \"John\", lastName: \"Smith\" });\n      createEffect(() => {\n        s();\n        s2();\n        state.firstName;\n      });\n      set1 = set;\n      setState1 = setState;\n    });\n    expect(triggered).toBe(1);\n    set1!(7);\n    expect(triggered).toBe(2);\n    setState1({ middleInitial: \"R.\", firstName: \"Matt\" });\n    expect(triggered).toBe(3);\n  })","file":"dev.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"should trigger solid primitive update","suites":["external source"],"updatePoint":{"line":62,"column":43},"line":62,"code":"  it(\"should trigger solid primitive update\", () => {\n    createRoot(fn => {\n      const e = new ExternalSource(0);\n      const memo = createMemo(() => {\n        return e.get();\n      });\n      expect(memo()).toBe(0);\n      e.update(1);\n      expect(memo()).toBe(1);\n      fn();\n    });\n  });","file":"external-source.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"to observable","suites":["Observable operator"],"updatePoint":{"line":4,"column":21},"line":4,"code":"  test(\"to observable\", () => {\n    let out: string;\n    let set: (v: string) => void;\n    createRoot(() => {\n      const [s, _set] = createSignal(\"Hi\"),\n        obsv$ = observable(s);\n\n      set = _set;\n      obsv$.subscribe({ next: v => (out = v) });\n    });\n    expect(out!).toBe(\"Hi\");\n    set!(\"John\");\n    expect(out!).toBe(\"John\");\n  });","file":"observable.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"preserve the observer's next binding","suites":["Observable operator"],"updatePoint":{"line":19,"column":44},"line":19,"code":"  test(\"preserve the observer's next binding\", () => {\n    const observer = {\n      next: jest.fn().mockReturnThis(),\n    };\n\n    createRoot(() => {\n      const [s] = createSignal(\"Hi\"),\n        obsv$ = observable(s);\n\n      obsv$.subscribe(observer);\n    });\n    expect(observer.next).toHaveReturnedWith(observer);\n  })","file":"observable.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"from subscribable","suites":["from transform"],"updatePoint":{"line":35,"column":25},"line":35,"code":"  test(\"from subscribable\", async () => {\n    let out: () => string;\n    let set: (v: string) => void;\n    createRoot(() => {\n      const [s, _set] = createSignal(\"Hi\"),\n        obsv$ = observable(s);\n\n      set = _set;\n      out = from(obsv$);\n    });\n    expect(out!()).toBe(\"Hi\");\n    set!(\"John\");\n    expect(out!()).toBe(\"John\");\n  });","file":"observable.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"from producer","suites":["from transform"],"updatePoint":{"line":50,"column":21},"line":50,"code":"  test(\"from producer\", async () => {\n    let out: () => string;\n    let set: (v: string) => void;\n    createRoot(() => {\n      const [s, _set] = createSignal(\"Hi\"),\n        obsv$ = observable(s);\n\n      set = _set;\n      out = from((set) => {\n        const sub = obsv$.subscribe(set);\n        return () => sub.unsubscribe()\n      });\n    });\n    expect(out!()).toBe(\"Hi\");\n    set!(\"John\");\n    expect(out!()).toBe(\"John\");\n  });","file":"observable.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"initial async resource","suites":["Simulate a dynamic fetch"],"updatePoint":{"line":30,"column":30},"line":30,"code":"  test(\"initial async resource\", async done => {\n    createRoot(() => {\n      const [id, setId] = createSignal(\"1\");\n      trigger = setId;\n      onError(e => (error = e));\n      [value] = createResource(id, fetcher);\n      createRenderEffect(value);\n    });\n    expect(value()).toBeUndefined();\n    expect(value.loading).toBe(true);\n    resolve(\"John\");\n    await Promise.resolve();\n    expect(value()).toBe(\"John\");\n    expect(value.loading).toBe(false);\n    done();\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"test out of order","suites":["Simulate a dynamic fetch"],"updatePoint":{"line":47,"column":25},"line":47,"code":"  test(\"test out of order\", async done => {\n    trigger(\"2\");\n    expect(value.loading).toBe(true);\n    const resolve1 = resolve;\n    trigger(\"3\");\n    const resolve2 = resolve;\n    resolve2(\"Jake\");\n    resolve1(\"Jo\");\n    await Promise.resolve();\n    expect(value()).toBe(\"Jake\");\n    expect(value.loading).toBe(false);\n    done();\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"promise rejection","suites":["Simulate a dynamic fetch"],"updatePoint":{"line":61,"column":25},"line":61,"code":"  test(\"promise rejection\", async done => {\n    trigger(\"4\");\n    expect(value.loading).toBe(true);\n    expect(value.error).toBeUndefined();\n    reject(\"Because I said so\");\n    await Promise.resolve();\n    expect(error).toBe(\"Because I said so\");\n    expect(value.error).toBe(\"Because I said so\");\n    expect(value.loading).toBe(false);\n    done();\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"initial async resource refetch","suites":["Simulate a dynamic fetch"],"updatePoint":{"line":86,"column":38},"line":86,"code":"  test(\"initial async resource refetch\", async done => {\n    createRoot(() => {\n      const [id, setId] = createSignal(\"1\");\n      trigger = setId;\n      onError(e => (error = e));\n      [value] = createResource(id, fetcher);\n      createRenderEffect(value);\n    });\n    expect(value()).toBeUndefined();\n    expect(value.loading).toBe(true);\n    resolve(\"John\");\n    await Promise.resolve();\n    expect(value()).toBe(\"John\");\n    expect(value.loading).toBe(false);\n    refetchResources();\n    expect(value.loading).toBe(true);\n    resolve(\"Jon\");\n    await Promise.resolve();\n    expect(value()).toBe(\"Jon\");\n    expect(value.loading).toBe(false);\n    done();\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"global refetch disabled","suites":["Simulate a dynamic fetch"],"updatePoint":{"line":109,"column":31},"line":109,"code":"  test(\"global refetch disabled\", async done => {\n    createRoot(() => {\n      const [id, setId] = createSignal(\"1\");\n      trigger = setId;\n      onError(e => (error = e));\n      [value] = createResource(id, fetcher, { globalRefetch: false });\n      createRenderEffect(value);\n    });\n    expect(value()).toBeUndefined();\n    expect(value.loading).toBe(true);\n    resolve(\"John\");\n    await Promise.resolve();\n    expect(value()).toBe(\"John\");\n    expect(value.loading).toBe(false);\n    refetchResources();\n    expect(value.loading).toBe(false);\n    resolve(\"Jon\");\n    await Promise.resolve();\n    expect(value()).toBe(\"John\");\n    expect(value.loading).toBe(false);\n    done();\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"initial async resource","suites":["Simulate a dynamic fetch with state and reconcile"],"updatePoint":{"line":155,"column":30},"line":155,"code":"  test(\"initial async resource\", async done => {\n    createRoot(() => {\n      [user, { refetch }] = createResource(fetcher);\n      [state] = createStore<{ user?: User; userLoading: boolean }>({\n        get user() {\n          return user();\n        },\n        get userLoading() {\n          return user.loading;\n        }\n      });\n      createComputed(() => (state.user, count++));\n    });\n    expect(state.user).toBeUndefined();\n    expect(state.userLoading).toBe(true);\n    resolve(data[0]);\n    await Promise.resolve();\n    await Promise.resolve();\n    expect(state.user).toStrictEqual(data[0]);\n    expect(state.userLoading).toBe(false);\n    expect(count).toBe(2);\n\n    refetch();\n    expect(state.userLoading).toBe(true);\n    resolve(data[1]);\n    await Promise.resolve();\n    await Promise.resolve();\n    expect(state.user).toStrictEqual(data[0]);\n    expect(state.user!.firstName).toBe(\"Joseph\");\n    expect(state.user!.address).toStrictEqual(data[0].address);\n    expect(state.userLoading).toBe(false);\n    expect(count).toBe(2);\n    done();\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"loads default value","suites":["using Resource with no root"],"updatePoint":{"line":192,"column":27},"line":192,"code":"  test(\"loads default value\", () => {\n    expect(() => {\n      let resolve: (v: string) => void;\n      createResource(\"error\", () => new Promise(r => (resolve = r)));\n      resolve!(\"Hi\");\n    }).not.toThrow();\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"loads default value","suites":["using Resource with initial Value"],"updatePoint":{"line":213,"column":27},"line":213,"code":"  test(\"loads default value\", async () => {\n    createRoot(() => {\n      const [id, setId] = createSignal(\"1\");\n      trigger = setId;\n      onError(e => (error = e));\n      [value] = createResource(id, fetcher, { initialValue: \"Loading\" });\n      createRenderEffect(value);\n    });\n    expect(value()).toBe(\"Loading\");\n    expect(value.loading).toBe(true);\n    resolve(\"John\");\n    await Promise.resolve();\n    expect(value()).toBe(\"John\");\n    expect(value.loading).toBe(false);\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"queue a task","suites":["requestCallback basics"],"updatePoint":{"line":6,"column":20},"line":6,"code":"  test(\"queue a task\", done => {\n    requestCallback(() => {\n      done();\n    });\n  });","file":"scheduler.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"queue a task in correct order","suites":["requestCallback basics"],"updatePoint":{"line":12,"column":37},"line":12,"code":"  test(\"queue a task in correct order\", done => {\n    let count = 0;\n    requestCallback(() => {\n      expect(count).toBe(2);\n      done();\n    });\n    requestCallback(\n      () => {\n        count++;\n        expect(count).toBe(1);\n      },\n      { timeout: 10 }\n    );\n    requestCallback(\n      () => {\n        count++;\n        expect(count).toBe(2);\n      },\n      { timeout: 40 }\n    );\n  });","file":"scheduler.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"does not trigger downstream computations unless changed","suites":["createMemo","executing propagating"],"updatePoint":{"line":5,"column":63},"line":5,"code":"    it(\"does not trigger downstream computations unless changed\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(1, { equals: false });\n        let order = \"\";\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1();\n        });\n        createComputed(() => {\n          order += \"c1\";\n          t1();\n        });\n        expect(order).toBe(\"t1c1\");\n        order = \"\";\n        set(1);\n        expect(order).toBe(\"t1\");\n        order = \"\";\n        set(2);\n        expect(order).toBe(\"t1c1\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"applies updates to changed dependees in same order as createComputed","suites":["createMemo","executing propagating"],"updatePoint":{"line":27,"column":76},"line":27,"code":"    it(\"applies updates to changed dependees in same order as createComputed\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(0);\n        let order = \"\";\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1() === 0;\n        });\n        createComputed(() => {\n          order += \"c1\";\n          return s1();\n        });\n        createComputed(() => {\n          order += \"c2\";\n          return t1();\n        });\n\n        expect(order).toBe(\"t1c1c2\");\n        order = \"\";\n        set(1);\n        expect(order).toBe(\"t1c2c1\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"updates downstream pending computations","suites":["createMemo","executing propagating"],"updatePoint":{"line":51,"column":47},"line":51,"code":"    it(\"updates downstream pending computations\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(0);\n        const [s2] = createSignal(0);\n        let order = \"\";\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1() === 0;\n        });\n        createComputed(() => {\n          order += \"c1\";\n          return s1();\n        });\n        createComputed(() => {\n          order += \"c2\";\n          t1();\n          createComputed(() => {\n            order += \"c2_1\";\n            return s2();\n          });\n        });\n        order = \"\";\n        set(1);\n        expect(order).toBe(\"t1c2c2_1c1\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"updates on active dependencies","suites":["createMemo","with changing dependencies"],"updatePoint":{"line":98,"column":38},"line":98,"code":"    it(\"updates on active dependencies\", () => {\n      createRoot(() => {\n        init();\n        setT(5);\n        expect(fevals).toBe(1);\n        expect(f()).toBe(5);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"does not update on inactive dependencies","suites":["createMemo","with changing dependencies"],"updatePoint":{"line":107,"column":48},"line":107,"code":"    it(\"does not update on inactive dependencies\", () => {\n      createRoot(() => {\n        init();\n        setE(5);\n        expect(fevals).toBe(0);\n        expect(f()).toBe(1);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"deactivates obsolete dependencies","suites":["createMemo","with changing dependencies"],"updatePoint":{"line":116,"column":41},"line":116,"code":"    it(\"deactivates obsolete dependencies\", () => {\n      createRoot(() => {\n        init();\n        setI(false);\n        fevals = 0;\n        setT(5);\n        expect(fevals).toBe(0);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"activates new dependencies","suites":["createMemo","with changing dependencies"],"updatePoint":{"line":126,"column":34},"line":126,"code":"    it(\"activates new dependencies\", () => {\n      createRoot(() => {\n        init();\n        setI(false);\n        fevals = 0;\n        setE(5);\n        expect(fevals).toBe(1);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"ensures that new dependencies are updated before dependee","suites":["createMemo","with changing dependencies"],"updatePoint":{"line":136,"column":65},"line":136,"code":"    it(\"ensures that new dependencies are updated before dependee\", () => {\n      createRoot(() => {\n        var order = \"\",\n          [a, setA] = createSignal(0),\n          b = createMemo(() => {\n            order += \"b\";\n            return a() + 1;\n          }),\n          c = createMemo(() => {\n            order += \"c\";\n            const check = b();\n            if (check) {\n              return check;\n            }\n            return e();\n          }),\n          d = createMemo(() => {\n            return a();\n          }),\n          e = createMemo(() => {\n            order += \"d\";\n            return d() + 10;\n          });\n\n        expect(order).toBe(\"bcd\");\n\n        order = \"\";\n        setA(-1);\n\n        expect(order).toBe(\"bcd\");\n        expect(c()).toBe(9);\n\n        order = \"\";\n        setA(0);\n\n        expect(order).toBe(\"bcd\");\n        expect(c()).toBe(1);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"does not update subsequent pending computations after stale invocations","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":178,"column":79},"line":178,"code":"    it(\"does not update subsequent pending computations after stale invocations\", () => {\n      createRoot(() => {\n        const [s1, set1] = createSignal(1);\n        const [s2, set2] = createSignal(false);\n        let count = 0;\n        /*\n                    s1\n                    |\n                +---+---+\n               t1 t2 c1 t3\n                \\       /\n                   c3\n             [PN,PN,STL,void]\n        */\n        const t1 = createMemo(() => s1() > 0);\n        const t2 = createMemo(() => s1() > 0);\n        const c1 = createMemo(() => s1());\n        const t3 = createMemo(() => {\n          const a = s1();\n          const b = s2();\n          return a && b;\n        });\n        createComputed(() => {\n          t1();\n          t2();\n          c1();\n          t3();\n          count++;\n        });\n        set2(true);\n        expect(count).toBe(2);\n        set1(2);\n        expect(count).toBe(3);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"evaluates stale computations before dependendees when trackers stay unchanged","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":214,"column":85},"line":214,"code":"    it(\"evaluates stale computations before dependendees when trackers stay unchanged\", () => {\n      createRoot(() => {\n        let [s1, set] = createSignal(1, { equals: false });\n        let order = \"\";\n        let t1 = createMemo(() => {\n          order += \"t1\";\n          return s1() > 2;\n        });\n        let t2 = createMemo(() => {\n          order += \"t2\";\n          return s1() > 2;\n        });\n        let c1 = createMemo(\n          () => {\n            order += \"c1\";\n            s1();\n          },\n          undefined,\n          { equals: false }\n        );\n        createComputed(() => {\n          order += \"c2\";\n          t1();\n          t2();\n          c1();\n        });\n        order = \"\";\n        set(1);\n        expect(order).toBe(\"t1t2c1c2\");\n        order = \"\";\n        set(3);\n        expect(order).toBe(\"t2c2t1c1\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"evaluates nested trackings","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":249,"column":34},"line":249,"code":"    it(\"evaluates nested trackings\", () => {\n      createRoot(() => {\n        const [s1, set1] = createSignal(1);\n        const [s2] = createSignal(1);\n        let count = 0;\n        let c1: () => number;\n        createMemo(() => {\n          c1 = createMemo(() => s2());\n          return s1();\n        });\n        createComputed(() => {\n          count++;\n          c1();\n        });\n        set1(2);\n        expect(count).toBe(1);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"propagates in topological order","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":268,"column":39},"line":268,"code":"    it(\"propagates in topological order\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(true);\n        let order = \"\";\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1();\n        });\n        const t2 = createMemo(() => {\n          order += \"t2\";\n          return s1();\n        });\n        createComputed(() => {\n          t1();\n          t2();\n          order += \"c1\";\n        });\n        order = \"\";\n        set(false);\n        expect(order).toBe(\"t1t2c1\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"does not evaluate dependencies with tracking sources that have not changed","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":291,"column":82},"line":291,"code":"    it(\"does not evaluate dependencies with tracking sources that have not changed\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(1);\n        let order = \"\";\n        let c2: () => boolean;\n        createComputed(() => {\n          order += \"c1\";\n          if (s1() > 1) {\n            c2();\n          }\n        });\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1() < 3;\n        });\n        const t2 = createMemo(() => {\n          order += \"t2\";\n          return t1();\n        });\n        c2 = createMemo(() => {\n          order += \"c2\";\n          return t2();\n        });\n        order = \"\";\n        set(2);\n        expect(order).toBe(\"c1t1\");\n        order = \"\";\n        set(3);\n        expect(order).toBe(\"c1t1t2c2\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"correctly marks downstream computations as stale on change","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":323,"column":66},"line":323,"code":"    it(\"correctly marks downstream computations as stale on change\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(1);\n        let order = \"\";\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1();\n        });\n        const c1 = createMemo(() => {\n          order += \"c1\";\n          return t1();\n        });\n        const c2 = createMemo(() => {\n          order += \"c2\";\n          return c1();\n        });\n        createComputed(() => {\n          order += \"c3\";\n          return c2();\n        });\n        order = \"\";\n        set(2);\n        expect(order).toBe(\"t1c1c2c3\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"throws when continually setting a direct dependency","suites":["createMemo","with unending changes"],"updatePoint":{"line":351,"column":59},"line":351,"code":"    it(\"throws when continually setting a direct dependency\", () => {\n      createRoot(() => {\n        const [d, set] = createSignal(1);\n\n        expect(() => {\n          createMemo(() => {\n            return set(d() + 1);\n          });\n        }).toThrow();\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"throws when continually setting an indirect dependency","suites":["createMemo","with unending changes"],"updatePoint":{"line":363,"column":62},"line":363,"code":"    it(\"throws when continually setting an indirect dependency\", () => {\n      createRoot(() => {\n        let i = 2;\n        const [d, set] = createSignal(1),\n          f1 = createMemo(() => d()),\n          f2 = createMemo(() => f1()),\n          f3 = createMemo(() => f2());\n\n        expect(() => {\n          createMemo(() => {\n            f3();\n            set(i++);\n          });\n        }).toThrow();\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"throws when cycle created by modifying a branch","suites":["createMemo","with circular dependencies"],"updatePoint":{"line":382,"column":55},"line":382,"code":"    it(\"throws when cycle created by modifying a branch\", () => {\n      createRoot(() => {\n        var [d, set] = createSignal(1),\n          f: Accessor<number | undefined> = createMemo(() => (f ? f() : d()), undefined, {\n            equals: false\n          });\n\n        expect(() => {\n          set(0);\n        }).toThrow();\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and read a Signal","suites":["Create signals"],"updatePoint":{"line":25,"column":32},"line":25,"code":"  test(\"Create and read a Signal\", () => {\n    const [value] = createSignal(5);\n    expect(value()).toBe(5);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and read a Signal with comparator","suites":["Create signals"],"updatePoint":{"line":29,"column":48},"line":29,"code":"  test(\"Create and read a Signal with comparator\", () => {\n    const [value] = createSignal(5, { equals: (a, b) => a === b });\n    expect(value()).toBe(5);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and read a Memo","suites":["Create signals"],"updatePoint":{"line":33,"column":30},"line":33,"code":"  test(\"Create and read a Memo\", () => {\n    createRoot(() => {\n      const memo = createMemo(() => \"Hello\");\n      expect(memo()).toBe(\"Hello\");\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and read a Memo with initial value","suites":["Create signals"],"updatePoint":{"line":39,"column":49},"line":39,"code":"  test(\"Create and read a Memo with initial value\", () => {\n    createRoot(() => {\n      const memo = createMemo(i => `${i} John`, \"Hello\");\n      expect(memo()).toBe(\"Hello John\");\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create onMount","suites":["Create signals"],"updatePoint":{"line":45,"column":22},"line":45,"code":"  test(\"Create onMount\", () => {\n    let temp: string;\n    createRoot(() => {\n      onMount(() => (temp = \"impure\"));\n    });\n    expect(temp!).toBe(\"impure\");\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create a Computed with explicit deps","suites":["Create signals"],"updatePoint":{"line":52,"column":44},"line":52,"code":"  test(\"Create a Computed with explicit deps\", () => {\n    createRoot(() => {\n      let temp: string;\n      const [sign] = createSignal(\"thoughts\");\n      const fn = on(sign, v => (temp = `impure ${v}`));\n      createComputed(fn);\n      createComputed(on(sign, v => (temp = `impure ${v}`)));\n      expect(temp!).toBe(\"impure thoughts\");\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create a Computed with multiple explicit deps","suites":["Create signals"],"updatePoint":{"line":62,"column":53},"line":62,"code":"  test(\"Create a Computed with multiple explicit deps\", () => {\n    createRoot(() => {\n      let temp: string;\n      const [sign] = createSignal(\"thoughts\");\n      const [num] = createSignal(3);\n      const fn = on([sign, num], v => (temp = `impure ${v[1]}`));\n      createComputed(fn);\n      expect(temp!).toBe(\"impure 3\");\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create a Computed with explicit deps and lazy evaluation","suites":["Create signals"],"updatePoint":{"line":72,"column":64},"line":72,"code":"  test(\"Create a Computed with explicit deps and lazy evaluation\", () => {\n    createRoot(() => {\n      let temp: string;\n      const [sign, set] = createSignal(\"thoughts\");\n      const fn = on(sign, v => (temp = `impure ${v}`), { defer: true });\n      createComputed(fn);\n      expect(temp!).toBeUndefined();\n      set(\"minds\");\n      expect(temp!).toBe(\"impure minds\");\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and update a Signal","suites":["Update signals"],"updatePoint":{"line":86,"column":34},"line":86,"code":"  test(\"Create and update a Signal\", () => {\n    const [value, setValue] = createSignal(5);\n    setValue(10);\n    expect(value()).toBe(10);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and update a Signal with fn","suites":["Update signals"],"updatePoint":{"line":91,"column":42},"line":91,"code":"  test(\"Create and update a Signal with fn\", () => {\n    const [value, setValue] = createSignal(5);\n    setValue(p => p + 5);\n    expect(value()).toBe(10);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create Signal and set different value","suites":["Update signals"],"updatePoint":{"line":96,"column":45},"line":96,"code":"  test(\"Create Signal and set different value\", () => {\n    const [value, setValue] = createSignal(5);\n    setValue(10);\n    expect(value()).toBe(10);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create Signal and set equivalent value","suites":["Update signals"],"updatePoint":{"line":101,"column":46},"line":101,"code":"  test(\"Create Signal and set equivalent value\", () => {\n    const [value, setValue] = createSignal(5, { equals: (a, b) => a > b });\n    setValue(3);\n    expect(value()).toBe(5);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and read a Signal with function value","suites":["Update signals"],"updatePoint":{"line":106,"column":52},"line":106,"code":"  test(\"Create and read a Signal with function value\", () => {\n    const [value, setValue] = createSignal<() => string>(() => \"Hi\");\n    expect(value()()).toBe(\"Hi\");\n    setValue(() => () => \"Hello\");\n    expect(value()()).toBe(\"Hello\");\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and trigger a Memo","suites":["Update signals"],"updatePoint":{"line":112,"column":33},"line":112,"code":"  test(\"Create and trigger a Memo\", () => {\n    createRoot(() => {\n      const [name, setName] = createSignal(\"John\"),\n        memo = createMemo(() => `Hello ${name()}`);\n      expect(memo()).toBe(\"Hello John\");\n      setName(\"Jake\");\n      expect(memo()).toBe(\"Hello Jake\");\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and trigger a Memo in an effect","suites":["Update signals"],"updatePoint":{"line":121,"column":46},"line":121,"code":"  test(\"Create and trigger a Memo in an effect\", done => {\n    createRoot(() => {\n      let temp: string;\n      const [name, setName] = createSignal(\"John\"),\n        memo = createMemo(() => `Hello ${name()}`);\n      createEffect(() => (temp = `${memo()}!!!`));\n      setTimeout(() => {\n        expect(temp).toBe(\"Hello John!!!\");\n        setName(\"Jake\");\n        expect(temp).toBe(\"Hello Jake!!!\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and trigger an Effect","suites":["Update signals"],"updatePoint":{"line":135,"column":36},"line":135,"code":"  test(\"Create and trigger an Effect\", done => {\n    createRoot(() => {\n      let temp: string;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      createEffect(() => (temp = `unpure ${sign()}`));\n      setTimeout(() => {\n        expect(temp).toBe(\"unpure thoughts\");\n        setSign(\"mind\");\n        expect(temp).toBe(\"unpure mind\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and trigger an Effect with function signals","suites":["Update signals"],"updatePoint":{"line":148,"column":58},"line":148,"code":"  test(\"Create and trigger an Effect with function signals\", done => {\n    createRoot(() => {\n      let temp: string;\n      const [sign, setSign] = createSignal<() => string>(() => \"thoughts\");\n      createEffect(() => (temp = `unpure ${sign()()}`));\n      setTimeout(() => {\n        expect(temp).toBe(\"unpure thoughts\");\n        setSign(() => () => \"mind\");\n        expect(temp).toBe(\"unpure mind\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Set signal returns argument","suites":["Update signals"],"updatePoint":{"line":161,"column":35},"line":161,"code":"  test(\"Set signal returns argument\", () => {\n    const [_, setValue] = createSignal<number>();\n    const res1: undefined = setValue(undefined);\n    expect(res1).toBe(undefined);\n    const res2: number = setValue(12);\n    expect(res2).toBe(12);\n    const res3 = setValue(Math.random() >= 0 ? 12 : undefined);\n    expect(res3).toBe(12);\n    const res4 = setValue();\n    expect(res4).toBe(undefined);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Mute an effect","suites":["Untrack signals"],"updatePoint":{"line":175,"column":22},"line":175,"code":"  test(\"Mute an effect\", done => {\n    createRoot(() => {\n      let temp: string;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      createEffect(() => (temp = `unpure ${untrack(sign)}`));\n      setTimeout(() => {\n        expect(temp).toBe(\"unpure thoughts\");\n        setSign(\"mind\");\n        expect(temp).toBe(\"unpure thoughts\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Groups updates","suites":["Batch signals"],"updatePoint":{"line":191,"column":22},"line":191,"code":"  test(\"Groups updates\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [a, setA] = createSignal(0);\n      const [b, setB] = createSignal(0);\n      createEffect(() => {\n        setA(1);\n        setB(1);\n      });\n      createComputed(() => (count = a() + b()));\n      setTimeout(() => {\n        expect(count).toBe(2);\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Groups updates with repeated sets","suites":["Batch signals"],"updatePoint":{"line":207,"column":41},"line":207,"code":"  test(\"Groups updates with repeated sets\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [a, setA] = createSignal(0);\n      createEffect(() => {\n        setA(1);\n        setA(4);\n      });\n      createComputed(() => (count = a()));\n      setTimeout(() => {\n        expect(count).toBe(4);\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Groups updates with fn setSignal","suites":["Batch signals"],"updatePoint":{"line":222,"column":40},"line":222,"code":"  test(\"Groups updates with fn setSignal\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [a, setA] = createSignal(0);\n      const [b, setB] = createSignal(0);\n      createEffect(() => {\n        setA(a => a + 1);\n        setB(b => b + 1);\n      });\n      createComputed(() => (count = a() + b()));\n      setTimeout(() => {\n        expect(count).toBe(2);\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Groups updates with fn setSignal with repeated sets","suites":["Batch signals"],"updatePoint":{"line":238,"column":59},"line":238,"code":"  test(\"Groups updates with fn setSignal with repeated sets\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [a, setA] = createSignal(0);\n      createEffect(() => {\n        setA(a => a + 1);\n        setA(a => a + 2);\n      });\n      createComputed(() => (count = a()));\n      setTimeout(() => {\n        expect(count).toBe(3);\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Test cross setting in a batched update","suites":["Batch signals"],"updatePoint":{"line":253,"column":46},"line":253,"code":"  test(\"Test cross setting in a batched update\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [a, setA] = createSignal(1);\n      const [b, setB] = createSignal(0);\n      createEffect(() => {\n        setA(a => a + b());\n      });\n      createComputed(() => (count = a()));\n      setTimeout(() => {\n        setB(b => b + 1);\n        setTimeout(() => {\n          expect(count).toBe(2);\n          done();\n        });\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Handles errors gracefully","suites":["Batch signals"],"updatePoint":{"line":271,"column":33},"line":271,"code":"  test(\"Handles errors gracefully\", done => {\n    createRoot(() => {\n      let error: Error;\n      const [a, setA] = createSignal(0);\n      const [b, setB] = createSignal(0);\n      createEffect(() => {\n        try {\n          setA(1);\n          throw new Error(\"test\");\n          setB(1);\n        } catch (e) {\n          error = e as Error;\n        }\n      });\n      createComputed(() => a() + b());\n      setTimeout(() => {\n        expect(a()).toBe(1);\n        expect(b()).toBe(0);\n        setA(2);\n        expect(a()).toBe(2);\n        expect(error).toBeInstanceOf(Error);\n        expect(error.message).toBe(\"test\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"No default value can return undefined","suites":["Typecheck computed and effects"],"updatePoint":{"line":300,"column":45},"line":300,"code":"  test(\"No default value can return undefined\", () => {\n    createRoot(() => {\n      let count = 0;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      const fn = (arg?: number) => {\n        count++;\n        sign();\n        expect(arg).toBe(undefined);\n        return arg;\n      };\n      createComputed(fn);\n      createRenderEffect(fn);\n      createEffect(fn);\n      setTimeout(() => {\n        expect(count).toBe(3);\n        setSign(\"update\");\n        expect(count).toBe(6);\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Default value never receives undefined","suites":["Typecheck computed and effects"],"updatePoint":{"line":320,"column":46},"line":320,"code":"  test(\"Default value never receives undefined\", () => {\n    createRoot(() => {\n      let count = 0;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      const fn = (arg: number) => {\n        count++;\n        sign();\n        expect(arg).toBe(12);\n        return arg;\n      };\n      createComputed(fn, 12);\n      createRenderEffect(fn, 12);\n      createEffect(fn, 12);\n      setTimeout(() => {\n        expect(count).toBe(3);\n        setSign(\"update\");\n        expect(count).toBe(6);\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Clean an effect","suites":["onCleanup"],"updatePoint":{"line":343,"column":23},"line":343,"code":"  test(\"Clean an effect\", done => {\n    createRoot(() => {\n      let temp: string;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      createEffect(() => {\n        sign();\n        onCleanup(() => (temp = \"after\"));\n      });\n      setTimeout(() => {\n        expect(temp).toBeUndefined();\n        setSign(\"mind\");\n        expect(temp).toBe(\"after\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Explicit root disposal","suites":["onCleanup"],"updatePoint":{"line":359,"column":30},"line":359,"code":"  test(\"Explicit root disposal\", () => {\n    let temp: string | undefined, disposer: () => void;\n    createRoot(dispose => {\n      disposer = dispose;\n      onCleanup(() => (temp = \"disposed\"));\n    });\n    expect(temp).toBeUndefined();\n    disposer!();\n    expect(temp).toBe(\"disposed\");\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"No Handler","suites":["onError"],"updatePoint":{"line":372,"column":18},"line":372,"code":"  test(\"No Handler\", () => {\n    expect(() =>\n      createRoot(() => {\n        throw \"fail\";\n      })\n    ).toThrow(\"fail\");\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Top level","suites":["onError"],"updatePoint":{"line":379,"column":17},"line":379,"code":"  test(\"Top level\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        onError(() => (errored = true));\n        throw \"fail\";\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"In initial effect","suites":["onError"],"updatePoint":{"line":390,"column":25},"line":390,"code":"  test(\"In initial effect\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        createEffect(() => {\n          onError(() => (errored = true));\n          throw \"fail\";\n        });\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"With multiple error handlers","suites":["onError"],"updatePoint":{"line":403,"column":36},"line":403,"code":"  test(\"With multiple error handlers\", () => {\n    let errored = false;\n    let errored2 = false;\n    expect(() =>\n      createRoot(() => {\n        createEffect(() => {\n          onError(() => (errored = true));\n          onError(() => (errored2 = true));\n          throw \"fail\";\n        });\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n    expect(errored2).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"In update effect","suites":["onError"],"updatePoint":{"line":419,"column":24},"line":419,"code":"  test(\"In update effect\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        const [s, set] = createSignal(0);\n        createEffect(() => {\n          const v = s();\n          onError(() => (errored = true));\n          if (v) throw \"fail\";\n        });\n        set(1);\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"In initial nested effect","suites":["onError"],"updatePoint":{"line":435,"column":32},"line":435,"code":"  test(\"In initial nested effect\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        createEffect(() => {\n          createEffect(() => {\n            onError(() => (errored = true));\n            throw \"fail\";\n          });\n        });\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"In nested update effect","suites":["onError"],"updatePoint":{"line":450,"column":31},"line":450,"code":"  test(\"In nested update effect\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        const [s, set] = createSignal(0);\n        createEffect(() => {\n          createEffect(() => {\n            const v = s();\n            onError(() => (errored = true));\n            if (v) throw \"fail\";\n          });\n        });\n        set(1);\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"In nested update effect different levels","suites":["onError"],"updatePoint":{"line":468,"column":48},"line":468,"code":"  test(\"In nested update effect different levels\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        const [s, set] = createSignal(0);\n        createEffect(() => {\n          onError(() => (errored = true));\n          createEffect(() => {\n            const v = s();\n            if (v) throw \"fail\";\n          });\n        });\n        set(1);\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple defer","suites":["createDeferred"],"updatePoint":{"line":488,"column":20},"line":488,"code":"  test(\"simple defer\", done => {\n    createRoot(() => {\n      const [s, set] = createSignal(\"init\"),\n        r = createDeferred(s, { timeoutMs: 20 });\n      expect(r()).toBe(\"init\");\n      set(\"Hi\");\n      expect(r()).toBe(\"init\");\n      setTimeout(() => {\n        expect(r()).toBe(\"Hi\");\n        done();\n      }, 100);\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple selection","suites":["createSelector"],"updatePoint":{"line":504,"column":24},"line":504,"code":"  test(\"simple selection\", done => {\n    createRoot(() => {\n      const [s, set] = createSignal<number>(-1),\n        isSelected = createSelector<number, number>(s);\n      let count = 0;\n      const list = Array.from({ length: 100 }, (_, i) =>\n        createMemo(() => {\n          count++;\n          return isSelected(i) ? \"selected\" : \"no\";\n        })\n      );\n      expect(count).toBe(100);\n      expect(list[3]()).toBe(\"no\");\n      setTimeout(() => {\n        count = 0;\n        set(3);\n        expect(count).toBe(1);\n        expect(list[3]()).toBe(\"selected\");\n        count = 0;\n        set(6);\n        expect(count).toBe(2);\n        expect(list[3]()).toBe(\"no\");\n        expect(list[6]()).toBe(\"selected\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"double selection","suites":["createSelector"],"updatePoint":{"line":532,"column":24},"line":532,"code":"  test(\"double selection\", done => {\n    createRoot(() => {\n      const [s, set] = createSignal<number>(-1),\n        isSelected = createSelector<number, number>(s);\n      let count = 0;\n      const list = Array.from({ length: 100 }, (_, i) => [\n        createMemo(() => {\n          count++;\n          return isSelected(i) ? \"selected\" : \"no\";\n        }),\n        createMemo(() => {\n          count++;\n          return isSelected(i) ? \"oui\" : \"non\";\n        })\n      ]);\n      expect(count).toBe(200);\n      expect(list[3][0]()).toBe(\"no\");\n      expect(list[3][1]()).toBe(\"non\");\n      setTimeout(() => {\n        count = 0;\n        set(3);\n        expect(count).toBe(2);\n        expect(list[3][0]()).toBe(\"selected\");\n        expect(list[3][1]()).toBe(\"oui\");\n        count = 0;\n        set(6);\n        expect(count).toBe(4);\n        expect(list[3][0]()).toBe(\"no\");\n        expect(list[6][0]()).toBe(\"selected\");\n        expect(list[3][1]()).toBe(\"non\");\n        expect(list[6][1]()).toBe(\"oui\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"zero index","suites":["createSelector"],"updatePoint":{"line":568,"column":18},"line":568,"code":"  test(\"zero index\", done => {\n    createRoot(() => {\n      const [s, set] = createSignal<number>(-1),\n        isSelected = createSelector<number, number>(s);\n      let count = 0;\n      const list = [\n        createMemo(() => {\n          count++;\n          return isSelected(0) ? \"selected\" : \"no\";\n        })\n      ];\n      expect(count).toBe(1);\n      expect(list[0]()).toBe(\"no\");\n      setTimeout(() => {\n        count = 0;\n        set(0);\n        expect(count).toBe(1);\n        expect(list[0]()).toBe(\"selected\");\n        count = 0;\n        set(-1);\n        expect(count).toBe(1);\n        expect(list[0]()).toBe(\"no\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"createContext without arguments defaults to undefined","suites":["create and use context"],"updatePoint":{"line":597,"column":61},"line":597,"code":"  test(\"createContext without arguments defaults to undefined\", () => {\n    const context = createContext<number>();\n    const res = useContext(context);\n    expect(res).toBe<typeof res>(undefined);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Top level owner execute and disposal","suites":["runWithOwner"],"updatePoint":{"line":605,"column":44},"line":605,"code":"  test(\"Top level owner execute and disposal\", () => {\n    let effectRun = false;\n    let cleanupRun = false;\n    const [owner, dispose] = createRoot(dispose => {\n      return [getOwner()!, dispose];\n    });\n\n    runWithOwner(owner, () => {\n      createEffect(() => effectRun = true);\n      onCleanup(() => cleanupRun = true);\n      expect(effectRun).toBe(false);\n      expect(cleanupRun).toBe(false);\n    });\n    expect(effectRun).toBe(true);\n    expect(cleanupRun).toBe(false);\n    dispose();\n    expect(cleanupRun).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and trigger a Reaction","suites":["createReaction"],"updatePoint":{"line":626,"column":37},"line":626,"code":"  test(\"Create and trigger a Reaction\", (done) => {\n    createRoot(() => {\n      let count = 0;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      const track = createReaction(() => count++);\n      expect(count).toBe(0);\n      track(sign)\n      expect(count).toBe(0);\n      setTimeout(() => {\n        expect(count).toBe(0);\n        setSign(\"mind\");\n        expect(count).toBe(1);\n        setSign(\"body\");\n        expect(count).toBe(1);\n        track(sign)\n        setSign(\"everything\");\n        expect(count).toBe(2);\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Reconcile a simple object","suites":["setState with reconcile"],"updatePoint":{"line":5,"column":33},"line":5,"code":"  test(\"Reconcile a simple object\", () => {\n    const [state, setState] = createStore({ data: 2, missing: \"soon\" });\n    expect(state.data).toBe(2);\n    expect(state.missing).toBe(\"soon\");\n    setState(reconcile({ data: 5 }));\n    expect(state.data).toBe(5);\n    expect(state.missing).toBeUndefined();\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile a simple object on a nested path","suites":["setState with reconcile"],"updatePoint":{"line":14,"column":50},"line":14,"code":"  test(\"Reconcile a simple object on a nested path\", () => {\n    const [state, setState] = createStore({\n      data: { user: { firstName: \"John\", middleName: \"\", lastName: \"Snow\" } }\n    });\n    expect(state.data.user.firstName).toBe(\"John\");\n    expect(state.data.user.lastName).toBe(\"Snow\");\n    setState(\"data\", \"user\", reconcile({ firstName: \"Jake\", middleName: \"R\" }));\n    expect(state.data.user.firstName).toBe(\"Jake\");\n    expect(state.data.user.middleName).toBe(\"R\");\n    expect(state.data.user.lastName).toBeUndefined();\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile a simple object on a nested path with no prev state","suites":["setState with reconcile"],"updatePoint":{"line":26,"column":69},"line":26,"code":"  test(\"Reconcile a simple object on a nested path with no prev state\", () => {\n    const [state, setState] = createStore<{ user?: { firstName: string; middleName: string } }>({});\n    expect(state.user).toBeUndefined();\n    setState(\"user\", reconcile({ firstName: \"Jake\", middleName: \"R\" }));\n    expect(state.user!.firstName).toBe(\"Jake\");\n    expect(state.user!.middleName).toBe(\"R\");\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile reorder a keyed array","suites":["setState with reconcile"],"updatePoint":{"line":34,"column":39},"line":34,"code":"  test(\"Reconcile reorder a keyed array\", () => {\n    const JOHN = { id: 1, firstName: \"John\", lastName: \"Snow\" },\n      NED = { id: 2, firstName: \"Ned\", lastName: \"Stark\" },\n      BRANDON = { id: 3, firstName: \"Brandon\", lastName: \"Start\" },\n      ARYA = { id: 4, firstName: \"Arya\", lastName: \"Start\" };\n    const [state, setState] = createStore({ users: [JOHN, NED, BRANDON] });\n    expect(Object.is(unwrap(state.users[0]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), BRANDON)).toBe(true);\n    setState(\"users\", reconcile([NED, JOHN, BRANDON]));\n    expect(Object.is(unwrap(state.users[0]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), BRANDON)).toBe(true);\n    setState(\"users\", reconcile([NED, BRANDON, JOHN]));\n    expect(Object.is(unwrap(state.users[0]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), BRANDON)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), JOHN)).toBe(true);\n    setState(\"users\", reconcile([NED, BRANDON, JOHN, ARYA]));\n    expect(Object.is(unwrap(state.users[0]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), BRANDON)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[3]), ARYA)).toBe(true);\n    setState(\"users\", reconcile([BRANDON, JOHN, ARYA]));\n    expect(Object.is(unwrap(state.users[0]), BRANDON)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), ARYA)).toBe(true);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile overwrite in non-keyed merge mode","suites":["setState with reconcile"],"updatePoint":{"line":62,"column":51},"line":62,"code":"  test(\"Reconcile overwrite in non-keyed merge mode\", () => {\n    const JOHN = { id: 1, firstName: \"John\", lastName: \"Snow\" },\n      NED = { id: 2, firstName: \"Ned\", lastName: \"Stark\" },\n      BRANDON = { id: 3, firstName: \"Brandon\", lastName: \"Start\" };\n    const [state, setState] = createStore({\n      users: [{ ...JOHN }, { ...NED }, { ...BRANDON }]\n    });\n    expect(state.users[0].id).toBe(1);\n    expect(state.users[0].firstName).toBe(\"John\");\n    expect(state.users[1].id).toBe(2);\n    expect(state.users[1].firstName).toBe(\"Ned\");\n    expect(state.users[2].id).toBe(3);\n    expect(state.users[2].firstName).toBe(\"Brandon\");\n    setState(\n      \"users\",\n      reconcile([{ ...NED }, { ...JOHN }, { ...BRANDON }], {\n        merge: true,\n        key: null\n      })\n    );\n    expect(state.users[0].id).toBe(2);\n    expect(state.users[0].firstName).toBe(\"Ned\");\n    expect(state.users[1].id).toBe(1);\n    expect(state.users[1].firstName).toBe(\"John\");\n    expect(state.users[2].id).toBe(3);\n    expect(state.users[2].firstName).toBe(\"Brandon\");\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top Level Mutation","suites":["setState with produce"],"updatePoint":{"line":95,"column":26},"line":95,"code":"  test(\"Top Level Mutation\", () => {\n    const [state, setState] = createStore<DataState>({ data: { starting: 1, ending: 1 } });\n    setState(\n      produce(s => {\n        s.data.ending = s.data.starting + 1;\n      })\n    );\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).toBe(2);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top Level Mutation in computation","suites":["setState with produce"],"updatePoint":{"line":105,"column":41},"line":105,"code":"  test(\"Top Level Mutation in computation\", () => {\n    createRoot(() => {\n      const [s, set] = createSignal(1);\n      const [state, setState] = createStore<{ data: number[] }>({ data: [] });\n      createEffect(() => {\n        setState(\n          produce(state => {\n            state.data.push(s());\n          })\n        );\n      });\n      createEffect(() => state.data.length);\n    });\n    expect(true).toBe(true);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Nested Level Mutation","suites":["setState with produce"],"updatePoint":{"line":120,"column":29},"line":120,"code":"  test(\"Nested Level Mutation\", () => {\n    const [state, setState] = createStore({ data: { starting: 1, ending: 1 } });\n    setState(\n      \"data\",\n      produce(s => {\n        s.ending = s.starting + 1;\n      })\n    );\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).toBe(2);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top Level Deletion","suites":["setState with produce"],"updatePoint":{"line":131,"column":26},"line":131,"code":"  test(\"Top Level Deletion\", () => {\n    const [state, setState] = createStore<DataState>({ data: { starting: 1, ending: 1 } });\n    setState(\n      produce(s => {\n        delete s.data.ending;\n      })\n    );\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).not.toBeDefined();\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top Level Object Mutation","suites":["setState with produce"],"updatePoint":{"line":141,"column":33},"line":141,"code":"  test(\"Top Level Object Mutation\", () => {\n    const [state, setState] = createStore<DataState>({ data: { starting: 1, ending: 1 } }),\n      next = { starting: 3, ending: 6 };\n    setState(\n      produce(s => {\n        s.data = next;\n      })\n    );\n    expect(unwrap(state.data)).toBe(next);\n    expect(state.data.starting).toBe(3);\n    expect(state.data.ending).toBe(6);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Test Array Mutation","suites":["setState with produce"],"updatePoint":{"line":153,"column":27},"line":153,"code":"  test(\"Test Array Mutation\", () => {\n    interface TodoState {\n      todos: { id: number; title: string; done: boolean }[];\n    }\n    const [state, setState] = createStore<TodoState>({\n      todos: [\n        { id: 1, title: \"Go To Work\", done: true },\n        { id: 2, title: \"Eat Lunch\", done: false }\n      ]\n    });\n    setState(\n      produce(s => {\n        s.todos[1].done = true;\n        s.todos.push({ id: 3, title: \"Go Home\", done: false });\n      })\n    );\n    expect(Array.isArray(state.todos)).toBe(true);\n    expect(state.todos[1].done).toBe(true);\n    expect(state.todos[2].title).toBe(\"Go Home\");\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting a property","suites":["State Mutablity"],"updatePoint":{"line":5,"column":26},"line":5,"code":"  test(\"Setting a property\", () => {\n    const user = createMutable({ name: \"John\" });\n    expect(user.name).toBe(\"John\");\n    user.name = \"Jake\";\n    expect(user.name).toBe(\"Jake\");\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Deleting a property","suites":["State Mutablity"],"updatePoint":{"line":12,"column":27},"line":12,"code":"  test(\"Deleting a property\", () => {\n    const user = createMutable({ name: \"John\" });\n    expect(user.name).toBe(\"John\");\n    // @ts-ignore\n    delete user.name;\n    expect(user.name).toBeUndefined();\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Testing an update from state","suites":["State Getter/Setters"],"updatePoint":{"line":22,"column":36},"line":22,"code":"  test(\"Testing an update from state\", () => {\n    let user: any;\n    createRoot(() => {\n      user = createMutable({\n        name: \"John\",\n        get greeting(): string {\n          return `Hi, ${this.name}`;\n        }\n      });\n    });\n    expect(user.greeting).toBe(\"Hi, John\");\n    user.name = \"Jake\";\n    expect(user.greeting).toBe(\"Hi, Jake\");\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"setting a value with setters","suites":["State Getter/Setters"],"updatePoint":{"line":37,"column":36},"line":37,"code":"  test(\"setting a value with setters\", () => {\n    let user: any;\n    createRoot(() => {\n      user = createMutable({\n        firstName: \"John\",\n        lastName: \"Smith\",\n        get fullName(): string {\n          return `${this.firstName} ${this.lastName}`;\n        },\n        set fullName(value) {\n          const parts = value.split(\" \");\n          this.firstName = parts[0];\n          this.lastName = parts[1];\n        }\n      });\n    });\n    expect(user.fullName).toBe(\"John Smith\");\n    user.fullName = \"Jake Murray\";\n    expect(user.firstName).toBe(\"Jake\");\n    expect(user.lastName).toBe(\"Murray\");\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Simple Key Value","suites":["Simple update modes"],"updatePoint":{"line":61,"column":24},"line":61,"code":"  test(\"Simple Key Value\", () => {\n    const state = createMutable({ key: \"\" });\n    state.key = \"value\";\n    expect(state.key).toBe(\"value\");\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Nested update","suites":["Simple update modes"],"updatePoint":{"line":67,"column":21},"line":67,"code":"  test(\"Nested update\", () => {\n    const state = createMutable({ data: { starting: 1, ending: 1 } });\n    state.data.ending = 2;\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).toBe(2);\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Test Array","suites":["Simple update modes"],"updatePoint":{"line":74,"column":18},"line":74,"code":"  test(\"Test Array\", () => {\n    const state = createMutable({\n      todos: [\n        { id: 1, title: \"Go To Work\", done: true },\n        { id: 2, title: \"Eat Lunch\", done: false }\n      ]\n    });\n    state.todos[1].done = true;\n    state.todos.push({ id: 3, title: \"Go Home\", done: false });\n    expect(Array.isArray(state.todos)).toBe(true);\n    expect(state.todos[1].done).toBe(true);\n    expect(state.todos[2].title).toBe(\"Go Home\");\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen state object","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":90,"column":41},"line":90,"code":"  test(\"Unwrap nested frozen state object\", () => {\n    const state = createMutable({\n        data: Object.freeze({ user: { firstName: \"John\", lastName: \"Snow\" } })\n      }),\n      s = unwrap({ ...state });\n    expect(s.data.user.firstName).toBe(\"John\");\n    expect(s.data.user.lastName).toBe(\"Snow\");\n    // check if proxy still\n    expect(s.data.user[$RAW]).toBeUndefined();\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen array","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":100,"column":34},"line":100,"code":"  test(\"Unwrap nested frozen array\", () => {\n    const state = createMutable({\n        data: [{ user: { firstName: \"John\", lastName: \"Snow\" } }]\n      }),\n      s = unwrap({ data: state.data.slice(0) });\n    expect(s.data[0].user.firstName).toBe(\"John\");\n    expect(s.data[0].user.lastName).toBe(\"Snow\");\n    // check if proxy still\n    expect(s.data[0].user[$RAW]).toBeUndefined();\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen state array","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":110,"column":40},"line":110,"code":"  test(\"Unwrap nested frozen state array\", () => {\n    const state = createMutable({\n        data: Object.freeze([{ user: { firstName: \"John\", lastName: \"Snow\" } }])\n      }),\n      s = unwrap({ ...state });\n    expect(s.data[0].user.firstName).toBe(\"John\");\n    expect(s.data[0].user.lastName).toBe(\"Snow\");\n    // check if proxy still\n    expect(s.data[0].user[$RAW]).toBeUndefined();\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track a state change","suites":["Tracking State changes"],"updatePoint":{"line":123,"column":28},"line":123,"code":"  test(\"Track a state change\", () => {\n    createRoot(() => {\n      const state = createMutable({ data: 2 })\n      let executionCount = 0;\n\n      expect.assertions(2);\n      createComputed(() => {\n        if (executionCount === 0) expect(state.data).toBe(2);\n        else if (executionCount === 1) {\n          expect(state.data).toBe(5);\n        } else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n\n      state.data = 5;\n      // same value again should not retrigger\n      state.data = 5;\n    });\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track a nested state change","suites":["Tracking State changes"],"updatePoint":{"line":146,"column":35},"line":146,"code":"  test(\"Track a nested state change\", () => {\n    createRoot(() => {\n      const state = createMutable({\n          user: { firstName: \"John\", lastName: \"Smith\" }\n        })\n      let executionCount = 0;\n\n      expect.assertions(2);\n      createComputed(() => {\n        if (executionCount === 0) {\n          expect(state.user.firstName).toBe(\"John\");\n        } else if (executionCount === 1) {\n          expect(state.user.firstName).toBe(\"Jake\");\n        } else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n\n      state.user.firstName = \"Jake\";\n    });\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Array Native Methods: Array.Filter","suites":["Handling functions in state"],"updatePoint":{"line":172,"column":42},"line":172,"code":"  test(\"Array Native Methods: Array.Filter\", () => {\n    createRoot(() => {\n      const state = createMutable({ list: [0, 1, 2] }),\n        getFiltered = createMemo(() => state.list.filter(i => i % 2));\n      expect(getFiltered()).toStrictEqual([1]);\n    });\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track function change","suites":["Handling functions in state"],"updatePoint":{"line":180,"column":29},"line":180,"code":"  test(\"Track function change\", () => {\n    createRoot(() => {\n      const state = createMutable<{ fn: () => number }>({\n          fn: () => 1\n        }),\n        getValue = createMemo(() => state.fn());\n      state.fn = () => 2;\n      expect(getValue()).toBe(2);\n    });\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting state from signal","suites":["Setting state from Effects"],"updatePoint":{"line":193,"column":33},"line":193,"code":"  test(\"Setting state from signal\", () => {\n    createRoot(() => {\n      const [getData, setData] = createSignal(\"init\"),\n        state = createMutable({ data: \"\" });\n      createComputed(() => (state.data = getData()));\n      setData(\"signal\");\n      expect(state.data).toBe(\"signal\");\n    });\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Select Promise","suites":["Setting state from Effects"],"updatePoint":{"line":203,"column":22},"line":203,"code":"  test(\"Select Promise\", done => {\n    createRoot(async () => {\n      const p = new Promise<string>(resolve => {\n          setTimeout(resolve, 20, \"promised\");\n        }),\n        state = createMutable({ data: \"\" });\n      p.then(v => (state.data = v));\n      await p;\n      expect(state.data).toBe(\"promised\");\n      done();\n    });\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting plain object","suites":["State wrapping"],"updatePoint":{"line":218,"column":28},"line":218,"code":"  test(\"Setting plain object\", () => {\n    const data = { withProperty: \"y\" },\n      state = createMutable({ data });\n    // not wrapped\n    expect(state.data).not.toBe(data);\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting plain array","suites":["State wrapping"],"updatePoint":{"line":224,"column":27},"line":224,"code":"  test(\"Setting plain array\", () => {\n    const data = [1, 2, 3],\n      state = createMutable({ data });\n    // not wrapped\n    expect(state.data).not.toBe(data);\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting non-wrappable","suites":["State wrapping"],"updatePoint":{"line":230,"column":29},"line":230,"code":"  test(\"Setting non-wrappable\", () => {\n    const date = new Date(),\n      state = createMutable({ time: date });\n    // not wrapped\n    expect(state.time).toBe(date);\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting a property","suites":["State immutablity"],"updatePoint":{"line":5,"column":26},"line":5,"code":"  test(\"Setting a property\", () => {\n    const [state] = createStore({ name: \"John\" });\n    expect(state.name).toBe(\"John\");\n    // @ts-expect-error cannot mutate a store directly\n    state.name = \"Jake\";\n    expect(state.name).toBe(\"John\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Deleting a property","suites":["State immutablity"],"updatePoint":{"line":13,"column":27},"line":13,"code":"  test(\"Deleting a property\", () => {\n    const [state] = createStore({ name: \"John\" });\n    expect(state.name).toBe(\"John\");\n    // @ts-ignore\n    delete state.name;\n    expect(state.name).toBe(\"John\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Immutable state is not mutable even inside setter","suites":["State immutablity"],"updatePoint":{"line":21,"column":57},"line":21,"code":"  test(\"Immutable state is not mutable even inside setter\", () => {\n    const [state, setState] = createStore({ name: \"John\" });\n    expect(state.name).toBe(\"John\");\n    setState(() => {\n      // @ts-expect-error cannot mutate a store directly\n      state.name = \"Jake\";\n    });\n    expect(state.name).toBe(\"John\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Testing an update from state","suites":["State Getters"],"updatePoint":{"line":33,"column":36},"line":33,"code":"  test(\"Testing an update from state\", () => {\n    let state: any, setState: Function;\n    createRoot(() => {\n      [state, setState] = createStore({\n        name: \"John\",\n        get greeting(): string {\n          return `Hi, ${this.name}`;\n        }\n      });\n    });\n    expect(state!.greeting).toBe(\"Hi, John\");\n    setState!({ name: \"Jake\" });\n    expect(state!.greeting).toBe(\"Hi, Jake\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Testing an update from state","suites":["State Getters"],"updatePoint":{"line":48,"column":36},"line":48,"code":"  test(\"Testing an update from state\", () => {\n    let state: any, setState: Function;\n    createRoot(() => {\n      let greeting: () => string;\n      [state, setState] = createStore({\n        name: \"John\",\n        get greeting(): string {\n          return greeting();\n        }\n      });\n      greeting = createMemo(() => `Hi, ${state.name}`);\n    });\n    expect(state!.greeting).toBe(\"Hi, John\");\n    setState!({ name: \"Jake\" });\n    expect(state!.greeting).toBe(\"Hi, Jake\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Simple Key Value","suites":["Simple setState modes"],"updatePoint":{"line":67,"column":24},"line":67,"code":"  test(\"Simple Key Value\", () => {\n    const [state, setState] = createStore({ key: \"\" });\n    setState(\"key\", \"value\");\n    expect(state.key).toBe(\"value\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top level merge","suites":["Simple setState modes"],"updatePoint":{"line":73,"column":23},"line":73,"code":"  test(\"Top level merge\", () => {\n    const [state, setState] = createStore({ starting: 1, ending: 1 });\n    setState({ ending: 2 });\n    expect(state.starting).toBe(1);\n    expect(state.ending).toBe(2);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top level merge no arguments","suites":["Simple setState modes"],"updatePoint":{"line":80,"column":36},"line":80,"code":"  test(\"Top level merge no arguments\", () => {\n    const [state, setState] = createStore({ starting: 1 });\n    setState({});\n    expect(state.starting).toBe(1);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top level state function merge","suites":["Simple setState modes"],"updatePoint":{"line":86,"column":38},"line":86,"code":"  test(\"Top level state function merge\", () => {\n    const [state, setState] = createStore({ starting: 1, ending: 1 });\n    setState((s, t) => {\n      expect(t).toStrictEqual([]);\n      return { ending: s.starting + 1 };\n    });\n    expect(state.starting).toBe(1);\n    expect(state.ending).toBe(2);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Nested merge","suites":["Simple setState modes"],"updatePoint":{"line":96,"column":20},"line":96,"code":"  test(\"Nested merge\", () => {\n    const [state, setState] = createStore({ data: { starting: 1, ending: 1 } });\n    setState(\"data\", { ending: 2 });\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).toBe(2);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Nested state function merge","suites":["Simple setState modes"],"updatePoint":{"line":103,"column":35},"line":103,"code":"  test(\"Nested state function merge\", () => {\n    const [state, setState] = createStore({ data: { starting: 1, ending: 1 } });\n    setState(\"data\", (d, t) => {\n      expect(t).toStrictEqual([\"data\"]);\n      return { ending: d.starting + 1 };\n    });\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).toBe(2);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Test Array","suites":["Simple setState modes"],"updatePoint":{"line":113,"column":18},"line":113,"code":"  test(\"Test Array\", () => {\n    const [state, setState] = createStore({\n      todos: [\n        { id: 1, title: \"Go To Work\", done: true },\n        { id: 2, title: \"Eat Lunch\", done: false }\n      ]\n    });\n    setState(\"todos\", 1, { done: true });\n    setState(\"todos\", [...state.todos, { id: 3, title: \"Go Home\", done: false }]);\n    expect(Array.isArray(state.todos)).toBe(true);\n    expect(state.todos[1].done).toBe(true);\n    expect(state.todos[2].title).toBe(\"Go Home\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Update Specific","suites":["Array setState modes"],"updatePoint":{"line":129,"column":23},"line":129,"code":"  test(\"Update Specific\", () => {\n    const [state, setState] = createStore({ rows: [1, 2, 3, 4, 5] });\n    setState(\"rows\", [1, 3], (r, t) => {\n      // @ts-ignore traversed types are wrong and incomplete\n      expect(typeof t[0]).toBe(\"number\");\n      // @ts-ignore\n      expect(t[1]).toBe(\"rows\");\n      return r * 2;\n    });\n    expect(state.rows[0]).toBe(1);\n    expect(state.rows[1]).toBe(4);\n    expect(state.rows[2]).toBe(3);\n    expect(state.rows[3]).toBe(8);\n    expect(state.rows[4]).toBe(5);\n    expect(Object.keys(state.rows)).toStrictEqual([\"0\", \"1\", \"2\", \"3\", \"4\"]);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Update filterFn","suites":["Array setState modes"],"updatePoint":{"line":145,"column":23},"line":145,"code":"  test(\"Update filterFn\", () => {\n    const [state, setState] = createStore({ rows: [1, 2, 3, 4, 5] });\n    setState(\n      \"rows\",\n      (r, i) => Boolean(i % 2),\n      (r, t) => {\n        // @ts-ignore\n        expect(typeof t[0]).toBe(\"number\");\n        // @ts-ignore\n        expect(t[1]).toBe(\"rows\");\n        return r * 2;\n      }\n    );\n    expect(state.rows[0]).toBe(1);\n    expect(state.rows[1]).toBe(4);\n    expect(state.rows[2]).toBe(3);\n    expect(state.rows[3]).toBe(8);\n    expect(state.rows[4]).toBe(5);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Update traversal range","suites":["Array setState modes"],"updatePoint":{"line":164,"column":30},"line":164,"code":"  test(\"Update traversal range\", () => {\n    const [state, setState] = createStore({ rows: [1, 2, 3, 4, 5] });\n    setState(\"rows\", { from: 1, to: 4, by: 2 }, (r, t) => {\n      // @ts-ignore\n      expect(typeof t[0]).toBe(\"number\");\n      // @ts-ignore\n      expect(t[1]).toBe(\"rows\");\n      return r * 2;\n    });\n    expect(state.rows[0]).toBe(1);\n    expect(state.rows[1]).toBe(4);\n    expect(state.rows[2]).toBe(3);\n    expect(state.rows[3]).toBe(8);\n    expect(state.rows[4]).toBe(5);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Update traversal range defaults","suites":["Array setState modes"],"updatePoint":{"line":179,"column":39},"line":179,"code":"  test(\"Update traversal range defaults\", () => {\n    const [state, setState] = createStore({ rows: [1, 2, 3, 4, 5] });\n    setState(\"rows\", {}, (r, t) => {\n      // @ts-ignore\n      expect(typeof t[0]).toBe(\"number\");\n      // @ts-ignore\n      expect(t[1]).toBe(\"rows\");\n      return r * 2;\n    });\n    expect(state.rows[0]).toBe(2);\n    expect(state.rows[1]).toBe(4);\n    expect(state.rows[2]).toBe(6);\n    expect(state.rows[3]).toBe(8);\n    expect(state.rows[4]).toBe(10);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen state object","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":197,"column":41},"line":197,"code":"  test(\"Unwrap nested frozen state object\", () => {\n    const [state] = createStore({\n        data: Object.freeze({ user: { firstName: \"John\", lastName: \"Snow\" } })\n      }),\n      s = unwrap({ ...state });\n    expect(s.data.user.firstName).toBe(\"John\");\n    expect(s.data.user.lastName).toBe(\"Snow\");\n    // check if proxy still\n    expect(s.data.user[$RAW]).toBeUndefined();\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen array","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":207,"column":34},"line":207,"code":"  test(\"Unwrap nested frozen array\", () => {\n    const [state] = createStore({\n        data: [{ user: { firstName: \"John\", lastName: \"Snow\" } }]\n      }),\n      s = unwrap({ data: state.data.slice(0) });\n    expect(s.data[0].user.firstName).toBe(\"John\");\n    expect(s.data[0].user.lastName).toBe(\"Snow\");\n    // check if proxy still\n    expect(s.data[0].user[$RAW]).toBeUndefined();\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen state array","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":217,"column":40},"line":217,"code":"  test(\"Unwrap nested frozen state array\", () => {\n    const [state] = createStore({\n        data: Object.freeze([{ user: { firstName: \"John\", lastName: \"Snow\" } }])\n      }),\n      s = unwrap({ ...state });\n    expect(s.data[0].user.firstName).toBe(\"John\");\n    expect(s.data[0].user.lastName).toBe(\"Snow\");\n    // check if proxy still\n    expect(s.data[0].user[$RAW]).toBeUndefined();\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track a state change","suites":["Tracking State changes"],"updatePoint":{"line":230,"column":28},"line":230,"code":"  test(\"Track a state change\", () => {\n    createRoot(() => {\n      const [state, setState] = createStore({ data: 2 });\n      let executionCount = 0;\n\n      expect.assertions(2);\n      createComputed(() => {\n        if (executionCount === 0) expect(state.data).toBe(2);\n        else if (executionCount === 1) {\n          expect(state.data).toBe(5);\n        } else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n\n      setState({ data: 5 });\n\n      // same value again should not retrigger\n      setState({ data: 5 });\n    });\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track a nested state change","suites":["Tracking State changes"],"updatePoint":{"line":254,"column":35},"line":254,"code":"  test(\"Track a nested state change\", () => {\n    createRoot(() => {\n      const [state, setState] = createStore({\n        user: { firstName: \"John\", lastName: \"Smith\" }\n      });\n      let executionCount = 0;\n\n      expect.assertions(2);\n      createComputed(() => {\n        if (executionCount === 0) {\n          expect(state.user.firstName).toBe(\"John\");\n        } else if (executionCount === 1) {\n          expect(state.user.firstName).toBe(\"Jake\");\n        } else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n\n      setState(\"user\", \"firstName\", \"Jake\");\n    });\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Tracking Object key addition/removal","suites":["Tracking State changes"],"updatePoint":{"line":278,"column":44},"line":278,"code":"  test(\"Tracking Object key addition/removal\", () => {\n    createRoot(() => {\n      const [state, setState] = createStore<{ obj: { item?: number } }>({ obj: {} });\n      let executionCount = 0;\n\n      createComputed(\n        on(\n          () => state.obj,\n          v => {\n            if (executionCount === 0) expect(v.item).toBeUndefined();\n            else if (executionCount === 1) {\n              expect(v.item).toBe(5);\n            } else if (executionCount === 2) {\n              expect(v.item).toBeUndefined();\n            } else {\n              // should never get here\n              expect(executionCount).toBe(-1);\n            }\n            executionCount++;\n          }\n        )\n      );\n\n      // add\n      setState(\"obj\", \"item\", 5);\n\n      // delete\n      setState(\"obj\", \"item\", undefined);\n    });\n    expect.assertions(3);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Tracking Top level iteration Object key addition/removal","suites":["Tracking State changes"],"updatePoint":{"line":310,"column":64},"line":310,"code":"  test(\"Tracking Top level iteration Object key addition/removal\", () => {\n    createRoot(() => {\n      const [state, setState] = createStore<{ item?: number }>({});\n      let executionCount = 0;\n\n      createComputed(() => {\n        const keys = Object.keys(state);\n        if (executionCount === 0) expect(keys.length).toBe(0);\n        else if (executionCount === 1) {\n          expect(keys.length).toBe(1);\n          expect(keys[0]).toBe(\"item\");\n        } else if (executionCount === 2) {\n          expect(keys.length).toBe(0);\n        } else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n\n      // add\n      setState(\"item\", 5);\n\n      // delete\n      setState(\"item\", undefined);\n    });\n    expect.assertions(4);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Not Tracking Top level key addition/removal","suites":["Tracking State changes"],"updatePoint":{"line":339,"column":51},"line":339,"code":"  test(\"Not Tracking Top level key addition/removal\", () => {\n    createRoot(() => {\n      const [state, setState] = createStore<{ item?: number; item2?: number }>({});\n      let executionCount = 0;\n\n      createComputed(() => {\n        if (executionCount === 0) expect(state.item2).toBeUndefined();\n        else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n\n      // add\n      setState(\"item\", 5);\n\n      // delete\n      setState(\"item\", undefined);\n    });\n    expect.assertions(1);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Array Native Methods: Array.Filter","suites":["Handling functions in state"],"updatePoint":{"line":364,"column":42},"line":364,"code":"  test(\"Array Native Methods: Array.Filter\", () => {\n    createRoot(() => {\n      const [state] = createStore({ list: [0, 1, 2] }),\n        getFiltered = createMemo(() => state.list.filter(i => i % 2));\n      expect(getFiltered()).toStrictEqual([1]);\n    });\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track function change","suites":["Handling functions in state"],"updatePoint":{"line":372,"column":29},"line":372,"code":"  test(\"Track function change\", () => {\n    createRoot(() => {\n      const [state, setState] = createStore<{ fn: () => number }>({\n          fn: () => 1\n        }),\n        getValue = createMemo(() => state.fn());\n      setState({ fn: () => 2 });\n      expect(getValue()).toBe(2);\n    });\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting state from signal","suites":["Setting state from Effects"],"updatePoint":{"line":385,"column":33},"line":385,"code":"  test(\"Setting state from signal\", () => {\n    createRoot(() => {\n      const [getData, setData] = createSignal(\"init\"),\n        [state, setState] = createStore({ data: \"\" });\n      createComputed(() => setState(\"data\", getData()));\n      setData(\"signal\");\n      expect(state.data).toBe(\"signal\");\n    });\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Select Promise","suites":["Setting state from Effects"],"updatePoint":{"line":395,"column":22},"line":395,"code":"  test(\"Select Promise\", done => {\n    createRoot(async () => {\n      const p = new Promise<string>(resolve => {\n        setTimeout(resolve, 20, \"promised\");\n      });\n      const [state, setState] = createStore({ data: \"\" });\n      p.then(v => setState(\"data\", v));\n      await p;\n      expect(state.data).toBe(\"promised\");\n      done();\n    });\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting plain object","suites":["State wrapping"],"updatePoint":{"line":410,"column":28},"line":410,"code":"  test(\"Setting plain object\", () => {\n    const data = { withProperty: \"y\" },\n      [state] = createStore({ data });\n    // not wrapped\n    expect(state.data).not.toBe(data);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting plain array","suites":["State wrapping"],"updatePoint":{"line":416,"column":27},"line":416,"code":"  test(\"Setting plain array\", () => {\n    const data = [1, 2, 3],\n      [state] = createStore({ data });\n    // not wrapped\n    expect(state.data).not.toBe(data);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting non-wrappable","suites":["State wrapping"],"updatePoint":{"line":422,"column":29},"line":422,"code":"  test(\"Setting non-wrappable\", () => {\n    const date = new Date(),\n      [state] = createStore({ time: date });\n    // not wrapped\n    expect(state.time).toBe(date);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting plain object","suites":["Array length"],"updatePoint":{"line":431,"column":28},"line":431,"code":"  test(\"Setting plain object\", () => {\n    const [state, setState] = createStore<{ list: number[] }>({ list: [] });\n    let length;\n    // isolate length tracking\n    const list = state.list;\n    createRoot(() => {\n      createComputed(() => {\n        length = list.length;\n      });\n    });\n    expect(length).toBe(0);\n    // insert at index 0\n    setState(\"list\", 0, 1);\n    expect(length).toBe(1);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"there is no infinite loop","suites":["State recursion"],"updatePoint":{"line":449,"column":33},"line":449,"code":"  test(\"there is no infinite loop\", () => {\n    const x: { a: number; b: any } = { a: 1, b: undefined };\n    x.b = x;\n\n    const [state, setState] = createStore(x);\n    expect(state.a).toBe(state.b.a);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"wrapped nested class","suites":["Nested Classes"],"updatePoint":{"line":459,"column":28},"line":459,"code":"  test(\"wrapped nested class\", () => {\n    class CustomThing {\n      a: number;\n      b: number;\n      constructor(value: number) {\n        this.a = value;\n        this.b = 10;\n      }\n    }\n\n    const [inner] = createStore(new CustomThing(1));\n    const [store, setStore] = createStore({ inner });\n\n    expect(store.inner.a).toBe(1);\n    expect(store.inner.b).toBe(10);\n\n    let sum;\n    createRoot(() => {\n      createComputed(() => {\n        sum = store.inner.a + store.inner.b;\n      });\n    });\n    expect(sum).toBe(11);\n    setStore(\"inner\", \"a\", 10);\n    expect(sum).toBe(20);\n    setStore(\"inner\", \"b\", 5);\n    expect(sum).toBe(15);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"not wrapped nested class","suites":["Nested Classes"],"updatePoint":{"line":488,"column":32},"line":488,"code":"  test(\"not wrapped nested class\", () => {\n    class CustomThing {\n      a: number;\n      b: number;\n      constructor(value: number) {\n        this.a = value;\n        this.b = 10;\n      }\n    }\n    const [store, setStore] = createStore({ inner: new CustomThing(1) });\n\n    expect(store.inner.a).toBe(1);\n    expect(store.inner.b).toBe(10);\n\n    let sum;\n    createRoot(() => {\n      createComputed(() => {\n        sum = store.inner.a + store.inner.b;\n      });\n    });\n    expect(sum).toBe(11);\n    setStore(\"inner\", \"a\", 10);\n    expect(sum).toBe(11);\n    setStore(\"inner\", \"b\", 5);\n    expect(sum).toBe(11);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"}]}