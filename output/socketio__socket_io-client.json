{"repo":"socketio/socket.io-client","url":"https://github.com/socketio/socket.io-client","branch":"master","configs":[{"package":"socket.io-client","lang":"ts","dir":"test","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should have an accessible socket id equal to the server-side socket id (default namespace)","suites":["connection state recovery"],"updatePoint":{"line":6,"column":96},"line":6,"code":"  it(\"should have an accessible socket id equal to the server-side socket id (default namespace)\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, {\n        forceNew: true,\n      });\n\n      expect(socket.recovered).to.eql(false);\n\n      socket.emit(\"hi\"); // init the offset\n\n      socket.on(\"hi\", () => {\n        const id = socket.id;\n\n        socket.io.engine.close();\n\n        socket.on(\"connect\", () => {\n          expect(socket.id).to.eql(id); // means that the reconnection was successful\n          expect(socket.recovered).to.eql(true); // means that the reconnection was successful\n          done();\n        });\n      });\n    });\n  });","file":"connection-state-recovery.ts","skipped":false,"dir":"test"},{"name":"should connect to localhost","suites":["connection"],"updatePoint":{"line":9,"column":33},"line":9,"code":"  it(\"should connect to localhost\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket.emit(\"hi\");\n      socket.on(\"hi\", (data) => {\n        socket.disconnect();\n        done();\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should not connect when autoConnect option set to false","suites":["connection"],"updatePoint":{"line":20,"column":61},"line":20,"code":"  it(\"should not connect when autoConnect option set to false\", () => {\n    const socket = io(BASE_URL, { forceNew: true, autoConnect: false });\n    expect(socket.io.engine).to.not.be.ok();\n    socket.disconnect();\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should start two connections with same path","suites":["connection"],"updatePoint":{"line":26,"column":49},"line":26,"code":"  it(\"should start two connections with same path\", () => {\n    const s1 = io(BASE_URL + \"/\");\n    const s2 = io(BASE_URL + \"/\");\n\n    expect(s1.io).to.not.be(s2.io);\n    s1.disconnect();\n    s2.disconnect();\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should start two connections with same path and different querystrings","suites":["connection"],"updatePoint":{"line":35,"column":76},"line":35,"code":"  it(\"should start two connections with same path and different querystrings\", () => {\n    const s1 = io(BASE_URL + \"/?woot\");\n    const s2 = io(BASE_URL + \"/\");\n\n    expect(s1.io).to.not.be(s2.io);\n    s1.disconnect();\n    s2.disconnect();\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should start two connections with different paths","suites":["connection"],"updatePoint":{"line":44,"column":55},"line":44,"code":"  it(\"should start two connections with different paths\", () => {\n    const s1 = io(BASE_URL + \"/\", { path: \"/foo\" });\n    const s2 = io(BASE_URL + \"/\", { path: \"/bar\" });\n\n    expect(s1.io).to.not.be(s2.io);\n    s1.disconnect();\n    s2.disconnect();\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should start a single connection with different namespaces","suites":["connection"],"updatePoint":{"line":53,"column":64},"line":53,"code":"  it(\"should start a single connection with different namespaces\", () => {\n    const opts = {};\n    const s1 = io(BASE_URL + \"/foo\", opts);\n    const s2 = io(BASE_URL + \"/bar\", opts);\n\n    expect(s1.io).to.be(s2.io);\n    s1.disconnect();\n    s2.disconnect();\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should work with acks","suites":["connection"],"updatePoint":{"line":63,"column":27},"line":63,"code":"  it(\"should work with acks\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket.emit(\"ack\");\n      socket.on(\"ack\", (fn) => {\n        fn(5, { test: true });\n      });\n      socket.on(\"got it\", () => {\n        socket.disconnect();\n        done();\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should receive date with ack","suites":["connection"],"updatePoint":{"line":77,"column":34},"line":77,"code":"  it(\"should receive date with ack\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket.emit(\"getAckDate\", { test: true }, (data) => {\n        expect(data).to.be.a(\"string\");\n        socket.disconnect();\n        done();\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should work with false","suites":["connection"],"updatePoint":{"line":88,"column":28},"line":88,"code":"  it(\"should work with false\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket.emit(\"false\");\n      socket.on(\"false\", (f) => {\n        expect(f).to.be(false);\n        socket.disconnect();\n        done();\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should receive utf8 multibyte characters","suites":["connection"],"updatePoint":{"line":100,"column":46},"line":100,"code":"  it(\"should receive utf8 multibyte characters\", () => {\n    return wrap((done) => {\n      const correct = [\n        \"てすと\",\n        \"Я Б Г Д Ж Й\",\n        \"Ä ä Ü ü ß\",\n        \"utf8 — string\",\n        \"utf8 — string\",\n      ];\n\n      const socket = io(BASE_URL, { forceNew: true });\n      let i = 0;\n      socket.on(\"takeUtf8\", (data) => {\n        expect(data).to.be(correct[i]);\n        i++;\n        if (i === correct.length) {\n          socket.disconnect();\n          done();\n        }\n      });\n      socket.emit(\"getUtf8\");\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should connect to a namespace after connection established","suites":["connection"],"updatePoint":{"line":124,"column":64},"line":124,"code":"  it(\"should connect to a namespace after connection established\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL);\n      const socket = manager.socket(\"/\");\n      socket.on(\"connect\", () => {\n        const foo = manager.socket(\"/foo\");\n        foo.on(\"connect\", () => {\n          foo.close();\n          socket.close();\n          manager._close();\n          done();\n        });\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should open a new namespace after connection gets closed","suites":["connection"],"updatePoint":{"line":140,"column":62},"line":140,"code":"  it(\"should open a new namespace after connection gets closed\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL);\n      const socket = manager.socket(\"/\");\n      socket\n        .on(\"connect\", () => {\n          socket.disconnect();\n        })\n        .on(\"disconnect\", () => {\n          const foo = manager.socket(\"/foo\");\n          foo.on(\"connect\", () => {\n            foo.disconnect();\n            manager._close();\n            done();\n          });\n        });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should reconnect by default","suites":["connection"],"updatePoint":{"line":159,"column":33},"line":159,"code":"  it(\"should reconnect by default\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true, reconnectionDelay: 0 });\n      socket.io.on(\"reconnect\", () => {\n        socket.disconnect();\n        done();\n      });\n\n      setTimeout(() => {\n        socket.io.engine.close();\n      }, 500);\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should reconnect manually","suites":["connection"],"updatePoint":{"line":173,"column":31},"line":173,"code":"  it(\"should reconnect manually\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket\n        .once(\"connect\", () => {\n          socket.disconnect();\n        })\n        .once(\"disconnect\", () => {\n          socket.once(\"connect\", () => {\n            socket.disconnect();\n            done();\n          });\n          socket.connect();\n        });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should reconnect automatically after reconnecting manually","suites":["connection"],"updatePoint":{"line":190,"column":64},"line":190,"code":"  it(\"should reconnect automatically after reconnecting manually\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket\n        .once(\"connect\", () => {\n          socket.disconnect();\n        })\n        .once(\"disconnect\", () => {\n          socket.io.on(\"reconnect\", () => {\n            socket.disconnect();\n            done();\n          });\n          socket.connect();\n          setTimeout(() => {\n            socket.io.engine.close();\n          }, 500);\n        });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should attempt reconnects after a failed reconnect","suites":["connection"],"updatePoint":{"line":210,"column":56},"line":210,"code":"  it(\"should attempt reconnects after a failed reconnect\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL, {\n        reconnection: true,\n        timeout: 0,\n        reconnectionAttempts: 2,\n        reconnectionDelay: 10,\n      });\n      const socket = manager.socket(\"/timeout\");\n      manager.once(\"reconnect_failed\", () => {\n        let reconnects = 0;\n        const reconnectCb = () => {\n          reconnects++;\n        };\n\n        manager.on(\"reconnect_attempt\", reconnectCb);\n        manager.on(\"reconnect_failed\", () => {\n          expect(reconnects).to.be(2);\n          socket.close();\n          manager._close();\n          done();\n        });\n        socket.connect();\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"reconnect delay should increase every time","suites":["connection"],"updatePoint":{"line":237,"column":48},"line":237,"code":"  it(\"reconnect delay should increase every time\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL, {\n        reconnection: true,\n        timeout: 0,\n        reconnectionAttempts: 3,\n        reconnectionDelay: 100,\n        randomizationFactor: 0.2,\n      });\n      const socket = manager.socket(\"/timeout\");\n      let reconnects = 0;\n      let increasingDelay = true;\n      let startTime;\n      let prevDelay = 0;\n\n      manager.on(\"error\", () => {\n        startTime = new Date().getTime();\n      });\n      manager.on(\"reconnect_attempt\", () => {\n        reconnects++;\n        const currentTime = new Date().getTime();\n        const delay = currentTime - startTime;\n        if (delay <= prevDelay) {\n          increasingDelay = false;\n        }\n        prevDelay = delay;\n      });\n\n      manager.on(\"reconnect_failed\", () => {\n        expect(reconnects).to.be(3);\n        expect(increasingDelay).to.be.ok();\n        socket.close();\n        manager._close();\n        done();\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should not reconnect when force closed","suites":["connection"],"updatePoint":{"line":275,"column":44},"line":275,"code":"  it(\"should not reconnect when force closed\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL + \"/invalid\", {\n        forceNew: true,\n        timeout: 0,\n        reconnectionDelay: 10,\n      });\n      socket.io.once(\"error\", () => {\n        socket.io.on(\"reconnect_attempt\", () => {\n          expect().fail();\n        });\n        socket.disconnect();\n        // set a timeout to let reconnection possibly fire\n        setTimeout(() => {\n          done();\n        }, 500);\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should stop reconnecting when force closed","suites":["connection"],"updatePoint":{"line":295,"column":48},"line":295,"code":"  it(\"should stop reconnecting when force closed\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL + \"/invalid\", {\n        forceNew: true,\n        timeout: 0,\n        reconnectionDelay: 10,\n      });\n      socket.io.once(\"reconnect_attempt\", () => {\n        socket.io.on(\"reconnect_attempt\", () => {\n          expect().fail();\n        });\n        socket.disconnect();\n        // set a timeout to let reconnection possibly fire\n        setTimeout(() => {\n          done();\n        }, 500);\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should reconnect after stopping reconnection","suites":["connection"],"updatePoint":{"line":315,"column":50},"line":315,"code":"  it(\"should reconnect after stopping reconnection\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL + \"/invalid\", {\n        forceNew: true,\n        timeout: 0,\n        reconnectionDelay: 10,\n      });\n      socket.io.once(\"reconnect_attempt\", () => {\n        socket.io.on(\"reconnect_attempt\", () => {\n          socket.disconnect();\n          done();\n        });\n        socket.disconnect();\n        socket.connect();\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should stop reconnecting on a socket and keep to reconnect on another","suites":["connection"],"updatePoint":{"line":333,"column":75},"line":333,"code":"  it(\"should stop reconnecting on a socket and keep to reconnect on another\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL);\n      const socket1 = manager.socket(\"/\");\n      const socket2 = manager.socket(\"/asd\");\n\n      manager.on(\"reconnect_attempt\", () => {\n        socket1.on(\"connect\", () => {\n          expect().fail();\n        });\n        socket2.on(\"connect\", () => {\n          setTimeout(() => {\n            socket2.disconnect();\n            manager._close();\n            done();\n          }, 500);\n        });\n        socket1.disconnect();\n      });\n\n      setTimeout(() => {\n        manager.engine.close();\n      }, 1000);\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should try to reconnect twice and fail when requested two attempts with immediate timeout and reconnect enabled","suites":["connection"],"updatePoint":{"line":359,"column":117},"line":359,"code":"  it(\"should try to reconnect twice and fail when requested two attempts with immediate timeout and reconnect enabled\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL, {\n        reconnection: true,\n        timeout: 0,\n        reconnectionAttempts: 2,\n        reconnectionDelay: 10,\n      });\n      let socket;\n\n      let reconnects = 0;\n      const reconnectCb = () => {\n        reconnects++;\n      };\n\n      manager.on(\"reconnect_attempt\", reconnectCb);\n      manager.on(\"reconnect_failed\", () => {\n        expect(reconnects).to.be(2);\n        socket.close();\n        manager._close();\n        done();\n      });\n\n      socket = manager.socket(\"/timeout\");\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should fire reconnect_* events on manager","suites":["connection"],"updatePoint":{"line":386,"column":47},"line":386,"code":"  it(\"should fire reconnect_* events on manager\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL, {\n        reconnection: true,\n        timeout: 0,\n        reconnectionAttempts: 2,\n        reconnectionDelay: 10,\n      });\n      const socket = manager.socket(\"/timeout_socket\");\n\n      let reconnects = 0;\n      const reconnectCb = (attempts) => {\n        reconnects++;\n        expect(attempts).to.be(reconnects);\n      };\n\n      manager.on(\"reconnect_attempt\", reconnectCb);\n      manager.on(\"reconnect_failed\", () => {\n        expect(reconnects).to.be(2);\n        socket.close();\n        manager._close();\n        done();\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should fire reconnecting (on manager) with attempts number when reconnecting twice","suites":["connection"],"updatePoint":{"line":412,"column":88},"line":412,"code":"  it(\"should fire reconnecting (on manager) with attempts number when reconnecting twice\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL, {\n        reconnection: true,\n        timeout: 0,\n        reconnectionAttempts: 2,\n        reconnectionDelay: 10,\n      });\n      const socket = manager.socket(\"/timeout_socket\");\n\n      let reconnects = 0;\n      const reconnectCb = (attempts) => {\n        reconnects++;\n        expect(attempts).to.be(reconnects);\n      };\n\n      manager.on(\"reconnect_attempt\", reconnectCb);\n      manager.on(\"reconnect_failed\", () => {\n        expect(reconnects).to.be(2);\n        socket.close();\n        manager._close();\n        done();\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should not try to reconnect and should form a connection when connecting to correct port with default timeout","suites":["connection"],"updatePoint":{"line":438,"column":115},"line":438,"code":"  it(\"should not try to reconnect and should form a connection when connecting to correct port with default timeout\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL, {\n        reconnection: true,\n        reconnectionDelay: 10,\n      });\n      const cb = () => {\n        socket.close();\n        expect().fail();\n      };\n      manager.on(\"reconnect_attempt\", cb);\n\n      var socket = manager.socket(\"/valid\");\n      socket.on(\"connect\", () => {\n        // set a timeout to let reconnection possibly fire\n        setTimeout(() => {\n          socket.close();\n          manager._close();\n          done();\n        }, 1000);\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should connect while disconnecting another socket","suites":["connection"],"updatePoint":{"line":462,"column":55},"line":462,"code":"  it(\"should connect while disconnecting another socket\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL);\n      const socket1 = manager.socket(\"/foo\");\n      socket1.on(\"connect\", () => {\n        const socket2 = manager.socket(\"/asd\");\n        socket2.on(\"connect\", done);\n        socket1.disconnect();\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should emit a connect_error event when reaching a Socket.IO server in v2.x","suites":["connection"],"updatePoint":{"line":474,"column":80},"line":474,"code":"  it(\"should emit a connect_error event when reaching a Socket.IO server in v2.x\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, {\n        autoConnect: false,\n      });\n\n      socket.on(\"connect_error\", () => {\n        done();\n      });\n\n      // @ts-ignore\n      socket.onpacket({\n        nsp: \"/\",\n        type: 0,\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should not close the connection when disconnecting a single socket","suites":["connection"],"updatePoint":{"line":492,"column":72},"line":492,"code":"  it(\"should not close the connection when disconnecting a single socket\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL, {\n        autoConnect: false,\n      });\n      const socket1 = manager.socket(\"/foo\");\n      const socket2 = manager.socket(\"/asd\");\n\n      socket1.connect();\n      socket1.on(\"connect\", () => {\n        socket2.connect();\n      });\n\n      socket2.on(\"connect\", () => {\n        socket2.on(\"disconnect\", () => {\n          done(new Error(\"should not happen for now\"));\n        });\n        socket1.disconnect();\n        setTimeout(() => {\n          socket2.off(\"disconnect\");\n          manager.on(\"close\", () => {\n            done();\n          });\n          socket2.disconnect();\n        }, 200);\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should try to reconnect twice and fail when requested two attempts with incorrect address and reconnect enabled","suites":["connection"],"updatePoint":{"line":524,"column":119},"line":524,"code":"    it(\"should try to reconnect twice and fail when requested two attempts with incorrect address and reconnect enabled\", () => {\n      return wrap((done) => {\n        const manager = new Manager(\"http://localhost:3940\", {\n          reconnection: true,\n          reconnectionAttempts: 2,\n          reconnectionDelay: 10,\n        });\n        const socket = manager.socket(\"/asd\");\n        let reconnects = 0;\n        const cb = () => {\n          reconnects++;\n        };\n\n        manager.on(\"reconnect_attempt\", cb);\n\n        manager.on(\"reconnect_failed\", () => {\n          expect(reconnects).to.be(2);\n          socket.disconnect();\n          manager._close();\n          done();\n        });\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should not try to reconnect with incorrect port when reconnection disabled","suites":["connection"],"updatePoint":{"line":548,"column":82},"line":548,"code":"    it(\"should not try to reconnect with incorrect port when reconnection disabled\", () => {\n      return wrap((done) => {\n        const manager = new Manager(\"http://localhost:9823\", {\n          reconnection: false,\n        });\n        const cb = () => {\n          socket.close();\n          expect().fail();\n        };\n        manager.on(\"reconnect_attempt\", cb);\n\n        manager.on(\"error\", () => {\n          // set a timeout to let reconnection possibly fire\n          setTimeout(() => {\n            socket.disconnect();\n            manager._close();\n            done();\n          }, 1000);\n        });\n\n        var socket = manager.socket(\"/invalid\");\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should still try to reconnect twice after opening another socket asynchronously","suites":["connection"],"updatePoint":{"line":572,"column":87},"line":572,"code":"    it(\"should still try to reconnect twice after opening another socket asynchronously\", () => {\n      return wrap((done) => {\n        const manager = new Manager(\"http://localhost:9823\", {\n          reconnection: true,\n          reconnectionAttempts: 2,\n        });\n        let delay = Math.floor(\n          manager.reconnectionDelay() * manager.randomizationFactor() * 0.5\n        );\n        delay = Math.max(delay, 10);\n\n        let reconnects = 0;\n        const cb = () => {\n          reconnects++;\n        };\n\n        manager.on(\"reconnect_attempt\", cb);\n\n        manager.on(\"reconnect_failed\", () => {\n          expect(reconnects).to.be(2);\n          socket.disconnect();\n          manager._close();\n          done();\n        });\n\n        var socket = manager.socket(\"/room1\");\n\n        setTimeout(() => {\n          manager.socket(\"/room2\");\n        }, delay);\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should use overridden setTimeout by default","suites":["connection","reconnect timeout"],"updatePoint":{"line":631,"column":51},"line":631,"code":"    it(\"should use overridden setTimeout by default\", async () => {\n      const clock = install();\n      const manager = new Manager(options);\n      setupManagerCallbacks(manager);\n\n      // Wait real clock time for the socket to connect before disconnecting it.\n      await clock.tickAsync(options.timeout);\n      await wait(options.timeout);\n      manager.engine.close();\n\n      // Let the clock approach the reconnect delay.\n      await clock.tickAsync(options.reconnectionDelayMax - 1);\n      expect(reconnected).to.be(false);\n\n      await clock.tickAsync(1); // reconnect.\n      expect(reconnected).to.be(true);\n\n      clock.uninstall();\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should use native setTimeout with useNativeSetTimers","suites":["connection","reconnect timeout"],"updatePoint":{"line":651,"column":60},"line":651,"code":"    it(\"should use native setTimeout with useNativeSetTimers\", async () => {\n      options.useNativeTimers = true;\n      const clock = install();\n      const manager = new Manager(options);\n      setupManagerCallbacks(manager);\n\n      // Wait real clock time for the socket to connect before disconnecting it.\n      await clock.tickAsync(options.timeout);\n      await wait(options.timeout);\n      manager.engine.close();\n\n      // Since the client will not use the overridden timeout function,\n      // advancing the fake clock should not reconnect.\n      await clock.tickAsync(options.reconnectionDelayMax);\n      expect(reconnected).to.be(false);\n      clock.uninstall();\n\n      // Wait reconnectionDelayMax to trigger reconnect.\n      await wait(options.reconnectionDelayMax);\n      expect(reconnected).to.be(true);\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should emit date as string","suites":["connection","reconnect timeout"],"updatePoint":{"line":674,"column":32},"line":674,"code":"  it(\"should emit date as string\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket.on(\"takeDate\", (data) => {\n        socket.close();\n        expect(data).to.be.a(\"string\");\n        done();\n      });\n      socket.emit(\"getDate\");\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should emit date in object","suites":["connection","reconnect timeout"],"updatePoint":{"line":686,"column":32},"line":686,"code":"  it(\"should emit date in object\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket.on(\"takeDateObj\", (data) => {\n        socket.close();\n        expect(data).to.be.an(\"object\");\n        expect(data.date).to.be.a(\"string\");\n        done();\n      });\n      socket.emit(\"getDateObj\");\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should get base64 data as a last resort","suites":["connection","reconnect timeout"],"updatePoint":{"line":700,"column":47},"line":700,"code":"    it(\"should get base64 data as a last resort\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL, { forceNew: true });\n        socket.on(\"takebin\", (a) => {\n          socket.disconnect();\n          expect(a.base64).to.be(true);\n          expect(a.data).to.eql(\"YXNkZmFzZGY=\");\n          done();\n        });\n        socket.emit(\"getbin\");\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should get binary data (as an ArrayBuffer)","suites":["connection","reconnect timeout"],"updatePoint":{"line":717,"column":50},"line":717,"code":"    it(\"should get binary data (as an ArrayBuffer)\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL, { forceNew: true });\n        if (typeof window === \"undefined\") {\n          socket.io.engine.binaryType = \"arraybuffer\";\n        }\n        socket.emit(\"doge\");\n        socket.on(\"doge\", (buffer) => {\n          expect(buffer instanceof ArrayBuffer).to.be(true);\n          socket.disconnect();\n          done();\n        });\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send binary data (as an ArrayBuffer)","suites":["connection","reconnect timeout"],"updatePoint":{"line":732,"column":51},"line":732,"code":"    it(\"should send binary data (as an ArrayBuffer)\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL, { forceNew: true });\n        socket.on(\"buffack\", () => {\n          socket.disconnect();\n          done();\n        });\n        const buf = base64.decode(\"asdfasdf\");\n        socket.emit(\"buffa\", buf);\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send binary data (as an ArrayBuffer) mixed with json","suites":["connection","reconnect timeout"],"updatePoint":{"line":744,"column":67},"line":744,"code":"    it(\"should send binary data (as an ArrayBuffer) mixed with json\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL, { forceNew: true });\n        socket.on(\"jsonbuff-ack\", () => {\n          socket.disconnect();\n          done();\n        });\n        const buf = base64.decode(\"howdy\");\n        socket.emit(\"jsonbuff\", {\n          hello: \"lol\",\n          message: buf,\n          goodbye: \"gotcha\",\n        });\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send events with ArrayBuffers in the correct order","suites":["connection","reconnect timeout"],"updatePoint":{"line":760,"column":65},"line":760,"code":"    it(\"should send events with ArrayBuffers in the correct order\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL, { forceNew: true });\n        socket.on(\"abuff2-ack\", () => {\n          socket.disconnect();\n          done();\n        });\n        const buf = base64.decode(\"abuff1\");\n        socket.emit(\"abuff1\", buf);\n        socket.emit(\"abuff2\", \"please arrive second\");\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send binary data (as a Blob)","suites":["connection","reconnect timeout"],"updatePoint":{"line":775,"column":43},"line":775,"code":"    it(\"should send binary data (as a Blob)\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL, { forceNew: true });\n        socket.on(\"back\", () => {\n          socket.disconnect();\n          done();\n        });\n        const blob = textBlobBuilder(\"hello world\");\n        socket.emit(\"blob\", blob);\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send binary data (as a Blob) mixed with json","suites":["connection","reconnect timeout"],"updatePoint":{"line":787,"column":59},"line":787,"code":"    it(\"should send binary data (as a Blob) mixed with json\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL, { forceNew: true });\n        socket.on(\"jsonblob-ack\", () => {\n          socket.disconnect();\n          done();\n        });\n        const blob = textBlobBuilder(\"EEEEEEEEE\");\n        socket.emit(\"jsonblob\", {\n          hello: \"lol\",\n          message: blob,\n          goodbye: \"gotcha\",\n        });\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send events with Blobs in the correct order","suites":["connection","reconnect timeout"],"updatePoint":{"line":803,"column":58},"line":803,"code":"    it(\"should send events with Blobs in the correct order\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL, { forceNew: true });\n        socket.on(\"blob3-ack\", () => {\n          socket.disconnect();\n          done();\n        });\n        const blob = textBlobBuilder(\"BLOBBLOB\");\n        socket.emit(\"blob1\", blob);\n        socket.emit(\"blob2\", \"second\");\n        socket.emit(\"blob3\", blob);\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should reopen a cached socket","suites":["connection","reconnect timeout"],"updatePoint":{"line":818,"column":35},"line":818,"code":"  it(\"should reopen a cached socket\", () => {\n    return wrap((done) => {\n      const manager = new Manager(BASE_URL, {\n        autoConnect: true,\n      });\n      const socket = manager.socket(\"/\");\n      socket.on(\"connect\", () => {\n        socket.disconnect();\n      });\n\n      socket.on(\"disconnect\", () => {\n        const socket2 = manager.socket(\"/\");\n\n        expect(socket2 === socket).to.be(true);\n        expect(socket2.active).to.be(true);\n\n        socket2.on(\"connect\", () => {\n          socket2.disconnect();\n          done();\n        });\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should stop once the timer is triggered","suites":["autoUnref option"],"updatePoint":{"line":14,"column":45},"line":14,"code":"  it(\"should stop once the timer is triggered\", (done) => {\n    exec(fixture(\"unref.ts\"), done);\n  });","file":"node.ts","skipped":false,"dir":"test"},{"name":"should stop once the timer is triggered (even when trying to reconnect)","suites":["autoUnref option"],"updatePoint":{"line":18,"column":77},"line":18,"code":"  it(\"should stop once the timer is triggered (even when trying to reconnect)\", (done) => {\n    exec(fixture(\"unref-during-reconnection.ts\"), done);\n  });","file":"node.ts","skipped":false,"dir":"test"},{"name":"should stop once the timer is triggered (polling)","suites":["autoUnref option"],"updatePoint":{"line":22,"column":55},"line":22,"code":"  it(\"should stop once the timer is triggered (polling)\", (done) => {\n    exec(fixture(\"unref-polling-only.ts\"), done);\n  });","file":"node.ts","skipped":false,"dir":"test"},{"name":"should stop once the timer is triggered (websocket)","suites":["autoUnref option"],"updatePoint":{"line":26,"column":57},"line":26,"code":"  it(\"should stop once the timer is triggered (websocket)\", (done) => {\n    exec(fixture(\"unref-websocket-only.ts\"), done);\n  });","file":"node.ts","skipped":false,"dir":"test"},{"name":"should not stop with autoUnref set to false","suites":["autoUnref option"],"updatePoint":{"line":30,"column":49},"line":30,"code":"  it(\"should not stop with autoUnref set to false\", (done) => {\n    const process = exec(fixture(\"no-unref.ts\"), () => {\n      done(new Error(\"should not happen\"));\n    });\n    setTimeout(() => {\n      process.kill();\n      done();\n    }, 1000);\n  });","file":"node.ts","skipped":false,"dir":"test"},{"name":"should preserve the order of the packets","suites":["retry"],"updatePoint":{"line":6,"column":46},"line":6,"code":"  it(\"should preserve the order of the packets\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, {\n        forceNew: true,\n        retries: 1,\n        ackTimeout: 50,\n      });\n\n      let i = 0;\n      const expected = [\n        \"0\",\n        '20[\"echo\",1]',\n        '21[\"echo\",2]',\n        '22[\"echo\",3]',\n        \"1\",\n      ];\n\n      socket.io.engine.on(\"packetCreate\", ({ data }) => {\n        expect(data).to.eql(expected[i++]);\n      });\n\n      socket.emit(\"echo\", 1, () => {\n        // @ts-ignore\n        expect(socket._queue.length).to.eql(2);\n      });\n\n      // @ts-ignore\n      expect(socket._queue.length).to.eql(1);\n\n      socket.emit(\"echo\", 2, () => {\n        // @ts-ignore\n        expect(socket._queue.length).to.eql(1);\n      });\n\n      // @ts-ignore\n      expect(socket._queue.length).to.eql(2);\n\n      socket.emit(\"echo\", 3, (err, val) => {\n        expect(err).to.be(null);\n        expect(val).to.eql(3);\n        // @ts-ignore\n        expect(socket._queue.length).to.eql(0);\n\n        success(done, socket);\n      });\n\n      // @ts-ignore\n      expect(socket._queue.length).to.eql(3);\n    });\n  });","file":"retry.ts","skipped":false,"dir":"test"},{"name":"should fail when the server does not acknowledge the packet","suites":["retry"],"updatePoint":{"line":57,"column":65},"line":57,"code":"  it(\"should fail when the server does not acknowledge the packet\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, {\n        forceNew: true,\n        retries: 3,\n        ackTimeout: 50,\n      });\n\n      let count = 0;\n\n      let i = 0;\n      const expected = [\n        \"0\",\n        '20[\"ack\"]',\n        '20[\"ack\"]',\n        '20[\"ack\"]',\n        '20[\"ack\"]',\n        \"1\",\n      ];\n\n      socket.io.engine.on(\"packetCreate\", ({ data }) => {\n        expect(data).to.eql(expected[i++]);\n      });\n\n      socket.emit(\"ack\", () => {\n        expect(count).to.eql(4);\n\n        success(done, socket);\n      });\n\n      socket.on(\"ack\", () => {\n        count++;\n      });\n    });\n  });","file":"retry.ts","skipped":false,"dir":"test"},{"name":"should have an accessible socket id equal to the server-side socket id (default namespace)","suites":["socket"],"updatePoint":{"line":6,"column":96},"line":6,"code":"  it(\"should have an accessible socket id equal to the server-side socket id (default namespace)\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n\n      socket.emit(\"getId\", (id) => {\n        expect(socket.id).to.be.ok();\n        expect(socket.id).to.be.eql(id);\n        expect(socket.id).to.not.eql(socket.io.engine.id);\n        socket.disconnect();\n        done();\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should have an accessible socket id equal to the server-side socket id (custom namespace)","suites":["socket"],"updatePoint":{"line":20,"column":95},"line":20,"code":"  it(\"should have an accessible socket id equal to the server-side socket id (custom namespace)\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL + \"/foo\", { forceNew: true });\n      socket.emit(\"getId\", (id) => {\n        expect(socket.id).to.be.ok();\n        expect(socket.id).to.be.eql(id);\n        expect(socket.id).to.not.eql(socket.io.engine.id);\n        socket.disconnect();\n        done();\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"clears socket.id upon disconnection","suites":["socket"],"updatePoint":{"line":33,"column":41},"line":33,"code":"  it(\"clears socket.id upon disconnection\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket.on(\"connect\", () => {\n        socket.on(\"disconnect\", () => {\n          expect(socket.id).to.not.be.ok();\n          done();\n        });\n\n        socket.disconnect();\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"doesn't fire an error event if we force disconnect in opening state","suites":["socket"],"updatePoint":{"line":47,"column":73},"line":47,"code":"  it(\"doesn't fire an error event if we force disconnect in opening state\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true, timeout: 100 });\n      socket.disconnect();\n      socket.io.on(\"error\", () => {\n        throw new Error(\"Unexpected\");\n      });\n      setTimeout(() => {\n        done();\n      }, 300);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"fire a connect_error event when the connection cannot be established","suites":["socket"],"updatePoint":{"line":60,"column":74},"line":60,"code":"  it(\"fire a connect_error event when the connection cannot be established\", () => {\n    return wrap((done) => {\n      const socket = io(\"http://localhost:9823\", {\n        forceNew: true,\n        timeout: 100,\n      });\n      socket.on(\"connect_error\", () => {\n        socket.close();\n        done();\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"doesn't fire a connect_error event when the connection is already established","suites":["socket"],"updatePoint":{"line":73,"column":83},"line":73,"code":"  it(\"doesn't fire a connect_error event when the connection is already established\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket.on(\"connect\", () => {\n        socket.io.engine.close();\n      });\n      socket.on(\"connect_error\", () => {\n        done(new Error(\"should not happen\"));\n      });\n      setTimeout(() => {\n        socket.close();\n        done();\n      }, 300);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should change socket.id upon reconnection","suites":["socket"],"updatePoint":{"line":89,"column":47},"line":89,"code":"  it(\"should change socket.id upon reconnection\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket.on(\"connect\", () => {\n        const id = socket.id;\n\n        socket.io.on(\"reconnect_attempt\", () => {\n          expect(socket.id).to.not.be.ok();\n        });\n\n        socket.io.on(\"reconnect\", () => {\n          expect(socket.id).to.not.eql(id);\n          socket.disconnect();\n          done();\n        });\n\n        socket.io.engine.close();\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should enable compression by default","suites":["socket"],"updatePoint":{"line":110,"column":42},"line":110,"code":"  it(\"should enable compression by default\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket.on(\"connect\", () => {\n        socket.io.engine.once(\"packetCreate\", (packet) => {\n          expect(packet.options.compress).to.be(true);\n          socket.disconnect();\n          done();\n        });\n        socket.emit(\"hi\");\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should disable compression","suites":["socket"],"updatePoint":{"line":124,"column":32},"line":124,"code":"  it(\"should disable compression\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n      socket.on(\"connect\", () => {\n        socket.io.engine.once(\"packetCreate\", (packet) => {\n          expect(packet.options.compress).to.be(false);\n          socket.disconnect();\n          done();\n        });\n        socket.compress(false).emit(\"hi\");\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept an object (default namespace)","suites":["socket","query option"],"updatePoint":{"line":139,"column":51},"line":139,"code":"    it(\"should accept an object (default namespace)\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/\", {\n          forceNew: true,\n          query: { e: \"f\" },\n        });\n\n        socket.emit(\"getHandshake\", (handshake) => {\n          expect(handshake.query.e).to.be(\"f\");\n          socket.disconnect();\n          done();\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept a query string (default namespace)","suites":["socket","query option"],"updatePoint":{"line":154,"column":56},"line":154,"code":"    it(\"should accept a query string (default namespace)\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/?c=d\", { forceNew: true });\n\n        socket.emit(\"getHandshake\", (handshake) => {\n          expect(handshake.query.c).to.be(\"d\");\n          socket.disconnect();\n          done();\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept an object","suites":["socket","query option"],"updatePoint":{"line":166,"column":31},"line":166,"code":"    it(\"should accept an object\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc\", {\n          forceNew: true,\n          query: { a: \"b\" },\n        });\n\n        socket.on(\"handshake\", (handshake) => {\n          expect(handshake.query.a).to.be(\"b\");\n          socket.disconnect();\n          done();\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept a query string","suites":["socket","query option"],"updatePoint":{"line":181,"column":36},"line":181,"code":"    it(\"should accept a query string\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc?b=c&d=e\", { forceNew: true });\n\n        socket.on(\"handshake\", (handshake) => {\n          expect(handshake.query.b).to.be(\"c\");\n          expect(handshake.query.d).to.be(\"e\");\n          socket.disconnect();\n          done();\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should properly encode the parameters","suites":["socket","query option"],"updatePoint":{"line":194,"column":45},"line":194,"code":"    it(\"should properly encode the parameters\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc\", {\n          forceNew: true,\n          query: { \"&a\": \"&=?a\" },\n        });\n\n        socket.on(\"handshake\", (handshake) => {\n          expect(handshake.query[\"&a\"]).to.be(\"&=?a\");\n          socket.disconnect();\n          done();\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept an object","suites":["socket","auth option"],"updatePoint":{"line":211,"column":31},"line":211,"code":"    it(\"should accept an object\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc\", {\n          forceNew: true,\n          auth: { a: \"b\", c: \"d\" },\n        });\n\n        socket.on(\"handshake\", (handshake) => {\n          expect(handshake.auth.a).to.be(\"b\");\n          expect(handshake.auth.c).to.be(\"d\");\n          expect(handshake.query.a).to.be(undefined);\n          socket.disconnect();\n          done();\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept an function","suites":["socket","auth option"],"updatePoint":{"line":228,"column":33},"line":228,"code":"    it(\"should accept an function\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc\", {\n          forceNew: true,\n          auth: (cb) => cb({ e: \"f\" }),\n        });\n\n        socket.on(\"handshake\", (handshake) => {\n          expect(handshake.auth.e).to.be(\"f\");\n          expect(handshake.query.e).to.be(undefined);\n          socket.disconnect();\n          done();\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should fire an error event on middleware failure from custom namespace","suites":["socket","auth option"],"updatePoint":{"line":245,"column":76},"line":245,"code":"  it(\"should fire an error event on middleware failure from custom namespace\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL + \"/no\", { forceNew: true });\n      socket.on(\"connect_error\", (err) => {\n        expect(err).to.be.an(Error);\n        expect(err.message).to.eql(\"Auth failed (custom namespace)\");\n        socket.disconnect();\n        done();\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not try to reconnect after a middleware failure","suites":["socket","auth option"],"updatePoint":{"line":257,"column":60},"line":257,"code":"  it(\"should not try to reconnect after a middleware failure\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL + \"/no\", {\n        forceNew: true,\n        reconnectionDelay: 10,\n      });\n\n      let count = 0;\n\n      socket.on(\"connect_error\", () => {\n        count++;\n        // force reconnection\n        socket.io.engine.close();\n      });\n\n      setTimeout(() => {\n        expect(count).to.eql(1);\n        done();\n      }, 100);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should properly disconnect then reconnect","suites":["socket","auth option"],"updatePoint":{"line":279,"column":47},"line":279,"code":"  it(\"should properly disconnect then reconnect\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL + \"/\", {\n        forceNew: true,\n        transports: [\"websocket\"],\n      });\n\n      let count = 0;\n\n      socket.once(\"connect\", () => {\n        socket.disconnect().connect();\n      });\n\n      socket.on(\"disconnect\", () => {\n        count++;\n      });\n\n      setTimeout(() => {\n        expect(count).to.eql(1);\n        success(done, socket);\n      }, 200);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should throw on reserved event","suites":["socket","auth option"],"updatePoint":{"line":303,"column":36},"line":303,"code":"  it(\"should throw on reserved event\", () => {\n    const socket = io(BASE_URL + \"/no\", { forceNew: true });\n\n    expect(() => socket.emit(\"disconnecting\", \"goodbye\")).to.throwException(\n      /\"disconnecting\" is a reserved event name/\n    );\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit events in order","suites":["socket","auth option"],"updatePoint":{"line":311,"column":33},"line":311,"code":"  it(\"should emit events in order\", () => {\n    return wrap((done) => {\n      const socket = io(BASE_URL + \"/\", { autoConnect: false });\n      let i = 0;\n\n      socket.on(\"connect\", () => {\n        socket.emit(\"echo\", \"second\", () => {\n          expect(++i).to.eql(2);\n\n          socket.disconnect();\n          done();\n        });\n      });\n\n      socket.emit(\"echo\", \"first\", () => {\n        expect(++i).to.eql(1);\n      });\n\n      socket.connect();\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit an event and wait for the acknowledgement","suites":["socket","auth option"],"updatePoint":{"line":333,"column":59},"line":333,"code":"  it(\"should emit an event and wait for the acknowledgement\", () => {\n    return wrap(async (done) => {\n      const socket = io(BASE_URL, { forceNew: true });\n\n      const val = await socket.emitWithAck(\"echo\", 123);\n      expect(val).to.be(123);\n\n      success(done, socket);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should discard a volatile packet when the socket is not connected","suites":["socket","volatile packets"],"updatePoint":{"line":345,"column":73},"line":345,"code":"    it(\"should discard a volatile packet when the socket is not connected\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL, { forceNew: true, autoConnect: false });\n\n        socket.volatile.emit(\"getId\", () => {\n          done(new Error(\"should not happen\"));\n        });\n\n        socket.emit(\"getId\", () => {\n          socket.disconnect();\n          done();\n        });\n\n        socket.connect();\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should discard a volatile packet when the pipe is not ready","suites":["socket","volatile packets"],"updatePoint":{"line":362,"column":67},"line":362,"code":"    it(\"should discard a volatile packet when the pipe is not ready\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL, { forceNew: true });\n\n        socket.on(\"connect\", () => {\n          socket.emit(\"getId\", () => {\n            socket.disconnect();\n            done();\n          });\n\n          socket.volatile.emit(\"getId\", () => {\n            done(new Error(\"should not happen\"));\n          });\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should send a volatile packet when the socket is connected and the pipe is ready","suites":["socket","volatile packets"],"updatePoint":{"line":379,"column":88},"line":379,"code":"    it(\"should send a volatile packet when the socket is connected and the pipe is ready\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL, { forceNew: true });\n\n        const interval = setInterval(() => {\n          socket.volatile.emit(\"getId\", () => {\n            clearInterval(interval);\n            socket.disconnect();\n            done();\n          });\n        }, 200);\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should call listener","suites":["socket","onAny"],"updatePoint":{"line":395,"column":28},"line":395,"code":"    it(\"should call listener\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc\", {\n          forceNew: true,\n        });\n\n        socket.onAny((event, arg1) => {\n          expect(event).to.be(\"handshake\");\n          expect(arg1).to.be.an(Object);\n\n          success(done, socket);\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should prepend listener","suites":["socket","onAny"],"updatePoint":{"line":410,"column":31},"line":410,"code":"    it(\"should prepend listener\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc\", { forceNew: true });\n\n        let count = 0;\n\n        socket.onAny((event, arg1) => {\n          expect(count).to.be(2);\n\n          success(done, socket);\n        });\n\n        socket.prependAny(() => {\n          expect(count++).to.be(1);\n        });\n\n        socket.prependAny(() => {\n          expect(count++).to.be(0);\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should remove listener","suites":["socket","onAny"],"updatePoint":{"line":432,"column":30},"line":432,"code":"    it(\"should remove listener\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc\", {\n          forceNew: true,\n        });\n\n        let count = 0;\n\n        const fail = () => done(new Error(\"fail\"));\n\n        socket.onAny(fail);\n        socket.offAny(fail);\n        expect(socket.listenersAny.length).to.be(0);\n\n        socket.onAny(() => {\n          success(done, socket);\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should call listener","suites":["socket","onAnyOutgoing"],"updatePoint":{"line":454,"column":28},"line":454,"code":"    it(\"should call listener\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc\", {\n          forceNew: true,\n        });\n\n        socket.on(\"connect\", () => {\n          socket.onAnyOutgoing((event, arg1) => {\n            expect(event).to.be(\"my-event\");\n            expect(arg1).to.be(\"123\");\n\n            success(done, socket);\n          });\n\n          socket.emit(\"my-event\", \"123\");\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should call listener with binary data","suites":["socket","onAnyOutgoing"],"updatePoint":{"line":473,"column":45},"line":473,"code":"    it(\"should call listener with binary data\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc\", {\n          forceNew: true,\n        });\n\n        socket.on(\"connect\", () => {\n          socket.onAnyOutgoing((event, arg1) => {\n            expect(event).to.be(\"my-event\");\n            expect(arg1).to.be.an(Uint8Array);\n\n            success(done, socket);\n          });\n\n          socket.emit(\"my-event\", Uint8Array.of(1, 2, 3));\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should prepend listener","suites":["socket","onAnyOutgoing"],"updatePoint":{"line":492,"column":31},"line":492,"code":"    it(\"should prepend listener\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc\", {\n          forceNew: true,\n        });\n\n        let count = 0;\n\n        socket.onAnyOutgoing(() => {\n          expect(count).to.be(2);\n\n          success(done, socket);\n        });\n\n        socket.prependAnyOutgoing(() => {\n          expect(count++).to.be(1);\n        });\n\n        socket.prependAnyOutgoing(() => {\n          expect(count++).to.be(0);\n        });\n\n        socket.emit(\"my-event\", \"123\");\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should remove listener","suites":["socket","onAnyOutgoing"],"updatePoint":{"line":518,"column":30},"line":518,"code":"    it(\"should remove listener\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/abc\", {\n          forceNew: true,\n        });\n        const fail = () => done(new Error(\"fail\"));\n\n        socket.onAnyOutgoing(fail);\n        socket.offAnyOutgoing(fail);\n        expect(socket.listenersAnyOutgoing.length).to.be(0);\n\n        socket.onAnyOutgoing(() => {\n          success(done, socket);\n        });\n\n        socket.emit(\"my-event\", \"123\");\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should timeout after the given delay when socket is not connected","suites":["socket","timeout"],"updatePoint":{"line":539,"column":73},"line":539,"code":"    it(\"should timeout after the given delay when socket is not connected\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/\", {\n          autoConnect: false,\n        });\n\n        socket.timeout(50).emit(\"event\", (err) => {\n          expect(err).to.be.an(Error);\n          expect(socket.sendBuffer).to.be.empty();\n\n          success(done, socket);\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should timeout when the server does not acknowledge the event","suites":["socket","timeout"],"updatePoint":{"line":554,"column":69},"line":554,"code":"    it(\"should timeout when the server does not acknowledge the event\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/\");\n\n        socket.timeout(50).emit(\"unknown\", (err) => {\n          expect(err).to.be.an(Error);\n          success(done, socket);\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should timeout when the server does not acknowledge the event in time","suites":["socket","timeout"],"updatePoint":{"line":565,"column":77},"line":565,"code":"    it(\"should timeout when the server does not acknowledge the event in time\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/\");\n\n        let count = 0;\n\n        socket.timeout(0).emit(\"echo\", 42, (err) => {\n          expect(err).to.be.an(Error);\n          count++;\n        });\n\n        setTimeout(() => {\n          expect(count).to.eql(1);\n          success(done, socket);\n        }, 200);\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not timeout when the server does acknowledge the event","suites":["socket","timeout"],"updatePoint":{"line":583,"column":69},"line":583,"code":"    it(\"should not timeout when the server does acknowledge the event\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/\");\n\n        socket.timeout(50).emit(\"echo\", 42, (err, value) => {\n          expect(err).to.be(null);\n          expect(value).to.be(42);\n          success(done, socket);\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should timeout when the server does not acknowledge the event (promise)","suites":["socket","timeout"],"updatePoint":{"line":595,"column":79},"line":595,"code":"    it(\"should timeout when the server does not acknowledge the event (promise)\", () => {\n      return wrap(async (done) => {\n        const socket = io(BASE_URL + \"/\");\n\n        try {\n          await socket.timeout(50).emitWithAck(\"unknown\");\n          expect.fail();\n        } catch (e) {\n          success(done, socket);\n        }\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not timeout when the server does acknowledge the event (promise)","suites":["socket","timeout"],"updatePoint":{"line":608,"column":79},"line":608,"code":"    it(\"should not timeout when the server does acknowledge the event (promise)\", () => {\n      return wrap(async (done) => {\n        const socket = io(BASE_URL + \"/\");\n\n        try {\n          const value = await socket.timeout(50).emitWithAck(\"echo\", 42);\n          expect(value).to.be(42);\n          success(done, socket);\n        } catch (e) {\n          expect.fail();\n        }\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should use the default value","suites":["socket","timeout"],"updatePoint":{"line":622,"column":36},"line":622,"code":"    it(\"should use the default value\", () => {\n      return wrap((done) => {\n        const socket = io(BASE_URL + \"/\", {\n          ackTimeout: 50,\n        });\n\n        socket.emit(\"unknown\", (err) => {\n          expect(err).to.be.an(Error);\n          success(done, socket);\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"infers correct types for listener parameters of reserved events","suites":["typed events","no event map","on"],"updatePoint":{"line":11,"column":73},"line":11,"code":"      it(\"infers correct types for listener parameters of reserved events\", () => {\n        const socket = io();\n        expectType<Socket<DefaultEventsMap, DefaultEventsMap>>(socket);\n\n        expectError(socket.on(\"connect\", (arg) => {}));\n\n        socket.on(\"connect_error\", (err) => {\n          expectType<Error>(err);\n        });\n\n        socket.on(\"disconnect\", (reason) => {\n          expectType<Socket.DisconnectReason>(reason);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"infers 'any' for listener parameters of other events","suites":["typed events","no event map","on"],"updatePoint":{"line":26,"column":62},"line":26,"code":"      it(\"infers 'any' for listener parameters of other events\", () => {\n        const socket = io();\n\n        socket.on(\"random\", (a, b, c) => {\n          expectType<any>(a);\n          expectType<any>(b);\n          expectType<any>(c);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"infers 'any' for listener parameters of other events using enums","suites":["typed events","no event map","on"],"updatePoint":{"line":36,"column":74},"line":36,"code":"      it(\"infers 'any' for listener parameters of other events using enums\", () => {\n        const socket = io();\n\n        enum Events {\n          TEST = \"test\",\n        }\n\n        socket.on(\"test\", (a, b, c) => {\n          expectType<any>(a);\n          expectType<any>(b);\n          expectType<any>(c);\n        });\n\n        socket.on(Events.TEST, (a, b, c) => {\n          expectType<any>(a);\n          expectType<any>(b);\n          expectType<any>(c);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts any parameters","suites":["typed events","no event map","emit"],"updatePoint":{"line":58,"column":32},"line":58,"code":"      it(\"accepts any parameters\", async () => {\n        const socket = io();\n\n        socket.emit(\"random\", 1, \"2\", [3]);\n        socket.emit(\"no parameters\");\n\n        socket.emit(\"ackFromClient\", \"1\", 2, (c, d) => {\n          expectType<any>(c);\n          expectType<any>(d);\n        });\n\n        socket.timeout(1000).emit(\"ackFromClient\", \"1\", 2, (err, c, d) => {\n          expectType<any>(err);\n          expectType<any>(c);\n          expectType<any>(d);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts any parameters","suites":["typed events","no event map","emitWithAck"],"updatePoint":{"line":78,"column":32},"line":78,"code":"      it(\"accepts any parameters\", async () => {\n        const socket = io();\n\n        const value = await socket.emitWithAck(\n          \"ackFromClientSingleArg\",\n          \"1\",\n          2\n        );\n        expectType<any>(value);\n\n        const value2 = await socket\n          .timeout(1000)\n          .emitWithAck(\"ackFromClientSingleArg\", \"3\", 4);\n        expectType<any>(value2);\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"infers correct types for listener parameters","suites":["typed events","single event map","on"],"updatePoint":{"line":102,"column":54},"line":102,"code":"      it(\"infers correct types for listener parameters\", () => {\n        const socket: Socket<BidirectionalEvents> = io();\n\n        expectType<Socket<BidirectionalEvents, BidirectionalEvents>>(socket);\n\n        socket.on(\"random\", (a, b, c) => {\n          expectType<number>(a);\n          expectType<string>(b);\n          expectType<number[]>(c);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept arguments of wrong types","suites":["typed events","single event map","on"],"updatePoint":{"line":114,"column":50},"line":114,"code":"      it(\"does not accept arguments of wrong types\", () => {\n        const socket: Socket<BidirectionalEvents> = io();\n\n        expectType<Socket<BidirectionalEvents, BidirectionalEvents>>(socket);\n\n        expectError(socket.on(\"random\"));\n        expectError(socket.on(\"random\", (a, b, c, d) => {}));\n        expectError(socket.on(2, 3));\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts arguments of the correct types","suites":["typed events","single event map","emit"],"updatePoint":{"line":126,"column":48},"line":126,"code":"      it(\"accepts arguments of the correct types\", () => {\n        const socket: Socket<BidirectionalEvents> = io();\n\n        socket.emit(\"random\", 1, \"2\", [3]);\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept arguments of the wrong types","suites":["typed events","single event map","emit"],"updatePoint":{"line":132,"column":54},"line":132,"code":"      it(\"does not accept arguments of the wrong types\", () => {\n        const socket: Socket<BidirectionalEvents> = io();\n\n        expectError(socket.emit(\"random\"));\n        expectError(socket.emit(\"random\", (a, b, c) => {}));\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"infers correct types for listener parameters","suites":["typed events","listen and emit event maps","on"],"updatePoint":{"line":162,"column":54},"line":162,"code":"      it(\"infers correct types for listener parameters\", () => {\n        const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();\n\n        expectType<Socket<ServerToClientEvents, ClientToServerEvents>>(socket);\n\n        socket.on(\"helloFromServer\", (message) => {\n          expectType<string>(message);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept emit events","suites":["typed events","listen and emit event maps","on"],"updatePoint":{"line":172,"column":37},"line":172,"code":"      it(\"does not accept emit events\", () => {\n        const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();\n\n        expectType<Socket<ServerToClientEvents, ClientToServerEvents>>(socket);\n\n        expectError(socket.on(\"helloFromClient\", (message) => {}));\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts arguments of the correct types","suites":["typed events","listen and emit event maps","emit"],"updatePoint":{"line":182,"column":48},"line":182,"code":"      it(\"accepts arguments of the correct types\", () => {\n        const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();\n\n        socket.emit(\"helloFromClient\", \"hi\");\n\n        socket.emit(\"ackFromClient\", \"1\", 2, (c, d) => {\n          expectType<string>(c);\n          expectType<boolean>(d);\n        });\n\n        socket.timeout(1000).emit(\"ackFromClient\", \"1\", 2, (err, c, d) => {\n          expectType<Error>(err);\n          expectType<string>(c);\n          expectType<boolean>(d);\n        });\n\n        socket.emit(\"ackFromClientNoArg\", () => {});\n\n        socket.timeout(1000).emit(\"ackFromClientNoArg\", (err) => {\n          expectType<Error>(err);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept arguments of wrong types","suites":["typed events","listen and emit event maps","emit"],"updatePoint":{"line":205,"column":50},"line":205,"code":"      it(\"does not accept arguments of wrong types\", () => {\n        const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();\n\n        expectError(socket.emit(\"helloFromClient\"));\n        expectError(socket.emit(\"helloFromClient\", 10));\n        expectError(socket.emit(\"helloFromClient\", \"hi\", 10));\n        expectError(socket.emit(\"helloFromServer\", \"hi\", 10));\n        expectError(socket.emit(\"wrong name\", 10));\n        expectError(socket.emit(\"wrong name\"));\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts arguments of the correct types","suites":["typed events","listen and emit event maps","emitWithAck"],"updatePoint":{"line":218,"column":48},"line":218,"code":"      it(\"accepts arguments of the correct types\", async () => {\n        const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();\n\n        const value = await socket.emitWithAck(\n          \"ackFromClientSingleArg\",\n          \"1\",\n          2\n        );\n        expectType<string>(value);\n\n        const value2 = await socket\n          .timeout(1000)\n          .emitWithAck(\"ackFromClientSingleArg\", \"3\", 4);\n        expectType<string>(value2);\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"works with undefined","suites":["url"],"updatePoint":{"line":7,"column":26},"line":7,"code":"  it(\"works with undefined\", () => {\n    loc.hostname = \"woot.com\";\n    loc.protocol = \"https:\";\n    loc.port = 4005;\n    loc.host = loc.hostname + \":\" + loc.port;\n    const parsed = url(undefined, undefined, loc);\n    expect(parsed.host).to.be(\"woot.com\");\n    expect(parsed.protocol).to.be(\"https\");\n    expect(parsed.port).to.be(\"4005\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with relative paths","suites":["url"],"updatePoint":{"line":18,"column":31},"line":18,"code":"  it(\"works with relative paths\", () => {\n    loc.hostname = \"woot.com\";\n    loc.protocol = \"https:\";\n    loc.port = 3000;\n    loc.host = loc.hostname + \":\" + loc.port;\n    const parsed = url(\"/test\", undefined, loc);\n    expect(parsed.host).to.be(\"woot.com\");\n    expect(parsed.protocol).to.be(\"https\");\n    expect(parsed.port).to.be(\"3000\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with no protocol","suites":["url"],"updatePoint":{"line":29,"column":28},"line":29,"code":"  it(\"works with no protocol\", () => {\n    loc.protocol = \"http:\";\n    const parsed = url(\"localhost:3000\", undefined, loc);\n    expect(parsed.host).to.be(\"localhost\");\n    expect(parsed.port).to.be(\"3000\");\n    expect(parsed.protocol).to.be(\"http\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with no schema","suites":["url"],"updatePoint":{"line":37,"column":26},"line":37,"code":"  it(\"works with no schema\", () => {\n    loc.protocol = \"http:\";\n    const parsed = url(\"//localhost:3000\", undefined, loc);\n    expect(parsed.host).to.be(\"localhost\");\n    expect(parsed.port).to.be(\"3000\");\n    expect(parsed.protocol).to.be(\"http\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"forces ports for unique url ids","suites":["url"],"updatePoint":{"line":45,"column":37},"line":45,"code":"  it(\"forces ports for unique url ids\", () => {\n    const id1 = url(\"http://google.com:80/\");\n    const id2 = url(\"http://google.com/\");\n    const id3 = url(\"https://google.com/\");\n    const id4 = url(\"http://google.com/\", \"/test\");\n    expect(id1.id).to.be(id2.id);\n    expect(id1.id).to.not.be(id3.id);\n    expect(id2.id).to.not.be(id3.id);\n    expect(id2.id).to.not.be(id4.id);\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"identifies the namespace","suites":["url"],"updatePoint":{"line":56,"column":30},"line":56,"code":"  it(\"identifies the namespace\", () => {\n    loc.protocol = \"http:\";\n    loc.hostname = \"woot.com\";\n\n    expect(url(\"/woot\", undefined, loc).path).to.be(\"/woot\");\n    expect(url(\"http://google.com\").path).to.be(\"/\");\n    expect(url(\"http://google.com/\").path).to.be(\"/\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with ipv6","suites":["url"],"updatePoint":{"line":65,"column":21},"line":65,"code":"  it(\"works with ipv6\", () => {\n    const parsed = url(\"http://[::1]\");\n    expect(parsed.protocol).to.be(\"http\");\n    expect(parsed.host).to.be(\"::1\");\n    expect(parsed.port).to.be(\"80\");\n    expect(parsed.id).to.be(\"http://[::1]:80\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with ipv6 location","suites":["url"],"updatePoint":{"line":73,"column":30},"line":73,"code":"  it(\"works with ipv6 location\", () => {\n    loc.protocol = \"http:\";\n    loc.hostname = \"[::1]\";\n    loc.port = \"\";\n    loc.host = loc.hostname + \":\" + loc.port;\n\n    const parsed = url(undefined, undefined, loc);\n    expect(parsed.protocol).to.be(\"http\");\n    expect(parsed.host).to.be(\"::1\");\n    expect(parsed.port).to.be(\"80\");\n    expect(parsed.id).to.be(\"http://[::1]:80\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with a custom path","suites":["url"],"updatePoint":{"line":86,"column":30},"line":86,"code":"  it(\"works with a custom path\", function () {\n    const parsed = url(\"https://woot.com/some-namespace\", \"/some-path\");\n    expect(parsed.id).to.be(\"https://woot.com:443/some-path\");\n    expect(parsed.path).to.be(\"/some-namespace\");\n  });","file":"url.ts","skipped":false,"dir":"test"}]}