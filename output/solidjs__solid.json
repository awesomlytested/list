{"repo":"solidjs/solid","url":"https://github.com/solidjs/solid","branch":"main","configs":[{"package":"solid-js","lang":"ts","dir":"packages/solid/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"solid-js/store","lang":"ts","dir":"packages/solid/store/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"solid-js/web","lang":"js","dir":"packages/solid/web/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"test-integration","lang":"ts","dir":"packages/test-integration/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"simple mapArray","suites":["Map operator"],"updatePoint":{"line":4,"column":23},"line":4,"code":"  test(\"simple mapArray\", () => {\n    createRoot(() => {\n      const [s, set] = createSignal([1, 2, 3, 4]),\n        r = createMemo(mapArray(s, v => v * 2));\n      expect(r()).toEqual([2, 4, 6, 8]);\n      set([3, 4, 5]);\n      expect(r()).toEqual([6, 8, 10]);\n    });\n  });","file":"array.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"show fallback","suites":["Map operator"],"updatePoint":{"line":14,"column":21},"line":14,"code":"  test(\"show fallback\", () => {\n    createRoot(() => {\n      const [s, set] = createSignal([1, 2, 3, 4]),\n        double = mapArray<number, number | string>(s, v => v * 2, {\n          fallback: () => \"Empty\"\n        }),\n        r = createMemo(double);\n      expect(r()).toEqual([2, 4, 6, 8]);\n      set([]);\n      expect(r()).toEqual([\"Empty\"]);\n      set([3, 4, 5]);\n      expect(r()).toEqual([6, 8, 10]);\n    });\n  });","file":"array.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple indexArray","suites":["Index operator"],"updatePoint":{"line":31,"column":25},"line":31,"code":"  test(\"simple indexArray\", () => {\n    createRoot(() => {\n      const [s, set] = createSignal([1, 2, 3, 4]),\n        r = createMemo(indexArray(s, v => v() * 2));\n      expect(r()).toEqual([2, 4, 6, 8]);\n    });\n  });","file":"array.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"show fallback","suites":["Index operator"],"updatePoint":{"line":40,"column":21},"line":40,"code":"  test(\"show fallback\", () => {\n    createRoot(() => {\n      const [s, set] = createSignal([1, 2, 3, 4]),\n        double = indexArray<number, number | string>(s, v => v() * 2, {\n          fallback: () => \"Empty\"\n        }),\n        r = createMemo(double);\n      expect(r()).toEqual([2, 4, 6, 8]);\n      set([]);\n      expect(r()).toEqual([\"Empty\"]);\n      set([3, 4, 5]);\n      expect(r()).toEqual([6, 8, 10]);\n    });\n  });","file":"array.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"create simple component","suites":["CreateComponent"],"updatePoint":{"line":29,"column":31},"line":29,"code":"  test(\"create simple component\", () => {\n    createRoot(() => {\n      const out = createComponent(Comp, {\n        greeting: \"Hi\",\n        get name() {\n          return \"dynamic\";\n        }\n      });\n      expect(out).toBe(\"Hi dynamic\");\n    });\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"null/undefined props are replaced with empty props","suites":["CreateComponent"],"updatePoint":{"line":40,"column":58},"line":40,"code":"  test(\"null/undefined props are replaced with empty props\", () => {\n    createRoot(() => {\n      const nonObjects = [null, undefined, false];\n      nonObjects.forEach(nonObject => {\n        const out = createComponent(p => p, nonObject);\n        expect(out).toEqual({});\n      });\n    });\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple set","suites":["Set Default Props"],"updatePoint":{"line":52,"column":18},"line":52,"code":"  test(\"simple set\", () => {\n    let props: SimplePropTypes = {\n        get a() {\n          return \"ji\";\n        },\n        b: null,\n        c: \"j\"\n      },\n      defaults: SimplePropTypes = { a: \"yy\", b: \"ggg\", d: \"DD\" };\n    props = mergeProps(defaults, props);\n    expect(props.a).toBe(\"ji\");\n    expect(props.b).toBe(null);\n    expect(props.c).toBe(\"j\");\n    expect(props.d).toBe(\"DD\");\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple set","suites":["Clone Props"],"updatePoint":{"line":70,"column":18},"line":70,"code":"  test(\"simple set\", () => {\n    let reactive = false;\n    const props: SimplePropTypes = {\n      get a() {\n        reactive = true;\n        return \"ji\";\n      },\n      b: null,\n      c: \"j\"\n    };\n    const newProps = mergeProps({}, props);\n    expect(reactive).toBe(false);\n    expect(newProps.a).toBe(\"ji\");\n    expect(reactive).toBe(true);\n    expect(newProps.b).toBe(null);\n    expect(newProps.c).toBe(\"j\");\n    expect(newProps.d).toBe(undefined);\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple set","suites":["Merge Signal"],"updatePoint":{"line":102,"column":18},"line":102,"code":"  test(\"simple set\", () => {\n    const [s, set] = createSignal<SimplePropTypes>({\n        get a() {\n          return \"ji\";\n        },\n        b: null,\n        c: \"j\"\n      }),\n      defaults: SimplePropTypes = { a: \"yy\", b: \"ggg\", d: \"DD\" };\n    const props = mergeProps(defaults, s);\n    const res: string[] = [];\n    createRoot(() => {\n      createEffect(() => {\n        res.push(props.a as string);\n      });\n    });\n    expect(props.a).toBe(\"ji\");\n    expect(props.b).toBe(null);\n    expect(props.c).toBe(\"j\");\n    expect(props.d).toBe(\"DD\");\n    set({ a: \"h\" });\n    expect(props.a).toBe(\"h\");\n    expect(props.b).toBe(\"ggg\");\n    expect(props.c).toBeUndefined();\n    expect(props.d).toBe(\"DD\");\n    expect(res[0]).toBe(\"ji\");\n    expect(res[1]).toBe(\"h\");\n    expect(res.length).toBe(2);\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"null/undefined/false are ignored","suites":["Merge Signal"],"updatePoint":{"line":132,"column":40},"line":132,"code":"  test(\"null/undefined/false are ignored\", () => {\n    const props = mergeProps({ a: 1 }, null, undefined, false);\n    expect(props).toEqual({ a: 1 });\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"SplitProps in two","suites":["SplitProps Props"],"updatePoint":{"line":139,"column":25},"line":139,"code":"  test(\"SplitProps in two\", () => {\n    createRoot(() => {\n      const out = createComponent(Comp2, {\n        greeting: \"Hi\",\n        get name() {\n          return \"dynamic\";\n        }\n      });\n      expect(out).toBe(\"Hi dynamic\");\n    });\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"SplitProps in two with store","suites":["SplitProps Props"],"updatePoint":{"line":150,"column":36},"line":150,"code":"  test(\"SplitProps in two with store\", () => {\n    createRoot(() => {\n      const [state] = createStore({ greeting: \"Yo\", name: \"Bob\" });\n      const out = createComponent(Comp2, state);\n      expect(out).toBe(\"Yo Bob\");\n    });\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Merge SplitProps","suites":["SplitProps Props"],"updatePoint":{"line":157,"column":24},"line":157,"code":"  test(\"Merge SplitProps\", () => {\n    let value: string | undefined = undefined;\n    const [splittedProps] = splitProps({ color: \"blue\" } as { color: string; other?: string }, [\n      \"color\",\n      \"other\"\n    ]);\n    const mergedProps = mergeProps(splittedProps, {\n      get color() {\n        return value;\n      },\n      other: \"value\"\n    });\n    expect(mergedProps.color).toBe(\"blue\");\n    value = \"red\";\n    expect(mergedProps.color).toBe(\"red\");\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"creating some","suites":["createUniqueId"],"updatePoint":{"line":176,"column":21},"line":176,"code":"  test(\"creating some\", () => {\n    const id1 = createUniqueId();\n    const id2 = createUniqueId();\n\n    expect(id1).toBeDefined();\n    expect(id2).toBeDefined();\n    expect(id1).not.toEqual(id2);\n  });","file":"component.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Reactive graph serialization","suites":["Dev features"],"updatePoint":{"line":15,"column":36},"line":15,"code":"  test(\"Reactive graph serialization\", () => {\n    let owner: ReturnType<typeof getOwner>, set1: (v: number) => number, setState1: any;\n\n    const SNAPSHOTS = [\n      `{\"s1773325850\":5,\"s1773325850-1\":5,\"c-1\":{\"explicit\":6},\"CustomComponent:c-2\":{\"s533736025\":{\"firstName\":\"John\",\"lastName\":\"Smith\"}}}`,\n      `{\"s1773325850\":7,\"s1773325850-1\":5,\"c-1\":{\"explicit\":6},\"CustomComponent:c-2\":{\"s533736025\":{\"firstName\":\"Matt\",\"lastName\":\"Smith\",\"middleInitial\":\"R.\"}}}`\n    ];\n    const CustomComponent = () => {\n      const [state, setState] = createStore({ firstName: \"John\", lastName: \"Smith\" });\n      setState1 = setState;\n      return \"\";\n    };\n    createRoot(() => {\n      owner = getOwner();\n      const [s, set] = createSignal(5);\n      const [s2] = createSignal(5);\n      createEffect(() => {\n        const [s] = createSignal(6, { name: \"explicit\" });\n      });\n      createComponent(CustomComponent, {});\n      set1 = set;\n    });\n    expect(JSON.stringify(DEV.serializeGraph(owner!))).toBe(SNAPSHOTS[0]);\n    set1!(7);\n    setState1({ middleInitial: \"R.\", firstName: \"Matt\" });\n    expect(JSON.stringify(DEV.serializeGraph(owner!))).toBe(SNAPSHOTS[1]);\n  });","file":"dev.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Context nodes can be named","suites":["Dev features"],"updatePoint":{"line":43,"column":34},"line":43,"code":"  test(\"Context nodes can be named\", () => {\n    createRoot(dispose => {\n      const ctx = createContext(undefined, { name: \"test\" });\n      ctx.Provider({ value: undefined, children: undefined });\n      const ctxNode = getOwner()!.owned![0];\n      expect(ctxNode.name).toBe(\"test\");\n      dispose();\n    });\n  });","file":"dev.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"AfterUpdate Hook","suites":["Dev features"],"updatePoint":{"line":53,"column":24},"line":53,"code":"  test(\"AfterUpdate Hook\", () => {\n    let triggered = 0;\n    let set1: (v: number) => number, setState1: any;\n    global._$afterUpdate = () => triggered++;\n    createRoot(() => {\n      const [s, set] = createSignal(5);\n      const [s2] = createSignal(5);\n      createEffect(() => {\n        const [s] = createSignal(6, { name: \"explicit\" });\n      });\n      const [state, setState] = createStore({ firstName: \"John\", lastName: \"Smith\" });\n      createEffect(() => {\n        s();\n        s2();\n        state.firstName;\n      });\n      set1 = set;\n      setState1 = setState;\n    });\n    expect(triggered).toBe(1);\n    set1!(7);\n    expect(triggered).toBe(2);\n    setState1({ middleInitial: \"R.\", firstName: \"Matt\" });\n    expect(triggered).toBe(3);\n  });","file":"dev.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"AfterUpdate Hook with effect write","suites":["Dev features"],"updatePoint":{"line":79,"column":42},"line":79,"code":"  test(\"AfterUpdate Hook with effect write\", () => {\n    let triggered = 0;\n    let set1: (v: number) => number;\n    let log = \"\";\n    global._$afterUpdate = () => triggered++;\n    createRoot(() => {\n      const [s, set] = createSignal(5);\n      const [s2, set2] = createSignal(0);\n      const [s3, set3] = createSignal(0);\n      createComputed(() => {\n        log += \"a\";\n        set3(s2());\n      });\n      createEffect(() => {\n        log += \"b\";\n        set2(s());\n      });\n      createEffect(() => {\n        log += \"c\";\n        s3();\n      });\n      set1 = set;\n    });\n    expect(triggered).toBe(1);\n    expect(log).toBe(\"abcac\");\n    log = \"\";\n    set1!(7);\n    expect(triggered).toBe(2);\n    expect(log).toBe(\"bac\");\n  });","file":"dev.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"AfterCreateRoot Hook","suites":["Dev features"],"updatePoint":{"line":110,"column":28},"line":110,"code":"  test(\"AfterCreateRoot Hook\", () => {\n    const captured: Owner[] = [];\n    global._$afterCreateRoot = root => captured.push(root);\n    createRoot(() => {\n      const root = getOwner()!;\n      expect(captured.length).toBe(1);\n      expect(captured[0]).toBe(root);\n      createRoot(_ => {\n        const inner = getOwner()!;\n        expect(captured.length).toBe(2);\n        expect(captured[1]).toBe(inner);\n        expect(inner.owner).toBe(root);\n      });\n    });\n  });","file":"dev.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"should trigger solid primitive update","suites":["external source"],"updatePoint":{"line":62,"column":43},"line":62,"code":"  it(\"should trigger solid primitive update\", () => {\n    createRoot(fn => {\n      const e = new ExternalSource(0);\n      const memo = createMemo(() => {\n        return e.get();\n      });\n      expect(memo()).toBe(0);\n      e.update(1);\n      expect(memo()).toBe(1);\n      fn();\n    });\n  });","file":"external-source.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"to observable","suites":["Observable operator"],"updatePoint":{"line":4,"column":21},"line":4,"code":"  test(\"to observable\", () => {\n    let out: string;\n    let set: (v: string) => void;\n    createRoot(() => {\n      const [s, _set] = createSignal(\"Hi\"),\n        obsv$ = observable(s);\n\n      set = _set;\n      obsv$.subscribe({ next: v => (out = v) });\n    });\n    expect(out!).toBe(\"Hi\");\n    set!(\"John\");\n    expect(out!).toBe(\"John\");\n  });","file":"observable.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"preserve the observer's next binding","suites":["Observable operator"],"updatePoint":{"line":19,"column":44},"line":19,"code":"  test(\"preserve the observer's next binding\", () => {\n    const observer = {\n      next: jest.fn().mockReturnThis()\n    };\n\n    createRoot(() => {\n      const [s] = createSignal(\"Hi\"),\n        obsv$ = observable(s);\n\n      obsv$.subscribe(observer);\n    });\n    expect(observer.next).toHaveReturnedWith(observer);\n  });","file":"observable.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"observable throws TypeError on non-object","suites":["Observable operator"],"updatePoint":{"line":33,"column":49},"line":33,"code":"  test(\"observable throws TypeError on non-object\", () => {\n    const [s, _set] = createSignal(\"Hi\");\n    const o = observable(s);\n    expect(() => o.subscribe(null as any)).toThrow(TypeError);\n  });","file":"observable.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"observable unsubscribe","suites":["Observable operator"],"updatePoint":{"line":39,"column":30},"line":39,"code":"  test(\"observable unsubscribe\", () => {\n    const [s, set] = createSignal(\"Hi\");\n    const o = observable(s);\n    let out: string;\n    let subscription: any;\n    createRoot(() => {\n      subscription = o.subscribe({\n        next(v) {\n          out = v;\n        }\n      });\n    });\n    set(\"John\");\n    expect(out!).toBe(\"John\");\n    subscription.unsubscribe();\n    set(\"Benjamin\");\n    expect(out!).toBe(\"John\");\n  });","file":"observable.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"from subscribable","suites":["from transform"],"updatePoint":{"line":60,"column":25},"line":60,"code":"  test(\"from subscribable\", async () => {\n    let out: () => string | undefined;\n    let set: (v: string) => void;\n    createRoot(() => {\n      const [s, _set] = createSignal(\"Hi\"),\n        obsv$ = observable(s);\n\n      set = _set;\n      out = from(obsv$);\n    });\n    expect(out!()).toBe(\"Hi\");\n    set!(\"John\");\n    expect(out!()).toBe(\"John\");\n  });","file":"observable.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"from producer","suites":["from transform"],"updatePoint":{"line":75,"column":21},"line":75,"code":"  test(\"from producer\", async () => {\n    let out: () => string | undefined;\n    let set: (v: string) => void;\n    createRoot(() => {\n      const [s, _set] = createSignal(\"Hi\"),\n        obsv$ = observable(s);\n\n      set = _set;\n      out = from(set => {\n        const sub = obsv$.subscribe(set);\n        return () => sub.unsubscribe();\n      });\n    });\n    expect(out!()).toBe(\"Hi\");\n    set!(\"John\");\n    expect(out!()).toBe(\"John\");\n  });","file":"observable.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"initial async resource","suites":["Simulate a dynamic fetch"],"updatePoint":{"line":30,"column":30},"line":30,"code":"  test(\"initial async resource\", async () => {\n    createRoot(() => {\n      const [id, setId] = createSignal(\"1\");\n      trigger = setId;\n      onError(e => (error = e));\n      [value] = createResource(id, fetcher);\n      createRenderEffect(value);\n    });\n    expect(value()).toBeUndefined();\n    expect(value.latest).toBeUndefined();\n    expect(value.loading).toBe(true);\n    resolve(\"John\");\n    await Promise.resolve();\n    expect(value()).toBe(\"John\");\n    expect(value.latest).toBe(\"John\");\n    expect(value.loading).toBe(false);\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"test out of order","suites":["Simulate a dynamic fetch"],"updatePoint":{"line":48,"column":25},"line":48,"code":"  test(\"test out of order\", async () => {\n    trigger(\"2\");\n    expect(value.loading).toBe(true);\n    const resolve1 = resolve;\n    trigger(\"3\");\n    const resolve2 = resolve;\n    resolve2(\"Jake\");\n    resolve1(\"Jo\");\n    await Promise.resolve();\n    expect(value()).toBe(\"Jake\");\n    expect(value.loading).toBe(false);\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"promise rejection","suites":["Simulate a dynamic fetch"],"updatePoint":{"line":61,"column":25},"line":61,"code":"  test(\"promise rejection\", async () => {\n    trigger(\"4\");\n    expect(value.loading).toBe(true);\n    expect(value.error).toBeUndefined();\n    reject(\"Because I said so\");\n    await Promise.resolve();\n    expect(error).toBe(\"Because I said so\");\n    expect(value.error).toBe(\"Because I said so\");\n    expect(value.loading).toBe(false);\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"initial async resource","suites":["Simulate a dynamic fetch with state and reconcile"],"updatePoint":{"line":95,"column":30},"line":95,"code":"  test(\"initial async resource\", async () => {\n    createRoot(async () => {\n      [user, { refetch }] = createResource(fetcher);\n      [state] = createStore<{ user?: User; userLoading: boolean }>({\n        get user() {\n          return user();\n        },\n        get userLoading() {\n          return user.loading;\n        }\n      });\n      createRenderEffect(() => (state.user, count++));\n    });\n    expect(state.user).toBeUndefined();\n    expect(state.userLoading).toBe(true);\n    resolve(data[0]);\n    await Promise.resolve();\n    await Promise.resolve();\n    expect(unwrap(state.user)).toStrictEqual(data[0]);\n    expect(state.userLoading).toBe(false);\n    expect(count).toBe(2);\n\n    refetch();\n    expect(state.userLoading).toBe(true);\n    resolve(data[1]);\n    await Promise.resolve();\n    await Promise.resolve();\n    expect(unwrap(state.user)).toStrictEqual(data[0]);\n    expect(state.user?.firstName).toBe(\"Joseph\");\n    expect(unwrap(state.user?.address)).toStrictEqual(data[0].address);\n    expect(state.userLoading).toBe(false);\n    expect(count).toBe(2);\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"loads default value","suites":["using Resource with no root"],"updatePoint":{"line":131,"column":27},"line":131,"code":"  test(\"loads default value\", () => {\n    expect(() => {\n      let resolve: (v: string) => void;\n      createResource(\"error\", () => new Promise(r => (resolve = r)));\n      resolve!(\"Hi\");\n    }).not.toThrow();\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"loads default value","suites":["using Resource with initial Value"],"updatePoint":{"line":152,"column":27},"line":152,"code":"  test(\"loads default value\", async () => {\n    createRoot(() => {\n      const [id, setId] = createSignal(\"1\");\n      trigger = setId;\n      onError(e => (error = e));\n      [value] = createResource(id, fetcher, { initialValue: \"Loading\" });\n      createRenderEffect(value);\n    });\n    expect(value()).toBe(\"Loading\");\n    expect(value.loading).toBe(true);\n    resolve(\"John\");\n    await Promise.resolve();\n    expect(value()).toBe(\"John\");\n    expect(value.loading).toBe(false);\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"works with falsy errors","suites":["using Resource with errors"],"updatePoint":{"line":181,"column":31},"line":181,"code":"  test(\"works with falsy errors\", async () => {\n    createRoot(() => {\n      const [id, setId] = createSignal(\"1\");\n      trigger = setId;\n      onError(e => (error = e));\n      [value] = createResource(id, fetcher);\n      createRenderEffect(value);\n    });\n    expect(value()).toBeUndefined();\n    expect(value.state === \"pending\").toBe(true);\n    expect(value.error).toBeUndefined();\n    reject(null);\n    await Promise.resolve();\n    expect(value.state === \"errored\").toBe(true);\n    expect(value.error.message).toBe(\"Unknown error\");\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"loads and diffs","suites":["using Resource with custom store"],"updatePoint":{"line":232,"column":23},"line":232,"code":"  test(\"loads and diffs\", async () => {\n    let first = 0;\n    let last = 0;\n    let addr = 0;\n    let street = 0;\n    createRoot(() => {\n      [value] = createResource(fetcher, {\n        initialValue: {\n          firstName: \"John\",\n          lastName: \"Smith\",\n          address: {\n            streetNumber: 4,\n            streetName: \"Grindel Rd\",\n            city: \"New York\",\n            state: \"NY\",\n            zip: 10001\n          }\n        },\n        storage: createDeepSignal\n      });\n      createRenderEffect(() => (first++, value()?.firstName));\n      createRenderEffect(() => (last++, value()?.lastName));\n      const address = createMemo(() => (addr++, value()?.address));\n      createRenderEffect(() => (street++, address()?.streetName));\n    });\n    expect(value()).toEqual({\n      firstName: \"John\",\n      lastName: \"Smith\",\n      address: {\n        streetNumber: 4,\n        streetName: \"Grindel Rd\",\n        city: \"New York\",\n        state: \"NY\",\n        zip: 10001\n      }\n    });\n    expect(value.loading).toBe(true);\n    expect(first).toBe(1);\n    expect(last).toBe(1);\n    expect(addr).toBe(1);\n    expect(street).toBe(1);\n    resolve({\n      firstName: \"Matt\",\n      lastName: \"Smith\",\n      address: {\n        streetNumber: 4,\n        streetName: \"Central Rd\",\n        city: \"New York\",\n        state: \"NY\",\n        zip: 10001\n      }\n    });\n    await Promise.resolve();\n    expect(value()).toEqual({\n      firstName: \"Matt\",\n      lastName: \"Smith\",\n      address: {\n        streetNumber: 4,\n        streetName: \"Central Rd\",\n        city: \"New York\",\n        state: \"NY\",\n        zip: 10001\n      }\n    });\n    expect(value.loading).toBe(false);\n    expect(first).toBe(2);\n    expect(last).toBe(1);\n    expect(addr).toBe(1);\n    expect(street).toBe(2);\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"mutates","suites":["using Resource with custom store"],"updatePoint":{"line":303,"column":15},"line":303,"code":"  test(\"mutates\", async () => {\n    let first = 0;\n    let last = 0;\n    let addr = 0;\n    let street = 0;\n    let mutate: <T>(v: T) => T;\n    createRoot(() => {\n      [value, { mutate }] = createResource(false, fetcher, {\n        initialValue: {\n          firstName: \"John\",\n          lastName: \"Smith\",\n          address: {\n            streetNumber: 4,\n            streetName: \"Grindel Rd\",\n            city: \"New York\",\n            state: \"NY\",\n            zip: 10001\n          }\n        },\n        storage: createDeepSignal\n      });\n      createRenderEffect(() => (first++, value()?.firstName));\n      createRenderEffect(() => (last++, value()?.lastName));\n      const address = createMemo(() => (addr++, value()?.address));\n      createRenderEffect(() => (street++, address()?.streetName));\n    });\n    expect(value()).toEqual({\n      firstName: \"John\",\n      lastName: \"Smith\",\n      address: {\n        streetNumber: 4,\n        streetName: \"Grindel Rd\",\n        city: \"New York\",\n        state: \"NY\",\n        zip: 10001\n      }\n    });\n    expect(value.loading).toBe(false);\n    expect(first).toBe(1);\n    expect(last).toBe(1);\n    expect(addr).toBe(1);\n    expect(street).toBe(1);\n    mutate!({\n      firstName: \"Matt\",\n      lastName: \"Smith\",\n      address: {\n        streetNumber: 4,\n        streetName: \"Central Rd\",\n        city: \"New York\",\n        state: \"NY\",\n        zip: 10001\n      }\n    });\n    await Promise.resolve();\n    expect(value()).toEqual({\n      firstName: \"Matt\",\n      lastName: \"Smith\",\n      address: {\n        streetNumber: 4,\n        streetName: \"Central Rd\",\n        city: \"New York\",\n        state: \"NY\",\n        zip: 10001\n      }\n    });\n    expect(value.loading).toBe(false);\n    expect(first).toBe(2);\n    expect(last).toBe(1);\n    expect(addr).toBe(1);\n    expect(street).toBe(2);\n  });","file":"resource.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"queue a task","suites":["requestCallback basics"],"updatePoint":{"line":6,"column":20},"line":6,"code":"  test(\"queue a task\", done => {\n    requestCallback(() => {\n      done();\n    });\n  });","file":"scheduler.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"queue a task in correct order","suites":["requestCallback basics"],"updatePoint":{"line":12,"column":37},"line":12,"code":"  test(\"queue a task in correct order\", done => {\n    let count = 0;\n    requestCallback(() => {\n      expect(count).toBe(2);\n      done();\n    });\n    requestCallback(\n      () => {\n        count++;\n        expect(count).toBe(1);\n      },\n      { timeout: 10 }\n    );\n    requestCallback(\n      () => {\n        count++;\n        expect(count).toBe(2);\n      },\n      { timeout: 40 }\n    );\n  });","file":"scheduler.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"supports cancelling a callback","suites":["requestCallback basics"],"updatePoint":{"line":34,"column":38},"line":34,"code":"  test(\"supports cancelling a callback\", done => {\n    const task = requestCallback(() => { done(new Error('should not be called')) });\n    cancelCallback(task);\n    requestCallback(done);\n  });","file":"scheduler.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"propagates in topological order","suites":["createMemo","executing propagating"],"updatePoint":{"line":5,"column":39},"line":5,"code":"    it(\"propagates in topological order\", () => {\n      createRoot(() => {\n        //\n        //     c1\n        //    /  \\\n        //   /    \\\n        //  b1     b2\n        //   \\    /\n        //    \\  /\n        //     a1\n        //\n        var seq = \"\",\n          [a1, setA1] = createSignal(false),\n          b1 = createMemo(() => {\n            a1();\n            seq += \"b1\";\n          }, undefined, { equals: false }),\n          b2 = createMemo(() => {\n            a1();\n            seq += \"b2\";\n          }, undefined, { equals: false }),\n          c1 = createMemo(() => {\n            b1(), b2();\n            seq += \"c1\";\n          }, undefined, { equals: false });\n\n        seq = \"\";\n        setA1(true);\n\n        expect(seq).toBe(\"b1b2c1\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"only propagates once with linear convergences","suites":["createMemo","executing propagating"],"updatePoint":{"line":38,"column":53},"line":38,"code":"    it(\"only propagates once with linear convergences\", () => {\n      createRoot(() => {\n        //         d\n        //         |\n        // +---+---+---+---+\n        // v   v   v   v   v\n        // f1  f2  f3  f4  f5\n        // |   |   |   |   |\n        // +---+---+---+---+\n        //         v\n        //         g\n        var [d, setD] = createSignal(0),\n          f1 = createMemo(() => d()),\n          f2 = createMemo(() => d()),\n          f3 = createMemo(() => d()),\n          f4 = createMemo(() => d()),\n          f5 = createMemo(() => d()),\n          gcount = 0,\n          g = createMemo(() => {\n            gcount++;\n            return f1() + f2() + f3() + f4() + f5();\n          });\n\n        gcount = 0;\n        setD(1);\n        expect(gcount).toBe(1);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"only propagates once with exponential convergence","suites":["createMemo","executing propagating"],"updatePoint":{"line":67,"column":57},"line":67,"code":"    it(\"only propagates once with exponential convergence\", () => {\n      createRoot(() => {\n        //     d\n        //     |\n        // +---+---+\n        // v   v   v\n        // f1  f2 f3\n        //   \\ | /\n        //     O\n        //   / | \\\n        // v   v   v\n        // g1  g2  g3\n        // +---+---+\n        //     v\n        //     h\n        var [d, setD] = createSignal(0),\n          f1 = createMemo(() => {\n            return d();\n          }),\n          f2 = createMemo(() => {\n            return d();\n          }),\n          f3 = createMemo(() => {\n            return d();\n          }),\n          g1 = createMemo(() => {\n            return f1() + f2() + f3();\n          }),\n          g2 = createMemo(() => {\n            return f1() + f2() + f3();\n          }),\n          g3 = createMemo(() => {\n            return f1() + f2() + f3();\n          }),\n          hcount = 0,\n          h = createMemo(() => {\n            hcount++;\n            return g1() + g2() + g3();\n          });\n        hcount = 0;\n        setD(1);\n        expect(hcount).toBe(1);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"does not trigger downstream computations unless changed","suites":["createMemo","executing propagating"],"updatePoint":{"line":112,"column":63},"line":112,"code":"    it(\"does not trigger downstream computations unless changed\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(1, { equals: false });\n        let order = \"\";\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1();\n        });\n        createMemo(() => {\n          order += \"c1\";\n          t1();\n        });\n        expect(order).toBe(\"t1c1\");\n        order = \"\";\n        set(1);\n        expect(order).toBe(\"t1\");\n        order = \"\";\n        set(2);\n        expect(order).toBe(\"t1c1\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"applies updates to changed dependees in same order as createMemo","suites":["createMemo","executing propagating"],"updatePoint":{"line":134,"column":72},"line":134,"code":"    it(\"applies updates to changed dependees in same order as createMemo\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(0);\n        let order = \"\";\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1() === 0;\n        });\n        createMemo(() => {\n          order += \"c1\";\n          return s1();\n        });\n        createMemo(() => {\n          order += \"c2\";\n          return t1();\n        });\n\n        expect(order).toBe(\"t1c1c2\");\n        order = \"\";\n        set(1);\n        expect(order).toBe(\"t1c2c1\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"updates downstream pending computations","suites":["createMemo","executing propagating"],"updatePoint":{"line":158,"column":47},"line":158,"code":"    it(\"updates downstream pending computations\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(0);\n        const [s2] = createSignal(0);\n        let order = \"\";\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1() === 0;\n        });\n        createMemo(() => {\n          order += \"c1\";\n          return s1();\n        });\n        createMemo(() => {\n          order += \"c2\";\n          t1();\n          createMemo(() => {\n            order += \"c2_1\";\n            return s2();\n          });\n        });\n        order = \"\";\n        set(1);\n        expect(order).toBe(\"t1c2c2_1c1\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"updates on active dependencies","suites":["createMemo","with changing dependencies"],"updatePoint":{"line":205,"column":38},"line":205,"code":"    it(\"updates on active dependencies\", () => {\n      createRoot(() => {\n        init();\n        setT(5);\n        expect(fevals).toBe(1);\n        expect(f()).toBe(5);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"does not update on inactive dependencies","suites":["createMemo","with changing dependencies"],"updatePoint":{"line":214,"column":48},"line":214,"code":"    it(\"does not update on inactive dependencies\", () => {\n      createRoot(() => {\n        init();\n        setE(5);\n        expect(fevals).toBe(0);\n        expect(f()).toBe(1);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"deactivates obsolete dependencies","suites":["createMemo","with changing dependencies"],"updatePoint":{"line":223,"column":41},"line":223,"code":"    it(\"deactivates obsolete dependencies\", () => {\n      createRoot(() => {\n        init();\n        setI(false);\n        fevals = 0;\n        setT(5);\n        expect(fevals).toBe(0);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"activates new dependencies","suites":["createMemo","with changing dependencies"],"updatePoint":{"line":233,"column":34},"line":233,"code":"    it(\"activates new dependencies\", () => {\n      createRoot(() => {\n        init();\n        setI(false);\n        fevals = 0;\n        setE(5);\n        expect(fevals).toBe(1);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"ensures that new dependencies are updated before dependee","suites":["createMemo","with changing dependencies"],"updatePoint":{"line":243,"column":65},"line":243,"code":"    it(\"ensures that new dependencies are updated before dependee\", () => {\n      createRoot(() => {\n        var order = \"\",\n          [a, setA] = createSignal(0),\n          b = createMemo(() => {\n            order += \"b\";\n            return a() + 1;\n          }),\n          c = createMemo(() => {\n            order += \"c\";\n            const check = b();\n            if (check) {\n              return check;\n            }\n            return e();\n          }),\n          d = createMemo(() => {\n            return a();\n          }),\n          e = createMemo(() => {\n            order += \"d\";\n            return d() + 10;\n          });\n\n        expect(order).toBe(\"bcd\");\n\n        order = \"\";\n        setA(-1);\n\n        expect(order).toBe(\"bcd\");\n        expect(c()).toBe(9);\n\n        order = \"\";\n        setA(0);\n\n        expect(order).toBe(\"bcd\");\n        expect(c()).toBe(1);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"does not update subsequent pending computations after stale invocations","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":285,"column":79},"line":285,"code":"    it(\"does not update subsequent pending computations after stale invocations\", () => {\n      createRoot(() => {\n        const [s1, set1] = createSignal(1);\n        const [s2, set2] = createSignal(false);\n        let count = 0;\n        /*\n                    s1\n                    |\n                +---+---+\n               t1 t2 c1 t3\n                \\       /\n                   c3\n             [PN,PN,STL,void]\n        */\n        const t1 = createMemo(() => s1() > 0);\n        const t2 = createMemo(() => s1() > 0);\n        const c1 = createMemo(() => s1());\n        const t3 = createMemo(() => {\n          const a = s1();\n          const b = s2();\n          return a && b;\n        });\n        createMemo(() => {\n          t1();\n          t2();\n          c1();\n          t3();\n          count++;\n        });\n        set2(true);\n        expect(count).toBe(2);\n        set1(2);\n        expect(count).toBe(3);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"evaluates stale computations before dependendees when trackers stay unchanged","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":321,"column":85},"line":321,"code":"    it(\"evaluates stale computations before dependendees when trackers stay unchanged\", () => {\n      createRoot(() => {\n        let [s1, set] = createSignal(1, { equals: false });\n        let order = \"\";\n        let t1 = createMemo(() => {\n          order += \"t1\";\n          return s1() > 2;\n        });\n        let t2 = createMemo(() => {\n          order += \"t2\";\n          return s1() > 2;\n        });\n        let c1 = createMemo(\n          () => {\n            order += \"c1\";\n            s1();\n          },\n          undefined,\n          { equals: false }\n        );\n        createMemo(() => {\n          order += \"c2\";\n          t1();\n          t2();\n          c1();\n        });\n        order = \"\";\n        set(1);\n        expect(order).toBe(\"t1t2c1c2\");\n        order = \"\";\n        set(3);\n        expect(order).toBe(\"t2c2t1c1\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"evaluates nested trackings","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":356,"column":34},"line":356,"code":"    it(\"evaluates nested trackings\", () => {\n      createRoot(() => {\n        const [s1, set1] = createSignal(1);\n        const [s2] = createSignal(1);\n        let count = 0;\n        let c1: () => number;\n        createMemo(() => {\n          c1 = createMemo(() => s2());\n          return s1();\n        });\n        createMemo(() => {\n          count++;\n          c1();\n        });\n        set1(2);\n        expect(count).toBe(1);\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"propagates in topological order","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":375,"column":39},"line":375,"code":"    it(\"propagates in topological order\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(true);\n        let order = \"\";\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1();\n        });\n        const t2 = createMemo(() => {\n          order += \"t2\";\n          return s1();\n        });\n        createMemo(() => {\n          t1();\n          t2();\n          order += \"c1\";\n        });\n        order = \"\";\n        set(false);\n        expect(order).toBe(\"t1t2c1\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"does not evaluate dependencies with tracking sources that have not changed","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":398,"column":82},"line":398,"code":"    it(\"does not evaluate dependencies with tracking sources that have not changed\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(1);\n        let order = \"\";\n        let c2: () => boolean;\n        createMemo(() => {\n          order += \"c1\";\n          if (s1() > 1) {\n            c2();\n          }\n        });\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1() < 3;\n        });\n        const t2 = createMemo(() => {\n          order += \"t2\";\n          return t1();\n        });\n        c2 = createMemo(() => {\n          order += \"c2\";\n          return t2();\n        });\n        order = \"\";\n        set(2);\n        expect(order).toBe(\"c1t1\");\n        order = \"\";\n        set(3);\n        expect(order).toBe(\"c1t1t2c2\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"correctly marks downstream computations as stale on change","suites":["createMemo","with intercepting computations"],"updatePoint":{"line":430,"column":66},"line":430,"code":"    it(\"correctly marks downstream computations as stale on change\", () => {\n      createRoot(() => {\n        const [s1, set] = createSignal(1);\n        let order = \"\";\n        const t1 = createMemo(() => {\n          order += \"t1\";\n          return s1();\n        });\n        const c1 = createMemo(() => {\n          order += \"c1\";\n          return t1();\n        });\n        const c2 = createMemo(() => {\n          order += \"c2\";\n          return c1();\n        });\n        createMemo(() => {\n          order += \"c3\";\n          return c2();\n        });\n        order = \"\";\n        set(2);\n        expect(order).toBe(\"t1c1c2c3\");\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"throws when continually setting a direct dependency","suites":["createMemo","with unending changes"],"updatePoint":{"line":458,"column":59},"line":458,"code":"    it(\"throws when continually setting a direct dependency\", () => {\n      createRoot(() => {\n        const [d, set] = createSignal(1);\n\n        expect(() => {\n          createMemo(() => {\n            return set(d() + 1);\n          });\n        }).toThrow();\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"throws when continually setting an indirect dependency","suites":["createMemo","with unending changes"],"updatePoint":{"line":470,"column":62},"line":470,"code":"    it(\"throws when continually setting an indirect dependency\", () => {\n      createRoot(() => {\n        let i = 2;\n        const [d, set] = createSignal(1),\n          f1 = createMemo(() => d()),\n          f2 = createMemo(() => f1()),\n          f3 = createMemo(() => f2());\n\n        expect(() => {\n          createMemo(() => {\n            f3();\n            set(i++);\n          });\n        }).toThrow();\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"throws when cycle created by modifying a branch","suites":["createMemo","with circular dependencies"],"updatePoint":{"line":489,"column":55},"line":489,"code":"    it(\"throws when cycle created by modifying a branch\", () => {\n      createRoot(() => {\n        var [d, set] = createSignal(1),\n          f: Accessor<number | undefined> = createMemo(() => (f ? f() : d()), undefined, {\n            equals: false\n          });\n\n        expect(() => {\n          set(0);\n        }).toThrow();\n      });\n    });","file":"signals.memo.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and read a Signal","suites":["Create signals"],"updatePoint":{"line":26,"column":32},"line":26,"code":"  test(\"Create and read a Signal\", () => {\n    const [value] = createSignal(5);\n    expect(value()).toBe(5);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and read a Signal with comparator","suites":["Create signals"],"updatePoint":{"line":30,"column":48},"line":30,"code":"  test(\"Create and read a Signal with comparator\", () => {\n    const [value] = createSignal(5, { equals: (a, b) => a === b });\n    expect(value()).toBe(5);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and read a Memo","suites":["Create signals"],"updatePoint":{"line":34,"column":30},"line":34,"code":"  test(\"Create and read a Memo\", () => {\n    createRoot(() => {\n      const memo = createMemo(() => \"Hello\");\n      expect(memo()).toBe(\"Hello\");\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and read a Memo with initial value","suites":["Create signals"],"updatePoint":{"line":40,"column":49},"line":40,"code":"  test(\"Create and read a Memo with initial value\", () => {\n    createRoot(() => {\n      const memo = createMemo(i => `${i} John`, \"Hello\");\n      expect(memo()).toBe(\"Hello John\");\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create onMount","suites":["Create signals"],"updatePoint":{"line":46,"column":22},"line":46,"code":"  test(\"Create onMount\", () => {\n    let temp: string;\n    createRoot(() => {\n      onMount(() => (temp = \"impure\"));\n    });\n    expect(temp!).toBe(\"impure\");\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create a Effect with explicit deps","suites":["Create signals"],"updatePoint":{"line":53,"column":42},"line":53,"code":"  test(\"Create a Effect with explicit deps\", () => {\n    let temp: string;\n    createRoot(() => {\n      const [sign] = createSignal(\"thoughts\");\n      const fn = on(sign, v => (temp = `impure ${v}`));\n      createEffect(fn);\n      createEffect(on(sign, v => (temp = `impure ${v}`)));\n    });\n    expect(temp!).toBe(\"impure thoughts\");\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create a Effect with multiple explicit deps","suites":["Create signals"],"updatePoint":{"line":63,"column":51},"line":63,"code":"  test(\"Create a Effect with multiple explicit deps\", () => {\n    let temp: string;\n    createRoot(() => {\n      const [sign] = createSignal(\"thoughts\");\n      const [num] = createSignal(3);\n      const fn = on([sign, num], v => (temp = `impure ${v[1]}`));\n      createEffect(fn);\n    });\n    expect(temp!).toBe(\"impure 3\");\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create a Effect with explicit deps and lazy evaluation","suites":["Create signals"],"updatePoint":{"line":73,"column":62},"line":73,"code":"  test(\"Create a Effect with explicit deps and lazy evaluation\", () => {\n    let temp: string;\n    const [sign, set] = createSignal(\"thoughts\");\n    createRoot(() => {\n      const fn = on(sign, v => (temp = `impure ${v}`), { defer: true });\n      createEffect(fn);\n    });\n    expect(temp!).toBeUndefined();\n    set(\"minds\");\n    expect(temp!).toBe(\"impure minds\");\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and update a Signal","suites":["Update signals"],"updatePoint":{"line":87,"column":34},"line":87,"code":"  test(\"Create and update a Signal\", () => {\n    const [value, setValue] = createSignal(5);\n    setValue(10);\n    expect(value()).toBe(10);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and update a Signal with fn","suites":["Update signals"],"updatePoint":{"line":92,"column":42},"line":92,"code":"  test(\"Create and update a Signal with fn\", () => {\n    const [value, setValue] = createSignal(5);\n    setValue(p => p + 5);\n    expect(value()).toBe(10);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create Signal and set different value","suites":["Update signals"],"updatePoint":{"line":97,"column":45},"line":97,"code":"  test(\"Create Signal and set different value\", () => {\n    const [value, setValue] = createSignal(5);\n    setValue(10);\n    expect(value()).toBe(10);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create Signal and set equivalent value","suites":["Update signals"],"updatePoint":{"line":102,"column":46},"line":102,"code":"  test(\"Create Signal and set equivalent value\", () => {\n    const [value, setValue] = createSignal(5, { equals: (a, b) => a > b });\n    setValue(3);\n    expect(value()).toBe(5);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and read a Signal with function value","suites":["Update signals"],"updatePoint":{"line":107,"column":52},"line":107,"code":"  test(\"Create and read a Signal with function value\", () => {\n    const [value, setValue] = createSignal<() => string>(() => \"Hi\");\n    expect(value()()).toBe(\"Hi\");\n    setValue(() => () => \"Hello\");\n    expect(value()()).toBe(\"Hello\");\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and trigger a Memo","suites":["Update signals"],"updatePoint":{"line":113,"column":33},"line":113,"code":"  test(\"Create and trigger a Memo\", () => {\n    createRoot(() => {\n      const [name, setName] = createSignal(\"John\"),\n        memo = createMemo(() => `Hello ${name()}`);\n      expect(memo()).toBe(\"Hello John\");\n      setName(\"Jake\");\n      expect(memo()).toBe(\"Hello Jake\");\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create Signal and set equivalent value not trigger Memo","suites":["Update signals"],"updatePoint":{"line":122,"column":63},"line":122,"code":"  test(\"Create Signal and set equivalent value not trigger Memo\", () => {\n    createRoot(() => {\n      const [name, setName] = createSignal(\"John\", { equals: (a, b) => b.startsWith(\"J\") }),\n        memo = createMemo(() => `Hello ${name()}`);\n      expect(name()).toBe(\"John\");\n      expect(memo()).toBe(\"Hello John\");\n      setName(\"Jake\");\n      expect(name()).toBe(\"John\");\n      expect(memo()).toBe(\"Hello John\");\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and trigger a Memo in an effect","suites":["Update signals"],"updatePoint":{"line":133,"column":46},"line":133,"code":"  test(\"Create and trigger a Memo in an effect\", done => {\n    createRoot(() => {\n      let temp: string;\n      const [name, setName] = createSignal(\"John\"),\n        memo = createMemo(() => `Hello ${name()}`);\n      createEffect(() => (temp = `${memo()}!!!`));\n      setTimeout(() => {\n        expect(temp).toBe(\"Hello John!!!\");\n        setName(\"Jake\");\n        expect(temp).toBe(\"Hello Jake!!!\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and trigger an Effect","suites":["Update signals"],"updatePoint":{"line":147,"column":36},"line":147,"code":"  test(\"Create and trigger an Effect\", done => {\n    createRoot(() => {\n      let temp: string;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      createEffect(() => (temp = `unpure ${sign()}`));\n      setTimeout(() => {\n        expect(temp).toBe(\"unpure thoughts\");\n        setSign(\"mind\");\n        expect(temp).toBe(\"unpure mind\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and trigger an Effect with function signals","suites":["Update signals"],"updatePoint":{"line":160,"column":58},"line":160,"code":"  test(\"Create and trigger an Effect with function signals\", done => {\n    createRoot(() => {\n      let temp: string;\n      const [sign, setSign] = createSignal<() => string>(() => \"thoughts\");\n      createEffect(() => (temp = `unpure ${sign()()}`));\n      setTimeout(() => {\n        expect(temp).toBe(\"unpure thoughts\");\n        setSign(() => () => \"mind\");\n        expect(temp).toBe(\"unpure mind\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Set signal returns argument","suites":["Update signals"],"updatePoint":{"line":173,"column":35},"line":173,"code":"  test(\"Set signal returns argument\", () => {\n    const [_, setValue] = createSignal<number>();\n    const res1: undefined = setValue(undefined);\n    expect(res1).toBe(undefined);\n    const res2: number = setValue(12);\n    expect(res2).toBe(12);\n    const res3 = setValue(Math.random() >= 0 ? 12 : undefined);\n    expect(res3).toBe(12);\n    const res4 = setValue();\n    expect(res4).toBe(undefined);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Mute an effect","suites":["Untrack signals"],"updatePoint":{"line":187,"column":22},"line":187,"code":"  test(\"Mute an effect\", done => {\n    createRoot(() => {\n      let temp: string;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      createEffect(() => (temp = `unpure ${untrack(sign)}`));\n      setTimeout(() => {\n        expect(temp).toBe(\"unpure thoughts\");\n        setSign(\"mind\");\n        expect(temp).toBe(\"unpure thoughts\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Mute an effect","suites":["Batching signals"],"updatePoint":{"line":203,"column":22},"line":203,"code":"  test(\"Mute an effect\", done => {\n    createRoot(() => {\n      let temp: string;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      createEffect(() => (temp = `unpure ${untrack(sign)}`));\n      setTimeout(() => {\n        expect(temp).toBe(\"unpure thoughts\");\n        setSign(\"mind\");\n        expect(temp).toBe(\"unpure thoughts\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Groups updates","suites":["Effect grouping of signals"],"updatePoint":{"line":219,"column":22},"line":219,"code":"  test(\"Groups updates\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [a, setA] = createSignal(0);\n      const [b, setB] = createSignal(0);\n      createEffect(() => {\n        setA(1);\n        setB(1);\n      });\n      createMemo(() => (count += a() + b()));\n      setTimeout(() => {\n        expect(count).toBe(2);\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Groups updates with repeated sets","suites":["Effect grouping of signals"],"updatePoint":{"line":235,"column":41},"line":235,"code":"  test(\"Groups updates with repeated sets\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [a, setA] = createSignal(0);\n      createEffect(() => {\n        setA(1);\n        setA(4);\n      });\n      createMemo(() => (count += a()));\n      setTimeout(() => {\n        expect(count).toBe(4);\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Groups updates with fn setSignal","suites":["Effect grouping of signals"],"updatePoint":{"line":250,"column":40},"line":250,"code":"  test(\"Groups updates with fn setSignal\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [a, setA] = createSignal(0);\n      const [b, setB] = createSignal(0);\n      createEffect(() => {\n        setA(a => a + 1);\n        setB(b => b + 1);\n      });\n      createMemo(() => (count += a() + b()));\n      setTimeout(() => {\n        expect(count).toBe(2);\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Groups updates with fn setSignal with repeated sets","suites":["Effect grouping of signals"],"updatePoint":{"line":266,"column":59},"line":266,"code":"  test(\"Groups updates with fn setSignal with repeated sets\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [a, setA] = createSignal(0);\n      createEffect(() => {\n        setA(a => a + 1);\n        setA(a => a + 2);\n      });\n      createMemo(() => (count += a()));\n      setTimeout(() => {\n        expect(count).toBe(3);\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Test cross setting in a effect update","suites":["Effect grouping of signals"],"updatePoint":{"line":281,"column":45},"line":281,"code":"  test(\"Test cross setting in a effect update\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [a, setA] = createSignal(1);\n      const [b, setB] = createSignal(0);\n      createEffect(() => {\n        setA(a => a + b());\n      });\n      createMemo(() => (count += a()));\n      setTimeout(() => {\n        setB(b => b + 1);\n        setTimeout(() => {\n          expect(count).toBe(3);\n          done();\n        });\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Handles errors gracefully","suites":["Effect grouping of signals"],"updatePoint":{"line":299,"column":33},"line":299,"code":"  test(\"Handles errors gracefully\", done => {\n    createRoot(() => {\n      let error: Error;\n      const [a, setA] = createSignal(0);\n      const [b, setB] = createSignal(0);\n      createEffect(() => {\n        try {\n          setA(1);\n          throw new Error(\"test\");\n          setB(1);\n        } catch (e) {\n          error = e as Error;\n        }\n      });\n      createMemo(() => a() + b());\n      setTimeout(() => {\n        expect(a()).toBe(1);\n        expect(b()).toBe(0);\n        setA(2);\n        expect(a()).toBe(2);\n        expect(error).toBeInstanceOf(Error);\n        expect(error.message).toBe(\"test\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Multiple sets","suites":["Effect grouping of signals"],"updatePoint":{"line":326,"column":21},"line":326,"code":"  test(\"Multiple sets\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [a, setA] = createSignal(0);\n      createEffect(() => {\n        setA(1);\n        setA(0);\n      });\n      createMemo(() => (count = a()));\n      setTimeout(() => {\n        expect(count).toBe(0);\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"No default value can return undefined","suites":["Typecheck computed and effects"],"updatePoint":{"line":344,"column":45},"line":344,"code":"  test(\"No default value can return undefined\", () => {\n    createRoot(() => {\n      let count = 0;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      const fn = (arg?: number) => {\n        count++;\n        sign();\n        expect(arg).toBe(undefined);\n        return arg;\n      };\n      createComputed(fn);\n      createRenderEffect(fn);\n      createEffect(fn);\n      setTimeout(() => {\n        expect(count).toBe(3);\n        setSign(\"update\");\n        expect(count).toBe(6);\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Default value never receives undefined","suites":["Typecheck computed and effects"],"updatePoint":{"line":364,"column":46},"line":364,"code":"  test(\"Default value never receives undefined\", () => {\n    createRoot(() => {\n      let count = 0;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      const fn = (arg: number) => {\n        count++;\n        sign();\n        expect(arg).toBe(12);\n        return arg;\n      };\n      createComputed(fn, 12);\n      createRenderEffect(fn, 12);\n      createEffect(fn, 12);\n      setTimeout(() => {\n        expect(count).toBe(3);\n        setSign(\"update\");\n        expect(count).toBe(6);\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Clean an effect","suites":["onCleanup"],"updatePoint":{"line":387,"column":23},"line":387,"code":"  test(\"Clean an effect\", done => {\n    createRoot(() => {\n      let temp: string;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      createEffect(() => {\n        sign();\n        onCleanup(() => (temp = \"after\"));\n      });\n      setTimeout(() => {\n        expect(temp).toBeUndefined();\n        setSign(\"mind\");\n        expect(temp).toBe(\"after\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Explicit root disposal","suites":["onCleanup"],"updatePoint":{"line":403,"column":30},"line":403,"code":"  test(\"Explicit root disposal\", () => {\n    let temp: string | undefined, disposer: () => void;\n    createRoot(dispose => {\n      disposer = dispose;\n      onCleanup(() => (temp = \"disposed\"));\n    });\n    expect(temp).toBeUndefined();\n    disposer!();\n    expect(temp).toBe(\"disposed\");\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Failed Root disposal from arguments","suites":["onCleanup"],"updatePoint":{"line":413,"column":43},"line":413,"code":"  test(\"Failed Root disposal from arguments\", () => {\n    let temp: string | undefined, disposer: () => void;\n    createRoot((...args) => {\n      disposer = args[0];\n      onCleanup(() => (temp = \"disposed\"));\n    });\n    expect(temp).toBeUndefined();\n    expect(disposer!).toThrow();\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"No Handler","suites":["onError"],"updatePoint":{"line":425,"column":18},"line":425,"code":"  test(\"No Handler\", () => {\n    expect(() =>\n      createRoot(() => {\n        throw \"fail\";\n      })\n    ).toThrow(\"fail\");\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Top level","suites":["onError"],"updatePoint":{"line":432,"column":17},"line":432,"code":"  test(\"Top level\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        onError(() => (errored = true));\n        throw \"fail\";\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"In initial effect","suites":["onError"],"updatePoint":{"line":443,"column":25},"line":443,"code":"  test(\"In initial effect\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        createEffect(() => {\n          onError(() => (errored = true));\n          throw \"fail\";\n        });\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"With multiple error handlers","suites":["onError"],"updatePoint":{"line":456,"column":36},"line":456,"code":"  test(\"With multiple error handlers\", () => {\n    let errored = false;\n    let errored2 = false;\n    expect(() =>\n      createRoot(() => {\n        createEffect(() => {\n          onError(() => (errored = true));\n          onError(() => (errored2 = true));\n          throw \"fail\";\n        });\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n    expect(errored2).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"In update effect","suites":["onError"],"updatePoint":{"line":472,"column":24},"line":472,"code":"  test(\"In update effect\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        const [s, set] = createSignal(0);\n        createEffect(() => {\n          const v = s();\n          onError(() => (errored = true));\n          if (v) throw \"fail\";\n        });\n        set(1);\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"In initial nested effect","suites":["onError"],"updatePoint":{"line":488,"column":32},"line":488,"code":"  test(\"In initial nested effect\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        createEffect(() => {\n          createEffect(() => {\n            onError(() => (errored = true));\n            throw \"fail\";\n          });\n        });\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"In nested update effect","suites":["onError"],"updatePoint":{"line":503,"column":31},"line":503,"code":"  test(\"In nested update effect\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        const [s, set] = createSignal(0);\n        createEffect(() => {\n          createEffect(() => {\n            const v = s();\n            onError(() => (errored = true));\n            if (v) throw \"fail\";\n          });\n        });\n        set(1);\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"In nested update effect different levels","suites":["onError"],"updatePoint":{"line":521,"column":48},"line":521,"code":"  test(\"In nested update effect different levels\", () => {\n    let errored = false;\n    expect(() =>\n      createRoot(() => {\n        const [s, set] = createSignal(0);\n        createEffect(() => {\n          onError(() => (errored = true));\n          createEffect(() => {\n            const v = s();\n            if (v) throw \"fail\";\n          });\n        });\n        set(1);\n      })\n    ).not.toThrow(\"fail\");\n    expect(errored).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple defer","suites":["createDeferred"],"updatePoint":{"line":541,"column":20},"line":541,"code":"  test(\"simple defer\", done => {\n    createRoot(() => {\n      const [s, set] = createSignal(\"init\"),\n        r = createDeferred(s, { timeoutMs: 20 });\n      expect(r()).toBe(\"init\");\n      set(\"Hi\");\n      expect(r()).toBe(\"init\");\n      setTimeout(() => {\n        expect(r()).toBe(\"Hi\");\n        done();\n      }, 100);\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"simple selection","suites":["createSelector"],"updatePoint":{"line":557,"column":24},"line":557,"code":"  test(\"simple selection\", done => {\n    createRoot(() => {\n      const [s, set] = createSignal<number>(),\n        isSelected = createSelector(s);\n      let count = 0;\n      const list = Array.from({ length: 100 }, (_, i) =>\n        createMemo(() => {\n          count++;\n          return isSelected(i) ? \"selected\" : \"no\";\n        })\n      );\n      expect(count).toBe(100);\n      expect(list[3]()).toBe(\"no\");\n      setTimeout(() => {\n        count = 0;\n        set(3);\n        expect(count).toBe(1);\n        expect(list[3]()).toBe(\"selected\");\n        count = 0;\n        set(6);\n        expect(count).toBe(2);\n        expect(list[3]()).toBe(\"no\");\n        expect(list[6]()).toBe(\"selected\");\n        set(undefined);\n        expect(count).toBe(3);\n        expect(list[6]()).toBe(\"no\");\n        set(5);\n        expect(count).toBe(4);\n        expect(list[5]()).toBe(\"selected\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"double selection","suites":["createSelector"],"updatePoint":{"line":591,"column":24},"line":591,"code":"  test(\"double selection\", done => {\n    createRoot(() => {\n      const [s, set] = createSignal<number>(-1),\n        isSelected = createSelector<number, number>(s);\n      let count = 0;\n      const list = Array.from({ length: 100 }, (_, i) => [\n        createMemo(() => {\n          count++;\n          return isSelected(i) ? \"selected\" : \"no\";\n        }),\n        createMemo(() => {\n          count++;\n          return isSelected(i) ? \"oui\" : \"non\";\n        })\n      ]);\n      expect(count).toBe(200);\n      expect(list[3][0]()).toBe(\"no\");\n      expect(list[3][1]()).toBe(\"non\");\n      setTimeout(() => {\n        count = 0;\n        set(3);\n        expect(count).toBe(2);\n        expect(list[3][0]()).toBe(\"selected\");\n        expect(list[3][1]()).toBe(\"oui\");\n        count = 0;\n        set(6);\n        expect(count).toBe(4);\n        expect(list[3][0]()).toBe(\"no\");\n        expect(list[6][0]()).toBe(\"selected\");\n        expect(list[3][1]()).toBe(\"non\");\n        expect(list[6][1]()).toBe(\"oui\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"zero index","suites":["createSelector"],"updatePoint":{"line":627,"column":18},"line":627,"code":"  test(\"zero index\", done => {\n    createRoot(() => {\n      const [s, set] = createSignal<number>(-1),\n        isSelected = createSelector<number, number>(s);\n      let count = 0;\n      const list = [\n        createMemo(() => {\n          count++;\n          return isSelected(0) ? \"selected\" : \"no\";\n        })\n      ];\n      expect(count).toBe(1);\n      expect(list[0]()).toBe(\"no\");\n      setTimeout(() => {\n        count = 0;\n        set(0);\n        expect(count).toBe(1);\n        expect(list[0]()).toBe(\"selected\");\n        count = 0;\n        set(-1);\n        expect(count).toBe(1);\n        expect(list[0]()).toBe(\"no\");\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"createContext without arguments defaults to undefined","suites":["create and use context"],"updatePoint":{"line":656,"column":61},"line":656,"code":"  test(\"createContext without arguments defaults to undefined\", () => {\n    const context = createContext<number>();\n    const res = useContext(context);\n    expect(res).toBe<typeof res>(undefined);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Top level owner execute and disposal","suites":["runWithOwner"],"updatePoint":{"line":664,"column":44},"line":664,"code":"  test(\"Top level owner execute and disposal\", () => {\n    let effectRun = false;\n    let cleanupRun = false;\n    const [owner, dispose] = createRoot(dispose => {\n      return [getOwner()!, dispose];\n    });\n\n    runWithOwner(owner, () => {\n      createEffect(() => (effectRun = true));\n      onCleanup(() => (cleanupRun = true));\n      expect(effectRun).toBe(false);\n      expect(cleanupRun).toBe(false);\n    });\n    expect(effectRun).toBe(true);\n    expect(cleanupRun).toBe(false);\n    dispose();\n    expect(cleanupRun).toBe(true);\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Create and trigger a Reaction","suites":["createReaction"],"updatePoint":{"line":685,"column":37},"line":685,"code":"  test(\"Create and trigger a Reaction\", done => {\n    createRoot(() => {\n      let count = 0;\n      const [sign, setSign] = createSignal(\"thoughts\");\n      const track = createReaction(() => count++);\n      expect(count).toBe(0);\n      track(sign);\n      expect(count).toBe(0);\n      setTimeout(() => {\n        expect(count).toBe(0);\n        setSign(\"mind\");\n        expect(count).toBe(1);\n        setSign(\"body\");\n        expect(count).toBe(1);\n        track(sign);\n        setSign(\"everything\");\n        expect(count).toBe(2);\n        done();\n      });\n    });\n  });","file":"signals.spec.ts","skipped":false,"dir":"packages/solid/test"},{"name":"Reconcile a simple object","suites":["setState with reconcile"],"updatePoint":{"line":5,"column":33},"line":5,"code":"  test(\"Reconcile a simple object\", () => {\n    const [state, setState] = createStore<{ data: number; missing?: string }>({\n      data: 2,\n      missing: \"soon\"\n    });\n    expect(state.data).toBe(2);\n    expect(state.missing).toBe(\"soon\");\n    setState(reconcile({ data: 5 }));\n    expect(state.data).toBe(5);\n    expect(state.missing).toBeUndefined();\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile a simple object on a nested path","suites":["setState with reconcile"],"updatePoint":{"line":17,"column":50},"line":17,"code":"  test(\"Reconcile a simple object on a nested path\", () => {\n    const [state, setState] = createStore<{\n      data: { user: { firstName: string; middleName: string; lastName?: string } };\n    }>({\n      data: { user: { firstName: \"John\", middleName: \"\", lastName: \"Snow\" } }\n    });\n    expect(state.data.user.firstName).toBe(\"John\");\n    expect(state.data.user.lastName).toBe(\"Snow\");\n    setState(\"data\", \"user\", reconcile({ firstName: \"Jake\", middleName: \"R\" }));\n    expect(state.data.user.firstName).toBe(\"Jake\");\n    expect(state.data.user.middleName).toBe(\"R\");\n    expect(state.data.user.lastName).toBeUndefined();\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile a simple object on a nested path with no prev state","suites":["setState with reconcile"],"updatePoint":{"line":31,"column":69},"line":31,"code":"  test(\"Reconcile a simple object on a nested path with no prev state\", () => {\n    const [state, setState] = createStore<{ user?: { firstName: string; middleName: string } }>({});\n    expect(state.user).toBeUndefined();\n    setState(\"user\", reconcile({ firstName: \"Jake\", middleName: \"R\" }));\n    expect(state.user!.firstName).toBe(\"Jake\");\n    expect(state.user!.middleName).toBe(\"R\");\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile reorder a keyed array","suites":["setState with reconcile"],"updatePoint":{"line":39,"column":39},"line":39,"code":"  test(\"Reconcile reorder a keyed array\", () => {\n    const JOHN = { id: 1, firstName: \"John\", lastName: \"Snow\" },\n      NED = { id: 2, firstName: \"Ned\", lastName: \"Stark\" },\n      BRANDON = { id: 3, firstName: \"Brandon\", lastName: \"Start\" },\n      ARYA = { id: 4, firstName: \"Arya\", lastName: \"Start\" };\n    const [state, setState] = createStore({ users: [JOHN, NED, BRANDON] });\n    expect(Object.is(unwrap(state.users[0]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), BRANDON)).toBe(true);\n    setState(\"users\", reconcile([NED, JOHN, BRANDON]));\n    expect(Object.is(unwrap(state.users[0]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), BRANDON)).toBe(true);\n    setState(\"users\", reconcile([NED, BRANDON, JOHN]));\n    expect(Object.is(unwrap(state.users[0]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), BRANDON)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), JOHN)).toBe(true);\n    setState(\"users\", reconcile([NED, BRANDON, JOHN, ARYA]));\n    expect(Object.is(unwrap(state.users[0]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), BRANDON)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[3]), ARYA)).toBe(true);\n    setState(\"users\", reconcile([BRANDON, JOHN, ARYA]));\n    expect(Object.is(unwrap(state.users[0]), BRANDON)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), ARYA)).toBe(true);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile overwrite in non-keyed merge mode","suites":["setState with reconcile"],"updatePoint":{"line":67,"column":51},"line":67,"code":"  test(\"Reconcile overwrite in non-keyed merge mode\", () => {\n    const JOHN = { id: 1, firstName: \"John\", lastName: \"Snow\" },\n      NED = { id: 2, firstName: \"Ned\", lastName: \"Stark\" },\n      BRANDON = { id: 3, firstName: \"Brandon\", lastName: \"Start\" };\n    const [state, setState] = createStore({\n      users: [{ ...JOHN }, { ...NED }, { ...BRANDON }]\n    });\n    expect(state.users[0].id).toBe(1);\n    expect(state.users[0].firstName).toBe(\"John\");\n    expect(state.users[1].id).toBe(2);\n    expect(state.users[1].firstName).toBe(\"Ned\");\n    expect(state.users[2].id).toBe(3);\n    expect(state.users[2].firstName).toBe(\"Brandon\");\n    setState(\n      \"users\",\n      reconcile([{ ...NED }, { ...JOHN }, { ...BRANDON }], {\n        merge: true,\n        key: null\n      })\n    );\n    expect(state.users[0].id).toBe(2);\n    expect(state.users[0].firstName).toBe(\"Ned\");\n    expect(state.users[1].id).toBe(1);\n    expect(state.users[1].firstName).toBe(\"John\");\n    expect(state.users[2].id).toBe(3);\n    expect(state.users[2].firstName).toBe(\"Brandon\");\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile top level key mismatch","suites":["setState with reconcile"],"updatePoint":{"line":95,"column":40},"line":95,"code":"  test(\"Reconcile top level key mismatch\", () => {\n    const JOHN = { id: 1, firstName: \"John\", lastName: \"Snow\" },\n      NED = { id: 2, firstName: \"Ned\", lastName: \"Stark\" };\n\n    const [user, setUser] = createStore(JOHN);\n    expect(user.id).toBe(1);\n    expect(user.firstName).toBe(\"John\");\n    setUser(reconcile(NED));\n    expect(user.id).toBe(2);\n    expect(user.firstName).toBe(\"Ned\");\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile nested top level key mismatch","suites":["setState with reconcile"],"updatePoint":{"line":107,"column":47},"line":107,"code":"  test(\"Reconcile nested top level key mismatch\", () => {\n    const JOHN = { id: 1, firstName: \"John\", lastName: \"Snow\" },\n      NED = { id: 2, firstName: \"Ned\", lastName: \"Stark\" };\n\n    const [user, setUser] = createStore({ user: JOHN });\n    expect(user.user.id).toBe(1);\n    expect(user.user.firstName).toBe(\"John\");\n    setUser(\"user\", reconcile(NED));\n    expect(user.user.id).toBe(2);\n    expect(user.user.firstName).toBe(\"Ned\");\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top Level Mutation","suites":["setState with produce"],"updatePoint":{"line":124,"column":26},"line":124,"code":"  test(\"Top Level Mutation\", () => {\n    const [state, setState] = createStore<DataState>({ data: { starting: 1, ending: 1 } });\n    setState(\n      produce(s => {\n        s.data.ending = s.data.starting + 1;\n      })\n    );\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).toBe(2);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"referential equality","suites":["setState with produce"],"updatePoint":{"line":134,"column":28},"line":134,"code":"  test(\"referential equality\", () => {\n    const [state, setState] = createStore<DataState>({ data: { starting: 1, ending: 1 } });\n    setState(\n      produce(s => {\n        if (s.data === s.data) s.data.ending!++;\n      })\n    );\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).toBe(2);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top Level Mutation in computation","suites":["setState with produce"],"updatePoint":{"line":144,"column":41},"line":144,"code":"  test(\"Top Level Mutation in computation\", () => {\n    createRoot(() => {\n      const [s, set] = createSignal(1);\n      const [state, setState] = createStore<{ data: number[] }>({ data: [] });\n      createEffect(() => {\n        setState(\n          produce(state => {\n            state.data.push(s());\n          })\n        );\n      });\n      createEffect(() => state.data.length);\n    });\n    expect(true).toBe(true);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Nested Level Mutation","suites":["setState with produce"],"updatePoint":{"line":159,"column":29},"line":159,"code":"  test(\"Nested Level Mutation\", () => {\n    const [state, setState] = createStore({ data: { starting: 1, ending: 1 } });\n    setState(\n      \"data\",\n      produce(s => {\n        s.ending = s.starting + 1;\n      })\n    );\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).toBe(2);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top Level Deletion","suites":["setState with produce"],"updatePoint":{"line":170,"column":26},"line":170,"code":"  test(\"Top Level Deletion\", () => {\n    const [state, setState] = createStore<DataState>({ data: { starting: 1, ending: 1 } });\n    setState(\n      produce(s => {\n        delete s.data.ending;\n      })\n    );\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).not.toBeDefined();\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top Level Object Mutation","suites":["setState with produce"],"updatePoint":{"line":180,"column":33},"line":180,"code":"  test(\"Top Level Object Mutation\", () => {\n    const [state, setState] = createStore<DataState>({ data: { starting: 1, ending: 1 } }),\n      next = { starting: 3, ending: 6 };\n    setState(\n      produce(s => {\n        s.data = next;\n      })\n    );\n    expect(unwrap(state.data)).toBe(next);\n    expect(state.data.starting).toBe(3);\n    expect(state.data.ending).toBe(6);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Test Array Mutation","suites":["setState with produce"],"updatePoint":{"line":192,"column":27},"line":192,"code":"  test(\"Test Array Mutation\", () => {\n    interface TodoState {\n      todos: { id: number; title: string; done: boolean }[];\n    }\n    const [state, setState] = createStore<TodoState>({\n      todos: [\n        { id: 1, title: \"Go To Work\", done: true },\n        { id: 2, title: \"Eat Lunch\", done: false }\n      ]\n    });\n    setState(\n      produce(s => {\n        s.todos[1].done = true;\n        s.todos.push({ id: 3, title: \"Go Home\", done: false });\n      })\n    );\n    expect(Array.isArray(state.todos)).toBe(true);\n    expect(state.todos[1].done).toBe(true);\n    expect(state.todos[2].title).toBe(\"Go Home\");\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Test Top-Level Array Mutation","suites":["setState with produce"],"updatePoint":{"line":213,"column":37},"line":213,"code":"  test(\"Test Top-Level Array Mutation\", () => {\n    type TodoState = Array<{\n      id: number;\n      title: string;\n      done: boolean;\n    }>;\n    const [state, setState] = createStore<TodoState>([\n      { id: 1, title: \"Go To Work\", done: true },\n      { id: 2, title: \"Eat Lunch\", done: false }\n    ]);\n    setState(\n      produce(s => {\n        s[1].done = true;\n        s.push({ id: 3, title: \"Go Home\", done: false });\n      })\n    );\n    expect(Array.isArray(state)).toBe(true);\n    expect(state[1].done).toBe(true);\n    expect(state[2].title).toBe(\"Go Home\");\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile a simple object","suites":["modifyMutable with reconcile"],"updatePoint":{"line":236,"column":33},"line":236,"code":"  test(\"Reconcile a simple object\", () => {\n    const state = createMutable<{ data: number; missing?: string }>({\n      data: 2,\n      missing: \"soon\"\n    });\n    expect(state.data).toBe(2);\n    expect(state.missing).toBe(\"soon\");\n    modifyMutable(state, reconcile({ data: 5 }));\n    expect(state.data).toBe(5);\n    expect(state.missing).toBeUndefined();\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile a simple object on a nested path","suites":["modifyMutable with reconcile"],"updatePoint":{"line":248,"column":50},"line":248,"code":"  test(\"Reconcile a simple object on a nested path\", () => {\n    const state = createMutable<{\n      data: { user: { firstName: string; middleName: string; lastName?: string } };\n    }>({\n      data: { user: { firstName: \"John\", middleName: \"\", lastName: \"Snow\" } }\n    });\n    expect(state.data.user.firstName).toBe(\"John\");\n    expect(state.data.user.lastName).toBe(\"Snow\");\n    modifyMutable(state.data.user, reconcile({ firstName: \"Jake\", middleName: \"R\" }));\n    expect(state.data.user.firstName).toBe(\"Jake\");\n    expect(state.data.user.middleName).toBe(\"R\");\n    expect(state.data.user.lastName).toBeUndefined();\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile reorder a keyed array","suites":["modifyMutable with reconcile"],"updatePoint":{"line":262,"column":39},"line":262,"code":"  test(\"Reconcile reorder a keyed array\", () => {\n    const JOHN = { id: 1, firstName: \"John\", lastName: \"Snow\" },\n      NED = { id: 2, firstName: \"Ned\", lastName: \"Stark\" },\n      BRANDON = { id: 3, firstName: \"Brandon\", lastName: \"Start\" },\n      ARYA = { id: 4, firstName: \"Arya\", lastName: \"Start\" };\n    const state = createMutable({ users: [JOHN, NED, BRANDON] });\n    expect(Object.is(unwrap(state.users[0]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), BRANDON)).toBe(true);\n    modifyMutable(state.users, reconcile([NED, JOHN, BRANDON]));\n    expect(Object.is(unwrap(state.users[0]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), BRANDON)).toBe(true);\n    modifyMutable(state.users, reconcile([NED, BRANDON, JOHN]));\n    expect(Object.is(unwrap(state.users[0]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), BRANDON)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), JOHN)).toBe(true);\n    modifyMutable(state.users, reconcile([NED, BRANDON, JOHN, ARYA]));\n    expect(Object.is(unwrap(state.users[0]), NED)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), BRANDON)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[3]), ARYA)).toBe(true);\n    modifyMutable(state.users, reconcile([BRANDON, JOHN, ARYA]));\n    expect(Object.is(unwrap(state.users[0]), BRANDON)).toBe(true);\n    expect(Object.is(unwrap(state.users[1]), JOHN)).toBe(true);\n    expect(Object.is(unwrap(state.users[2]), ARYA)).toBe(true);\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Reconcile overwrite in non-keyed merge mode","suites":["modifyMutable with reconcile"],"updatePoint":{"line":290,"column":51},"line":290,"code":"  test(\"Reconcile overwrite in non-keyed merge mode\", () => {\n    const JOHN = { id: 1, firstName: \"John\", lastName: \"Snow\" },\n      NED = { id: 2, firstName: \"Ned\", lastName: \"Stark\" },\n      BRANDON = { id: 3, firstName: \"Brandon\", lastName: \"Start\" };\n    const state = createMutable({\n      users: [{ ...JOHN }, { ...NED }, { ...BRANDON }]\n    });\n    expect(state.users[0].id).toBe(1);\n    expect(state.users[0].firstName).toBe(\"John\");\n    expect(state.users[1].id).toBe(2);\n    expect(state.users[1].firstName).toBe(\"Ned\");\n    expect(state.users[2].id).toBe(3);\n    expect(state.users[2].firstName).toBe(\"Brandon\");\n    modifyMutable(\n      state.users,\n      reconcile([{ ...NED }, { ...JOHN }, { ...BRANDON }], {\n        merge: true,\n        key: null\n      })\n    );\n    expect(state.users[0].id).toBe(2);\n    expect(state.users[0].firstName).toBe(\"Ned\");\n    expect(state.users[1].id).toBe(1);\n    expect(state.users[1].firstName).toBe(\"John\");\n    expect(state.users[2].id).toBe(3);\n    expect(state.users[2].firstName).toBe(\"Brandon\");\n  });","file":"modifiers.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting a property","suites":["State Mutablity"],"updatePoint":{"line":6,"column":26},"line":6,"code":"  test(\"Setting a property\", () => {\n    const user = createMutable({ name: \"John\" });\n    expect(user.name).toBe(\"John\");\n    user.name = \"Jake\";\n    expect(user.name).toBe(\"Jake\");\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Deleting a property","suites":["State Mutablity"],"updatePoint":{"line":13,"column":27},"line":13,"code":"  test(\"Deleting a property\", () => {\n    const user = createMutable({ name: \"John\" });\n    expect(user.name).toBe(\"John\");\n    // @ts-ignore\n    delete user.name;\n    expect(user.name).toBeUndefined();\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Testing an update from state","suites":["State Getter/Setters"],"updatePoint":{"line":23,"column":36},"line":23,"code":"  test(\"Testing an update from state\", () => {\n    let user: any;\n    createRoot(() => {\n      user = createMutable({\n        name: \"John\",\n        get greeting(): string {\n          return `Hi, ${this.name}`;\n        }\n      });\n    });\n    expect(user.greeting).toBe(\"Hi, John\");\n    user.name = \"Jake\";\n    expect(user.greeting).toBe(\"Hi, Jake\");\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"setting a value with setters","suites":["State Getter/Setters"],"updatePoint":{"line":38,"column":36},"line":38,"code":"  test(\"setting a value with setters\", () => {\n    let user: any;\n    createRoot(() => {\n      user = createMutable({\n        firstName: \"John\",\n        lastName: \"Smith\",\n        get fullName(): string {\n          return `${this.firstName} ${this.lastName}`;\n        },\n        set fullName(value) {\n          const parts = value.split(\" \");\n          this.firstName = parts[0];\n          this.lastName = parts[1];\n        }\n      });\n    });\n    expect(user.fullName).toBe(\"John Smith\");\n    user.fullName = \"Jake Murray\";\n    expect(user.firstName).toBe(\"Jake\");\n    expect(user.lastName).toBe(\"Murray\");\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Simple Key Value","suites":["Simple update modes"],"updatePoint":{"line":62,"column":24},"line":62,"code":"  test(\"Simple Key Value\", () => {\n    const state = createMutable({ key: \"\" });\n    state.key = \"value\";\n    expect(state.key).toBe(\"value\");\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Nested update","suites":["Simple update modes"],"updatePoint":{"line":68,"column":21},"line":68,"code":"  test(\"Nested update\", () => {\n    const state = createMutable({ data: { starting: 1, ending: 1 } });\n    state.data.ending = 2;\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).toBe(2);\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Test Array","suites":["Simple update modes"],"updatePoint":{"line":75,"column":18},"line":75,"code":"  test(\"Test Array\", () => {\n    const todos = createMutable([\n      { id: 1, title: \"Go To Work\", done: true },\n      { id: 2, title: \"Eat Lunch\", done: false }\n    ]);\n    todos[1].done = true;\n    todos.push({ id: 3, title: \"Go Home\", done: false });\n    expect(Array.isArray(todos)).toBe(true);\n    expect(todos[1].done).toBe(true);\n    expect(todos[2].title).toBe(\"Go Home\");\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen state object","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":89,"column":41},"line":89,"code":"  test(\"Unwrap nested frozen state object\", () => {\n    const state = createMutable({\n        data: Object.freeze({ user: { firstName: \"John\", lastName: \"Snow\" } })\n      }),\n      s = unwrap({ ...state });\n    expect(s.data.user.firstName).toBe(\"John\");\n    expect(s.data.user.lastName).toBe(\"Snow\");\n    // @ts-ignore check if proxy still\n    expect(s.data.user[$RAW]).toBeUndefined();\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen array","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":99,"column":34},"line":99,"code":"  test(\"Unwrap nested frozen array\", () => {\n    const state = createMutable({\n        data: [{ user: { firstName: \"John\", lastName: \"Snow\" } }]\n      }),\n      s = unwrap({ data: state.data.slice(0) });\n    expect(s.data[0].user.firstName).toBe(\"John\");\n    expect(s.data[0].user.lastName).toBe(\"Snow\");\n    // @ts-ignore check if proxy still\n    expect(s.data[0].user[$RAW]).toBeUndefined();\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen state array","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":109,"column":40},"line":109,"code":"  test(\"Unwrap nested frozen state array\", () => {\n    const state = createMutable({\n        data: Object.freeze([{ user: { firstName: \"John\", lastName: \"Snow\" } }])\n      }),\n      s = unwrap({ ...state });\n    expect(s.data[0].user.firstName).toBe(\"John\");\n    expect(s.data[0].user.lastName).toBe(\"Snow\");\n    // @ts-ignore check if proxy still\n    expect(s.data[0].user[$RAW]).toBeUndefined();\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track a state change","suites":["Tracking State changes"],"updatePoint":{"line":122,"column":28},"line":122,"code":"  test(\"Track a state change\", () => {\n    let state: { data: number };\n    createRoot(() => {\n      state = createMutable({ data: 2 });\n      let executionCount = 0;\n\n      expect.assertions(2);\n      createEffect(() => {\n        if (executionCount === 0) expect(state.data).toBe(2);\n        else if (executionCount === 1) {\n          expect(state.data).toBe(5);\n        } else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n    });\n    state!.data = 5;\n    // same value again should not retrigger\n    state!.data = 5;\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Deleting an undefined property","suites":["Tracking State changes"],"updatePoint":{"line":145,"column":38},"line":145,"code":"  test(\"Deleting an undefined property\", () => {\n    let state: { firstName: string; lastName: string | undefined };\n    let executionCount = 0;\n    createRoot(() => {\n      state = createMutable({\n        firstName: \"John\",\n        lastName: undefined\n      });\n\n      createEffect(() => {\n        state.lastName;\n        executionCount++;\n      });\n      //this should retrigger the execution despite it being undefined\n    });\n    delete state!.lastName;\n    expect(executionCount).toBe(2);\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track a nested state change","suites":["Tracking State changes"],"updatePoint":{"line":164,"column":35},"line":164,"code":"  test(\"Track a nested state change\", () => {\n    let executionCount = 0;\n    let state: { user: { firstName: string; lastName: string } };\n    createRoot(() => {\n      state = createMutable({\n        user: { firstName: \"John\", lastName: \"Smith\" }\n      });\n      expect.assertions(2);\n      createEffect(() => {\n        if (executionCount === 0) {\n          expect(state.user.firstName).toBe(\"John\");\n        } else if (executionCount === 1) {\n          expect(state.user.firstName).toBe(\"Jake\");\n        } else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n    });\n    state!.user.firstName = \"Jake\";\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Array Native Methods: Array.Filter","suites":["Handling functions in state"],"updatePoint":{"line":189,"column":42},"line":189,"code":"  test(\"Array Native Methods: Array.Filter\", () => {\n    createRoot(() => {\n      const list = createMutable([0, 1, 2]),\n        getFiltered = createMemo(() => list.filter(i => i % 2));\n      expect(getFiltered()).toStrictEqual([1]);\n    });\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track function change","suites":["Handling functions in state"],"updatePoint":{"line":197,"column":29},"line":197,"code":"  test(\"Track function change\", () => {\n    createRoot(() => {\n      const state = createMutable<{ fn: () => number }>({\n          fn: () => 1\n        }),\n        getValue = createMemo(() => state.fn());\n      state.fn = () => 2;\n      expect(getValue()).toBe(2);\n    });\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting state from signal","suites":["Setting state from Effects"],"updatePoint":{"line":210,"column":33},"line":210,"code":"  test(\"Setting state from signal\", () => {\n    let state: { data: string };\n    let getData: Accessor<string>, setData: Setter<string>;\n    createRoot(() => {\n      ([getData, setData] = createSignal(\"init\")), (state = createMutable({ data: \"\" }));\n      // don't do this often\n      createEffect(() => (state.data = getData()));\n    });\n    setData!(\"signal\");\n    expect(state!.data).toBe(\"signal\");\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Select Promise","suites":["Setting state from Effects"],"updatePoint":{"line":222,"column":22},"line":222,"code":"  test(\"Select Promise\", done => {\n    createRoot(async () => {\n      const p = new Promise<string>(resolve => {\n          setTimeout(resolve, 20, \"promised\");\n        }),\n        state = createMutable({ data: \"\" });\n      p.then(v => (state.data = v));\n      await p;\n      expect(state.data).toBe(\"promised\");\n      done();\n    });\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting plain object","suites":["State wrapping"],"updatePoint":{"line":237,"column":28},"line":237,"code":"  test(\"Setting plain object\", () => {\n    const data = { withProperty: \"y\" },\n      state = createMutable({ data });\n    // not wrapped\n    expect(state.data).not.toBe(data);\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting plain array","suites":["State wrapping"],"updatePoint":{"line":243,"column":27},"line":243,"code":"  test(\"Setting plain array\", () => {\n    const data = [1, 2, 3],\n      state = createMutable({ data });\n    // not wrapped\n    expect(state.data).not.toBe(data);\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting non-wrappable","suites":["State wrapping"],"updatePoint":{"line":249,"column":29},"line":249,"code":"  test(\"Setting non-wrappable\", () => {\n    const date = new Date(),\n      state = createMutable({ time: date });\n    // not wrapped\n    expect(state.time).toBe(date);\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Respects batch in array mutate 2","suites":["State wrapping"],"updatePoint":{"line":255,"column":40},"line":255,"code":"  test(\"Respects batch in array mutate 2\", () => {\n    const state = createMutable([1, 2, 3]);\n    batch(() => {\n      expect(state.length).toBe(3);\n      const move = state.splice(1, 1);\n      expect(state.length).toBe(2);\n      state.splice(0, 0, ...move);\n      expect(state.length).toBe(3);\n      expect(state).toEqual([2, 1, 3]);\n    });\n    expect(state.length).toBe(3);\n    expect(state).toEqual([2, 1, 3]);\n  });","file":"mutable.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting a property","suites":["State immutablity"],"updatePoint":{"line":14,"column":26},"line":14,"code":"  test(\"Setting a property\", () => {\n    const [state] = createStore({ name: \"John\" });\n    expect(state.name).toBe(\"John\");\n    state.name = \"Jake\";\n    expect(state.name).toBe(\"John\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Deleting a property","suites":["State immutablity"],"updatePoint":{"line":21,"column":27},"line":21,"code":"  test(\"Deleting a property\", () => {\n    const [state] = createStore({ name: \"John\" });\n    expect(state.name).toBe(\"John\");\n    // @ts-expect-error can't delete required property\n    delete state.name;\n    expect(state.name).toBe(\"John\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Immutable state is not mutable even inside setter","suites":["State immutablity"],"updatePoint":{"line":29,"column":57},"line":29,"code":"  test(\"Immutable state is not mutable even inside setter\", () => {\n    const [state, setState] = createStore({ name: \"John\" });\n    expect(state.name).toBe(\"John\");\n    setState(() => {\n      state.name = \"Jake\";\n    });\n    expect(state.name).toBe(\"John\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Testing an update from state","suites":["State Getters"],"updatePoint":{"line":40,"column":36},"line":40,"code":"  test(\"Testing an update from state\", () => {\n    let state: any, setState: Function;\n    createRoot(() => {\n      [state, setState] = createStore({\n        name: \"John\",\n        get greeting(): string {\n          return `Hi, ${this.name}`;\n        }\n      });\n    });\n    expect(state!.greeting).toBe(\"Hi, John\");\n    setState!({ name: \"Jake\" });\n    expect(state!.greeting).toBe(\"Hi, Jake\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Testing an update from state","suites":["State Getters"],"updatePoint":{"line":55,"column":36},"line":55,"code":"  test(\"Testing an update from state\", () => {\n    let state: any, setState: Function;\n    createRoot(() => {\n      let greeting: () => string;\n      [state, setState] = createStore({\n        name: \"John\",\n        get greeting(): string {\n          return greeting();\n        }\n      });\n      greeting = createMemo(() => `Hi, ${state.name}`);\n    });\n    expect(state!.greeting).toBe(\"Hi, John\");\n    setState!({ name: \"Jake\" });\n    expect(state!.greeting).toBe(\"Hi, Jake\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Simple Key Value","suites":["Simple setState modes"],"updatePoint":{"line":74,"column":24},"line":74,"code":"  test(\"Simple Key Value\", () => {\n    const [state, setState] = createStore({ key: \"\" });\n    setState(\"key\", \"value\");\n    expect(state.key).toBe(\"value\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top level merge","suites":["Simple setState modes"],"updatePoint":{"line":80,"column":23},"line":80,"code":"  test(\"Top level merge\", () => {\n    const [state, setState] = createStore({ starting: 1, ending: 1 });\n    setState({ ending: 2 });\n    expect(state.starting).toBe(1);\n    expect(state.ending).toBe(2);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top level merge no arguments","suites":["Simple setState modes"],"updatePoint":{"line":87,"column":36},"line":87,"code":"  test(\"Top level merge no arguments\", () => {\n    const [state, setState] = createStore({ starting: 1 });\n    setState({});\n    expect(state.starting).toBe(1);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Top level state function merge","suites":["Simple setState modes"],"updatePoint":{"line":93,"column":38},"line":93,"code":"  test(\"Top level state function merge\", () => {\n    const [state, setState] = createStore({ starting: 1, ending: 1 });\n    setState((s, t) => {\n      expect(t).toStrictEqual([]);\n      return { ending: s.starting + 1 };\n    });\n    expect(state.starting).toBe(1);\n    expect(state.ending).toBe(2);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Nested merge","suites":["Simple setState modes"],"updatePoint":{"line":103,"column":20},"line":103,"code":"  test(\"Nested merge\", () => {\n    const [state, setState] = createStore({ data: { starting: 1, ending: 1 } });\n    setState(\"data\", { ending: 2 });\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).toBe(2);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Nested state function merge","suites":["Simple setState modes"],"updatePoint":{"line":110,"column":35},"line":110,"code":"  test(\"Nested state function merge\", () => {\n    const [state, setState] = createStore({ data: { starting: 1, ending: 1 } });\n    setState(\"data\", (d, t) => {\n      expect(t).toStrictEqual([\"data\"]);\n      return { ending: d.starting + 1 };\n    });\n    expect(state.data.starting).toBe(1);\n    expect(state.data.ending).toBe(2);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Test Array","suites":["Simple setState modes"],"updatePoint":{"line":120,"column":18},"line":120,"code":"  test(\"Test Array\", () => {\n    const [todos, setTodos] = createStore([\n      { id: 1, title: \"Go To Work\", done: true },\n      { id: 2, title: \"Eat Lunch\", done: false }\n    ]);\n    setTodos(1, { done: true });\n    setTodos([...todos, { id: 3, title: \"Go Home\", done: false }]);\n    setTodos(t => [...t.slice(1)]);\n    expect(Array.isArray(todos)).toBe(true);\n    expect(todos[0].done).toBe(true);\n    expect(todos[1].title).toBe(\"Go Home\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Test Array Nested","suites":["Simple setState modes"],"updatePoint":{"line":133,"column":25},"line":133,"code":"  test(\"Test Array Nested\", () => {\n    const [state, setState] = createStore({\n      todos: [\n        { id: 1, title: \"Go To Work\", done: true },\n        { id: 2, title: \"Eat Lunch\", done: false }\n      ]\n    });\n    setState(\"todos\", 1, { done: true });\n    setState(\"todos\", [...state.todos, { id: 3, title: \"Go Home\", done: false }]);\n    expect(Array.isArray(state.todos)).toBe(true);\n    expect(state.todos[1].done).toBe(true);\n    expect(state.todos[2].title).toBe(\"Go Home\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Update Specific","suites":["Array setState modes"],"updatePoint":{"line":149,"column":23},"line":149,"code":"  test(\"Update Specific\", () => {\n    const [state, setState] = createStore([1, 2, 3, 4, 5]);\n    setState([1, 3], (r, t) => {\n      expect(typeof t[0]).toBe(\"number\");\n      return r * 2;\n    });\n    expect(state[0]).toBe(1);\n    expect(state[1]).toBe(4);\n    expect(state[2]).toBe(3);\n    expect(state[3]).toBe(8);\n    expect(state[4]).toBe(5);\n    expect(Object.keys(state)).toStrictEqual([\"0\", \"1\", \"2\", \"3\", \"4\"]);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Update Specific Object","suites":["Array setState modes"],"updatePoint":{"line":162,"column":30},"line":162,"code":"  test(\"Update Specific Object\", () => {\n    const [state, setState] = createStore([1, 2, 3, 4, 5]);\n    setState({\n      1: 4,\n      3: 8\n    });\n    expect(state[0]).toBe(1);\n    expect(state[1]).toBe(4);\n    expect(state[2]).toBe(3);\n    expect(state[3]).toBe(8);\n    expect(state[4]).toBe(5);\n    expect(Object.keys(state)).toStrictEqual([\"0\", \"1\", \"2\", \"3\", \"4\"]);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Update filterFn","suites":["Array setState modes"],"updatePoint":{"line":175,"column":23},"line":175,"code":"  test(\"Update filterFn\", () => {\n    const [state, setState] = createStore([1, 2, 3, 4, 5]);\n    setState(\n      (r, i) => Boolean(i % 2),\n      (r, t) => {\n        expect(typeof t[0]).toBe(\"number\");\n        return r * 2;\n      }\n    );\n    expect(state[0]).toBe(1);\n    expect(state[1]).toBe(4);\n    expect(state[2]).toBe(3);\n    expect(state[3]).toBe(8);\n    expect(state[4]).toBe(5);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Update traversal range","suites":["Array setState modes"],"updatePoint":{"line":190,"column":30},"line":190,"code":"  test(\"Update traversal range\", () => {\n    const [state, setState] = createStore([1, 2, 3, 4, 5]);\n    setState({ from: 1, to: 4, by: 2 }, (r, t) => {\n      expect(typeof t[0]).toBe(\"number\");\n      return r * 2;\n    });\n    expect(state[0]).toBe(1);\n    expect(state[1]).toBe(4);\n    expect(state[2]).toBe(3);\n    expect(state[3]).toBe(8);\n    expect(state[4]).toBe(5);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Update traversal range defaults","suites":["Array setState modes"],"updatePoint":{"line":202,"column":39},"line":202,"code":"  test(\"Update traversal range defaults\", () => {\n    const [state, setState] = createStore([1, 2, 3, 4, 5]);\n    setState({}, (r, t) => {\n      expect(typeof t[0]).toBe(\"number\");\n      return r * 2;\n    });\n    expect(state[0]).toBe(2);\n    expect(state[1]).toBe(4);\n    expect(state[2]).toBe(6);\n    expect(state[3]).toBe(8);\n    expect(state[4]).toBe(10);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen state object","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":217,"column":41},"line":217,"code":"  test(\"Unwrap nested frozen state object\", () => {\n    const [state] = createStore({\n        data: Object.freeze({ user: { firstName: \"John\", lastName: \"Snow\" } })\n      }),\n      s = unwrap({ ...state });\n    expect(s.data.user.firstName).toBe(\"John\");\n    expect(s.data.user.lastName).toBe(\"Snow\");\n    // @ts-ignore check if proxy still\n    expect(s.data.user[$RAW]).toBeUndefined();\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen array","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":227,"column":34},"line":227,"code":"  test(\"Unwrap nested frozen array\", () => {\n    const [state] = createStore({\n        data: [{ user: { firstName: \"John\", lastName: \"Snow\" } }]\n      }),\n      s = unwrap({ data: state.data.slice(0) });\n    expect(s.data[0].user.firstName).toBe(\"John\");\n    expect(s.data[0].user.lastName).toBe(\"Snow\");\n    // @ts-ignore check if proxy still\n    expect(s.data[0].user[$RAW]).toBeUndefined();\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Unwrap nested frozen state array","suites":["Unwrapping Edge Cases"],"updatePoint":{"line":237,"column":40},"line":237,"code":"  test(\"Unwrap nested frozen state array\", () => {\n    const [state] = createStore({\n        data: Object.freeze([{ user: { firstName: \"John\", lastName: \"Snow\" } }])\n      }),\n      s = unwrap({ ...state });\n    expect(s.data[0].user.firstName).toBe(\"John\");\n    expect(s.data[0].user.lastName).toBe(\"Snow\");\n    // @ts-ignore check if proxy still\n    expect(s.data[0].user[$RAW]).toBeUndefined();\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track a state change","suites":["Tracking State changes"],"updatePoint":{"line":250,"column":28},"line":250,"code":"  test(\"Track a state change\", () => {\n    const [state, setState] = createStore({ data: 2 });\n    createRoot(() => {\n      let executionCount = 0;\n\n      expect.assertions(2);\n      createEffect(() => {\n        if (executionCount === 0) expect(state.data).toBe(2);\n        else if (executionCount === 1) {\n          expect(state.data).toBe(5);\n        } else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n    });\n    setState({ data: 5 });\n    // same value again should not retrigger\n    setState({ data: 5 });\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track a nested state change","suites":["Tracking State changes"],"updatePoint":{"line":272,"column":35},"line":272,"code":"  test(\"Track a nested state change\", () => {\n    const [state, setState] = createStore({\n      user: { firstName: \"John\", lastName: \"Smith\" }\n    });\n    createRoot(() => {\n      let executionCount = 0;\n\n      expect.assertions(2);\n      createEffect(() => {\n        if (executionCount === 0) {\n          expect(state.user.firstName).toBe(\"John\");\n        } else if (executionCount === 1) {\n          expect(state.user.firstName).toBe(\"Jake\");\n        } else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n    });\n    setState(\"user\", \"firstName\", \"Jake\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Tracking Top-Level Array iteration","suites":["Tracking State changes"],"updatePoint":{"line":295,"column":42},"line":295,"code":"  test(\"Tracking Top-Level Array iteration\", () => {\n    const [state, setState] = createStore([\"hi\"]);\n    let executionCount = 0;\n    let executionCount2 = 0;\n    let executionCount3 = 0;\n    createRoot(() => {\n      createEffect(() => {\n        for (let i = 0; i < state.length; i++) state[i];\n        untrack(() => {\n          if (executionCount === 0) expect(state.length).toBe(1);\n          else if (executionCount === 1) {\n            expect(state.length).toBe(2);\n            expect(state[1]).toBe(\"item\");\n          } else if (executionCount === 2) {\n            expect(state.length).toBe(2);\n            expect(state[1]).toBe(\"new\");\n          } else if (executionCount === 3) {\n            expect(state.length).toBe(1);\n          } else {\n            // should never get here\n            expect(executionCount).toBe(-1);\n          }\n        });\n        executionCount++;\n      });\n\n      createEffect(() => {\n        for (const item of state);\n        untrack(() => {\n          if (executionCount2 === 0) expect(state.length).toBe(1);\n          else if (executionCount2 === 1) {\n            expect(state.length).toBe(2);\n            expect(state[1]).toBe(\"item\");\n          } else if (executionCount2 === 2) {\n            expect(state.length).toBe(2);\n            expect(state[1]).toBe(\"new\");\n          } else if (executionCount2 === 3) {\n            expect(state.length).toBe(1);\n          } else {\n            // should never get here\n            expect(executionCount2).toBe(-1);\n          }\n        });\n        executionCount2++;\n      });\n\n      const mapped = mapArray(\n        () => state,\n        item => item\n      );\n      createEffect(() => {\n        mapped();\n        untrack(() => {\n          if (executionCount3 === 0) expect(state.length).toBe(1);\n          else if (executionCount3 === 1) {\n            expect(state.length).toBe(2);\n            expect(state[1]).toBe(\"item\");\n          } else if (executionCount3 === 2) {\n            expect(state.length).toBe(2);\n            expect(state[1]).toBe(\"new\");\n          } else if (executionCount3 === 3) {\n            expect(state.length).toBe(1);\n          } else {\n            // should never get here\n            expect(executionCount3).toBe(-1);\n          }\n        });\n        executionCount3++;\n      });\n    });\n    // add\n    setState(1, \"item\");\n\n    // update\n    setState(1, \"new\");\n\n    // delete\n    setState(s => [s[0]]);\n    expect.assertions(18);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Tracking iteration Object key addition/removal","suites":["Tracking State changes"],"updatePoint":{"line":376,"column":54},"line":376,"code":"  test(\"Tracking iteration Object key addition/removal\", () => {\n    const [state, setState] = createStore<{ obj: { item?: number } }>({ obj: {} });\n    let executionCount = 0;\n    let executionCount2 = 0;\n    createRoot(() => {\n      createEffect(() => {\n        const keys = Object.keys(state.obj);\n        if (executionCount === 0) expect(keys.length).toBe(0);\n        else if (executionCount === 1) {\n          expect(keys.length).toBe(1);\n          expect(keys[0]).toBe(\"item\");\n        } else if (executionCount === 2) {\n          expect(keys.length).toBe(0);\n        } else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n\n      createEffect(() => {\n        for (const key in state.obj) {\n          key;\n        }\n        const u = unwrap(state.obj);\n        if (executionCount2 === 0) expect(u.item).toBeUndefined();\n        else if (executionCount2 === 1) {\n          expect(u.item).toBe(5);\n        } else if (executionCount2 === 2) {\n          expect(u.item).toBeUndefined();\n        } else {\n          // should never get here\n          expect(executionCount2).toBe(-1);\n        }\n        executionCount2++;\n      });\n    });\n    // add\n    setState(\"obj\", \"item\", 5);\n\n    // update\n    // setState(\"obj\", \"item\", 10);\n\n    // delete\n    setState(\"obj\", \"item\", undefined);\n    expect.assertions(7);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Doesn't trigger object on addition/removal","suites":["Tracking State changes"],"updatePoint":{"line":424,"column":50},"line":424,"code":"  test(\"Doesn't trigger object on addition/removal\", () => {\n    const [state, setState] = createStore<{ obj: { item?: number } }>({ obj: {} });\n    let executionCount = 0;\n    createRoot(() => {\n      createEffect(\n        on(\n          () => state.obj,\n          v => {\n            if (executionCount === 0) expect(v.item).toBeUndefined();\n            else if (executionCount === 1) {\n              expect(v.item).toBe(5);\n            } else {\n              // should never get here\n              expect(executionCount).toBe(-1);\n            }\n            executionCount++;\n          }\n        )\n      );\n    });\n    // add\n    setState(\"obj\", \"item\", 5);\n\n    // delete\n    setState(\"obj\", \"item\", undefined);\n    expect.assertions(1);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Tracking Top level iteration Object key addition/removal","suites":["Tracking State changes"],"updatePoint":{"line":452,"column":64},"line":452,"code":"  test(\"Tracking Top level iteration Object key addition/removal\", () => {\n    const [state, setState] = createStore<{ item?: number }>({});\n    let executionCount = 0;\n    let executionCount2 = 0;\n    createRoot(() => {\n      createEffect(() => {\n        const keys = Object.keys(state);\n        if (executionCount === 0) expect(keys.length).toBe(0);\n        else if (executionCount === 1) {\n          expect(keys.length).toBe(1);\n          expect(keys[0]).toBe(\"item\");\n        } else if (executionCount === 2) {\n          expect(keys.length).toBe(0);\n        } else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n\n      createEffect(() => {\n        for (const key in state) {\n          key;\n        }\n        const u = unwrap(state);\n        if (executionCount2 === 0) expect(u.item).toBeUndefined();\n        else if (executionCount2 === 1) {\n          expect(u.item).toBe(5);\n        } else if (executionCount2 === 2) {\n          expect(u.item).toBeUndefined();\n        } else {\n          // should never get here\n          expect(executionCount2).toBe(-1);\n        }\n        executionCount2++;\n      });\n    });\n    // add\n    setState(\"item\", 5);\n\n    // delete\n    setState(\"item\", undefined);\n    expect.assertions(7);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Not Tracking Top level key addition/removal","suites":["Tracking State changes"],"updatePoint":{"line":497,"column":51},"line":497,"code":"  test(\"Not Tracking Top level key addition/removal\", () => {\n    const [state, setState] = createStore<{ item?: number; item2?: number }>({});\n    let executionCount = 0;\n    createRoot(() => {\n      createEffect(() => {\n        if (executionCount === 0) expect(state.item2).toBeUndefined();\n        else {\n          // should never get here\n          expect(executionCount).toBe(-1);\n        }\n        executionCount++;\n      });\n    });\n    // add\n    setState(\"item\", 5);\n\n    // delete\n    setState(\"item\", undefined);\n    expect.assertions(1);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Array Native Methods: Array.Filter","suites":["Handling functions in state"],"updatePoint":{"line":520,"column":42},"line":520,"code":"  test(\"Array Native Methods: Array.Filter\", () => {\n    createRoot(() => {\n      const [state] = createStore({ list: [0, 1, 2] }),\n        getFiltered = createMemo(() => state.list.filter(i => i % 2));\n      expect(getFiltered()).toStrictEqual([1]);\n    });\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Track function change","suites":["Handling functions in state"],"updatePoint":{"line":528,"column":29},"line":528,"code":"  test(\"Track function change\", () => {\n    createRoot(() => {\n      const [state, setState] = createStore<{ fn: () => number }>({\n          fn: () => 1\n        }),\n        getValue = createMemo(() => state.fn());\n      setState({ fn: () => 2 });\n      expect(getValue()).toBe(2);\n    });\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting state from signal","suites":["Setting state from Effects"],"updatePoint":{"line":541,"column":33},"line":541,"code":"  test(\"Setting state from signal\", () => {\n    const [getData, setData] = createSignal(\"init\"),\n      [state, setState] = createStore({ data: \"\" });\n    createRoot(() => {\n      createEffect(() => setState(\"data\", getData()));\n    });\n    setData(\"signal\");\n    expect(state.data).toBe(\"signal\");\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Select Promise","suites":["Setting state from Effects"],"updatePoint":{"line":551,"column":22},"line":551,"code":"  test(\"Select Promise\", done => {\n    createRoot(async () => {\n      const p = new Promise<string>(resolve => {\n        setTimeout(resolve, 20, \"promised\");\n      });\n      const [state, setState] = createStore({ data: \"\" });\n      p.then(v => setState(\"data\", v));\n      await p;\n      expect(state.data).toBe(\"promised\");\n      done();\n    });\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Respects batch","suites":["Batching"],"updatePoint":{"line":566,"column":22},"line":566,"code":"  test(\"Respects batch\", () => {\n    let data = 1;\n    const [state, setState] = createStore({ data: 1 });\n    const memo = createRoot(() => createMemo(() => (data = state.data)));\n\n    batch(() => {\n      expect(state.data).toBe(1);\n      expect(memo()).toBe(1);\n      expect(data).toBe(1);\n      setState(\"data\", 2);\n      expect(state.data).toBe(2);\n      expect(data).toBe(1);\n      expect(memo()).toBe(2);\n      expect(data).toBe(2);\n    });\n    expect(state.data).toBe(2);\n    expect(memo!()).toBe(2);\n    expect(data).toBe(2);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Respects batch in array","suites":["Batching"],"updatePoint":{"line":585,"column":31},"line":585,"code":"  test(\"Respects batch in array\", () => {\n    let data = 1;\n    const [state, setState] = createStore([1]);\n    const memo = createRoot(() => createMemo(() => (data = state[0])));\n    batch(() => {\n      expect(state[0]).toBe(1);\n      expect(memo()).toBe(1);\n      expect(data).toBe(1);\n      setState(0, 2);\n      expect(state[0]).toBe(2);\n      expect(data).toBe(1);\n      expect(memo()).toBe(2);\n      expect(data).toBe(2);\n    });\n    expect(state[0]).toBe(2);\n    expect(memo()).toBe(2);\n    expect(data).toBe(2);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Respects batch in array mutate","suites":["Batching"],"updatePoint":{"line":603,"column":38},"line":603,"code":"  test(\"Respects batch in array mutate\", () => {\n    let data = 1;\n    const [state, setState] = createStore([1]);\n    const memo = createRoot(() => createMemo(() => (data = state.length)));\n    batch(() => {\n      expect(state.length).toBe(1);\n      expect(memo()).toBe(1);\n      expect(data).toBe(1);\n      setState([...state, 2]);\n      expect(state.length).toBe(2);\n      expect(data).toBe(1);\n      expect(memo()).toBe(2);\n      expect(data).toBe(2);\n    });\n    expect(state.length).toBe(2);\n    expect(memo()).toBe(2);\n    expect(data).toBe(2);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting plain object","suites":["State wrapping"],"updatePoint":{"line":624,"column":28},"line":624,"code":"  test(\"Setting plain object\", () => {\n    const data = { withProperty: \"y\" },\n      [state] = createStore({ data });\n    // not wrapped\n    expect(state.data).not.toBe(data);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting plain array","suites":["State wrapping"],"updatePoint":{"line":630,"column":27},"line":630,"code":"  test(\"Setting plain array\", () => {\n    const data = [1, 2, 3],\n      [state] = createStore({ data });\n    // not wrapped\n    expect(state.data).not.toBe(data);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting non-wrappable","suites":["State wrapping"],"updatePoint":{"line":636,"column":29},"line":636,"code":"  test(\"Setting non-wrappable\", () => {\n    const date = new Date(),\n      [state] = createStore({ time: date });\n    // not wrapped\n    expect(state.time).toBe(date);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"Setting plain object","suites":["Array length"],"updatePoint":{"line":645,"column":28},"line":645,"code":"  test(\"Setting plain object\", () => {\n    const [state, setState] = createStore<{ list: number[] }>({ list: [] });\n    let length;\n    // isolate length tracking\n    const list = state.list;\n    createRoot(() => {\n      createEffect(() => {\n        length = list.length;\n      });\n    });\n    expect(length).toBe(0);\n    // insert at index 0\n    setState(\"list\", 0, 1);\n    expect(length).toBe(1);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"there is no infinite loop","suites":["State recursion"],"updatePoint":{"line":663,"column":33},"line":663,"code":"  test(\"there is no infinite loop\", () => {\n    const x: { a: number; b: any } = { a: 1, b: undefined };\n    x.b = x;\n\n    const [state, setState] = createStore(x);\n    expect(state.a).toBe(state.b.a);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"wrapped nested class","suites":["Nested Classes"],"updatePoint":{"line":673,"column":28},"line":673,"code":"  test(\"wrapped nested class\", () => {\n    class CustomThing {\n      a: number;\n      b: number;\n      constructor(value: number) {\n        this.a = value;\n        this.b = 10;\n      }\n    }\n\n    const [inner] = createStore(new CustomThing(1));\n    const [store, setStore] = createStore({ inner });\n\n    expect(store.inner.a).toBe(1);\n    expect(store.inner.b).toBe(10);\n\n    let sum;\n    createRoot(() => {\n      createEffect(() => {\n        sum = store.inner.a + store.inner.b;\n      });\n    });\n    expect(sum).toBe(11);\n    setStore(\"inner\", \"a\", 10);\n    expect(sum).toBe(20);\n    setStore(\"inner\", \"b\", 5);\n    expect(sum).toBe(15);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"},{"name":"not wrapped nested class","suites":["Nested Classes"],"updatePoint":{"line":702,"column":32},"line":702,"code":"  test(\"not wrapped nested class\", () => {\n    class CustomThing {\n      a: number;\n      b: number;\n      constructor(value: number) {\n        this.a = value;\n        this.b = 10;\n      }\n    }\n    const [store, setStore] = createStore({ inner: new CustomThing(1) });\n\n    expect(store.inner.a).toBe(1);\n    expect(store.inner.b).toBe(10);\n\n    let sum;\n    createRoot(() => {\n      createEffect(() => {\n        sum = store.inner.a + store.inner.b;\n      });\n    });\n    expect(sum).toBe(11);\n    setStore(\"inner\", \"a\", 10);\n    expect(sum).toBe(11);\n    setStore(\"inner\", \"b\", 5);\n    expect(sum).toBe(11);\n  });","file":"store.spec.ts","skipped":false,"dir":"packages/solid/store/test"}]}