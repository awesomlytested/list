{
    "repo": "atom/atom",
    "url": "https://github.com/atom/atom",
    "branch": "master",
    "configs": [
        {
            "package": "atom",
            "lang": "js",
            "dir": "spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "about",
            "lang": "js",
            "dir": "packages/about/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "autoflow",
            "lang": "js",
            "dir": "packages/autoflow/spec",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "dalek",
            "lang": "js",
            "dir": "packages/dalek/test",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "deprecation-cop",
            "lang": "js",
            "dir": "packages/deprecation-cop/spec",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "dev-live-reload",
            "lang": "js",
            "dir": "packages/dev-live-reload/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "exception-reporting",
            "lang": "js",
            "dir": "packages/exception-reporting/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "git-diff",
            "lang": "js",
            "dir": "packages/git-diff/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "go-to-line",
            "lang": "js",
            "dir": "packages/go-to-line/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "grammar-selector",
            "lang": "js",
            "dir": "packages/grammar-selector/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "incompatible-packages",
            "lang": "js",
            "dir": "packages/incompatible-packages/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "line-ending-selector",
            "lang": "js",
            "dir": "packages/line-ending-selector/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "link",
            "lang": "js",
            "dir": "packages/link/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "one-dark-ui",
            "lang": "js",
            "dir": "packages/one-dark-ui/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "one-light-ui",
            "lang": "js",
            "dir": "packages/one-light-ui/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "update-package-dependencies",
            "lang": "js",
            "dir": "packages/update-package-dependencies/spec",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "welcome",
            "lang": "js",
            "dir": "packages/welcome/test",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "You-Dont-Need-jQuery",
            "lang": "js",
            "dir": "spec/fixtures/git/repo-with-submodules/You-Dont-Need-jQuery/test",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "can serialize object trees containing redundant child object references",
            "suites": [
                "ApplicationDelegate",
                "set/getTemporaryWindowState"
            ],
            "updatePoint": {
                "line": 5,
                "column": 79
            },
            "line": 5,
            "code": "    it('can serialize object trees containing redundant child object references', async function () {\n      const applicationDelegate = new ApplicationDelegate();\n      const childObject = {\n        c: 1\n      };\n      const sentObject = {\n        a: childObject,\n        b: childObject\n      };\n      await applicationDelegate.setTemporaryWindowState(sentObject);\n      const receivedObject = await applicationDelegate.getTemporaryWindowState();\n      expect(receivedObject).toEqual(sentObject);\n    });",
            "file": "application-delegate-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the position of the window, and can retrieve the position just set",
            "suites": [
                "AtomEnvironment",
                "window sizing methods",
                "::getPosition and ::setPosition"
            ],
            "updatePoint": {
                "line": 24,
                "column": 81
            },
            "line": 24,
            "code": "      it('sets the position of the window, and can retrieve the position just set', () => {\n        atom.setPosition(22, 45);\n        expect(atom.getPosition()).toEqual({\n          x: 22,\n          y: 45\n        });\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the size of the window, and can retrieve the size just set",
            "suites": [
                "AtomEnvironment",
                "window sizing methods",
                "::getSize and ::setSize"
            ],
            "updatePoint": {
                "line": 36,
                "column": 73
            },
            "line": 36,
            "code": "      it('sets the size of the window, and can retrieve the size just set', async () => {\n        const newWidth = originalSize.width - 12;\n        const newHeight = originalSize.height - 23;\n        await atom.setSize(newWidth, newHeight);\n        expect(atom.getSize()).toEqual({\n          width: newWidth,\n          height: newHeight\n        });\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false if the version is a SHA and true otherwise",
            "suites": [
                "AtomEnvironment",
                ".isReleasedVersion()"
            ],
            "updatePoint": {
                "line": 48,
                "column": 64
            },
            "line": 48,
            "code": "    it('returns false if the version is a SHA and true otherwise', () => {\n      let version = '0.1.0';\n      spyOn(atom, 'getVersion').andCallFake(() => version);\n      expect(atom.isReleasedVersion()).toBe(true);\n      version = '36b5518';\n      expect(atom.isReleasedVersion()).toBe(false);\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads the default core config schema",
            "suites": [
                "AtomEnvironment",
                "loading default config"
            ],
            "updatePoint": {
                "line": 57,
                "column": 44
            },
            "line": 57,
            "code": "    it('loads the default core config schema', () => {\n      expect(atom.config.get('core.excludeVcsIgnoredPaths')).toBe(true);\n      expect(atom.config.get('core.followSymlinks')).toBe(true);\n      expect(atom.config.get('editor.showInvisibles')).toBe(false);\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will open the dev tools when an error is triggered",
            "suites": [
                "AtomEnvironment",
                "window onerror handler"
            ],
            "updatePoint": {
                "line": 70,
                "column": 58
            },
            "line": 70,
            "code": "    it('will open the dev tools when an error is triggered', async () => {\n      try {\n        a + 1; // eslint-disable-line no-undef, no-unused-expressions\n      } catch (e) {\n        window.onerror(e.toString(), 'abc', 2, 3, e);\n      }\n\n      await devToolsPromise;\n      expect(atom.openDevTools).toHaveBeenCalled();\n      expect(atom.executeJavaScriptInDevTools).toHaveBeenCalled();\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is called when there is an error",
            "suites": [
                "AtomEnvironment",
                "window onerror handler",
                "::onWillThrowError"
            ],
            "updatePoint": {
                "line": 86,
                "column": 42
            },
            "line": 86,
            "code": "      it('is called when there is an error', () => {\n        let error = null;\n        atom.onWillThrowError(willThrowSpy);\n\n        try {\n          a + 1; // eslint-disable-line no-undef, no-unused-expressions\n        } catch (e) {\n          error = e;\n          window.onerror(e.toString(), 'abc', 2, 3, e);\n        }\n\n        delete willThrowSpy.mostRecentCall.args[0].preventDefault;\n        expect(willThrowSpy).toHaveBeenCalledWith({\n          message: error.toString(),\n          url: 'abc',\n          line: 2,\n          column: 3,\n          originalError: error\n        });\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will not show the devtools when preventDefault() is called",
            "suites": [
                "AtomEnvironment",
                "window onerror handler",
                "::onWillThrowError"
            ],
            "updatePoint": {
                "line": 106,
                "column": 68
            },
            "line": 106,
            "code": "      it('will not show the devtools when preventDefault() is called', () => {\n        willThrowSpy.andCallFake(errorObject => errorObject.preventDefault());\n        atom.onWillThrowError(willThrowSpy);\n\n        try {\n          a + 1; // eslint-disable-line no-undef, no-unused-expressions\n        } catch (e) {\n          window.onerror(e.toString(), 'abc', 2, 3, e);\n        }\n\n        expect(willThrowSpy).toHaveBeenCalled();\n        expect(atom.openDevTools).not.toHaveBeenCalled();\n        expect(atom.executeJavaScriptInDevTools).not.toHaveBeenCalled();\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is called when there is an error",
            "suites": [
                "AtomEnvironment",
                "window onerror handler",
                "::onDidThrowError"
            ],
            "updatePoint": {
                "line": 124,
                "column": 42
            },
            "line": 124,
            "code": "      it('is called when there is an error', () => {\n        let error = null;\n        atom.onDidThrowError(didThrowSpy);\n\n        try {\n          a + 1; // eslint-disable-line no-undef, no-unused-expressions\n        } catch (e) {\n          error = e;\n          window.onerror(e.toString(), 'abc', 2, 3, e);\n        }\n\n        expect(didThrowSpy).toHaveBeenCalledWith({\n          message: error.toString(),\n          url: 'abc',\n          line: 2,\n          column: 3,\n          originalError: error\n        });\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies onDidFailAssertion handlers with an error object based on the call site of the assertion",
            "suites": [
                "AtomEnvironment",
                ".assert(condition, message, callback)",
                "if the condition is false"
            ],
            "updatePoint": {
                "line": 153,
                "column": 107
            },
            "line": 153,
            "code": "      it('notifies onDidFailAssertion handlers with an error object based on the call site of the assertion', () => {\n        const result = atom.assert(false, 'a == b');\n        expect(result).toBe(false);\n        expect(errors.length).toBe(1);\n        expect(errors[0].message).toBe('Assertion failed: a == b');\n        expect(errors[0].stack).toContain('atom-environment-spec');\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the callback with the assertion failure's error object",
            "suites": [
                "AtomEnvironment",
                ".assert(condition, message, callback)",
                "if the condition is false",
                "if passed a callback function"
            ],
            "updatePoint": {
                "line": 161,
                "column": 72
            },
            "line": 161,
            "code": "        it(\"calls the callback with the assertion failure's error object\", () => {\n          let error = null;\n          atom.assert(false, 'a == b', e => error = e);\n          expect(error).toBe(errors[0]);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "assigns the metadata on the assertion failure's error object",
            "suites": [
                "AtomEnvironment",
                ".assert(condition, message, callback)",
                "if the condition is false",
                "if passed metadata"
            ],
            "updatePoint": {
                "line": 168,
                "column": 72
            },
            "line": 168,
            "code": "        it(\"assigns the metadata on the assertion failure's error object\", () => {\n          atom.assert(false, 'a == b', {\n            foo: 'bar'\n          });\n          expect(errors[0].metadata).toEqual({\n            foo: 'bar'\n          });\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error",
            "suites": [
                "AtomEnvironment",
                ".assert(condition, message, callback)",
                "if the condition is false",
                "when Atom has been built from source"
            ],
            "updatePoint": {
                "line": 178,
                "column": 27
            },
            "line": 178,
            "code": "        it('throws an error', () => {\n          atom.isReleasedVersion.andReturn(false);\n          expect(() => atom.assert(false, 'testing')).toThrow('Assertion failed: testing');\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing",
            "suites": [
                "AtomEnvironment",
                ".assert(condition, message, callback)",
                "if the condition is true"
            ],
            "updatePoint": {
                "line": 185,
                "column": 22
            },
            "line": 185,
            "code": "      it('does nothing', () => {\n        const result = atom.assert(true, 'a == b');\n        expect(result).toBe(true);\n        expect(errors).toEqual([]);\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects the state based on the current project paths",
            "suites": [
                "AtomEnvironment",
                "saving and loading"
            ],
            "updatePoint": {
                "line": 195,
                "column": 60
            },
            "line": 195,
            "code": "    it('selects the state based on the current project paths', async () => {\n      jasmine.useRealClock();\n      const [dir1, dir2] = [temp.mkdirSync('dir1-'), temp.mkdirSync('dir2-')];\n      const loadSettings = Object.assign(atom.getLoadSettings(), {\n        initialProjectRoots: [dir1],\n        windowState: null\n      });\n      spyOn(atom, 'getLoadSettings').andCallFake(() => loadSettings);\n      spyOn(atom, 'serialize').andReturn({\n        stuff: 'cool'\n      });\n      atom.project.setPaths([dir1, dir2]); // State persistence will fail if other Atom instances are running\n\n      expect(await atom.stateStore.connect()).toBe(true);\n      await atom.saveState();\n      expect(await atom.loadState()).toBeFalsy();\n      loadSettings.initialProjectRoots = [dir2, dir1];\n      expect(await atom.loadState()).toEqual({\n        stuff: 'cool'\n      });\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "saves state when the CPU is idle after a keydown or mousedown event",
            "suites": [
                "AtomEnvironment",
                "saving and loading"
            ],
            "updatePoint": {
                "line": 216,
                "column": 75
            },
            "line": 216,
            "code": "    it('saves state when the CPU is idle after a keydown or mousedown event', () => {\n      const atomEnv = new AtomEnvironment({\n        applicationDelegate: global.atom.applicationDelegate\n      });\n      const idleCallbacks = [];\n      atomEnv.initialize({\n        window: {\n          requestIdleCallback(callback) {\n            idleCallbacks.push(callback);\n          },\n\n          addEventListener() {},\n\n          removeEventListener() {}\n\n        },\n        document: document.implementation.createHTMLDocument()\n      });\n      spyOn(atomEnv, 'saveState');\n      const keydown = new KeyboardEvent('keydown');\n      atomEnv.document.dispatchEvent(keydown);\n      advanceClock(atomEnv.saveStateDebounceInterval);\n      idleCallbacks.shift()();\n      expect(atomEnv.saveState).toHaveBeenCalledWith({\n        isUnloading: false\n      });\n      expect(atomEnv.saveState).not.toHaveBeenCalledWith({\n        isUnloading: true\n      });\n      atomEnv.saveState.reset();\n      const mousedown = new MouseEvent('mousedown');\n      atomEnv.document.dispatchEvent(mousedown);\n      advanceClock(atomEnv.saveStateDebounceInterval);\n      idleCallbacks.shift()();\n      expect(atomEnv.saveState).toHaveBeenCalledWith({\n        isUnloading: false\n      });\n      expect(atomEnv.saveState).not.toHaveBeenCalledWith({\n        isUnloading: true\n      });\n      atomEnv.destroy();\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores mousedown/keydown events happening after calling prepareToUnloadEditorWindow",
            "suites": [
                "AtomEnvironment",
                "saving and loading"
            ],
            "updatePoint": {
                "line": 258,
                "column": 92
            },
            "line": 258,
            "code": "    it('ignores mousedown/keydown events happening after calling prepareToUnloadEditorWindow', async () => {\n      const atomEnv = new AtomEnvironment({\n        applicationDelegate: global.atom.applicationDelegate\n      });\n      const idleCallbacks = [];\n      atomEnv.initialize({\n        window: {\n          requestIdleCallback(callback) {\n            idleCallbacks.push(callback);\n          },\n\n          addEventListener() {},\n\n          removeEventListener() {}\n\n        },\n        document: document.implementation.createHTMLDocument()\n      });\n      spyOn(atomEnv, 'saveState');\n      let mousedown = new MouseEvent('mousedown');\n      atomEnv.document.dispatchEvent(mousedown);\n      expect(atomEnv.saveState).not.toHaveBeenCalled();\n      await atomEnv.prepareToUnloadEditorWindow();\n      expect(atomEnv.saveState).toHaveBeenCalledWith({\n        isUnloading: true\n      });\n      advanceClock(atomEnv.saveStateDebounceInterval);\n      idleCallbacks.shift()();\n      expect(atomEnv.saveState.calls.length).toBe(1);\n      mousedown = new MouseEvent('mousedown');\n      atomEnv.document.dispatchEvent(mousedown);\n      advanceClock(atomEnv.saveStateDebounceInterval);\n      idleCallbacks.shift()();\n      expect(atomEnv.saveState.calls.length).toBe(1);\n      atomEnv.destroy();\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "serializes the project state with all the options supplied in saveState",
            "suites": [
                "AtomEnvironment",
                "saving and loading"
            ],
            "updatePoint": {
                "line": 294,
                "column": 79
            },
            "line": 294,
            "code": "    it('serializes the project state with all the options supplied in saveState', async () => {\n      spyOn(atom.project, 'serialize').andReturn({\n        foo: 42\n      });\n      await atom.saveState({\n        anyOption: 'any option'\n      });\n      expect(atom.project.serialize.calls.length).toBe(1);\n      expect(atom.project.serialize.mostRecentCall.args[0]).toEqual({\n        anyOption: 'any option'\n      });\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "serializes the text editor registry",
            "suites": [
                "AtomEnvironment",
                "saving and loading"
            ],
            "updatePoint": {
                "line": 306,
                "column": 43
            },
            "line": 306,
            "code": "    it('serializes the text editor registry', async () => {\n      await atom.packages.activatePackage('language-text');\n      const editor = await atom.workspace.open('sample.js');\n      expect(atom.grammars.assignLanguageMode(editor, 'text.plain')).toBe(true);\n      const atom2 = new AtomEnvironment({\n        applicationDelegate: atom.applicationDelegate,\n        window: document.createElement('div'),\n        document: Object.assign(document.createElement('div'), {\n          body: document.createElement('div'),\n          head: document.createElement('div')\n        })\n      });\n      atom2.initialize({\n        document,\n        window\n      });\n      await atom2.deserialize(atom.serialize());\n      await atom2.packages.activatePackage('language-text');\n      const editor2 = atom2.workspace.getActiveTextEditor();\n      expect(editor2.getBuffer().getLanguageMode().getLanguageId()).toBe('text.plain');\n      atom2.destroy();\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "propagates unrecognized project state restoration failures",
            "suites": [
                "AtomEnvironment",
                "saving and loading",
                "deserialization failures"
            ],
            "updatePoint": {
                "line": 329,
                "column": 68
            },
            "line": 329,
            "code": "      it('propagates unrecognized project state restoration failures', async () => {\n        let err;\n        spyOn(atom.project, 'deserialize').andCallFake(() => {\n          err = new Error('deserialization failure');\n          return Promise.reject(err);\n        });\n        spyOn(atom.notifications, 'addError');\n        await atom.deserialize({\n          project: 'should work'\n        });\n        expect(atom.notifications.addError).toHaveBeenCalledWith('Unable to deserialize project', {\n          description: 'deserialization failure',\n          stack: err.stack\n        });\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "disregards missing project folder errors",
            "suites": [
                "AtomEnvironment",
                "saving and loading",
                "deserialization failures"
            ],
            "updatePoint": {
                "line": 344,
                "column": 50
            },
            "line": 344,
            "code": "      it('disregards missing project folder errors', async () => {\n        spyOn(atom.project, 'deserialize').andCallFake(() => {\n          const err = new Error('deserialization failure');\n          err.missingProjectPaths = ['nah'];\n          return Promise.reject(err);\n        });\n        spyOn(atom.notifications, 'addError');\n        await atom.deserialize({\n          project: 'should work'\n        });\n        expect(atom.notifications.addError).not.toHaveBeenCalled();\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens an empty buffer",
            "suites": [
                "AtomEnvironment",
                "openInitialEmptyEditorIfNecessary",
                "when there are no paths set"
            ],
            "updatePoint": {
                "line": 363,
                "column": 31
            },
            "line": 363,
            "code": "      it('opens an empty buffer', () => {\n        spyOn(atom.workspace, 'open');\n        atom.openInitialEmptyEditorIfNecessary();\n        expect(atom.workspace.open).toHaveBeenCalledWith(null, {\n          pending: true\n        });\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not open an empty buffer when a buffer is already open",
            "suites": [
                "AtomEnvironment",
                "openInitialEmptyEditorIfNecessary",
                "when there are no paths set"
            ],
            "updatePoint": {
                "line": 370,
                "column": 69
            },
            "line": 370,
            "code": "      it('does not open an empty buffer when a buffer is already open', async () => {\n        await atom.workspace.open();\n        spyOn(atom.workspace, 'open');\n        atom.openInitialEmptyEditorIfNecessary();\n        expect(atom.workspace.open).not.toHaveBeenCalled();\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not open an empty buffer when core.openEmptyEditorOnStart is false",
            "suites": [
                "AtomEnvironment",
                "openInitialEmptyEditorIfNecessary",
                "when there are no paths set"
            ],
            "updatePoint": {
                "line": 376,
                "column": 81
            },
            "line": 376,
            "code": "      it('does not open an empty buffer when core.openEmptyEditorOnStart is false', async () => {\n        atom.config.set('core.openEmptyEditorOnStart', false);\n        spyOn(atom.workspace, 'open');\n        atom.openInitialEmptyEditorIfNecessary();\n        expect(atom.workspace.open).not.toHaveBeenCalled();\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not open an empty buffer",
            "suites": [
                "AtomEnvironment",
                "openInitialEmptyEditorIfNecessary",
                "when the project has a path"
            ],
            "updatePoint": {
                "line": 390,
                "column": 39
            },
            "line": 390,
            "code": "      it('does not open an empty buffer', () => {\n        atom.openInitialEmptyEditorIfNecessary();\n        expect(atom.workspace.open).not.toHaveBeenCalled();\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing if the user dismisses the file picker",
            "suites": [
                "AtomEnvironment",
                "adding a project folder"
            ],
            "updatePoint": {
                "line": 397,
                "column": 58
            },
            "line": 397,
            "code": "    it('does nothing if the user dismisses the file picker', () => {\n      const projectRoots = atom.project.getPaths();\n      spyOn(atom, 'pickFolder').andCallFake(callback => callback(null));\n      atom.addProjectFolder();\n      expect(atom.project.getPaths()).toEqual(projectRoots);\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the selected folder to the project",
            "suites": [
                "AtomEnvironment",
                "adding a project folder",
                "when there is no saved state for the added folders"
            ],
            "updatePoint": {
                "line": 408,
                "column": 49
            },
            "line": 408,
            "code": "      it('adds the selected folder to the project', async () => {\n        atom.project.setPaths([]);\n        const tempDirectory = temp.mkdirSync('a-new-directory');\n        spyOn(atom, 'pickFolder').andCallFake(callback => callback([tempDirectory]));\n        await atom.addProjectFolder();\n        expect(atom.project.getPaths()).toEqual([tempDirectory]);\n        expect(atom.attemptRestoreProjectStateForPaths).not.toHaveBeenCalled();\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "attempts to restore the project state",
            "suites": [
                "AtomEnvironment",
                "adding a project folder",
                "when there is saved state for the relevant directories",
                "when there are no project folders"
            ],
            "updatePoint": {
                "line": 427,
                "column": 49
            },
            "line": 427,
            "code": "        it('attempts to restore the project state', async () => {\n          await atom.addProjectFolder();\n          expect(atom.attemptRestoreProjectStateForPaths).toHaveBeenCalledWith(state, [__dirname]);\n          expect(atom.project.getPaths()).toEqual([]);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not attempt to restore the project state, instead adding the project paths",
            "suites": [
                "AtomEnvironment",
                "adding a project folder",
                "when there is saved state for the relevant directories",
                "when there are already project folders"
            ],
            "updatePoint": {
                "line": 436,
                "column": 91
            },
            "line": 436,
            "code": "        it('does not attempt to restore the project state, instead adding the project paths', async () => {\n          await atom.addProjectFolder();\n          expect(atom.attemptRestoreProjectStateForPaths).not.toHaveBeenCalled();\n          expect(atom.project.getPaths()).toEqual([openedPath, __dirname]);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "automatically restores the saved state into the current environment",
            "suites": [
                "AtomEnvironment",
                "attemptRestoreProjectStateForPaths(state, projectPaths, filesToOpen)",
                "when the window is clean (empty or has only unnamed, unmodified buffers)"
            ],
            "updatePoint": {
                "line": 450,
                "column": 77
            },
            "line": 450,
            "code": "      it('automatically restores the saved state into the current environment', async () => {\n        const projectPath = temp.mkdirSync();\n        const filePath1 = path.join(projectPath, 'file-1');\n        const filePath2 = path.join(projectPath, 'file-2');\n        const filePath3 = path.join(projectPath, 'file-3');\n        fs.writeFileSync(filePath1, 'abc');\n        fs.writeFileSync(filePath2, 'def');\n        fs.writeFileSync(filePath3, 'ghi');\n        const env1 = new AtomEnvironment({\n          applicationDelegate: atom.applicationDelegate\n        });\n        env1.project.setPaths([projectPath]);\n        await env1.workspace.open(filePath1);\n        await env1.workspace.open(filePath2);\n        await env1.workspace.open(filePath3);\n        const env1State = env1.serialize();\n        env1.destroy();\n        const env2 = new AtomEnvironment({\n          applicationDelegate: atom.applicationDelegate\n        });\n        await env2.attemptRestoreProjectStateForPaths(env1State, [projectPath], [filePath2]);\n        const restoredURIs = env2.workspace.getPaneItems().map(p => p.getURI());\n        expect(restoredURIs).toEqual([filePath1, filePath2, filePath3]);\n        env2.destroy();\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't prompt the user to restore state",
            "suites": [
                "AtomEnvironment",
                "attemptRestoreProjectStateForPaths(state, projectPaths, filesToOpen)",
                "when the window is clean (empty or has only unnamed, unmodified buffers)",
                "when a dock has a non-text editor"
            ],
            "updatePoint": {
                "line": 476,
                "column": 52
            },
            "line": 476,
            "code": "        it(\"doesn't prompt the user to restore state\", () => {\n          const dock = atom.workspace.getLeftDock();\n          dock.getActivePane().addItem({\n            getTitle() {\n              return 'title';\n            },\n\n            element: document.createElement('div')\n          });\n          const state = {};\n          spyOn(atom, 'confirm');\n          atom.attemptRestoreProjectStateForPaths(state, [__dirname], [__filename]);\n          expect(atom.confirm).not.toHaveBeenCalled();\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prompts the user to restore the state",
            "suites": [
                "AtomEnvironment",
                "attemptRestoreProjectStateForPaths(state, projectPaths, filesToOpen)",
                "when the window is dirty",
                "when a dock has a modified editor"
            ],
            "updatePoint": {
                "line": 499,
                "column": 49
            },
            "line": 499,
            "code": "        it('prompts the user to restore the state', () => {\n          const dock = atom.workspace.getLeftDock();\n          dock.getActivePane().addItem(editor);\n          spyOn(atom, 'confirm').andReturn(1);\n          spyOn(atom.project, 'addPath');\n          spyOn(atom.workspace, 'open');\n          const state = Symbol('state');\n          atom.attemptRestoreProjectStateForPaths(state, [__dirname], [__filename]);\n          expect(atom.confirm).toHaveBeenCalled();\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prompts the user to restore the state in a new window, discarding it and adding folder to current window",
            "suites": [
                "AtomEnvironment",
                "attemptRestoreProjectStateForPaths(state, projectPaths, filesToOpen)",
                "when the window is dirty",
                "when a dock has a modified editor"
            ],
            "updatePoint": {
                "line": 510,
                "column": 114
            },
            "line": 510,
            "code": "      it('prompts the user to restore the state in a new window, discarding it and adding folder to current window', async () => {\n        jasmine.useRealClock();\n        spyOn(atom, 'confirm').andCallFake((options, callback) => callback(1));\n        spyOn(atom.project, 'addPath');\n        spyOn(atom.workspace, 'open');\n        const state = Symbol('state');\n        atom.attemptRestoreProjectStateForPaths(state, [__dirname], [__filename]);\n        expect(atom.confirm).toHaveBeenCalled();\n        await conditionPromise(() => atom.project.addPath.callCount === 1);\n        expect(atom.project.addPath).toHaveBeenCalledWith(__dirname);\n        expect(atom.workspace.open.callCount).toBe(1);\n        expect(atom.workspace.open).toHaveBeenCalledWith(__filename);\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prompts the user to restore the state in a new window, opening a new window",
            "suites": [
                "AtomEnvironment",
                "attemptRestoreProjectStateForPaths(state, projectPaths, filesToOpen)",
                "when the window is dirty",
                "when a dock has a modified editor"
            ],
            "updatePoint": {
                "line": 523,
                "column": 85
            },
            "line": 523,
            "code": "      it('prompts the user to restore the state in a new window, opening a new window', async () => {\n        jasmine.useRealClock();\n        spyOn(atom, 'confirm').andCallFake((options, callback) => callback(0));\n        spyOn(atom, 'open');\n        const state = Symbol('state');\n        atom.attemptRestoreProjectStateForPaths(state, [__dirname], [__filename]);\n        expect(atom.confirm).toHaveBeenCalled();\n        await conditionPromise(() => atom.open.callCount === 1);\n        expect(atom.open).toHaveBeenCalledWith({\n          pathsToOpen: [__dirname, __filename],\n          newWindow: true,\n          devMode: atom.inDevMode(),\n          safeMode: atom.inSafeMode()\n        });\n      });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "saves the BlobStore so it can be loaded after reload",
            "suites": [
                "AtomEnvironment",
                "::unloadEditorWindow()"
            ],
            "updatePoint": {
                "line": 541,
                "column": 60
            },
            "line": 541,
            "code": "    it('saves the BlobStore so it can be loaded after reload', () => {\n      const configDirPath = temp.mkdirSync('atom-spec-environment');\n      const fakeBlobStore = jasmine.createSpyObj('blob store', ['save']);\n      const atomEnvironment = new AtomEnvironment({\n        applicationDelegate: atom.applicationDelegate,\n        enablePersistence: true\n      });\n      atomEnvironment.initialize({\n        configDirPath,\n        blobStore: fakeBlobStore,\n        window,\n        document\n      });\n      atomEnvironment.unloadEditorWindow();\n      expect(fakeBlobStore.save).toHaveBeenCalled();\n      atomEnvironment.destroy();\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw exceptions when unsubscribing from ipc events (regression)",
            "suites": [
                "AtomEnvironment",
                "::destroy()"
            ],
            "updatePoint": {
                "line": 560,
                "column": 81
            },
            "line": 560,
            "code": "    it('does not throw exceptions when unsubscribing from ipc events (regression)', async () => {\n      const fakeDocument = {\n        addEventListener() {},\n\n        removeEventListener() {},\n\n        head: document.createElement('head'),\n        body: document.createElement('body')\n      };\n      const atomEnvironment = new AtomEnvironment({\n        applicationDelegate: atom.applicationDelegate\n      });\n      atomEnvironment.initialize({\n        window,\n        document: fakeDocument\n      });\n      spyOn(atomEnvironment.packages, 'loadPackages').andReturn(Promise.resolve());\n      spyOn(atomEnvironment.packages, 'activate').andReturn(Promise.resolve());\n      spyOn(atomEnvironment, 'displayWindow').andReturn(Promise.resolve());\n      await atomEnvironment.startEditorWindow();\n      atomEnvironment.unloadEditorWindow();\n      atomEnvironment.destroy();\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is triggered once the shell environment is loaded",
            "suites": [
                "AtomEnvironment",
                "::whenShellEnvironmentLoaded()"
            ],
            "updatePoint": {
                "line": 612,
                "column": 57
            },
            "line": 612,
            "code": "    it('is triggered once the shell environment is loaded', async () => {\n      atomEnvironment.whenShellEnvironmentLoaded(spy);\n      atomEnvironment.updateProcessEnvAndTriggerHooks();\n      await envLoaded();\n      expect(spy).toHaveBeenCalled();\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "triggers the callback immediately if the shell environment is already loaded",
            "suites": [
                "AtomEnvironment",
                "::whenShellEnvironmentLoaded()"
            ],
            "updatePoint": {
                "line": 618,
                "column": 84
            },
            "line": 618,
            "code": "    it('triggers the callback immediately if the shell environment is already loaded', async () => {\n      atomEnvironment.updateProcessEnvAndTriggerHooks();\n      await envLoaded();\n      atomEnvironment.whenShellEnvironmentLoaded(spy);\n      expect(spy).toHaveBeenCalled();\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file",
            "suites": [
                "AtomEnvironment",
                "::openLocations(locations)",
                "when there is no saved state",
                "when the opened path exists"
            ],
            "updatePoint": {
                "line": 634,
                "column": 24
            },
            "line": 634,
            "code": "        it('opens a file', async () => {\n          const pathToOpen = __filename;\n          await atom.openLocations([{\n            pathToOpen,\n            exists: true,\n            isFile: true\n          }]);\n          expect(atom.project.getPaths()).toEqual([]);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory as a project folder",
            "suites": [
                "AtomEnvironment",
                "::openLocations(locations)",
                "when there is no saved state",
                "when the opened path exists"
            ],
            "updatePoint": {
                "line": 643,
                "column": 49
            },
            "line": 643,
            "code": "        it('opens a directory as a project folder', async () => {\n          const pathToOpen = __dirname;\n          await atom.openLocations([{\n            pathToOpen,\n            exists: true,\n            isDirectory: true\n          }]);\n          expect(atom.workspace.getTextEditors().map(e => e.getPath())).toEqual([]);\n          expect(atom.project.getPaths()).toEqual([pathToOpen]);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens it as a new file",
            "suites": [
                "AtomEnvironment",
                "::openLocations(locations)",
                "when there is no saved state",
                "when the opened path does not exist"
            ],
            "updatePoint": {
                "line": 655,
                "column": 34
            },
            "line": 655,
            "code": "        it('opens it as a new file', async () => {\n          const pathToOpen = path.join(__dirname, 'this-path-does-not-exist.txt');\n          await atom.openLocations([{\n            pathToOpen,\n            exists: false\n          }]);\n          expect(atom.workspace.getTextEditors().map(e => e.getPath())).toEqual([pathToOpen]);\n          expect(atom.project.getPaths()).toEqual([]);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "may be required to be an existing directory",
            "suites": [
                "AtomEnvironment",
                "::openLocations(locations)",
                "when there is no saved state",
                "when the opened path does not exist"
            ],
            "updatePoint": {
                "line": 664,
                "column": 55
            },
            "line": 664,
            "code": "        it('may be required to be an existing directory', async () => {\n          spyOn(atom.notifications, 'addWarning');\n          const nonExistent = path.join(__dirname, 'no');\n          const existingFile = __filename;\n          const existingDir = path.join(__dirname, 'fixtures');\n          await atom.openLocations([{\n            pathToOpen: nonExistent,\n            isDirectory: true\n          }, {\n            pathToOpen: existingFile,\n            isDirectory: true\n          }, {\n            pathToOpen: existingDir,\n            isDirectory: true\n          }]);\n          expect(atom.workspace.getTextEditors()).toEqual([]);\n          expect(atom.project.getPaths()).toEqual([existingDir]);\n          expect(atom.notifications.addWarning).toHaveBeenCalledWith('Unable to open project folders', {\n            description: `The directories \\`${nonExistent}\\` and \\`${existingFile}\\` do not exist.`\n          });\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds it to the project's paths as is",
            "suites": [
                "AtomEnvironment",
                "::openLocations(locations)",
                "when there is no saved state",
                "when the opened path is handled by a registered directory provider"
            ],
            "updatePoint": {
                "line": 709,
                "column": 48
            },
            "line": 709,
            "code": "        it(\"adds it to the project's paths as is\", async () => {\n          const pathToOpen = 'remote://server:7644/some/dir/path';\n          spyOn(atom.project, 'addPath');\n          await atom.openLocations([{\n            pathToOpen\n          }]);\n          expect(atom.project.addPath).toHaveBeenCalledWith(pathToOpen);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "attempts to restore the project state",
            "suites": [
                "AtomEnvironment",
                "::openLocations(locations)",
                "when there is saved state for the relevant directories",
                "when there are no project folders"
            ],
            "updatePoint": {
                "line": 733,
                "column": 49
            },
            "line": 733,
            "code": "        it('attempts to restore the project state', async () => {\n          const pathToOpen = __dirname;\n          await atom.openLocations([{\n            pathToOpen,\n            isDirectory: true\n          }]);\n          expect(atom.attemptRestoreProjectStateForPaths).toHaveBeenCalledWith(state, [pathToOpen], []);\n          expect(atom.project.getPaths()).toEqual([]);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes missing mandatory project folders in computation of initial state key",
            "suites": [
                "AtomEnvironment",
                "::openLocations(locations)",
                "when there is saved state for the relevant directories",
                "when there are no project folders"
            ],
            "updatePoint": {
                "line": 742,
                "column": 90
            },
            "line": 742,
            "code": "        it('includes missing mandatory project folders in computation of initial state key', async () => {\n          const existingDir = path.join(__dirname, 'fixtures');\n          const missingDir = path.join(__dirname, 'no');\n          atom.loadState.andCallFake(function (key) {\n            if (key === `${existingDir}:${missingDir}`) {\n              return Promise.resolve(state);\n            } else {\n              return Promise.resolve(null);\n            }\n          });\n          await atom.openLocations([{\n            pathToOpen: existingDir\n          }, {\n            pathToOpen: missingDir,\n            isDirectory: true\n          }]);\n          expect(atom.attemptRestoreProjectStateForPaths).toHaveBeenCalledWith(state, [existingDir], []);\n          expect(atom.project.getPaths(), [existingDir]);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the specified files",
            "suites": [
                "AtomEnvironment",
                "::openLocations(locations)",
                "when there is saved state for the relevant directories",
                "when there are no project folders"
            ],
            "updatePoint": {
                "line": 761,
                "column": 37
            },
            "line": 761,
            "code": "        it('opens the specified files', async () => {\n          await atom.openLocations([{\n            pathToOpen: __dirname,\n            isDirectory: true\n          }, {\n            pathToOpen: __filename\n          }]);\n          expect(atom.attemptRestoreProjectStateForPaths).toHaveBeenCalledWith(state, [__dirname], [__filename]);\n          expect(atom.project.getPaths()).toEqual([]);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not attempt to restore the project state, instead adding the project paths",
            "suites": [
                "AtomEnvironment",
                "::openLocations(locations)",
                "when there is saved state for the relevant directories",
                "when there are already project folders"
            ],
            "updatePoint": {
                "line": 774,
                "column": 91
            },
            "line": 774,
            "code": "        it('does not attempt to restore the project state, instead adding the project paths', async () => {\n          const pathToOpen = path.join(__dirname, 'fixtures');\n          await atom.openLocations([{\n            pathToOpen,\n            exists: true,\n            isDirectory: true\n          }]);\n          expect(atom.attemptRestoreProjectStateForPaths).not.toHaveBeenCalled();\n          expect(atom.project.getPaths()).toEqual([__dirname, pathToOpen]);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the specified files",
            "suites": [
                "AtomEnvironment",
                "::openLocations(locations)",
                "when there is saved state for the relevant directories",
                "when there are already project folders"
            ],
            "updatePoint": {
                "line": 784,
                "column": 37
            },
            "line": 784,
            "code": "        it('opens the specified files', async () => {\n          const pathToOpen = path.join(__dirname, 'fixtures');\n          const fileToOpen = path.join(pathToOpen, 'michelle-is-awesome.txt');\n          await atom.openLocations([{\n            pathToOpen,\n            exists: true,\n            isDirectory: true\n          }, {\n            pathToOpen: fileToOpen,\n            exists: true,\n            isFile: true\n          }]);\n          expect(atom.attemptRestoreProjectStateForPaths).not.toHaveBeenCalledWith(state, [pathToOpen], [fileToOpen]);\n          expect(atom.project.getPaths()).toEqual([__dirname, pathToOpen]);\n        });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the correct channel based on the version number",
            "suites": [
                "AtomEnvironment",
                "::getReleaseChannel()"
            ],
            "updatePoint": {
                "line": 807,
                "column": 63
            },
            "line": 807,
            "code": "    it('returns the correct channel based on the version number', () => {\n      version = '1.5.6';\n      expect(atom.getReleaseChannel()).toBe('stable');\n      version = '1.5.0-beta10';\n      expect(atom.getReleaseChannel()).toBe('beta');\n      version = '1.7.0-dev-5340c91';\n      expect(atom.getReleaseChannel()).toBe('dev');\n    });",
            "file": "atom-environment-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets ATOM_HOME to the portable .atom folder if it has permission",
            "suites": [
                "AtomPaths",
                "SetAtomHomePath",
                "when a portable .atom folder exists"
            ],
            "updatePoint": {
                "line": 28,
                "column": 74
            },
            "line": 28,
            "code": "      it('sets ATOM_HOME to the portable .atom folder if it has permission', () => {\n        atomPaths.setAtomHome(app.getPath('home'));\n        expect(process.env.ATOM_HOME).toEqual(portableAtomHomePath);\n      });",
            "file": "atom-paths-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses ATOM_HOME if no write access to portable .atom folder",
            "suites": [
                "AtomPaths",
                "SetAtomHomePath",
                "when a portable .atom folder exists"
            ],
            "updatePoint": {
                "line": 32,
                "column": 68
            },
            "line": 32,
            "code": "      it('uses ATOM_HOME if no write access to portable .atom folder', () => {\n        if (process.platform === 'win32') return;\n        const readOnlyPath = temp.mkdirSync('atom-path-spec-no-write-access');\n        process.env.ATOM_HOME = readOnlyPath;\n        fs.chmodSync(portableAtomHomePath, 444);\n        atomPaths.setAtomHome(app.getPath('home'));\n        expect(process.env.ATOM_HOME).toEqual(readOnlyPath);\n      });",
            "file": "atom-paths-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "leaves ATOM_HOME unmodified if it was already set",
            "suites": [
                "AtomPaths",
                "SetAtomHomePath",
                "when a portable folder does not exist"
            ],
            "updatePoint": {
                "line": 49,
                "column": 59
            },
            "line": 49,
            "code": "      it('leaves ATOM_HOME unmodified if it was already set', () => {\n        const temporaryHome = temp.mkdirSync('atom-spec-setatomhomepath');\n        process.env.ATOM_HOME = temporaryHome;\n        atomPaths.setAtomHome(app.getPath('home'));\n        expect(process.env.ATOM_HOME).toEqual(temporaryHome);\n      });",
            "file": "atom-paths-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets ATOM_HOME to a default location if not yet set",
            "suites": [
                "AtomPaths",
                "SetAtomHomePath",
                "when a portable folder does not exist"
            ],
            "updatePoint": {
                "line": 55,
                "column": 61
            },
            "line": 55,
            "code": "      it('sets ATOM_HOME to a default location if not yet set', () => {\n        const expectedPath = path.join(app.getPath('home'), '.atom');\n        atomPaths.setAtomHome(app.getPath('home'));\n        expect(process.env.ATOM_HOME).toEqual(expectedPath);\n      });",
            "file": "atom-paths-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets userData path to the folder if it has permission",
            "suites": [
                "AtomPaths",
                "setUserData",
                "when an electronUserData folder exists"
            ],
            "updatePoint": {
                "line": 88,
                "column": 63
            },
            "line": 88,
            "code": "      it('sets userData path to the folder if it has permission', () => {\n        fs.mkdirSync(electronUserDataPath);\n        atomPaths.setUserData(app);\n        expect(app.getPath('userData')).toEqual(electronUserDataPath);\n      });",
            "file": "atom-paths-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "leaves userData unchanged if no write access to electronUserData folder",
            "suites": [
                "AtomPaths",
                "setUserData",
                "when an electronUserData folder exists"
            ],
            "updatePoint": {
                "line": 93,
                "column": 81
            },
            "line": 93,
            "code": "      it('leaves userData unchanged if no write access to electronUserData folder', () => {\n        if (process.platform === 'win32') return;\n        fs.mkdirSync(electronUserDataPath);\n        fs.chmodSync(electronUserDataPath, 444);\n        atomPaths.setUserData(app);\n        fs.chmodSync(electronUserDataPath, 666);\n        expect(app.getPath('userData')).toEqual(defaultElectronUserDataPath);\n      });",
            "file": "atom-paths-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "leaves userData app path unchanged",
            "suites": [
                "AtomPaths",
                "setUserData",
                "when an electronUserDataPath folder does not exist"
            ],
            "updatePoint": {
                "line": 103,
                "column": 44
            },
            "line": 103,
            "code": "      it('leaves userData app path unchanged', () => {\n        atomPaths.setUserData(app);\n        expect(app.getPath('userData')).toEqual(defaultElectronUserDataPath);\n      });",
            "file": "atom-paths-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sends the file relative in the package as response",
            "suites": [
                "\"atom\" protocol URL"
            ],
            "updatePoint": {
                "line": 1,
                "column": 92
            },
            "line": 1,
            "code": "describe('\"atom\" protocol URL', () => it('sends the file relative in the package as response', function () {\n  let called = false;\n  const request = new XMLHttpRequest();\n  request.addEventListener('load', () => called = true);\n  request.open('GET', 'atom://async/package.json', true);\n  request.send();\n  waitsFor('request to be done', () => called === true);\n}));",
            "file": "atom-protocol-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "subscribes to \"did-begin-checking-for-update\" event",
            "suites": [
                "AutoUpdateManager (renderer)",
                "::onDidBeginCheckingForUpdate"
            ],
            "updatePoint": {
                "line": 23,
                "column": 59
            },
            "line": 23,
            "code": "    it('subscribes to \"did-begin-checking-for-update\" event', () => {\n      const spy = jasmine.createSpy('spy');\n      autoUpdateManager.onDidBeginCheckingForUpdate(spy);\n      electronAutoUpdater.emit('checking-for-update');\n      waitsFor(() => {\n        return spy.callCount === 1;\n      });\n    });",
            "file": "auto-update-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "subscribes to \"did-begin-downloading-update\" event",
            "suites": [
                "AutoUpdateManager (renderer)",
                "::onDidBeginDownloadingUpdate"
            ],
            "updatePoint": {
                "line": 33,
                "column": 58
            },
            "line": 33,
            "code": "    it('subscribes to \"did-begin-downloading-update\" event', () => {\n      const spy = jasmine.createSpy('spy');\n      autoUpdateManager.onDidBeginDownloadingUpdate(spy);\n      electronAutoUpdater.emit('update-available');\n      waitsFor(() => {\n        return spy.callCount === 1;\n      });\n    });",
            "file": "auto-update-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "subscribes to \"did-complete-downloading-update\" event",
            "suites": [
                "AutoUpdateManager (renderer)",
                "::onDidCompleteDownloadingUpdate"
            ],
            "updatePoint": {
                "line": 43,
                "column": 61
            },
            "line": 43,
            "code": "    it('subscribes to \"did-complete-downloading-update\" event', () => {\n      const spy = jasmine.createSpy('spy');\n      autoUpdateManager.onDidCompleteDownloadingUpdate(spy);\n      electronAutoUpdater.emit('update-downloaded', null, null, '1.2.3');\n      waitsFor(() => {\n        return spy.callCount === 1;\n      });\n      runs(() => {\n        expect(spy.mostRecentCall.args[0].releaseVersion).toBe('1.2.3');\n      });\n    });",
            "file": "auto-update-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "subscribes to \"update-not-available\" event",
            "suites": [
                "AutoUpdateManager (renderer)",
                "::onUpdateNotAvailable"
            ],
            "updatePoint": {
                "line": 56,
                "column": 50
            },
            "line": 56,
            "code": "    it('subscribes to \"update-not-available\" event', () => {\n      const spy = jasmine.createSpy('spy');\n      autoUpdateManager.onUpdateNotAvailable(spy);\n      electronAutoUpdater.emit('update-not-available');\n      waitsFor(() => {\n        return spy.callCount === 1;\n      });\n    });",
            "file": "auto-update-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "subscribes to \"update-error\" event",
            "suites": [
                "AutoUpdateManager (renderer)",
                "::onUpdateError"
            ],
            "updatePoint": {
                "line": 66,
                "column": 42
            },
            "line": 66,
            "code": "    it('subscribes to \"update-error\" event', () => {\n      const spy = jasmine.createSpy('spy');\n      autoUpdateManager.onUpdateError(spy);\n      electronAutoUpdater.emit('error', {}, 'an error message');\n      waitsFor(() => spy.callCount === 1);\n      runs(() => expect(autoUpdateManager.getErrorMessage()).toBe('an error message'));\n    });",
            "file": "auto-update-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true on macOS and Windows when in stable",
            "suites": [
                "AutoUpdateManager (renderer)",
                "::platformSupportsUpdates"
            ],
            "updatePoint": {
                "line": 76,
                "column": 56
            },
            "line": 76,
            "code": "    it('returns true on macOS and Windows when in stable', () => {\n      spyOn(autoUpdateManager, 'getState').andCallFake(() => state);\n      spyOn(atom, 'getReleaseChannel').andCallFake(() => releaseChannel);\n      state = 'idle';\n      releaseChannel = 'stable';\n      expect(autoUpdateManager.platformSupportsUpdates()).toBe(true);\n      state = 'idle';\n      releaseChannel = 'dev';\n      expect(autoUpdateManager.platformSupportsUpdates()).toBe(false);\n      state = 'unsupported';\n      releaseChannel = 'stable';\n      expect(autoUpdateManager.platformSupportsUpdates()).toBe(false);\n      state = 'unsupported';\n      releaseChannel = 'dev';\n      expect(autoUpdateManager.platformSupportsUpdates()).toBe(false);\n    });",
            "file": "auto-update-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "unsubscribes from all events",
            "suites": [
                "AutoUpdateManager (renderer)",
                "::destroy"
            ],
            "updatePoint": {
                "line": 94,
                "column": 36
            },
            "line": 94,
            "code": "    it('unsubscribes from all events', () => {\n      const spy = jasmine.createSpy('spy');\n      const doneIndicator = jasmine.createSpy('spy');\n      atom.applicationDelegate.onUpdateNotAvailable(doneIndicator);\n      autoUpdateManager.onDidBeginCheckingForUpdate(spy);\n      autoUpdateManager.onDidBeginDownloadingUpdate(spy);\n      autoUpdateManager.onDidCompleteDownloadingUpdate(spy);\n      autoUpdateManager.onUpdateNotAvailable(spy);\n      autoUpdateManager.destroy();\n      electronAutoUpdater.emit('checking-for-update');\n      electronAutoUpdater.emit('update-available');\n      electronAutoUpdater.emit('update-downloaded', null, null, '1.2.3');\n      electronAutoUpdater.emit('update-not-available');\n      waitsFor(() => {\n        return doneIndicator.callCount === 1;\n      });\n      runs(() => {\n        expect(spy.callCount).toBe(0);\n      });\n    });",
            "file": "auto-update-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "transpiles it using babel",
            "suites": [
                "Babel transpiler support",
                "when a .js file starts with /** @babel */;"
            ],
            "updatePoint": {
                "line": 39,
                "column": 92
            },
            "line": 39,
            "code": "  describe('when a .js file starts with /** @babel */;', () => it('transpiles it using babel', function () {\n    const transpiled = require('./fixtures/babel/babel-comment.js');\n\n    expect(transpiled(3)).toBe(4);\n  }));",
            "file": "babel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "transpiles it using babel",
            "suites": [
                "Babel transpiler support",
                "when a .js file starts with 'use babel';"
            ],
            "updatePoint": {
                "line": 44,
                "column": 90
            },
            "line": 44,
            "code": "  describe(\"when a .js file starts with 'use babel';\", () => it('transpiles it using babel', function () {\n    const transpiled = require('./fixtures/babel/babel-single-quotes.js');\n\n    expect(transpiled(3)).toBe(4);\n  }));",
            "file": "babel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "transpiles it using babel",
            "suites": [
                "Babel transpiler support",
                "when a .js file starts with \"use babel\";"
            ],
            "updatePoint": {
                "line": 49,
                "column": 90
            },
            "line": 49,
            "code": "  describe('when a .js file starts with \"use babel\";', () => it('transpiles it using babel', function () {\n    const transpiled = require('./fixtures/babel/babel-double-quotes.js');\n\n    expect(transpiled(3)).toBe(4);\n  }));",
            "file": "babel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "transpiles it using babel",
            "suites": [
                "Babel transpiler support",
                "when a .js file starts with /* @flow */"
            ],
            "updatePoint": {
                "line": 54,
                "column": 89
            },
            "line": 54,
            "code": "  describe('when a .js file starts with /* @flow */', () => it('transpiles it using babel', function () {\n    const transpiled = require('./fixtures/babel/flow-comment.js');\n\n    expect(transpiled(3)).toBe(4);\n  }));",
            "file": "babel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "transpiles it using babel",
            "suites": [
                "Babel transpiler support",
                "when a .js file starts with // @flow"
            ],
            "updatePoint": {
                "line": 59,
                "column": 86
            },
            "line": 59,
            "code": "  describe('when a .js file starts with // @flow', () => it('transpiles it using babel', function () {\n    const transpiled = require('./fixtures/babel/flow-slash-comment.js');\n\n    expect(transpiled(3)).toBe(4);\n  }));",
            "file": "babel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not transpile it using babel",
            "suites": [
                "Babel transpiler support",
                "when a .js file does not start with 'use babel';"
            ],
            "updatePoint": {
                "line": 65,
                "column": 41
            },
            "line": 65,
            "code": "    it('does not transpile it using babel', function () {\n      spyOn(console, 'error');\n      expect(() => require('./fixtures/babel/invalid.js')).toThrow();\n    });",
            "file": "babel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not try to log to stdout or stderr while parsing the file",
            "suites": [
                "Babel transpiler support",
                "when a .js file does not start with 'use babel';"
            ],
            "updatePoint": {
                "line": 69,
                "column": 70
            },
            "line": 69,
            "code": "    it('does not try to log to stdout or stderr while parsing the file', function () {\n      spyOn(process.stderr, 'write');\n      spyOn(process.stdout, 'write');\n\n      require('./fixtures/babel/babel-double-quotes.js');\n\n      expect(process.stdout.write).not.toHaveBeenCalled();\n      expect(process.stderr.write).not.toHaveBeenCalled();\n    });",
            "file": "babel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "executes the script in a new process",
            "suites": [
                "BufferedNodeProcess"
            ],
            "updatePoint": {
                "line": 7,
                "column": 42
            },
            "line": 7,
            "code": "  it('executes the script in a new process', function () {\n    const exit = jasmine.createSpy('exitCallback');\n    let output = '';\n\n    const stdout = lines => output += lines;\n\n    let error = '';\n\n    const stderr = lines => error += lines;\n\n    const args = ['hi'];\n    const command = path.join(__dirname, 'fixtures', 'script.js');\n    new BufferedNodeProcess({\n      command,\n      args,\n      stdout,\n      stderr,\n      exit\n    });\n    waitsFor(() => exit.callCount === 1);\n    runs(function () {\n      expect(output).toBe('hi');\n      expect(error).toBe('');\n      expect(args).toEqual(['hi']);\n    });\n  });",
            "file": "buffered-node-process-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "suppresses deprecations in the new process",
            "suites": [
                "BufferedNodeProcess"
            ],
            "updatePoint": {
                "line": 33,
                "column": 48
            },
            "line": 33,
            "code": "  it('suppresses deprecations in the new process', function () {\n    const exit = jasmine.createSpy('exitCallback');\n    let output = '';\n\n    const stdout = lines => output += lines;\n\n    let error = '';\n\n    const stderr = lines => error += lines;\n\n    const command = path.join(__dirname, 'fixtures', 'script-with-deprecations.js');\n    new BufferedNodeProcess({\n      command,\n      stdout,\n      stderr,\n      exit\n    });\n    waitsFor(() => exit.callCount === 1);\n    runs(function () {\n      expect(output).toBe('hi');\n      expect(error).toBe('');\n    });\n  });",
            "file": "buffered-node-process-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the error handler and does not throw an exception",
            "suites": [
                "BufferedProcess",
                "when a bad command is specified",
                "when there is an error handler specified",
                "when an error event is emitted by the process"
            ],
            "updatePoint": {
                "line": 19,
                "column": 129
            },
            "line": 19,
            "code": "      describe('when an error event is emitted by the process', () => it('calls the error handler and does not throw an exception', function () {\n        const bufferedProcess = new BufferedProcess({\n          command: 'bad-command-nope1',\n          args: ['nothing'],\n          options: {\n            shell: false\n          }\n        });\n        const errorSpy = jasmine.createSpy().andCallFake(error => error.handle());\n        bufferedProcess.onWillThrowError(errorSpy);\n        waitsFor(() => errorSpy.callCount > 0);\n        runs(function () {\n          expect(window.onerror).not.toHaveBeenCalled();\n          expect(errorSpy).toHaveBeenCalled();\n          expect(errorSpy.mostRecentCall.args[0].error.message).toContain('spawn bad-command-nope1 ENOENT');\n        });\n      }));",
            "file": "buffered-process-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the error handler and does not throw an exception",
            "suites": [
                "BufferedProcess",
                "when a bad command is specified",
                "when there is an error handler specified",
                "when an error is thrown spawning the process"
            ],
            "updatePoint": {
                "line": 36,
                "column": 128
            },
            "line": 36,
            "code": "      describe('when an error is thrown spawning the process', () => it('calls the error handler and does not throw an exception', function () {\n        spyOn(ChildProcess, 'spawn').andCallFake(function () {\n          const error = new Error('Something is really wrong');\n          error.code = 'EAGAIN';\n          throw error;\n        });\n        const bufferedProcess = new BufferedProcess({\n          command: 'ls',\n          args: [],\n          options: {}\n        });\n        const errorSpy = jasmine.createSpy().andCallFake(error => error.handle());\n        bufferedProcess.onWillThrowError(errorSpy);\n        waitsFor(() => errorSpy.callCount > 0);\n        runs(function () {\n          expect(window.onerror).not.toHaveBeenCalled();\n          expect(errorSpy).toHaveBeenCalled();\n          expect(errorSpy.mostRecentCall.args[0].error.message).toContain('Something is really wrong');\n        });\n      }));",
            "file": "buffered-process-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does throw an exception",
            "suites": [
                "BufferedProcess",
                "when a bad command is specified",
                "when there is not an error handler specified"
            ],
            "updatePoint": {
                "line": 57,
                "column": 94
            },
            "line": 57,
            "code": "    describe('when there is not an error handler specified', () => it('does throw an exception', function () {\n      new BufferedProcess({\n        command: 'bad-command-nope2',\n        args: ['nothing'],\n        options: {\n          shell: false\n        }\n      });\n      waitsFor(() => window.onerror.callCount > 0);\n      runs(function () {\n        expect(window.onerror).toHaveBeenCalled();\n        expect(window.onerror.mostRecentCall.args[0]).toContain('Failed to spawn command `bad-command-nope2`');\n        expect(window.onerror.mostRecentCall.args[4].name).toBe('BufferedProcessError');\n      });\n    }));",
            "file": "buffered-process-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesnt start unless start method is called",
            "suites": [
                "BufferedProcess",
                "when autoStart is false"
            ],
            "updatePoint": {
                "line": 73,
                "column": 90
            },
            "line": 73,
            "code": "  describe('when autoStart is false', () => it('doesnt start unless start method is called', function () {\n    let stdout = '';\n    let stderr = '';\n    const exitCallback = jasmine.createSpy('exit callback');\n    const apmProcess = new BufferedProcess({\n      autoStart: false,\n      command: atom.packages.getApmPath(),\n      args: ['-h'],\n      options: {},\n\n      stdout(lines) {\n        stdout += lines;\n      },\n\n      stderr(lines) {\n        stderr += lines;\n      },\n\n      exit: exitCallback\n    });\n    expect(apmProcess.started).not.toBe(true);\n    apmProcess.start();\n    expect(apmProcess.started).toBe(true);\n    waitsFor(() => exitCallback.callCount === 1);\n    runs(function () {\n      expect(stderr).toContain('apm - Atom Package Manager');\n      expect(stdout).toEqual('');\n    });\n  }));",
            "file": "buffered-process-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the specified stdout, stderr, and exit callbacks",
            "suites": [
                "BufferedProcess",
                "when autoStart is false"
            ],
            "updatePoint": {
                "line": 102,
                "column": 60
            },
            "line": 102,
            "code": "  it('calls the specified stdout, stderr, and exit callbacks', function () {\n    let stdout = '';\n    let stderr = '';\n    const exitCallback = jasmine.createSpy('exit callback');\n    new BufferedProcess({\n      command: atom.packages.getApmPath(),\n      args: ['-h'],\n      options: {},\n\n      stdout(lines) {\n        stdout += lines;\n      },\n\n      stderr(lines) {\n        stderr += lines;\n      },\n\n      exit: exitCallback\n    });\n    waitsFor(() => exitCallback.callCount === 1);\n    runs(function () {\n      expect(stderr).toContain('apm - Atom Package Manager');\n      expect(stdout).toEqual('');\n    });\n  });",
            "file": "buffered-process-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the specified stdout callback with whole lines",
            "suites": [
                "BufferedProcess",
                "when autoStart is false"
            ],
            "updatePoint": {
                "line": 127,
                "column": 58
            },
            "line": 127,
            "code": "  it('calls the specified stdout callback with whole lines', function () {\n    const exitCallback = jasmine.createSpy('exit callback');\n\n    const loremPath = require.resolve('./fixtures/lorem.txt');\n\n    const content = fs.readFileSync(loremPath).toString();\n    let stdout = '';\n    let allLinesEndWithNewline = true;\n    new BufferedProcess({\n      command: process.platform === 'win32' ? 'type' : 'cat',\n      args: [loremPath],\n      options: {},\n\n      stdout(lines) {\n        const endsWithNewline = lines.charAt(lines.length - 1) === '\\n';\n\n        if (!endsWithNewline) {\n          allLinesEndWithNewline = false;\n        }\n\n        stdout += lines;\n      },\n\n      exit: exitCallback\n    });\n    waitsFor(() => exitCallback.callCount === 1);\n    runs(function () {\n      expect(allLinesEndWithNewline).toBe(true);\n      expect(stdout).toBe(content);\n    });\n  });",
            "file": "buffered-process-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't quote arguments of the form /root,C...",
            "suites": [
                "BufferedProcess",
                "on Windows",
                "when the explorer command is spawned on Windows"
            ],
            "updatePoint": {
                "line": 171,
                "column": 120
            },
            "line": 171,
            "code": "    describe('when the explorer command is spawned on Windows', () => it(\"doesn't quote arguments of the form /root,C...\", function () {\n      new BufferedProcess({\n        command: 'explorer.exe',\n        args: ['/root,C:\\\\foo']\n      });\n      expect(ChildProcess.spawn.argsForCall[0][1][3]).toBe('\"explorer.exe /root,C:\\\\foo\"');\n    }));",
            "file": "buffered-process-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "spawns the command using a cmd.exe wrapper when options.shell is undefined",
            "suites": [
                "BufferedProcess",
                "on Windows",
                "when the explorer command is spawned on Windows"
            ],
            "updatePoint": {
                "line": 178,
                "column": 82
            },
            "line": 178,
            "code": "    it('spawns the command using a cmd.exe wrapper when options.shell is undefined', function () {\n      new BufferedProcess({\n        command: 'dir'\n      });\n      expect(path.basename(ChildProcess.spawn.argsForCall[0][0])).toBe('cmd.exe');\n      expect(ChildProcess.spawn.argsForCall[0][1][0]).toBe('/s');\n      expect(ChildProcess.spawn.argsForCall[0][1][1]).toBe('/d');\n      expect(ChildProcess.spawn.argsForCall[0][1][2]).toBe('/c');\n      expect(ChildProcess.spawn.argsForCall[0][1][3]).toBe('\"dir\"');\n    });",
            "file": "buffered-process-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "writes and reads text to/from the native clipboard",
            "suites": [
                "Clipboard",
                "write(text, metadata) and read()"
            ],
            "updatePoint": {
                "line": 3,
                "column": 58
            },
            "line": 3,
            "code": "    it('writes and reads text to/from the native clipboard', () => {\n      expect(atom.clipboard.read()).toBe('initial clipboard content');\n      atom.clipboard.write('next');\n      expect(atom.clipboard.read()).toBe('next');\n    });",
            "file": "clipboard-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns metadata if the item on the native clipboard matches the last written item",
            "suites": [
                "Clipboard",
                "write(text, metadata) and read()"
            ],
            "updatePoint": {
                "line": 8,
                "column": 90
            },
            "line": 8,
            "code": "    it('returns metadata if the item on the native clipboard matches the last written item', () => {\n      atom.clipboard.write('next', {\n        meta: 'data'\n      });\n      expect(atom.clipboard.read()).toBe('next');\n      expect(atom.clipboard.readWithMetadata().text).toBe('next');\n      expect(atom.clipboard.readWithMetadata().metadata).toEqual({\n        meta: 'data'\n      });\n    });",
            "file": "clipboard-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "converts line endings to the OS's native line endings on ",
            "suites": [
                "Clipboard",
                "line endings"
            ],
            "updatePoint": {
                "line": 24,
                "column": 78
            },
            "line": 24,
            "code": "      it(`converts line endings to the OS's native line endings on ${platform}`, () => {\n        Object.defineProperty(process, 'platform', {\n          value: platform\n        });\n        atom.clipboard.write('next\\ndone\\r\\n\\n', {\n          meta: 'data'\n        });\n        expect(atom.clipboard.readWithMetadata()).toEqual({\n          text: `next${eol}done${eol}${eol}`,\n          metadata: {\n            meta: 'data'\n          }\n        });\n        Object.defineProperty(process, 'platform', {\n          value: originalPlatform\n        });\n      });",
            "file": "clipboard-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shows an error dialog when installing commands interactively fails",
            "suites": [
                "CommandInstaller on #darwin"
            ],
            "updatePoint": {
                "line": 28,
                "column": 72
            },
            "line": 28,
            "code": "  it('shows an error dialog when installing commands interactively fails', () => {\n    const appDelegate = jasmine.createSpyObj('appDelegate', ['confirm']);\n    installer = new CommandInstaller(appDelegate);\n    installer.initialize('2.0.2');\n    spyOn(installer, 'installAtomCommand').andCallFake((__, callback) => callback(new Error('an error')));\n    installer.installShellCommandsInteractively();\n    expect(appDelegate.confirm.mostRecentCall.args[0]).toEqual({\n      message: 'Failed to install shell commands',\n      detail: 'an error'\n    });\n    appDelegate.confirm.reset();\n    installer.installAtomCommand.andCallFake((__, callback) => callback());\n    spyOn(installer, 'installApmCommand').andCallFake((__, callback) => callback(new Error('another error')));\n    installer.installShellCommandsInteractively();\n    expect(appDelegate.confirm.mostRecentCall.args[0]).toEqual({\n      message: 'Failed to install shell commands',\n      detail: 'another error'\n    });\n  });",
            "file": "command-installer-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shows a success dialog when installing commands interactively succeeds",
            "suites": [
                "CommandInstaller on #darwin"
            ],
            "updatePoint": {
                "line": 47,
                "column": 76
            },
            "line": 47,
            "code": "  it('shows a success dialog when installing commands interactively succeeds', () => {\n    const appDelegate = jasmine.createSpyObj('appDelegate', ['confirm']);\n    installer = new CommandInstaller(appDelegate);\n    installer.initialize('2.0.2');\n    spyOn(installer, 'installAtomCommand').andCallFake((__, callback) => callback(undefined, 'atom'));\n    spyOn(installer, 'installApmCommand').andCallFake((__, callback) => callback(undefined, 'apm'));\n    installer.installShellCommandsInteractively();\n    expect(appDelegate.confirm.mostRecentCall.args[0]).toEqual({\n      message: 'Commands installed.',\n      detail: 'The shell commands `atom` and `apm` are installed.'\n    });\n  });",
            "file": "command-installer-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "symlinks the atom command as 'atom'",
            "suites": [
                "CommandInstaller on #darwin",
                "when using a stable version of atom"
            ],
            "updatePoint": {
                "line": 64,
                "column": 43
            },
            "line": 64,
            "code": "    it(\"symlinks the atom command as 'atom'\", () => {\n      const installedAtomPath = path.join(installationPath, 'atom');\n      expect(fs.isFileSync(installedAtomPath)).toBeFalsy();\n      waitsFor(done => {\n        installer.installAtomCommand(false, error => {\n          expect(error).toBeNull();\n          expect(fs.realpathSync(installedAtomPath)).toBe(fs.realpathSync(atomBinPath));\n          expect(fs.isExecutableSync(installedAtomPath)).toBe(true);\n          expect(fs.isFileSync(path.join(installationPath, 'atom-beta'))).toBe(false);\n          done();\n        });\n      });\n    });",
            "file": "command-installer-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "symlinks the apm command as 'apm'",
            "suites": [
                "CommandInstaller on #darwin",
                "when using a stable version of atom"
            ],
            "updatePoint": {
                "line": 77,
                "column": 41
            },
            "line": 77,
            "code": "    it(\"symlinks the apm command as 'apm'\", () => {\n      const installedApmPath = path.join(installationPath, 'apm');\n      expect(fs.isFileSync(installedApmPath)).toBeFalsy();\n      waitsFor(done => {\n        installer.installApmCommand(false, error => {\n          expect(error).toBeNull();\n          expect(fs.realpathSync(installedApmPath)).toBe(fs.realpathSync(apmBinPath));\n          expect(fs.isExecutableSync(installedApmPath)).toBeTruthy();\n          expect(fs.isFileSync(path.join(installationPath, 'apm-beta'))).toBe(false);\n          done();\n        });\n      });\n    });",
            "file": "command-installer-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "symlinks the atom command as 'atom-beta'",
            "suites": [
                "CommandInstaller on #darwin",
                "when using a beta version of atom"
            ],
            "updatePoint": {
                "line": 96,
                "column": 48
            },
            "line": 96,
            "code": "    it(\"symlinks the atom command as 'atom-beta'\", () => {\n      const installedAtomPath = path.join(installationPath, 'atom-beta');\n      expect(fs.isFileSync(installedAtomPath)).toBeFalsy();\n      waitsFor(done => {\n        installer.installAtomCommand(false, error => {\n          expect(error).toBeNull();\n          expect(fs.realpathSync(installedAtomPath)).toBe(fs.realpathSync(atomBinPath));\n          expect(fs.isExecutableSync(installedAtomPath)).toBe(true);\n          expect(fs.isFileSync(path.join(installationPath, 'atom'))).toBe(false);\n          done();\n        });\n      });\n    });",
            "file": "command-installer-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "symlinks the apm command as 'apm-beta'",
            "suites": [
                "CommandInstaller on #darwin",
                "when using a beta version of atom"
            ],
            "updatePoint": {
                "line": 109,
                "column": 46
            },
            "line": 109,
            "code": "    it(\"symlinks the apm command as 'apm-beta'\", () => {\n      const installedApmPath = path.join(installationPath, 'apm-beta');\n      expect(fs.isFileSync(installedApmPath)).toBeFalsy();\n      waitsFor(done => {\n        installer.installApmCommand(false, error => {\n          expect(error).toBeNull();\n          expect(fs.realpathSync(installedApmPath)).toBe(fs.realpathSync(apmBinPath));\n          expect(fs.isExecutableSync(installedApmPath)).toBeTruthy();\n          expect(fs.isFileSync(path.join(installationPath, 'apm'))).toBe(false);\n          done();\n        });\n      });\n    });",
            "file": "command-installer-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "symlinks the atom command as 'atom-nightly'",
            "suites": [
                "CommandInstaller on #darwin",
                "when using a nightly version of atom"
            ],
            "updatePoint": {
                "line": 128,
                "column": 51
            },
            "line": 128,
            "code": "    it(\"symlinks the atom command as 'atom-nightly'\", () => {\n      const installedAtomPath = path.join(installationPath, 'atom-nightly');\n      expect(fs.isFileSync(installedAtomPath)).toBeFalsy();\n      waitsFor(done => {\n        installer.installAtomCommand(false, error => {\n          expect(error).toBeNull();\n          expect(fs.realpathSync(installedAtomPath)).toBe(fs.realpathSync(atomBinPath));\n          expect(fs.isExecutableSync(installedAtomPath)).toBe(true);\n          expect(fs.isFileSync(path.join(installationPath, 'atom'))).toBe(false);\n          done();\n        });\n      });\n    });",
            "file": "command-installer-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "symlinks the apm command as 'apm-nightly'",
            "suites": [
                "CommandInstaller on #darwin",
                "when using a nightly version of atom"
            ],
            "updatePoint": {
                "line": 141,
                "column": 49
            },
            "line": 141,
            "code": "    it(\"symlinks the apm command as 'apm-nightly'\", () => {\n      const installedApmPath = path.join(installationPath, 'apm-nightly');\n      expect(fs.isFileSync(installedApmPath)).toBeFalsy();\n      waitsFor(done => {\n        installer.installApmCommand(false, error => {\n          expect(error).toBeNull();\n          expect(fs.realpathSync(installedApmPath)).toBe(fs.realpathSync(apmBinPath));\n          expect(fs.isExecutableSync(installedApmPath)).toBeTruthy();\n          expect(fs.isFileSync(path.join(installationPath, 'nightly'))).toBe(false);\n          done();\n        });\n      });\n    });",
            "file": "command-installer-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes callbacks with selectors matching the target",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 22,
                "column": 60
            },
            "line": 22,
            "code": "    it('invokes callbacks with selectors matching the target', () => {\n      let called = false;\n      registry.add('.grandchild', 'command', function (event) {\n        expect(this).toBe(grandchild);\n        expect(event.type).toBe('command');\n        expect(event.eventPhase).toBe(Event.BUBBLING_PHASE);\n        expect(event.target).toBe(grandchild);\n        expect(event.currentTarget).toBe(grandchild);\n        called = true;\n      });\n      grandchild.dispatchEvent(new CustomEvent('command', {\n        bubbles: true\n      }));\n      expect(called).toBe(true);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes callbacks with selectors matching ancestors of the target",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 37,
                "column": 73
            },
            "line": 37,
            "code": "    it('invokes callbacks with selectors matching ancestors of the target', () => {\n      const calls = [];\n      registry.add('.child', 'command', function (event) {\n        expect(this).toBe(child);\n        expect(event.target).toBe(grandchild);\n        expect(event.currentTarget).toBe(child);\n        calls.push('child');\n      });\n      registry.add('.parent', 'command', function (event) {\n        expect(this).toBe(parent);\n        expect(event.target).toBe(grandchild);\n        expect(event.currentTarget).toBe(parent);\n        calls.push('parent');\n      });\n      grandchild.dispatchEvent(new CustomEvent('command', {\n        bubbles: true\n      }));\n      expect(calls).toEqual(['child', 'parent']);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes inline listeners prior to listeners applied via selectors",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 56,
                "column": 73
            },
            "line": 56,
            "code": "    it('invokes inline listeners prior to listeners applied via selectors', () => {\n      const calls = [];\n      registry.add('.grandchild', 'command', () => calls.push('grandchild'));\n      registry.add(child, 'command', () => calls.push('child-inline'));\n      registry.add('.child', 'command', () => calls.push('child'));\n      registry.add('.parent', 'command', () => calls.push('parent'));\n      grandchild.dispatchEvent(new CustomEvent('command', {\n        bubbles: true\n      }));\n      expect(calls).toEqual(['grandchild', 'child-inline', 'child', 'parent']);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "orders multiple matching listeners for an element by selector specificity",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 67,
                "column": 81
            },
            "line": 67,
            "code": "    it('orders multiple matching listeners for an element by selector specificity', () => {\n      child.classList.add('foo', 'bar');\n      const calls = [];\n      registry.add('.foo.bar', 'command', () => calls.push('.foo.bar'));\n      registry.add('.foo', 'command', () => calls.push('.foo'));\n      registry.add('.bar', 'command', () => calls.push('.bar')); // specificity ties favor commands added later, like CSS\n\n      grandchild.dispatchEvent(new CustomEvent('command', {\n        bubbles: true\n      }));\n      expect(calls).toEqual(['.foo.bar', '.bar', '.foo']);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "orders inline listeners by reverse registration order",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 79,
                "column": 61
            },
            "line": 79,
            "code": "    it('orders inline listeners by reverse registration order', () => {\n      const calls = [];\n      registry.add(child, 'command', () => calls.push('child1'));\n      registry.add(child, 'command', () => calls.push('child2'));\n      child.dispatchEvent(new CustomEvent('command', {\n        bubbles: true\n      }));\n      expect(calls).toEqual(['child2', 'child1']);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stops bubbling through ancestors when .stopPropagation() is called on the event",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 88,
                "column": 87
            },
            "line": 88,
            "code": "    it('stops bubbling through ancestors when .stopPropagation() is called on the event', () => {\n      const calls = [];\n      registry.add('.parent', 'command', () => calls.push('parent'));\n      registry.add('.child', 'command', () => calls.push('child-2'));\n      registry.add('.child', 'command', event => {\n        calls.push('child-1');\n        event.stopPropagation();\n      });\n      const dispatchedEvent = new CustomEvent('command', {\n        bubbles: true\n      });\n      spyOn(dispatchedEvent, 'stopPropagation');\n      grandchild.dispatchEvent(dispatchedEvent);\n      expect(calls).toEqual(['child-1', 'child-2']);\n      expect(dispatchedEvent.stopPropagation).toHaveBeenCalled();\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stops invoking callbacks when .stopImmediatePropagation() is called on the event",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 104,
                "column": 88
            },
            "line": 104,
            "code": "    it('stops invoking callbacks when .stopImmediatePropagation() is called on the event', () => {\n      const calls = [];\n      registry.add('.parent', 'command', () => calls.push('parent'));\n      registry.add('.child', 'command', () => calls.push('child-2'));\n      registry.add('.child', 'command', event => {\n        calls.push('child-1');\n        event.stopImmediatePropagation();\n      });\n      const dispatchedEvent = new CustomEvent('command', {\n        bubbles: true\n      });\n      spyOn(dispatchedEvent, 'stopImmediatePropagation');\n      grandchild.dispatchEvent(dispatchedEvent);\n      expect(calls).toEqual(['child-1']);\n      expect(dispatchedEvent.stopImmediatePropagation).toHaveBeenCalled();\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "forwards .preventDefault() calls from the synthetic event to the original",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 120,
                "column": 81
            },
            "line": 120,
            "code": "    it('forwards .preventDefault() calls from the synthetic event to the original', () => {\n      registry.add('.child', 'command', event => event.preventDefault());\n      const dispatchedEvent = new CustomEvent('command', {\n        bubbles: true\n      });\n      spyOn(dispatchedEvent, 'preventDefault');\n      grandchild.dispatchEvent(dispatchedEvent);\n      expect(dispatchedEvent.preventDefault).toHaveBeenCalled();\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "forwards .abortKeyBinding() calls from the synthetic event to the original",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 129,
                "column": 82
            },
            "line": 129,
            "code": "    it('forwards .abortKeyBinding() calls from the synthetic event to the original', () => {\n      registry.add('.child', 'command', event => event.abortKeyBinding());\n      const dispatchedEvent = new CustomEvent('command', {\n        bubbles: true\n      });\n      dispatchedEvent.abortKeyBinding = jasmine.createSpy('abortKeyBinding');\n      grandchild.dispatchEvent(dispatchedEvent);\n      expect(dispatchedEvent.abortKeyBinding).toHaveBeenCalled();\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "copies non-standard properties from the original event to the synthetic event",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 138,
                "column": 85
            },
            "line": 138,
            "code": "    it('copies non-standard properties from the original event to the synthetic event', () => {\n      let syntheticEvent = null;\n      registry.add('.child', 'command', event => syntheticEvent = event);\n      const dispatchedEvent = new CustomEvent('command', {\n        bubbles: true\n      });\n      dispatchedEvent.nonStandardProperty = 'testing';\n      grandchild.dispatchEvent(dispatchedEvent);\n      expect(syntheticEvent.nonStandardProperty).toBe('testing');\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows listeners to be removed via a disposable returned by ::add",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 148,
                "column": 73
            },
            "line": 148,
            "code": "    it('allows listeners to be removed via a disposable returned by ::add', () => {\n      let calls = [];\n      const disposable1 = registry.add('.parent', 'command', () => calls.push('parent'));\n      const disposable2 = registry.add('.child', 'command', () => calls.push('child'));\n      disposable1.dispose();\n      grandchild.dispatchEvent(new CustomEvent('command', {\n        bubbles: true\n      }));\n      expect(calls).toEqual(['child']);\n      calls = [];\n      disposable2.dispose();\n      grandchild.dispatchEvent(new CustomEvent('command', {\n        bubbles: true\n      }));\n      expect(calls).toEqual([]);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows multiple commands to be registered under one selector when called with an object",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 164,
                "column": 95
            },
            "line": 164,
            "code": "    it('allows multiple commands to be registered under one selector when called with an object', () => {\n      let calls = [];\n      const disposable = registry.add('.child', {\n        'command-1'() {\n          calls.push('command-1');\n        },\n\n        'command-2'() {\n          calls.push('command-2');\n        }\n\n      });\n      grandchild.dispatchEvent(new CustomEvent('command-1', {\n        bubbles: true\n      }));\n      grandchild.dispatchEvent(new CustomEvent('command-2', {\n        bubbles: true\n      }));\n      expect(calls).toEqual(['command-1', 'command-2']);\n      calls = [];\n      disposable.dispose();\n      grandchild.dispatchEvent(new CustomEvent('command-1', {\n        bubbles: true\n      }));\n      grandchild.dispatchEvent(new CustomEvent('command-2', {\n        bubbles: true\n      }));\n      expect(calls).toEqual([]);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes callbacks registered with ::onWillDispatch and ::onDidDispatch",
            "suites": [
                "CommandRegistry",
                "when a command event is dispatched on an element"
            ],
            "updatePoint": {
                "line": 193,
                "column": 78
            },
            "line": 193,
            "code": "    it('invokes callbacks registered with ::onWillDispatch and ::onDidDispatch', () => {\n      const sequence = [];\n      registry.onDidDispatch(event => sequence.push(['onDidDispatch', event]));\n      registry.add('.grandchild', 'command', event => sequence.push(['listener', event]));\n      registry.onWillDispatch(event => sequence.push(['onWillDispatch', event]));\n      grandchild.dispatchEvent(new CustomEvent('command', {\n        bubbles: true\n      }));\n      expect(sequence[0][0]).toBe('onWillDispatch');\n      expect(sequence[1][0]).toBe('listener');\n      expect(sequence[2][0]).toBe('onDidDispatch');\n      expect(sequence[0][1] === sequence[1][1] && sequence[1][1] === sequence[2][1]).toBe(true);\n      expect(sequence[0][1].constructor).toBe(CustomEvent);\n      expect(sequence[0][1].target).toBe(grandchild);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error when called with an invalid selector",
            "suites": [
                "CommandRegistry",
                "::add(selector, commandName, callback)"
            ],
            "updatePoint": {
                "line": 210,
                "column": 60
            },
            "line": 210,
            "code": "    it('throws an error when called with an invalid selector', () => {\n      const badSelector = '<>';\n      let addError = null;\n\n      try {\n        registry.add(badSelector, 'foo:bar', () => {});\n      } catch (error) {\n        addError = error;\n      }\n\n      expect(addError.message).toContain(badSelector);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error when called with a null callback and selector target",
            "suites": [
                "CommandRegistry",
                "::add(selector, commandName, callback)"
            ],
            "updatePoint": {
                "line": 222,
                "column": 76
            },
            "line": 222,
            "code": "    it('throws an error when called with a null callback and selector target', () => {\n      const badCallback = null;\n      expect(() => {\n        registry.add('.selector', 'foo:bar', badCallback);\n      }).toThrow(new Error('Cannot register a command with a null listener.'));\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error when called with a null callback and object target",
            "suites": [
                "CommandRegistry",
                "::add(selector, commandName, callback)"
            ],
            "updatePoint": {
                "line": 228,
                "column": 74
            },
            "line": 228,
            "code": "    it('throws an error when called with a null callback and object target', () => {\n      const badCallback = null;\n      expect(() => {\n        registry.add(document.body, 'foo:bar', badCallback);\n      }).toThrow(new Error('Cannot register a command with a null listener.'));\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error when called with an object listener without a didDispatch method",
            "suites": [
                "CommandRegistry",
                "::add(selector, commandName, callback)"
            ],
            "updatePoint": {
                "line": 234,
                "column": 88
            },
            "line": 234,
            "code": "    it('throws an error when called with an object listener without a didDispatch method', () => {\n      const badListener = {\n        title: 'a listener without a didDispatch callback',\n        description: 'this should throw an error'\n      };\n      expect(() => {\n        registry.add(document.body, 'foo:bar', badListener);\n      }).toThrow(new Error('Listener must be a callback function or an object with a didDispatch method.'));\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns command descriptors that can be invoked on the target or its ancestors",
            "suites": [
                "CommandRegistry",
                "::findCommands({target})"
            ],
            "updatePoint": {
                "line": 245,
                "column": 86
            },
            "line": 245,
            "code": "    it('returns command descriptors that can be invoked on the target or its ancestors', () => {\n      registry.add('.parent', 'namespace:command-1', () => {});\n      registry.add('.child', 'namespace:command-2', () => {});\n      registry.add('.grandchild', 'namespace:command-3', () => {});\n      registry.add('.grandchild.no-match', 'namespace:command-4', () => {});\n      registry.add(grandchild, 'namespace:inline-command-1', () => {});\n      registry.add(child, 'namespace:inline-command-2', () => {});\n      const commands = registry.findCommands({\n        target: grandchild\n      });\n\n      const nonJqueryCommands = _.reject(commands, cmd => cmd.jQuery);\n\n      expect(nonJqueryCommands).toEqual([{\n        name: 'namespace:inline-command-1',\n        displayName: 'Namespace: Inline Command 1'\n      }, {\n        name: 'namespace:command-3',\n        displayName: 'Namespace: Command 3'\n      }, {\n        name: 'namespace:inline-command-2',\n        displayName: 'Namespace: Inline Command 2'\n      }, {\n        name: 'namespace:command-2',\n        displayName: 'Namespace: Command 2'\n      }, {\n        name: 'namespace:command-1',\n        displayName: 'Namespace: Command 1'\n      }]);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns command descriptors with arbitrary metadata if set in a listener object",
            "suites": [
                "CommandRegistry",
                "::findCommands({target})"
            ],
            "updatePoint": {
                "line": 275,
                "column": 87
            },
            "line": 275,
            "code": "    it('returns command descriptors with arbitrary metadata if set in a listener object', () => {\n      registry.add('.grandchild', 'namespace:command-1', () => {});\n      registry.add('.grandchild', 'namespace:command-2', {\n        displayName: 'Custom Command 2',\n        metadata: {\n          some: 'other',\n          object: 'data'\n        },\n\n        didDispatch() {}\n\n      });\n      registry.add('.grandchild', 'namespace:command-3', {\n        name: 'some:other:incorrect:commandname',\n        displayName: 'Custom Command 3',\n        metadata: {\n          some: 'other',\n          object: 'data'\n        },\n\n        didDispatch() {}\n\n      });\n      const commands = registry.findCommands({\n        target: grandchild\n      });\n      expect(commands).toEqual([{\n        displayName: 'Namespace: Command 1',\n        name: 'namespace:command-1'\n      }, {\n        displayName: 'Custom Command 2',\n        metadata: {\n          some: 'other',\n          object: 'data'\n        },\n        name: 'namespace:command-2'\n      }, {\n        displayName: 'Custom Command 3',\n        metadata: {\n          some: 'other',\n          object: 'data'\n        },\n        name: 'namespace:command-3'\n      }]);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns command descriptors with arbitrary metadata if set on a listener function",
            "suites": [
                "CommandRegistry",
                "::findCommands({target})"
            ],
            "updatePoint": {
                "line": 320,
                "column": 89
            },
            "line": 320,
            "code": "    it('returns command descriptors with arbitrary metadata if set on a listener function', () => {\n      function listener() {}\n\n      listener.displayName = 'Custom Command 2';\n      listener.metadata = {\n        some: 'other',\n        object: 'data'\n      };\n      registry.add('.grandchild', 'namespace:command-2', listener);\n      const commands = registry.findCommands({\n        target: grandchild\n      });\n      expect(commands).toEqual([{\n        displayName: 'Custom Command 2',\n        metadata: {\n          some: 'other',\n          object: 'data'\n        },\n        name: 'namespace:command-2'\n      }]);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "simulates invocation of the given command ",
            "suites": [
                "CommandRegistry",
                "::dispatch(target, commandName)"
            ],
            "updatePoint": {
                "line": 343,
                "column": 50
            },
            "line": 343,
            "code": "    it('simulates invocation of the given command ', () => {\n      let called = false;\n      registry.add('.grandchild', 'command', function (event) {\n        expect(this).toBe(grandchild);\n        expect(event.type).toBe('command');\n        expect(event.eventPhase).toBe(Event.BUBBLING_PHASE);\n        expect(event.target).toBe(grandchild);\n        expect(event.currentTarget).toBe(grandchild);\n        called = true;\n      });\n      registry.dispatch(grandchild, 'command');\n      expect(called).toBe(true);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a promise if any listeners matched the command",
            "suites": [
                "CommandRegistry",
                "::dispatch(target, commandName)"
            ],
            "updatePoint": {
                "line": 356,
                "column": 62
            },
            "line": 356,
            "code": "    it('returns a promise if any listeners matched the command', () => {\n      registry.add('.grandchild', 'command', () => {});\n      expect(registry.dispatch(grandchild, 'command').constructor.name).toBe('Promise');\n      expect(registry.dispatch(grandchild, 'bogus')).toBe(null);\n      expect(registry.dispatch(parent, 'command')).toBe(null);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a promise that resolves when the listeners resolve",
            "suites": [
                "CommandRegistry",
                "::dispatch(target, commandName)"
            ],
            "updatePoint": {
                "line": 362,
                "column": 66
            },
            "line": 362,
            "code": "    it('returns a promise that resolves when the listeners resolve', async () => {\n      jasmine.useRealClock();\n      registry.add('.grandchild', 'command', () => 1);\n      registry.add('.grandchild', 'command', () => Promise.resolve(2));\n      registry.add('.grandchild', 'command', () => new Promise(resolve => {\n        setTimeout(() => {\n          resolve(3);\n        }, 1);\n      }));\n      const values = await registry.dispatch(grandchild, 'command');\n      expect(values).toEqual([3, 2, 1]);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a promise that rejects when a listener is rejected",
            "suites": [
                "CommandRegistry",
                "::dispatch(target, commandName)"
            ],
            "updatePoint": {
                "line": 374,
                "column": 66
            },
            "line": 374,
            "code": "    it('returns a promise that rejects when a listener is rejected', async () => {\n      jasmine.useRealClock();\n      registry.add('.grandchild', 'command', () => 1);\n      registry.add('.grandchild', 'command', () => Promise.resolve(2));\n      registry.add('.grandchild', 'command', () => new Promise((resolve, reject) => {\n        setTimeout(() => {\n          reject(3); // eslint-disable-line prefer-promise-reject-errors\n        }, 1);\n      }));\n      let value;\n\n      try {\n        value = await registry.dispatch(grandchild, 'command');\n      } catch (err) {\n        value = err;\n      }\n\n      expect(value).toBe(3);\n    });",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes all command handlers except for those in the snapshot",
            "suites": [
                "CommandRegistry",
                "::getSnapshot and ::restoreSnapshot"
            ],
            "updatePoint": {
                "line": 394,
                "column": 121
            },
            "line": 394,
            "code": "  describe('::getSnapshot and ::restoreSnapshot', () => it('removes all command handlers except for those in the snapshot', () => {\n    registry.add('.parent', 'namespace:command-1', () => {});\n    registry.add('.child', 'namespace:command-2', () => {});\n    const snapshot = registry.getSnapshot();\n    registry.add('.grandchild', 'namespace:command-3', () => {});\n    expect(registry.findCommands({\n      target: grandchild\n    }).slice(0, 3)).toEqual([{\n      name: 'namespace:command-3',\n      displayName: 'Namespace: Command 3'\n    }, {\n      name: 'namespace:command-2',\n      displayName: 'Namespace: Command 2'\n    }, {\n      name: 'namespace:command-1',\n      displayName: 'Namespace: Command 1'\n    }]);\n    registry.restoreSnapshot(snapshot);\n    expect(registry.findCommands({\n      target: grandchild\n    }).slice(0, 2)).toEqual([{\n      name: 'namespace:command-2',\n      displayName: 'Namespace: Command 2'\n    }, {\n      name: 'namespace:command-1',\n      displayName: 'Namespace: Command 1'\n    }]);\n    registry.add('.grandchild', 'namespace:command-3', () => {});\n    registry.restoreSnapshot(snapshot);\n    expect(registry.findCommands({\n      target: grandchild\n    }).slice(0, 2)).toEqual([{\n      name: 'namespace:command-2',\n      displayName: 'Namespace: Command 2'\n    }, {\n      name: 'namespace:command-1',\n      displayName: 'Namespace: Command 1'\n    }]);\n  }));",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds event listeners for any previously-added commands",
            "suites": [
                "CommandRegistry",
                "::attach(rootNode)"
            ],
            "updatePoint": {
                "line": 433,
                "column": 97
            },
            "line": 433,
            "code": "  describe('::attach(rootNode)', () => it('adds event listeners for any previously-added commands', () => {\n    const registry2 = new CommandRegistry();\n    const commandSpy = jasmine.createSpy('command-callback');\n    registry2.add('.grandchild', 'command-1', commandSpy);\n    grandchild.dispatchEvent(new CustomEvent('command-1', {\n      bubbles: true\n    }));\n    expect(commandSpy).not.toHaveBeenCalled();\n    registry2.attach(parent);\n    grandchild.dispatchEvent(new CustomEvent('command-1', {\n      bubbles: true\n    }));\n    expect(commandSpy).toHaveBeenCalled();\n  }));",
            "file": "command-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns an empty object from .get()",
            "suites": [
                "ConfigFile",
                "when the file does not exist"
            ],
            "updatePoint": {
                "line": 22,
                "column": 43
            },
            "line": 22,
            "code": "    it('returns an empty object from .get()', async () => {\n      configFile = new ConfigFile(filePath);\n      subscription = await configFile.watch();\n      expect(configFile.get()).toEqual({});\n    });",
            "file": "config-file-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns an empty object from .get()",
            "suites": [
                "ConfigFile",
                "when the file is empty"
            ],
            "updatePoint": {
                "line": 29,
                "column": 43
            },
            "line": 29,
            "code": "    it('returns an empty object from .get()', async () => {\n      writeFileSync(filePath, '');\n      configFile = new ConfigFile(filePath);\n      subscription = await configFile.watch();\n      expect(configFile.get()).toEqual({});\n    });",
            "file": "config-file-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies onDidChange observers with the data",
            "suites": [
                "ConfigFile",
                "when the file is updated with valid CSON"
            ],
            "updatePoint": {
                "line": 37,
                "column": 52
            },
            "line": 37,
            "code": "    it('notifies onDidChange observers with the data', async () => {\n      configFile = new ConfigFile(filePath);\n      subscription = await configFile.watch();\n      const event = new Promise(resolve => configFile.onDidChange(resolve));\n      writeFileSync(filePath, dedent`\n        '*':\n          foo: 'bar'\n\n        'javascript':\n          foo: 'baz'\n      `);\n      expect(await event).toEqual({\n        '*': {\n          foo: 'bar'\n        },\n        javascript: {\n          foo: 'baz'\n        }\n      });\n      expect(configFile.get()).toEqual({\n        '*': {\n          foo: 'bar'\n        },\n        javascript: {\n          foo: 'baz'\n        }\n      });\n    });",
            "file": "config-file-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies onDidError observers",
            "suites": [
                "ConfigFile",
                "when the file is updated with invalid CSON"
            ],
            "updatePoint": {
                "line": 67,
                "column": 37
            },
            "line": 67,
            "code": "    it('notifies onDidError observers', async () => {\n      configFile = new ConfigFile(filePath);\n      subscription = await configFile.watch();\n      const message = new Promise(resolve => configFile.onDidError(resolve));\n      writeFileSync(filePath, dedent`\n        um what?\n      `, 2);\n      expect(await message).toContain('Failed to load `the-config.cson`');\n      const event = new Promise(resolve => configFile.onDidChange(resolve));\n      writeFileSync(filePath, dedent`\n        '*':\n          foo: 'bar'\n\n        'javascript':\n          foo: 'baz'\n      `, 4);\n      expect(await event).toEqual({\n        '*': {\n          foo: 'bar'\n        },\n        javascript: {\n          foo: 'baz'\n        }\n      });\n    });",
            "file": "config-file-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns an existing ConfigFile",
            "suites": [
                "ConfigFile",
                "ConfigFile.at()"
            ],
            "updatePoint": {
                "line": 100,
                "column": 38
            },
            "line": 100,
            "code": "    it('returns an existing ConfigFile', () => {\n      const cf = ConfigFile.at(path0);\n      expect(cf).toEqual(configFile);\n    });",
            "file": "config-file-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new ConfigFile for unrecognized paths",
            "suites": [
                "ConfigFile",
                "ConfigFile.at()"
            ],
            "updatePoint": {
                "line": 104,
                "column": 55
            },
            "line": 104,
            "code": "    it('creates a new ConfigFile for unrecognized paths', () => {\n      const cf = ConfigFile.at(path1);\n      expect(cf).not.toEqual(configFile);\n    });",
            "file": "config-file-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows a key path's value to be read",
            "suites": [
                "Config",
                ".get(keyPath, {scope, sources, excludeSources})"
            ],
            "updatePoint": {
                "line": 13,
                "column": 44
            },
            "line": 13,
            "code": "    it(\"allows a key path's value to be read\", () => {\n      expect(atom.config.set('foo.bar.baz', 42)).toBe(true);\n      expect(atom.config.get('foo.bar.baz')).toBe(42);\n      expect(atom.config.get('foo.quux')).toBeUndefined();\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a deep clone of the key path's value",
            "suites": [
                "Config",
                ".get(keyPath, {scope, sources, excludeSources})"
            ],
            "updatePoint": {
                "line": 18,
                "column": 52
            },
            "line": 18,
            "code": "    it(\"returns a deep clone of the key path's value\", () => {\n      atom.config.set('value', {\n        array: [1, {\n          b: 2\n        }, 3]\n      });\n      const retrievedValue = atom.config.get('value');\n      retrievedValue.array[0] = 4;\n      retrievedValue.array[1].b = 2.1;\n      expect(atom.config.get('value')).toEqual({\n        array: [1, {\n          b: 2\n        }, 3]\n      });\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges defaults into the returned value if both the assigned value and the default value are objects",
            "suites": [
                "Config",
                ".get(keyPath, {scope, sources, excludeSources})"
            ],
            "updatePoint": {
                "line": 33,
                "column": 108
            },
            "line": 33,
            "code": "    it('merges defaults into the returned value if both the assigned value and the default value are objects', () => {\n      atom.config.setDefaults('foo.bar', {\n        baz: 1,\n        ok: 2\n      });\n      atom.config.set('foo.bar', {\n        baz: 3\n      });\n      expect(atom.config.get('foo.bar')).toEqual({\n        baz: 3,\n        ok: 2\n      });\n      atom.config.setDefaults('other', {\n        baz: 1\n      });\n      atom.config.set('other', 7);\n      expect(atom.config.get('other')).toBe(7);\n      atom.config.set('bar.baz', {\n        a: 3\n      });\n      atom.config.setDefaults('bar', {\n        baz: 7\n      });\n      expect(atom.config.get('bar.baz')).toEqual({\n        a: 3\n      });\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only retrieves values from the specified sources",
            "suites": [
                "Config",
                ".get(keyPath, {scope, sources, excludeSources})",
                "when a 'sources' option is specified"
            ],
            "updatePoint": {
                "line": 60,
                "column": 111
            },
            "line": 60,
            "code": "    describe(\"when a 'sources' option is specified\", () => it('only retrieves values from the specified sources', () => {\n      atom.config.set('x.y', 1, {\n        scopeSelector: '.foo',\n        source: 'a'\n      });\n      atom.config.set('x.y', 2, {\n        scopeSelector: '.foo',\n        source: 'b'\n      });\n      atom.config.set('x.y', 3, {\n        scopeSelector: '.foo',\n        source: 'c'\n      });\n      atom.config.setSchema('x.y', {\n        type: 'integer',\n        default: 4\n      });\n      expect(atom.config.get('x.y', {\n        sources: ['a'],\n        scope: ['.foo']\n      })).toBe(1);\n      expect(atom.config.get('x.y', {\n        sources: ['b'],\n        scope: ['.foo']\n      })).toBe(2);\n      expect(atom.config.get('x.y', {\n        sources: ['c'],\n        scope: ['.foo']\n      })).toBe(3); // Schema defaults never match a specific source. We could potentially add a special \"schema\" source.\n\n      expect(atom.config.get('x.y', {\n        sources: ['x'],\n        scope: ['.foo']\n      })).toBeUndefined();\n      expect(atom.config.get(null, {\n        sources: ['a'],\n        scope: ['.foo']\n      }).x.y).toBe(1);\n    }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only retrieves values from the specified sources",
            "suites": [
                "Config",
                ".get(keyPath, {scope, sources, excludeSources})",
                "when an 'excludeSources' option is specified"
            ],
            "updatePoint": {
                "line": 99,
                "column": 119
            },
            "line": 99,
            "code": "    describe(\"when an 'excludeSources' option is specified\", () => it('only retrieves values from the specified sources', () => {\n      atom.config.set('x.y', 0);\n      atom.config.set('x.y', 1, {\n        scopeSelector: '.foo',\n        source: 'a'\n      });\n      atom.config.set('x.y', 2, {\n        scopeSelector: '.foo',\n        source: 'b'\n      });\n      atom.config.set('x.y', 3, {\n        scopeSelector: '.foo',\n        source: 'c'\n      });\n      atom.config.setSchema('x.y', {\n        type: 'integer',\n        default: 4\n      });\n      expect(atom.config.get('x.y', {\n        excludeSources: ['a'],\n        scope: ['.foo']\n      })).toBe(3);\n      expect(atom.config.get('x.y', {\n        excludeSources: ['c'],\n        scope: ['.foo']\n      })).toBe(2);\n      expect(atom.config.get('x.y', {\n        excludeSources: ['b', 'c'],\n        scope: ['.foo']\n      })).toBe(1);\n      expect(atom.config.get('x.y', {\n        excludeSources: ['b', 'c', 'a'],\n        scope: ['.foo']\n      })).toBe(0);\n      expect(atom.config.get('x.y', {\n        excludeSources: ['b', 'c', 'a', atom.config.getUserConfigPath()],\n        scope: ['.foo']\n      })).toBe(4);\n      expect(atom.config.get('x.y', {\n        excludeSources: [atom.config.getUserConfigPath()]\n      })).toBe(4);\n    }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the property with the most specific scope selector",
            "suites": [
                "Config",
                ".get(keyPath, {scope, sources, excludeSources})",
                "when a 'scope' option is given"
            ],
            "updatePoint": {
                "line": 142,
                "column": 68
            },
            "line": 142,
            "code": "      it('returns the property with the most specific scope selector', () => {\n        atom.config.set('foo.bar.baz', 42, {\n          scopeSelector: '.source.coffee .string.quoted.double.coffee'\n        });\n        atom.config.set('foo.bar.baz', 22, {\n          scopeSelector: '.source .string.quoted.double'\n        });\n        atom.config.set('foo.bar.baz', 11, {\n          scopeSelector: '.source'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee', '.string.quoted.double.coffee']\n        })).toBe(42);\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.js', '.string.quoted.double.js']\n        })).toBe(22);\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.js', '.variable.assignment.js']\n        })).toBe(11);\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.text']\n        })).toBeUndefined();\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "favors the most recently added properties in the event of a specificity tie",
            "suites": [
                "Config",
                ".get(keyPath, {scope, sources, excludeSources})",
                "when a 'scope' option is given"
            ],
            "updatePoint": {
                "line": 165,
                "column": 85
            },
            "line": 165,
            "code": "      it('favors the most recently added properties in the event of a specificity tie', () => {\n        atom.config.set('foo.bar.baz', 42, {\n          scopeSelector: '.source.coffee .string.quoted.single'\n        });\n        atom.config.set('foo.bar.baz', 22, {\n          scopeSelector: '.source.coffee .string.quoted.double'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee', '.string.quoted.single']\n        })).toBe(42);\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee', '.string.quoted.single.double']\n        })).toBe(22);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "falls back to the global when there is no scoped property specified",
            "suites": [
                "Config",
                ".get(keyPath, {scope, sources, excludeSources})",
                "when a 'scope' option is given",
                "when there are global defaults"
            ],
            "updatePoint": {
                "line": 179,
                "column": 126
            },
            "line": 179,
            "code": "      describe('when there are global defaults', () => it('falls back to the global when there is no scoped property specified', () => {\n        atom.config.setDefaults('foo', {\n          hasDefault: 'ok'\n        });\n        expect(atom.config.get('foo.hasDefault', {\n          scope: ['.source.coffee', '.string.quoted.single']\n        })).toBe('ok');\n      }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the user's setting because the user's setting has higher priority",
            "suites": [
                "Config",
                ".get(keyPath, {scope, sources, excludeSources})",
                "when a 'scope' option is given",
                "when package settings are added after user settings"
            ],
            "updatePoint": {
                "line": 187,
                "column": 153
            },
            "line": 187,
            "code": "      describe('when package settings are added after user settings', () => it(\"returns the user's setting because the user's setting has higher priority\", () => {\n        atom.config.set('foo.bar.baz', 100, {\n          scopeSelector: '.source.coffee'\n        });\n        atom.config.set('foo.bar.baz', 1, {\n          scopeSelector: '.source.coffee',\n          source: 'some-package'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee']\n        })).toBe(100);\n      }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reads all of the values for a given key-path",
            "suites": [
                "Config",
                ".getAll(keyPath, {scope, sources, excludeSources})"
            ],
            "updatePoint": {
                "line": 202,
                "column": 52
            },
            "line": 202,
            "code": "    it('reads all of the values for a given key-path', () => {\n      expect(atom.config.set('foo', 41)).toBe(true);\n      expect(atom.config.set('foo', 43, {\n        scopeSelector: '.a .b'\n      })).toBe(true);\n      expect(atom.config.set('foo', 42, {\n        scopeSelector: '.a'\n      })).toBe(true);\n      expect(atom.config.set('foo', 44, {\n        scopeSelector: '.a .b.c'\n      })).toBe(true);\n      expect(atom.config.set('foo', -44, {\n        scopeSelector: '.d'\n      })).toBe(true);\n      expect(atom.config.getAll('foo', {\n        scope: ['.a', '.b.c']\n      })).toEqual([{\n        scopeSelector: '.a .b.c',\n        value: 44\n      }, {\n        scopeSelector: '.a .b',\n        value: 43\n      }, {\n        scopeSelector: '.a',\n        value: 42\n      }, {\n        scopeSelector: '*',\n        value: 41\n      }]);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes the schema's default value",
            "suites": [
                "Config",
                ".getAll(keyPath, {scope, sources, excludeSources})"
            ],
            "updatePoint": {
                "line": 232,
                "column": 43
            },
            "line": 232,
            "code": "    it(\"includes the schema's default value\", () => {\n      atom.config.setSchema('foo', {\n        type: 'number',\n        default: 40\n      });\n      expect(atom.config.set('foo', 43, {\n        scopeSelector: '.a .b'\n      })).toBe(true);\n      expect(atom.config.getAll('foo', {\n        scope: ['.a', '.b.c']\n      })).toEqual([{\n        scopeSelector: '.a .b',\n        value: 43\n      }, {\n        scopeSelector: '*',\n        value: 40\n      }]);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows a key path's value to be written",
            "suites": [
                "Config",
                ".set(keyPath, value, {source, scopeSelector})"
            ],
            "updatePoint": {
                "line": 252,
                "column": 47
            },
            "line": 252,
            "code": "    it(\"allows a key path's value to be written\", () => {\n      expect(atom.config.set('foo.bar.baz', 42)).toBe(true);\n      expect(atom.config.get('foo.bar.baz')).toBe(42);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "saves the user's config to disk after it stops changing",
            "suites": [
                "Config",
                ".set(keyPath, value, {source, scopeSelector})"
            ],
            "updatePoint": {
                "line": 256,
                "column": 63
            },
            "line": 256,
            "code": "    it(\"saves the user's config to disk after it stops changing\", () => {\n      atom.config.set('foo.bar.baz', 42);\n      expect(savedSettings.length).toBe(0);\n      atom.config.set('foo.bar.baz', 43);\n      expect(savedSettings.length).toBe(0);\n      atom.config.set('foo.bar.baz', 44);\n      advanceClock(10);\n      expect(savedSettings.length).toBe(1);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not save when a non-default 'source' is given",
            "suites": [
                "Config",
                ".set(keyPath, value, {source, scopeSelector})"
            ],
            "updatePoint": {
                "line": 265,
                "column": 58
            },
            "line": 265,
            "code": "    it(\"does not save when a non-default 'source' is given\", () => {\n      atom.config.set('foo.bar.baz', 42, {\n        source: 'some-other-source',\n        scopeSelector: '.a'\n      });\n      advanceClock(500);\n      expect(savedSettings.length).toBe(0);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not allow a 'source' option without a 'scopeSelector'",
            "suites": [
                "Config",
                ".set(keyPath, value, {source, scopeSelector})"
            ],
            "updatePoint": {
                "line": 273,
                "column": 66
            },
            "line": 273,
            "code": "    it(\"does not allow a 'source' option without a 'scopeSelector'\", () => {\n      expect(() => atom.config.set('foo', 1, {\n        source: ['.source.ruby']\n      })).toThrow();\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the root object",
            "suites": [
                "Config",
                ".set(keyPath, value, {source, scopeSelector})",
                "when the key-path is null"
            ],
            "updatePoint": {
                "line": 278,
                "column": 72
            },
            "line": 278,
            "code": "    describe('when the key-path is null', () => it('sets the root object', () => {\n      expect(atom.config.set(null, {\n        editor: {\n          tabLength: 6\n        }\n      })).toBe(true);\n      expect(atom.config.get('editor.tabLength')).toBe(6);\n      expect(atom.config.set(null, {\n        editor: {\n          tabLength: 8,\n          scopeSelector: ['.source.js']\n        }\n      })).toBe(true);\n      expect(atom.config.get('editor.tabLength', {\n        scope: ['.source.js']\n      })).toBe(8);\n    }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not store the value in the user's config",
            "suites": [
                "Config",
                ".set(keyPath, value, {source, scopeSelector})",
                "when the value equals the default value"
            ],
            "updatePoint": {
                "line": 295,
                "column": 111
            },
            "line": 295,
            "code": "    describe('when the value equals the default value', () => it(\"does not store the value in the user's config\", () => {\n      atom.config.setSchema('foo', {\n        type: 'object',\n        properties: {\n          same: {\n            type: 'number',\n            default: 1\n          },\n          changes: {\n            type: 'number',\n            default: 1\n          },\n          sameArray: {\n            type: 'array',\n            default: [1, 2, 3]\n          },\n          sameObject: {\n            type: 'object',\n            default: {\n              a: 1,\n              b: 2\n            }\n          },\n          null: {\n            type: '*',\n            default: null\n          },\n          undefined: {\n            type: '*',\n            default: undefined\n          }\n        }\n      });\n      expect(atom.config.settings.foo).toBeUndefined();\n      atom.config.set('foo.same', 1);\n      atom.config.set('foo.changes', 2);\n      atom.config.set('foo.sameArray', [1, 2, 3]);\n      atom.config.set('foo.null', undefined);\n      atom.config.set('foo.undefined', null);\n      atom.config.set('foo.sameObject', {\n        b: 2,\n        a: 1\n      });\n      const userConfigPath = atom.config.getUserConfigPath();\n      expect(atom.config.get('foo.same', {\n        sources: [userConfigPath]\n      })).toBeUndefined();\n      expect(atom.config.get('foo.changes')).toBe(2);\n      expect(atom.config.get('foo.changes', {\n        sources: [userConfigPath]\n      })).toBe(2);\n      atom.config.set('foo.changes', 1);\n      expect(atom.config.get('foo.changes', {\n        sources: [userConfigPath]\n      })).toBeUndefined();\n    }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the value and overrides the others",
            "suites": [
                "Config",
                ".set(keyPath, value, {source, scopeSelector})",
                "when a 'scopeSelector' is given"
            ],
            "updatePoint": {
                "line": 351,
                "column": 97
            },
            "line": 351,
            "code": "    describe(\"when a 'scopeSelector' is given\", () => it('sets the value and overrides the others', () => {\n      atom.config.set('foo.bar.baz', 42, {\n        scopeSelector: '.source.coffee .string.quoted.double.coffee'\n      });\n      atom.config.set('foo.bar.baz', 22, {\n        scopeSelector: '.source .string.quoted.double'\n      });\n      atom.config.set('foo.bar.baz', 11, {\n        scopeSelector: '.source'\n      });\n      expect(atom.config.get('foo.bar.baz', {\n        scope: ['.source.coffee', '.string.quoted.double.coffee']\n      })).toBe(42);\n      expect(atom.config.set('foo.bar.baz', 100, {\n        scopeSelector: '.source.coffee .string.quoted.double.coffee'\n      })).toBe(true);\n      expect(atom.config.get('foo.bar.baz', {\n        scope: ['.source.coffee', '.string.quoted.double.coffee']\n      })).toBe(100);\n    }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the value of the key path to its default",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})"
            ],
            "updatePoint": {
                "line": 395,
                "column": 53
            },
            "line": 395,
            "code": "    it('sets the value of the key path to its default', () => {\n      atom.config.setDefaults('a', {\n        b: 3\n      });\n      atom.config.set('a.b', 4);\n      expect(atom.config.get('a.b')).toBe(4);\n      atom.config.unset('a.b');\n      expect(atom.config.get('a.b')).toBe(3);\n      atom.config.set('a.c', 5);\n      expect(atom.config.get('a.c')).toBe(5);\n      atom.config.unset('a.c');\n      expect(atom.config.get('a.c')).toBeUndefined();\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls ::save()",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})"
            ],
            "updatePoint": {
                "line": 408,
                "column": 22
            },
            "line": 408,
            "code": "    it('calls ::save()', () => {\n      atom.config.setDefaults('a', {\n        b: 3\n      });\n      atom.config.set('a.b', 4);\n      savedSettings.length = 0;\n      atom.config.unset('a.c');\n      advanceClock(500);\n      expect(savedSettings.length).toBe(1);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes all scoped settings with the given source",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})",
                "when no 'scopeSelector' is given",
                "when a 'source' but no key-path is given"
            ],
            "updatePoint": {
                "line": 419,
                "column": 118
            },
            "line": 419,
            "code": "      describe(\"when a 'source' but no key-path is given\", () => it('removes all scoped settings with the given source', () => {\n        atom.config.set('foo.bar.baz', 1, {\n          scopeSelector: '.a',\n          source: 'source-a'\n        });\n        atom.config.set('foo.bar.quux', 2, {\n          scopeSelector: '.b',\n          source: 'source-a'\n        });\n        expect(atom.config.get('foo.bar', {\n          scope: ['.a.b']\n        })).toEqual({\n          baz: 1,\n          quux: 2\n        });\n        atom.config.unset(null, {\n          source: 'source-a'\n        });\n        expect(atom.config.get('foo.bar', {\n          scope: ['.a']\n        })).toEqual({\n          baz: 0,\n          ok: 0\n        });\n      }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes all scoped settings with the given source and key-path",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})",
                "when no 'scopeSelector' is given",
                "when a 'source' and a key-path is given"
            ],
            "updatePoint": {
                "line": 444,
                "column": 130
            },
            "line": 444,
            "code": "      describe(\"when a 'source' and a key-path is given\", () => it('removes all scoped settings with the given source and key-path', () => {\n        atom.config.set('foo.bar.baz', 1);\n        atom.config.set('foo.bar.baz', 2, {\n          scopeSelector: '.a',\n          source: 'source-a'\n        });\n        atom.config.set('foo.bar.baz', 3, {\n          scopeSelector: '.a.b',\n          source: 'source-b'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.a.b']\n        })).toEqual(3);\n        atom.config.unset('foo.bar.baz', {\n          source: 'source-b'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.a.b']\n        })).toEqual(2);\n        expect(atom.config.get('foo.bar.baz')).toEqual(1);\n      }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes all scoped and unscoped properties for that key-path",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})",
                "when no 'scopeSelector' is given",
                "when no 'source' is given"
            ],
            "updatePoint": {
                "line": 465,
                "column": 114
            },
            "line": 465,
            "code": "      describe(\"when no 'source' is given\", () => it('removes all scoped and unscoped properties for that key-path', () => {\n        atom.config.setDefaults('foo.bar', {\n          baz: 100\n        });\n        atom.config.set('foo.bar', {\n          baz: 1,\n          ok: 2\n        }, {\n          scopeSelector: '.a'\n        });\n        atom.config.set('foo.bar', {\n          baz: 11,\n          ok: 12\n        }, {\n          scopeSelector: '.b'\n        });\n        atom.config.set('foo.bar', {\n          baz: 21,\n          ok: 22\n        });\n        atom.config.unset('foo.bar.baz');\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.a']\n        })).toBe(100);\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.b']\n        })).toBe(100);\n        expect(atom.config.get('foo.bar.baz')).toBe(100);\n        expect(atom.config.get('foo.bar.ok', {\n          scope: ['.a']\n        })).toBe(2);\n        expect(atom.config.get('foo.bar.ok', {\n          scope: ['.b']\n        })).toBe(12);\n        expect(atom.config.get('foo.bar.ok')).toBe(22);\n      }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the global default when no scoped default set",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})",
                "when a 'scopeSelector' is given"
            ],
            "updatePoint": {
                "line": 503,
                "column": 64
            },
            "line": 503,
            "code": "      it('restores the global default when no scoped default set', () => {\n        atom.config.setDefaults('foo', {\n          bar: {\n            baz: 10\n          }\n        });\n        atom.config.set('foo.bar.baz', 55, {\n          scopeSelector: '.source.coffee'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee']\n        })).toBe(55);\n        atom.config.unset('foo.bar.baz', {\n          scopeSelector: '.source.coffee'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee']\n        })).toBe(10);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the scoped default when a scoped default is set",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})",
                "when a 'scopeSelector' is given"
            ],
            "updatePoint": {
                "line": 522,
                "column": 66
            },
            "line": 522,
            "code": "      it('restores the scoped default when a scoped default is set', () => {\n        atom.config.setDefaults('foo', {\n          bar: {\n            baz: 10\n          }\n        });\n        atom.config.set('foo.bar.baz', 42, {\n          scopeSelector: '.source.coffee',\n          source: 'some-source'\n        });\n        atom.config.set('foo.bar.baz', 55, {\n          scopeSelector: '.source.coffee'\n        });\n        atom.config.set('foo.bar.ok', 100, {\n          scopeSelector: '.source.coffee'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee']\n        })).toBe(55);\n        atom.config.unset('foo.bar.baz', {\n          scopeSelector: '.source.coffee'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee']\n        })).toBe(42);\n        expect(atom.config.get('foo.bar.ok', {\n          scope: ['.source.coffee']\n        })).toBe(100);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls ::save()",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})",
                "when a 'scopeSelector' is given"
            ],
            "updatePoint": {
                "line": 551,
                "column": 24
            },
            "line": 551,
            "code": "      it('calls ::save()', () => {\n        atom.config.setDefaults('foo', {\n          bar: {\n            baz: 10\n          }\n        });\n        atom.config.set('foo.bar.baz', 55, {\n          scopeSelector: '.source.coffee'\n        });\n        savedSettings.length = 0;\n        atom.config.unset('foo.bar.baz', {\n          scopeSelector: '.source.coffee'\n        });\n        advanceClock(150);\n        expect(savedSettings.length).toBe(1);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows removing settings for a specific source and scope selector",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})",
                "when a 'scopeSelector' is given"
            ],
            "updatePoint": {
                "line": 567,
                "column": 75
            },
            "line": 567,
            "code": "      it('allows removing settings for a specific source and scope selector', () => {\n        atom.config.set('foo.bar.baz', 55, {\n          scopeSelector: '.source.coffee',\n          source: 'source-a'\n        });\n        atom.config.set('foo.bar.baz', 65, {\n          scopeSelector: '.source.coffee',\n          source: 'source-b'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee']\n        })).toBe(65);\n        atom.config.unset('foo.bar.baz', {\n          source: 'source-b',\n          scopeSelector: '.source.coffee'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee', '.string']\n        })).toBe(55);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows removing all settings for a specific source",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})",
                "when a 'scopeSelector' is given"
            ],
            "updatePoint": {
                "line": 587,
                "column": 60
            },
            "line": 587,
            "code": "      it('allows removing all settings for a specific source', () => {\n        atom.config.set('foo.bar.baz', 55, {\n          scopeSelector: '.source.coffee',\n          source: 'source-a'\n        });\n        atom.config.set('foo.bar.baz', 65, {\n          scopeSelector: '.source.coffee',\n          source: 'source-b'\n        });\n        atom.config.set('foo.bar.ok', 65, {\n          scopeSelector: '.source.coffee',\n          source: 'source-b'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee']\n        })).toBe(65);\n        atom.config.unset(null, {\n          source: 'source-b',\n          scopeSelector: '.source.coffee'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee', '.string']\n        })).toBe(55);\n        expect(atom.config.get('foo.bar.ok', {\n          scope: ['.source.coffee', '.string']\n        })).toBe(0);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not call ::save or add a scoped property when no value has been set",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})",
                "when a 'scopeSelector' is given"
            ],
            "updatePoint": {
                "line": 614,
                "column": 82
            },
            "line": 614,
            "code": "      it('does not call ::save or add a scoped property when no value has been set', () => {\n        // see https://github.com/atom/atom/issues/4175\n        atom.config.setDefaults('foo', {\n          bar: {\n            baz: 10\n          }\n        });\n        atom.config.unset('foo.bar.baz', {\n          scopeSelector: '.source.coffee'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee']\n        })).toBe(10);\n        expect(savedSettings.length).toBe(0);\n        const scopedProperties = atom.config.scopedSettingsStore.propertiesForSource('user-config');\n        expect(scopedProperties['.coffee.source']).toBeUndefined();\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the scoped value when it was the only set value on the object",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})",
                "when a 'scopeSelector' is given"
            ],
            "updatePoint": {
                "line": 631,
                "column": 79
            },
            "line": 631,
            "code": "      it('removes the scoped value when it was the only set value on the object', () => {\n        atom.config.setDefaults('foo', {\n          bar: {\n            baz: 10\n          }\n        });\n        atom.config.set('foo.bar.baz', 55, {\n          scopeSelector: '.source.coffee'\n        });\n        atom.config.set('foo.bar.ok', 20, {\n          scopeSelector: '.source.coffee'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee']\n        })).toBe(55);\n        advanceClock(150);\n        savedSettings.length = 0;\n        atom.config.unset('foo.bar.baz', {\n          scopeSelector: '.source.coffee'\n        });\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee']\n        })).toBe(10);\n        expect(atom.config.get('foo.bar.ok', {\n          scope: ['.source.coffee']\n        })).toBe(20);\n        advanceClock(150);\n        expect(savedSettings[0]['.coffee.source']).toEqual({\n          foo: {\n            bar: {\n              ok: 20\n            }\n          }\n        });\n        atom.config.unset('foo.bar.ok', {\n          scopeSelector: '.source.coffee'\n        });\n        advanceClock(150);\n        expect(savedSettings.length).toBe(2);\n        expect(savedSettings[1]['.coffee.source']).toBeUndefined();\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not call ::save when the value is already at the default",
            "suites": [
                "Config",
                ".unset(keyPath, {source, scopeSelector})",
                "when a 'scopeSelector' is given"
            ],
            "updatePoint": {
                "line": 672,
                "column": 71
            },
            "line": 672,
            "code": "      it('does not call ::save when the value is already at the default', () => {\n        atom.config.setDefaults('foo', {\n          bar: {\n            baz: 10\n          }\n        });\n        atom.config.set('foo.bar.baz', 55);\n        advanceClock(150);\n        savedSettings.length = 0;\n        atom.config.unset('foo.bar.ok', {\n          scopeSelector: '.source.coffee'\n        });\n        advanceClock(150);\n        expect(savedSettings.length).toBe(0);\n        expect(atom.config.get('foo.bar.baz', {\n          scope: ['.source.coffee']\n        })).toBe(55);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not fire the given callback with the current value at the keypath",
            "suites": [
                "Config",
                ".onDidChange(keyPath, {scope})",
                "when a keyPath is specified"
            ],
            "updatePoint": {
                "line": 700,
                "column": 80
            },
            "line": 700,
            "code": "      it('does not fire the given callback with the current value at the keypath', () => expect(observeHandler).not.toHaveBeenCalled());",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires the callback every time the observed value changes",
            "suites": [
                "Config",
                ".onDidChange(keyPath, {scope})",
                "when a keyPath is specified"
            ],
            "updatePoint": {
                "line": 701,
                "column": 66
            },
            "line": 701,
            "code": "      it('fires the callback every time the observed value changes', () => {\n        atom.config.set('foo.bar.baz', 'value 2');\n        expect(observeHandler).toHaveBeenCalledWith({\n          newValue: 'value 2',\n          oldValue: 'value 1'\n        });\n        observeHandler.reset();\n        observeHandler.andCallFake(() => {\n          throw new Error('oops');\n        });\n        expect(() => atom.config.set('foo.bar.baz', 'value 1')).toThrow('oops');\n        expect(observeHandler).toHaveBeenCalledWith({\n          newValue: 'value 1',\n          oldValue: 'value 2'\n        });\n        observeHandler.reset(); // Regression: exception in earlier handler shouldn't put observer\n        // into a bad state.\n\n        atom.config.set('something.else', 'new value');\n        expect(observeHandler).not.toHaveBeenCalled();\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not fire the given callback initially",
            "suites": [
                "Config",
                ".onDidChange(keyPath, {scope})",
                "when a keyPath is not specified"
            ],
            "updatePoint": {
                "line": 729,
                "column": 52
            },
            "line": 729,
            "code": "      it('does not fire the given callback initially', () => expect(observeHandler).not.toHaveBeenCalled());",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires the callback every time any value changes",
            "suites": [
                "Config",
                ".onDidChange(keyPath, {scope})",
                "when a keyPath is not specified"
            ],
            "updatePoint": {
                "line": 730,
                "column": 57
            },
            "line": 730,
            "code": "      it('fires the callback every time any value changes', () => {\n        observeHandler.reset(); // clear the initial call\n\n        atom.config.set('foo.bar.baz', 'value 2');\n        expect(observeHandler).toHaveBeenCalled();\n        expect(observeHandler.mostRecentCall.args[0].newValue.foo.bar.baz).toBe('value 2');\n        expect(observeHandler.mostRecentCall.args[0].oldValue.foo.bar.baz).toBe('value 1');\n        observeHandler.reset();\n        atom.config.set('foo.bar.baz', 'value 1');\n        expect(observeHandler).toHaveBeenCalled();\n        expect(observeHandler.mostRecentCall.args[0].newValue.foo.bar.baz).toBe('value 1');\n        expect(observeHandler.mostRecentCall.args[0].oldValue.foo.bar.baz).toBe('value 2');\n        observeHandler.reset();\n        atom.config.set('foo.bar.int', 1);\n        expect(observeHandler).toHaveBeenCalled();\n        expect(observeHandler.mostRecentCall.args[0].newValue.foo.bar.int).toBe(1);\n        expect(observeHandler.mostRecentCall.args[0].oldValue.foo.bar.int).toBe(undefined);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the supplied callback when the value at the descriptor/keypath changes",
            "suites": [
                "Config",
                ".onDidChange(keyPath, {scope})",
                "when a 'scope' is given"
            ],
            "updatePoint": {
                "line": 749,
                "column": 126
            },
            "line": 749,
            "code": "    describe(\"when a 'scope' is given\", () => it('calls the supplied callback when the value at the descriptor/keypath changes', () => {\n      const changeSpy = jasmine.createSpy('onDidChange callback');\n      atom.config.onDidChange('foo.bar.baz', {\n        scope: ['.source.coffee', '.string.quoted.double.coffee']\n      }, changeSpy);\n      atom.config.set('foo.bar.baz', 12);\n      expect(changeSpy).toHaveBeenCalledWith({\n        oldValue: undefined,\n        newValue: 12\n      });\n      changeSpy.reset();\n      atom.config.set('foo.bar.baz', 22, {\n        scopeSelector: '.source .string.quoted.double',\n        source: 'a'\n      });\n      expect(changeSpy).toHaveBeenCalledWith({\n        oldValue: 12,\n        newValue: 22\n      });\n      changeSpy.reset();\n      atom.config.set('foo.bar.baz', 42, {\n        scopeSelector: '.source.coffee .string.quoted.double.coffee',\n        source: 'b'\n      });\n      expect(changeSpy).toHaveBeenCalledWith({\n        oldValue: 22,\n        newValue: 42\n      });\n      changeSpy.reset();\n      atom.config.unset(null, {\n        scopeSelector: '.source.coffee .string.quoted.double.coffee',\n        source: 'b'\n      });\n      expect(changeSpy).toHaveBeenCalledWith({\n        oldValue: 42,\n        newValue: 22\n      });\n      changeSpy.reset();\n      atom.config.unset(null, {\n        scopeSelector: '.source .string.quoted.double',\n        source: 'a'\n      });\n      expect(changeSpy).toHaveBeenCalledWith({\n        oldValue: 22,\n        newValue: 12\n      });\n      changeSpy.reset();\n      atom.config.set('foo.bar.baz', undefined);\n      expect(changeSpy).toHaveBeenCalledWith({\n        oldValue: 12,\n        newValue: undefined\n      });\n      changeSpy.reset();\n    }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires the given callback with the current value at the keypath",
            "suites": [
                "Config",
                ".observe(keyPath, {scope})"
            ],
            "updatePoint": {
                "line": 811,
                "column": 70
            },
            "line": 811,
            "code": "    it('fires the given callback with the current value at the keypath', () => expect(observeHandler).toHaveBeenCalledWith('value 1'));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires the callback every time the observed value changes",
            "suites": [
                "Config",
                ".observe(keyPath, {scope})"
            ],
            "updatePoint": {
                "line": 812,
                "column": 64
            },
            "line": 812,
            "code": "    it('fires the callback every time the observed value changes', () => {\n      observeHandler.reset(); // clear the initial call\n\n      atom.config.set('foo.bar.baz', 'value 2');\n      expect(observeHandler).toHaveBeenCalledWith('value 2');\n      observeHandler.reset();\n      atom.config.set('foo.bar.baz', 'value 1');\n      expect(observeHandler).toHaveBeenCalledWith('value 1');\n      advanceClock(100); // complete pending save that was requested in ::set\n\n      observeHandler.reset();\n      atom.config.resetUserSettings({\n        foo: {}\n      });\n      expect(observeHandler).toHaveBeenCalledWith(undefined);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires the callback when the observed value is deleted",
            "suites": [
                "Config",
                ".observe(keyPath, {scope})"
            ],
            "updatePoint": {
                "line": 828,
                "column": 61
            },
            "line": 828,
            "code": "    it('fires the callback when the observed value is deleted', () => {\n      observeHandler.reset(); // clear the initial call\n\n      atom.config.set('foo.bar.baz', undefined);\n      expect(observeHandler).toHaveBeenCalledWith(undefined);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires the callback when the full key path goes into and out of existence",
            "suites": [
                "Config",
                ".observe(keyPath, {scope})"
            ],
            "updatePoint": {
                "line": 834,
                "column": 80
            },
            "line": 834,
            "code": "    it('fires the callback when the full key path goes into and out of existence', () => {\n      observeHandler.reset(); // clear the initial call\n\n      atom.config.set('foo.bar', undefined);\n      expect(observeHandler).toHaveBeenCalledWith(undefined);\n      observeHandler.reset();\n      atom.config.set('foo.bar.baz', \"i'm back\");\n      expect(observeHandler).toHaveBeenCalledWith(\"i'm back\");\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not fire the callback once the subscription is disposed",
            "suites": [
                "Config",
                ".observe(keyPath, {scope})"
            ],
            "updatePoint": {
                "line": 843,
                "column": 68
            },
            "line": 843,
            "code": "    it('does not fire the callback once the subscription is disposed', () => {\n      observeHandler.reset(); // clear the initial call\n\n      observeSubscription.dispose();\n      atom.config.set('foo.bar.baz', 'value 2');\n      expect(observeHandler).not.toHaveBeenCalled();\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not fire the callback for a similarly named keyPath",
            "suites": [
                "Config",
                ".observe(keyPath, {scope})"
            ],
            "updatePoint": {
                "line": 850,
                "column": 64
            },
            "line": 850,
            "code": "    it('does not fire the callback for a similarly named keyPath', () => {\n      const bazCatHandler = jasmine.createSpy('bazCatHandler');\n      observeSubscription = atom.config.observe('foo.bar.bazCat', bazCatHandler);\n      bazCatHandler.reset();\n      atom.config.set('foo.bar.baz', 'value 10');\n      expect(bazCatHandler).not.toHaveBeenCalled();\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows settings to be observed in a specific scope",
            "suites": [
                "Config",
                ".observe(keyPath, {scope})",
                "when a 'scope' is given"
            ],
            "updatePoint": {
                "line": 863,
                "column": 60
            },
            "line": 863,
            "code": "      it('allows settings to be observed in a specific scope', () => {\n        atom.config.observe('foo.bar.baz', {\n          scope: ['.some.scope']\n        }, observeHandler);\n        atom.config.observe('foo.bar.baz', {\n          scope: ['.another.scope']\n        }, otherHandler);\n        atom.config.set('foo.bar.baz', 'value 2', {\n          scopeSelector: '.some'\n        });\n        expect(observeHandler).toHaveBeenCalledWith('value 2');\n        expect(otherHandler).not.toHaveBeenCalledWith('value 2');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the callback when properties with more specific selectors are removed",
            "suites": [
                "Config",
                ".observe(keyPath, {scope})",
                "when a 'scope' is given"
            ],
            "updatePoint": {
                "line": 876,
                "column": 85
            },
            "line": 876,
            "code": "      it('calls the callback when properties with more specific selectors are removed', () => {\n        const changeSpy = jasmine.createSpy();\n        atom.config.observe('foo.bar.baz', {\n          scope: ['.source.coffee', '.string.quoted.double.coffee']\n        }, changeSpy);\n        expect(changeSpy).toHaveBeenCalledWith('value 1');\n        changeSpy.reset();\n        atom.config.set('foo.bar.baz', 12);\n        expect(changeSpy).toHaveBeenCalledWith(12);\n        changeSpy.reset();\n        atom.config.set('foo.bar.baz', 22, {\n          scopeSelector: '.source .string.quoted.double',\n          source: 'a'\n        });\n        expect(changeSpy).toHaveBeenCalledWith(22);\n        changeSpy.reset();\n        atom.config.set('foo.bar.baz', 42, {\n          scopeSelector: '.source.coffee .string.quoted.double.coffee',\n          source: 'b'\n        });\n        expect(changeSpy).toHaveBeenCalledWith(42);\n        changeSpy.reset();\n        atom.config.unset(null, {\n          scopeSelector: '.source.coffee .string.quoted.double.coffee',\n          source: 'b'\n        });\n        expect(changeSpy).toHaveBeenCalledWith(22);\n        changeSpy.reset();\n        atom.config.unset(null, {\n          scopeSelector: '.source .string.quoted.double',\n          source: 'a'\n        });\n        expect(changeSpy).toHaveBeenCalledWith(12);\n        changeSpy.reset();\n        atom.config.set('foo.bar.baz', undefined);\n        expect(changeSpy).toHaveBeenCalledWith(undefined);\n        changeSpy.reset();\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows only one change event for the duration of the given callback",
            "suites": [
                "Config",
                ".transact(callback)"
            ],
            "updatePoint": {
                "line": 922,
                "column": 75
            },
            "line": 922,
            "code": "    it('allows only one change event for the duration of the given callback', () => {\n      atom.config.transact(() => {\n        atom.config.set('foo.bar.baz', 1);\n        atom.config.set('foo.bar.baz', 2);\n        atom.config.set('foo.bar.baz', 3);\n      });\n      expect(changeSpy.callCount).toBe(1);\n      expect(changeSpy.argsForCall[0][0]).toEqual({\n        newValue: 3,\n        oldValue: undefined\n      });\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not emit an event if no changes occur while paused",
            "suites": [
                "Config",
                ".transact(callback)"
            ],
            "updatePoint": {
                "line": 934,
                "column": 63
            },
            "line": 934,
            "code": "    it('does not emit an event if no changes occur while paused', () => {\n      atom.config.transact(() => {});\n      expect(changeSpy).not.toHaveBeenCalled();\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows only one change event for the duration of the given promise if it gets resolved",
            "suites": [
                "Config",
                ".transactAsync(callback)"
            ],
            "updatePoint": {
                "line": 945,
                "column": 94
            },
            "line": 945,
            "code": "    it('allows only one change event for the duration of the given promise if it gets resolved', () => {\n      let promiseResult = null;\n      const transactionPromise = atom.config.transactAsync(() => {\n        atom.config.set('foo.bar.baz', 1);\n        atom.config.set('foo.bar.baz', 2);\n        atom.config.set('foo.bar.baz', 3);\n        return Promise.resolve('a result');\n      });\n      waitsForPromise(() => transactionPromise.then(result => {\n        promiseResult = result;\n      }));\n      runs(() => {\n        expect(promiseResult).toBe('a result');\n        expect(changeSpy.callCount).toBe(1);\n        expect(changeSpy.argsForCall[0][0]).toEqual({\n          newValue: 3,\n          oldValue: undefined\n        });\n      });\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows only one change event for the duration of the given promise if it gets rejected",
            "suites": [
                "Config",
                ".transactAsync(callback)"
            ],
            "updatePoint": {
                "line": 965,
                "column": 94
            },
            "line": 965,
            "code": "    it('allows only one change event for the duration of the given promise if it gets rejected', () => {\n      let promiseError = null;\n      const transactionPromise = atom.config.transactAsync(() => {\n        atom.config.set('foo.bar.baz', 1);\n        atom.config.set('foo.bar.baz', 2);\n        atom.config.set('foo.bar.baz', 3);\n        return Promise.reject(new Error('an error'));\n      });\n      waitsForPromise(() => transactionPromise.catch(error => {\n        promiseError = error;\n      }));\n      runs(() => {\n        expect(promiseError.message).toBe('an error');\n        expect(changeSpy.callCount).toBe(1);\n        expect(changeSpy.argsForCall[0][0]).toEqual({\n          newValue: 3,\n          oldValue: undefined\n        });\n      });\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows only one change event even when the given callback throws",
            "suites": [
                "Config",
                ".transactAsync(callback)"
            ],
            "updatePoint": {
                "line": 985,
                "column": 72
            },
            "line": 985,
            "code": "    it('allows only one change event even when the given callback throws', () => {\n      const error = new Error('Oops!');\n      let promiseError = null;\n      const transactionPromise = atom.config.transactAsync(() => {\n        atom.config.set('foo.bar.baz', 1);\n        atom.config.set('foo.bar.baz', 2);\n        atom.config.set('foo.bar.baz', 3);\n        throw error;\n      });\n      waitsForPromise(() => transactionPromise.catch(e => {\n        promiseError = e;\n      }));\n      runs(() => {\n        expect(promiseError).toBe(error);\n        expect(changeSpy.callCount).toBe(1);\n        expect(changeSpy.argsForCall[0][0]).toEqual({\n          newValue: 3,\n          oldValue: undefined\n        });\n      });\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns an array of all of the config's source names",
            "suites": [
                "Config",
                ".getSources()"
            ],
            "updatePoint": {
                "line": 1008,
                "column": 60
            },
            "line": 1008,
            "code": "    it(\"returns an array of all of the config's source names\", () => {\n      expect(atom.config.getSources()).toEqual([]);\n      atom.config.set('a.b', 1, {\n        scopeSelector: '.x1',\n        source: 'source-1'\n      });\n      atom.config.set('a.c', 1, {\n        scopeSelector: '.x1',\n        source: 'source-1'\n      });\n      atom.config.set('a.b', 2, {\n        scopeSelector: '.x2',\n        source: 'source-2'\n      });\n      atom.config.set('a.b', 1, {\n        scopeSelector: '.x3',\n        source: 'source-3'\n      });\n      expect(atom.config.getSources()).toEqual(['source-1', 'source-2', 'source-3']);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the save callback with any non-default properties",
            "suites": [
                "Config",
                ".save()"
            ],
            "updatePoint": {
                "line": 1030,
                "column": 63
            },
            "line": 1030,
            "code": "    it('calls the save callback with any non-default properties', () => {\n      atom.config.set('a.b.c', 1);\n      atom.config.set('a.b.d', 2);\n      atom.config.set('x.y.z', 3);\n      atom.config.setDefaults('a.b', {\n        e: 4,\n        f: 5\n      });\n      atom.config.save();\n      expect(savedSettings).toEqual([{\n        '*': atom.config.settings\n      }]);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "serializes properties in alphabetical order",
            "suites": [
                "Config",
                ".save()"
            ],
            "updatePoint": {
                "line": 1043,
                "column": 51
            },
            "line": 1043,
            "code": "    it('serializes properties in alphabetical order', () => {\n      atom.config.set('foo', 1);\n      atom.config.set('bar', 2);\n      atom.config.set('baz.foo', 3);\n      atom.config.set('baz.bar', 4);\n      savedSettings.length = 0;\n      atom.config.save();\n      const writtenConfig = savedSettings[0];\n      expect(writtenConfig).toEqual({\n        '*': atom.config.settings\n      });\n      let expectedKeys = ['bar', 'baz', 'foo'];\n      let foundKeys = [];\n\n      for (const key in writtenConfig['*']) {\n        if (expectedKeys.includes(key)) {\n          foundKeys.push(key);\n        }\n      }\n\n      expect(foundKeys).toEqual(expectedKeys);\n      expectedKeys = ['bar', 'foo'];\n      foundKeys = [];\n\n      for (const key in writtenConfig['*']['baz']) {\n        if (expectedKeys.includes(key)) {\n          foundKeys.push(key);\n        }\n      }\n\n      expect(foundKeys).toEqual(expectedKeys);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "serializes any explicitly set config settings",
            "suites": [
                "Config",
                ".save()",
                "when scoped settings are defined"
            ],
            "updatePoint": {
                "line": 1076,
                "column": 55
            },
            "line": 1076,
            "code": "      it('serializes any explicitly set config settings', () => {\n        atom.config.set('foo.bar', 'ruby', {\n          scopeSelector: '.source.ruby'\n        });\n        atom.config.set('foo.omg', 'wow', {\n          scopeSelector: '.source.ruby'\n        });\n        atom.config.set('foo.bar', 'coffee', {\n          scopeSelector: '.source.coffee'\n        });\n        savedSettings.length = 0;\n        atom.config.save();\n        const writtenConfig = savedSettings[0];\n        expect(writtenConfig).toEqualJson({\n          '*': atom.config.settings,\n          '.ruby.source': {\n            foo: {\n              bar: 'ruby',\n              omg: 'wow'\n            }\n          },\n          '.coffee.source': {\n            foo: {\n              bar: 'coffee'\n            }\n          }\n        });\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the config data based on the file contents",
            "suites": [
                "Config",
                ".resetUserSettings()",
                "when the config file contains scoped settings"
            ],
            "updatePoint": {
                "line": 1123,
                "column": 60
            },
            "line": 1123,
            "code": "      it('updates the config data based on the file contents', () => {\n        atom.config.resetUserSettings({\n          '*': {\n            foo: {\n              bar: 'baz'\n            }\n          },\n          '.source.ruby': {\n            foo: {\n              bar: 'more-specific'\n            }\n          }\n        });\n        expect(atom.config.get('foo.bar')).toBe('baz');\n        expect(atom.config.get('foo.bar', {\n          scope: ['.source.ruby']\n        })).toBe('more-specific');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "validates and does not load the incorrect values",
            "suites": [
                "Config",
                ".resetUserSettings()",
                "when the config file does not conform to the schema"
            ],
            "updatePoint": {
                "line": 1143,
                "column": 58
            },
            "line": 1143,
            "code": "      it('validates and does not load the incorrect values', () => {\n        atom.config.resetUserSettings({\n          '*': {\n            foo: {\n              bar: 'omg',\n              int: 'baz'\n            }\n          },\n          '.source.ruby': {\n            foo: {\n              bar: 'scoped',\n              int: 'nope'\n            }\n          }\n        });\n        expect(atom.config.get('foo.int')).toBe(12);\n        expect(atom.config.get('foo.bar')).toBe('omg');\n        expect(atom.config.get('foo.int', {\n          scope: ['.source.ruby']\n        })).toBe(12);\n        expect(atom.config.get('foo.bar', {\n          scope: ['.source.ruby']\n        })).toBe('scoped');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the config data based on the file contents",
            "suites": [
                "Config",
                ".resetUserSettings()",
                "when the config file does not conform to the schema"
            ],
            "updatePoint": {
                "line": 1168,
                "column": 58
            },
            "line": 1168,
            "code": "    it('updates the config data based on the file contents', () => {\n      atom.config.resetUserSettings({\n        foo: {\n          bar: 'baz'\n        }\n      });\n      expect(atom.config.get('foo.bar')).toBe('baz');\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies observers for updated keypaths on load",
            "suites": [
                "Config",
                ".resetUserSettings()",
                "when the config file does not conform to the schema"
            ],
            "updatePoint": {
                "line": 1176,
                "column": 55
            },
            "line": 1176,
            "code": "    it('notifies observers for updated keypaths on load', () => {\n      const observeHandler = jasmine.createSpy('observeHandler');\n      atom.config.observe('foo.bar', observeHandler);\n      atom.config.resetUserSettings({\n        foo: {\n          bar: 'baz'\n        }\n      });\n      expect(observeHandler).toHaveBeenCalledWith('baz');\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the only the settings that have values matching the schema",
            "suites": [
                "Config",
                ".resetUserSettings()",
                "when the config file contains values that do not adhere to the schema"
            ],
            "updatePoint": {
                "line": 1187,
                "column": 76
            },
            "line": 1187,
            "code": "      it('updates the only the settings that have values matching the schema', () => {\n        atom.config.resetUserSettings({\n          foo: {\n            bar: 'baz',\n            int: 'bad value'\n          }\n        });\n        expect(atom.config.get('foo.bar')).toBe('baz');\n        expect(atom.config.get('foo.int')).toBe(12);\n        expect(console.warn).toHaveBeenCalled();\n        expect(console.warn.mostRecentCall.args[0]).toContain('foo.int');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not fire a change event for paths that did not change",
            "suites": [
                "Config",
                ".resetUserSettings()",
                "when the config file contains values that do not adhere to the schema"
            ],
            "updatePoint": {
                "line": 1200,
                "column": 66
            },
            "line": 1200,
            "code": "    it('does not fire a change event for paths that did not change', () => {\n      atom.config.resetUserSettings({\n        foo: {\n          bar: 'baz',\n          int: 3\n        }\n      });\n      const noChangeSpy = jasmine.createSpy('unchanged');\n      atom.config.onDidChange('foo.bar', noChangeSpy);\n      atom.config.resetUserSettings({\n        foo: {\n          bar: 'baz',\n          int: 4\n        }\n      });\n      expect(noChangeSpy).not.toHaveBeenCalled();\n      expect(atom.config.get('foo.bar')).toBe('baz');\n      expect(atom.config.get('foo.int')).toBe(4);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not fire a change event for paths whose non-primitive values did not change",
            "suites": [
                "Config",
                ".resetUserSettings()",
                "when the config file contains values that do not adhere to the schema"
            ],
            "updatePoint": {
                "line": 1219,
                "column": 88
            },
            "line": 1219,
            "code": "    it('does not fire a change event for paths whose non-primitive values did not change', () => {\n      atom.config.setSchema('foo.bar', {\n        type: 'array',\n        items: {\n          type: 'string'\n        }\n      });\n      atom.config.resetUserSettings({\n        foo: {\n          bar: ['baz', 'quux'],\n          int: 2\n        }\n      });\n      const noChangeSpy = jasmine.createSpy('unchanged');\n      atom.config.onDidChange('foo.bar', noChangeSpy);\n      atom.config.resetUserSettings({\n        foo: {\n          bar: ['baz', 'quux'],\n          int: 2\n        }\n      });\n      expect(noChangeSpy).not.toHaveBeenCalled();\n      expect(atom.config.get('foo.bar')).toEqual(['baz', 'quux']);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resets the setting back to the default",
            "suites": [
                "Config",
                ".resetUserSettings()",
                "when a setting with a default is removed"
            ],
            "updatePoint": {
                "line": 1244,
                "column": 48
            },
            "line": 1244,
            "code": "      it('resets the setting back to the default', () => {\n        atom.config.resetUserSettings({\n          foo: {\n            bar: ['baz', 'quux'],\n            int: 2\n          }\n        });\n        const events = [];\n        atom.config.onDidChange('foo.int', event => events.push(event));\n        atom.config.resetUserSettings({\n          foo: {\n            bar: ['baz', 'quux']\n          }\n        });\n        expect(events.length).toBe(1);\n        expect(events[0]).toEqual({\n          oldValue: 2,\n          newValue: 12\n        });\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps all the global scope settings after overriding one",
            "suites": [
                "Config",
                ".resetUserSettings()",
                "when a setting with a default is removed"
            ],
            "updatePoint": {
                "line": 1265,
                "column": 64
            },
            "line": 1265,
            "code": "    it('keeps all the global scope settings after overriding one', () => {\n      atom.config.resetUserSettings({\n        '*': {\n          foo: {\n            bar: 'baz',\n            int: 99\n          }\n        }\n      });\n      atom.config.set('foo.int', 50, {\n        scopeSelector: '*'\n      });\n      advanceClock(100);\n      expect(savedSettings[0]['*'].foo).toEqual({\n        bar: 'baz',\n        int: 50\n      });\n      expect(atom.config.get('foo.int', {\n        scope: ['*']\n      })).toEqual(50);\n      expect(atom.config.get('foo.bar', {\n        scope: ['*']\n      })).toEqual('baz');\n      expect(atom.config.get('foo.int')).toEqual(50);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "pushes the given value to the array at the key path and updates observers",
            "suites": [
                "Config",
                ".pushAtKeyPath(keyPath, value)"
            ],
            "updatePoint": {
                "line": 1292,
                "column": 81
            },
            "line": 1292,
            "code": "    it('pushes the given value to the array at the key path and updates observers', () => {\n      atom.config.set('foo.bar.baz', ['a']);\n      const observeHandler = jasmine.createSpy('observeHandler');\n      atom.config.observe('foo.bar.baz', observeHandler);\n      observeHandler.reset();\n      expect(atom.config.pushAtKeyPath('foo.bar.baz', 'b')).toBe(2);\n      expect(atom.config.get('foo.bar.baz')).toEqual(['a', 'b']);\n      expect(observeHandler).toHaveBeenCalledWith(atom.config.get('foo.bar.baz'));\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "unshifts the given value to the array at the key path and updates observers",
            "suites": [
                "Config",
                ".unshiftAtKeyPath(keyPath, value)"
            ],
            "updatePoint": {
                "line": 1303,
                "column": 83
            },
            "line": 1303,
            "code": "    it('unshifts the given value to the array at the key path and updates observers', () => {\n      atom.config.set('foo.bar.baz', ['b']);\n      const observeHandler = jasmine.createSpy('observeHandler');\n      atom.config.observe('foo.bar.baz', observeHandler);\n      observeHandler.reset();\n      expect(atom.config.unshiftAtKeyPath('foo.bar.baz', 'a')).toBe(2);\n      expect(atom.config.get('foo.bar.baz')).toEqual(['a', 'b']);\n      expect(observeHandler).toHaveBeenCalledWith(atom.config.get('foo.bar.baz'));\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the given value from the array at the key path and updates observers",
            "suites": [
                "Config",
                ".removeAtKeyPath(keyPath, value)"
            ],
            "updatePoint": {
                "line": 1314,
                "column": 84
            },
            "line": 1314,
            "code": "    it('removes the given value from the array at the key path and updates observers', () => {\n      atom.config.set('foo.bar.baz', ['a', 'b', 'c']);\n      const observeHandler = jasmine.createSpy('observeHandler');\n      atom.config.observe('foo.bar.baz', observeHandler);\n      observeHandler.reset();\n      expect(atom.config.removeAtKeyPath('foo.bar.baz', 'b')).toEqual(['a', 'c']);\n      expect(atom.config.get('foo.bar.baz')).toEqual(['a', 'c']);\n      expect(observeHandler).toHaveBeenCalledWith(atom.config.get('foo.bar.baz'));\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "assigns any previously-unassigned keys to the object at the key path",
            "suites": [
                "Config",
                ".setDefaults(keyPath, defaults)"
            ],
            "updatePoint": {
                "line": 1325,
                "column": 76
            },
            "line": 1325,
            "code": "    it('assigns any previously-unassigned keys to the object at the key path', () => {\n      atom.config.set('foo.bar.baz', {\n        a: 1\n      });\n      atom.config.setDefaults('foo.bar.baz', {\n        a: 2,\n        b: 3,\n        c: 4\n      });\n      expect(atom.config.get('foo.bar.baz.a')).toBe(1);\n      expect(atom.config.get('foo.bar.baz.b')).toBe(3);\n      expect(atom.config.get('foo.bar.baz.c')).toBe(4);\n      atom.config.setDefaults('foo.quux', {\n        x: 0,\n        y: 1\n      });\n      expect(atom.config.get('foo.quux.x')).toBe(0);\n      expect(atom.config.get('foo.quux.y')).toBe(1);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits an updated event",
            "suites": [
                "Config",
                ".setDefaults(keyPath, defaults)"
            ],
            "updatePoint": {
                "line": 1344,
                "column": 30
            },
            "line": 1344,
            "code": "    it('emits an updated event', () => {\n      const updatedCallback = jasmine.createSpy('updated');\n      atom.config.onDidChange('foo.bar.baz.a', updatedCallback);\n      expect(updatedCallback.callCount).toBe(0);\n      atom.config.setDefaults('foo.bar.baz', {\n        a: 2\n      });\n      expect(updatedCallback.callCount).toBe(1);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a properly nested schema",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)"
            ],
            "updatePoint": {
                "line": 1355,
                "column": 40
            },
            "line": 1355,
            "code": "    it('creates a properly nested schema', () => {\n      const schema = {\n        type: 'object',\n        properties: {\n          anInt: {\n            type: 'integer',\n            default: 12\n          }\n        }\n      };\n      atom.config.setSchema('foo.bar', schema);\n      expect(atom.config.getSchema('foo')).toEqual({\n        type: 'object',\n        properties: {\n          bar: {\n            type: 'object',\n            properties: {\n              anInt: {\n                type: 'integer',\n                default: 12\n              }\n            }\n          }\n        }\n      });\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets defaults specified by the schema",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)"
            ],
            "updatePoint": {
                "line": 1381,
                "column": 45
            },
            "line": 1381,
            "code": "    it('sets defaults specified by the schema', () => {\n      const schema = {\n        type: 'object',\n        properties: {\n          anInt: {\n            type: 'integer',\n            default: 12\n          },\n          anObject: {\n            type: 'object',\n            properties: {\n              nestedInt: {\n                type: 'integer',\n                default: 24\n              },\n              nestedObject: {\n                type: 'object',\n                properties: {\n                  superNestedInt: {\n                    type: 'integer',\n                    default: 36\n                  }\n                }\n              }\n            }\n          }\n        }\n      };\n      atom.config.setSchema('foo.bar', schema);\n      expect(atom.config.get('foo.bar.anInt')).toBe(12);\n      expect(atom.config.get('foo.bar.anObject')).toEqual({\n        nestedInt: 24,\n        nestedObject: {\n          superNestedInt: 36\n        }\n      });\n      expect(atom.config.get('foo')).toEqual({\n        bar: {\n          anInt: 12,\n          anObject: {\n            nestedInt: 24,\n            nestedObject: {\n              superNestedInt: 36\n            }\n          }\n        }\n      });\n      atom.config.set('foo.bar.anObject.nestedObject.superNestedInt', 37);\n      expect(atom.config.get('foo')).toEqual({\n        bar: {\n          anInt: 12,\n          anObject: {\n            nestedInt: 24,\n            nestedObject: {\n              superNestedInt: 37\n            }\n          }\n        }\n      });\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can set a non-object schema",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)"
            ],
            "updatePoint": {
                "line": 1441,
                "column": 35
            },
            "line": 1441,
            "code": "    it('can set a non-object schema', () => {\n      const schema = {\n        type: 'integer',\n        default: 12\n      };\n      atom.config.setSchema('foo.bar.anInt', schema);\n      expect(atom.config.get('foo.bar.anInt')).toBe(12);\n      expect(atom.config.getSchema('foo.bar.anInt')).toEqual({\n        type: 'integer',\n        default: 12\n      });\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows the schema to be retrieved via ::getSchema",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)"
            ],
            "updatePoint": {
                "line": 1453,
                "column": 57
            },
            "line": 1453,
            "code": "    it('allows the schema to be retrieved via ::getSchema', () => {\n      const schema = {\n        type: 'object',\n        properties: {\n          anInt: {\n            type: 'integer',\n            default: 12\n          }\n        }\n      };\n      atom.config.setSchema('foo.bar', schema);\n      expect(atom.config.getSchema('foo.bar')).toEqual({\n        type: 'object',\n        properties: {\n          anInt: {\n            type: 'integer',\n            default: 12\n          }\n        }\n      });\n      expect(atom.config.getSchema('foo.bar.anInt')).toEqual({\n        type: 'integer',\n        default: 12\n      });\n      expect(atom.config.getSchema('foo.baz')).toEqual({\n        type: 'any'\n      });\n      expect(atom.config.getSchema('foo.bar.anInt.baz')).toBe(null);\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "respects the schema for scoped settings",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)"
            ],
            "updatePoint": {
                "line": 1482,
                "column": 47
            },
            "line": 1482,
            "code": "    it('respects the schema for scoped settings', () => {\n      const schema = {\n        type: 'string',\n        default: 'ok',\n        scopes: {\n          '.source.js': {\n            default: 'omg'\n          }\n        }\n      };\n      atom.config.setSchema('foo.bar.str', schema);\n      expect(atom.config.get('foo.bar.str')).toBe('ok');\n      expect(atom.config.get('foo.bar.str', {\n        scope: ['.source.js']\n      })).toBe('omg');\n      expect(atom.config.get('foo.bar.str', {\n        scope: ['.source.coffee']\n      })).toBe('ok');\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "respects the new schema when values are set",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when a schema is added after config values have been set"
            ],
            "updatePoint": {
                "line": 1518,
                "column": 53
            },
            "line": 1518,
            "code": "      it('respects the new schema when values are set', () => {\n        expect(atom.config.set('foo.bar.str', 'global')).toBe(true);\n        expect(atom.config.set('foo.bar.str', 'scoped', {\n          scopeSelector: '.source.js'\n        })).toBe(true);\n        expect(atom.config.get('foo.bar.str')).toBe('global');\n        expect(atom.config.get('foo.bar.str', {\n          scope: ['.source.js']\n        })).toBe('scoped');\n        expect(atom.config.set('foo.bar.noschema', 'nsGlobal')).toBe(true);\n        expect(atom.config.set('foo.bar.noschema', 'nsScoped', {\n          scopeSelector: '.source.js'\n        })).toBe(true);\n        expect(atom.config.get('foo.bar.noschema')).toBe('nsGlobal');\n        expect(atom.config.get('foo.bar.noschema', {\n          scope: ['.source.js']\n        })).toBe('nsScoped');\n        expect(atom.config.set('foo.bar.int', 'nope')).toBe(true);\n        expect(atom.config.set('foo.bar.int', 'notanint', {\n          scopeSelector: '.source.js'\n        })).toBe(true);\n        expect(atom.config.set('foo.bar.int', 23, {\n          scopeSelector: '.source.coffee'\n        })).toBe(true);\n        expect(atom.config.get('foo.bar.int')).toBe('nope');\n        expect(atom.config.get('foo.bar.int', {\n          scope: ['.source.js']\n        })).toBe('notanint');\n        expect(atom.config.get('foo.bar.int', {\n          scope: ['.source.coffee']\n        })).toBe(23);\n        atom.config.setSchema('foo.bar', schema);\n        expect(atom.config.get('foo.bar.str')).toBe('global');\n        expect(atom.config.get('foo.bar.str', {\n          scope: ['.source.js']\n        })).toBe('scoped');\n        expect(atom.config.get('foo.bar.noschema')).toBe('nsGlobal');\n        expect(atom.config.get('foo.bar.noschema', {\n          scope: ['.source.js']\n        })).toBe('nsScoped');\n        expect(atom.config.get('foo.bar.int')).toBe(2);\n        expect(atom.config.get('foo.bar.int', {\n          scope: ['.source.js']\n        })).toBe(2);\n        expect(atom.config.get('foo.bar.int', {\n          scope: ['.source.coffee']\n        })).toBe(23);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets all values that adhere to the schema",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when a schema is added after config values have been set"
            ],
            "updatePoint": {
                "line": 1566,
                "column": 51
            },
            "line": 1566,
            "code": "      it('sets all values that adhere to the schema', () => {\n        expect(atom.config.set('foo.bar.int', 10)).toBe(true);\n        expect(atom.config.set('foo.bar.int', 15, {\n          scopeSelector: '.source.js'\n        })).toBe(true);\n        expect(atom.config.set('foo.bar.int', 23, {\n          scopeSelector: '.source.coffee'\n        })).toBe(true);\n        expect(atom.config.get('foo.bar.int')).toBe(10);\n        expect(atom.config.get('foo.bar.int', {\n          scope: ['.source.js']\n        })).toBe(15);\n        expect(atom.config.get('foo.bar.int', {\n          scope: ['.source.coffee']\n        })).toBe(23);\n        atom.config.setSchema('foo.bar', schema);\n        expect(atom.config.get('foo.bar.int')).toBe(10);\n        expect(atom.config.get('foo.bar.int', {\n          scope: ['.source.js']\n        })).toBe(15);\n        expect(atom.config.get('foo.bar.int', {\n          scope: ['.source.coffee']\n        })).toBe(23);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "coerces a string to an int",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"integer\" type"
            ],
            "updatePoint": {
                "line": 1599,
                "column": 36
            },
            "line": 1599,
            "code": "      it('coerces a string to an int', () => {\n        atom.config.set('foo.bar.anInt', '123');\n        expect(atom.config.get('foo.bar.anInt')).toBe(123);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not allow infinity",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"integer\" type"
            ],
            "updatePoint": {
                "line": 1603,
                "column": 33
            },
            "line": 1603,
            "code": "      it('does not allow infinity', () => {\n        atom.config.set('foo.bar.anInt', Infinity);\n        expect(atom.config.get('foo.bar.anInt')).toBe(12);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "coerces a float to an int",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"integer\" type"
            ],
            "updatePoint": {
                "line": 1607,
                "column": 35
            },
            "line": 1607,
            "code": "      it('coerces a float to an int', () => {\n        atom.config.set('foo.bar.anInt', 12.3);\n        expect(atom.config.get('foo.bar.anInt')).toBe(12);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will not set non-integers",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"integer\" type"
            ],
            "updatePoint": {
                "line": 1611,
                "column": 35
            },
            "line": 1611,
            "code": "      it('will not set non-integers', () => {\n        atom.config.set('foo.bar.anInt', null);\n        expect(atom.config.get('foo.bar.anInt')).toBe(12);\n        atom.config.set('foo.bar.anInt', 'nope');\n        expect(atom.config.get('foo.bar.anInt')).toBe(12);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the specified value within the specified range",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"integer\" type",
                "when the minimum and maximum keys are used"
            ],
            "updatePoint": {
                "line": 1627,
                "column": 64
            },
            "line": 1627,
            "code": "        it('keeps the specified value within the specified range', () => {\n          atom.config.set('foo.bar.anInt', '123');\n          expect(atom.config.get('foo.bar.anInt')).toBe(20);\n          atom.config.set('foo.bar.anInt', '1');\n          expect(atom.config.get('foo.bar.anInt')).toBe(10);\n        });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can coerce an int, and fallback to a string",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"integer\" and \"string\" type"
            ],
            "updatePoint": {
                "line": 1643,
                "column": 53
            },
            "line": 1643,
            "code": "      it('can coerce an int, and fallback to a string', () => {\n        atom.config.set('foo.bar.anInt', '123');\n        expect(atom.config.get('foo.bar.anInt')).toBe(123);\n        atom.config.set('foo.bar.anInt', 'cats');\n        expect(atom.config.get('foo.bar.anInt')).toBe('cats');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can set a string, a boolean, and revert back to the default",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"string\" and \"boolean\" type"
            ],
            "updatePoint": {
                "line": 1658,
                "column": 69
            },
            "line": 1658,
            "code": "      it('can set a string, a boolean, and revert back to the default', () => {\n        atom.config.set('foo.bar', 'ok');\n        expect(atom.config.get('foo.bar')).toBe('ok');\n        atom.config.set('foo.bar', false);\n        expect(atom.config.get('foo.bar')).toBe(false);\n        atom.config.set('foo.bar', undefined);\n        expect(atom.config.get('foo.bar')).toBe('def');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "coerces a string to a float",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has a \"number\" type"
            ],
            "updatePoint": {
                "line": 1675,
                "column": 37
            },
            "line": 1675,
            "code": "      it('coerces a string to a float', () => {\n        atom.config.set('foo.bar.aFloat', '12.23');\n        expect(atom.config.get('foo.bar.aFloat')).toBe(12.23);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will not set non-numbers",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has a \"number\" type"
            ],
            "updatePoint": {
                "line": 1679,
                "column": 34
            },
            "line": 1679,
            "code": "      it('will not set non-numbers', () => {\n        atom.config.set('foo.bar.aFloat', null);\n        expect(atom.config.get('foo.bar.aFloat')).toBe(12.1);\n        atom.config.set('foo.bar.aFloat', 'nope');\n        expect(atom.config.get('foo.bar.aFloat')).toBe(12.1);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the specified value within the specified range",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has a \"number\" type",
                "when the minimum and maximum keys are used"
            ],
            "updatePoint": {
                "line": 1695,
                "column": 64
            },
            "line": 1695,
            "code": "        it('keeps the specified value within the specified range', () => {\n          atom.config.set('foo.bar.aFloat', '123.2');\n          expect(atom.config.get('foo.bar.aFloat')).toBe(25.4);\n          atom.config.set('foo.bar.aFloat', '1.0');\n          expect(atom.config.get('foo.bar.aFloat')).toBe(11.2);\n        });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "coerces various types to a boolean",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has a \"boolean\" type"
            ],
            "updatePoint": {
                "line": 1711,
                "column": 44
            },
            "line": 1711,
            "code": "      it('coerces various types to a boolean', () => {\n        atom.config.set('foo.bar.aBool', 'true');\n        expect(atom.config.get('foo.bar.aBool')).toBe(true);\n        atom.config.set('foo.bar.aBool', 'false');\n        expect(atom.config.get('foo.bar.aBool')).toBe(false);\n        atom.config.set('foo.bar.aBool', 'TRUE');\n        expect(atom.config.get('foo.bar.aBool')).toBe(true);\n        atom.config.set('foo.bar.aBool', 'FALSE');\n        expect(atom.config.get('foo.bar.aBool')).toBe(false);\n        atom.config.set('foo.bar.aBool', 1);\n        expect(atom.config.get('foo.bar.aBool')).toBe(false);\n        atom.config.set('foo.bar.aBool', 0);\n        expect(atom.config.get('foo.bar.aBool')).toBe(false);\n        atom.config.set('foo.bar.aBool', {});\n        expect(atom.config.get('foo.bar.aBool')).toBe(false);\n        atom.config.set('foo.bar.aBool', null);\n        expect(atom.config.get('foo.bar.aBool')).toBe(false);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reverts back to the default value when undefined is passed to set",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has a \"boolean\" type"
            ],
            "updatePoint": {
                "line": 1729,
                "column": 75
            },
            "line": 1729,
            "code": "      it('reverts back to the default value when undefined is passed to set', () => {\n        atom.config.set('foo.bar.aBool', 'false');\n        expect(atom.config.get('foo.bar.aBool')).toBe(false);\n        atom.config.set('foo.bar.aBool', undefined);\n        expect(atom.config.get('foo.bar.aBool')).toBe(true);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows strings",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"string\" type"
            ],
            "updatePoint": {
                "line": 1744,
                "column": 24
            },
            "line": 1744,
            "code": "      it('allows strings', () => {\n        atom.config.set('foo.bar.aString', 'yep');\n        expect(atom.config.get('foo.bar.aString')).toBe('yep');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will only set strings",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"string\" type"
            ],
            "updatePoint": {
                "line": 1748,
                "column": 31
            },
            "line": 1748,
            "code": "      it('will only set strings', () => {\n        expect(atom.config.set('foo.bar.aString', 123)).toBe(false);\n        expect(atom.config.get('foo.bar.aString')).toBe('ok');\n        expect(atom.config.set('foo.bar.aString', true)).toBe(false);\n        expect(atom.config.get('foo.bar.aString')).toBe('ok');\n        expect(atom.config.set('foo.bar.aString', null)).toBe(false);\n        expect(atom.config.get('foo.bar.aString')).toBe('ok');\n        expect(atom.config.set('foo.bar.aString', [])).toBe(false);\n        expect(atom.config.get('foo.bar.aString')).toBe('ok');\n        expect(atom.config.set('foo.bar.aString', {\n          nope: 'nope'\n        })).toBe(false);\n        expect(atom.config.get('foo.bar.aString')).toBe('ok');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not allow setting children of that key-path",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"string\" type"
            ],
            "updatePoint": {
                "line": 1762,
                "column": 58
            },
            "line": 1762,
            "code": "      it('does not allow setting children of that key-path', () => {\n        expect(atom.config.set('foo.bar.aString.something', 123)).toBe(false);\n        expect(atom.config.get('foo.bar.aString')).toBe('ok');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "trims the string to be no longer than the specified maximum",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"string\" type",
                "when the schema has a \"maximumLength\" key"
            ],
            "updatePoint": {
                "line": 1766,
                "column": 129
            },
            "line": 1766,
            "code": "      describe('when the schema has a \"maximumLength\" key', () => it('trims the string to be no longer than the specified maximum', () => {\n        const schema = {\n          type: 'string',\n          default: 'ok',\n          maximumLength: 3\n        };\n        atom.config.setSchema('foo.bar.aString', schema);\n        atom.config.set('foo.bar.aString', 'abcdefg');\n        expect(atom.config.get('foo.bar.aString')).toBe('abc');\n      }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "converts and validates all the children",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"object\" type"
            ],
            "updatePoint": {
                "line": 1799,
                "column": 49
            },
            "line": 1799,
            "code": "      it('converts and validates all the children', () => {\n        atom.config.set('foo.bar', {\n          anInt: '23',\n          nestedObject: {\n            nestedBool: 'true'\n          }\n        });\n        expect(atom.config.get('foo.bar')).toEqual({\n          anInt: 23,\n          nestedObject: {\n            nestedBool: true\n          }\n        });\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will set only the values that adhere to the schema",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"object\" type"
            ],
            "updatePoint": {
                "line": 1813,
                "column": 60
            },
            "line": 1813,
            "code": "      it('will set only the values that adhere to the schema', () => {\n        expect(atom.config.set('foo.bar', {\n          anInt: 'nope',\n          nestedObject: {\n            nestedBool: true\n          }\n        })).toBe(true);\n        expect(atom.config.get('foo.bar.anInt')).toEqual(12);\n        expect(atom.config.get('foo.bar.nestedObject.nestedBool')).toEqual(true);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not allow other properties to be set on the object",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"object\" type",
                "when the value has additionalProperties set to false"
            ],
            "updatePoint": {
                "line": 1823,
                "column": 136
            },
            "line": 1823,
            "code": "      describe('when the value has additionalProperties set to false', () => it('does not allow other properties to be set on the object', () => {\n        atom.config.setSchema('foo.bar', {\n          type: 'object',\n          properties: {\n            anInt: {\n              type: 'integer',\n              default: 12\n            }\n          },\n          additionalProperties: false\n        });\n        expect(atom.config.set('foo.bar', {\n          anInt: 5,\n          somethingElse: 'ok'\n        })).toBe(true);\n        expect(atom.config.get('foo.bar.anInt')).toBe(5);\n        expect(atom.config.get('foo.bar.somethingElse')).toBeUndefined();\n        expect(atom.config.set('foo.bar.somethingElse', {\n          anInt: 5\n        })).toBe(false);\n        expect(atom.config.get('foo.bar.somethingElse')).toBeUndefined();\n      }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "validates properties of the object against that schema",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"object\" type",
                "when the value has an additionalProperties schema"
            ],
            "updatePoint": {
                "line": 1845,
                "column": 132
            },
            "line": 1845,
            "code": "      describe('when the value has an additionalProperties schema', () => it('validates properties of the object against that schema', () => {\n        atom.config.setSchema('foo.bar', {\n          type: 'object',\n          properties: {\n            anInt: {\n              type: 'integer',\n              default: 12\n            }\n          },\n          additionalProperties: {\n            type: 'string'\n          }\n        });\n        expect(atom.config.set('foo.bar', {\n          anInt: 5,\n          somethingElse: 'ok'\n        })).toBe(true);\n        expect(atom.config.get('foo.bar.anInt')).toBe(5);\n        expect(atom.config.get('foo.bar.somethingElse')).toBe('ok');\n        expect(atom.config.set('foo.bar.somethingElse', 7)).toBe(false);\n        expect(atom.config.get('foo.bar.somethingElse')).toBe('ok');\n        expect(atom.config.set('foo.bar', {\n          anInt: 6,\n          somethingElse: 7\n        })).toBe(true);\n        expect(atom.config.get('foo.bar.anInt')).toBe(6);\n        expect(atom.config.get('foo.bar.somethingElse')).toBe(undefined);\n      }));",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "converts an array of strings to an array of ints",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"array\" type"
            ],
            "updatePoint": {
                "line": 1885,
                "column": 58
            },
            "line": 1885,
            "code": "      it('converts an array of strings to an array of ints', () => {\n        atom.config.set('foo.bar', ['2', '3', '4']);\n        expect(atom.config.get('foo.bar')).toEqual([2, 3, 4]);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not allow setting children of that key-path",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has an \"array\" type"
            ],
            "updatePoint": {
                "line": 1889,
                "column": 58
            },
            "line": 1889,
            "code": "      it('does not allow setting children of that key-path', () => {\n        expect(atom.config.set('foo.bar.child', 123)).toBe(false);\n        expect(atom.config.set('foo.bar.child.grandchild', 123)).toBe(false);\n        expect(atom.config.get('foo.bar')).toEqual([1, 2, 3]);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a Color object",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has a \"color\" type"
            ],
            "updatePoint": {
                "line": 1903,
                "column": 32
            },
            "line": 1903,
            "code": "      it('returns a Color object', () => {\n        let color = atom.config.get('foo.bar.aColor');\n        expect(color.toHexString()).toBe('#ffffff');\n        expect(color.toRGBAString()).toBe('rgba(255, 255, 255, 1)');\n        color.red = 0;\n        color.green = 0;\n        color.blue = 0;\n        color.alpha = 0;\n        atom.config.set('foo.bar.aColor', color);\n        color = atom.config.get('foo.bar.aColor');\n        expect(color.toHexString()).toBe('#000000');\n        expect(color.toRGBAString()).toBe('rgba(0, 0, 0, 0)');\n        color.red = 300;\n        color.green = -200;\n        color.blue = -1;\n        color.alpha = 'not see through';\n        atom.config.set('foo.bar.aColor', color);\n        color = atom.config.get('foo.bar.aColor');\n        expect(color.toHexString()).toBe('#ff0000');\n        expect(color.toRGBAString()).toBe('rgba(255, 0, 0, 1)');\n        color.red = 11;\n        color.green = 11;\n        color.blue = 124;\n        color.alpha = 1;\n        atom.config.set('foo.bar.aColor', color);\n        color = atom.config.get('foo.bar.aColor');\n        expect(color.toHexString()).toBe('#0b0b7c');\n        expect(color.toRGBAString()).toBe('rgba(11, 11, 124, 1)');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "coerces various types to a color object",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has a \"color\" type"
            ],
            "updatePoint": {
                "line": 1932,
                "column": 49
            },
            "line": 1932,
            "code": "      it('coerces various types to a color object', () => {\n        atom.config.set('foo.bar.aColor', 'red');\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 255,\n          green: 0,\n          blue: 0,\n          alpha: 1\n        });\n        atom.config.set('foo.bar.aColor', '#020');\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 0,\n          green: 34,\n          blue: 0,\n          alpha: 1\n        });\n        atom.config.set('foo.bar.aColor', '#abcdef');\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 171,\n          green: 205,\n          blue: 239,\n          alpha: 1\n        });\n        atom.config.set('foo.bar.aColor', 'rgb(1,2,3)');\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 1,\n          green: 2,\n          blue: 3,\n          alpha: 1\n        });\n        atom.config.set('foo.bar.aColor', 'rgba(4,5,6,.7)');\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 4,\n          green: 5,\n          blue: 6,\n          alpha: 0.7\n        });\n        atom.config.set('foo.bar.aColor', 'hsl(120,100%,50%)');\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 0,\n          green: 255,\n          blue: 0,\n          alpha: 1\n        });\n        atom.config.set('foo.bar.aColor', 'hsla(120,100%,50%,0.3)');\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 0,\n          green: 255,\n          blue: 0,\n          alpha: 0.3\n        });\n        atom.config.set('foo.bar.aColor', {\n          red: 100,\n          green: 255,\n          blue: 2,\n          alpha: 0.5\n        });\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 100,\n          green: 255,\n          blue: 2,\n          alpha: 0.5\n        });\n        atom.config.set('foo.bar.aColor', {\n          red: 255\n        });\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 255,\n          green: 0,\n          blue: 0,\n          alpha: 1\n        });\n        atom.config.set('foo.bar.aColor', {\n          red: 1000\n        });\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 255,\n          green: 0,\n          blue: 0,\n          alpha: 1\n        });\n        atom.config.set('foo.bar.aColor', {\n          red: 'dark'\n        });\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 0,\n          green: 0,\n          blue: 0,\n          alpha: 1\n        });\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reverts back to the default value when undefined is passed to set",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has a \"color\" type"
            ],
            "updatePoint": {
                "line": 2022,
                "column": 75
            },
            "line": 2022,
            "code": "      it('reverts back to the default value when undefined is passed to set', () => {\n        atom.config.set('foo.bar.aColor', undefined);\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 255,\n          green: 255,\n          blue: 255,\n          alpha: 1\n        });\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will not set non-colors",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has a \"color\" type"
            ],
            "updatePoint": {
                "line": 2031,
                "column": 33
            },
            "line": 2031,
            "code": "      it('will not set non-colors', () => {\n        atom.config.set('foo.bar.aColor', null);\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 255,\n          green: 255,\n          blue: 255,\n          alpha: 1\n        });\n        atom.config.set('foo.bar.aColor', 'nope');\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 255,\n          green: 255,\n          blue: 255,\n          alpha: 1\n        });\n        atom.config.set('foo.bar.aColor', 30);\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 255,\n          green: 255,\n          blue: 255,\n          alpha: 1\n        });\n        atom.config.set('foo.bar.aColor', false);\n        expect(atom.config.get('foo.bar.aColor')).toEqual({\n          red: 255,\n          green: 255,\n          blue: 255,\n          alpha: 1\n        });\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a clone of the Color when returned in a parent object",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the value has a \"color\" type"
            ],
            "updatePoint": {
                "line": 2061,
                "column": 71
            },
            "line": 2061,
            "code": "      it('returns a clone of the Color when returned in a parent object', () => {\n        const color1 = atom.config.get('foo.bar').aColor;\n        const color2 = atom.config.get('foo.bar').aColor;\n        expect(color1.toRGBAString()).toBe('rgba(255, 255, 255, 1)');\n        expect(color2.toRGBAString()).toBe('rgba(255, 255, 255, 1)');\n        expect(color1).not.toBe(color2);\n        expect(color1).toEqual(color2);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will only set a string when the string is in the enum values",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the `enum` key is used"
            ],
            "updatePoint": {
                "line": 2108,
                "column": 70
            },
            "line": 2108,
            "code": "      it('will only set a string when the string is in the enum values', () => {\n        expect(atom.config.set('foo.bar.str', 'nope')).toBe(false);\n        expect(atom.config.get('foo.bar.str')).toBe('ok');\n        expect(atom.config.set('foo.bar.str', 'one')).toBe(true);\n        expect(atom.config.get('foo.bar.str')).toBe('one');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will only set an integer when the integer is in the enum values",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the `enum` key is used"
            ],
            "updatePoint": {
                "line": 2114,
                "column": 73
            },
            "line": 2114,
            "code": "      it('will only set an integer when the integer is in the enum values', () => {\n        expect(atom.config.set('foo.bar.int', '400')).toBe(false);\n        expect(atom.config.get('foo.bar.int')).toBe(2);\n        expect(atom.config.set('foo.bar.int', '3')).toBe(true);\n        expect(atom.config.get('foo.bar.int')).toBe(3);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will only set an array when the array values are in the enum values",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the `enum` key is used"
            ],
            "updatePoint": {
                "line": 2120,
                "column": 77
            },
            "line": 2120,
            "code": "      it('will only set an array when the array values are in the enum values', () => {\n        expect(atom.config.set('foo.bar.arr', ['one', 'five'])).toBe(true);\n        expect(atom.config.get('foo.bar.arr')).toEqual(['one']);\n        expect(atom.config.set('foo.bar.arr', ['two', 'three'])).toBe(true);\n        expect(atom.config.get('foo.bar.arr')).toEqual(['two', 'three']);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will honor the enum when specified as an array",
            "suites": [
                "Config",
                ".setSchema(keyPath, schema)",
                "when the `enum` key is used"
            ],
            "updatePoint": {
                "line": 2126,
                "column": 56
            },
            "line": 2126,
            "code": "      it('will honor the enum when specified as an array', () => {\n        expect(atom.config.set('foo.bar.str_options', 'one')).toBe(true);\n        expect(atom.config.get('foo.bar.str_options')).toEqual('one');\n        expect(atom.config.set('foo.bar.str_options', 'two')).toBe(true);\n        expect(atom.config.get('foo.bar.str_options')).toEqual('two');\n        expect(atom.config.set('foo.bar.str_options', 'One')).toBe(false);\n        expect(atom.config.get('foo.bar.str_options')).toEqual('two');\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ensures that early set and unset calls are replayed after the config is loaded from disk",
            "suites": [
                "Config",
                "when .set/.unset is called prior to .resetUserSettings"
            ],
            "updatePoint": {
                "line": 2140,
                "column": 96
            },
            "line": 2140,
            "code": "    it('ensures that early set and unset calls are replayed after the config is loaded from disk', () => {\n      atom.config.unset('foo.bar');\n      atom.config.set('foo.qux', 'boo');\n      expect(atom.config.get('foo.bar')).toBeUndefined();\n      expect(atom.config.get('foo.qux')).toBe('boo');\n      expect(atom.config.get('do.ray')).toBeUndefined();\n      advanceClock(100);\n      expect(savedSettings.length).toBe(0);\n      atom.config.resetUserSettings({\n        '*': {\n          foo: {\n            bar: 'baz'\n          },\n          do: {\n            ray: 'me'\n          }\n        }\n      });\n      advanceClock(100);\n      expect(savedSettings.length).toBe(1);\n      expect(atom.config.get('foo.bar')).toBeUndefined();\n      expect(atom.config.get('foo.qux')).toBe('boo');\n      expect(atom.config.get('do.ray')).toBe('me');\n    });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gracefully handles invalid config objects",
            "suites": [
                "Config",
                "project specific settings",
                "config.resetProjectSettings"
            ],
            "updatePoint": {
                "line": 2167,
                "column": 51
            },
            "line": 2167,
            "code": "      it('gracefully handles invalid config objects', () => {\n        atom.config.resetProjectSettings({});\n        expect(atom.config.get('foo.bar')).toBeUndefined();\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a deep clone of the property value",
            "suites": [
                "Config",
                "project specific settings",
                "config.get",
                "project settings"
            ],
            "updatePoint": {
                "line": 2175,
                "column": 54
            },
            "line": 2175,
            "code": "        it('returns a deep clone of the property value', () => {\n          atom.config.resetProjectSettings({\n            '*': {\n              value: {\n                array: [1, {\n                  b: 2\n                }, 3]\n              }\n            }\n          }, dummyPath);\n          const retrievedValue = atom.config.get('value');\n          retrievedValue.array[0] = 4;\n          retrievedValue.array[1].b = 2.1;\n          expect(atom.config.get('value')).toEqual({\n            array: [1, {\n              b: 2\n            }, 3]\n          });\n        });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "properly gets project settings",
            "suites": [
                "Config",
                "project specific settings",
                "config.get",
                "project settings"
            ],
            "updatePoint": {
                "line": 2194,
                "column": 42
            },
            "line": 2194,
            "code": "        it('properly gets project settings', () => {\n          atom.config.resetProjectSettings({\n            '*': {\n              foo: 'wei'\n            }\n          }, dummyPath);\n          expect(atom.config.get('foo')).toBe('wei');\n          atom.config.resetProjectSettings({\n            '*': {\n              foo: {\n                bar: 'baz'\n              }\n            }\n          }, dummyPath);\n          expect(atom.config.get('foo.bar')).toBe('baz');\n        });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gets project settings with higher priority than regular settings",
            "suites": [
                "Config",
                "project specific settings",
                "config.get",
                "project settings"
            ],
            "updatePoint": {
                "line": 2210,
                "column": 76
            },
            "line": 2210,
            "code": "        it('gets project settings with higher priority than regular settings', () => {\n          atom.config.set('foo', 'bar');\n          atom.config.resetProjectSettings({\n            '*': {\n              foo: 'baz'\n            }\n          }, dummyPath);\n          expect(atom.config.get('foo')).toBe('baz');\n        });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly gets nested and scoped properties for project settings",
            "suites": [
                "Config",
                "project specific settings",
                "config.get",
                "project settings"
            ],
            "updatePoint": {
                "line": 2219,
                "column": 76
            },
            "line": 2219,
            "code": "        it('correctly gets nested and scoped properties for project settings', () => {\n          expect(atom.config.set('foo.bar.str', 'global')).toBe(true);\n          expect(atom.config.set('foo.bar.str', 'scoped', {\n            scopeSelector: '.source.js'\n          })).toBe(true);\n          expect(atom.config.get('foo.bar.str')).toBe('global');\n          expect(atom.config.get('foo.bar.str', {\n            scope: ['.source.js']\n          })).toBe('scoped');\n        });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a deep clone of the property value",
            "suites": [
                "Config",
                "project specific settings",
                "config.get",
                "project settings"
            ],
            "updatePoint": {
                "line": 2229,
                "column": 54
            },
            "line": 2229,
            "code": "        it('returns a deep clone of the property value', () => {\n          atom.config.set('value', {\n            array: [1, {\n              b: 2\n            }, 3]\n          });\n          const retrievedValue = atom.config.get('value');\n          retrievedValue.array[0] = 4;\n          retrievedValue.array[1].b = 2.1;\n          expect(atom.config.get('value')).toEqual({\n            array: [1, {\n              b: 2\n            }, 3]\n          });\n        });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gets scoped values correctly",
            "suites": [
                "Config",
                "project specific settings",
                "config.get",
                "project settings"
            ],
            "updatePoint": {
                "line": 2244,
                "column": 40
            },
            "line": 2244,
            "code": "        it('gets scoped values correctly', () => {\n          atom.config.set('foo', 'bam', {\n            scope: ['second']\n          });\n          expect(atom.config.get('foo', {\n            scopeSelector: 'second'\n          })).toBe('bam');\n          atom.config.resetProjectSettings({\n            '*': {\n              foo: 'baz'\n            },\n            second: {\n              foo: 'bar'\n            }\n          }, dummyPath);\n          expect(atom.config.get('foo', {\n            scopeSelector: 'second'\n          })).toBe('baz');\n          atom.config.clearProjectSettings();\n          expect(atom.config.get('foo', {\n            scopeSelector: 'second'\n          })).toBe('bam');\n        });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears project settings correctly",
            "suites": [
                "Config",
                "project specific settings",
                "config.get",
                "project settings"
            ],
            "updatePoint": {
                "line": 2267,
                "column": 45
            },
            "line": 2267,
            "code": "        it('clears project settings correctly', () => {\n          atom.config.set('foo', 'bar');\n          expect(atom.config.get('foo')).toBe('bar');\n          atom.config.resetProjectSettings({\n            '*': {\n              foo: 'baz'\n            },\n            second: {\n              foo: 'bar'\n            }\n          }, dummyPath);\n          expect(atom.config.get('foo')).toBe('baz');\n          expect(atom.config.getSources().length).toBe(1);\n          atom.config.clearProjectSettings();\n          expect(atom.config.get('foo')).toBe('bar');\n          expect(atom.config.getSources().length).toBe(0);\n        });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gets settings in the same way .get would return them",
            "suites": [
                "Config",
                "project specific settings",
                "config.getAll"
            ],
            "updatePoint": {
                "line": 2288,
                "column": 62
            },
            "line": 2288,
            "code": "      it('gets settings in the same way .get would return them', () => {\n        atom.config.resetProjectSettings({\n          '*': {\n            a: 'b'\n          }\n        }, dummyPath);\n        atom.config.set('a', 'f');\n        expect(atom.config.getAll('a')).toEqual([{\n          scopeSelector: '*',\n          value: 'b'\n        }]);\n      });",
            "file": "config-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can add top-level menu items that can be removed with the returned disposable",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 33,
                "column": 85
            },
            "line": 33,
            "code": "    it('can add top-level menu items that can be removed with the returned disposable', function () {\n      const disposable = contextMenu.add({\n        '.parent': [{\n          label: 'A',\n          command: 'a'\n        }],\n        '.child': [{\n          label: 'B',\n          command: 'b'\n        }],\n        '.grandchild': [{\n          label: 'C',\n          command: 'c'\n        }]\n      });\n      expect(contextMenu.templateForElement(grandchild)).toEqual([{\n        label: 'C',\n        id: 'C',\n        command: 'c'\n      }, {\n        label: 'B',\n        id: 'B',\n        command: 'b'\n      }, {\n        label: 'A',\n        id: 'A',\n        command: 'a'\n      }]);\n      disposable.dispose();\n      expect(contextMenu.templateForElement(grandchild)).toEqual([]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can add submenu items to existing menus that can be removed with the returned disposable",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 64,
                "column": 96
            },
            "line": 64,
            "code": "    it('can add submenu items to existing menus that can be removed with the returned disposable', function () {\n      const disposable1 = contextMenu.add({\n        '.grandchild': [{\n          label: 'A',\n          submenu: [{\n            label: 'B',\n            command: 'b'\n          }]\n        }]\n      });\n      const disposable2 = contextMenu.add({\n        '.grandchild': [{\n          label: 'A',\n          submenu: [{\n            label: 'C',\n            command: 'c'\n          }]\n        }]\n      });\n      expect(contextMenu.templateForElement(grandchild)).toEqual([{\n        label: 'A',\n        id: 'A',\n        submenu: [{\n          label: 'B',\n          id: 'B',\n          command: 'b'\n        }, {\n          label: 'C',\n          id: 'C',\n          command: 'c'\n        }]\n      }]);\n      disposable2.dispose();\n      expect(contextMenu.templateForElement(grandchild)).toEqual([{\n        label: 'A',\n        id: 'A',\n        submenu: [{\n          label: 'B',\n          id: 'B',\n          command: 'b'\n        }]\n      }]);\n      disposable1.dispose();\n      expect(contextMenu.templateForElement(grandchild)).toEqual([]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "favors the most specific / recently added item in the case of a duplicate label",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 109,
                "column": 87
            },
            "line": 109,
            "code": "    it('favors the most specific / recently added item in the case of a duplicate label', function () {\n      grandchild.classList.add('foo');\n      const disposable1 = contextMenu.add({\n        '.grandchild': [{\n          label: 'A',\n          command: 'a'\n        }]\n      });\n      const disposable2 = contextMenu.add({\n        '.grandchild.foo': [{\n          label: 'A',\n          command: 'b'\n        }]\n      });\n      const disposable3 = contextMenu.add({\n        '.grandchild': [{\n          label: 'A',\n          command: 'c'\n        }]\n      });\n      contextMenu.add({\n        '.child': [{\n          label: 'A',\n          command: 'd'\n        }]\n      });\n      expect(contextMenu.templateForElement(grandchild)).toEqual([{\n        label: 'A',\n        id: 'A',\n        command: 'b'\n      }]);\n      disposable2.dispose();\n      expect(contextMenu.templateForElement(grandchild)).toEqual([{\n        label: 'A',\n        id: 'A',\n        command: 'c'\n      }]);\n      disposable3.dispose();\n      expect(contextMenu.templateForElement(grandchild)).toEqual([{\n        label: 'A',\n        id: 'A',\n        command: 'a'\n      }]);\n      disposable1.dispose();\n      expect(contextMenu.templateForElement(grandchild)).toEqual([{\n        label: 'A',\n        id: 'A',\n        command: 'd'\n      }]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows multiple separators, but not adjacent to each other",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 159,
                "column": 66
            },
            "line": 159,
            "code": "    it('allows multiple separators, but not adjacent to each other', function () {\n      contextMenu.add({\n        '.grandchild': [{\n          label: 'A',\n          command: 'a'\n        }, {\n          type: 'separator'\n        }, {\n          type: 'separator'\n        }, {\n          label: 'B',\n          command: 'b'\n        }, {\n          type: 'separator'\n        }, {\n          type: 'separator'\n        }, {\n          label: 'C',\n          command: 'c'\n        }]\n      });\n      expect(contextMenu.templateForElement(grandchild)).toEqual([{\n        label: 'A',\n        id: 'A',\n        command: 'a'\n      }, {\n        type: 'separator'\n      }, {\n        label: 'B',\n        id: 'B',\n        command: 'b'\n      }, {\n        type: 'separator'\n      }, {\n        label: 'C',\n        id: 'C',\n        command: 'c'\n      }]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "excludes items marked for display in devMode unless in dev mode",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 198,
                "column": 71
            },
            "line": 198,
            "code": "    it('excludes items marked for display in devMode unless in dev mode', function () {\n      contextMenu.add({\n        '.grandchild': [{\n          label: 'A',\n          command: 'a',\n          devMode: true\n        }, {\n          label: 'B',\n          command: 'b',\n          devMode: false\n        }]\n      });\n      expect(contextMenu.templateForElement(grandchild)).toEqual([{\n        label: 'B',\n        id: 'B',\n        command: 'b'\n      }]);\n      contextMenu.devMode = true;\n      expect(contextMenu.templateForElement(grandchild)).toEqual([{\n        label: 'A',\n        id: 'A',\n        command: 'a'\n      }, {\n        label: 'B',\n        id: 'B',\n        command: 'b'\n      }]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows items to be associated with `created` hooks which are invoked on template construction with the item and event",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 226,
                "column": 125
            },
            "line": 226,
            "code": "    it('allows items to be associated with `created` hooks which are invoked on template construction with the item and event', function () {\n      let createdEvent = null;\n      const item = {\n        label: 'A',\n        command: 'a',\n\n        created(event) {\n          this.command = 'b';\n          createdEvent = event;\n        }\n\n      };\n      contextMenu.add({\n        '.grandchild': [item]\n      });\n      const dispatchedEvent = {\n        target: grandchild\n      };\n      expect(contextMenu.templateForEvent(dispatchedEvent)).toEqual([{\n        label: 'A',\n        id: 'A',\n        command: 'b'\n      }]);\n      expect(item.command).toBe('a'); // doesn't modify original item template\n\n      expect(createdEvent).toBe(dispatchedEvent);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows items to be associated with `shouldDisplay` hooks which are invoked on construction to determine whether the item should be included",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 253,
                "column": 147
            },
            "line": 253,
            "code": "    it('allows items to be associated with `shouldDisplay` hooks which are invoked on construction to determine whether the item should be included', function () {\n      let shouldDisplayEvent = null;\n      let shouldDisplay = true;\n      const item = {\n        label: 'A',\n        command: 'a',\n\n        shouldDisplay(event) {\n          this.foo = 'bar';\n          shouldDisplayEvent = event;\n          return shouldDisplay;\n        }\n\n      };\n      contextMenu.add({\n        '.grandchild': [item]\n      });\n      const dispatchedEvent = {\n        target: grandchild\n      };\n      expect(contextMenu.templateForEvent(dispatchedEvent)).toEqual([{\n        label: 'A',\n        id: 'A',\n        command: 'a'\n      }]);\n      expect(item.foo).toBeUndefined(); // doesn't modify original item template\n\n      expect(shouldDisplayEvent).toBe(dispatchedEvent);\n      shouldDisplay = false;\n      expect(contextMenu.templateForEvent(dispatchedEvent)).toEqual([]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prunes a trailing separator",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 284,
                "column": 35
            },
            "line": 284,
            "code": "    it('prunes a trailing separator', function () {\n      contextMenu.add({\n        '.grandchild': [{\n          label: 'A',\n          command: 'a'\n        }, {\n          type: 'separator'\n        }, {\n          label: 'B',\n          command: 'b'\n        }, {\n          type: 'separator'\n        }]\n      });\n      expect(contextMenu.templateForEvent({\n        target: grandchild\n      }).length).toBe(3);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prunes a leading separator",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 302,
                "column": 34
            },
            "line": 302,
            "code": "    it('prunes a leading separator', function () {\n      contextMenu.add({\n        '.grandchild': [{\n          type: 'separator'\n        }, {\n          label: 'A',\n          command: 'a'\n        }, {\n          type: 'separator'\n        }, {\n          label: 'B',\n          command: 'b'\n        }]\n      });\n      expect(contextMenu.templateForEvent({\n        target: grandchild\n      }).length).toBe(3);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prunes duplicate separators",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 320,
                "column": 35
            },
            "line": 320,
            "code": "    it('prunes duplicate separators', function () {\n      contextMenu.add({\n        '.grandchild': [{\n          label: 'A',\n          command: 'a'\n        }, {\n          type: 'separator'\n        }, {\n          type: 'separator'\n        }, {\n          label: 'B',\n          command: 'b'\n        }]\n      });\n      expect(contextMenu.templateForEvent({\n        target: grandchild\n      }).length).toBe(3);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prunes all redundant separators",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 338,
                "column": 39
            },
            "line": 338,
            "code": "    it('prunes all redundant separators', function () {\n      contextMenu.add({\n        '.grandchild': [{\n          type: 'separator'\n        }, {\n          type: 'separator'\n        }, {\n          label: 'A',\n          command: 'a'\n        }, {\n          type: 'separator'\n        }, {\n          type: 'separator'\n        }, {\n          label: 'B',\n          command: 'b'\n        }, {\n          label: 'C',\n          command: 'c'\n        }, {\n          type: 'separator'\n        }, {\n          type: 'separator'\n        }]\n      });\n      expect(contextMenu.templateForEvent({\n        target: grandchild\n      }).length).toBe(4);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error when the selector is invalid",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 367,
                "column": 52
            },
            "line": 367,
            "code": "    it('throws an error when the selector is invalid', function () {\n      let addError = null;\n\n      try {\n        contextMenu.add({\n          '<>': [{\n            label: 'A',\n            command: 'a'\n          }]\n        });\n      } catch (error) {\n        addError = error;\n      }\n\n      expect(addError.message).toContain('<>');\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls `created` hooks for submenu items",
            "suites": [
                "ContextMenuManager",
                "::add(itemsBySelector)"
            ],
            "updatePoint": {
                "line": 383,
                "column": 47
            },
            "line": 383,
            "code": "    it('calls `created` hooks for submenu items', function () {\n      const item = {\n        label: 'A',\n        command: 'B',\n        submenu: [{\n          label: 'C',\n\n          created(event) {\n            this.label = 'D';\n          }\n\n        }]\n      };\n      contextMenu.add({\n        '.grandchild': [item]\n      });\n      const dispatchedEvent = {\n        target: grandchild\n      };\n      expect(contextMenu.templateForEvent(dispatchedEvent)).toEqual([{\n        label: 'A',\n        id: 'A',\n        command: 'B',\n        submenu: [{\n          label: 'D',\n          id: 'D'\n        }]\n      }]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds Electron-style accelerators to items that have keybindings",
            "suites": [
                "ContextMenuManager",
                "::templateForEvent(target)"
            ],
            "updatePoint": {
                "line": 435,
                "column": 71
            },
            "line": 435,
            "code": "    it('adds Electron-style accelerators to items that have keybindings', function () {\n      child.focus();\n      const dispatchedEvent = {\n        target: child\n      };\n      expect(contextMenu.templateForEvent(dispatchedEvent)).toEqual([{\n        label: 'My Command',\n        id: 'My Command',\n        command: 'test:my-command',\n        accelerator: 'Ctrl+A',\n        submenu: [{\n          label: 'My Other Command',\n          id: 'My Other Command',\n          command: 'test:my-other-command',\n          accelerator: 'Shift+B'\n        }]\n      }]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds accelerators when a parent node has key bindings for a given command",
            "suites": [
                "ContextMenuManager",
                "::templateForEvent(target)"
            ],
            "updatePoint": {
                "line": 453,
                "column": 81
            },
            "line": 453,
            "code": "    it('adds accelerators when a parent node has key bindings for a given command', function () {\n      grandchild.focus();\n      const dispatchedEvent = {\n        target: grandchild\n      };\n      expect(contextMenu.templateForEvent(dispatchedEvent)).toEqual([{\n        label: 'My Command',\n        id: 'My Command',\n        command: 'test:my-command',\n        accelerator: 'Ctrl+A',\n        submenu: [{\n          label: 'My Other Command',\n          id: 'My Other Command',\n          command: 'test:my-other-command',\n          accelerator: 'Shift+B'\n        }]\n      }]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not add accelerators when a child node has key bindings for a given command",
            "suites": [
                "ContextMenuManager",
                "::templateForEvent(target)"
            ],
            "updatePoint": {
                "line": 471,
                "column": 88
            },
            "line": 471,
            "code": "    it('does not add accelerators when a child node has key bindings for a given command', function () {\n      parent.focus();\n      const dispatchedEvent = {\n        target: parent\n      };\n      expect(contextMenu.templateForEvent(dispatchedEvent)).toEqual([{\n        label: 'My Command',\n        id: 'My Command',\n        command: 'test:my-command',\n        submenu: [{\n          label: 'My Other Command',\n          id: 'My Other Command',\n          command: 'test:my-other-command'\n        }]\n      }]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds accelerators based on focus, not context menu target",
            "suites": [
                "ContextMenuManager",
                "::templateForEvent(target)"
            ],
            "updatePoint": {
                "line": 487,
                "column": 65
            },
            "line": 487,
            "code": "    it('adds accelerators based on focus, not context menu target', function () {\n      grandchild.focus();\n      const dispatchedEvent = {\n        target: parent\n      };\n      expect(contextMenu.templateForEvent(dispatchedEvent)).toEqual([{\n        label: 'My Command',\n        id: 'My Command',\n        command: 'test:my-command',\n        accelerator: 'Ctrl+A',\n        submenu: [{\n          label: 'My Other Command',\n          id: 'My Other Command',\n          command: 'test:my-other-command',\n          accelerator: 'Shift+B'\n        }]\n      }]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not add accelerators for multi-keystroke key bindings",
            "suites": [
                "ContextMenuManager",
                "::templateForEvent(target)"
            ],
            "updatePoint": {
                "line": 505,
                "column": 66
            },
            "line": 505,
            "code": "    it('does not add accelerators for multi-keystroke key bindings', function () {\n      atom.keymaps.add('source', {\n        '.child': {\n          'ctrl-a ctrl-b': 'test:multi-keystroke-command'\n        }\n      });\n      contextMenu.clear();\n      contextMenu.add({\n        '.parent': [{\n          label: 'Multi-keystroke command',\n          command: 'test:multi-keystroke-command'\n        }]\n      });\n      child.focus();\n      const label = process.platform === 'darwin' ? '⌃A ⌃B' : 'Ctrl+A Ctrl+B';\n      expect(contextMenu.templateForEvent({\n        target: child\n      })).toEqual([{\n        label: `Multi-keystroke command [${label}]`,\n        id: `Multi-keystroke command`,\n        command: 'test:multi-keystroke-command'\n      }]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "applies simple sorting rules",
            "suites": [
                "ContextMenuManager",
                "::templateForEvent(target) (sorting)"
            ],
            "updatePoint": {
                "line": 530,
                "column": 36
            },
            "line": 530,
            "code": "    it('applies simple sorting rules', function () {\n      contextMenu.add({\n        '.parent': [{\n          label: 'My Command',\n          command: 'test:my-command',\n          after: ['test:my-other-command']\n        }, {\n          label: 'My Other Command',\n          command: 'test:my-other-command'\n        }]\n      });\n      const dispatchedEvent = {\n        target: parent\n      };\n      expect(contextMenu.templateForEvent(dispatchedEvent)).toEqual([{\n        label: 'My Other Command',\n        id: 'My Other Command',\n        command: 'test:my-other-command'\n      }, {\n        label: 'My Command',\n        id: 'My Command',\n        command: 'test:my-command',\n        after: ['test:my-other-command']\n      }]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "applies sorting rules recursively to submenus",
            "suites": [
                "ContextMenuManager",
                "::templateForEvent(target) (sorting)"
            ],
            "updatePoint": {
                "line": 555,
                "column": 53
            },
            "line": 555,
            "code": "    it('applies sorting rules recursively to submenus', function () {\n      contextMenu.add({\n        '.parent': [{\n          label: 'Parent',\n          submenu: [{\n            label: 'My Command',\n            command: 'test:my-command',\n            after: ['test:my-other-command']\n          }, {\n            label: 'My Other Command',\n            command: 'test:my-other-command'\n          }]\n        }]\n      });\n      const dispatchedEvent = {\n        target: parent\n      };\n      expect(contextMenu.templateForEvent(dispatchedEvent)).toEqual([{\n        label: 'Parent',\n        id: `Parent`,\n        submenu: [{\n          label: 'My Other Command',\n          id: 'My Other Command',\n          command: 'test:my-other-command'\n        }, {\n          label: 'My Command',\n          id: 'My Command',\n          command: 'test:my-command',\n          after: ['test:my-other-command']\n        }]\n      }]);\n    });",
            "file": "context-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can add decorations associated with markers and remove them",
            "suites": [
                "DecorationManager",
                "decorations"
            ],
            "updatePoint": {
                "line": 30,
                "column": 67
            },
            "line": 30,
            "code": "    it('can add decorations associated with markers and remove them', function () {\n      expect(layer1MarkerDecoration).toBeDefined();\n      expect(layer1MarkerDecoration.getProperties()).toBe(decorationProperties);\n      expect(decorationManager.decorationsForScreenRowRange(2, 3)).toEqual({\n        [layer1Marker.id]: [layer1MarkerDecoration],\n        [layer2Marker.id]: [layer2MarkerDecoration]\n      });\n      layer1MarkerDecoration.destroy();\n      expect(decorationManager.decorationsForScreenRowRange(2, 3)[layer1Marker.id]).not.toBeDefined();\n      layer2MarkerDecoration.destroy();\n      expect(decorationManager.decorationsForScreenRowRange(2, 3)[layer2Marker.id]).not.toBeDefined();\n    });",
            "file": "decoration-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will not fail if the decoration is removed twice",
            "suites": [
                "DecorationManager",
                "decorations"
            ],
            "updatePoint": {
                "line": 42,
                "column": 56
            },
            "line": 42,
            "code": "    it('will not fail if the decoration is removed twice', function () {\n      layer1MarkerDecoration.destroy();\n      layer1MarkerDecoration.destroy();\n    });",
            "file": "decoration-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not allow destroyed markers to be decorated",
            "suites": [
                "DecorationManager",
                "decorations"
            ],
            "updatePoint": {
                "line": 46,
                "column": 56
            },
            "line": 46,
            "code": "    it('does not allow destroyed markers to be decorated', function () {\n      layer1Marker.destroy();\n      expect(() => decorationManager.decorateMarker(layer1Marker, {\n        type: 'overlay',\n        item: document.createElement('div')\n      })).toThrow('Cannot decorate a destroyed marker');\n      expect(decorationManager.getOverlayDecorations()).toEqual([]);\n    });",
            "file": "decoration-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not allow destroyed marker layers to be decorated",
            "suites": [
                "DecorationManager",
                "decorations"
            ],
            "updatePoint": {
                "line": 54,
                "column": 62
            },
            "line": 54,
            "code": "    it('does not allow destroyed marker layers to be decorated', function () {\n      const layer = editor.addMarkerLayer();\n      layer.destroy();\n      expect(() => decorationManager.decorateMarkerLayer(layer, {\n        type: 'highlight'\n      })).toThrow('Cannot decorate a destroyed marker layer');\n    });",
            "file": "decoration-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits an 'updated' event containing the new and old params",
            "suites": [
                "DecorationManager",
                "decorations",
                "when a decoration is updated via Decoration::update()"
            ],
            "updatePoint": {
                "line": 61,
                "column": 138
            },
            "line": 61,
            "code": "    describe('when a decoration is updated via Decoration::update()', () => it(\"emits an 'updated' event containing the new and old params\", function () {\n      let updatedSpy;\n      layer1MarkerDecoration.onDidChangeProperties(updatedSpy = jasmine.createSpy());\n      layer1MarkerDecoration.setProperties({\n        type: 'line-number',\n        class: 'two'\n      });\n      const {\n        oldProperties,\n        newProperties\n      } = updatedSpy.mostRecentCall.args[0];\n      expect(oldProperties).toEqual(decorationProperties);\n      expect(newProperties.type).toBe('line-number');\n      expect(newProperties.gutterName).toBe('line-number');\n      expect(newProperties.class).toBe('two');\n    }));",
            "file": "decoration-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns decorations matching the given optional properties",
            "suites": [
                "DecorationManager",
                "decorations",
                "::getDecorations(properties)"
            ],
            "updatePoint": {
                "line": 77,
                "column": 113
            },
            "line": 77,
            "code": "    describe('::getDecorations(properties)', () => it('returns decorations matching the given optional properties', function () {\n      expect(decorationManager.getDecorations()).toEqual([layer1MarkerDecoration, layer2MarkerDecoration]);\n      expect(decorationManager.getDecorations({\n        class: 'two'\n      }).length).toEqual(0);\n      expect(decorationManager.getDecorations({\n        class: 'one'\n      }).length).toEqual(2);\n    }));",
            "file": "decoration-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a decoration that is both of 'line-number' and 'gutter' type when called with the 'line-number' type",
            "suites": [
                "DecorationManager",
                "::decorateMarker",
                "when decorating gutters"
            ],
            "updatePoint": {
                "line": 90,
                "column": 116
            },
            "line": 90,
            "code": "    it(\"creates a decoration that is both of 'line-number' and 'gutter' type when called with the 'line-number' type\", function () {\n      const decorationProperties = {\n        type: 'line-number',\n        class: 'one'\n      };\n      const layer1MarkerDecoration = decorationManager.decorateMarker(layer1Marker, decorationProperties);\n      expect(layer1MarkerDecoration.isType('line-number')).toBe(true);\n      expect(layer1MarkerDecoration.isType('gutter')).toBe(true);\n      expect(layer1MarkerDecoration.getProperties().gutterName).toBe('line-number');\n      expect(layer1MarkerDecoration.getProperties().class).toBe('one');\n    });",
            "file": "decoration-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a decoration that is only of 'gutter' type if called with the 'gutter' type and a 'gutterName'",
            "suites": [
                "DecorationManager",
                "::decorateMarker",
                "when decorating gutters"
            ],
            "updatePoint": {
                "line": 101,
                "column": 110
            },
            "line": 101,
            "code": "    it(\"creates a decoration that is only of 'gutter' type if called with the 'gutter' type and a 'gutterName'\", function () {\n      const decorationProperties = {\n        type: 'gutter',\n        gutterName: 'test-gutter',\n        class: 'one'\n      };\n      const layer1MarkerDecoration = decorationManager.decorateMarker(layer1Marker, decorationProperties);\n      expect(layer1MarkerDecoration.isType('gutter')).toBe(true);\n      expect(layer1MarkerDecoration.isType('line-number')).toBe(false);\n      expect(layer1MarkerDecoration.getProperties().gutterName).toBe('test-gutter');\n      expect(layer1MarkerDecoration.getProperties().class).toBe('one');\n    });",
            "file": "decoration-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a Directory with a path that matches the uri",
            "suites": [
                "DefaultDirectoryProvider",
                ".directoryForURISync(uri)"
            ],
            "updatePoint": {
                "line": 18,
                "column": 60
            },
            "line": 18,
            "code": "    it('returns a Directory with a path that matches the uri', function () {\n      const provider = new DefaultDirectoryProvider();\n      const directory = provider.directoryForURISync(tmp);\n      expect(directory.getPath()).toEqual(tmp);\n    });",
            "file": "default-directory-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "normalizes its input before creating a Directory for it",
            "suites": [
                "DefaultDirectoryProvider",
                ".directoryForURISync(uri)"
            ],
            "updatePoint": {
                "line": 23,
                "column": 63
            },
            "line": 23,
            "code": "    it('normalizes its input before creating a Directory for it', function () {\n      const provider = new DefaultDirectoryProvider();\n      const nonNormalizedPath = tmp + path.sep + '..' + path.sep + path.basename(tmp);\n      expect(tmp.includes('..')).toBe(false);\n      expect(nonNormalizedPath.includes('..')).toBe(true);\n      const directory = provider.directoryForURISync(nonNormalizedPath);\n      expect(directory.getPath()).toEqual(tmp);\n    });",
            "file": "default-directory-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "normalizes disk drive letter in path on #win32",
            "suites": [
                "DefaultDirectoryProvider",
                ".directoryForURISync(uri)"
            ],
            "updatePoint": {
                "line": 31,
                "column": 54
            },
            "line": 31,
            "code": "    it('normalizes disk drive letter in path on #win32', function () {\n      const provider = new DefaultDirectoryProvider();\n      const nonNormalizedPath = tmp[0].toLowerCase() + tmp.slice(1);\n      expect(tmp).not.toMatch(/^[a-z]:/);\n      expect(nonNormalizedPath).toMatch(/^[a-z]:/);\n      const directory = provider.directoryForURISync(nonNormalizedPath);\n      expect(directory.getPath()).toEqual(tmp);\n    });",
            "file": "default-directory-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a Directory for its parent dir when passed a file",
            "suites": [
                "DefaultDirectoryProvider",
                ".directoryForURISync(uri)"
            ],
            "updatePoint": {
                "line": 39,
                "column": 65
            },
            "line": 39,
            "code": "    it('creates a Directory for its parent dir when passed a file', function () {\n      const provider = new DefaultDirectoryProvider();\n      const file = path.join(tmp, 'example.txt');\n      fs.writeFileSync(file, 'data');\n      const directory = provider.directoryForURISync(file);\n      expect(directory.getPath()).toEqual(tmp);\n    });",
            "file": "default-directory-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a Directory with a path as a uri when passed a uri",
            "suites": [
                "DefaultDirectoryProvider",
                ".directoryForURISync(uri)"
            ],
            "updatePoint": {
                "line": 46,
                "column": 66
            },
            "line": 46,
            "code": "    it('creates a Directory with a path as a uri when passed a uri', function () {\n      const provider = new DefaultDirectoryProvider();\n      const uri = 'remote://server:6792/path/to/a/dir';\n      const directory = provider.directoryForURISync(uri);\n      expect(directory.getPath()).toEqual(uri);\n    });",
            "file": "default-directory-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a Promise that resolves to a Directory with a path that matches the uri",
            "suites": [
                "DefaultDirectoryProvider",
                ".directoryForURI(uri)"
            ],
            "updatePoint": {
                "line": 53,
                "column": 125
            },
            "line": 53,
            "code": "  describe('.directoryForURI(uri)', () => it('returns a Promise that resolves to a Directory with a path that matches the uri', function () {\n    const provider = new DefaultDirectoryProvider();\n    waitsForPromise(() => provider.directoryForURI(tmp).then(directory => expect(directory.getPath()).toEqual(tmp)));\n  }));",
            "file": "default-directory-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "terminates the task after running a search",
            "suites": [
                "DefaultDirectorySearcher"
            ],
            "updatePoint": {
                "line": 14,
                "column": 48
            },
            "line": 14,
            "code": "  it('terminates the task after running a search', async function () {\n    const options = {\n      ignoreCase: false,\n      includeHidden: false,\n      excludeVcsIgnores: true,\n      inclusions: [],\n      globalExclusions: ['a-dir'],\n\n      didMatch() {},\n\n      didError() {},\n\n      didSearchPaths() {}\n\n    };\n    spyOn(Task.prototype, 'terminate').andCallThrough();\n    await searcher.search([{\n      getPath() {\n        return dirPath;\n      }\n\n    }], /abcdefg/, options);\n    expect(Task.prototype.terminate).toHaveBeenCalled();\n  });",
            "file": "default-directory-searcher-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a disposable that can be used to remove the manager",
            "suites": [
                "DeserializerManager",
                "::add(deserializer)"
            ],
            "updatePoint": {
                "line": 20,
                "column": 103
            },
            "line": 20,
            "code": "  describe('::add(deserializer)', () => it('returns a disposable that can be used to remove the manager', function () {\n    const disposable = manager.add(Foo);\n    expect(manager.deserialize({\n      deserializer: 'Foo',\n      name: 'Bar'\n    })).toBeDefined();\n    disposable.dispose();\n    spyOn(console, 'warn');\n    expect(manager.deserialize({\n      deserializer: 'Foo',\n      name: 'Bar'\n    })).toBeUndefined();\n  }));",
            "file": "deserializer-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls deserialize on the manager for the given state object, or returns undefined if one can't be found",
            "suites": [
                "DeserializerManager",
                "::deserialize(state)"
            ],
            "updatePoint": {
                "line": 35,
                "column": 111
            },
            "line": 35,
            "code": "    it(\"calls deserialize on the manager for the given state object, or returns undefined if one can't be found\", function () {\n      spyOn(console, 'warn');\n      const object = manager.deserialize({\n        deserializer: 'Foo',\n        name: 'Bar'\n      });\n      expect(object.name).toBe('Bar');\n      expect(manager.deserialize({\n        deserializer: 'Bogus'\n      })).toBeUndefined();\n    });",
            "file": "deserializer-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "attempts to deserialize the state",
            "suites": [
                "DeserializerManager",
                "::deserialize(state)",
                "when the manager has a version",
                "when the deserialized state has a matching version"
            ],
            "updatePoint": {
                "line": 48,
                "column": 112
            },
            "line": 48,
            "code": "      describe('when the deserialized state has a matching version', () => it('attempts to deserialize the state', function () {\n        const object = manager.deserialize({\n          deserializer: 'Foo',\n          version: 2,\n          name: 'Bar'\n        });\n        expect(object.name).toBe('Bar');\n      }));",
            "file": "deserializer-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns undefined",
            "suites": [
                "DeserializerManager",
                "::deserialize(state)",
                "when the manager has a version",
                "when the deserialized state has a non-matching version"
            ],
            "updatePoint": {
                "line": 56,
                "column": 100
            },
            "line": 56,
            "code": "      describe('when the deserialized state has a non-matching version', () => it('returns undefined', function () {\n        expect(manager.deserialize({\n          deserializer: 'Foo',\n          version: 3,\n          name: 'Bar'\n        })).toBeUndefined();\n        expect(manager.deserialize({\n          deserializer: 'Foo',\n          version: 1,\n          name: 'Bar'\n        })).toBeUndefined();\n        expect(manager.deserialize({\n          deserializer: 'Foo',\n          name: 'Bar'\n        })).toBeUndefined();\n      }));",
            "file": "deserializer-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the dock and activates its active pane",
            "suites": [
                "Dock",
                "when a dock is activated"
            ],
            "updatePoint": {
                "line": 10,
                "column": 52
            },
            "line": 10,
            "code": "    it('opens the dock and activates its active pane', () => {\n      jasmine.attachToDOM(atom.workspace.getElement());\n      const dock = atom.workspace.getLeftDock();\n      const didChangeVisibleSpy = jasmine.createSpy();\n      dock.onDidChangeVisible(didChangeVisibleSpy);\n      expect(dock.isVisible()).toBe(false);\n      expect(document.activeElement).toBe(atom.workspace.getCenter().getActivePane().getElement());\n      dock.activate();\n      expect(dock.isVisible()).toBe(true);\n      expect(document.activeElement).toBe(dock.getActivePane().getElement());\n      expect(didChangeVisibleSpy).toHaveBeenCalledWith(true);\n    });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "transfers focus back to the active center pane if the dock had focus",
            "suites": [
                "Dock",
                "when a dock is hidden"
            ],
            "updatePoint": {
                "line": 24,
                "column": 76
            },
            "line": 24,
            "code": "    it('transfers focus back to the active center pane if the dock had focus', () => {\n      jasmine.attachToDOM(atom.workspace.getElement());\n      const dock = atom.workspace.getLeftDock();\n      const didChangeVisibleSpy = jasmine.createSpy();\n      dock.onDidChangeVisible(didChangeVisibleSpy);\n      dock.activate();\n      expect(document.activeElement).toBe(dock.getActivePane().getElement());\n      expect(didChangeVisibleSpy.mostRecentCall.args[0]).toBe(true);\n      dock.hide();\n      expect(document.activeElement).toBe(atom.workspace.getCenter().getActivePane().getElement());\n      expect(didChangeVisibleSpy.mostRecentCall.args[0]).toBe(false);\n      dock.activate();\n      expect(document.activeElement).toBe(dock.getActivePane().getElement());\n      expect(didChangeVisibleSpy.mostRecentCall.args[0]).toBe(true);\n      dock.toggle();\n      expect(document.activeElement).toBe(atom.workspace.getCenter().getActivePane().getElement());\n      expect(didChangeVisibleSpy.mostRecentCall.args[0]).toBe(false); // Don't change focus if the dock was not focused in the first place\n\n      const modalElement = document.createElement('div');\n      modalElement.setAttribute('tabindex', -1);\n      atom.workspace.addModalPanel({\n        item: modalElement\n      });\n      modalElement.focus();\n      expect(document.activeElement).toBe(modalElement);\n      dock.show();\n      expect(document.activeElement).toBe(modalElement);\n      expect(didChangeVisibleSpy.mostRecentCall.args[0]).toBe(true);\n      dock.hide();\n      expect(document.activeElement).toBe(modalElement);\n      expect(didChangeVisibleSpy.mostRecentCall.args[0]).toBe(false);\n    });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the dock",
            "suites": [
                "Dock",
                "when a pane in a dock is activated"
            ],
            "updatePoint": {
                "line": 58,
                "column": 22
            },
            "line": 58,
            "code": "    it('opens the dock', async () => {\n      const item = {\n        element: document.createElement('div'),\n\n        getDefaultLocation() {\n          return 'left';\n        }\n\n      };\n      await atom.workspace.open(item, {\n        activatePane: false\n      });\n      expect(atom.workspace.getLeftDock().isVisible()).toBe(false);\n      atom.workspace.getLeftDock().getPanes()[0].activate();\n      expect(atom.workspace.getLeftDock().isVisible()).toBe(true);\n    });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the next pane",
            "suites": [
                "Dock",
                "activating the next pane",
                "when the dock has more than one pane"
            ],
            "updatePoint": {
                "line": 77,
                "column": 33
            },
            "line": 77,
            "code": "      it('activates the next pane', () => {\n        const dock = atom.workspace.getLeftDock();\n        const pane1 = dock.getPanes()[0];\n        const pane2 = pane1.splitRight();\n        const pane3 = pane2.splitRight();\n        pane2.activate();\n        expect(pane1.isActive()).toBe(false);\n        expect(pane2.isActive()).toBe(true);\n        expect(pane3.isActive()).toBe(false);\n        dock.activateNextPane();\n        expect(pane1.isActive()).toBe(false);\n        expect(pane2.isActive()).toBe(false);\n        expect(pane3.isActive()).toBe(true);\n      });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "leaves the current pane active",
            "suites": [
                "Dock",
                "activating the next pane",
                "when the dock has only one pane"
            ],
            "updatePoint": {
                "line": 93,
                "column": 40
            },
            "line": 93,
            "code": "      it('leaves the current pane active', () => {\n        const dock = atom.workspace.getLeftDock();\n        expect(dock.getPanes().length).toBe(1);\n        const pane = dock.getPanes()[0];\n        expect(pane.isActive()).toBe(true);\n        dock.activateNextPane();\n        expect(pane.isActive()).toBe(true);\n      });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the previous pane",
            "suites": [
                "Dock",
                "activating the previous pane",
                "when the dock has more than one pane"
            ],
            "updatePoint": {
                "line": 105,
                "column": 37
            },
            "line": 105,
            "code": "      it('activates the previous pane', () => {\n        const dock = atom.workspace.getLeftDock();\n        const pane1 = dock.getPanes()[0];\n        const pane2 = pane1.splitRight();\n        const pane3 = pane2.splitRight();\n        pane2.activate();\n        expect(pane1.isActive()).toBe(false);\n        expect(pane2.isActive()).toBe(true);\n        expect(pane3.isActive()).toBe(false);\n        dock.activatePreviousPane();\n        expect(pane1.isActive()).toBe(true);\n        expect(pane2.isActive()).toBe(false);\n        expect(pane3.isActive()).toBe(false);\n      });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "leaves the current pane active",
            "suites": [
                "Dock",
                "activating the previous pane",
                "when the dock has only one pane"
            ],
            "updatePoint": {
                "line": 121,
                "column": 40
            },
            "line": 121,
            "code": "      it('leaves the current pane active', () => {\n        const dock = atom.workspace.getLeftDock();\n        expect(dock.getPanes().length).toBe(1);\n        const pane = dock.getPanes()[0];\n        expect(pane.isActive()).toBe(true);\n        dock.activatePreviousPane();\n        expect(pane.isActive()).toBe(true);\n      });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resizes a vertically-oriented dock to the current item's preferred width",
            "suites": [
                "Dock",
                "when the dock resize handle is double-clicked",
                "when the dock is open"
            ],
            "updatePoint": {
                "line": 133,
                "column": 82
            },
            "line": 133,
            "code": "      it(\"resizes a vertically-oriented dock to the current item's preferred width\", async () => {\n        jasmine.attachToDOM(atom.workspace.getElement());\n        const item = {\n          element: document.createElement('div'),\n\n          getDefaultLocation() {\n            return 'left';\n          },\n\n          getPreferredWidth() {\n            return 142;\n          },\n\n          getPreferredHeight() {\n            return 122;\n          }\n\n        };\n        await atom.workspace.open(item);\n        const dock = atom.workspace.getLeftDock();\n        const dockElement = dock.getElement();\n        dock.setState({\n          size: 300\n        });\n        await getNextUpdatePromise();\n        expect(dockElement.offsetWidth).toBe(300);\n        dockElement.querySelector('.atom-dock-resize-handle').dispatchEvent(new MouseEvent('mousedown', {\n          detail: 2\n        }));\n        await getNextUpdatePromise();\n        expect(dockElement.offsetWidth).toBe(item.getPreferredWidth());\n      });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resizes a horizontally-oriented dock to the current item's preferred width",
            "suites": [
                "Dock",
                "when the dock resize handle is double-clicked",
                "when the dock is open"
            ],
            "updatePoint": {
                "line": 165,
                "column": 84
            },
            "line": 165,
            "code": "      it(\"resizes a horizontally-oriented dock to the current item's preferred width\", async () => {\n        jasmine.attachToDOM(atom.workspace.getElement());\n        const item = {\n          element: document.createElement('div'),\n\n          getDefaultLocation() {\n            return 'bottom';\n          },\n\n          getPreferredWidth() {\n            return 122;\n          },\n\n          getPreferredHeight() {\n            return 142;\n          }\n\n        };\n        await atom.workspace.open(item);\n        const dock = atom.workspace.getBottomDock();\n        const dockElement = dock.getElement();\n        dock.setState({\n          size: 300\n        });\n        await getNextUpdatePromise();\n        expect(dockElement.offsetHeight).toBe(300);\n        dockElement.querySelector('.atom-dock-resize-handle').dispatchEvent(new MouseEvent('mousedown', {\n          detail: 2\n        }));\n        await getNextUpdatePromise();\n        expect(dockElement.offsetHeight).toBe(item.getPreferredHeight());\n      });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing",
            "suites": [
                "Dock",
                "when the dock resize handle is double-clicked",
                "when the dock is closed"
            ],
            "updatePoint": {
                "line": 199,
                "column": 22
            },
            "line": 199,
            "code": "      it('does nothing', async () => {\n        jasmine.attachToDOM(atom.workspace.getElement());\n        const item = {\n          element: document.createElement('div'),\n\n          getDefaultLocation() {\n            return 'bottom';\n          },\n\n          getPreferredWidth() {\n            return 122;\n          },\n\n          getPreferredHeight() {\n            return 142;\n          }\n\n        };\n        await atom.workspace.open(item, {\n          activatePane: false\n        });\n        const dockElement = atom.workspace.getBottomDock().getElement();\n        dockElement.querySelector('.atom-dock-resize-handle').dispatchEvent(new MouseEvent('mousedown', {\n          detail: 2\n        }));\n        expect(dockElement.offsetHeight).toBe(0);\n        expect(dockElement.querySelector('.atom-dock-inner').offsetHeight).toBe(0); // The content should be masked away.\n\n        expect(dockElement.querySelector('.atom-dock-mask').offsetHeight).toBe(0);\n      });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is takes the preferred size of the item",
            "suites": [
                "Dock",
                "when you add an item to an empty dock",
                "when the item has a preferred size"
            ],
            "updatePoint": {
                "line": 233,
                "column": 49
            },
            "line": 233,
            "code": "      it('is takes the preferred size of the item', async () => {\n        jasmine.attachToDOM(atom.workspace.getElement());\n\n        const createItem = preferredWidth => ({\n          element: document.createElement('div'),\n\n          getDefaultLocation() {\n            return 'left';\n          },\n\n          getPreferredWidth() {\n            return preferredWidth;\n          }\n\n        });\n\n        const dock = atom.workspace.getLeftDock();\n        const dockElement = dock.getElement();\n        expect(dock.getPaneItems()).toHaveLength(0);\n        const item1 = createItem(111);\n        await atom.workspace.open(item1); // It should update the width every time we go from 0 -> 1 items, not just the first.\n\n        expect(dock.isVisible()).toBe(true);\n        expect(dockElement.offsetWidth).toBe(111);\n        dock.destroyActivePane();\n        expect(dock.getPaneItems()).toHaveLength(0);\n        expect(dock.isVisible()).toBe(false);\n        const item2 = createItem(222);\n        await atom.workspace.open(item2);\n        expect(dock.isVisible()).toBe(true);\n        expect(dockElement.offsetWidth).toBe(222); // Adding a second shouldn't change the size.\n\n        const item3 = createItem(333);\n        await atom.workspace.open(item3);\n        expect(dockElement.offsetWidth).toBe(222);\n      });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is still has an explicit size",
            "suites": [
                "Dock",
                "when you add an item to an empty dock",
                "when the item has no preferred size"
            ],
            "updatePoint": {
                "line": 271,
                "column": 39
            },
            "line": 271,
            "code": "      it('is still has an explicit size', async () => {\n        jasmine.attachToDOM(atom.workspace.getElement());\n        const item = {\n          element: document.createElement('div'),\n\n          getDefaultLocation() {\n            return 'left';\n          }\n\n        };\n        const dock = atom.workspace.getLeftDock();\n        expect(dock.getPaneItems()).toHaveLength(0);\n        expect(dock.state.size).toBe(null);\n        await atom.workspace.open(item);\n        expect(dock.state.size).not.toBe(null);\n      });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the serialized size",
            "suites": [
                "Dock",
                "a deserialized dock"
            ],
            "updatePoint": {
                "line": 290,
                "column": 36
            },
            "line": 290,
            "code": "    it('restores the serialized size', async () => {\n      jasmine.attachToDOM(atom.workspace.getElement());\n      const item = {\n        element: document.createElement('div'),\n\n        getDefaultLocation() {\n          return 'left';\n        },\n\n        getPreferredWidth() {\n          return 122;\n        },\n\n        serialize: () => ({\n          deserializer: 'DockTestItem'\n        })\n      };\n      atom.deserializers.add({\n        name: 'DockTestItem',\n        deserialize: () => item\n      });\n      const dock = atom.workspace.getLeftDock();\n      const dockElement = dock.getElement();\n      await atom.workspace.open(item);\n      dock.setState({\n        size: 150\n      });\n      expect(dockElement.offsetWidth).toBe(150);\n      const serialized = dock.serialize();\n      dock.setState({\n        size: 122\n      });\n      expect(dockElement.offsetWidth).toBe(122);\n      dock.destroyActivePane();\n      dock.deserialize(serialized, atom.deserializers);\n      expect(dockElement.offsetWidth).toBe(150);\n    });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "isn't visible if it has no items",
            "suites": [
                "Dock",
                "a deserialized dock"
            ],
            "updatePoint": {
                "line": 327,
                "column": 40
            },
            "line": 327,
            "code": "    it(\"isn't visible if it has no items\", async () => {\n      jasmine.attachToDOM(atom.workspace.getElement());\n      const item = {\n        element: document.createElement('div'),\n\n        getDefaultLocation() {\n          return 'left';\n        },\n\n        getPreferredWidth() {\n          return 122;\n        }\n\n      };\n      const dock = atom.workspace.getLeftDock();\n      await atom.workspace.open(item);\n      expect(dock.isVisible()).toBe(true);\n      const serialized = dock.serialize();\n      dock.deserialize(serialized, atom.deserializers);\n      expect(dock.getPaneItems()).toHaveLength(0);\n      expect(dock.isVisible()).toBe(false);\n    });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands docks to match the preferred size of the dragged item",
            "suites": [
                "Dock",
                "drag handling"
            ],
            "updatePoint": {
                "line": 351,
                "column": 69
            },
            "line": 351,
            "code": "    it('expands docks to match the preferred size of the dragged item', async () => {\n      jasmine.attachToDOM(atom.workspace.getElement());\n      const element = document.createElement('div');\n      element.setAttribute('is', 'tabs-tab');\n      element.item = {\n        element,\n\n        getDefaultLocation() {\n          return 'left';\n        },\n\n        getPreferredWidth() {\n          return 144;\n        }\n\n      };\n      const dragEvent = new DragEvent('dragstart');\n      Object.defineProperty(dragEvent, 'target', {\n        value: element\n      });\n      atom.workspace.getElement().handleDragStart(dragEvent);\n      await getNextUpdatePromise();\n      expect(atom.workspace.getLeftDock().refs.wrapperElement.offsetWidth).toBe(144);\n    });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing when text nodes are dragged",
            "suites": [
                "Dock",
                "drag handling"
            ],
            "updatePoint": {
                "line": 375,
                "column": 48
            },
            "line": 375,
            "code": "    it('does nothing when text nodes are dragged', () => {\n      jasmine.attachToDOM(atom.workspace.getElement());\n      const textNode = document.createTextNode('hello');\n      const dragEvent = new DragEvent('dragstart');\n      Object.defineProperty(dragEvent, 'target', {\n        value: textNode\n      });\n      expect(() => atom.workspace.getElement().handleDragStart(dragEvent)).not.toThrow();\n    });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is deprecated",
            "suites": [
                "Dock",
                "::getActiveTextEditor()"
            ],
            "updatePoint": {
                "line": 386,
                "column": 21
            },
            "line": 386,
            "code": "    it('is deprecated', () => {\n      spyOn(Grim, 'deprecate');\n      atom.workspace.getLeftDock().getActiveTextEditor();\n      expect(Grim.deprecate.callCount).toBe(1);\n    });",
            "file": "dock-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is empty when the file doesn't exist",
            "suites": [
                "FileSystemBlobStore"
            ],
            "updatePoint": {
                "line": 16,
                "column": 42
            },
            "line": 16,
            "code": "  it(\"is empty when the file doesn't exist\", function () {\n    expect(blobStore.get('foo')).toBeUndefined();\n    expect(blobStore.get('bar')).toBeUndefined();\n  });",
            "file": "file-system-blob-store-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows to read and write buffers from/to memory without persisting them",
            "suites": [
                "FileSystemBlobStore"
            ],
            "updatePoint": {
                "line": 20,
                "column": 77
            },
            "line": 20,
            "code": "  it('allows to read and write buffers from/to memory without persisting them', function () {\n    blobStore.set('foo', Buffer.from('foo'));\n    blobStore.set('bar', Buffer.from('bar'));\n    expect(blobStore.get('foo')).toEqual(Buffer.from('foo'));\n    expect(blobStore.get('bar')).toEqual(Buffer.from('bar'));\n    expect(blobStore.get('baz')).toBeUndefined();\n    expect(blobStore.get('qux')).toBeUndefined();\n  });",
            "file": "file-system-blob-store-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "persists buffers when saved and retrieves them on load, giving priority to in-memory ones",
            "suites": [
                "FileSystemBlobStore"
            ],
            "updatePoint": {
                "line": 28,
                "column": 95
            },
            "line": 28,
            "code": "  it('persists buffers when saved and retrieves them on load, giving priority to in-memory ones', function () {\n    blobStore.set('foo', Buffer.from('foo'));\n    blobStore.set('bar', Buffer.from('bar'));\n    blobStore.save();\n    blobStore = FileSystemBlobStore.load(storageDirectory);\n    expect(blobStore.get('foo')).toEqual(Buffer.from('foo'));\n    expect(blobStore.get('bar')).toEqual(Buffer.from('bar'));\n    expect(blobStore.get('baz')).toBeUndefined();\n    expect(blobStore.get('qux')).toBeUndefined();\n    blobStore.set('foo', Buffer.from('changed'));\n    expect(blobStore.get('foo')).toEqual(Buffer.from('changed'));\n  });",
            "file": "file-system-blob-store-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "persists in-memory and previously stored buffers, and deletes unused keys when saved",
            "suites": [
                "FileSystemBlobStore"
            ],
            "updatePoint": {
                "line": 40,
                "column": 90
            },
            "line": 40,
            "code": "  it('persists in-memory and previously stored buffers, and deletes unused keys when saved', function () {\n    blobStore.set('foo', Buffer.from('foo'));\n    blobStore.set('bar', Buffer.from('bar'));\n    blobStore.save();\n    blobStore = FileSystemBlobStore.load(storageDirectory);\n    blobStore.set('bar', Buffer.from('changed'));\n    blobStore.set('qux', Buffer.from('qux'));\n    blobStore.save();\n    blobStore = FileSystemBlobStore.load(storageDirectory);\n    expect(blobStore.get('foo')).toBeUndefined();\n    expect(blobStore.get('bar')).toEqual(Buffer.from('changed'));\n    expect(blobStore.get('qux')).toEqual(Buffer.from('qux'));\n  });",
            "file": "file-system-blob-store-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows to delete keys from both memory and stored buffers",
            "suites": [
                "FileSystemBlobStore"
            ],
            "updatePoint": {
                "line": 53,
                "column": 63
            },
            "line": 53,
            "code": "  it('allows to delete keys from both memory and stored buffers', function () {\n    blobStore.set('a', Buffer.from('a'));\n    blobStore.set('b', Buffer.from('b'));\n    blobStore.save();\n    blobStore = FileSystemBlobStore.load(storageDirectory);\n    blobStore.get('a'); // prevent the key from being deleted on save\n\n    blobStore.set('b', Buffer.from('b'));\n    blobStore.set('c', Buffer.from('c'));\n    blobStore.delete('b');\n    blobStore.delete('c');\n    blobStore.save();\n    blobStore = FileSystemBlobStore.load(storageDirectory);\n    expect(blobStore.get('a')).toEqual(Buffer.from('a'));\n    expect(blobStore.get('b')).toBeUndefined();\n    expect(blobStore.get('b')).toBeUndefined();\n    expect(blobStore.get('c')).toBeUndefined();\n  });",
            "file": "file-system-blob-store-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores errors when loading an invalid blob store",
            "suites": [
                "FileSystemBlobStore"
            ],
            "updatePoint": {
                "line": 71,
                "column": 55
            },
            "line": 71,
            "code": "  it('ignores errors when loading an invalid blob store', function () {\n    blobStore.set('a', Buffer.from('a'));\n    blobStore.set('b', Buffer.from('b'));\n    blobStore.save(); // Simulate corruption\n\n    fs.writeFileSync(path.join(storageDirectory, 'MAP'), Buffer.from([0]));\n    fs.writeFileSync(path.join(storageDirectory, 'INVKEYS'), Buffer.from([0]));\n    fs.writeFileSync(path.join(storageDirectory, 'BLOB'), Buffer.from([0]));\n    blobStore = FileSystemBlobStore.load(storageDirectory);\n    expect(blobStore.get('a')).toBeUndefined();\n    expect(blobStore.get('b')).toBeUndefined();\n    blobStore.set('a', Buffer.from('x'));\n    blobStore.set('b', Buffer.from('y'));\n    blobStore.save();\n    blobStore = FileSystemBlobStore.load(storageDirectory);\n    expect(blobStore.get('a')).toEqual(Buffer.from('x'));\n    expect(blobStore.get('b')).toEqual(Buffer.from('y'));\n  });",
            "file": "file-system-blob-store-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "1.0 Query by selector",
            "suites": [
                "query selector",
                "basic"
            ],
            "updatePoint": {
                "line": 25,
                "column": 29
            },
            "line": 25,
            "code": "    it('1.0 Query by selector', () => {\n      const $els = $('li.item[data-role=\"red\"]');\n      const els = document.querySelectorAll('li.item[data-role=\"red\"]');\n      expect($els.length).to.equal(2);\n      [].forEach.call($els, function ($el, i) {\n        expect($el).to.equal(els[i]);\n      });\n    });",
            "file": "fixtures/git/repo-with-submodules/You-Dont-Need-jQuery/test/query.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "1.1 Query by class",
            "suites": [
                "query selector",
                "basic"
            ],
            "updatePoint": {
                "line": 33,
                "column": 26
            },
            "line": 33,
            "code": "    it('1.1 Query by class', () => {\n      const $els = $('.item');\n      const els = document.getElementsByClassName('item');\n      [].forEach.call($els, function ($el, i) {\n        expect($el).to.equal(els[i]);\n      });\n    });",
            "file": "fixtures/git/repo-with-submodules/You-Dont-Need-jQuery/test/query.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "1.2 Query by id",
            "suites": [
                "query selector",
                "basic"
            ],
            "updatePoint": {
                "line": 40,
                "column": 23
            },
            "line": 40,
            "code": "    it('1.2 Query by id', () => {\n      expect($('#nested-ul')[0]).to.equal(document.getElementById('nested-ul'));\n    });",
            "file": "fixtures/git/repo-with-submodules/You-Dont-Need-jQuery/test/query.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "1.3 Query by attribute",
            "suites": [
                "query selector",
                "basic"
            ],
            "updatePoint": {
                "line": 43,
                "column": 30
            },
            "line": 43,
            "code": "    it('1.3 Query by attribute', () => {\n      const $els = $('[data-role=\"blue\"]');\n      const els = document.querySelectorAll('[data-role=\"blue\"]');\n      expect($els.length).to.equal(2);\n      [].forEach.call($els, function ($el, i) {\n        expect($el).to.equal(els[i]);\n      });\n    });",
            "file": "fixtures/git/repo-with-submodules/You-Dont-Need-jQuery/test/query.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "1.4 Query in descendents",
            "suites": [
                "query selector",
                "basic"
            ],
            "updatePoint": {
                "line": 51,
                "column": 32
            },
            "line": 51,
            "code": "    it('1.4 Query in descendents', () => {\n      const $els = $('#query-selector-test1').find('.item');\n      const els = document.getElementById('query-selector-test1').querySelectorAll('.item');\n      expect($els.length).to.equal(4);\n      [].forEach.call($els, function ($el, i) {\n        expect($el).to.equal(els[i]);\n      });\n    });",
            "file": "fixtures/git/repo-with-submodules/You-Dont-Need-jQuery/test/query.spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves with a GitRepository",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectory(directory)",
                "when specified a Directory with a Git repository"
            ],
            "updatePoint": {
                "line": 29,
                "column": 39
            },
            "line": 29,
            "code": "      it('resolves with a GitRepository', async () => {\n        const directory = new Directory(path.join(__dirname, 'fixtures', 'git', 'master.git'));\n        const result = await provider.repositoryForDirectory(directory);\n        expect(result).toBeInstanceOf(GitRepository);\n        expect(provider.pathToRepository[result.getPath()]).toBeTruthy();\n        expect(result.getType()).toBe('git'); // Refresh should be started\n\n        await new Promise(resolve => result.onDidChangeStatuses(resolve));\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves with the same GitRepository for different Directory objects in the same repo",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectory(directory)",
                "when specified a Directory with a Git repository"
            ],
            "updatePoint": {
                "line": 38,
                "column": 95
            },
            "line": 38,
            "code": "      it('resolves with the same GitRepository for different Directory objects in the same repo', async () => {\n        const firstRepo = await provider.repositoryForDirectory(new Directory(path.join(__dirname, 'fixtures', 'git', 'master.git')));\n        const secondRepo = await provider.repositoryForDirectory(new Directory(path.join(__dirname, 'fixtures', 'git', 'master.git', 'objects')));\n        expect(firstRepo).toBeInstanceOf(GitRepository);\n        expect(firstRepo).toBe(secondRepo);\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves with null",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectory(directory)",
                "when specified a Directory without a Git repository"
            ],
            "updatePoint": {
                "line": 46,
                "column": 28
            },
            "line": 46,
            "code": "      it('resolves with null', async () => {\n        const directory = new Directory(temp.mkdirSync('dir'));\n        const repo = await provider.repositoryForDirectory(directory);\n        expect(repo).toBe(null);\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves with null",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectory(directory)",
                "when specified a Directory with an invalid Git repository"
            ],
            "updatePoint": {
                "line": 53,
                "column": 28
            },
            "line": 53,
            "code": "      it('resolves with null', async () => {\n        const dirPath = temp.mkdirSync('dir');\n        fs.writeFileSync(path.join(dirPath, '.git', 'objects'), '');\n        fs.writeFileSync(path.join(dirPath, '.git', 'HEAD'), '');\n        fs.writeFileSync(path.join(dirPath, '.git', 'refs'), '');\n        const directory = new Directory(dirPath);\n        const repo = await provider.repositoryForDirectory(directory);\n        expect(repo).toBe(null);\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a Promise that resolves to a GitRepository",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectory(directory)",
                "when specified a Directory with a valid gitfile-linked repository"
            ],
            "updatePoint": {
                "line": 64,
                "column": 60
            },
            "line": 64,
            "code": "      it('returns a Promise that resolves to a GitRepository', async () => {\n        const gitDirPath = path.join(__dirname, 'fixtures', 'git', 'master.git');\n        const workDirPath = temp.mkdirSync('git-workdir');\n        fs.writeFileSync(path.join(workDirPath, '.git'), `gitdir: ${gitDirPath}\\n`);\n        const directory = new Directory(workDirPath);\n        const result = await provider.repositoryForDirectory(directory);\n        expect(result).toBeInstanceOf(GitRepository);\n        expect(provider.pathToRepository[result.getPath()]).toBeTruthy();\n        expect(result.getType()).toBe('git');\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a Promise that resolves to a GitRepository",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectory(directory)",
                "when specified a Directory with a commondir file for a worktree"
            ],
            "updatePoint": {
                "line": 76,
                "column": 60
            },
            "line": 76,
            "code": "      it('returns a Promise that resolves to a GitRepository', async () => {\n        const directory = new Directory(path.join(__dirname, 'fixtures', 'git', 'master.git', 'worktrees', 'worktree-dir'));\n        const result = await provider.repositoryForDirectory(directory);\n        expect(result).toBeInstanceOf(GitRepository);\n        expect(provider.pathToRepository[result.getPath()]).toBeTruthy();\n        expect(result.getType()).toBe('git');\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a Promise that resolves to null",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectory(directory)",
                "when specified a Directory without exists()"
            ],
            "updatePoint": {
                "line": 99,
                "column": 49
            },
            "line": 99,
            "code": "      it('returns a Promise that resolves to null', async () => {\n        const repo = await provider.repositoryForDirectory(directory);\n        expect(repo).toBe(null);\n        expect(directory.getSubdirectory).toHaveBeenCalledWith('.git');\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves with a GitRepository",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectorySync(directory)",
                "when specified a Directory with a Git repository"
            ],
            "updatePoint": {
                "line": 108,
                "column": 39
            },
            "line": 108,
            "code": "      it('resolves with a GitRepository', async () => {\n        const directory = new Directory(path.join(__dirname, 'fixtures', 'git', 'master.git'));\n        const result = provider.repositoryForDirectorySync(directory);\n        expect(result).toBeInstanceOf(GitRepository);\n        expect(provider.pathToRepository[result.getPath()]).toBeTruthy();\n        expect(result.getType()).toBe('git'); // Refresh should be started\n\n        await new Promise(resolve => result.onDidChangeStatuses(resolve));\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves with the same GitRepository for different Directory objects in the same repo",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectorySync(directory)",
                "when specified a Directory with a Git repository"
            ],
            "updatePoint": {
                "line": 117,
                "column": 95
            },
            "line": 117,
            "code": "      it('resolves with the same GitRepository for different Directory objects in the same repo', () => {\n        const firstRepo = provider.repositoryForDirectorySync(new Directory(path.join(__dirname, 'fixtures', 'git', 'master.git')));\n        const secondRepo = provider.repositoryForDirectorySync(new Directory(path.join(__dirname, 'fixtures', 'git', 'master.git', 'objects')));\n        expect(firstRepo).toBeInstanceOf(GitRepository);\n        expect(firstRepo).toBe(secondRepo);\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves with null",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectorySync(directory)",
                "when specified a Directory without a Git repository"
            ],
            "updatePoint": {
                "line": 125,
                "column": 28
            },
            "line": 125,
            "code": "      it('resolves with null', () => {\n        const directory = new Directory(temp.mkdirSync('dir'));\n        const repo = provider.repositoryForDirectorySync(directory);\n        expect(repo).toBe(null);\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves with null",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectorySync(directory)",
                "when specified a Directory with an invalid Git repository"
            ],
            "updatePoint": {
                "line": 132,
                "column": 28
            },
            "line": 132,
            "code": "      it('resolves with null', () => {\n        const dirPath = temp.mkdirSync('dir');\n        fs.writeFileSync(path.join(dirPath, '.git', 'objects'), '');\n        fs.writeFileSync(path.join(dirPath, '.git', 'HEAD'), '');\n        fs.writeFileSync(path.join(dirPath, '.git', 'refs'), '');\n        const directory = new Directory(dirPath);\n        const repo = provider.repositoryForDirectorySync(directory);\n        expect(repo).toBe(null);\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a Promise that resolves to a GitRepository",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectorySync(directory)",
                "when specified a Directory with a valid gitfile-linked repository"
            ],
            "updatePoint": {
                "line": 143,
                "column": 60
            },
            "line": 143,
            "code": "      it('returns a Promise that resolves to a GitRepository', () => {\n        const gitDirPath = path.join(__dirname, 'fixtures', 'git', 'master.git');\n        const workDirPath = temp.mkdirSync('git-workdir');\n        fs.writeFileSync(path.join(workDirPath, '.git'), `gitdir: ${gitDirPath}\\n`);\n        const directory = new Directory(workDirPath);\n        const result = provider.repositoryForDirectorySync(directory);\n        expect(result).toBeInstanceOf(GitRepository);\n        expect(provider.pathToRepository[result.getPath()]).toBeTruthy();\n        expect(result.getType()).toBe('git');\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a Promise that resolves to a GitRepository",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectorySync(directory)",
                "when specified a Directory with a commondir file for a worktree"
            ],
            "updatePoint": {
                "line": 155,
                "column": 60
            },
            "line": 155,
            "code": "      it('returns a Promise that resolves to a GitRepository', () => {\n        const directory = new Directory(path.join(__dirname, 'fixtures', 'git', 'master.git', 'worktrees', 'worktree-dir'));\n        const result = provider.repositoryForDirectorySync(directory);\n        expect(result).toBeInstanceOf(GitRepository);\n        expect(provider.pathToRepository[result.getPath()]).toBeTruthy();\n        expect(result.getType()).toBe('git');\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null",
            "suites": [
                "GitRepositoryProvider",
                ".repositoryForDirectorySync(directory)",
                "when specified a Directory without existsSync()"
            ],
            "updatePoint": {
                "line": 178,
                "column": 22
            },
            "line": 178,
            "code": "      it('returns null', () => {\n        const repo = provider.repositoryForDirectorySync(directory);\n        expect(repo).toBe(null);\n        expect(directory.getSubdirectory).toHaveBeenCalledWith('.git');\n      });",
            "file": "git-repository-provider-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null when no repository is found",
            "suites": [
                "GitRepository",
                "@open(path)"
            ],
            "updatePoint": {
                "line": 21,
                "column": 48
            },
            "line": 21,
            "code": "    it('returns null when no repository is found', () => {\n      expect(GitRepository.open(path.join(temp.dir, 'nogit.txt'))).toBeNull();\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an exception when no repository is found",
            "suites": [
                "GitRepository",
                "new GitRepository(path)"
            ],
            "updatePoint": {
                "line": 26,
                "column": 55
            },
            "line": 26,
            "code": "    it('throws an exception when no repository is found', () => {\n      expect(() => new GitRepository(path.join(temp.dir, 'nogit.txt'))).toThrow();\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the repository path for a .git directory path with a directory",
            "suites": [
                "GitRepository",
                ".getPath()"
            ],
            "updatePoint": {
                "line": 31,
                "column": 78
            },
            "line": 31,
            "code": "    it('returns the repository path for a .git directory path with a directory', () => {\n      repo = new GitRepository(path.join(__dirname, 'fixtures', 'git', 'master.git', 'objects'));\n      expect(repo.getPath()).toBe(path.join(__dirname, 'fixtures', 'git', 'master.git'));\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the repository path for a repository path",
            "suites": [
                "GitRepository",
                ".getPath()"
            ],
            "updatePoint": {
                "line": 35,
                "column": 57
            },
            "line": 35,
            "code": "    it('returns the repository path for a repository path', () => {\n      repo = new GitRepository(path.join(__dirname, 'fixtures', 'git', 'master.git'));\n      expect(repo.getPath()).toBe(path.join(__dirname, 'fixtures', 'git', 'master.git'));\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true for an ignored path",
            "suites": [
                "GitRepository",
                ".isPathIgnored(path)"
            ],
            "updatePoint": {
                "line": 41,
                "column": 40
            },
            "line": 41,
            "code": "    it('returns true for an ignored path', () => {\n      repo = new GitRepository(path.join(__dirname, 'fixtures', 'git', 'ignore.git'));\n      expect(repo.isPathIgnored('a.txt')).toBeTruthy();\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false for a non-ignored path",
            "suites": [
                "GitRepository",
                ".isPathIgnored(path)"
            ],
            "updatePoint": {
                "line": 45,
                "column": 44
            },
            "line": 45,
            "code": "    it('returns false for a non-ignored path', () => {\n      repo = new GitRepository(path.join(__dirname, 'fixtures', 'git', 'ignore.git'));\n      expect(repo.isPathIgnored('b.txt')).toBeFalsy();\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false if the path has not been modified",
            "suites": [
                "GitRepository",
                ".isPathModified(path)",
                "when the path is unstaged"
            ],
            "updatePoint": {
                "line": 59,
                "column": 57
            },
            "line": 59,
            "code": "      it('returns false if the path has not been modified', () => {\n        expect(repo.isPathModified(filePath)).toBeFalsy();\n      });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true if the path is modified",
            "suites": [
                "GitRepository",
                ".isPathModified(path)",
                "when the path is unstaged"
            ],
            "updatePoint": {
                "line": 62,
                "column": 46
            },
            "line": 62,
            "code": "      it('returns true if the path is modified', () => {\n        fs.writeFileSync(filePath, 'change');\n        expect(repo.isPathModified(filePath)).toBeTruthy();\n      });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true if the path is deleted",
            "suites": [
                "GitRepository",
                ".isPathModified(path)",
                "when the path is unstaged"
            ],
            "updatePoint": {
                "line": 66,
                "column": 45
            },
            "line": 66,
            "code": "      it('returns true if the path is deleted', () => {\n        fs.removeSync(filePath);\n        expect(repo.isPathModified(filePath)).toBeTruthy();\n      });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false if the path is new",
            "suites": [
                "GitRepository",
                ".isPathModified(path)",
                "when the path is unstaged"
            ],
            "updatePoint": {
                "line": 70,
                "column": 42
            },
            "line": 70,
            "code": "      it('returns false if the path is new', () => {\n        expect(repo.isPathModified(newPath)).toBeFalsy();\n      });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true if the path is new",
            "suites": [
                "GitRepository",
                ".isPathNew(path)",
                "when the path is unstaged"
            ],
            "updatePoint": {
                "line": 85,
                "column": 41
            },
            "line": 85,
            "code": "      it('returns true if the path is new', () => {\n        expect(repo.isPathNew(newPath)).toBeTruthy();\n      });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false if the path isn't new",
            "suites": [
                "GitRepository",
                ".isPathNew(path)",
                "when the path is unstaged"
            ],
            "updatePoint": {
                "line": 88,
                "column": 45
            },
            "line": 88,
            "code": "      it(\"returns false if the path isn't new\", () => {\n        expect(repo.isPathNew(filePath)).toBeFalsy();\n      });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "no longer reports a path as modified after checkout",
            "suites": [
                "GitRepository",
                ".checkoutHead(path)"
            ],
            "updatePoint": {
                "line": 100,
                "column": 59
            },
            "line": 100,
            "code": "    it('no longer reports a path as modified after checkout', () => {\n      expect(repo.isPathModified(filePath)).toBeFalsy();\n      fs.writeFileSync(filePath, 'ch ch changes');\n      expect(repo.isPathModified(filePath)).toBeTruthy();\n      expect(repo.checkoutHead(filePath)).toBeTruthy();\n      expect(repo.isPathModified(filePath)).toBeFalsy();\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the contents of the path to the original text",
            "suites": [
                "GitRepository",
                ".checkoutHead(path)"
            ],
            "updatePoint": {
                "line": 107,
                "column": 62
            },
            "line": 107,
            "code": "    it('restores the contents of the path to the original text', () => {\n      fs.writeFileSync(filePath, 'ch ch changes');\n      expect(repo.checkoutHead(filePath)).toBeTruthy();\n      expect(fs.readFileSync(filePath, 'utf8')).toBe('');\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires a status-changed event if the checkout completes successfully",
            "suites": [
                "GitRepository",
                ".checkoutHead(path)"
            ],
            "updatePoint": {
                "line": 112,
                "column": 75
            },
            "line": 112,
            "code": "    it('fires a status-changed event if the checkout completes successfully', () => {\n      fs.writeFileSync(filePath, 'ch ch changes');\n      repo.getPathStatus(filePath);\n      const statusHandler = jasmine.createSpy('statusHandler');\n      repo.onDidChangeStatus(statusHandler);\n      repo.checkoutHead(filePath);\n      expect(statusHandler.callCount).toBe(1);\n      expect(statusHandler.argsForCall[0][0]).toEqual({\n        path: filePath,\n        pathStatus: 0\n      });\n      repo.checkoutHead(filePath);\n      expect(statusHandler.callCount).toBe(1);\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "displays a confirmation dialog by default",
            "suites": [
                "GitRepository",
                ".checkoutHeadForEditor(editor)"
            ],
            "updatePoint": {
                "line": 141,
                "column": 49
            },
            "line": 141,
            "code": "    it('displays a confirmation dialog by default', () => {\n      // Permissions issues with this test on Windows\n      if (process.platform === 'win32') return;\n      atom.confirm.andCallFake(({\n        buttons\n      }) => buttons.OK());\n      atom.config.set('editor.confirmCheckoutHeadRevision', true);\n      repo.checkoutHeadForEditor(editor);\n      expect(fs.readFileSync(filePath, 'utf8')).toBe('');\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not display a dialog when confirmation is disabled",
            "suites": [
                "GitRepository",
                ".checkoutHeadForEditor(editor)"
            ],
            "updatePoint": {
                "line": 151,
                "column": 63
            },
            "line": 151,
            "code": "    it('does not display a dialog when confirmation is disabled', () => {\n      // Flakey EPERM opening a.txt on Win32\n      if (process.platform === 'win32') return;\n      atom.config.set('editor.confirmCheckoutHeadRevision', false);\n      repo.checkoutHeadForEditor(editor);\n      expect(fs.readFileSync(filePath, 'utf8')).toBe('');\n      expect(atom.confirm).not.toHaveBeenCalled();\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an exception when any method is called after it is called",
            "suites": [
                "GitRepository",
                ".destroy()"
            ],
            "updatePoint": {
                "line": 161,
                "column": 72
            },
            "line": 161,
            "code": "    it('throws an exception when any method is called after it is called', () => {\n      repo = new GitRepository(path.join(__dirname, 'fixtures', 'git', 'master.git'));\n      repo.destroy();\n      expect(() => repo.getShortHead()).toThrow();\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "trigger a status-changed event when the new status differs from the last cached one",
            "suites": [
                "GitRepository",
                ".getPathStatus(path)"
            ],
            "updatePoint": {
                "line": 174,
                "column": 91
            },
            "line": 174,
            "code": "    it('trigger a status-changed event when the new status differs from the last cached one', () => {\n      const statusHandler = jasmine.createSpy('statusHandler');\n      repo.onDidChangeStatus(statusHandler);\n      fs.writeFileSync(filePath, '');\n      let status = repo.getPathStatus(filePath);\n      expect(statusHandler.callCount).toBe(1);\n      expect(statusHandler.argsForCall[0][0]).toEqual({\n        path: filePath,\n        pathStatus: status\n      });\n      fs.writeFileSync(filePath, 'abc');\n      status = repo.getPathStatus(filePath);\n      expect(statusHandler.callCount).toBe(1);\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gets the status based on the files inside the directory",
            "suites": [
                "GitRepository",
                ".getDirectoryStatus(path)"
            ],
            "updatePoint": {
                "line": 197,
                "column": 63
            },
            "line": 197,
            "code": "    it('gets the status based on the files inside the directory', () => {\n      expect(repo.isStatusModified(repo.getDirectoryStatus(directoryPath))).toBe(false);\n      fs.writeFileSync(filePath, 'abc');\n      repo.getPathStatus(filePath);\n      expect(repo.isStatusModified(repo.getDirectoryStatus(directoryPath))).toBe(true);\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns status information for all new and modified files",
            "suites": [
                "GitRepository",
                ".refreshStatus()"
            ],
            "updatePoint": {
                "line": 219,
                "column": 65
            },
            "line": 219,
            "code": "    it('returns status information for all new and modified files', async () => {\n      const statusHandler = jasmine.createSpy('statusHandler');\n      repo.onDidChangeStatuses(statusHandler);\n      fs.writeFileSync(modifiedPath, 'making this path modified');\n      await repo.refreshStatus();\n      expect(statusHandler.callCount).toBe(1);\n      expect(repo.getCachedPathStatus(cleanPath)).toBeUndefined();\n      expect(repo.isStatusNew(repo.getCachedPathStatus(newPath))).toBeTruthy();\n      expect(repo.isStatusModified(repo.getCachedPathStatus(modifiedPath))).toBeTruthy();\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "caches the proper statuses when a subdir is open",
            "suites": [
                "GitRepository",
                ".refreshStatus()"
            ],
            "updatePoint": {
                "line": 229,
                "column": 56
            },
            "line": 229,
            "code": "    it('caches the proper statuses when a subdir is open', async () => {\n      const subDir = path.join(workingDirectory, 'dir');\n      fs.mkdirSync(subDir);\n      const filePath = path.join(subDir, 'b.txt');\n      fs.writeFileSync(filePath, '');\n      atom.project.setPaths([subDir]);\n      await atom.workspace.open('b.txt');\n      repo = atom.project.getRepositories()[0];\n      await repo.refreshStatus();\n      const status = repo.getCachedPathStatus(filePath);\n      expect(repo.isStatusModified(status)).toBe(false);\n      expect(repo.isStatusNew(status)).toBe(false);\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works correctly when the project has multiple folders (regression)",
            "suites": [
                "GitRepository",
                ".refreshStatus()"
            ],
            "updatePoint": {
                "line": 242,
                "column": 74
            },
            "line": 242,
            "code": "    it('works correctly when the project has multiple folders (regression)', async () => {\n      atom.project.addPath(workingDirectory);\n      atom.project.addPath(path.join(__dirname, 'fixtures', 'dir'));\n      await repo.refreshStatus();\n      expect(repo.getCachedPathStatus(cleanPath)).toBeUndefined();\n      expect(repo.isStatusNew(repo.getCachedPathStatus(newPath))).toBeTruthy();\n      expect(repo.isStatusModified(repo.getCachedPathStatus(modifiedPath))).toBeTruthy();\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "caches statuses that were looked up synchronously",
            "suites": [
                "GitRepository",
                ".refreshStatus()"
            ],
            "updatePoint": {
                "line": 250,
                "column": 57
            },
            "line": 250,
            "code": "    it('caches statuses that were looked up synchronously', async () => {\n      const originalContent = 'undefined';\n      fs.writeFileSync(modifiedPath, 'making this path modified');\n      repo.getPathStatus('file.txt');\n      fs.writeFileSync(modifiedPath, originalContent);\n      await repo.refreshStatus();\n      expect(repo.isStatusModified(repo.getCachedPathStatus(modifiedPath))).toBeFalsy();\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a status-changed event when a buffer is saved",
            "suites": [
                "GitRepository",
                "buffer events"
            ],
            "updatePoint": {
                "line": 267,
                "column": 59
            },
            "line": 267,
            "code": "    it('emits a status-changed event when a buffer is saved', async () => {\n      editor.insertNewline();\n      const statusHandler = jasmine.createSpy('statusHandler');\n      atom.project.getRepositories()[0].onDidChangeStatus(statusHandler);\n      await editor.save();\n      expect(statusHandler.callCount).toBe(1);\n      expect(statusHandler).toHaveBeenCalledWith({\n        path: editor.getPath(),\n        pathStatus: 256\n      });\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a status-changed event when a buffer is reloaded",
            "suites": [
                "GitRepository",
                "buffer events"
            ],
            "updatePoint": {
                "line": 278,
                "column": 62
            },
            "line": 278,
            "code": "    it('emits a status-changed event when a buffer is reloaded', async () => {\n      fs.writeFileSync(editor.getPath(), 'changed');\n      const statusHandler = jasmine.createSpy('statusHandler');\n      atom.project.getRepositories()[0].onDidChangeStatus(statusHandler);\n      await editor.getBuffer().reload();\n      expect(statusHandler.callCount).toBe(1);\n      expect(statusHandler).toHaveBeenCalledWith({\n        path: editor.getPath(),\n        pathStatus: 256\n      });\n      await editor.getBuffer().reload();\n      expect(statusHandler.callCount).toBe(1);\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a status-changed event when a buffer's path changes",
            "suites": [
                "GitRepository",
                "buffer events"
            ],
            "updatePoint": {
                "line": 291,
                "column": 65
            },
            "line": 291,
            "code": "    it(\"emits a status-changed event when a buffer's path changes\", () => {\n      fs.writeFileSync(editor.getPath(), 'changed');\n      const statusHandler = jasmine.createSpy('statusHandler');\n      atom.project.getRepositories()[0].onDidChangeStatus(statusHandler);\n      editor.getBuffer().emitter.emit('did-change-path');\n      expect(statusHandler.callCount).toBe(1);\n      expect(statusHandler).toHaveBeenCalledWith({\n        path: editor.getPath(),\n        pathStatus: 256\n      });\n      editor.getBuffer().emitter.emit('did-change-path');\n      expect(statusHandler.callCount).toBe(1);\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stops listening to the buffer when the repository is destroyed (regression)",
            "suites": [
                "GitRepository",
                "buffer events"
            ],
            "updatePoint": {
                "line": 304,
                "column": 83
            },
            "line": 304,
            "code": "    it('stops listening to the buffer when the repository is destroyed (regression)', () => {\n      atom.project.getRepositories()[0].destroy();\n      expect(() => editor.save()).not.toThrow();\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "subscribes to all the serialized buffers in the project",
            "suites": [
                "GitRepository",
                "when a project is deserialized"
            ],
            "updatePoint": {
                "line": 314,
                "column": 63
            },
            "line": 314,
            "code": "    it('subscribes to all the serialized buffers in the project', async () => {\n      atom.project.setPaths([copyRepository()]);\n      await atom.workspace.open('file.txt');\n      project2 = new Project({\n        notificationManager: atom.notifications,\n        packageManager: atom.packages,\n        confirm: atom.confirm,\n        grammarRegistry: atom.grammars,\n        applicationDelegate: atom.applicationDelegate\n      });\n      await project2.deserialize(atom.project.serialize({\n        isUnloading: false\n      }));\n      buffer = project2.getBuffers()[0];\n      buffer.append('changes');\n      statusHandler = jasmine.createSpy('statusHandler');\n      project2.getRepositories()[0].onDidChangeStatus(statusHandler);\n      await buffer.save();\n      expect(statusHandler.callCount).toBe(1);\n      expect(statusHandler).toHaveBeenCalledWith({\n        path: buffer.getPath(),\n        pathStatus: 256\n      });\n    });",
            "file": "git-repository-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "assigns to the buffer a language mode with the given language id",
            "suites": [
                "GrammarRegistry",
                ".assignLanguageMode(buffer, languageId)"
            ],
            "updatePoint": {
                "line": 30,
                "column": 72
            },
            "line": 30,
            "code": "    it('assigns to the buffer a language mode with the given language id', async () => {\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      grammarRegistry.loadGrammarSync(require.resolve('language-css/grammars/css.cson'));\n      const buffer = new TextBuffer();\n      expect(grammarRegistry.assignLanguageMode(buffer, 'source.js')).toBe(true);\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('source.js');\n      expect(grammarRegistry.getAssignedLanguageId(buffer)).toBe('source.js'); // Returns true if we found the grammar, even if it didn't change\n\n      expect(grammarRegistry.assignLanguageMode(buffer, 'source.js')).toBe(true); // Language names are not case-sensitive\n\n      expect(grammarRegistry.assignLanguageMode(buffer, 'source.css')).toBe(true);\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('source.css'); // Returns false if no language is found\n\n      expect(grammarRegistry.assignLanguageMode(buffer, 'blub')).toBe(false);\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('source.css');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "makes the buffer use the null grammar",
            "suites": [
                "GrammarRegistry",
                ".assignLanguageMode(buffer, languageId)",
                "when no languageId is passed"
            ],
            "updatePoint": {
                "line": 47,
                "column": 47
            },
            "line": 47,
            "code": "      it('makes the buffer use the null grammar', () => {\n        grammarRegistry.loadGrammarSync(require.resolve('language-css/grammars/css.cson'));\n        const buffer = new TextBuffer();\n        expect(grammarRegistry.assignLanguageMode(buffer, 'source.css')).toBe(true);\n        expect(buffer.getLanguageMode().getLanguageId()).toBe('source.css');\n        expect(grammarRegistry.assignLanguageMode(buffer, null)).toBe(true);\n        expect(buffer.getLanguageMode().getLanguageId()).toBe('text.plain.null-grammar');\n        expect(grammarRegistry.getAssignedLanguageId(buffer)).toBe(null);\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows a TextMate grammar to be assigned directly, even when Tree-sitter is permitted",
            "suites": [
                "GrammarRegistry",
                ".assignGrammar(buffer, grammar)"
            ],
            "updatePoint": {
                "line": 59,
                "column": 93
            },
            "line": 59,
            "code": "    it('allows a TextMate grammar to be assigned directly, even when Tree-sitter is permitted', () => {\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/tree-sitter-javascript.cson'));\n      const tmGrammar = grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      const buffer = new TextBuffer();\n      expect(grammarRegistry.assignGrammar(buffer, tmGrammar)).toBe(true);\n      expect(buffer.getLanguageMode().getGrammar()).toBe(tmGrammar);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a text-mate grammar when `core.useTreeSitterParsers` is false",
            "suites": [
                "GrammarRegistry",
                ".grammarForId(languageId)"
            ],
            "updatePoint": {
                "line": 68,
                "column": 77
            },
            "line": 68,
            "code": "    it('returns a text-mate grammar when `core.useTreeSitterParsers` is false', () => {\n      atom.config.set('core.useTreeSitterParsers', false, {\n        scopeSelector: '.source.js'\n      });\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/tree-sitter-javascript.cson'));\n      const grammar = grammarRegistry.grammarForId('source.js');\n      expect(grammar instanceof FirstMate.Grammar).toBe(true);\n      expect(grammar.scopeName).toBe('source.js');\n      grammarRegistry.removeGrammar(grammar);\n      expect(grammarRegistry.grammarForId('javascript')).toBe(undefined);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a tree-sitter grammar when `core.useTreeSitterParsers` is true",
            "suites": [
                "GrammarRegistry",
                ".grammarForId(languageId)"
            ],
            "updatePoint": {
                "line": 80,
                "column": 78
            },
            "line": 80,
            "code": "    it('returns a tree-sitter grammar when `core.useTreeSitterParsers` is true', () => {\n      atom.config.set('core.useTreeSitterParsers', true);\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/tree-sitter-javascript.cson'));\n      const grammar = grammarRegistry.grammarForId('source.js');\n      expect(grammar instanceof TreeSitterGrammar).toBe(true);\n      expect(grammar.scopeName).toBe('source.js');\n      grammarRegistry.removeGrammar(grammar);\n      expect(grammarRegistry.grammarForId('source.js') instanceof FirstMate.Grammar).toBe(true);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "assigns to the buffer a language mode based on the best available grammar",
            "suites": [
                "GrammarRegistry",
                ".autoAssignLanguageMode(buffer)"
            ],
            "updatePoint": {
                "line": 92,
                "column": 81
            },
            "line": 92,
            "code": "    it('assigns to the buffer a language mode based on the best available grammar', () => {\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      grammarRegistry.loadGrammarSync(require.resolve('language-css/grammars/css.cson'));\n      const buffer = new TextBuffer();\n      buffer.setPath('foo.js');\n      expect(grammarRegistry.assignLanguageMode(buffer, 'source.css')).toBe(true);\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('source.css');\n      grammarRegistry.autoAssignLanguageMode(buffer);\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('source.js');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "assigns a grammar to the buffer based on its path",
            "suites": [
                "GrammarRegistry",
                ".maintainLanguageMode(buffer)"
            ],
            "updatePoint": {
                "line": 104,
                "column": 57
            },
            "line": 104,
            "code": "    it('assigns a grammar to the buffer based on its path', async () => {\n      const buffer = new TextBuffer();\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      grammarRegistry.loadGrammarSync(require.resolve('language-c/grammars/c.cson'));\n      buffer.setPath('test.js');\n      grammarRegistry.maintainLanguageMode(buffer);\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('source.js');\n      buffer.setPath('test.c');\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('source.c');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the buffer's grammar when a more appropriate text-mate grammar is added for its path",
            "suites": [
                "GrammarRegistry",
                ".maintainLanguageMode(buffer)"
            ],
            "updatePoint": {
                "line": 114,
                "column": 100
            },
            "line": 114,
            "code": "    it(\"updates the buffer's grammar when a more appropriate text-mate grammar is added for its path\", async () => {\n      atom.config.set('core.useTreeSitterParsers', false);\n      const buffer = new TextBuffer();\n      expect(buffer.getLanguageMode().getLanguageId()).toBe(null);\n      buffer.setPath('test.js');\n      grammarRegistry.maintainLanguageMode(buffer);\n      const textMateGrammar = grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      expect(buffer.getLanguageMode().grammar).toBe(textMateGrammar);\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/tree-sitter-javascript.cson'));\n      expect(buffer.getLanguageMode().grammar).toBe(textMateGrammar);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the buffer's grammar when a more appropriate tree-sitter grammar is added for its path",
            "suites": [
                "GrammarRegistry",
                ".maintainLanguageMode(buffer)"
            ],
            "updatePoint": {
                "line": 125,
                "column": 102
            },
            "line": 125,
            "code": "    it(\"updates the buffer's grammar when a more appropriate tree-sitter grammar is added for its path\", async () => {\n      atom.config.set('core.useTreeSitterParsers', true);\n      const buffer = new TextBuffer();\n      expect(buffer.getLanguageMode().getLanguageId()).toBe(null);\n      buffer.setPath('test.js');\n      grammarRegistry.maintainLanguageMode(buffer);\n      const treeSitterGrammar = grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/tree-sitter-javascript.cson'));\n      expect(buffer.getLanguageMode().grammar).toBe(treeSitterGrammar);\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      expect(buffer.getLanguageMode().grammar).toBe(treeSitterGrammar);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can be overridden by calling .assignLanguageMode",
            "suites": [
                "GrammarRegistry",
                ".maintainLanguageMode(buffer)"
            ],
            "updatePoint": {
                "line": 136,
                "column": 56
            },
            "line": 136,
            "code": "    it('can be overridden by calling .assignLanguageMode', () => {\n      const buffer = new TextBuffer();\n      buffer.setPath('test.js');\n      grammarRegistry.maintainLanguageMode(buffer);\n      grammarRegistry.loadGrammarSync(require.resolve('language-css/grammars/css.cson'));\n      expect(grammarRegistry.assignLanguageMode(buffer, 'source.css')).toBe(true);\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('source.css');\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('source.css');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a disposable that can be used to stop the registry from updating the buffer",
            "suites": [
                "GrammarRegistry",
                ".maintainLanguageMode(buffer)"
            ],
            "updatePoint": {
                "line": 146,
                "column": 91
            },
            "line": 146,
            "code": "    it('returns a disposable that can be used to stop the registry from updating the buffer', async () => {\n      const buffer = new TextBuffer();\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      const previousSubscriptionCount = buffer.emitter.getTotalListenerCount();\n      const disposable = grammarRegistry.maintainLanguageMode(buffer);\n      expect(buffer.emitter.getTotalListenerCount()).toBeGreaterThan(previousSubscriptionCount);\n      expect(retainedBufferCount(grammarRegistry)).toBe(1);\n      buffer.setPath('test.js');\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('source.js');\n      buffer.setPath('test.txt');\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('text.plain.null-grammar');\n      disposable.dispose();\n      expect(buffer.emitter.getTotalListenerCount()).toBe(previousSubscriptionCount);\n      expect(retainedBufferCount(grammarRegistry)).toBe(0);\n      buffer.setPath('test.js');\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('text.plain.null-grammar');\n      expect(retainedBufferCount(grammarRegistry)).toBe(0);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't do anything when called a second time with the same buffer",
            "suites": [
                "GrammarRegistry",
                ".maintainLanguageMode(buffer)"
            ],
            "updatePoint": {
                "line": 164,
                "column": 74
            },
            "line": 164,
            "code": "    it(\"doesn't do anything when called a second time with the same buffer\", async () => {\n      const buffer = new TextBuffer();\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      const disposable1 = grammarRegistry.maintainLanguageMode(buffer);\n      const disposable2 = grammarRegistry.maintainLanguageMode(buffer);\n      buffer.setPath('test.js');\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('source.js');\n      disposable2.dispose();\n      buffer.setPath('test.txt');\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('text.plain.null-grammar');\n      disposable1.dispose();\n      buffer.setPath('test.js');\n      expect(buffer.getLanguageMode().getLanguageId()).toBe('text.plain.null-grammar');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not retain the buffer after the buffer is destroyed",
            "suites": [
                "GrammarRegistry",
                ".maintainLanguageMode(buffer)"
            ],
            "updatePoint": {
                "line": 178,
                "column": 64
            },
            "line": 178,
            "code": "    it('does not retain the buffer after the buffer is destroyed', () => {\n      const buffer = new TextBuffer();\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      const disposable = grammarRegistry.maintainLanguageMode(buffer);\n      expect(retainedBufferCount(grammarRegistry)).toBe(1);\n      expect(subscriptionCount(grammarRegistry)).toBe(3);\n      buffer.destroy();\n      expect(retainedBufferCount(grammarRegistry)).toBe(0);\n      expect(subscriptionCount(grammarRegistry)).toBe(1);\n      expect(buffer.emitter.getTotalListenerCount()).toBe(0);\n      disposable.dispose();\n      expect(retainedBufferCount(grammarRegistry)).toBe(0);\n      expect(subscriptionCount(grammarRegistry)).toBe(1);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not retain the buffer when the grammar registry is destroyed",
            "suites": [
                "GrammarRegistry",
                ".maintainLanguageMode(buffer)"
            ],
            "updatePoint": {
                "line": 192,
                "column": 73
            },
            "line": 192,
            "code": "    it('does not retain the buffer when the grammar registry is destroyed', () => {\n      const buffer = new TextBuffer();\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      grammarRegistry.maintainLanguageMode(buffer);\n      expect(retainedBufferCount(grammarRegistry)).toBe(1);\n      expect(subscriptionCount(grammarRegistry)).toBe(3);\n      grammarRegistry.clear();\n      expect(retainedBufferCount(grammarRegistry)).toBe(0);\n      expect(subscriptionCount(grammarRegistry)).toBe(1);\n      expect(buffer.emitter.getTotalListenerCount()).toBe(0);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "always returns a grammar",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)"
            ],
            "updatePoint": {
                "line": 205,
                "column": 32
            },
            "line": 205,
            "code": "    it('always returns a grammar', () => {\n      const registry = new GrammarRegistry({\n        config: atom.config\n      });\n      expect(registry.selectGrammar().scopeName).toBe('text.plain.null-grammar');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects the text.plain grammar over the null grammar",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)"
            ],
            "updatePoint": {
                "line": 211,
                "column": 60
            },
            "line": 211,
            "code": "    it('selects the text.plain grammar over the null grammar', async () => {\n      await atom.packages.activatePackage('language-text');\n      expect(atom.grammars.selectGrammar('test.txt').scopeName).toBe('text.plain');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects a grammar based on the file path case insensitively",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)"
            ],
            "updatePoint": {
                "line": 215,
                "column": 67
            },
            "line": 215,
            "code": "    it('selects a grammar based on the file path case insensitively', async () => {\n      await atom.packages.activatePackage('language-coffee-script');\n      expect(atom.grammars.selectGrammar('/tmp/source.coffee').scopeName).toBe('source.coffee');\n      expect(atom.grammars.selectGrammar('/tmp/source.COFFEE').scopeName).toBe('source.coffee');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "normalizes back slashes to forward slashes when matching the fileTypes",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "on Windows"
            ],
            "updatePoint": {
                "line": 233,
                "column": 80
            },
            "line": 233,
            "code": "      it('normalizes back slashes to forward slashes when matching the fileTypes', async () => {\n        await atom.packages.activatePackage('language-git');\n        expect(atom.grammars.selectGrammar('something\\\\.git\\\\config').scopeName).toBe('source.git-config');\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can use the filePath to load the correct grammar based on the grammar's filetype",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "on Windows"
            ],
            "updatePoint": {
                "line": 238,
                "column": 88
            },
            "line": 238,
            "code": "    it(\"can use the filePath to load the correct grammar based on the grammar's filetype\", async () => {\n      await atom.packages.activatePackage('language-git');\n      await atom.packages.activatePackage('language-javascript');\n      await atom.packages.activatePackage('language-ruby');\n      expect(atom.grammars.selectGrammar('file.js').name).toBe('JavaScript'); // based on extension (.js)\n\n      expect(atom.grammars.selectGrammar(path.join(temp.dir, '.git', 'config')).name).toBe('Git Config'); // based on end of the path (.git/config)\n\n      expect(atom.grammars.selectGrammar('Rakefile').name).toBe('Ruby'); // based on the file's basename (Rakefile)\n\n      expect(atom.grammars.selectGrammar('curb').name).toBe('Null Grammar');\n      expect(atom.grammars.selectGrammar('/hu.git/config').name).toBe('Null Grammar');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the filePath's shebang line if the grammar cannot be determined by the extension or basename",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "on Windows"
            ],
            "updatePoint": {
                "line": 251,
                "column": 105
            },
            "line": 251,
            "code": "    it(\"uses the filePath's shebang line if the grammar cannot be determined by the extension or basename\", async () => {\n      await atom.packages.activatePackage('language-javascript');\n      await atom.packages.activatePackage('language-ruby');\n\n      const filePath = require.resolve('./fixtures/shebang');\n\n      expect(atom.grammars.selectGrammar(filePath).name).toBe('Ruby');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the number of newlines in the first line regex to determine the number of lines to test against",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "on Windows"
            ],
            "updatePoint": {
                "line": 259,
                "column": 108
            },
            "line": 259,
            "code": "    it('uses the number of newlines in the first line regex to determine the number of lines to test against', async () => {\n      await atom.packages.activatePackage('language-property-list');\n      await atom.packages.activatePackage('language-coffee-script');\n      let fileContent = 'first-line\\n<html>';\n      expect(atom.grammars.selectGrammar('dummy.coffee', fileContent).name).toBe('CoffeeScript');\n      fileContent = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\n      expect(atom.grammars.selectGrammar('grammar.tmLanguage', fileContent).name).toBe('Null Grammar');\n      fileContent += '\\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">';\n      expect(atom.grammars.selectGrammar('grammar.tmLanguage', fileContent).name).toBe('Property List (XML)');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't read the file when the file contents are specified",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "on Windows"
            ],
            "updatePoint": {
                "line": 269,
                "column": 66
            },
            "line": 269,
            "code": "    it(\"doesn't read the file when the file contents are specified\", async () => {\n      await atom.packages.activatePackage('language-ruby');\n\n      const filePath = require.resolve('./fixtures/shebang');\n\n      const filePathContents = fs.readFileSync(filePath, 'utf8');\n      spyOn(fs, 'read').andCallThrough();\n      expect(atom.grammars.selectGrammar(filePath, filePathContents).name).toBe('Ruby');\n      expect(fs.read).not.toHaveBeenCalled();\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects the grammar with the longest fileType match",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "when multiple grammars have matching fileTypes"
            ],
            "updatePoint": {
                "line": 280,
                "column": 61
            },
            "line": 280,
            "code": "      it('selects the grammar with the longest fileType match', () => {\n        const grammarPath1 = temp.path({\n          suffix: '.json'\n        });\n        fs.writeFileSync(grammarPath1, JSON.stringify({\n          name: 'test1',\n          scopeName: 'source1',\n          fileTypes: ['test']\n        }));\n        const grammar1 = atom.grammars.loadGrammarSync(grammarPath1);\n        expect(atom.grammars.selectGrammar('more.test', '')).toBe(grammar1);\n        fs.removeSync(grammarPath1);\n        const grammarPath2 = temp.path({\n          suffix: '.json'\n        });\n        fs.writeFileSync(grammarPath2, JSON.stringify({\n          name: 'test2',\n          scopeName: 'source2',\n          fileTypes: ['test', 'more.test']\n        }));\n        const grammar2 = atom.grammars.loadGrammarSync(grammarPath2);\n        expect(atom.grammars.selectGrammar('more.test', '')).toBe(grammar2);\n        return fs.removeSync(grammarPath2);\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "favors non-bundled packages when breaking scoring ties",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "when multiple grammars have matching fileTypes"
            ],
            "updatePoint": {
                "line": 305,
                "column": 62
            },
            "line": 305,
            "code": "    it('favors non-bundled packages when breaking scoring ties', async () => {\n      await atom.packages.activatePackage('language-ruby');\n      await atom.packages.activatePackage(path.join(__dirname, 'fixtures', 'packages', 'package-with-rb-filetype'));\n      atom.grammars.grammarForScopeName('source.ruby').bundledPackage = true;\n      atom.grammars.grammarForScopeName('test.rb').bundledPackage = false;\n      expect(atom.grammars.selectGrammar('test.rb', '#!/usr/bin/env ruby').scopeName).toBe('source.ruby');\n      expect(atom.grammars.selectGrammar('test.rb', '#!/usr/bin/env testruby').scopeName).toBe('test.rb');\n      expect(atom.grammars.selectGrammar('test.rb').scopeName).toBe('test.rb');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw an exception (regression)",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "when there is no file path"
            ],
            "updatePoint": {
                "line": 315,
                "column": 50
            },
            "line": 315,
            "code": "      it('does not throw an exception (regression)', () => {\n        expect(() => atom.grammars.selectGrammar(null, '#!/usr/bin/ruby')).not.toThrow();\n        expect(() => atom.grammars.selectGrammar(null, '')).not.toThrow();\n        expect(() => atom.grammars.selectGrammar(null, null)).not.toThrow();\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "considers the custom file types as well as those defined in the grammar",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "when the user has custom grammar file types"
            ],
            "updatePoint": {
                "line": 322,
                "column": 81
            },
            "line": 322,
            "code": "      it('considers the custom file types as well as those defined in the grammar', async () => {\n        await atom.packages.activatePackage('language-ruby');\n        atom.config.set('core.customFileTypes', {\n          'source.ruby': ['Cheffile']\n        });\n        expect(atom.grammars.selectGrammar('build/Cheffile', 'cookbook \"postgres\"').scopeName).toBe('source.ruby');\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "favors user-defined file types over built-in ones of equal length",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "when the user has custom grammar file types"
            ],
            "updatePoint": {
                "line": 329,
                "column": 75
            },
            "line": 329,
            "code": "      it('favors user-defined file types over built-in ones of equal length', async () => {\n        await atom.packages.activatePackage('language-ruby');\n        await atom.packages.activatePackage('language-coffee-script');\n        atom.config.set('core.customFileTypes', {\n          'source.coffee': ['Rakefile'],\n          'source.ruby': ['Cakefile']\n        });\n        expect(atom.grammars.selectGrammar('Rakefile', '').scopeName).toBe('source.coffee');\n        expect(atom.grammars.selectGrammar('Cakefile', '').scopeName).toBe('source.ruby');\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "favors user-defined file types over grammars with matching first-line-regexps",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "when the user has custom grammar file types"
            ],
            "updatePoint": {
                "line": 339,
                "column": 87
            },
            "line": 339,
            "code": "      it('favors user-defined file types over grammars with matching first-line-regexps', async () => {\n        await atom.packages.activatePackage('language-ruby');\n        await atom.packages.activatePackage('language-javascript');\n        atom.config.set('core.customFileTypes', {\n          'source.ruby': ['bootstrap']\n        });\n        expect(atom.grammars.selectGrammar('bootstrap', '#!/usr/bin/env node').scopeName).toBe('source.ruby');\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "favors a grammar with a matching file type over one with m matching first line pattern",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "when the user has custom grammar file types"
            ],
            "updatePoint": {
                "line": 348,
                "column": 94
            },
            "line": 348,
            "code": "    it('favors a grammar with a matching file type over one with m matching first line pattern', async () => {\n      await atom.packages.activatePackage('language-ruby');\n      await atom.packages.activatePackage('language-javascript');\n      expect(atom.grammars.selectGrammar('foo.rb', '#!/usr/bin/env node').scopeName).toBe('source.ruby');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "favors a text-mate grammar over a tree-sitter grammar when `core.useTreeSitterParsers` is false",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "tree-sitter vs text-mate"
            ],
            "updatePoint": {
                "line": 354,
                "column": 105
            },
            "line": 354,
            "code": "      it('favors a text-mate grammar over a tree-sitter grammar when `core.useTreeSitterParsers` is false', () => {\n        atom.config.set('core.useTreeSitterParsers', false, {\n          scopeSelector: '.source.js'\n        });\n        grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n        grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/tree-sitter-javascript.cson'));\n        const grammar = grammarRegistry.selectGrammar('test.js');\n        expect(grammar.scopeName).toBe('source.js');\n        expect(grammar instanceof FirstMate.Grammar).toBe(true);\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "favors a tree-sitter grammar over a text-mate grammar when `core.useTreeSitterParsers` is true",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "tree-sitter vs text-mate"
            ],
            "updatePoint": {
                "line": 364,
                "column": 104
            },
            "line": 364,
            "code": "      it('favors a tree-sitter grammar over a text-mate grammar when `core.useTreeSitterParsers` is true', () => {\n        atom.config.set('core.useTreeSitterParsers', true);\n        grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n        grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/tree-sitter-javascript.cson'));\n        const grammar = grammarRegistry.selectGrammar('test.js');\n        expect(grammar instanceof TreeSitterGrammar).toBe(true);\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only favors a tree-sitter grammar if it actually matches in some way (regression)",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "tree-sitter vs text-mate"
            ],
            "updatePoint": {
                "line": 371,
                "column": 91
            },
            "line": 371,
            "code": "      it('only favors a tree-sitter grammar if it actually matches in some way (regression)', () => {\n        atom.config.set('core.useTreeSitterParsers', true);\n        grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/tree-sitter-javascript.cson'));\n        const grammar = grammarRegistry.selectGrammar('test', '');\n        expect(grammar.name).toBe('Null Grammar');\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "recognizes C++ header files",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "tree-sitter grammars with content regexes"
            ],
            "updatePoint": {
                "line": 379,
                "column": 37
            },
            "line": 379,
            "code": "      it('recognizes C++ header files', () => {\n        atom.config.set('core.useTreeSitterParsers', true);\n        grammarRegistry.loadGrammarSync(require.resolve('language-c/grammars/tree-sitter-c.cson'));\n        grammarRegistry.loadGrammarSync(require.resolve('language-c/grammars/tree-sitter-cpp.cson'));\n        grammarRegistry.loadGrammarSync(require.resolve('language-coffee-script/grammars/coffeescript.cson'));\n        let grammar = grammarRegistry.selectGrammar('test.h', dedent`\n          #include <string.h>\n\n          typedef struct {\n            void verb();\n          } Noun;\n        `);\n        expect(grammar.name).toBe('C');\n        grammar = grammarRegistry.selectGrammar('test.h', dedent`\n          #include <string>\n\n          class Noun {\n           public:\n            void verb();\n          };\n        `);\n        expect(grammar.name).toBe('C++'); // The word `class` only indicates C++ in `.h` files, not in all files.\n\n        grammar = grammarRegistry.selectGrammar('test.coffee', dedent`\n          module.exports =\n          class Noun\n            verb: -> true\n        `);\n        expect(grammar.name).toBe('CoffeeScript');\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "recognizes C++ files that do not match the content regex (regression)",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "tree-sitter grammars with content regexes"
            ],
            "updatePoint": {
                "line": 409,
                "column": 79
            },
            "line": 409,
            "code": "      it('recognizes C++ files that do not match the content regex (regression)', () => {\n        atom.config.set('core.useTreeSitterParsers', true);\n        grammarRegistry.loadGrammarSync(require.resolve('language-c/grammars/tree-sitter-c.cson'));\n        grammarRegistry.loadGrammarSync(require.resolve('language-c/grammars/c++.cson'));\n        grammarRegistry.loadGrammarSync(require.resolve('language-c/grammars/tree-sitter-cpp.cson'));\n        let grammar = grammarRegistry.selectGrammar('test.cc', dedent`\n          int a();\n        `);\n        expect(grammar.name).toBe('C++');\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not apply content regexes from grammars without filetype or first line matches",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "tree-sitter grammars with content regexes"
            ],
            "updatePoint": {
                "line": 419,
                "column": 93
            },
            "line": 419,
            "code": "      it('does not apply content regexes from grammars without filetype or first line matches', () => {\n        atom.config.set('core.useTreeSitterParsers', true);\n        grammarRegistry.loadGrammarSync(require.resolve('language-c/grammars/tree-sitter-cpp.cson'));\n        let grammar = grammarRegistry.selectGrammar('', dedent`\n          class Foo\n            # this is ruby, not C++\n          end\n        `);\n        expect(grammar.name).toBe('Null Grammar');\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "recognizes shell scripts with shebang lines",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "tree-sitter grammars with content regexes"
            ],
            "updatePoint": {
                "line": 429,
                "column": 53
            },
            "line": 429,
            "code": "      it('recognizes shell scripts with shebang lines', () => {\n        atom.config.set('core.useTreeSitterParsers', true);\n        grammarRegistry.loadGrammarSync(require.resolve('language-shellscript/grammars/shell-unix-bash.cson'));\n        grammarRegistry.loadGrammarSync(require.resolve('language-shellscript/grammars/tree-sitter-bash.cson'));\n        let grammar = grammarRegistry.selectGrammar('test.h', dedent`\n          #!/bin/bash\n\n          echo \"hi\"\n        `);\n        expect(grammar.name).toBe('Shell Script');\n        expect(grammar instanceof TreeSitterGrammar).toBeTruthy();\n        grammar = grammarRegistry.selectGrammar('test.h', dedent`\n          # vim: set ft=bash\n\n          echo \"hi\"\n        `);\n        expect(grammar.name).toBe('Shell Script');\n        expect(grammar instanceof TreeSitterGrammar).toBeTruthy();\n        atom.config.set('core.useTreeSitterParsers', false);\n        grammar = grammarRegistry.selectGrammar('test.h', dedent`\n          #!/bin/bash\n\n          echo \"hi\"\n        `);\n        expect(grammar.name).toBe('Shell Script');\n        expect(grammar instanceof TreeSitterGrammar).toBeFalsy();\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "recognizes JavaScript files that use Flow",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "tree-sitter grammars with content regexes"
            ],
            "updatePoint": {
                "line": 456,
                "column": 51
            },
            "line": 456,
            "code": "      it('recognizes JavaScript files that use Flow', () => {\n        atom.config.set('core.useTreeSitterParsers', true);\n        grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/tree-sitter-javascript.cson'));\n        grammarRegistry.loadGrammarSync(require.resolve('language-typescript/grammars/tree-sitter-flow.cson'));\n        let grammar = grammarRegistry.selectGrammar('test.js', dedent`\n          // Copyright something\n          // @flow\n\n          module.exports = function () { return 1 + 1 }\n        `);\n        expect(grammar.name).toBe('Flow JavaScript');\n        grammar = grammarRegistry.selectGrammar('test.js', dedent`\n          module.exports = function () { return 1 + 1 }\n        `);\n        expect(grammar.name).toBe('JavaScript');\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "favors grammars that match the content regex",
            "suites": [
                "GrammarRegistry",
                ".selectGrammar(filePath)",
                "text-mate grammars with content regexes"
            ],
            "updatePoint": {
                "line": 474,
                "column": 54
            },
            "line": 474,
            "code": "      it('favors grammars that match the content regex', () => {\n        const grammar1 = {\n          name: 'foo',\n          fileTypes: ['foo']\n        };\n        grammarRegistry.addGrammar(grammar1);\n        const grammar2 = {\n          name: 'foo++',\n          contentRegex: new OnigRegExp('.*bar'),\n          fileTypes: ['foo']\n        };\n        grammarRegistry.addGrammar(grammar2);\n        const grammar = grammarRegistry.selectGrammar('test.foo', dedent`\n          ${'\\n'.repeat(50)}bar${'\\n'.repeat(50)}\n        `);\n        expect(grammar).toBe(grammar2);\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the grammar, so it won't be returned by selectGrammar",
            "suites": [
                "GrammarRegistry",
                ".removeGrammar(grammar)"
            ],
            "updatePoint": {
                "line": 494,
                "column": 69
            },
            "line": 494,
            "code": "    it(\"removes the grammar, so it won't be returned by selectGrammar\", async () => {\n      await atom.packages.activatePackage('language-css');\n      const grammar = atom.grammars.selectGrammar('foo.css');\n      atom.grammars.removeGrammar(grammar);\n      expect(atom.grammars.selectGrammar('foo.css').name).not.toBe(grammar.name);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds an injection point to the grammar with the given id",
            "suites": [
                "GrammarRegistry",
                ".addInjectionPoint(languageId, {type, language, content})"
            ],
            "updatePoint": {
                "line": 517,
                "column": 64
            },
            "line": 517,
            "code": "    it('adds an injection point to the grammar with the given id', async () => {\n      await atom.packages.activatePackage('language-javascript');\n      atom.grammars.addInjectionPoint('javascript', injectionPoint);\n      const grammar = atom.grammars.grammarForId('javascript');\n      expect(grammar.injectionPoints).toContain(injectionPoint);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the injection point once the grammar is loaded",
            "suites": [
                "GrammarRegistry",
                ".addInjectionPoint(languageId, {type, language, content})",
                "when called before a grammar with the given id is loaded"
            ],
            "updatePoint": {
                "line": 524,
                "column": 61
            },
            "line": 524,
            "code": "      it('adds the injection point once the grammar is loaded', async () => {\n        atom.grammars.addInjectionPoint('javascript', injectionPoint);\n        await atom.packages.activatePackage('language-javascript');\n        const grammar = atom.grammars.grammarForId('javascript');\n        expect(grammar.injectionPoints).toContain(injectionPoint);\n      });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "persists editors' grammar overrides",
            "suites": [
                "GrammarRegistry",
                "serialization"
            ],
            "updatePoint": {
                "line": 533,
                "column": 43
            },
            "line": 533,
            "code": "    it(\"persists editors' grammar overrides\", async () => {\n      const buffer1 = new TextBuffer();\n      const buffer2 = new TextBuffer();\n      grammarRegistry.loadGrammarSync(require.resolve('language-c/grammars/c.cson'));\n      grammarRegistry.loadGrammarSync(require.resolve('language-html/grammars/html.cson'));\n      grammarRegistry.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      grammarRegistry.maintainLanguageMode(buffer1);\n      grammarRegistry.maintainLanguageMode(buffer2);\n      grammarRegistry.assignLanguageMode(buffer1, 'source.c');\n      grammarRegistry.assignLanguageMode(buffer2, 'source.js');\n      const buffer1Copy = await TextBuffer.deserialize(buffer1.serialize());\n      const buffer2Copy = await TextBuffer.deserialize(buffer2.serialize());\n      const grammarRegistryCopy = new GrammarRegistry({\n        config: atom.config\n      });\n      grammarRegistryCopy.deserialize(JSON.parse(JSON.stringify(grammarRegistry.serialize())));\n      grammarRegistryCopy.loadGrammarSync(require.resolve('language-c/grammars/c.cson'));\n      grammarRegistryCopy.loadGrammarSync(require.resolve('language-html/grammars/html.cson'));\n      expect(buffer1Copy.getLanguageMode().getLanguageId()).toBe(null);\n      expect(buffer2Copy.getLanguageMode().getLanguageId()).toBe(null);\n      grammarRegistryCopy.maintainLanguageMode(buffer1Copy);\n      grammarRegistryCopy.maintainLanguageMode(buffer2Copy);\n      expect(buffer1Copy.getLanguageMode().getLanguageId()).toBe('source.c');\n      expect(buffer2Copy.getLanguageMode().getLanguageId()).toBe(null);\n      grammarRegistryCopy.loadGrammarSync(require.resolve('language-javascript/grammars/javascript.cson'));\n      expect(buffer1Copy.getLanguageMode().getLanguageId()).toBe('source.c');\n      expect(buffer2Copy.getLanguageMode().getLanguageId()).toBe('source.js');\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns only Tree-sitter grammars by default",
            "suites": [
                "GrammarRegistry",
                "when working with grammars"
            ],
            "updatePoint": {
                "line": 566,
                "column": 52
            },
            "line": 566,
            "code": "    it('returns only Tree-sitter grammars by default', async () => {\n      const tmGrammars = atom.grammars.getGrammars();\n      const allGrammars = atom.grammars.getGrammars({\n        includeTreeSitter: true\n      });\n      expect(allGrammars.length).toBeGreaterThan(tmGrammars.length);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "executes the foreach callback on both Tree-sitter and TextMate grammars",
            "suites": [
                "GrammarRegistry",
                "when working with grammars"
            ],
            "updatePoint": {
                "line": 573,
                "column": 79
            },
            "line": 573,
            "code": "    it('executes the foreach callback on both Tree-sitter and TextMate grammars', async () => {\n      const numAllGrammars = atom.grammars.getGrammars({\n        includeTreeSitter: true\n      }).length;\n      let i = 0;\n      atom.grammars.forEachGrammar(() => i++);\n      expect(i).toBe(numAllGrammars);\n    });",
            "file": "grammar-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "it has no gutters",
            "suites": [
                "GutterContainer",
                "when initialized"
            ],
            "updatePoint": {
                "line": 14,
                "column": 58
            },
            "line": 14,
            "code": "  describe('when initialized', () => it('it has no gutters', () => {\n    expect(gutterContainer.getGutters().length).toBe(0);\n  }));",
            "file": "gutter-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new gutter",
            "suites": [
                "GutterContainer",
                "::addGutter"
            ],
            "updatePoint": {
                "line": 18,
                "column": 28
            },
            "line": 18,
            "code": "    it('creates a new gutter', () => {\n      const newGutter = gutterContainer.addGutter({\n        'test-gutter': 'test-gutter',\n        priority: 1\n      });\n      expect(gutterContainer.getGutters()).toEqual([newGutter]);\n      expect(newGutter.priority).toBe(1);\n    });",
            "file": "gutter-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error if the provided gutter name is already in use",
            "suites": [
                "GutterContainer",
                "::addGutter"
            ],
            "updatePoint": {
                "line": 26,
                "column": 69
            },
            "line": 26,
            "code": "    it('throws an error if the provided gutter name is already in use', () => {\n      const name = 'test-gutter';\n      gutterContainer.addGutter({\n        name\n      });\n      expect(gutterContainer.addGutter.bind(null, {\n        name\n      })).toThrow();\n    });",
            "file": "gutter-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps added gutters sorted by ascending priority",
            "suites": [
                "GutterContainer",
                "::addGutter"
            ],
            "updatePoint": {
                "line": 35,
                "column": 56
            },
            "line": 35,
            "code": "    it('keeps added gutters sorted by ascending priority', () => {\n      const gutter1 = gutterContainer.addGutter({\n        name: 'first',\n        priority: 1\n      });\n      const gutter3 = gutterContainer.addGutter({\n        name: 'third',\n        priority: 3\n      });\n      const gutter2 = gutterContainer.addGutter({\n        name: 'second',\n        priority: 2\n      });\n      expect(gutterContainer.getGutters()).toEqual([gutter1, gutter2, gutter3]);\n    });",
            "file": "gutter-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the gutter if it is contained by this GutterContainer",
            "suites": [
                "GutterContainer",
                "::removeGutter"
            ],
            "updatePoint": {
                "line": 58,
                "column": 69
            },
            "line": 58,
            "code": "    it('removes the gutter if it is contained by this GutterContainer', () => {\n      const gutter = gutterContainer.addGutter({\n        'test-gutter': 'test-gutter'\n      });\n      expect(gutterContainer.getGutters()).toEqual([gutter]);\n      gutterContainer.removeGutter(gutter);\n      expect(gutterContainer.getGutters().length).toBe(0);\n      expect(removedGutters).toEqual([gutter.name]);\n    });",
            "file": "gutter-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error if the gutter is not within this GutterContainer",
            "suites": [
                "GutterContainer",
                "::removeGutter"
            ],
            "updatePoint": {
                "line": 67,
                "column": 72
            },
            "line": 67,
            "code": "    it('throws an error if the gutter is not within this GutterContainer', () => {\n      const fakeOtherTextEditor = {};\n      const otherGutterContainer = new GutterContainer(fakeOtherTextEditor);\n      const gutter = new Gutter('gutter-name', otherGutterContainer);\n      expect(gutterContainer.removeGutter.bind(null, gutter)).toThrow();\n    });",
            "file": "gutter-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears its array of gutters and destroys custom gutters",
            "suites": [
                "GutterContainer",
                "::destroy"
            ],
            "updatePoint": {
                "line": 74,
                "column": 89
            },
            "line": 74,
            "code": "  describe('::destroy', () => it('clears its array of gutters and destroys custom gutters', () => {\n    const newGutter = gutterContainer.addGutter({\n      'test-gutter': 'test-gutter',\n      priority: 1\n    });\n    const newGutterSpy = jasmine.createSpy();\n    newGutter.onDidDestroy(newGutterSpy);\n    gutterContainer.destroy();\n    expect(newGutterSpy).toHaveBeenCalled();\n    expect(gutterContainer.getGutters()).toEqual([]);\n  }));",
            "file": "gutter-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "hides the gutter if it is visible.",
            "suites": [
                "Gutter",
                "::hide"
            ],
            "updatePoint": {
                "line": 9,
                "column": 65
            },
            "line": 9,
            "code": "  describe('::hide', () => it('hides the gutter if it is visible.', () => {\n    const options = {\n      name,\n      visible: true\n    };\n    const gutter = new Gutter(fakeGutterContainer, options);\n    const events = [];\n    gutter.onDidChangeVisible(gutter => events.push(gutter.isVisible()));\n    expect(gutter.isVisible()).toBe(true);\n    gutter.hide();\n    expect(gutter.isVisible()).toBe(false);\n    expect(events).toEqual([false]);\n    gutter.hide();\n    expect(gutter.isVisible()).toBe(false); // An event should only be emitted when the visibility changes.\n\n    expect(events.length).toBe(1);\n  }));",
            "file": "gutter-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shows the gutter if it is hidden.",
            "suites": [
                "Gutter",
                "::show"
            ],
            "updatePoint": {
                "line": 26,
                "column": 64
            },
            "line": 26,
            "code": "  describe('::show', () => it('shows the gutter if it is hidden.', () => {\n    const options = {\n      name,\n      visible: false\n    };\n    const gutter = new Gutter(fakeGutterContainer, options);\n    const events = [];\n    gutter.onDidChangeVisible(gutter => events.push(gutter.isVisible()));\n    expect(gutter.isVisible()).toBe(false);\n    gutter.show();\n    expect(gutter.isVisible()).toBe(true);\n    expect(events).toEqual([true]);\n    gutter.show();\n    expect(gutter.isVisible()).toBe(true); // An event should only be emitted when the visibility changes.\n\n    expect(events.length).toBe(1);\n  }));",
            "file": "gutter-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the gutter from its container.",
            "suites": [
                "Gutter",
                "::destroy"
            ],
            "updatePoint": {
                "line": 54,
                "column": 46
            },
            "line": 54,
            "code": "    it('removes the gutter from its container.', () => {\n      const gutter = new Gutter(mockGutterContainer, {\n        name\n      });\n      gutter.destroy();\n      expect(mockGutterContainerRemovedGutters).toEqual([gutter]);\n    });",
            "file": "gutter-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls all callbacks registered on ::onDidDestroy.",
            "suites": [
                "Gutter",
                "::destroy"
            ],
            "updatePoint": {
                "line": 61,
                "column": 57
            },
            "line": 61,
            "code": "    it('calls all callbacks registered on ::onDidDestroy.', () => {\n      const gutter = new Gutter(mockGutterContainer, {\n        name\n      });\n      let didDestroy = false;\n      gutter.onDidDestroy(() => {\n        didDestroy = true;\n      });\n      gutter.destroy();\n      expect(didDestroy).toBe(true);\n    });",
            "file": "gutter-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not allow destroying the line-number gutter",
            "suites": [
                "Gutter",
                "::destroy"
            ],
            "updatePoint": {
                "line": 72,
                "column": 56
            },
            "line": 72,
            "code": "    it('does not allow destroying the line-number gutter', () => {\n      const gutter = new Gutter(mockGutterContainer, {\n        name: 'line-number'\n      });\n      expect(gutter.destroy).toThrow();\n    });",
            "file": "gutter-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "registers the 'clear-project-history' command function",
            "suites": [
                "HistoryManager",
                "constructor"
            ],
            "updatePoint": {
                "line": 42,
                "column": 62
            },
            "line": 42,
            "code": "    it(\"registers the 'clear-project-history' command function\", () => {\n      expect(commandRegistry.add).toHaveBeenCalled();\n      const cmdCall = commandRegistry.add.calls[0];\n      expect(cmdCall.args.length).toBe(3);\n      expect(cmdCall.args[0]).toBe('atom-workspace');\n      expect(typeof cmdCall.args[1]['application:clear-project-history']).toBe('function');\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns an array of HistoryProjects",
            "suites": [
                "HistoryManager",
                "constructor",
                "getProjects"
            ],
            "updatePoint": {
                "line": 50,
                "column": 45
            },
            "line": 50,
            "code": "      it('returns an array of HistoryProjects', () => {\n        expect(historyManager.getProjects()).toEqual([new HistoryProject(['/1', 'c:\\\\2'], new Date(2016, 9, 17, 17, 16, 23)), new HistoryProject(['/test'], new Date(2016, 9, 17, 11, 12, 13))]);\n      });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns an array of HistoryProjects that is not mutable state",
            "suites": [
                "HistoryManager",
                "constructor",
                "getProjects"
            ],
            "updatePoint": {
                "line": 53,
                "column": 71
            },
            "line": 53,
            "code": "      it('returns an array of HistoryProjects that is not mutable state', () => {\n        const firstProjects = historyManager.getProjects();\n        firstProjects.pop();\n        firstProjects[0].path = 'modified';\n        const secondProjects = historyManager.getProjects();\n        expect(secondProjects.length).toBe(2);\n        expect(secondProjects[0].path).not.toBe('modified');\n      });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears the list of projects",
            "suites": [
                "HistoryManager",
                "constructor",
                "clearProjects"
            ],
            "updatePoint": {
                "line": 63,
                "column": 37
            },
            "line": 63,
            "code": "      it('clears the list of projects', async () => {\n        expect(historyManager.getProjects().length).not.toBe(0);\n        await historyManager.clearProjects();\n        expect(historyManager.getProjects().length).toBe(0);\n      });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "saves the state",
            "suites": [
                "HistoryManager",
                "constructor",
                "clearProjects"
            ],
            "updatePoint": {
                "line": 68,
                "column": 25
            },
            "line": 68,
            "code": "      it('saves the state', async () => {\n        await historyManager.clearProjects();\n        const historyManager2 = new HistoryManager({\n          stateStore,\n          project,\n          commands: commandRegistry\n        });\n        await historyManager2.loadState();\n        expect(historyManager.getProjects().length).toBe(0);\n      });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires the onDidChangeProjects event",
            "suites": [
                "HistoryManager",
                "constructor",
                "clearProjects"
            ],
            "updatePoint": {
                "line": 78,
                "column": 45
            },
            "line": 78,
            "code": "      it('fires the onDidChangeProjects event', async () => {\n        const didChangeSpy = jasmine.createSpy();\n        historyManager.onDidChangeProjects(didChangeSpy);\n        await historyManager.clearProjects();\n        expect(historyManager.getProjects().length).toBe(0);\n        expect(didChangeSpy).toHaveBeenCalled();\n      });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "listens to project.onDidChangePaths adding a new project",
            "suites": [
                "HistoryManager",
                "constructor",
                "clearProjects"
            ],
            "updatePoint": {
                "line": 86,
                "column": 64
            },
            "line": 86,
            "code": "    it('listens to project.onDidChangePaths adding a new project', () => {\n      const start = new Date();\n      project.didChangePathsListener(['/a/new', '/path/or/two']);\n      const projects = historyManager.getProjects();\n      expect(projects.length).toBe(3);\n      expect(projects[0].paths).toEqual(['/a/new', '/path/or/two']);\n      expect(projects[0].lastOpened).not.toBeLessThan(start);\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "listens to project.onDidChangePaths updating an existing project",
            "suites": [
                "HistoryManager",
                "constructor",
                "clearProjects"
            ],
            "updatePoint": {
                "line": 94,
                "column": 72
            },
            "line": 94,
            "code": "    it('listens to project.onDidChangePaths updating an existing project', () => {\n      const start = new Date();\n      project.didChangePathsListener(['/test']);\n      const projects = historyManager.getProjects();\n      expect(projects.length).toBe(2);\n      expect(projects[0].paths).toEqual(['/test']);\n      expect(projects[0].lastOpened).not.toBeLessThan(start);\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "defaults to an empty array if no state",
            "suites": [
                "HistoryManager",
                "loadState"
            ],
            "updatePoint": {
                "line": 104,
                "column": 46
            },
            "line": 104,
            "code": "    it('defaults to an empty array if no state', async () => {\n      await stateStore.clear();\n      await historyManager.loadState();\n      expect(historyManager.getProjects()).toEqual([]);\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "defaults to an empty array if no projects",
            "suites": [
                "HistoryManager",
                "loadState"
            ],
            "updatePoint": {
                "line": 109,
                "column": 49
            },
            "line": 109,
            "code": "    it('defaults to an empty array if no projects', async () => {\n      await stateStore.save('history-manager', {});\n      await historyManager.loadState();\n      expect(historyManager.getProjects()).toEqual([]);\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a new project to the end",
            "suites": [
                "HistoryManager",
                "addProject"
            ],
            "updatePoint": {
                "line": 116,
                "column": 37
            },
            "line": 116,
            "code": "    it('adds a new project to the end', async () => {\n      const date = new Date(2010, 10, 9, 8, 7, 6);\n      await historyManager.addProject(['/a/b'], date);\n      const projects = historyManager.getProjects();\n      expect(projects.length).toBe(3);\n      expect(projects[2].paths).toEqual(['/a/b']);\n      expect(projects[2].lastOpened).toBe(date);\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a new project to the start",
            "suites": [
                "HistoryManager",
                "addProject"
            ],
            "updatePoint": {
                "line": 124,
                "column": 39
            },
            "line": 124,
            "code": "    it('adds a new project to the start', async () => {\n      const date = new Date();\n      await historyManager.addProject(['/so/new'], date);\n      const projects = historyManager.getProjects();\n      expect(projects.length).toBe(3);\n      expect(projects[0].paths).toEqual(['/so/new']);\n      expect(projects[0].lastOpened).toBe(date);\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates an existing project and moves it to the start",
            "suites": [
                "HistoryManager",
                "addProject"
            ],
            "updatePoint": {
                "line": 132,
                "column": 61
            },
            "line": 132,
            "code": "    it('updates an existing project and moves it to the start', async () => {\n      const date = new Date();\n      await historyManager.addProject(['/test'], date);\n      const projects = historyManager.getProjects();\n      expect(projects.length).toBe(2);\n      expect(projects[0].paths).toEqual(['/test']);\n      expect(projects[0].lastOpened).toBe(date);\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires the onDidChangeProjects event when adding a project",
            "suites": [
                "HistoryManager",
                "addProject"
            ],
            "updatePoint": {
                "line": 140,
                "column": 65
            },
            "line": 140,
            "code": "    it('fires the onDidChangeProjects event when adding a project', async () => {\n      const didChangeSpy = jasmine.createSpy();\n      const beforeCount = historyManager.getProjects().length;\n      historyManager.onDidChangeProjects(didChangeSpy);\n      await historyManager.addProject(['/test-new'], new Date());\n      expect(didChangeSpy).toHaveBeenCalled();\n      expect(historyManager.getProjects().length).toBe(beforeCount + 1);\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires the onDidChangeProjects event when updating a project",
            "suites": [
                "HistoryManager",
                "addProject"
            ],
            "updatePoint": {
                "line": 148,
                "column": 67
            },
            "line": 148,
            "code": "    it('fires the onDidChangeProjects event when updating a project', async () => {\n      const didChangeSpy = jasmine.createSpy();\n      const beforeCount = historyManager.getProjects().length;\n      historyManager.onDidChangeProjects(didChangeSpy);\n      await historyManager.addProject(['/test'], new Date());\n      expect(didChangeSpy).toHaveBeenCalled();\n      expect(historyManager.getProjects().length).toBe(beforeCount);\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a project that matches the paths",
            "suites": [
                "HistoryManager",
                "getProject"
            ],
            "updatePoint": {
                "line": 158,
                "column": 48
            },
            "line": 158,
            "code": "    it('returns a project that matches the paths', () => {\n      const project = historyManager.getProject(['/1', 'c:\\\\2']);\n      expect(project).not.toBeNull();\n      expect(project.paths).toEqual(['/1', 'c:\\\\2']);\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null when it can't find the project",
            "suites": [
                "HistoryManager",
                "getProject"
            ],
            "updatePoint": {
                "line": 163,
                "column": 51
            },
            "line": 163,
            "code": "    it(\"returns null when it can't find the project\", () => {\n      const project = historyManager.getProject(['/1']);\n      expect(project).toBeNull();\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "saves the state",
            "suites": [
                "HistoryManager",
                "saveState"
            ],
            "updatePoint": {
                "line": 181,
                "column": 23
            },
            "line": 181,
            "code": "    it('saves the state', async () => {\n      await historyManager.addProject(['/save/state']);\n      await historyManager.saveState();\n      const historyManager2 = new HistoryManager({\n        stateStore,\n        project,\n        commands: commandRegistry\n      });\n      spyOn(historyManager2.stateStore, 'load').andCallFake(name => Promise.resolve(savedHistory));\n      await historyManager2.loadState();\n      expect(historyManager2.getProjects()[0].paths).toEqual(['/save/state']);\n    });",
            "file": "history-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can open a file in Atom and perform basic operations on it",
            "suites": [
                "Smoke Test"
            ],
            "updatePoint": {
                "line": 32,
                "column": 64
            },
            "line": 32,
            "code": "  it('can open a file in Atom and perform basic operations on it', async () => {\n    const tempDirPath = temp.mkdirSync('empty-dir');\n    const filePath = path.join(tempDirPath, 'new-file');\n    fs.writeFileSync(filePath, '', {\n      encoding: 'utf8'\n    });\n    runAtom([tempDirPath], {\n      ATOM_HOME: atomHome\n    }, async client => {\n      const roots = await client.treeViewRootDirectories();\n      expect(roots).toEqual([tempDirPath]);\n      await client.execute(filePath => atom.workspace.open(filePath), filePath);\n      const textEditorElement = await client.$('atom-text-editor');\n      await textEditorElement.waitForExist(5000);\n      await client.waitForPaneItemCount(1, 1000);\n      await textEditorElement.click();\n      const closestElement = await client.execute(() => document.activeElement.closest('atom-text-editor'));\n      expect(closestElement).not.toBeNull();\n      await client.keys('Hello!');\n      const text = await client.execute(() => atom.workspace.getActiveTextEditor().getText());\n      expect(text).toBe('Hello!');\n      await client.dispatchCommand('editor:delete-line');\n    });\n  });",
            "file": "integration/smoke-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires when user keymap is loaded",
            "suites": [
                "keymap-extensions",
                "did-load-user-keymap"
            ],
            "updatePoint": {
                "line": 18,
                "column": 77
            },
            "line": 18,
            "code": "  describe('did-load-user-keymap', () => it('fires when user keymap is loaded', function () {\n    spyOn(this, 'userKeymapLoaded');\n    atom.keymaps.loadUserKeymap();\n    expect(this.userKeymapLoaded).toHaveBeenCalled();\n  }));",
            "file": "keymap-extensions-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens an empty window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows"
            ],
            "updatePoint": {
                "line": 72,
                "column": 31
            },
            "line": 72,
            "code": "      it('opens an empty window', async function () {\n        await scenario.launch(parseCommandLine([]));\n        await scenario.assert('[_ _]');\n      }); // This is also the case when a user clicks on a file in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows"
            ],
            "updatePoint": {
                "line": 77,
                "column": 22
            },
            "line": 77,
            "code": "      it('opens a file', async function () {\n        await scenario.open(parseCommandLine(['a/1.md']));\n        await scenario.assert('[_ 1.md]');\n      }); // This is also the case when a user clicks on a folder in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows"
            ],
            "updatePoint": {
                "line": 83,
                "column": 27
            },
            "line": 83,
            "code": "      it('opens a directory', async function () {\n        await scenario.open(parseCommandLine(['a']));\n        await scenario.assert('[a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows"
            ],
            "updatePoint": {
                "line": 87,
                "column": 33
            },
            "line": 87,
            "code": "      it('opens a file with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'a/1.md']));\n        await scenario.assert('[_ 1.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows"
            ],
            "updatePoint": {
                "line": 91,
                "column": 38
            },
            "line": 91,
            "code": "      it('opens a directory with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'a']));\n        await scenario.assert('[a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows"
            ],
            "updatePoint": {
                "line": 95,
                "column": 40
            },
            "line": 95,
            "code": "      it('opens a file with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'a/1.md']));\n        await scenario.assert('[_ 1.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows"
            ],
            "updatePoint": {
                "line": 99,
                "column": 45
            },
            "line": 99,
            "code": "      it('opens a directory with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'a']));\n        await scenario.assert('[a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't restore windows when launched with no arguments",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"no\""
            ],
            "updatePoint": {
                "line": 121,
                "column": 69
            },
            "line": 121,
            "code": "          it(\"doesn't restore windows when launched with no arguments\", async function () {\n            await scenario.launch({\n              app\n            });\n            await scenario.assert('[_ _]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't restore windows when launched with paths to open",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"no\""
            ],
            "updatePoint": {
                "line": 127,
                "column": 70
            },
            "line": 127,
            "code": "          it(\"doesn't restore windows when launched with paths to open\", async function () {\n            await scenario.launch({\n              app,\n              pathsToOpen: ['a/1.md']\n            });\n            await scenario.assert('[_ 1.md]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't restore windows when --new-window is provided",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"no\""
            ],
            "updatePoint": {
                "line": 134,
                "column": 67
            },
            "line": 134,
            "code": "          it(\"doesn't restore windows when --new-window is provided\", async function () {\n            await scenario.launch({\n              app,\n              newWindow: true\n            });\n            await scenario.assert('[_ _]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores windows when launched with no arguments",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"yes\""
            ],
            "updatePoint": {
                "line": 146,
                "column": 62
            },
            "line": 146,
            "code": "          it('restores windows when launched with no arguments', async function () {\n            await scenario.launch({\n              app\n            });\n            await scenario.assert('[b _] [c _]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't restore windows when launched with paths to open",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"yes\""
            ],
            "updatePoint": {
                "line": 152,
                "column": 70
            },
            "line": 152,
            "code": "          it(\"doesn't restore windows when launched with paths to open\", async function () {\n            await scenario.launch({\n              app,\n              pathsToOpen: ['a/1.md']\n            });\n            await scenario.assert('[_ 1.md]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't restore windows when --new-window is provided",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"yes\""
            ],
            "updatePoint": {
                "line": 159,
                "column": 67
            },
            "line": 159,
            "code": "          it(\"doesn't restore windows when --new-window is provided\", async function () {\n            await scenario.launch({\n              app,\n              newWindow: true\n            });\n            await scenario.assert('[_ _]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores windows when launched with no arguments",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"always\""
            ],
            "updatePoint": {
                "line": 171,
                "column": 62
            },
            "line": 171,
            "code": "          it('restores windows when launched with no arguments', async function () {\n            await scenario.launch({\n              app\n            });\n            await scenario.assert('[b _] [c _]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores windows when launched with a project path to open",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"always\""
            ],
            "updatePoint": {
                "line": 177,
                "column": 72
            },
            "line": 177,
            "code": "          it('restores windows when launched with a project path to open', async function () {\n            await scenario.launch({\n              app,\n              pathsToOpen: ['a']\n            });\n            await scenario.assert('[b _] [c _] [a _]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores windows when launched with a file path to open",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"always\""
            ],
            "updatePoint": {
                "line": 184,
                "column": 69
            },
            "line": 184,
            "code": "          it('restores windows when launched with a file path to open', async function () {\n            await scenario.launch({\n              app,\n              pathsToOpen: ['a/1.md']\n            });\n            await scenario.assert('[b _] [c 1.md]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "collapses new paths into restored windows when appropriate",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"always\""
            ],
            "updatePoint": {
                "line": 191,
                "column": 72
            },
            "line": 191,
            "code": "          it('collapses new paths into restored windows when appropriate', async function () {\n            await scenario.launch({\n              app,\n              pathsToOpen: ['b/2.md']\n            });\n            await scenario.assert('[b 2.md] [c _]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't restore windows when --new-window is provided",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"always\""
            ],
            "updatePoint": {
                "line": 198,
                "column": 67
            },
            "line": 198,
            "code": "          it(\"doesn't restore windows when --new-window is provided\", async function () {\n            await scenario.launch({\n              app,\n              newWindow: true\n            });\n            await scenario.assert('[_ _]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't restore windows on open, just launch",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with previous window state",
                "with core.restorePreviousWindowsOnStart set to \"always\""
            ],
            "updatePoint": {
                "line": 205,
                "column": 58
            },
            "line": 205,
            "code": "          it(\"doesn't restore windows on open, just launch\", async function () {\n            await scenario.launch({\n              app,\n              pathsToOpen: ['a'],\n              newWindow: true\n            });\n            await scenario.open(parseCommandLine(['b']));\n            await scenario.assert('[a _] [b _]');\n          });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reads \"initialPaths\" as project roots",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with unversioned application state"
            ],
            "updatePoint": {
                "line": 217,
                "column": 49
            },
            "line": 217,
            "code": "        it('reads \"initialPaths\" as project roots', async function () {\n          const app = scenario.addApplication({\n            applicationJson: [{\n              initialPaths: [scenario.convertRootPath('a')]\n            }, {\n              initialPaths: [scenario.convertRootPath('b'), scenario.convertRootPath('c')]\n            }]\n          });\n          app.config.set('core.restorePreviousWindowsOnStart', 'always');\n          await scenario.launch({\n            app\n          });\n          await scenario.assert('[a _] [b,c _]');\n        });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "filters file paths from project root lists",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with no open windows",
                "with unversioned application state"
            ],
            "updatePoint": {
                "line": 231,
                "column": 54
            },
            "line": 231,
            "code": "        it('filters file paths from project root lists', async function () {\n          const app = scenario.addApplication({\n            applicationJson: [{\n              initialPaths: [scenario.convertRootPath('b'), scenario.convertEditorPath('a/1.md')]\n            }]\n          });\n          app.config.set('core.restorePreviousWindowsOnStart', 'always');\n          await scenario.launch({\n            app\n          });\n          await scenario.assert('[b _]');\n        });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a new, empty window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one empty window"
            ],
            "updatePoint": {
                "line": 250,
                "column": 35
            },
            "line": 250,
            "code": "      it('opens a new, empty window', async function () {\n        await scenario.open(parseCommandLine([]));\n        await scenario.assert('[_ _] [_ _]');\n      }); // This is also the case when a user clicks on a file in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one empty window"
            ],
            "updatePoint": {
                "line": 255,
                "column": 22
            },
            "line": 255,
            "code": "      it('opens a file', async function () {\n        await scenario.open(parseCommandLine(['a/1.md']));\n        await scenario.assert('[_ 1.md]');\n      }); // This is also the case when a user clicks on a folder in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one empty window"
            ],
            "updatePoint": {
                "line": 260,
                "column": 27
            },
            "line": 260,
            "code": "      it('opens a directory', async function () {\n        await scenario.open(parseCommandLine(['a']));\n        await scenario.assert('[a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one empty window"
            ],
            "updatePoint": {
                "line": 264,
                "column": 33
            },
            "line": 264,
            "code": "      it('opens a file with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'a/1.md']));\n        await scenario.assert('[_ 1.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one empty window"
            ],
            "updatePoint": {
                "line": 268,
                "column": 38
            },
            "line": 268,
            "code": "      it('opens a directory with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'a']));\n        await scenario.assert('[a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one empty window"
            ],
            "updatePoint": {
                "line": 272,
                "column": 40
            },
            "line": 272,
            "code": "      it('opens a file with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'a/1.md']));\n        await scenario.assert('[_ _] [_ 1.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one empty window"
            ],
            "updatePoint": {
                "line": 276,
                "column": 45
            },
            "line": 276,
            "code": "      it('opens a directory with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'a']));\n        await scenario.assert('[_ _] [a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a new, empty window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 286,
                "column": 35
            },
            "line": 286,
            "code": "      it('opens a new, empty window', async function () {\n        await scenario.open(parseCommandLine([]));\n        await scenario.assert('[a _] [_ _]');\n      }); // This is also the case when a user clicks on a file within the project root in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file within the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 291,
                "column": 46
            },
            "line": 291,
            "code": "      it('opens a file within the project root', async function () {\n        await scenario.open(parseCommandLine(['a/1.md']));\n        await scenario.assert('[a 1.md]');\n      }); // This is also the case when a user clicks on a project root folder in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory that matches the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 296,
                "column": 57
            },
            "line": 296,
            "code": "      it('opens a directory that matches the project root', async function () {\n        await scenario.open(parseCommandLine(['a']));\n        await scenario.assert('[a _]');\n      }); // This is also the case when a user clicks on a file outside the project root in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file outside the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 301,
                "column": 47
            },
            "line": 301,
            "code": "      it('opens a file outside the project root', async function () {\n        await scenario.open(parseCommandLine(['b/2.md']));\n        await scenario.assert('[a 2.md]');\n      }); // This is also the case when a user clicks on a new folder in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory other than the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 306,
                "column": 55
            },
            "line": 306,
            "code": "      it('opens a directory other than the project root', async function () {\n        await scenario.open(parseCommandLine(['b']));\n        await scenario.assert('[a _] [b _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file within the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 310,
                "column": 57
            },
            "line": 310,
            "code": "      it('opens a file within the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'a/1.md']));\n        await scenario.assert('[a 1.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory that matches the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 314,
                "column": 68
            },
            "line": 314,
            "code": "      it('opens a directory that matches the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'a']));\n        await scenario.assert('[a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file outside the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 318,
                "column": 58
            },
            "line": 318,
            "code": "      it('opens a file outside the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'b/2.md']));\n        await scenario.assert('[a 2.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory other than the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 322,
                "column": 66
            },
            "line": 322,
            "code": "      it('opens a directory other than the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'b']));\n        await scenario.assert('[a,b _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file within the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 326,
                "column": 64
            },
            "line": 326,
            "code": "      it('opens a file within the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'a/1.md']));\n        await scenario.assert('[a _] [_ 1.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory that matches the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 330,
                "column": 75
            },
            "line": 330,
            "code": "      it('opens a directory that matches the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'a']));\n        await scenario.assert('[a _] [a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file outside the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 334,
                "column": 65
            },
            "line": 334,
            "code": "      it('opens a file outside the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'b/2.md']));\n        await scenario.assert('[a _] [_ 2.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory other than the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with one window that has a project root"
            ],
            "updatePoint": {
                "line": 338,
                "column": 73
            },
            "line": 338,
            "code": "      it('opens a directory other than the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'b']));\n        await scenario.assert('[a _] [b _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a new, empty window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 348,
                "column": 35
            },
            "line": 348,
            "code": "      it('opens a new, empty window', async function () {\n        await scenario.open(parseCommandLine([]));\n        await scenario.assert('[a _] [_ _] [_ _]');\n      }); // This is also the case when a user clicks on a file within the project root in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file within the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 353,
                "column": 46
            },
            "line": 353,
            "code": "      it('opens a file within the project root', async function () {\n        await scenario.open(parseCommandLine(['a/1.md']));\n        await scenario.assert('[a 1.md] [_ _]');\n      }); // This is also the case when a user clicks on a project root folder in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory that matches the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 358,
                "column": 57
            },
            "line": 358,
            "code": "      it('opens a directory that matches the project root', async function () {\n        await scenario.open(parseCommandLine(['a']));\n        await scenario.assert('[a _] [_ _]');\n      }); // This is also the case when a user clicks on a file outside the project root in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file outside the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 363,
                "column": 47
            },
            "line": 363,
            "code": "      it('opens a file outside the project root', async function () {\n        await scenario.open(parseCommandLine(['b/2.md']));\n        await scenario.assert('[a _] [_ 2.md]');\n      }); // This is also the case when a user clicks on a new folder in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory other than the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 368,
                "column": 55
            },
            "line": 368,
            "code": "      it('opens a directory other than the project root', async function () {\n        await scenario.open(parseCommandLine(['b']));\n        await scenario.assert('[a _] [b _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file within the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 372,
                "column": 57
            },
            "line": 372,
            "code": "      it('opens a file within the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'a/1.md']));\n        await scenario.assert('[a 1.md] [_ _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory that matches the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 376,
                "column": 68
            },
            "line": 376,
            "code": "      it('opens a directory that matches the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'a']));\n        await scenario.assert('[a _] [_ _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file outside the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 380,
                "column": 58
            },
            "line": 380,
            "code": "      it('opens a file outside the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'b/2.md']));\n        await scenario.assert('[a _] [_ 2.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory other than the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 384,
                "column": 66
            },
            "line": 384,
            "code": "      it('opens a directory other than the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'b']));\n        await scenario.assert('[a _] [b _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file within the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 388,
                "column": 64
            },
            "line": 388,
            "code": "      it('opens a file within the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'a/1.md']));\n        await scenario.assert('[a _] [_ _] [_ 1.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory that matches the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 392,
                "column": 75
            },
            "line": 392,
            "code": "      it('opens a directory that matches the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'a']));\n        await scenario.assert('[a _] [_ _] [a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file outside the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 396,
                "column": 65
            },
            "line": 396,
            "code": "      it('opens a file outside the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'b/2.md']));\n        await scenario.assert('[a _] [_ _] [_ 2.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory other than the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one with a project root and one empty"
            ],
            "updatePoint": {
                "line": 400,
                "column": 73
            },
            "line": 400,
            "code": "      it('opens a directory other than the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'b']));\n        await scenario.assert('[a _] [_ _] [b _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a new, empty window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 410,
                "column": 35
            },
            "line": 410,
            "code": "      it('opens a new, empty window', async function () {\n        await scenario.open(parseCommandLine([]));\n        await scenario.assert('[_ _] [a _] [_ _]');\n      }); // This is also the case when a user clicks on a file within the project root in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file within the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 415,
                "column": 46
            },
            "line": 415,
            "code": "      it('opens a file within the project root', async function () {\n        await scenario.open(parseCommandLine(['a/1.md']));\n        await scenario.assert('[_ _] [a 1.md]');\n      }); // This is also the case when a user clicks on a project root folder in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory that matches the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 420,
                "column": 57
            },
            "line": 420,
            "code": "      it('opens a directory that matches the project root', async function () {\n        await scenario.open(parseCommandLine(['a']));\n        await scenario.assert('[_ _] [a _]');\n      }); // This is also the case when a user clicks on a file outside the project root in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file outside the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 425,
                "column": 47
            },
            "line": 425,
            "code": "      it('opens a file outside the project root', async function () {\n        await scenario.open(parseCommandLine(['b/2.md']));\n        await scenario.assert('[_ 2.md] [a _]');\n      }); // This is also the case when a user clicks on a new folder in their file manager",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory other than the project root",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 430,
                "column": 55
            },
            "line": 430,
            "code": "      it('opens a directory other than the project root', async function () {\n        await scenario.open(parseCommandLine(['b']));\n        await scenario.assert('[b _] [a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file within the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 434,
                "column": 57
            },
            "line": 434,
            "code": "      it('opens a file within the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'a/1.md']));\n        await scenario.assert('[_ _] [a 1.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory that matches the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 438,
                "column": 68
            },
            "line": 438,
            "code": "      it('opens a directory that matches the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'a']));\n        await scenario.assert('[_ _] [a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file outside the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 442,
                "column": 58
            },
            "line": 442,
            "code": "      it('opens a file outside the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'b/2.md']));\n        await scenario.assert('[_ _] [a 2.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory other than the project root with --add",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 446,
                "column": 66
            },
            "line": 446,
            "code": "      it('opens a directory other than the project root with --add', async function () {\n        await scenario.open(parseCommandLine(['--add', 'b']));\n        await scenario.assert('[_ _] [a,b _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file within the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 450,
                "column": 64
            },
            "line": 450,
            "code": "      it('opens a file within the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'a/1.md']));\n        await scenario.assert('[_ _] [a _] [_ 1.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory that matches the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 454,
                "column": 75
            },
            "line": 454,
            "code": "      it('opens a directory that matches the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'a']));\n        await scenario.assert('[_ _] [a _] [a _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file outside the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 458,
                "column": 65
            },
            "line": 458,
            "code": "      it('opens a file outside the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'b/2.md']));\n        await scenario.assert('[_ _] [a _] [_ 2.md]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory other than the project root with --new-window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "with two windows, one empty and one with a project root"
            ],
            "updatePoint": {
                "line": 462,
                "column": 73
            },
            "line": 462,
            "code": "      it('opens a directory other than the project root with --new-window', async function () {\n        await scenario.open(parseCommandLine(['--new-window', 'b']));\n        await scenario.assert('[_ _] [a _] [b _]');\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "kills the specified pid after a newly-opened window is closed",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "--wait"
            ],
            "updatePoint": {
                "line": 468,
                "column": 71
            },
            "line": 468,
            "code": "      it('kills the specified pid after a newly-opened window is closed', async function () {\n        const [w0] = await scenario.launch(parseCommandLine(['--new-window', '--wait', '--pid', '101']));\n        const w1 = await scenario.open(parseCommandLine(['--new-window', '--wait', '--pid', '202']));\n        assert.lengthOf(scenario.killedPids, 0);\n        w0.browserWindow.emit('closed');\n        assert.deepEqual(scenario.killedPids, [101]);\n        w1.browserWindow.emit('closed');\n        assert.deepEqual(scenario.killedPids, [101, 202]);\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "kills the specified pid after all newly-opened files in an existing window are closed",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "--wait"
            ],
            "updatePoint": {
                "line": 477,
                "column": 95
            },
            "line": 477,
            "code": "      it('kills the specified pid after all newly-opened files in an existing window are closed', async function () {\n        const [w] = await scenario.launch(parseCommandLine(['--new-window', 'a']));\n        await scenario.open(parseCommandLine(['--add', '--wait', '--pid', '303', 'a/1.md', 'b/2.md']));\n        await scenario.assert('[a 1.md,2.md]');\n        assert.lengthOf(scenario.killedPids, 0);\n        scenario.getApplication(0).windowDidClosePathWithWaitSession(w, scenario.convertEditorPath('b/2.md'));\n        assert.lengthOf(scenario.killedPids, 0);\n        scenario.getApplication(0).windowDidClosePathWithWaitSession(w, scenario.convertEditorPath('a/1.md'));\n        assert.deepEqual(scenario.killedPids, [303]);\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "kills the specified pid after a newly-opened directory in an existing window is closed",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "--wait"
            ],
            "updatePoint": {
                "line": 487,
                "column": 96
            },
            "line": 487,
            "code": "      it('kills the specified pid after a newly-opened directory in an existing window is closed', async function () {\n        const [w] = await scenario.launch(parseCommandLine(['--new-window', 'a']));\n        await scenario.open(parseCommandLine(['--add', '--wait', '--pid', '404', 'b']));\n        await scenario.assert('[a,b _]');\n        assert.lengthOf(scenario.killedPids, 0);\n        scenario.getApplication(0).windowDidClosePathWithWaitSession(w, scenario.convertRootPath('b'));\n        assert.deepEqual(scenario.killedPids, [404]);\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads the package's urlMain in a new window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "atom:// URLs",
                "with a package-name host"
            ],
            "updatePoint": {
                "line": 498,
                "column": 55
            },
            "line": 498,
            "code": "        it(\"loads the package's urlMain in a new window\", async function () {\n          await scenario.launch({});\n          const app = scenario.getApplication(0);\n          app.packages = {\n            getAvailablePackageMetadata: () => [{\n              name: 'package-with-url-main',\n              urlMain: 'some/url-main'\n            }],\n            resolvePackagePath: () => path.resolve('dot-atom/package-with-url-main')\n          };\n          const [w1, w2] = await scenario.open(parseCommandLine(['atom://package-with-url-main/test1', 'atom://package-with-url-main/test2']));\n          assert.strictEqual(w1.loadSettings.windowInitializationScript, path.resolve('dot-atom/package-with-url-main/some/url-main'));\n          assert.strictEqual(w1.loadSettings.urlToOpen, 'atom://package-with-url-main/test1');\n          assert.strictEqual(w2.loadSettings.windowInitializationScript, path.resolve('dot-atom/package-with-url-main/some/url-main'));\n          assert.strictEqual(w2.loadSettings.urlToOpen, 'atom://package-with-url-main/test2');\n        });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sends a URI message to the most recently focused non-spec window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "atom:// URLs",
                "with a package-name host"
            ],
            "updatePoint": {
                "line": 514,
                "column": 76
            },
            "line": 514,
            "code": "        it('sends a URI message to the most recently focused non-spec window', async function () {\n          const [w0] = await scenario.launch({});\n          const w1 = await scenario.open(parseCommandLine(['--new-window']));\n          const w2 = await scenario.open(parseCommandLine(['--new-window']));\n          const w3 = await scenario.open(parseCommandLine(['--test', 'a/1.md']));\n          const app = scenario.getApplication(0);\n          app.packages = {\n            getAvailablePackageMetadata: () => []\n          };\n          const [uw] = await scenario.open(parseCommandLine(['atom://package-without-url-main/test']));\n          assert.strictEqual(uw, w2);\n          assert.isTrue(w2.sendURIMessage.calledWith('atom://package-without-url-main/test'));\n          assert.strictEqual(w2.focus.callCount, 2);\n\n          for (const other of [w0, w1, w3]) {\n            assert.isFalse(other.sendURIMessage.called);\n          }\n        });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new window and sends a URI message to it once it loads",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "atom:// URLs",
                "with a package-name host"
            ],
            "updatePoint": {
                "line": 532,
                "column": 76
            },
            "line": 532,
            "code": "        it('creates a new window and sends a URI message to it once it loads', async function () {\n          const [w0] = await scenario.launch(parseCommandLine(['--test', 'a/1.md']));\n          const app = scenario.getApplication(0);\n          app.packages = {\n            getAvailablePackageMetadata: () => []\n          };\n          const [uw] = await scenario.open(parseCommandLine(['atom://package-without-url-main/test']));\n          assert.notStrictEqual(uw, w0);\n          assert.strictEqual(uw.loadSettings.windowInitializationScript, path.resolve(__dirname, '../../src/initialize-application-window.js'));\n          uw.emit('window:loaded');\n          assert.isTrue(uw.sendURIMessage.calledWith('atom://package-without-url-main/test'));\n        });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sends a URI message to the most recently focused non-spec window that owns the open locations",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "atom:// URLs",
                "with a \"core\" host"
            ],
            "updatePoint": {
                "line": 546,
                "column": 105
            },
            "line": 546,
            "code": "        it('sends a URI message to the most recently focused non-spec window that owns the open locations', async function () {\n          const [w0] = await scenario.launch(parseCommandLine(['a']));\n          const w1 = await scenario.open(parseCommandLine(['--new-window', 'a']));\n          const w2 = await scenario.open(parseCommandLine(['--new-window', 'b']));\n          const uri = `atom://core/open/file?filename=${encodeURIComponent(scenario.convertEditorPath('a/1.md'))}`;\n          const [uw] = await scenario.open(parseCommandLine([uri]));\n          assert.strictEqual(uw, w1);\n          assert.isTrue(w1.sendURIMessage.calledWith(uri));\n\n          for (const other of [w0, w2]) {\n            assert.isFalse(other.sendURIMessage.called);\n          }\n        });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new window and sends a URI message to it once it loads",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "atom:// URLs",
                "with a \"core\" host"
            ],
            "updatePoint": {
                "line": 559,
                "column": 76
            },
            "line": 559,
            "code": "        it('creates a new window and sends a URI message to it once it loads', async function () {\n          const [w0] = await scenario.launch(parseCommandLine(['--test', 'a/1.md']));\n          const uri = `atom://core/open/file?filename=${encodeURIComponent(scenario.convertEditorPath('b/2.md'))}`;\n          const [uw] = await scenario.open(parseCommandLine([uri]));\n          assert.notStrictEqual(uw, w0);\n          uw.emit('window:loaded');\n          assert.isTrue(uw.sendURIMessage.calledWith(uri));\n        });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file to a specific line number",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "atom:// URLs",
                "with a \"core\" host"
            ],
            "updatePoint": {
                "line": 569,
                "column": 46
            },
            "line": 569,
            "code": "    it('opens a file to a specific line number', async function () {\n      await scenario.open(parseCommandLine(['a/1.md:10']));\n      await scenario.assert('[_ 1.md]');\n      const w = scenario.getWindow(0);\n      assert.lengthOf(w._locations, 1);\n      assert.strictEqual(w._locations[0].initialLine, 9);\n      assert.isNull(w._locations[0].initialColumn);\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a file to a specific line number and column",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "atom:// URLs",
                "with a \"core\" host"
            ],
            "updatePoint": {
                "line": 577,
                "column": 57
            },
            "line": 577,
            "code": "    it('opens a file to a specific line number and column', async function () {\n      await scenario.open(parseCommandLine(['b/2.md:12:5']));\n      await scenario.assert('[_ 2.md]');\n      const w = scenario.getWindow(0);\n      assert.lengthOf(w._locations, 1);\n      assert.strictEqual(w._locations[0].initialLine, 11);\n      assert.strictEqual(w._locations[0].initialColumn, 4);\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a directory with a non-file protocol",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "atom:// URLs",
                "with a \"core\" host"
            ],
            "updatePoint": {
                "line": 585,
                "column": 50
            },
            "line": 585,
            "code": "    it('opens a directory with a non-file protocol', async function () {\n      await scenario.open(parseCommandLine(['remote://server:3437/some/directory/path']));\n      const w = scenario.getWindow(0);\n      assert.lengthOf(w._locations, 1);\n      assert.strictEqual(w._locations[0].pathToOpen, 'remote://server:3437/some/directory/path');\n      assert.isFalse(w._locations[0].exists);\n      assert.isFalse(w._locations[0].isDirectory);\n      assert.isFalse(w._locations[0].isFile);\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "truncates trailing whitespace and colons",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "atom:// URLs",
                "with a \"core\" host"
            ],
            "updatePoint": {
                "line": 594,
                "column": 48
            },
            "line": 594,
            "code": "    it('truncates trailing whitespace and colons', async function () {\n      await scenario.open(parseCommandLine(['b/2.md::  ']));\n      await scenario.assert('[_ 2.md]');\n      const w = scenario.getWindow(0);\n      assert.lengthOf(w._locations, 1);\n      assert.isNull(w._locations[0].initialLine);\n      assert.isNull(w._locations[0].initialColumn);\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "disregards test and benchmark windows",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "atom:// URLs",
                "with a \"core\" host"
            ],
            "updatePoint": {
                "line": 602,
                "column": 45
            },
            "line": 602,
            "code": "    it('disregards test and benchmark windows', async function () {\n      await scenario.launch(parseCommandLine(['--test', 'b']));\n      await scenario.open(parseCommandLine(['--new-window']));\n      await scenario.open(parseCommandLine(['--test', 'c']));\n      await scenario.open(parseCommandLine(['--benchmark', 'b']));\n      await scenario.open(parseCommandLine(['a/1.md'])); // Test and benchmark StubWindows are visible as empty editor windows here\n\n      await scenario.assert('[_ _] [_ 1.md] [_ _] [_ _]');\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "positions new windows at an offset from the previous window",
            "suites": [
                "AtomApplication",
                "command-line interface behavior",
                "atom:// URLs",
                "with a \"core\" host"
            ],
            "updatePoint": {
                "line": 614,
                "column": 67
            },
            "line": 614,
            "code": "    it('positions new windows at an offset from the previous window', async function () {\n      const [w0] = await scenario.launch(parseCommandLine(['a']));\n      w0.setSize(400, 400);\n      const d0 = w0.getDimensions();\n      const w1 = await scenario.open(parseCommandLine(['b']));\n      const d1 = w1.getDimensions();\n      assert.isAbove(d1.x, d0.x);\n      assert.isAbove(d1.y, d0.y);\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a new file",
            "suites": [
                "AtomApplication",
                "with no windows open"
            ],
            "updatePoint": {
                "line": 640,
                "column": 26
            },
            "line": 640,
            "code": "      it('opens a new file', function () {\n        app.emit('application:open-file');\n        assert.isTrue(app.promptForPathToOpen.calledWith('file', {\n          devMode: false,\n          safeMode: false,\n          window: null\n        }));\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a new directory",
            "suites": [
                "AtomApplication",
                "with no windows open"
            ],
            "updatePoint": {
                "line": 648,
                "column": 31
            },
            "line": 648,
            "code": "      it('opens a new directory', function () {\n        app.emit('application:open-folder');\n        assert.isTrue(app.promptForPathToOpen.calledWith('folder', {\n          devMode: false,\n          safeMode: false,\n          window: null\n        }));\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a new file or directory",
            "suites": [
                "AtomApplication",
                "with no windows open"
            ],
            "updatePoint": {
                "line": 656,
                "column": 39
            },
            "line": 656,
            "code": "      it('opens a new file or directory', function () {\n        app.emit('application:open');\n        assert.isTrue(app.promptForPathToOpen.calledWith('all', {\n          devMode: false,\n          safeMode: false,\n          window: null\n        }));\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reopens a project in a new window",
            "suites": [
                "AtomApplication",
                "with no windows open"
            ],
            "updatePoint": {
                "line": 664,
                "column": 43
            },
            "line": 664,
            "code": "      it('reopens a project in a new window', async function () {\n        const paths = scenario.convertPaths(['a', 'b']);\n        app.emit('application:reopen-project', {\n          paths\n        });\n        await conditionPromise(() => app.getAllWindows().length > 0);\n        assert.deepEqual(app.getAllWindows().map(w => Array.from(w._rootPaths)), [paths]);\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new application when no socket is present",
            "suites": [
                "AtomApplication",
                "existing application re-use"
            ],
            "updatePoint": {
                "line": 687,
                "column": 59
            },
            "line": 687,
            "code": "    it('creates a new application when no socket is present', async function () {\n      const app0 = await AtomApplication.open({\n        createApplication,\n        version\n      });\n      await app0.deleteSocketSecretFile();\n      const app1 = await AtomApplication.open({\n        createApplication,\n        version\n      });\n      assert.isNotNull(app1);\n      assert.notStrictEqual(app0, app1);\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new application for spec windows",
            "suites": [
                "AtomApplication",
                "existing application re-use"
            ],
            "updatePoint": {
                "line": 700,
                "column": 50
            },
            "line": 700,
            "code": "    it('creates a new application for spec windows', async function () {\n      const app0 = await AtomApplication.open({\n        createApplication,\n        version\n      });\n      const app1 = await AtomApplication.open({\n        createApplication,\n        version,\n        ...parseCommandLine(['--test', 'a'])\n      });\n      assert.isNotNull(app1);\n      assert.notStrictEqual(app0, app1);\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sends a request to an existing application when a socket is present",
            "suites": [
                "AtomApplication",
                "existing application re-use"
            ],
            "updatePoint": {
                "line": 713,
                "column": 75
            },
            "line": 713,
            "code": "    it('sends a request to an existing application when a socket is present', async function () {\n      const app0 = await AtomApplication.open({\n        createApplication,\n        version\n      });\n      assert.lengthOf(app0.getAllWindows(), 1);\n      const app1 = await AtomApplication.open({\n        createApplication,\n        version,\n        ...parseCommandLine(['--new-window'])\n      });\n      assert.isNull(app1);\n      assert.isTrue(electron.app.quit.called);\n      await conditionPromise(() => app0.getAllWindows().length === 2);\n      await scenario.assert('[_ _] [_ _]');\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "\"open\" opens a fixed path by the standard opening rules",
            "suites": [
                "AtomApplication",
                "IPC handling"
            ],
            "updatePoint": {
                "line": 746,
                "column": 63
            },
            "line": 746,
            "code": "    it('\"open\" opens a fixed path by the standard opening rules', async function () {\n      sinon.stub(app, 'atomWindowForEvent').callsFake(() => w1);\n      electron.ipcMain.emit('open', {}, {\n        pathsToOpen: [scenario.convertEditorPath('a/1.md')]\n      });\n      await app.openPaths.lastCall.returnValue;\n      await scenario.assert('[a 1.md] [_ _] [b _]');\n      electron.ipcMain.emit('open', {}, {\n        pathsToOpen: [scenario.convertRootPath('c')]\n      });\n      await app.openPaths.lastCall.returnValue;\n      await scenario.assert('[a 1.md] [c _] [b _]');\n      electron.ipcMain.emit('open', {}, {\n        pathsToOpen: [scenario.convertRootPath('d')],\n        here: true\n      });\n      await app.openPaths.lastCall.returnValue;\n      await scenario.assert('[a 1.md] [c,d _] [b _]');\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "\"open\" without any option open the prompt for selecting a path",
            "suites": [
                "AtomApplication",
                "IPC handling"
            ],
            "updatePoint": {
                "line": 765,
                "column": 70
            },
            "line": 765,
            "code": "    it('\"open\" without any option open the prompt for selecting a path', async function () {\n      sinon.stub(app, 'atomWindowForEvent').callsFake(() => w1);\n      electron.ipcMain.emit('open', {});\n      assert.strictEqual(app.promptForPath.lastCall.args[0], 'all');\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "\"open-chosen-any\" opens a file in the sending window",
            "suites": [
                "AtomApplication",
                "IPC handling"
            ],
            "updatePoint": {
                "line": 770,
                "column": 60
            },
            "line": 770,
            "code": "    it('\"open-chosen-any\" opens a file in the sending window', async function () {\n      sinon.stub(app, 'atomWindowForEvent').callsFake(() => w2);\n      electron.ipcMain.emit('open-chosen-any', {}, scenario.convertEditorPath('a/1.md'));\n      await conditionPromise(() => app.openPaths.called);\n      await app.openPaths.lastCall.returnValue;\n      await scenario.assert('[a _] [_ _] [b 1.md]');\n      assert.isTrue(app.promptForPath.called);\n      assert.strictEqual(app.promptForPath.lastCall.args[0], 'all');\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "\"open-chosen-any\" opens a directory by the standard opening rules",
            "suites": [
                "AtomApplication",
                "IPC handling"
            ],
            "updatePoint": {
                "line": 779,
                "column": 73
            },
            "line": 779,
            "code": "    it('\"open-chosen-any\" opens a directory by the standard opening rules', async function () {\n      sinon.stub(app, 'atomWindowForEvent').callsFake(() => w1); // Open unrecognized directory in empty window\n\n      electron.ipcMain.emit('open-chosen-any', {}, scenario.convertRootPath('c'));\n      await conditionPromise(() => app.openPaths.callCount > 0);\n      await app.openPaths.lastCall.returnValue;\n      await scenario.assert('[a _] [c _] [b _]');\n      assert.strictEqual(app.promptForPath.callCount, 1);\n      assert.strictEqual(app.promptForPath.lastCall.args[0], 'all'); // Open unrecognized directory in new window\n\n      electron.ipcMain.emit('open-chosen-any', {}, scenario.convertRootPath('d'));\n      await conditionPromise(() => app.openPaths.callCount > 1);\n      await app.openPaths.lastCall.returnValue;\n      await scenario.assert('[a _] [c _] [b _] [d _]');\n      assert.strictEqual(app.promptForPath.callCount, 2);\n      assert.strictEqual(app.promptForPath.lastCall.args[0], 'all'); // Open recognized directory in existing window\n\n      electron.ipcMain.emit('open-chosen-any', {}, scenario.convertRootPath('a'));\n      await conditionPromise(() => app.openPaths.callCount > 2);\n      await app.openPaths.lastCall.returnValue;\n      await scenario.assert('[a _] [c _] [b _] [d _]');\n      assert.strictEqual(app.promptForPath.callCount, 3);\n      assert.strictEqual(app.promptForPath.lastCall.args[0], 'all');\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "\"open-chosen-file\" opens a file chooser and opens the chosen file in the sending window",
            "suites": [
                "AtomApplication",
                "IPC handling"
            ],
            "updatePoint": {
                "line": 803,
                "column": 95
            },
            "line": 803,
            "code": "    it('\"open-chosen-file\" opens a file chooser and opens the chosen file in the sending window', async function () {\n      sinon.stub(app, 'atomWindowForEvent').callsFake(() => w0);\n      electron.ipcMain.emit('open-chosen-file', {}, scenario.convertEditorPath('b/2.md'));\n      await app.openPaths.lastCall.returnValue;\n      await scenario.assert('[a 2.md] [_ _] [b _]');\n      assert.isTrue(app.promptForPath.called);\n      assert.strictEqual(app.promptForPath.lastCall.args[0], 'file');\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "\"open-chosen-folder\" opens a directory chooser and opens the chosen directory",
            "suites": [
                "AtomApplication",
                "IPC handling"
            ],
            "updatePoint": {
                "line": 811,
                "column": 85
            },
            "line": 811,
            "code": "    it('\"open-chosen-folder\" opens a directory chooser and opens the chosen directory', async function () {\n      sinon.stub(app, 'atomWindowForEvent').callsFake(() => w0);\n      electron.ipcMain.emit('open-chosen-folder', {}, scenario.convertRootPath('c'));\n      await app.openPaths.lastCall.returnValue;\n      await scenario.assert('[a _] [c _] [b _]');\n      assert.isTrue(app.promptForPath.called);\n      assert.strictEqual(app.promptForPath.lastCall.args[0], 'folder');\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "occurs immediately when adding a window",
            "suites": [
                "AtomApplication",
                "window state serialization"
            ],
            "updatePoint": {
                "line": 821,
                "column": 47
            },
            "line": 821,
            "code": "    it('occurs immediately when adding a window', async function () {\n      await scenario.launch(parseCommandLine(['a']));\n      const promise = emitterEventPromise(scenario.getApplication(0), 'application:did-save-state');\n      await scenario.open(parseCommandLine(['c', 'b']));\n      await promise;\n      assert.isTrue(scenario.getApplication(0).storageFolder.store.calledWith('application.json', {\n        version: '1',\n        windows: [{\n          projectRoots: [scenario.convertRootPath('a')]\n        }, {\n          projectRoots: [scenario.convertRootPath('b'), scenario.convertRootPath('c')]\n        }]\n      }));\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "occurs immediately when removing a window",
            "suites": [
                "AtomApplication",
                "window state serialization"
            ],
            "updatePoint": {
                "line": 835,
                "column": 49
            },
            "line": 835,
            "code": "    it('occurs immediately when removing a window', async function () {\n      await scenario.launch(parseCommandLine(['a']));\n      const w = await scenario.open(parseCommandLine(['b']));\n      const promise = emitterEventPromise(scenario.getApplication(0), 'application:did-save-state');\n      scenario.getApplication(0).removeWindow(w);\n      await promise;\n      assert.isTrue(scenario.getApplication(0).storageFolder.store.calledWith('application.json', {\n        version: '1',\n        windows: [{\n          projectRoots: [scenario.convertRootPath('a')]\n        }]\n      }));\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "occurs when the window is blurred",
            "suites": [
                "AtomApplication",
                "window state serialization"
            ],
            "updatePoint": {
                "line": 848,
                "column": 41
            },
            "line": 848,
            "code": "    it('occurs when the window is blurred', async function () {\n      const [w] = await scenario.launch(parseCommandLine(['a']));\n      const promise = emitterEventPromise(scenario.getApplication(0), 'application:did-save-state');\n      w.browserWindow.emit('blur');\n      await promise;\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "quits the application",
            "suites": [
                "AtomApplication",
                "when closing the last window"
            ],
            "updatePoint": {
                "line": 857,
                "column": 31
            },
            "line": 857,
            "code": "      it('quits the application', async function () {\n        const [w] = await scenario.launch(parseCommandLine(['a']));\n        scenario.getApplication(0).removeWindow(w);\n        assert.isTrue(electron.app.quit.called);\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "leaves the application open",
            "suites": [
                "AtomApplication",
                "when closing the last window"
            ],
            "updatePoint": {
                "line": 863,
                "column": 37
            },
            "line": 863,
            "code": "      it('leaves the application open', async function () {\n        const [w] = await scenario.launch(parseCommandLine(['a']));\n        scenario.getApplication(0).removeWindow(w);\n        assert.isFalse(electron.app.quit.called);\n      });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "waits until all windows have saved their state before quitting",
            "suites": [
                "AtomApplication",
                "quitting"
            ],
            "updatePoint": {
                "line": 871,
                "column": 70
            },
            "line": 871,
            "code": "    it('waits until all windows have saved their state before quitting', async function () {\n      const [w0] = await scenario.launch(parseCommandLine(['a']));\n      const w1 = await scenario.open(parseCommandLine(['b']));\n      assert.notStrictEqual(w0, w1);\n      sinon.spy(w0, 'close');\n      let resolveUnload0;\n\n      w0.prepareToUnload = () => new Promise(resolve => {\n        resolveUnload0 = resolve;\n      });\n\n      sinon.spy(w1, 'close');\n      let resolveUnload1;\n\n      w1.prepareToUnload = () => new Promise(resolve => {\n        resolveUnload1 = resolve;\n      });\n\n      const evt = {\n        preventDefault: sinon.spy()\n      };\n      electron.app.emit('before-quit', evt);\n      await new Promise(process.nextTick);\n      assert.isTrue(evt.preventDefault.called);\n      assert.isFalse(electron.app.quit.called);\n      resolveUnload1(true);\n      await new Promise(process.nextTick);\n      assert.isFalse(electron.app.quit.called);\n      resolveUnload0(true);\n      await scenario.getApplication(0).lastBeforeQuitPromise;\n      assert.isTrue(electron.app.quit.called);\n      assert.isTrue(w0.close.called);\n      assert.isTrue(w1.close.called);\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prevents a quit if a user cancels when prompted to save",
            "suites": [
                "AtomApplication",
                "quitting"
            ],
            "updatePoint": {
                "line": 905,
                "column": 63
            },
            "line": 905,
            "code": "    it('prevents a quit if a user cancels when prompted to save', async function () {\n      const [w] = await scenario.launch(parseCommandLine(['a']));\n      let resolveUnload;\n\n      w.prepareToUnload = () => new Promise(resolve => {\n        resolveUnload = resolve;\n      });\n\n      const evt = {\n        preventDefault: sinon.spy()\n      };\n      electron.app.emit('before-quit', evt);\n      await new Promise(process.nextTick);\n      assert.isTrue(evt.preventDefault.called);\n      resolveUnload(false);\n      await scenario.getApplication(0).lastBeforeQuitPromise;\n      assert.isFalse(electron.app.quit.called);\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "closes successfully unloaded windows",
            "suites": [
                "AtomApplication",
                "quitting"
            ],
            "updatePoint": {
                "line": 923,
                "column": 44
            },
            "line": 923,
            "code": "    it('closes successfully unloaded windows', async function () {\n      const [w0] = await scenario.launch(parseCommandLine(['a']));\n      const w1 = await scenario.open(parseCommandLine(['b']));\n      sinon.spy(w0, 'close');\n      let resolveUnload0;\n\n      w0.prepareToUnload = () => new Promise(resolve => {\n        resolveUnload0 = resolve;\n      });\n\n      sinon.spy(w1, 'close');\n      let resolveUnload1;\n\n      w1.prepareToUnload = () => new Promise(resolve => {\n        resolveUnload1 = resolve;\n      });\n\n      const evt = {\n        preventDefault() {}\n\n      };\n      electron.app.emit('before-quit', evt);\n      resolveUnload0(false);\n      resolveUnload1(true);\n      await scenario.getApplication(0).lastBeforeQuitPromise;\n      assert.isFalse(electron.app.quit.called);\n      assert.isFalse(w0.close.called);\n      assert.isTrue(w1.close.called);\n    });",
            "file": "main-process/atom-application.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a real, properly configured BrowserWindow",
            "suites": [
                "AtomWindow",
                "creating a real window"
            ],
            "updatePoint": {
                "line": 80,
                "column": 57
            },
            "line": 80,
            "code": "    it('creates a real, properly configured BrowserWindow', async function () {\n      const w = new AtomWindow(app, service, {\n        resourcePath,\n        windowInitializationScript,\n        headless: true,\n        extra: 'extra-load-setting'\n      });\n      const {\n        browserWindow\n      } = w;\n      assert.isFalse(browserWindow.isVisible());\n      assert.isTrue(browserWindow.getTitle().startsWith('Atom'));\n      const settings = JSON.parse(browserWindow.loadSettingsJSON);\n      assert.strictEqual(settings.userSettings, 'stub-config');\n      assert.strictEqual(settings.extra, 'extra-load-setting');\n      assert.strictEqual(settings.resourcePath, resourcePath);\n      assert.strictEqual(settings.atomHome, atomHome);\n      assert.isFalse(settings.devMode);\n      assert.isFalse(settings.safeMode);\n      assert.isFalse(settings.clearWindowState);\n      await emitterEventPromise(browserWindow, 'ready-to-show');\n      assert.strictEqual(browserWindow.webContents.getURL(), url.format({\n        protocol: 'file',\n        pathname: `${resourcePath.replace(/\\\\/g, '/')}/static/index.html`,\n        slashes: true\n      }));\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets titleBarStyle to \"hidden\" for a custom title bar on non-spec windows",
            "suites": [
                "AtomWindow",
                "launch behavior"
            ],
            "updatePoint": {
                "line": 110,
                "column": 83
            },
            "line": 110,
            "code": "      it('sets titleBarStyle to \"hidden\" for a custom title bar on non-spec windows', function () {\n        app.config['core.titleBar'] = 'custom';\n        const {\n          browserWindow: w0\n        } = new AtomWindow(app, service, {\n          browserWindowConstructor: StubBrowserWindow\n        });\n        assert.strictEqual(w0.options.titleBarStyle, 'hidden');\n        const {\n          browserWindow: w1\n        } = new AtomWindow(app, service, {\n          browserWindowConstructor: StubBrowserWindow,\n          isSpec: true\n        });\n        assert.isUndefined(w1.options.titleBarStyle);\n      });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets titleBarStyle to \"hiddenInset\" for a custom inset title bar on non-spec windows",
            "suites": [
                "AtomWindow",
                "launch behavior"
            ],
            "updatePoint": {
                "line": 126,
                "column": 94
            },
            "line": 126,
            "code": "      it('sets titleBarStyle to \"hiddenInset\" for a custom inset title bar on non-spec windows', function () {\n        app.config['core.titleBar'] = 'custom-inset';\n        const {\n          browserWindow: w0\n        } = new AtomWindow(app, service, {\n          browserWindowConstructor: StubBrowserWindow\n        });\n        assert.strictEqual(w0.options.titleBarStyle, 'hiddenInset');\n        const {\n          browserWindow: w1\n        } = new AtomWindow(app, service, {\n          browserWindowConstructor: StubBrowserWindow,\n          isSpec: true\n        });\n        assert.isUndefined(w1.options.titleBarStyle);\n      });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets frame to \"false\" for a hidden title bar on non-spec windows",
            "suites": [
                "AtomWindow",
                "launch behavior"
            ],
            "updatePoint": {
                "line": 142,
                "column": 74
            },
            "line": 142,
            "code": "      it('sets frame to \"false\" for a hidden title bar on non-spec windows', function () {\n        app.config['core.titleBar'] = 'hidden';\n        const {\n          browserWindow: w0\n        } = new AtomWindow(app, service, {\n          browserWindowConstructor: StubBrowserWindow\n        });\n        assert.isFalse(w0.options.frame);\n        const {\n          browserWindow: w1\n        } = new AtomWindow(app, service, {\n          browserWindowConstructor: StubBrowserWindow,\n          isSpec: true\n        });\n        assert.isUndefined(w1.options.frame);\n      });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets frame to \"false\" for a hidden title bar on non-spec windows",
            "suites": [
                "AtomWindow",
                "launch behavior"
            ],
            "updatePoint": {
                "line": 159,
                "column": 74
            },
            "line": 159,
            "code": "      it('sets frame to \"false\" for a hidden title bar on non-spec windows', function () {\n        app.config['core.titleBar'] = 'hidden';\n        const {\n          browserWindow: w0\n        } = new AtomWindow(app, service, {\n          browserWindowConstructor: StubBrowserWindow\n        });\n        assert.isFalse(w0.options.frame);\n        const {\n          browserWindow: w1\n        } = new AtomWindow(app, service, {\n          browserWindowConstructor: StubBrowserWindow,\n          isSpec: true\n        });\n        assert.isUndefined(w1.options.frame);\n      });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens initial locations",
            "suites": [
                "AtomWindow",
                "launch behavior"
            ],
            "updatePoint": {
                "line": 177,
                "column": 31
            },
            "line": 177,
            "code": "    it('opens initial locations', async function () {\n      const locationsToOpen = [{\n        pathToOpen: 'file.txt',\n        initialLine: 1,\n        initialColumn: 2,\n        isDirectory: false,\n        hasWaitSession: false\n      }, {\n        pathToOpen: '/directory',\n        initialLine: null,\n        initialColumn: null,\n        isDirectory: true,\n        hasWaitSession: false\n      }];\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        locationsToOpen\n      });\n      assert.deepEqual(w.projectRoots, ['/directory']);\n      const loadPromise = emitterEventPromise(w, 'window:loaded');\n      w.browserWindow.emit('window:loaded');\n      await loadPromise;\n      assert.deepEqual(w.browserWindow.sent, [['message', 'open-locations', locationsToOpen]]);\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not open an initial null location",
            "suites": [
                "AtomWindow",
                "launch behavior"
            ],
            "updatePoint": {
                "line": 201,
                "column": 46
            },
            "line": 201,
            "code": "    it('does not open an initial null location', async function () {\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        locationsToOpen: [{\n          pathToOpen: null\n        }]\n      });\n      const loadPromise = emitterEventPromise(w, 'window:loaded');\n      w.browserWindow.emit('window:loaded');\n      await loadPromise;\n      assert.lengthOf(w.browserWindow.sent, 0);\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not open initial locations in spec mode",
            "suites": [
                "AtomWindow",
                "launch behavior"
            ],
            "updatePoint": {
                "line": 213,
                "column": 52
            },
            "line": 213,
            "code": "    it('does not open initial locations in spec mode', async function () {\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        locationsToOpen: [{\n          pathToOpen: 'file.txt'\n        }],\n        isSpec: true\n      });\n      const loadPromise = emitterEventPromise(w, 'window:loaded');\n      w.browserWindow.emit('window:loaded');\n      await loadPromise;\n      assert.lengthOf(w.browserWindow.sent, 0);\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses the webView for specs",
            "suites": [
                "AtomWindow",
                "launch behavior"
            ],
            "updatePoint": {
                "line": 226,
                "column": 37
            },
            "line": 226,
            "code": "    it('focuses the webView for specs', function () {\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        isSpec: true\n      });\n      assert.isTrue(w.browserWindow.behavior.focusOnWebView);\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "knows when it has no roots",
            "suites": [
                "AtomWindow",
                "project root tracking"
            ],
            "updatePoint": {
                "line": 235,
                "column": 34
            },
            "line": 235,
            "code": "    it('knows when it has no roots', function () {\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow\n      });\n      assert.isFalse(w.hasProjectPaths());\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is initialized from directories in the initial locationsToOpen",
            "suites": [
                "AtomWindow",
                "project root tracking"
            ],
            "updatePoint": {
                "line": 241,
                "column": 70
            },
            "line": 241,
            "code": "    it('is initialized from directories in the initial locationsToOpen', function () {\n      const locationsToOpen = [{\n        pathToOpen: 'file.txt',\n        exists: true,\n        isFile: true\n      }, {\n        pathToOpen: 'directory0',\n        exists: true,\n        isDirectory: true\n      }, {\n        pathToOpen: 'directory1',\n        exists: true,\n        isDirectory: true\n      }, {\n        pathToOpen: 'new-file.txt'\n      }, {\n        pathToOpen: null\n      }];\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        locationsToOpen\n      });\n      assert.deepEqual(w.projectRoots, ['directory0', 'directory1']);\n      assert.isTrue(w.loadSettings.hasOpenFiles);\n      assert.deepEqual(w.loadSettings.initialProjectRoots, ['directory0', 'directory1']);\n      assert.isTrue(w.hasProjectPaths());\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is updated synchronously by openLocations",
            "suites": [
                "AtomWindow",
                "project root tracking"
            ],
            "updatePoint": {
                "line": 268,
                "column": 49
            },
            "line": 268,
            "code": "    it('is updated synchronously by openLocations', async function () {\n      const locationsToOpen = [{\n        pathToOpen: 'file.txt',\n        isFile: true\n      }, {\n        pathToOpen: 'directory1',\n        isDirectory: true\n      }, {\n        pathToOpen: 'directory0',\n        isDirectory: true\n      }, {\n        pathToOpen: 'directory0',\n        isDirectory: true\n      }, {\n        pathToOpen: 'new-file.txt'\n      }];\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow\n      });\n      assert.deepEqual(w.projectRoots, []);\n      const promise = w.openLocations(locationsToOpen);\n      assert.deepEqual(w.projectRoots, ['directory0', 'directory1']);\n      w.resolveLoadedPromise();\n      await promise;\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is updated by setProjectRoots",
            "suites": [
                "AtomWindow",
                "project root tracking"
            ],
            "updatePoint": {
                "line": 293,
                "column": 37
            },
            "line": 293,
            "code": "    it('is updated by setProjectRoots', function () {\n      const locationsToOpen = [{\n        pathToOpen: 'directory0',\n        exists: true,\n        isDirectory: true\n      }];\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        locationsToOpen\n      });\n      assert.deepEqual(w.projectRoots, ['directory0']);\n      assert.deepEqual(w.loadSettings.initialProjectRoots, ['directory0']);\n      w.setProjectRoots(['directory1', 'directory0', 'directory2']);\n      assert.deepEqual(w.projectRoots, ['directory0', 'directory1', 'directory2']);\n      assert.deepEqual(w.loadSettings.initialProjectRoots, ['directory0', 'directory1', 'directory2']);\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "never reports that it owns the empty path",
            "suites": [
                "AtomWindow",
                "project root tracking"
            ],
            "updatePoint": {
                "line": 309,
                "column": 49
            },
            "line": 309,
            "code": "    it('never reports that it owns the empty path', function () {\n      const locationsToOpen = [{\n        pathToOpen: 'directory0',\n        exists: true,\n        isDirectory: true\n      }, {\n        pathToOpen: 'directory1',\n        exists: true,\n        isDirectory: true\n      }, {\n        pathToOpen: null\n      }];\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        locationsToOpen\n      });\n      assert.isFalse(w.containsLocation({\n        pathToOpen: null\n      }));\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "discovers an exact path match",
            "suites": [
                "AtomWindow",
                "project root tracking"
            ],
            "updatePoint": {
                "line": 329,
                "column": 37
            },
            "line": 329,
            "code": "    it('discovers an exact path match', function () {\n      const locationsToOpen = [{\n        pathToOpen: 'directory0',\n        exists: true,\n        isDirectory: true\n      }, {\n        pathToOpen: 'directory1',\n        exists: true,\n        isDirectory: true\n      }];\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        locationsToOpen\n      });\n      assert.isTrue(w.containsLocation({\n        pathToOpen: 'directory0'\n      }));\n      assert.isFalse(w.containsLocation({\n        pathToOpen: 'directory2'\n      }));\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "discovers the path of a file within any project root",
            "suites": [
                "AtomWindow",
                "project root tracking"
            ],
            "updatePoint": {
                "line": 350,
                "column": 60
            },
            "line": 350,
            "code": "    it('discovers the path of a file within any project root', function () {\n      const locationsToOpen = [{\n        pathToOpen: 'directory0',\n        exists: true,\n        isDirectory: true\n      }, {\n        pathToOpen: 'directory1',\n        exists: true,\n        isDirectory: true\n      }];\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        locationsToOpen\n      });\n      assert.isTrue(w.containsLocation({\n        pathToOpen: path.join('directory0/file-0.txt'),\n        exists: true,\n        isFile: true\n      }));\n      assert.isTrue(w.containsLocation({\n        pathToOpen: path.join('directory0/deep/file-0.txt'),\n        exists: true,\n        isFile: true\n      }));\n      assert.isFalse(w.containsLocation({\n        pathToOpen: path.join('directory2/file-9.txt'),\n        exists: true,\n        isFile: true\n      }));\n      assert.isFalse(w.containsLocation({\n        pathToOpen: path.join('directory2/deep/file-9.txt'),\n        exists: true,\n        isFile: true\n      }));\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reports that it owns nonexistent paths within a project root",
            "suites": [
                "AtomWindow",
                "project root tracking"
            ],
            "updatePoint": {
                "line": 385,
                "column": 68
            },
            "line": 385,
            "code": "    it('reports that it owns nonexistent paths within a project root', function () {\n      const locationsToOpen = [{\n        pathToOpen: 'directory0',\n        exists: true,\n        isDirectory: true\n      }, {\n        pathToOpen: 'directory1',\n        exists: true,\n        isDirectory: true\n      }];\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        locationsToOpen\n      });\n      assert.isTrue(w.containsLocation({\n        pathToOpen: path.join('directory0/file-1.txt'),\n        exists: false\n      }));\n      assert.isTrue(w.containsLocation({\n        pathToOpen: path.join('directory1/subdir/file-0.txt'),\n        exists: false\n      }));\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "never reports that it owns directories within a project root",
            "suites": [
                "AtomWindow",
                "project root tracking"
            ],
            "updatePoint": {
                "line": 408,
                "column": 68
            },
            "line": 408,
            "code": "    it('never reports that it owns directories within a project root', function () {\n      const locationsToOpen = [{\n        pathToOpen: 'directory0',\n        exists: true,\n        isDirectory: true\n      }, {\n        pathToOpen: 'directory1',\n        exists: true,\n        isDirectory: true\n      }];\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        locationsToOpen\n      });\n      assert.isFalse(w.containsLocation({\n        pathToOpen: path.join('directory0/subdir-0'),\n        exists: true,\n        isDirectory: true\n      }));\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "checks a full list of paths and reports if it owns all of them",
            "suites": [
                "AtomWindow",
                "project root tracking"
            ],
            "updatePoint": {
                "line": 428,
                "column": 70
            },
            "line": 428,
            "code": "    it('checks a full list of paths and reports if it owns all of them', function () {\n      const locationsToOpen = [{\n        pathToOpen: 'directory0',\n        exists: true,\n        isDirectory: true\n      }, {\n        pathToOpen: 'directory1',\n        exists: true,\n        isDirectory: true\n      }];\n      const w = new AtomWindow(app, service, {\n        browserWindowConstructor: StubBrowserWindow,\n        locationsToOpen\n      });\n      assert.isTrue(w.containsLocations([{\n        pathToOpen: 'directory0'\n      }, {\n        pathToOpen: path.join('directory1/file-0.txt'),\n        exists: true,\n        isFile: true\n      }]));\n      assert.isFalse(w.containsLocations([{\n        pathToOpen: 'directory2'\n      }, {\n        pathToOpen: 'directory0'\n      }]));\n      assert.isFalse(w.containsLocations([{\n        pathToOpen: 'directory2'\n      }, {\n        pathToOpen: 'directory1'\n      }]));\n    });",
            "file": "main-process/atom-window.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a recovery file and deletes it after saving",
            "suites": [
                "FileRecoveryService",
                "when no crash happens during a save"
            ],
            "updatePoint": {
                "line": 42,
                "column": 59
            },
            "line": 42,
            "code": "    it('creates a recovery file and deletes it after saving', async () => {\n      const mockWindow = {};\n      const filePath = temp.path();\n      fs.writeFileSync(filePath, 'some content');\n      await recoveryService.willSavePath(mockWindow, filePath);\n      assert.equal(fs.listTreeSync(recoveryDirectory).length, 1);\n      fs.writeFileSync(filePath, 'changed');\n      await recoveryService.didSavePath(mockWindow, filePath);\n      assert.equal(fs.listTreeSync(recoveryDirectory).length, 0);\n      assert.equal(fs.readFileSync(filePath, 'utf8'), 'changed');\n      fs.removeSync(filePath);\n    });",
            "file": "main-process/file-recovery-service.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates only one recovery file when many windows attempt to save the same file, deleting it when the last one finishes saving it",
            "suites": [
                "FileRecoveryService",
                "when no crash happens during a save"
            ],
            "updatePoint": {
                "line": 54,
                "column": 136
            },
            "line": 54,
            "code": "    it('creates only one recovery file when many windows attempt to save the same file, deleting it when the last one finishes saving it', async () => {\n      const mockWindow = {};\n      const anotherMockWindow = {};\n      const filePath = temp.path();\n      fs.writeFileSync(filePath, 'some content');\n      await recoveryService.willSavePath(mockWindow, filePath);\n      await recoveryService.willSavePath(anotherMockWindow, filePath);\n      assert.equal(fs.listTreeSync(recoveryDirectory).length, 1);\n      fs.writeFileSync(filePath, 'changed');\n      await recoveryService.didSavePath(mockWindow, filePath);\n      assert.equal(fs.listTreeSync(recoveryDirectory).length, 1);\n      assert.equal(fs.readFileSync(filePath, 'utf8'), 'changed');\n      await recoveryService.didSavePath(anotherMockWindow, filePath);\n      assert.equal(fs.listTreeSync(recoveryDirectory).length, 0);\n      assert.equal(fs.readFileSync(filePath, 'utf8'), 'changed');\n      fs.removeSync(filePath);\n    });",
            "file": "main-process/file-recovery-service.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the created recovery file and deletes it",
            "suites": [
                "FileRecoveryService",
                "when a crash happens during a save"
            ],
            "updatePoint": {
                "line": 73,
                "column": 57
            },
            "line": 73,
            "code": "    it('restores the created recovery file and deletes it', async () => {\n      const mockWindow = {};\n      const filePath = temp.path();\n      fs.writeFileSync(filePath, 'some content');\n      await recoveryService.willSavePath(mockWindow, filePath);\n      assert.equal(fs.listTreeSync(recoveryDirectory).length, 1);\n      fs.writeFileSync(filePath, 'changed');\n      await recoveryService.didCrashWindow(mockWindow);\n      assert.equal(fs.listTreeSync(recoveryDirectory).length, 0);\n      assert.equal(fs.readFileSync(filePath, 'utf8'), 'some content');\n      fs.removeSync(filePath);\n    });",
            "file": "main-process/file-recovery-service.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the created recovery file when many windows attempt to save the same file and one of them crashes",
            "suites": [
                "FileRecoveryService",
                "when a crash happens during a save"
            ],
            "updatePoint": {
                "line": 85,
                "column": 114
            },
            "line": 85,
            "code": "    it('restores the created recovery file when many windows attempt to save the same file and one of them crashes', async () => {\n      const mockWindow = {};\n      const anotherMockWindow = {};\n      const filePath = temp.path();\n      fs.writeFileSync(filePath, 'A');\n      await recoveryService.willSavePath(mockWindow, filePath);\n      fs.writeFileSync(filePath, 'B');\n      await recoveryService.willSavePath(anotherMockWindow, filePath);\n      assert.equal(fs.listTreeSync(recoveryDirectory).length, 1);\n      fs.writeFileSync(filePath, 'C');\n      await recoveryService.didCrashWindow(mockWindow);\n      assert.equal(fs.readFileSync(filePath, 'utf8'), 'A');\n      assert.equal(fs.listTreeSync(recoveryDirectory).length, 0);\n      fs.writeFileSync(filePath, 'D');\n      await recoveryService.willSavePath(mockWindow, filePath);\n      fs.writeFileSync(filePath, 'E');\n      await recoveryService.willSavePath(anotherMockWindow, filePath);\n      assert.equal(fs.listTreeSync(recoveryDirectory).length, 1);\n      fs.writeFileSync(filePath, 'F');\n      await recoveryService.didCrashWindow(anotherMockWindow);\n      assert.equal(fs.readFileSync(filePath, 'utf8'), 'D');\n      assert.equal(fs.listTreeSync(recoveryDirectory).length, 0);\n      fs.removeSync(filePath);\n    });",
            "file": "main-process/file-recovery-service.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a warning when a file can't be recovered",
            "suites": [
                "FileRecoveryService",
                "when a crash happens during a save"
            ],
            "updatePoint": {
                "line": 109,
                "column": 54
            },
            "line": 109,
            "code": "    it(\"emits a warning when a file can't be recovered\", async () => {\n      const mockWindow = {};\n      const filePath = temp.path();\n      fs.writeFileSync(filePath, 'content');\n      let logs = [];\n      spies.stub(console, 'log').callsFake(message => logs.push(message));\n      spies.stub(dialog, 'showMessageBox'); // Copy files to be recovered before mocking fs.createWriteStream\n\n      await recoveryService.willSavePath(mockWindow, filePath); // Stub out fs.createWriteStream so that we can return a fake error when\n      // attempting to copy the recovered file to its original location\n\n      var fakeEmitter = new EventEmitter();\n      var onStub = spies.stub(fakeEmitter, 'on');\n      onStub.withArgs('error').yields(new Error('Nope')).returns(fakeEmitter);\n      onStub.withArgs('open').returns(fakeEmitter);\n      spies.stub(fsreal, 'createWriteStream').withArgs(filePath).returns(fakeEmitter);\n      await recoveryService.didCrashWindow(mockWindow);\n      let recoveryFiles = fs.listTreeSync(recoveryDirectory);\n      assert.equal(recoveryFiles.length, 1);\n      assert.equal(logs.length, 1);\n      assert.match(logs[0], new RegExp(escapeRegExp(filePath)));\n      assert.match(logs[0], new RegExp(escapeRegExp(recoveryFiles[0])));\n      fs.removeSync(filePath);\n    });",
            "file": "main-process/file-recovery-service.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't create a recovery file when the file that's being saved doesn't exist yet",
            "suites": [
                "FileRecoveryService",
                "when a crash happens during a save"
            ],
            "updatePoint": {
                "line": 134,
                "column": 87
            },
            "line": 134,
            "code": "  it(\"doesn't create a recovery file when the file that's being saved doesn't exist yet\", async () => {\n    const mockWindow = {};\n    await recoveryService.willSavePath(mockWindow, 'a-file-that-doesnt-exist');\n    assert.equal(fs.listTreeSync(recoveryDirectory).length, 0);\n    await recoveryService.didSavePath(mockWindow, 'a-file-that-doesnt-exist');\n    assert.equal(fs.listTreeSync(recoveryDirectory).length, 0);\n  });",
            "file": "main-process/file-recovery-service.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "parses arguments as normal",
            "suites": [
                "parseCommandLine",
                "when --uri-handler is not passed"
            ],
            "updatePoint": {
                "line": 9,
                "column": 34
            },
            "line": 9,
            "code": "    it('parses arguments as normal', () => {\n      const args = parseCommandLine(['-d', '--safe', '--test', '/some/path', 'atom://test/url', 'atom://other/url']);\n      assert.isTrue(args.devMode);\n      assert.isTrue(args.safeMode);\n      assert.isTrue(args.test);\n      assert.deepEqual(args.urlsToOpen, ['atom://test/url', 'atom://other/url']);\n      assert.deepEqual(args.pathsToOpen, ['/some/path']);\n    }); // The \"underscore flag\" with no \"non-flag argument\" after it",
            "file": "main-process/parse-command-line.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not attempt to parse booleans as paths or URIs",
            "suites": [
                "parseCommandLine",
                "when --uri-handler is not passed",
                "and --_ or -_ are passed"
            ],
            "updatePoint": {
                "line": 22,
                "column": 61
            },
            "line": 22,
            "code": "      it('does not attempt to parse booleans as paths or URIs', () => {\n        const args = parseCommandLine(['--_', '/some/path', '-_', '-_', 'some/other/path', 'atom://test/url', '--_', 'atom://other/url', '-_', './another-path.file', '-_', '-_', '-_']);\n        assert.deepEqual(args.urlsToOpen, ['atom://test/url', 'atom://other/url']);\n        assert.deepEqual(args.pathsToOpen, ['/some/path', 'some/other/path', './another-path.file']);\n      });",
            "file": "main-process/parse-command-line.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not attempt to parse numbers as paths or URIs",
            "suites": [
                "parseCommandLine",
                "when --uri-handler is not passed",
                "and a non-flag number is passed as an argument"
            ],
            "updatePoint": {
                "line": 29,
                "column": 60
            },
            "line": 29,
            "code": "      it('does not attempt to parse numbers as paths or URIs', () => {\n        const args = parseCommandLine(['43', '/some/path', '22', '97', 'some/other/path', 'atom://test/url', '885', 'atom://other/url', '42', './another-path.file']);\n        assert.deepEqual(args.urlsToOpen, ['atom://test/url', 'atom://other/url']);\n        assert.deepEqual(args.pathsToOpen, ['/some/path', 'some/other/path', './another-path.file']);\n      });",
            "file": "main-process/parse-command-line.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores other arguments and limits to one URL",
            "suites": [
                "parseCommandLine",
                "when --uri-handler is passed"
            ],
            "updatePoint": {
                "line": 37,
                "column": 53
            },
            "line": 37,
            "code": "    it('ignores other arguments and limits to one URL', () => {\n      const args = parseCommandLine(['-d', '--uri-handler', '--safe', '--test', '/some/path', 'atom://test/url', 'atom://other/url']);\n      assert.isUndefined(args.devMode);\n      assert.isUndefined(args.safeMode);\n      assert.isUndefined(args.test);\n      assert.deepEqual(args.urlsToOpen, ['atom://test/url']);\n      assert.deepEqual(args.pathsToOpen, []);\n    });",
            "file": "main-process/parse-command-line.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores any arguments starting with \"-psn_\"",
            "suites": [
                "parseCommandLine",
                "when evil macOS Gatekeeper flag \"-psn_0_[six or seven digits here]\" is passed"
            ],
            "updatePoint": {
                "line": 47,
                "column": 51
            },
            "line": 47,
            "code": "    it('ignores any arguments starting with \"-psn_\"', () => {\n      const getPsnFlag = () => {\n        return `-psn_0_${Math.floor(Math.random() * 10_000_000)}`;\n      };\n\n      const args = parseCommandLine([getPsnFlag(), '/some/path', getPsnFlag(), getPsnFlag(), 'some/other/path', 'atom://test/url', getPsnFlag(), 'atom://other/url', '-psn_ Any argument starting with \"-psn_\" should be ignored, even this one.', './another-path.file']);\n      assert.deepEqual(args.urlsToOpen, ['atom://test/url', 'atom://other/url']);\n      assert.deepEqual(args.pathsToOpen, ['/some/path', 'some/other/path', './another-path.file']);\n    });",
            "file": "main-process/parse-command-line.test.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can add new menus that can be removed with the returned disposable",
            "suites": [
                "MenuManager",
                "::add(items)"
            ],
            "updatePoint": {
                "line": 19,
                "column": 74
            },
            "line": 19,
            "code": "    it('can add new menus that can be removed with the returned disposable', function () {\n      const disposable = menu.add([{\n        label: 'A',\n        submenu: [{\n          label: 'B',\n          command: 'b'\n        }]\n      }]);\n      expect(menu.template).toEqual([{\n        label: 'A',\n        id: 'A',\n        submenu: [{\n          label: 'B',\n          id: 'B',\n          command: 'b'\n        }]\n      }]);\n      disposable.dispose();\n      expect(menu.template).toEqual([]);\n    });",
            "file": "menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can add submenu items to existing menus that can be removed with the returned disposable",
            "suites": [
                "MenuManager",
                "::add(items)"
            ],
            "updatePoint": {
                "line": 39,
                "column": 96
            },
            "line": 39,
            "code": "    it('can add submenu items to existing menus that can be removed with the returned disposable', function () {\n      const disposable1 = menu.add([{\n        label: 'A',\n        submenu: [{\n          label: 'B',\n          command: 'b'\n        }]\n      }]);\n      const disposable2 = menu.add([{\n        label: 'A',\n        submenu: [{\n          label: 'C',\n          submenu: [{\n            label: 'D',\n            command: 'd'\n          }]\n        }]\n      }]);\n      const disposable3 = menu.add([{\n        label: 'A',\n        submenu: [{\n          label: 'C',\n          submenu: [{\n            label: 'E',\n            command: 'e'\n          }]\n        }]\n      }]);\n      expect(menu.template).toEqual([{\n        label: 'A',\n        id: 'A',\n        submenu: [{\n          label: 'B',\n          id: 'B',\n          command: 'b'\n        }, {\n          label: 'C',\n          id: 'C',\n          submenu: [{\n            label: 'D',\n            id: 'D',\n            command: 'd'\n          }, {\n            label: 'E',\n            id: 'E',\n            command: 'e'\n          }]\n        }]\n      }]);\n      disposable3.dispose();\n      expect(menu.template).toEqual([{\n        label: 'A',\n        id: 'A',\n        submenu: [{\n          label: 'B',\n          id: 'B',\n          command: 'b'\n        }, {\n          label: 'C',\n          id: 'C',\n          submenu: [{\n            label: 'D',\n            id: 'D',\n            command: 'd'\n          }]\n        }]\n      }]);\n      disposable2.dispose();\n      expect(menu.template).toEqual([{\n        label: 'A',\n        id: 'A',\n        submenu: [{\n          label: 'B',\n          id: 'B',\n          command: 'b'\n        }]\n      }]);\n      disposable1.dispose();\n      expect(menu.template).toEqual([]);\n    });",
            "file": "menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not add duplicate labels to the same menu",
            "suites": [
                "MenuManager",
                "::add(items)"
            ],
            "updatePoint": {
                "line": 119,
                "column": 54
            },
            "line": 119,
            "code": "    it('does not add duplicate labels to the same menu', function () {\n      const originalItemCount = menu.template.length;\n      menu.add([{\n        label: 'A',\n        submenu: [{\n          label: 'B',\n          command: 'b'\n        }]\n      }]);\n      menu.add([{\n        label: 'A',\n        submenu: [{\n          label: 'B',\n          command: 'b'\n        }]\n      }]);\n      expect(menu.template[originalItemCount]).toEqual({\n        label: 'A',\n        id: 'A',\n        submenu: [{\n          label: 'B',\n          id: 'B',\n          command: 'b'\n        }]\n      });\n    });",
            "file": "menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sends the current menu template and associated key bindings to the browser process",
            "suites": [
                "MenuManager",
                "::update()"
            ],
            "updatePoint": {
                "line": 151,
                "column": 90
            },
            "line": 151,
            "code": "    it('sends the current menu template and associated key bindings to the browser process', function () {\n      menu.add([{\n        label: 'A',\n        submenu: [{\n          label: 'B',\n          command: 'b'\n        }]\n      }]);\n      atom.keymaps.add('test', {\n        'atom-workspace': {\n          'ctrl-b': 'b'\n        }\n      });\n      menu.update();\n      advanceClock(1);\n      expect(menu.sendToBrowserProcess.argsForCall[0][1]['b']).toEqual(['ctrl-b']);\n    });",
            "file": "menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "omits key bindings that are mapped to unset! in any context",
            "suites": [
                "MenuManager",
                "::update()"
            ],
            "updatePoint": {
                "line": 168,
                "column": 67
            },
            "line": 168,
            "code": "    it('omits key bindings that are mapped to unset! in any context', function () {\n      // it would be nice to be smarter about omitting, but that would require a much\n      // more dynamic interaction between the currently focused element and the menu\n      menu.add([{\n        label: 'A',\n        submenu: [{\n          label: 'B',\n          command: 'b'\n        }]\n      }]);\n      atom.keymaps.add('test', {\n        'atom-workspace': {\n          'ctrl-b': 'b'\n        }\n      });\n      atom.keymaps.add('test', {\n        'atom-text-editor': {\n          'ctrl-b': 'unset!'\n        }\n      });\n      advanceClock(1);\n      expect(menu.sendToBrowserProcess.argsForCall[0][1]['b']).toBeUndefined();\n    });",
            "file": "menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "omits key bindings that could conflict with AltGraph characters on macOS",
            "suites": [
                "MenuManager",
                "::update()"
            ],
            "updatePoint": {
                "line": 191,
                "column": 80
            },
            "line": 191,
            "code": "    it('omits key bindings that could conflict with AltGraph characters on macOS', function () {\n      Object.defineProperty(process, 'platform', {\n        value: 'darwin'\n      });\n      menu.add([{\n        label: 'A',\n        submenu: [{\n          label: 'B',\n          command: 'b'\n        }, {\n          label: 'C',\n          command: 'c'\n        }, {\n          label: 'D',\n          command: 'd'\n        }]\n      }]);\n      atom.keymaps.add('test', {\n        'atom-workspace': {\n          'alt-b': 'b',\n          'alt-shift-C': 'c',\n          'alt-cmd-d': 'd'\n        }\n      });\n      advanceClock(1);\n      expect(menu.sendToBrowserProcess.argsForCall[0][1]['b']).toBeUndefined();\n      expect(menu.sendToBrowserProcess.argsForCall[0][1]['c']).toBeUndefined();\n      expect(menu.sendToBrowserProcess.argsForCall[0][1]['d']).toEqual(['alt-cmd-d']);\n    });",
            "file": "menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "omits key bindings that could conflict with AltGraph characters on Windows",
            "suites": [
                "MenuManager",
                "::update()"
            ],
            "updatePoint": {
                "line": 220,
                "column": 82
            },
            "line": 220,
            "code": "    it('omits key bindings that could conflict with AltGraph characters on Windows', function () {\n      Object.defineProperty(process, 'platform', {\n        value: 'win32'\n      });\n      menu.add([{\n        label: 'A',\n        submenu: [{\n          label: 'B',\n          command: 'b'\n        }, {\n          label: 'C',\n          command: 'c'\n        }, {\n          label: 'D',\n          command: 'd'\n        }]\n      }]);\n      atom.keymaps.add('test', {\n        'atom-workspace': {\n          'ctrl-alt-b': 'b',\n          'ctrl-alt-shift-C': 'c',\n          'ctrl-alt-cmd-d': 'd'\n        }\n      });\n      advanceClock(1);\n      expect(menu.sendToBrowserProcess.argsForCall[0][1]['b']).toBeUndefined();\n      expect(menu.sendToBrowserProcess.argsForCall[0][1]['c']).toBeUndefined();\n      expect(menu.sendToBrowserProcess.argsForCall[0][1]['d']).toEqual(['ctrl-alt-cmd-d']);\n    });",
            "file": "menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the application menu when a keymap is reloaded",
            "suites": [
                "MenuManager",
                "::update()"
            ],
            "updatePoint": {
                "line": 250,
                "column": 60
            },
            "line": 250,
            "code": "  it('updates the application menu when a keymap is reloaded', function () {\n    spyOn(menu, 'update');\n    const keymapPath = path.join(__dirname, 'fixtures', 'packages', 'package-with-keymaps', 'keymaps', 'keymap-1.cson');\n    atom.keymaps.reloadKeymap(keymapPath);\n    expect(menu.update).toHaveBeenCalled();\n  });",
            "file": "menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "preserves existing submenus",
            "suites": [
                "contextMenu",
                "dedupes separators"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "    it('preserves existing submenus', () => {\n      const items = [{\n        submenu: []\n      }];\n      expect(sortMenuItems(items)).toEqual(items);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "trims leading separators",
            "suites": [
                "contextMenu",
                "dedupes separators"
            ],
            "updatePoint": {
                "line": 15,
                "column": 32
            },
            "line": 15,
            "code": "    it('trims leading separators', () => {\n      const items = [{\n        type: 'separator'\n      }, {\n        command: 'core:one'\n      }];\n      const expected = [{\n        command: 'core:one'\n      }];\n      expect(sortMenuItems(items)).toEqual(expected);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "preserves separators at the beginning of set two",
            "suites": [
                "contextMenu",
                "dedupes separators"
            ],
            "updatePoint": {
                "line": 26,
                "column": 56
            },
            "line": 26,
            "code": "    it('preserves separators at the beginning of set two', () => {\n      const items = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }];\n      const expected = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }];\n      expect(sortMenuItems(items)).toEqual(expected);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "trims trailing separators",
            "suites": [
                "contextMenu",
                "dedupes separators"
            ],
            "updatePoint": {
                "line": 43,
                "column": 33
            },
            "line": 43,
            "code": "    it('trims trailing separators', () => {\n      const items = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }];\n      const expected = [{\n        command: 'core:one'\n      }];\n      expect(sortMenuItems(items)).toEqual(expected);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes duplicate separators across sets",
            "suites": [
                "contextMenu",
                "dedupes separators"
            ],
            "updatePoint": {
                "line": 54,
                "column": 48
            },
            "line": 54,
            "code": "    it('removes duplicate separators across sets', () => {\n      const items = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }];\n      const expected = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }];\n      expect(sortMenuItems(items)).toEqual(expected);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can move a group of one item",
            "suites": [
                "contextMenu",
                "can move an item to a different group by merging groups"
            ],
            "updatePoint": {
                "line": 75,
                "column": 36
            },
            "line": 75,
            "code": "    it('can move a group of one item', () => {\n      const items = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:three',\n        after: ['core:one']\n      }, {\n        type: 'separator'\n      }];\n      const expected = [{\n        command: 'core:one'\n      }, {\n        command: 'core:three',\n        after: ['core:one']\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }];\n      expect(sortMenuItems(items)).toEqual(expected);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves all items in the moving item's group",
            "suites": [
                "contextMenu",
                "can move an item to a different group by merging groups"
            ],
            "updatePoint": {
                "line": 102,
                "column": 50
            },
            "line": 102,
            "code": "    it(\"moves all items in the moving item's group\", () => {\n      const items = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:three',\n        after: ['core:one']\n      }, {\n        command: 'core:four'\n      }, {\n        type: 'separator'\n      }];\n      const expected = [{\n        command: 'core:one'\n      }, {\n        command: 'core:three',\n        after: ['core:one']\n      }, {\n        command: 'core:four'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }];\n      expect(sortMenuItems(items)).toEqual(expected);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores positions relative to commands that don't exist",
            "suites": [
                "contextMenu",
                "can move an item to a different group by merging groups"
            ],
            "updatePoint": {
                "line": 133,
                "column": 63
            },
            "line": 133,
            "code": "    it(\"ignores positions relative to commands that don't exist\", () => {\n      const items = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:three',\n        after: ['core:does-not-exist']\n      }, {\n        command: 'core:four',\n        after: ['core:one']\n      }, {\n        type: 'separator'\n      }];\n      const expected = [{\n        command: 'core:one'\n      }, {\n        command: 'core:three',\n        after: ['core:does-not-exist']\n      }, {\n        command: 'core:four',\n        after: ['core:one']\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }];\n      expect(sortMenuItems(items)).toEqual(expected);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can handle recursive group merging",
            "suites": [
                "contextMenu",
                "can move an item to a different group by merging groups"
            ],
            "updatePoint": {
                "line": 166,
                "column": 42
            },
            "line": 166,
            "code": "    it('can handle recursive group merging', () => {\n      const items = [{\n        command: 'core:one',\n        after: ['core:three']\n      }, {\n        command: 'core:two',\n        before: ['core:one']\n      }, {\n        command: 'core:three'\n      }];\n      const expected = [{\n        command: 'core:three'\n      }, {\n        command: 'core:two',\n        before: ['core:one']\n      }, {\n        command: 'core:one',\n        after: ['core:three']\n      }];\n      expect(sortMenuItems(items)).toEqual(expected);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can merge multiple groups when given a list of before/after commands",
            "suites": [
                "contextMenu",
                "can move an item to a different group by merging groups"
            ],
            "updatePoint": {
                "line": 187,
                "column": 76
            },
            "line": 187,
            "code": "    it('can merge multiple groups when given a list of before/after commands', () => {\n      const items = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:three',\n        after: ['core:one', 'core:two']\n      }];\n      const expected = [{\n        command: 'core:two'\n      }, {\n        command: 'core:one'\n      }, {\n        command: 'core:three',\n        after: ['core:one', 'core:two']\n      }];\n      expect(sortMenuItems(items)).toEqual(expected);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can merge multiple groups based on both before/after commands",
            "suites": [
                "contextMenu",
                "can move an item to a different group by merging groups"
            ],
            "updatePoint": {
                "line": 210,
                "column": 69
            },
            "line": 210,
            "code": "    it('can merge multiple groups based on both before/after commands', () => {\n      const items = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:three',\n        after: ['core:one'],\n        before: ['core:two']\n      }];\n      const expected = [{\n        command: 'core:one'\n      }, {\n        command: 'core:three',\n        after: ['core:one'],\n        before: ['core:two']\n      }, {\n        command: 'core:two'\n      }];\n      expect(sortMenuItems(items)).toEqual(expected);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does a simple sort",
            "suites": [
                "contextMenu",
                "sorts items within their ultimate group"
            ],
            "updatePoint": {
                "line": 237,
                "column": 26
            },
            "line": 237,
            "code": "    it('does a simple sort', () => {\n      const items = [{\n        command: 'core:two',\n        after: ['core:one']\n      }, {\n        command: 'core:one'\n      }];\n      expect(sortMenuItems(items)).toEqual([{\n        command: 'core:one'\n      }, {\n        command: 'core:two',\n        after: ['core:one']\n      }]);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves cycles by ignoring things that conflict",
            "suites": [
                "contextMenu",
                "sorts items within their ultimate group"
            ],
            "updatePoint": {
                "line": 251,
                "column": 56
            },
            "line": 251,
            "code": "    it('resolves cycles by ignoring things that conflict', () => {\n      const items = [{\n        command: 'core:two',\n        after: ['core:one']\n      }, {\n        command: 'core:one',\n        after: ['core:two']\n      }];\n      expect(sortMenuItems(items)).toEqual([{\n        command: 'core:one',\n        after: ['core:two']\n      }, {\n        command: 'core:two',\n        after: ['core:one']\n      }]);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does a simple sort",
            "suites": [
                "contextMenu",
                "sorts groups"
            ],
            "updatePoint": {
                "line": 269,
                "column": 26
            },
            "line": 269,
            "code": "    it('does a simple sort', () => {\n      const items = [{\n        command: 'core:two',\n        afterGroupContaining: ['core:one']\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:one'\n      }];\n      expect(sortMenuItems(items)).toEqual([{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two',\n        afterGroupContaining: ['core:one']\n      }]);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves cycles by ignoring things that conflict",
            "suites": [
                "contextMenu",
                "sorts groups"
            ],
            "updatePoint": {
                "line": 287,
                "column": 56
            },
            "line": 287,
            "code": "    it('resolves cycles by ignoring things that conflict', () => {\n      const items = [{\n        command: 'core:two',\n        afterGroupContaining: ['core:one']\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:one',\n        afterGroupContaining: ['core:two']\n      }];\n      expect(sortMenuItems(items)).toEqual([{\n        command: 'core:one',\n        afterGroupContaining: ['core:two']\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two',\n        afterGroupContaining: ['core:one']\n      }]);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores references to commands that do not exist",
            "suites": [
                "contextMenu",
                "sorts groups"
            ],
            "updatePoint": {
                "line": 307,
                "column": 56
            },
            "line": 307,
            "code": "    it('ignores references to commands that do not exist', () => {\n      const items = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two',\n        afterGroupContaining: ['core:does-not-exist']\n      }];\n      expect(sortMenuItems(items)).toEqual([{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two',\n        afterGroupContaining: ['core:does-not-exist']\n      }]);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only respects the first matching [before|after]GroupContaining rule in a given group",
            "suites": [
                "contextMenu",
                "sorts groups"
            ],
            "updatePoint": {
                "line": 325,
                "column": 92
            },
            "line": 325,
            "code": "    it('only respects the first matching [before|after]GroupContaining rule in a given group', () => {\n      const items = [{\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:three',\n        beforeGroupContaining: ['core:one']\n      }, {\n        command: 'core:four',\n        afterGroupContaining: ['core:two']\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }];\n      expect(sortMenuItems(items)).toEqual([{\n        command: 'core:three',\n        beforeGroupContaining: ['core:one']\n      }, {\n        command: 'core:four',\n        afterGroupContaining: ['core:two']\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:one'\n      }, {\n        type: 'separator'\n      }, {\n        command: 'core:two'\n      }]);\n    });",
            "file": "menu-sort-helpers-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves Electron module paths without hitting the filesystem",
            "suites": [
                "ModuleCache"
            ],
            "updatePoint": {
                "line": 18,
                "column": 67
            },
            "line": 18,
            "code": "  it('resolves Electron module paths without hitting the filesystem', function () {\n    const {\n      builtins\n    } = ModuleCache.cache;\n    expect(Object.keys(builtins).length).toBeGreaterThan(0);\n\n    for (let builtinName in builtins) {\n      const builtinPath = builtins[builtinName];\n      expect(require.resolve(builtinName)).toBe(builtinPath);\n      expect(fs.isFileSync(require.resolve(builtinName))).toBeTruthy();\n    }\n\n    expect(Module._findPath.callCount).toBe(0);\n  });",
            "file": "module-cache-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves relative core paths without hitting the filesystem",
            "suites": [
                "ModuleCache"
            ],
            "updatePoint": {
                "line": 32,
                "column": 65
            },
            "line": 32,
            "code": "  it('resolves relative core paths without hitting the filesystem', function () {\n    ModuleCache.add(atom.getLoadSettings().resourcePath, {\n      _atomModuleCache: {\n        extensions: {\n          '.json': [path.join('spec', 'fixtures', 'module-cache', 'file.json')]\n        }\n      }\n    });\n    expect(require('./fixtures/module-cache/file.json').foo).toBe('bar');\n    expect(Module._findPath.callCount).toBe(0);\n  });",
            "file": "module-cache-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves module paths when a compatible version is provided by core",
            "suites": [
                "ModuleCache"
            ],
            "updatePoint": {
                "line": 43,
                "column": 73
            },
            "line": 43,
            "code": "  it('resolves module paths when a compatible version is provided by core', function () {\n    const packagePath = fs.realpathSync(temp.mkdirSync('atom-package'));\n    ModuleCache.add(packagePath, {\n      _atomModuleCache: {\n        folders: [{\n          paths: [''],\n          dependencies: {\n            'underscore-plus': '*'\n          }\n        }]\n      }\n    });\n    ModuleCache.add(atom.getLoadSettings().resourcePath, {\n      _atomModuleCache: {\n        dependencies: [{\n          name: 'underscore-plus',\n          version: require('underscore-plus/package.json').version,\n          path: path.join('node_modules', 'underscore-plus', 'lib', 'underscore-plus.js')\n        }]\n      }\n    });\n    const indexPath = path.join(packagePath, 'index.js');\n    fs.writeFileSync(indexPath, `\\\nexports.load = function() { require('underscore-plus'); };\\\n`);\n\n    const packageMain = require(indexPath);\n\n    Module._findPath.reset();\n\n    packageMain.load();\n    expect(Module._findPath.callCount).toBe(0);\n  });",
            "file": "module-cache-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not resolve module paths when no compatible version is provided by core",
            "suites": [
                "ModuleCache"
            ],
            "updatePoint": {
                "line": 76,
                "column": 82
            },
            "line": 76,
            "code": "  it('does not resolve module paths when no compatible version is provided by core', function () {\n    const packagePath = fs.realpathSync(temp.mkdirSync('atom-package'));\n    ModuleCache.add(packagePath, {\n      _atomModuleCache: {\n        folders: [{\n          paths: [''],\n          dependencies: {\n            'underscore-plus': '0.0.1'\n          }\n        }]\n      }\n    });\n    ModuleCache.add(atom.getLoadSettings().resourcePath, {\n      _atomModuleCache: {\n        dependencies: [{\n          name: 'underscore-plus',\n          version: require('underscore-plus/package.json').version,\n          path: path.join('node_modules', 'underscore-plus', 'lib', 'underscore-plus.js')\n        }]\n      }\n    });\n    const indexPath = path.join(packagePath, 'index.js');\n    fs.writeFileSync(indexPath, `\\\nexports.load = function() { require('underscore-plus'); };\\\n`);\n    spyOn(process, 'cwd').andReturn('/'); // Required when running this test from CLI\n\n    const packageMain = require(indexPath);\n\n    Module._findPath.reset();\n\n    expect(() => packageMain.load()).toThrow();\n    expect(Module._findPath.callCount).toBe(1);\n  });",
            "file": "module-cache-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "attaches a Watcher to a newly created NativeWatcher for a new directory",
            "suites": [
                "NativeWatcherRegistry"
            ],
            "updatePoint": {
                "line": 89,
                "column": 77
            },
            "line": 89,
            "code": "  it('attaches a Watcher to a newly created NativeWatcher for a new directory', async function () {\n    const watcher = new MockWatcher(absolute('some', 'path'));\n    const NATIVE = new MockNative('created');\n\n    createNative = () => NATIVE;\n\n    await registry.attach(watcher);\n    expect(watcher.native).toBe(NATIVE);\n  });",
            "file": "native-watcher-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reuses an existing NativeWatcher on the same directory",
            "suites": [
                "NativeWatcherRegistry"
            ],
            "updatePoint": {
                "line": 98,
                "column": 60
            },
            "line": 98,
            "code": "  it('reuses an existing NativeWatcher on the same directory', async function () {\n    this.RETRY_FLAKY_TEST_AND_SLOW_DOWN_THE_BUILD();\n    const EXISTING = new MockNative('existing');\n    const existingPath = absolute('existing', 'path');\n    let firstTime = true;\n\n    createNative = () => {\n      if (firstTime) {\n        firstTime = false;\n        return EXISTING;\n      }\n\n      return new MockNative('nope');\n    };\n\n    await registry.attach(new MockWatcher(existingPath));\n    const watcher = new MockWatcher(existingPath);\n    await registry.attach(watcher);\n    expect(watcher.native).toBe(EXISTING);\n  });",
            "file": "native-watcher-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "attaches to an existing NativeWatcher on a parent directory",
            "suites": [
                "NativeWatcherRegistry"
            ],
            "updatePoint": {
                "line": 118,
                "column": 65
            },
            "line": 118,
            "code": "  it('attaches to an existing NativeWatcher on a parent directory', async function () {\n    const EXISTING = new MockNative('existing');\n    const parentDir = absolute('existing', 'path');\n    const subDir = path.join(parentDir, 'sub', 'directory');\n    let firstTime = true;\n\n    createNative = () => {\n      if (firstTime) {\n        firstTime = false;\n        return EXISTING;\n      }\n\n      return new MockNative('nope');\n    };\n\n    await registry.attach(new MockWatcher(parentDir));\n    const watcher = new MockWatcher(subDir);\n    await registry.attach(watcher);\n    expect(watcher.native).toBe(EXISTING);\n  });",
            "file": "native-watcher-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adopts Watchers from NativeWatchers on child directories",
            "suites": [
                "NativeWatcherRegistry"
            ],
            "updatePoint": {
                "line": 138,
                "column": 62
            },
            "line": 138,
            "code": "  it('adopts Watchers from NativeWatchers on child directories', async function () {\n    const parentDir = absolute('existing', 'path');\n    const childDir0 = path.join(parentDir, 'child', 'directory', 'zero');\n    const childDir1 = path.join(parentDir, 'child', 'directory', 'one');\n    const otherDir = absolute('another', 'path');\n    const CHILD0 = new MockNative('existing0');\n    const CHILD1 = new MockNative('existing1');\n    const OTHER = new MockNative('existing2');\n    const PARENT = new MockNative('parent');\n\n    createNative = dir => {\n      if (dir === childDir0) {\n        return CHILD0;\n      } else if (dir === childDir1) {\n        return CHILD1;\n      } else if (dir === otherDir) {\n        return OTHER;\n      } else if (dir === parentDir) {\n        return PARENT;\n      } else {\n        throw new Error(`Unexpected path: ${dir}`);\n      }\n    };\n\n    const watcher0 = new MockWatcher(childDir0);\n    await registry.attach(watcher0);\n    const watcher1 = new MockWatcher(childDir1);\n    await registry.attach(watcher1);\n    const watcher2 = new MockWatcher(otherDir);\n    await registry.attach(watcher2);\n    expect(watcher0.native).toBe(CHILD0);\n    expect(watcher1.native).toBe(CHILD1);\n    expect(watcher2.native).toBe(OTHER); // Consolidate all three watchers beneath the same native watcher on the parent directory\n\n    const watcher = new MockWatcher(parentDir);\n    await registry.attach(watcher);\n    expect(watcher.native).toBe(PARENT);\n    expect(watcher0.native).toBe(PARENT);\n    expect(CHILD0.stopped).toBe(true);\n    expect(CHILD0.disposed).toBe(true);\n    expect(watcher1.native).toBe(PARENT);\n    expect(CHILD1.stopped).toBe(true);\n    expect(CHILD1.disposed).toBe(true);\n    expect(watcher2.native).toBe(OTHER);\n    expect(OTHER.stopped).toBe(false);\n    expect(OTHER.disposed).toBe(false);\n  });",
            "file": "native-watcher-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "happens when they stop",
            "suites": [
                "NativeWatcherRegistry",
                "removing NativeWatchers"
            ],
            "updatePoint": {
                "line": 186,
                "column": 30
            },
            "line": 186,
            "code": "    it('happens when they stop', async function () {\n      const STOPPED = new MockNative('stopped');\n      const RUNNING = new MockNative('running');\n      const stoppedPath = absolute('watcher', 'that', 'will', 'be', 'stopped');\n      const stoppedPathParts = stoppedPath.split(path.sep).filter(part => part.length > 0);\n      const runningPath = absolute('watcher', 'that', 'will', 'continue', 'to', 'exist');\n      const runningPathParts = runningPath.split(path.sep).filter(part => part.length > 0);\n\n      createNative = dir => {\n        if (dir === stoppedPath) {\n          return STOPPED;\n        } else if (dir === runningPath) {\n          return RUNNING;\n        } else {\n          throw new Error(`Unexpected path: ${dir}`);\n        }\n      };\n\n      const stoppedWatcher = new MockWatcher(stoppedPath);\n      await registry.attach(stoppedWatcher);\n      const runningWatcher = new MockWatcher(runningPath);\n      await registry.attach(runningWatcher);\n      STOPPED.stop();\n      const runningNode = registry.tree.root.lookup(runningPathParts).when({\n        parent: node => node,\n        missing: () => false,\n        children: () => false\n      });\n      expect(runningNode).toBeTruthy();\n      expect(runningNode.getNativeWatcher()).toBe(RUNNING);\n      const stoppedNode = registry.tree.root.lookup(stoppedPathParts).when({\n        parent: () => false,\n        missing: () => true,\n        children: () => false\n      });\n      expect(stoppedNode).toBe(true);\n    });",
            "file": "native-watcher-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reassigns new child watchers when a parent watcher is stopped",
            "suites": [
                "NativeWatcherRegistry",
                "removing NativeWatchers"
            ],
            "updatePoint": {
                "line": 223,
                "column": 69
            },
            "line": 223,
            "code": "    it('reassigns new child watchers when a parent watcher is stopped', async function () {\n      const CHILD0 = new MockNative('child0');\n      const CHILD1 = new MockNative('child1');\n      const PARENT = new MockNative('parent');\n      const parentDir = absolute('parent');\n      const childDir0 = path.join(parentDir, 'child0');\n      const childDir1 = path.join(parentDir, 'child1');\n\n      createNative = dir => {\n        if (dir === parentDir) {\n          return PARENT;\n        } else if (dir === childDir0) {\n          return CHILD0;\n        } else if (dir === childDir1) {\n          return CHILD1;\n        } else {\n          throw new Error(`Unexpected directory ${dir}`);\n        }\n      };\n\n      const parentWatcher = new MockWatcher(parentDir);\n      const childWatcher0 = new MockWatcher(childDir0);\n      const childWatcher1 = new MockWatcher(childDir1);\n      await registry.attach(parentWatcher);\n      await Promise.all([registry.attach(childWatcher0), registry.attach(childWatcher1)]); // All three watchers should share the parent watcher's native watcher.\n\n      expect(parentWatcher.native).toBe(PARENT);\n      expect(childWatcher0.native).toBe(PARENT);\n      expect(childWatcher1.native).toBe(PARENT); // Stopping the parent should detach and recreate the child watchers.\n\n      PARENT.stop();\n      expect(childWatcher0.native).toBe(CHILD0);\n      expect(childWatcher1.native).toBe(CHILD1);\n      expect(registry.tree.root.lookup(parts(parentDir)).when({\n        parent: () => false,\n        missing: () => false,\n        children: () => true\n      })).toBe(true);\n      expect(registry.tree.root.lookup(parts(childDir0)).when({\n        parent: () => true,\n        missing: () => false,\n        children: () => false\n      })).toBe(true);\n      expect(registry.tree.root.lookup(parts(childDir1)).when({\n        parent: () => true,\n        missing: () => false,\n        children: () => false\n      })).toBe(true);\n    });",
            "file": "native-watcher-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "consolidates children when splitting a parent watcher",
            "suites": [
                "NativeWatcherRegistry",
                "removing NativeWatchers"
            ],
            "updatePoint": {
                "line": 272,
                "column": 61
            },
            "line": 272,
            "code": "    it('consolidates children when splitting a parent watcher', async function () {\n      const CHILD0 = new MockNative('child0');\n      const PARENT = new MockNative('parent');\n      const parentDir = absolute('parent');\n      const childDir0 = path.join(parentDir, 'child0');\n      const childDir1 = path.join(parentDir, 'child0', 'child1');\n\n      createNative = dir => {\n        if (dir === parentDir) {\n          return PARENT;\n        } else if (dir === childDir0) {\n          return CHILD0;\n        } else {\n          throw new Error(`Unexpected directory ${dir}`);\n        }\n      };\n\n      const parentWatcher = new MockWatcher(parentDir);\n      const childWatcher0 = new MockWatcher(childDir0);\n      const childWatcher1 = new MockWatcher(childDir1);\n      await registry.attach(parentWatcher);\n      await Promise.all([registry.attach(childWatcher0), registry.attach(childWatcher1)]); // All three watchers should share the parent watcher's native watcher.\n\n      expect(parentWatcher.native).toBe(PARENT);\n      expect(childWatcher0.native).toBe(PARENT);\n      expect(childWatcher1.native).toBe(PARENT); // Stopping the parent should detach and create the child watchers. Both child watchers should\n      // share the same native watcher.\n\n      PARENT.stop();\n      expect(childWatcher0.native).toBe(CHILD0);\n      expect(childWatcher1.native).toBe(CHILD0);\n      expect(registry.tree.root.lookup(parts(parentDir)).when({\n        parent: () => false,\n        missing: () => false,\n        children: () => true\n      })).toBe(true);\n      expect(registry.tree.root.lookup(parts(childDir0)).when({\n        parent: () => true,\n        missing: () => false,\n        children: () => false\n      })).toBe(true);\n      expect(registry.tree.root.lookup(parts(childDir1)).when({\n        parent: () => true,\n        missing: () => false,\n        children: () => false\n      })).toBe(true);\n    });",
            "file": "native-watcher-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "has a notifications instance",
            "suites": [
                "NotificationManager",
                "the atom global"
            ],
            "updatePoint": {
                "line": 8,
                "column": 68
            },
            "line": 8,
            "code": "  describe('the atom global', () => it('has a notifications instance', () => {\n    expect(atom.notifications instanceof NotificationManager).toBe(true);\n  }));",
            "file": "notification-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits an event when a notification has been added",
            "suites": [
                "NotificationManager",
                "adding events"
            ],
            "updatePoint": {
                "line": 17,
                "column": 57
            },
            "line": 17,
            "code": "    it('emits an event when a notification has been added', () => {\n      manager.add('error', 'Some error!', {\n        icon: 'someIcon'\n      });\n      expect(addSpy).toHaveBeenCalled();\n      const notification = addSpy.mostRecentCall.args[0];\n      expect(notification.getType()).toBe('error');\n      expect(notification.getMessage()).toBe('Some error!');\n      expect(notification.getIcon()).toBe('someIcon');\n    });",
            "file": "notification-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a fatal error when ::addFatalError has been called",
            "suites": [
                "NotificationManager",
                "adding events"
            ],
            "updatePoint": {
                "line": 27,
                "column": 64
            },
            "line": 27,
            "code": "    it('emits a fatal error when ::addFatalError has been called', () => {\n      manager.addFatalError('Some error!', {\n        icon: 'someIcon'\n      });\n      expect(addSpy).toHaveBeenCalled();\n      const notification = addSpy.mostRecentCall.args[0];\n      expect(notification.getType()).toBe('fatal');\n    });",
            "file": "notification-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits an error when ::addError has been called",
            "suites": [
                "NotificationManager",
                "adding events"
            ],
            "updatePoint": {
                "line": 35,
                "column": 54
            },
            "line": 35,
            "code": "    it('emits an error when ::addError has been called', () => {\n      manager.addError('Some error!', {\n        icon: 'someIcon'\n      });\n      expect(addSpy).toHaveBeenCalled();\n      const notification = addSpy.mostRecentCall.args[0];\n      expect(notification.getType()).toBe('error');\n    });",
            "file": "notification-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a warning notification when ::addWarning has been called",
            "suites": [
                "NotificationManager",
                "adding events"
            ],
            "updatePoint": {
                "line": 43,
                "column": 70
            },
            "line": 43,
            "code": "    it('emits a warning notification when ::addWarning has been called', () => {\n      manager.addWarning('Something!', {\n        icon: 'someIcon'\n      });\n      expect(addSpy).toHaveBeenCalled();\n      const notification = addSpy.mostRecentCall.args[0];\n      expect(notification.getType()).toBe('warning');\n    });",
            "file": "notification-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits an info notification when ::addInfo has been called",
            "suites": [
                "NotificationManager",
                "adding events"
            ],
            "updatePoint": {
                "line": 51,
                "column": 65
            },
            "line": 51,
            "code": "    it('emits an info notification when ::addInfo has been called', () => {\n      manager.addInfo('Something!', {\n        icon: 'someIcon'\n      });\n      expect(addSpy).toHaveBeenCalled();\n      const notification = addSpy.mostRecentCall.args[0];\n      expect(notification.getType()).toBe('info');\n    });",
            "file": "notification-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a success notification when ::addSuccess has been called",
            "suites": [
                "NotificationManager",
                "adding events"
            ],
            "updatePoint": {
                "line": 59,
                "column": 70
            },
            "line": 59,
            "code": "    it('emits a success notification when ::addSuccess has been called', () => {\n      manager.addSuccess('Something!', {\n        icon: 'someIcon'\n      });\n      expect(addSpy).toHaveBeenCalled();\n      const notification = addSpy.mostRecentCall.args[0];\n      expect(notification.getType()).toBe('success');\n    });",
            "file": "notification-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears the notifications when ::clear has been called",
            "suites": [
                "NotificationManager",
                "clearing notifications"
            ],
            "updatePoint": {
                "line": 69,
                "column": 61
            },
            "line": 69,
            "code": "    it('clears the notifications when ::clear has been called', () => {\n      manager.addSuccess('success');\n      expect(manager.getNotifications().length).toBe(1);\n      manager.clear();\n      expect(manager.getNotifications().length).toBe(0);\n    });",
            "file": "notification-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits an event when the notifications have been cleared",
            "suites": [
                "NotificationManager",
                "clearing notifications",
                "adding events"
            ],
            "updatePoint": {
                "line": 81,
                "column": 65
            },
            "line": 81,
            "code": "      it('emits an event when the notifications have been cleared', () => {\n        manager.clear();\n        expect(clearSpy).toHaveBeenCalled();\n      });",
            "file": "notification-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error when created with a non-string message",
            "suites": [
                "Notification"
            ],
            "updatePoint": {
                "line": 4,
                "column": 60
            },
            "line": 4,
            "code": "  it('throws an error when created with a non-string message', () => {\n    expect(() => new Notification('error', null)).toThrow();\n    expect(() => new Notification('error', 3)).toThrow();\n    expect(() => new Notification('error', {})).toThrow();\n    expect(() => new Notification('error', false)).toThrow();\n    expect(() => new Notification('error', [])).toThrow();\n  });",
            "file": "notification-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error when created with non-object options",
            "suites": [
                "Notification"
            ],
            "updatePoint": {
                "line": 11,
                "column": 58
            },
            "line": 11,
            "code": "  it('throws an error when created with non-object options', () => {\n    expect(() => new Notification('error', 'message', 'foo')).toThrow();\n    expect(() => new Notification('error', 'message', 3)).toThrow();\n    expect(() => new Notification('error', 'message', false)).toThrow();\n    expect(() => new Notification('error', 'message', [])).toThrow();\n  });",
            "file": "notification-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a Date object",
            "suites": [
                "Notification",
                "::getTimestamp()"
            ],
            "updatePoint": {
                "line": 17,
                "column": 62
            },
            "line": 17,
            "code": "  describe('::getTimestamp()', () => it('returns a Date object', () => {\n    const notification = new Notification('error', 'message!');\n    expect(notification.getTimestamp() instanceof Date).toBe(true);\n  }));",
            "file": "notification-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a default when no icon specified",
            "suites": [
                "Notification",
                "::getIcon()"
            ],
            "updatePoint": {
                "line": 22,
                "column": 48
            },
            "line": 22,
            "code": "    it('returns a default when no icon specified', () => {\n      const notification = new Notification('error', 'message!');\n      expect(notification.getIcon()).toBe('flame');\n    });",
            "file": "notification-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the icon specified",
            "suites": [
                "Notification",
                "::getIcon()"
            ],
            "updatePoint": {
                "line": 26,
                "column": 34
            },
            "line": 26,
            "code": "    it('returns the icon specified', () => {\n      const notification = new Notification('error', 'message!', {\n        icon: 'my-icon'\n      });\n      expect(notification.getIcon()).toBe('my-icon');\n    });",
            "file": "notification-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls a callback when the notification is dismissed",
            "suites": [
                "Notification",
                "dismissing notifications",
                "when the notfication is dismissable"
            ],
            "updatePoint": {
                "line": 34,
                "column": 113
            },
            "line": 34,
            "code": "    describe('when the notfication is dismissable', () => it('calls a callback when the notification is dismissed', () => {\n      const dismissedSpy = jasmine.createSpy();\n      const notification = new Notification('error', 'message', {\n        dismissable: true\n      });\n      notification.onDidDismiss(dismissedSpy);\n      expect(notification.isDismissable()).toBe(true);\n      expect(notification.isDismissed()).toBe(false);\n      notification.dismiss();\n      expect(dismissedSpy).toHaveBeenCalled();\n      expect(notification.isDismissed()).toBe(true);\n    }));",
            "file": "notification-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing when ::dismiss() is called",
            "suites": [
                "Notification",
                "dismissing notifications",
                "when the notfication is not dismissable"
            ],
            "updatePoint": {
                "line": 46,
                "column": 105
            },
            "line": 46,
            "code": "    describe('when the notfication is not dismissable', () => it('does nothing when ::dismiss() is called', () => {\n      const dismissedSpy = jasmine.createSpy();\n      const notification = new Notification('error', 'message');\n      notification.onDidDismiss(dismissedSpy);\n      expect(notification.isDismissable()).toBe(false);\n      expect(notification.isDismissed()).toBe(true);\n      notification.dismiss();\n      expect(dismissedSpy).not.toHaveBeenCalled();\n      expect(notification.isDismissed()).toBe(true);\n    }));",
            "file": "notification-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds regular package path",
            "suites": [
                "PackageManager",
                "initialize"
            ],
            "updatePoint": {
                "line": 38,
                "column": 33
            },
            "line": 38,
            "code": "    it('adds regular package path', () => {\n      const packageManger = new PackageManager({});\n      const configDirPath = path.join('~', 'someConfig');\n      packageManger.initialize({\n        configDirPath\n      });\n      expect(packageManger.packageDirPaths.length).toBe(1);\n      expect(packageManger.packageDirPaths[0]).toBe(path.join(configDirPath, 'packages'));\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds regular package path, dev package path, and Atom repo package path in dev mode and dev resource path is set",
            "suites": [
                "PackageManager",
                "initialize"
            ],
            "updatePoint": {
                "line": 47,
                "column": 120
            },
            "line": 47,
            "code": "    it('adds regular package path, dev package path, and Atom repo package path in dev mode and dev resource path is set', () => {\n      const packageManger = new PackageManager({});\n      const configDirPath = path.join('~', 'someConfig');\n      const resourcePath = path.join('~', '/atom');\n      packageManger.initialize({\n        configDirPath,\n        resourcePath,\n        devMode: true\n      });\n      expect(packageManger.packageDirPaths.length).toBe(3);\n      expect(packageManger.packageDirPaths).toContain(path.join(configDirPath, 'packages'));\n      expect(packageManger.packageDirPaths).toContain(path.join(configDirPath, 'dev', 'packages'));\n      expect(packageManger.packageDirPaths).toContain(path.join(resourcePath, 'packages'));\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the path to the apm command",
            "suites": [
                "PackageManager",
                "::getApmPath()"
            ],
            "updatePoint": {
                "line": 63,
                "column": 43
            },
            "line": 63,
            "code": "    it('returns the path to the apm command', () => {\n      let apmPath = path.join(process.resourcesPath, 'app', 'apm', 'bin', 'apm');\n\n      if (process.platform === 'win32') {\n        apmPath += '.cmd';\n      }\n\n      expect(atom.packages.getApmPath()).toBe(apmPath);\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the value of the core.apmPath config setting",
            "suites": [
                "PackageManager",
                "::getApmPath()",
                "when the core.apmPath setting is set"
            ],
            "updatePoint": {
                "line": 74,
                "column": 62
            },
            "line": 74,
            "code": "      it('returns the value of the core.apmPath config setting', () => {\n        expect(atom.packages.getApmPath()).toBe('/path/to/apm');\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets hasLoadedInitialPackages",
            "suites": [
                "PackageManager",
                "::loadPackages()"
            ],
            "updatePoint": {
                "line": 85,
                "column": 37
            },
            "line": 85,
            "code": "    it('sets hasLoadedInitialPackages', () => {\n      expect(atom.packages.hasLoadedInitialPackages()).toBe(false);\n      atom.packages.loadPackages();\n      expect(atom.packages.hasLoadedInitialPackages()).toBe(true);\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the package",
            "suites": [
                "PackageManager",
                "::loadPackage(name)"
            ],
            "updatePoint": {
                "line": 93,
                "column": 27
            },
            "line": 93,
            "code": "    it('returns the package', () => {\n      const pack = atom.packages.loadPackage('package-with-index');\n      expect(pack instanceof Package).toBe(true);\n      expect(pack.metadata.name).toBe('package-with-index');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the package if it has an invalid keymap",
            "suites": [
                "PackageManager",
                "::loadPackage(name)"
            ],
            "updatePoint": {
                "line": 98,
                "column": 55
            },
            "line": 98,
            "code": "    it('returns the package if it has an invalid keymap', () => {\n      spyOn(atom, 'inSpecMode').andReturn(false);\n      const pack = atom.packages.loadPackage('package-with-broken-keymap');\n      expect(pack instanceof Package).toBe(true);\n      expect(pack.metadata.name).toBe('package-with-broken-keymap');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the package if it has an invalid stylesheet",
            "suites": [
                "PackageManager",
                "::loadPackage(name)"
            ],
            "updatePoint": {
                "line": 104,
                "column": 59
            },
            "line": 104,
            "code": "    it('returns the package if it has an invalid stylesheet', () => {\n      spyOn(atom, 'inSpecMode').andReturn(false);\n      const pack = atom.packages.loadPackage('package-with-invalid-styles');\n      expect(pack instanceof Package).toBe(true);\n      expect(pack.metadata.name).toBe('package-with-invalid-styles');\n      expect(pack.stylesheets.length).toBe(0);\n      const addErrorHandler = jasmine.createSpy();\n      atom.notifications.onDidAddNotification(addErrorHandler);\n      expect(() => pack.reloadStylesheets()).not.toThrow();\n      expect(addErrorHandler.callCount).toBe(2);\n      expect(addErrorHandler.argsForCall[1][0].message).toContain('Failed to reload the package-with-invalid-styles package stylesheets');\n      expect(addErrorHandler.argsForCall[1][0].options.packageName).toEqual('package-with-invalid-styles');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null if the package has an invalid package.json",
            "suites": [
                "PackageManager",
                "::loadPackage(name)"
            ],
            "updatePoint": {
                "line": 117,
                "column": 63
            },
            "line": 117,
            "code": "    it('returns null if the package has an invalid package.json', () => {\n      spyOn(atom, 'inSpecMode').andReturn(false);\n      const addErrorHandler = jasmine.createSpy();\n      atom.notifications.onDidAddNotification(addErrorHandler);\n      expect(atom.packages.loadPackage('package-with-broken-package-json')).toBeNull();\n      expect(addErrorHandler.callCount).toBe(1);\n      expect(addErrorHandler.argsForCall[0][0].message).toContain('Failed to load the package-with-broken-package-json package');\n      expect(addErrorHandler.argsForCall[0][0].options.packageName).toEqual('package-with-broken-package-json');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null if the package name or path starts with a dot",
            "suites": [
                "PackageManager",
                "::loadPackage(name)"
            ],
            "updatePoint": {
                "line": 126,
                "column": 66
            },
            "line": 126,
            "code": "    it('returns null if the package name or path starts with a dot', () => {\n      expect(atom.packages.loadPackage('/Users/user/.atom/packages/.git')).toBeNull();\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "normalizes short repository urls in package.json",
            "suites": [
                "PackageManager",
                "::loadPackage(name)"
            ],
            "updatePoint": {
                "line": 129,
                "column": 56
            },
            "line": 129,
            "code": "    it('normalizes short repository urls in package.json', () => {\n      let {\n        metadata\n      } = atom.packages.loadPackage('package-with-short-url-package-json');\n      expect(metadata.repository.type).toBe('git');\n      expect(metadata.repository.url).toBe('https://github.com/example/repo');\n      ({\n        metadata\n      } = atom.packages.loadPackage('package-with-invalid-url-package-json'));\n      expect(metadata.repository.type).toBe('git');\n      expect(metadata.repository.url).toBe('foo');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "trims git+ from the beginning and .git from the end of repository URLs, even if npm already normalized them ",
            "suites": [
                "PackageManager",
                "::loadPackage(name)"
            ],
            "updatePoint": {
                "line": 141,
                "column": 116
            },
            "line": 141,
            "code": "    it('trims git+ from the beginning and .git from the end of repository URLs, even if npm already normalized them ', () => {\n      const {\n        metadata\n      } = atom.packages.loadPackage('package-with-prefixed-and-suffixed-repo-url');\n      expect(metadata.repository.type).toBe('git');\n      expect(metadata.repository.url).toBe('https://github.com/example/repo');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null if the package is not found in any package directory",
            "suites": [
                "PackageManager",
                "::loadPackage(name)"
            ],
            "updatePoint": {
                "line": 148,
                "column": 73
            },
            "line": 148,
            "code": "    it('returns null if the package is not found in any package directory', () => {\n      spyOn(console, 'warn');\n      expect(atom.packages.loadPackage('this-package-cannot-be-found')).toBeNull();\n      expect(console.warn.callCount).toBe(1);\n      expect(console.warn.argsForCall[0][0]).toContain('Could not resolve');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null",
            "suites": [
                "PackageManager",
                "::loadPackage(name)",
                "when the package is deprecated"
            ],
            "updatePoint": {
                "line": 155,
                "column": 22
            },
            "line": 155,
            "code": "      it('returns null', () => {\n        spyOn(console, 'warn');\n        expect(atom.packages.loadPackage(path.join(__dirname, 'fixtures', 'packages', 'wordcount'))).toBeNull();\n        expect(atom.packages.isDeprecatedPackage('wordcount', '2.1.9')).toBe(true);\n        expect(atom.packages.isDeprecatedPackage('wordcount', '2.2.0')).toBe(true);\n        expect(atom.packages.isDeprecatedPackage('wordcount', '2.2.1')).toBe(false);\n        expect(atom.packages.getDeprecatedPackageMetadata('wordcount').version).toBe('<=2.2.0');\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidLoadPackage listeners with the loaded package",
            "suites": [
                "PackageManager",
                "::loadPackage(name)",
                "when the package is deprecated"
            ],
            "updatePoint": {
                "line": 164,
                "column": 68
            },
            "line": 164,
            "code": "    it('invokes ::onDidLoadPackage listeners with the loaded package', () => {\n      let loadedPackage = null;\n      atom.packages.onDidLoadPackage(pack => {\n        loadedPackage = pack;\n      });\n      atom.packages.loadPackage('package-with-main');\n      expect(loadedPackage.name).toBe('package-with-main');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "registers any deserializers specified in the package's package.json",
            "suites": [
                "PackageManager",
                "::loadPackage(name)",
                "when the package is deprecated"
            ],
            "updatePoint": {
                "line": 172,
                "column": 75
            },
            "line": 172,
            "code": "    it(\"registers any deserializers specified in the package's package.json\", () => {\n      atom.packages.loadPackage('package-with-deserializers');\n      const state1 = {\n        deserializer: 'Deserializer1',\n        a: 'b'\n      };\n      expect(atom.deserializers.deserialize(state1)).toEqual({\n        wasDeserializedBy: 'deserializeMethod1',\n        state: state1\n      });\n      const state2 = {\n        deserializer: 'Deserializer2',\n        c: 'd'\n      };\n      expect(atom.deserializers.deserialize(state2)).toEqual({\n        wasDeserializedBy: 'deserializeMethod2',\n        state: state2\n      });\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "early-activates any atom.directory-provider or atom.repository-provider services that the package provide",
            "suites": [
                "PackageManager",
                "::loadPackage(name)",
                "when the package is deprecated"
            ],
            "updatePoint": {
                "line": 191,
                "column": 113
            },
            "line": 191,
            "code": "    it('early-activates any atom.directory-provider or atom.repository-provider services that the package provide', () => {\n      jasmine.useRealClock();\n      const providers = [];\n      atom.packages.serviceHub.consume('atom.directory-provider', '^0.1.0', provider => providers.push(provider));\n      atom.packages.loadPackage('package-with-directory-provider');\n      expect(providers.map(p => p.name)).toEqual(['directory provider from package-with-directory-provider']);\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not load the view providers immediately",
            "suites": [
                "PackageManager",
                "::loadPackage(name)",
                "when there are view providers specified in the package's package.json"
            ],
            "updatePoint": {
                "line": 209,
                "column": 54
            },
            "line": 209,
            "code": "      it('does not load the view providers immediately', () => {\n        const pack = atom.packages.loadPackage('package-with-view-providers');\n        expect(pack.mainModule).toBeNull();\n        expect(() => atom.views.getView(model1)).toThrow();\n        expect(() => atom.views.getView(model2)).toThrow();\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "registers the view providers when the package is activated",
            "suites": [
                "PackageManager",
                "::loadPackage(name)",
                "when there are view providers specified in the package's package.json"
            ],
            "updatePoint": {
                "line": 215,
                "column": 68
            },
            "line": 215,
            "code": "      it('registers the view providers when the package is activated', async () => {\n        atom.packages.loadPackage('package-with-view-providers');\n        await atom.packages.activatePackage('package-with-view-providers');\n        const element1 = atom.views.getView(model1);\n        expect(element1 instanceof HTMLDivElement).toBe(true);\n        expect(element1.dataset.createdBy).toBe('view-provider-1');\n        const element2 = atom.views.getView(model2);\n        expect(element2 instanceof HTMLDivElement).toBe(true);\n        expect(element2.dataset.createdBy).toBe('view-provider-2');\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "registers the view providers when any of the package's deserializers are used",
            "suites": [
                "PackageManager",
                "::loadPackage(name)",
                "when there are view providers specified in the package's package.json"
            ],
            "updatePoint": {
                "line": 225,
                "column": 87
            },
            "line": 225,
            "code": "      it(\"registers the view providers when any of the package's deserializers are used\", () => {\n        atom.packages.loadPackage('package-with-view-providers');\n        spyOn(atom.views, 'addViewProvider').andCallThrough();\n        atom.deserializers.deserialize({\n          deserializer: 'DeserializerFromPackageWithViewProviders',\n          a: 'b'\n        });\n        expect(atom.views.addViewProvider.callCount).toBe(2);\n        atom.deserializers.deserialize({\n          deserializer: 'DeserializerFromPackageWithViewProviders',\n          a: 'b'\n        });\n        expect(atom.views.addViewProvider.callCount).toBe(2);\n        const element1 = atom.views.getView(model1);\n        expect(element1 instanceof HTMLDivElement).toBe(true);\n        expect(element1.dataset.createdBy).toBe('view-provider-1');\n        const element2 = atom.views.getView(model2);\n        expect(element2 instanceof HTMLDivElement).toBe(true);\n        expect(element2.dataset.createdBy).toBe('view-provider-2');\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "registers the config schema in the package's metadata, if present",
            "suites": [
                "PackageManager",
                "::loadPackage(name)",
                "when there are view providers specified in the package's package.json"
            ],
            "updatePoint": {
                "line": 246,
                "column": 73
            },
            "line": 246,
            "code": "    it(\"registers the config schema in the package's metadata, if present\", () => {\n      let pack = atom.packages.loadPackage('package-with-json-config-schema');\n      expect(atom.config.getSchema('package-with-json-config-schema')).toEqual({\n        type: 'object',\n        properties: {\n          a: {\n            type: 'number',\n            default: 5\n          },\n          b: {\n            type: 'string',\n            default: 'five'\n          }\n        }\n      });\n      expect(pack.mainModule).toBeNull();\n      atom.packages.unloadPackage('package-with-json-config-schema');\n      atom.config.clear();\n      pack = atom.packages.loadPackage('package-with-json-config-schema');\n      expect(atom.config.getSchema('package-with-json-config-schema')).toEqual({\n        type: 'object',\n        properties: {\n          a: {\n            type: 'number',\n            default: 5\n          },\n          b: {\n            type: 'string',\n            default: 'five'\n          }\n        }\n      });\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "defers loading the package's main module if the package previously used no Atom APIs when its main module was required",
            "suites": [
                "PackageManager",
                "::loadPackage(name)",
                "when a package does not have deserializers, view providers or a config schema in its package.json"
            ],
            "updatePoint": {
                "line": 281,
                "column": 128
            },
            "line": 281,
            "code": "      it(\"defers loading the package's main module if the package previously used no Atom APIs when its main module was required\", () => {\n        const pack1 = atom.packages.loadPackage('package-with-main');\n        expect(pack1.mainModule).toBeDefined();\n        atom.packages.unloadPackage('package-with-main');\n        const pack2 = atom.packages.loadPackage('package-with-main');\n        expect(pack2.mainModule).toBeNull();\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not defer loading the package's main module if the package previously used Atom APIs when its main module was required",
            "suites": [
                "PackageManager",
                "::loadPackage(name)",
                "when a package does not have deserializers, view providers or a config schema in its package.json"
            ],
            "updatePoint": {
                "line": 288,
                "column": 133
            },
            "line": 288,
            "code": "      it(\"does not defer loading the package's main module if the package previously used Atom APIs when its main module was required\", () => {\n        const pack1 = atom.packages.loadPackage('package-with-eval-time-api-calls');\n        expect(pack1.mainModule).toBeDefined();\n        atom.packages.unloadPackage('package-with-eval-time-api-calls');\n        const pack2 = atom.packages.loadPackage('package-with-eval-time-api-calls');\n        expect(pack2.mainModule).not.toBeNull();\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the package path to the module cache",
            "suites": [
                "PackageManager",
                "::loadAvailablePackage(availablePackage)",
                "if the package was preloaded"
            ],
            "updatePoint": {
                "line": 299,
                "column": 51
            },
            "line": 299,
            "code": "      it('adds the package path to the module cache', () => {\n        const availablePackage = atom.packages.getAvailablePackages().find(p => p.name === 'spell-check');\n        availablePackage.isBundled = true;\n        expect(atom.packages.preloadedPackages[availablePackage.name]).toBeUndefined();\n        expect(atom.packages.isPackageLoaded(availablePackage.name)).toBe(false);\n        const metadata = atom.packages.loadPackageMetadata(availablePackage);\n        atom.packages.preloadPackage(availablePackage.name, {\n          rootDirPath: path.relative(atom.packages.resourcePath, availablePackage.path),\n          metadata\n        });\n        atom.packages.loadAvailablePackage(availablePackage);\n        expect(atom.packages.isPackageLoaded(availablePackage.name)).toBe(true);\n        expect(ModuleCache.add).toHaveBeenCalledWith(availablePackage.path, metadata);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deactivates it if it had been disabled",
            "suites": [
                "PackageManager",
                "::loadAvailablePackage(availablePackage)",
                "if the package was preloaded"
            ],
            "updatePoint": {
                "line": 313,
                "column": 48
            },
            "line": 313,
            "code": "      it('deactivates it if it had been disabled', () => {\n        const availablePackage = atom.packages.getAvailablePackages().find(p => p.name === 'spell-check');\n        availablePackage.isBundled = true;\n        expect(atom.packages.preloadedPackages[availablePackage.name]).toBeUndefined();\n        expect(atom.packages.isPackageLoaded(availablePackage.name)).toBe(false);\n        const metadata = atom.packages.loadPackageMetadata(availablePackage);\n        const preloadedPackage = atom.packages.preloadPackage(availablePackage.name, {\n          rootDirPath: path.relative(atom.packages.resourcePath, availablePackage.path),\n          metadata\n        });\n        expect(preloadedPackage.keymapActivated).toBe(true);\n        expect(preloadedPackage.settingsActivated).toBe(true);\n        expect(preloadedPackage.menusActivated).toBe(true);\n        atom.packages.loadAvailablePackage(availablePackage, new Set([availablePackage.name]));\n        expect(atom.packages.isPackageLoaded(availablePackage.name)).toBe(false);\n        expect(preloadedPackage.keymapActivated).toBe(false);\n        expect(preloadedPackage.settingsActivated).toBe(false);\n        expect(preloadedPackage.menusActivated).toBe(false);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deactivates it and reloads the new one if trying to load the same package outside of the bundle",
            "suites": [
                "PackageManager",
                "::loadAvailablePackage(availablePackage)",
                "if the package was preloaded"
            ],
            "updatePoint": {
                "line": 332,
                "column": 105
            },
            "line": 332,
            "code": "      it('deactivates it and reloads the new one if trying to load the same package outside of the bundle', () => {\n        const availablePackage = atom.packages.getAvailablePackages().find(p => p.name === 'spell-check');\n        availablePackage.isBundled = true;\n        expect(atom.packages.preloadedPackages[availablePackage.name]).toBeUndefined();\n        expect(atom.packages.isPackageLoaded(availablePackage.name)).toBe(false);\n        const metadata = atom.packages.loadPackageMetadata(availablePackage);\n        const preloadedPackage = atom.packages.preloadPackage(availablePackage.name, {\n          rootDirPath: path.relative(atom.packages.resourcePath, availablePackage.path),\n          metadata\n        });\n        expect(preloadedPackage.keymapActivated).toBe(true);\n        expect(preloadedPackage.settingsActivated).toBe(true);\n        expect(preloadedPackage.menusActivated).toBe(true);\n        availablePackage.isBundled = false;\n        atom.packages.loadAvailablePackage(availablePackage);\n        expect(atom.packages.isPackageLoaded(availablePackage.name)).toBe(true);\n        expect(preloadedPackage.keymapActivated).toBe(false);\n        expect(preloadedPackage.settingsActivated).toBe(false);\n        expect(preloadedPackage.menusActivated).toBe(false);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the package path to the module cache",
            "suites": [
                "PackageManager",
                "::loadAvailablePackage(availablePackage)",
                "if the package was not preloaded"
            ],
            "updatePoint": {
                "line": 354,
                "column": 51
            },
            "line": 354,
            "code": "      it('adds the package path to the module cache', () => {\n        const availablePackage = atom.packages.getAvailablePackages().find(p => p.name === 'spell-check');\n        availablePackage.isBundled = true;\n        const metadata = atom.packages.loadPackageMetadata(availablePackage);\n        atom.packages.loadAvailablePackage(availablePackage);\n        expect(ModuleCache.add).toHaveBeenCalledWith(availablePackage.path, metadata);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "requires the main module, loads the config schema and activates keymaps, menus and settings without reactivating them during package activation",
            "suites": [
                "PackageManager",
                "preloading"
            ],
            "updatePoint": {
                "line": 364,
                "column": 151
            },
            "line": 364,
            "code": "    it('requires the main module, loads the config schema and activates keymaps, menus and settings without reactivating them during package activation', () => {\n      const availablePackage = atom.packages.getAvailablePackages().find(p => p.name === 'spell-check');\n      availablePackage.isBundled = true;\n      const metadata = atom.packages.loadPackageMetadata(availablePackage);\n      expect(atom.packages.preloadedPackages[availablePackage.name]).toBeUndefined();\n      expect(atom.packages.isPackageLoaded(availablePackage.name)).toBe(false);\n      atom.packages.packagesCache = {};\n      atom.packages.packagesCache[availablePackage.name] = {\n        main: path.join(availablePackage.path, metadata.main),\n        grammarPaths: []\n      };\n      const preloadedPackage = atom.packages.preloadPackage(availablePackage.name, {\n        rootDirPath: path.relative(atom.packages.resourcePath, availablePackage.path),\n        metadata\n      });\n      expect(preloadedPackage.keymapActivated).toBe(true);\n      expect(preloadedPackage.settingsActivated).toBe(true);\n      expect(preloadedPackage.menusActivated).toBe(true);\n      expect(preloadedPackage.mainModule).toBeTruthy();\n      expect(preloadedPackage.configSchemaRegisteredOnLoad).toBeTruthy();\n      spyOn(atom.keymaps, 'add');\n      spyOn(atom.menu, 'add');\n      spyOn(atom.contextMenu, 'add');\n      spyOn(atom.config, 'setSchema');\n      atom.packages.loadAvailablePackage(availablePackage);\n      expect(preloadedPackage.getMainModulePath()).toBe(path.join(availablePackage.path, metadata.main));\n      atom.packages.activatePackage(availablePackage.name);\n      expect(atom.keymaps.add).not.toHaveBeenCalled();\n      expect(atom.menu.add).not.toHaveBeenCalled();\n      expect(atom.contextMenu.add).not.toHaveBeenCalled();\n      expect(atom.config.setSchema).not.toHaveBeenCalled();\n      expect(preloadedPackage.keymapActivated).toBe(true);\n      expect(preloadedPackage.settingsActivated).toBe(true);\n      expect(preloadedPackage.menusActivated).toBe(true);\n      expect(preloadedPackage.mainModule).toBeTruthy();\n      expect(preloadedPackage.configSchemaRegisteredOnLoad).toBeTruthy();\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deactivates disabled keymaps during package activation",
            "suites": [
                "PackageManager",
                "preloading"
            ],
            "updatePoint": {
                "line": 401,
                "column": 62
            },
            "line": 401,
            "code": "    it('deactivates disabled keymaps during package activation', () => {\n      const availablePackage = atom.packages.getAvailablePackages().find(p => p.name === 'spell-check');\n      availablePackage.isBundled = true;\n      const metadata = atom.packages.loadPackageMetadata(availablePackage);\n      expect(atom.packages.preloadedPackages[availablePackage.name]).toBeUndefined();\n      expect(atom.packages.isPackageLoaded(availablePackage.name)).toBe(false);\n      atom.packages.packagesCache = {};\n      atom.packages.packagesCache[availablePackage.name] = {\n        main: path.join(availablePackage.path, metadata.main),\n        grammarPaths: []\n      };\n      const preloadedPackage = atom.packages.preloadPackage(availablePackage.name, {\n        rootDirPath: path.relative(atom.packages.resourcePath, availablePackage.path),\n        metadata\n      });\n      expect(preloadedPackage.keymapActivated).toBe(true);\n      expect(preloadedPackage.settingsActivated).toBe(true);\n      expect(preloadedPackage.menusActivated).toBe(true);\n      atom.packages.loadAvailablePackage(availablePackage);\n      atom.config.set('core.packagesWithKeymapsDisabled', [availablePackage.name]);\n      atom.packages.activatePackage(availablePackage.name);\n      expect(preloadedPackage.keymapActivated).toBe(false);\n      expect(preloadedPackage.settingsActivated).toBe(true);\n      expect(preloadedPackage.menusActivated).toBe(true);\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error",
            "suites": [
                "PackageManager",
                "::unloadPackage(name)",
                "when the package is active"
            ],
            "updatePoint": {
                "line": 429,
                "column": 25
            },
            "line": 429,
            "code": "      it('throws an error', async () => {\n        const pack = await atom.packages.activatePackage('package-with-main');\n        expect(atom.packages.isPackageLoaded(pack.name)).toBeTruthy();\n        expect(atom.packages.isPackageActive(pack.name)).toBeTruthy();\n        expect(() => atom.packages.unloadPackage(pack.name)).toThrow();\n        expect(atom.packages.isPackageLoaded(pack.name)).toBeTruthy();\n        expect(atom.packages.isPackageActive(pack.name)).toBeTruthy();\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error",
            "suites": [
                "PackageManager",
                "::unloadPackage(name)",
                "when the package is not loaded"
            ],
            "updatePoint": {
                "line": 439,
                "column": 25
            },
            "line": 439,
            "code": "      it('throws an error', () => {\n        expect(atom.packages.isPackageLoaded('unloaded')).toBeFalsy();\n        expect(() => atom.packages.unloadPackage('unloaded')).toThrow();\n        expect(atom.packages.isPackageLoaded('unloaded')).toBeFalsy();\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "no longers reports it as being loaded",
            "suites": [
                "PackageManager",
                "::unloadPackage(name)",
                "when the package is loaded"
            ],
            "updatePoint": {
                "line": 446,
                "column": 47
            },
            "line": 446,
            "code": "      it('no longers reports it as being loaded', () => {\n        const pack = atom.packages.loadPackage('package-with-main');\n        expect(atom.packages.isPackageLoaded(pack.name)).toBeTruthy();\n        atom.packages.unloadPackage(pack.name);\n        expect(atom.packages.isPackageLoaded(pack.name)).toBeFalsy();\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidUnloadPackage listeners with the unloaded package",
            "suites": [
                "PackageManager",
                "::unloadPackage(name)",
                "when the package is loaded"
            ],
            "updatePoint": {
                "line": 453,
                "column": 72
            },
            "line": 453,
            "code": "    it('invokes ::onDidUnloadPackage listeners with the unloaded package', () => {\n      atom.packages.loadPackage('package-with-main');\n      let unloadedPackage;\n      atom.packages.onDidUnloadPackage(pack => {\n        unloadedPackage = pack;\n      });\n      atom.packages.unloadPackage('package-with-main');\n      expect(unloadedPackage.name).toBe('package-with-main');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "it only calls activate on the package once",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when called multiple times"
            ],
            "updatePoint": {
                "line": 465,
                "column": 52
            },
            "line": 465,
            "code": "      it('it only calls activate on the package once', async () => {\n        spyOn(Package.prototype, 'activateNow').andCallThrough();\n        await atom.packages.activatePackage('package-with-index');\n        await atom.packages.activatePackage('package-with-index');\n        await atom.packages.activatePackage('package-with-index');\n        expect(Package.prototype.activateNow.callCount).toBe(1);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "requires the module at the specified path",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the metadata specifies a main module path˜"
            ],
            "updatePoint": {
                "line": 478,
                "column": 53
            },
            "line": 478,
            "code": "        it('requires the module at the specified path', async () => {\n          const mainModule = require('./fixtures/packages/package-with-main/main-module');\n\n          spyOn(mainModule, 'activate');\n          const pack = await atom.packages.activatePackage('package-with-main');\n          expect(mainModule.activate).toHaveBeenCalled();\n          expect(pack.mainModule).toBe(mainModule);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "requires index.coffee",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the metadata does not specify a main module"
            ],
            "updatePoint": {
                "line": 488,
                "column": 33
            },
            "line": 488,
            "code": "        it('requires index.coffee', async () => {\n          const indexModule = require('./fixtures/packages/package-with-index/index');\n\n          spyOn(indexModule, 'activate');\n          const pack = await atom.packages.activatePackage('package-with-index');\n          expect(indexModule.activate).toHaveBeenCalled();\n          expect(pack.mainModule).toBe(indexModule);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "assigns config schema, including defaults when package contains a schema",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the metadata does not specify a main module"
            ],
            "updatePoint": {
                "line": 497,
                "column": 82
            },
            "line": 497,
            "code": "      it('assigns config schema, including defaults when package contains a schema', async () => {\n        expect(atom.config.get('package-with-config-schema.numbers.one')).toBeUndefined();\n        await atom.packages.activatePackage('package-with-config-schema');\n        expect(atom.config.get('package-with-config-schema.numbers.one')).toBe(1);\n        expect(atom.config.get('package-with-config-schema.numbers.two')).toBe(2);\n        expect(atom.config.set('package-with-config-schema.numbers.one', 'nope')).toBe(false);\n        expect(atom.config.set('package-with-config-schema.numbers.one', '10')).toBe(true);\n        expect(atom.config.get('package-with-config-schema.numbers.one')).toBe(10);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "defers requiring/activating the main module until an activation event bubbles to the root view",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `activationCommands`"
            ],
            "updatePoint": {
                "line": 524,
                "column": 106
            },
            "line": 524,
            "code": "        it('defers requiring/activating the main module until an activation event bubbles to the root view', async () => {\n          expect(Package.prototype.requireMainModule.callCount).toBe(0);\n          atom.workspace.getElement().dispatchEvent(new CustomEvent('activation-command', {\n            bubbles: true\n          }));\n          await promise;\n          expect(Package.prototype.requireMainModule.callCount).toBe(1);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "triggers the activation event on all handlers registered during activation",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `activationCommands`"
            ],
            "updatePoint": {
                "line": 532,
                "column": 86
            },
            "line": 532,
            "code": "        it('triggers the activation event on all handlers registered during activation', async () => {\n          await atom.workspace.open();\n          const editorElement = atom.workspace.getActiveTextEditor().getElement();\n          const editorCommandListener = jasmine.createSpy('editorCommandListener');\n          atom.commands.add('atom-text-editor', 'activation-command', editorCommandListener);\n          atom.commands.dispatch(editorElement, 'activation-command');\n          expect(mainModule.activate.callCount).toBe(1);\n          expect(mainModule.activationCommandCallCount).toBe(1);\n          expect(editorCommandListener.callCount).toBe(1);\n          expect(workspaceCommandListener.callCount).toBe(1);\n          atom.commands.dispatch(editorElement, 'activation-command');\n          expect(mainModule.activationCommandCallCount).toBe(2);\n          expect(editorCommandListener.callCount).toBe(2);\n          expect(workspaceCommandListener.callCount).toBe(2);\n          expect(mainModule.activate.callCount).toBe(1);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the package immediately when the events are empty",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `activationCommands`"
            ],
            "updatePoint": {
                "line": 548,
                "column": 71
            },
            "line": 548,
            "code": "        it('activates the package immediately when the events are empty', async () => {\n          mainModule = require('./fixtures/packages/package-with-empty-activation-commands/index');\n          spyOn(mainModule, 'activate').andCallThrough();\n          atom.packages.activatePackage('package-with-empty-activation-commands');\n          expect(mainModule.activate.callCount).toBe(1);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a notification when the activation commands are invalid",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `activationCommands`"
            ],
            "updatePoint": {
                "line": 554,
                "column": 72
            },
            "line": 554,
            "code": "        it('adds a notification when the activation commands are invalid', () => {\n          spyOn(atom, 'inSpecMode').andReturn(false);\n          const addErrorHandler = jasmine.createSpy();\n          atom.notifications.onDidAddNotification(addErrorHandler);\n          expect(() => atom.packages.activatePackage('package-with-invalid-activation-commands')).not.toThrow();\n          expect(addErrorHandler.callCount).toBe(1);\n          expect(addErrorHandler.argsForCall[0][0].message).toContain('Failed to activate the package-with-invalid-activation-commands package');\n          expect(addErrorHandler.argsForCall[0][0].options.packageName).toEqual('package-with-invalid-activation-commands');\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a notification when the context menu is invalid",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `activationCommands`"
            ],
            "updatePoint": {
                "line": 563,
                "column": 64
            },
            "line": 563,
            "code": "        it('adds a notification when the context menu is invalid', () => {\n          spyOn(atom, 'inSpecMode').andReturn(false);\n          const addErrorHandler = jasmine.createSpy();\n          atom.notifications.onDidAddNotification(addErrorHandler);\n          expect(() => atom.packages.activatePackage('package-with-invalid-context-menu')).not.toThrow();\n          expect(addErrorHandler.callCount).toBe(1);\n          expect(addErrorHandler.argsForCall[0][0].message).toContain('Failed to activate the package-with-invalid-context-menu package');\n          expect(addErrorHandler.argsForCall[0][0].options.packageName).toEqual('package-with-invalid-context-menu');\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a notification when the grammar is invalid",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `activationCommands`"
            ],
            "updatePoint": {
                "line": 572,
                "column": 59
            },
            "line": 572,
            "code": "        it('adds a notification when the grammar is invalid', async () => {\n          let notificationEvent;\n          await new Promise(resolve => {\n            const subscription = atom.notifications.onDidAddNotification(event => {\n              notificationEvent = event;\n              subscription.dispose();\n              resolve();\n            });\n            atom.packages.activatePackage('package-with-invalid-grammar');\n          });\n          expect(notificationEvent.message).toContain('Failed to load a package-with-invalid-grammar package grammar');\n          expect(notificationEvent.options.packageName).toEqual('package-with-invalid-grammar');\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a notification when the settings are invalid",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `activationCommands`"
            ],
            "updatePoint": {
                "line": 585,
                "column": 61
            },
            "line": 585,
            "code": "        it('adds a notification when the settings are invalid', async () => {\n          let notificationEvent;\n          await new Promise(resolve => {\n            const subscription = atom.notifications.onDidAddNotification(event => {\n              notificationEvent = event;\n              subscription.dispose();\n              resolve();\n            });\n            atom.packages.activatePackage('package-with-invalid-settings');\n          });\n          expect(notificationEvent.message).toContain('Failed to load the package-with-invalid-settings package settings');\n          expect(notificationEvent.options.packageName).toEqual('package-with-invalid-settings');\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the package when a deserializer is called",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes both activation commands and deserializers"
            ],
            "updatePoint": {
                "line": 618,
                "column": 63
            },
            "line": 618,
            "code": "        it('activates the package when a deserializer is called', async () => {\n          expect(Package.prototype.requireMainModule.callCount).toBe(0);\n          const state1 = {\n            deserializer: 'Deserializer1',\n            a: 'b'\n          };\n          expect(atom.deserializers.deserialize(state1, atom)).toEqual({\n            wasDeserializedBy: 'deserializeMethod1',\n            state: state1\n          });\n          await promise;\n          expect(Package.prototype.requireMainModule.callCount).toBe(1);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "defers requiring/activating the main module until an activation event bubbles to the root view",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes both activation commands and deserializers"
            ],
            "updatePoint": {
                "line": 631,
                "column": 106
            },
            "line": 631,
            "code": "        it('defers requiring/activating the main module until an activation event bubbles to the root view', async () => {\n          expect(Package.prototype.requireMainModule.callCount).toBe(0);\n          atom.workspace.getElement().dispatchEvent(new CustomEvent('activation-command-2', {\n            bubbles: true\n          }));\n          await promise;\n          expect(mainModule.activate.callCount).toBe(1);\n          expect(mainModule.activationCommandCallCount).toBe(1);\n          expect(Package.prototype.requireMainModule.callCount).toBe(1);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "defers requiring/activating the main module until an triggering of an activation hook occurs",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `activationHooks`"
            ],
            "updatePoint": {
                "line": 648,
                "column": 104
            },
            "line": 648,
            "code": "        it('defers requiring/activating the main module until an triggering of an activation hook occurs', async () => {\n          promise = atom.packages.activatePackage('package-with-activation-hooks');\n          expect(Package.prototype.requireMainModule.callCount).toBe(0);\n          atom.packages.triggerActivationHook('language-fictitious:grammar-used');\n          atom.packages.triggerDeferredActivationHooks();\n          await promise;\n          expect(Package.prototype.requireMainModule.callCount).toBe(1);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not double register activation hooks when deactivating and reactivating",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `activationHooks`"
            ],
            "updatePoint": {
                "line": 656,
                "column": 88
            },
            "line": 656,
            "code": "        it('does not double register activation hooks when deactivating and reactivating', async () => {\n          promise = atom.packages.activatePackage('package-with-activation-hooks');\n          expect(mainModule.activate.callCount).toBe(0);\n          atom.packages.triggerActivationHook('language-fictitious:grammar-used');\n          atom.packages.triggerDeferredActivationHooks();\n          await promise;\n          expect(mainModule.activate.callCount).toBe(1);\n          await atom.packages.deactivatePackage('package-with-activation-hooks');\n          promise = atom.packages.activatePackage('package-with-activation-hooks');\n          atom.packages.triggerActivationHook('language-fictitious:grammar-used');\n          atom.packages.triggerDeferredActivationHooks();\n          await promise;\n          expect(mainModule.activate.callCount).toBe(2);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the package immediately when activationHooks is empty",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `activationHooks`"
            ],
            "updatePoint": {
                "line": 670,
                "column": 75
            },
            "line": 670,
            "code": "        it('activates the package immediately when activationHooks is empty', async () => {\n          mainModule = require('./fixtures/packages/package-with-empty-activation-hooks/index');\n          spyOn(mainModule, 'activate').andCallThrough();\n          expect(Package.prototype.requireMainModule.callCount).toBe(0);\n          await atom.packages.activatePackage('package-with-empty-activation-hooks');\n          expect(mainModule.activate.callCount).toBe(1);\n          expect(Package.prototype.requireMainModule.callCount).toBe(1);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the package immediately if the activation hook had already been triggered",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `activationHooks`"
            ],
            "updatePoint": {
                "line": 678,
                "column": 95
            },
            "line": 678,
            "code": "        it('activates the package immediately if the activation hook had already been triggered', async () => {\n          atom.packages.triggerActivationHook('language-fictitious:grammar-used');\n          atom.packages.triggerDeferredActivationHooks();\n          expect(Package.prototype.requireMainModule.callCount).toBe(0);\n          await atom.packages.activatePackage('package-with-activation-hooks');\n          expect(mainModule.activate.callCount).toBe(1);\n          expect(Package.prototype.requireMainModule.callCount).toBe(1);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "defers requiring/activating the main module until a registered opener is called",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `workspaceOpeners`"
            ],
            "updatePoint": {
                "line": 693,
                "column": 91
            },
            "line": 693,
            "code": "        it('defers requiring/activating the main module until a registered opener is called', async () => {\n          promise = atom.packages.activatePackage('package-with-workspace-openers');\n          expect(Package.prototype.requireMainModule.callCount).toBe(0);\n          atom.workspace.open('atom://fictitious');\n          await promise;\n          expect(Package.prototype.requireMainModule.callCount).toBe(1);\n          expect(mainModule.openerCount).toBe(1);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the package immediately when the events are empty",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has a main module",
                "when the package metadata includes `workspaceOpeners`"
            ],
            "updatePoint": {
                "line": 701,
                "column": 71
            },
            "line": 701,
            "code": "        it('activates the package immediately when the events are empty', async () => {\n          mainModule = require('./fixtures/packages/package-with-empty-workspace-openers/index');\n          spyOn(mainModule, 'activate').andCallThrough();\n          atom.packages.activatePackage('package-with-empty-workspace-openers');\n          expect(mainModule.activate.callCount).toBe(1);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw an exception",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package has no main module"
            ],
            "updatePoint": {
                "line": 710,
                "column": 37
            },
            "line": 710,
            "code": "      it('does not throw an exception', () => {\n        spyOn(console, 'error');\n        spyOn(console, 'warn').andCallThrough();\n        expect(() => atom.packages.activatePackage('package-without-module')).not.toThrow();\n        expect(console.error).not.toHaveBeenCalled();\n        expect(console.warn).not.toHaveBeenCalled();\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the package and does not throw an exception or log a warning",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package does not export an activate function"
            ],
            "updatePoint": {
                "line": 719,
                "column": 80
            },
            "line": 719,
            "code": "      it('activates the package and does not throw an exception or log a warning', async () => {\n        spyOn(console, 'warn');\n        await atom.packages.activatePackage('package-with-no-activate');\n        expect(console.warn).not.toHaveBeenCalled();\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "passes the activate method the package's previously serialized state if it exists",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package does not export an activate function"
            ],
            "updatePoint": {
                "line": 725,
                "column": 89
            },
            "line": 725,
            "code": "    it(\"passes the activate method the package's previously serialized state if it exists\", async () => {\n      const pack = await atom.packages.activatePackage('package-with-serialization');\n      expect(pack.mainModule.someNumber).not.toBe(77);\n      pack.mainModule.someNumber = 77;\n      atom.packages.serializePackage('package-with-serialization');\n      await atom.packages.deactivatePackage('package-with-serialization');\n      spyOn(pack.mainModule, 'activate').andCallThrough();\n      await atom.packages.activatePackage('package-with-serialization');\n      expect(pack.mainModule.activate).toHaveBeenCalledWith({\n        someNumber: 77\n      });\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidActivatePackage listeners with the activated package",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package does not export an activate function"
            ],
            "updatePoint": {
                "line": 737,
                "column": 75
            },
            "line": 737,
            "code": "    it('invokes ::onDidActivatePackage listeners with the activated package', async () => {\n      let activatedPackage;\n      atom.packages.onDidActivatePackage(pack => {\n        activatedPackage = pack;\n      });\n      await atom.packages.activatePackage('package-with-main');\n      expect(activatedPackage.name).toBe('package-with-main');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a notification instead of throwing an exception",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package's main module throws an error on load"
            ],
            "updatePoint": {
                "line": 746,
                "column": 62
            },
            "line": 746,
            "code": "      it('adds a notification instead of throwing an exception', () => {\n        spyOn(atom, 'inSpecMode').andReturn(false);\n        atom.config.set('core.disabledPackages', []);\n        const addErrorHandler = jasmine.createSpy();\n        atom.notifications.onDidAddNotification(addErrorHandler);\n        expect(() => atom.packages.activatePackage('package-that-throws-an-exception')).not.toThrow();\n        expect(addErrorHandler.callCount).toBe(1);\n        expect(addErrorHandler.argsForCall[0][0].message).toContain('Failed to load the package-that-throws-an-exception package');\n        expect(addErrorHandler.argsForCall[0][0].options.packageName).toEqual('package-that-throws-an-exception');\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "re-throws the exception in test mode",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package's main module throws an error on load"
            ],
            "updatePoint": {
                "line": 756,
                "column": 46
            },
            "line": 756,
            "code": "      it('re-throws the exception in test mode', () => {\n        atom.config.set('core.disabledPackages', []);\n        expect(() => atom.packages.activatePackage('package-that-throws-an-exception')).toThrow('This package throws an exception');\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "rejects the promise",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "when the package is not found"
            ],
            "updatePoint": {
                "line": 762,
                "column": 29
            },
            "line": 762,
            "code": "      it('rejects the promise', async () => {\n        spyOn(console, 'warn');\n        atom.config.set('core.disabledPackages', []);\n\n        try {\n          await atom.packages.activatePackage('this-doesnt-exist');\n          expect('Error to be thrown').toBe('');\n        } catch (error) {\n          expect(console.warn.callCount).toBe(1);\n          expect(error.message).toContain(\"Failed to load package 'this-doesnt-exist'\");\n        }\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads all the .cson/.json files in the keymaps directory",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "keymap loading",
                "when the metadata does not contain a 'keymaps' manifest"
            ],
            "updatePoint": {
                "line": 777,
                "column": 68
            },
            "line": 777,
            "code": "        it('loads all the .cson/.json files in the keymaps directory', async () => {\n          const element1 = createTestElement('test-1');\n          const element2 = createTestElement('test-2');\n          const element3 = createTestElement('test-3');\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element1\n          })).toHaveLength(0);\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element2\n          })).toHaveLength(0);\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element3\n          })).toHaveLength(0);\n          await atom.packages.activatePackage('package-with-keymaps');\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element1\n          })[0].command).toBe('test-1');\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element2\n          })[0].command).toBe('test-2');\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element3\n          })).toHaveLength(0);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads only the keymaps specified by the manifest, in the specified order",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "keymap loading",
                "when the metadata contains a 'keymaps' manifest"
            ],
            "updatePoint": {
                "line": 809,
                "column": 84
            },
            "line": 809,
            "code": "        it('loads only the keymaps specified by the manifest, in the specified order', async () => {\n          const element1 = createTestElement('test-1');\n          const element3 = createTestElement('test-3');\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element1\n          })).toHaveLength(0);\n          await atom.packages.activatePackage('package-with-keymaps-manifest');\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element1\n          })[0].command).toBe('keymap-1');\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-n',\n            target: element1\n          })[0].command).toBe('keymap-2');\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-y',\n            target: element3\n          })).toHaveLength(0);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw an error on activation",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "keymap loading",
                "when the keymap file is empty"
            ],
            "updatePoint": {
                "line": 832,
                "column": 49
            },
            "line": 832,
            "code": "        it('does not throw an error on activation', async () => {\n          await atom.packages.activatePackage('package-with-empty-keymap');\n          expect(atom.packages.isPackageActive('package-with-empty-keymap')).toBe(true);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not add the keymaps",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "keymap loading",
                "when the package's keymaps have been disabled"
            ],
            "updatePoint": {
                "line": 838,
                "column": 36
            },
            "line": 838,
            "code": "        it('does not add the keymaps', async () => {\n          const element1 = createTestElement('test-1');\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element1\n          })).toHaveLength(0);\n          atom.config.set('core.packagesWithKeymapsDisabled', ['package-with-keymaps-manifest']);\n          await atom.packages.activatePackage('package-with-keymaps-manifest');\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element1\n          })).toHaveLength(0);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores package names in the array that aren't loaded",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "keymap loading",
                "when setting core.packagesWithKeymapsDisabled"
            ],
            "updatePoint": {
                "line": 853,
                "column": 65
            },
            "line": 853,
            "code": "        it(\"ignores package names in the array that aren't loaded\", () => {\n          atom.packages.observePackagesWithKeymapsDisabled();\n          expect(() => atom.config.set('core.packagesWithKeymapsDisabled', ['package-does-not-exist'])).not.toThrow();\n          expect(() => atom.config.set('core.packagesWithKeymapsDisabled', [])).not.toThrow();\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes and re-adds the keymaps",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "keymap loading",
                "when the package's keymaps are disabled and re-enabled after it is activated"
            ],
            "updatePoint": {
                "line": 860,
                "column": 43
            },
            "line": 860,
            "code": "        it('removes and re-adds the keymaps', async () => {\n          const element1 = createTestElement('test-1');\n          atom.packages.observePackagesWithKeymapsDisabled();\n          await atom.packages.activatePackage('package-with-keymaps-manifest');\n          atom.config.set('core.packagesWithKeymapsDisabled', ['package-with-keymaps-manifest']);\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element1\n          })).toHaveLength(0);\n          atom.config.set('core.packagesWithKeymapsDisabled', []);\n          expect(atom.keymaps.findKeyBindings({\n            keystrokes: 'ctrl-z',\n            target: element1\n          })[0].command).toBe('keymap-1');\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't override user-defined keymaps",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "keymap loading",
                "when the package is de-activated and re-activated"
            ],
            "updatePoint": {
                "line": 894,
                "column": 49
            },
            "line": 894,
            "code": "        it(\"doesn't override user-defined keymaps\", async () => {\n          fs.writeFileSync(userKeymapPath, `\".test-1\": {\"ctrl-z\": \"user-command\"}`);\n          atom.keymaps.loadUserKeymap();\n          await atom.packages.activatePackage('package-with-keymaps');\n          atom.keymaps.handleKeyboardEvent(buildKeydownEvent('z', {\n            ctrl: true,\n            target: element\n          }));\n          expect(events.length).toBe(1);\n          expect(events[0].type).toBe('user-command');\n          await atom.packages.deactivatePackage('package-with-keymaps');\n          await atom.packages.activatePackage('package-with-keymaps');\n          atom.keymaps.handleKeyboardEvent(buildKeydownEvent('z', {\n            ctrl: true,\n            target: element\n          }));\n          expect(events.length).toBe(2);\n          expect(events[1].type).toBe('user-command');\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads all the .cson/.json files in the menus directory",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "menu loading",
                "when the metadata does not contain a 'menus' manifest"
            ],
            "updatePoint": {
                "line": 921,
                "column": 66
            },
            "line": 921,
            "code": "        it('loads all the .cson/.json files in the menus directory', async () => {\n          const element = createTestElement('test-1');\n          expect(atom.contextMenu.templateForElement(element)).toEqual([]);\n          await atom.packages.activatePackage('package-with-menus');\n          expect(atom.menu.template.length).toBe(2);\n          expect(atom.menu.template[0].label).toBe('Second to Last');\n          expect(atom.menu.template[1].label).toBe('Last');\n          expect(atom.contextMenu.templateForElement(element)[0].label).toBe('Menu item 1');\n          expect(atom.contextMenu.templateForElement(element)[1].label).toBe('Menu item 2');\n          expect(atom.contextMenu.templateForElement(element)[2].label).toBe('Menu item 3');\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads only the menus specified by the manifest, in the specified order",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "menu loading",
                "when the metadata contains a 'menus' manifest"
            ],
            "updatePoint": {
                "line": 934,
                "column": 82
            },
            "line": 934,
            "code": "        it('loads only the menus specified by the manifest, in the specified order', async () => {\n          const element = createTestElement('test-1');\n          expect(atom.contextMenu.templateForElement(element)).toEqual([]);\n          await atom.packages.activatePackage('package-with-menus-manifest');\n          expect(atom.menu.template[0].label).toBe('Second to Last');\n          expect(atom.menu.template[1].label).toBe('Last');\n          expect(atom.contextMenu.templateForElement(element)[0].label).toBe('Menu item 2');\n          expect(atom.contextMenu.templateForElement(element)[1].label).toBe('Menu item 1');\n          expect(atom.contextMenu.templateForElement(element)[2]).toBeUndefined();\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw an error on activation",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "menu loading",
                "when the menu file is empty"
            ],
            "updatePoint": {
                "line": 946,
                "column": 49
            },
            "line": 946,
            "code": "        it('does not throw an error on activation', async () => {\n          await atom.packages.activatePackage('package-with-empty-menu');\n          expect(atom.packages.isPackageActive('package-with-empty-menu')).toBe(true);\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads style sheets from the styles directory as specified by the manifest",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "stylesheet loading",
                "when the metadata contains a 'styleSheets' manifest"
            ],
            "updatePoint": {
                "line": 954,
                "column": 85
            },
            "line": 954,
            "code": "        it('loads style sheets from the styles directory as specified by the manifest', async () => {\n          const one = require.resolve('./fixtures/packages/package-with-style-sheets-manifest/styles/1.css');\n\n          const two = require.resolve('./fixtures/packages/package-with-style-sheets-manifest/styles/2.less');\n\n          const three = require.resolve('./fixtures/packages/package-with-style-sheets-manifest/styles/3.css');\n\n          expect(atom.themes.stylesheetElementForId(one)).toBeNull();\n          expect(atom.themes.stylesheetElementForId(two)).toBeNull();\n          expect(atom.themes.stylesheetElementForId(three)).toBeNull();\n          await atom.packages.activatePackage('package-with-style-sheets-manifest');\n          expect(atom.themes.stylesheetElementForId(one)).not.toBeNull();\n          expect(atom.themes.stylesheetElementForId(two)).not.toBeNull();\n          expect(atom.themes.stylesheetElementForId(three)).toBeNull();\n          expect(getComputedStyle(document.querySelector('#jasmine-content')).fontSize).toBe('1px');\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads all style sheets from the styles directory",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "stylesheet loading",
                "when the metadata does not contain a 'styleSheets' manifest"
            ],
            "updatePoint": {
                "line": 972,
                "column": 60
            },
            "line": 972,
            "code": "        it('loads all style sheets from the styles directory', async () => {\n          const one = require.resolve('./fixtures/packages/package-with-styles/styles/1.css');\n\n          const two = require.resolve('./fixtures/packages/package-with-styles/styles/2.less');\n\n          const three = require.resolve('./fixtures/packages/package-with-styles/styles/3.test-context.css');\n\n          const four = require.resolve('./fixtures/packages/package-with-styles/styles/4.css');\n\n          expect(atom.themes.stylesheetElementForId(one)).toBeNull();\n          expect(atom.themes.stylesheetElementForId(two)).toBeNull();\n          expect(atom.themes.stylesheetElementForId(three)).toBeNull();\n          expect(atom.themes.stylesheetElementForId(four)).toBeNull();\n          await atom.packages.activatePackage('package-with-styles');\n          expect(atom.themes.stylesheetElementForId(one)).not.toBeNull();\n          expect(atom.themes.stylesheetElementForId(two)).not.toBeNull();\n          expect(atom.themes.stylesheetElementForId(three)).not.toBeNull();\n          expect(atom.themes.stylesheetElementForId(four)).not.toBeNull();\n          expect(getComputedStyle(document.querySelector('#jasmine-content')).fontSize).toBe('3px');\n        });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "assigns the stylesheet's context based on the filename",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "stylesheet loading",
                "when the metadata does not contain a 'styleSheets' manifest"
            ],
            "updatePoint": {
                "line": 993,
                "column": 64
            },
            "line": 993,
            "code": "      it(\"assigns the stylesheet's context based on the filename\", async () => {\n        await atom.packages.activatePackage('package-with-styles');\n        let count = 0;\n\n        for (let styleElement of atom.styles.getStyleElements()) {\n          if (styleElement.sourcePath.match(/1.css/)) {\n            expect(styleElement.context).toBe(undefined);\n            count++;\n          }\n\n          if (styleElement.sourcePath.match(/2.less/)) {\n            expect(styleElement.context).toBe(undefined);\n            count++;\n          }\n\n          if (styleElement.sourcePath.match(/3.test-context.css/)) {\n            expect(styleElement.context).toBe('test-context');\n            count++;\n          }\n\n          if (styleElement.sourcePath.match(/4.css/)) {\n            expect(styleElement.context).toBe(undefined);\n            count++;\n          }\n        }\n\n        expect(count).toBe(4);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads the package's grammars",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "grammar loading"
            ],
            "updatePoint": {
                "line": 1023,
                "column": 38
            },
            "line": 1023,
            "code": "      it(\"loads the package's grammars\", async () => {\n        await atom.packages.activatePackage('package-with-grammars');\n        expect(atom.grammars.selectGrammar('a.alot').name).toBe('Alot');\n        expect(atom.grammars.selectGrammar('a.alittle').name).toBe('Alittle');\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads any tree-sitter grammars defined in the package",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "grammar loading"
            ],
            "updatePoint": {
                "line": 1028,
                "column": 63
            },
            "line": 1028,
            "code": "      it('loads any tree-sitter grammars defined in the package', async () => {\n        atom.config.set('core.useTreeSitterParsers', true);\n        await atom.packages.activatePackage('package-with-tree-sitter-grammar');\n        const grammar = atom.grammars.selectGrammar('test.somelang');\n        expect(grammar.name).toBe('Some Language');\n        expect(grammar.languageModule.isFakeTreeSitterParser).toBe(true);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads the scoped properties",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "scoped-property loading"
            ],
            "updatePoint": {
                "line": 1037,
                "column": 37
            },
            "line": 1037,
            "code": "      it('loads the scoped properties', async () => {\n        await atom.packages.activatePackage('package-with-settings');\n        expect(atom.config.get('editor.increaseIndentPattern', {\n          scope: ['.source.omg']\n        })).toBe('^a');\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "registers the package's specified URI handler",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "URI handler registration"
            ],
            "updatePoint": {
                "line": 1045,
                "column": 55
            },
            "line": 1045,
            "code": "      it(\"registers the package's specified URI handler\", async () => {\n        const uri = 'atom://package-with-uri-handler/some/url?with=args';\n\n        const mod = require('./fixtures/packages/package-with-uri-handler');\n\n        spyOn(mod, 'handleURI');\n        spyOn(atom.packages, 'hasLoadedInitialPackages').andReturn(true);\n        const activationPromise = atom.packages.activatePackage('package-with-uri-handler');\n        atom.dispatchURIMessage(uri);\n        await activationPromise;\n        expect(mod.handleURI).toHaveBeenCalledWith(url.parse(uri, true), uri);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "registers the package's provided and consumed services",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "service registration"
            ],
            "updatePoint": {
                "line": 1059,
                "column": 64
            },
            "line": 1059,
            "code": "      it(\"registers the package's provided and consumed services\", async () => {\n        const consumerModule = require('./fixtures/packages/package-with-consumed-services');\n\n        let firstServiceV3Disposed = false;\n        let firstServiceV4Disposed = false;\n        let secondServiceDisposed = false;\n        spyOn(consumerModule, 'consumeFirstServiceV3').andReturn(new Disposable(() => {\n          firstServiceV3Disposed = true;\n        }));\n        spyOn(consumerModule, 'consumeFirstServiceV4').andReturn(new Disposable(() => {\n          firstServiceV4Disposed = true;\n        }));\n        spyOn(consumerModule, 'consumeSecondService').andReturn(new Disposable(() => {\n          secondServiceDisposed = true;\n        }));\n        await atom.packages.activatePackage('package-with-consumed-services');\n        await atom.packages.activatePackage('package-with-provided-services');\n        expect(consumerModule.consumeFirstServiceV3.callCount).toBe(1);\n        expect(consumerModule.consumeFirstServiceV3).toHaveBeenCalledWith('first-service-v3');\n        expect(consumerModule.consumeFirstServiceV4).toHaveBeenCalledWith('first-service-v4');\n        expect(consumerModule.consumeSecondService).toHaveBeenCalledWith('second-service');\n        consumerModule.consumeFirstServiceV3.reset();\n        consumerModule.consumeFirstServiceV4.reset();\n        consumerModule.consumeSecondService.reset();\n        await atom.packages.deactivatePackage('package-with-provided-services');\n        expect(firstServiceV3Disposed).toBe(true);\n        expect(firstServiceV4Disposed).toBe(true);\n        expect(secondServiceDisposed).toBe(true);\n        await atom.packages.deactivatePackage('package-with-consumed-services');\n        await atom.packages.activatePackage('package-with-provided-services');\n        expect(consumerModule.consumeFirstServiceV3).not.toHaveBeenCalled();\n        expect(consumerModule.consumeFirstServiceV4).not.toHaveBeenCalled();\n        expect(consumerModule.consumeSecondService).not.toHaveBeenCalled();\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores provided and consumed services that do not exist",
            "suites": [
                "PackageManager",
                "::activatePackage(id)",
                "service registration"
            ],
            "updatePoint": {
                "line": 1093,
                "column": 66
            },
            "line": 1093,
            "code": "      it('ignores provided and consumed services that do not exist', async () => {\n        const addErrorHandler = jasmine.createSpy();\n        atom.notifications.onDidAddNotification(addErrorHandler);\n        await atom.packages.activatePackage('package-with-missing-consumed-services');\n        await atom.packages.activatePackage('package-with-missing-provided-services');\n        expect(atom.packages.isPackageActive('package-with-missing-consumed-services')).toBe(true);\n        expect(atom.packages.isPackageActive('package-with-missing-provided-services')).toBe(true);\n        expect(addErrorHandler.callCount).toBe(0);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not serialize packages that threw an error during activation",
            "suites": [
                "PackageManager",
                "::serialize"
            ],
            "updatePoint": {
                "line": 1105,
                "column": 73
            },
            "line": 1105,
            "code": "    it('does not serialize packages that threw an error during activation', async () => {\n      spyOn(atom, 'inSpecMode').andReturn(false);\n      spyOn(console, 'warn');\n      const badPack = await atom.packages.activatePackage('package-that-throws-on-activate');\n      spyOn(badPack.mainModule, 'serialize').andCallThrough();\n      atom.packages.serialize();\n      expect(badPack.mainModule.serialize).not.toHaveBeenCalled();\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "absorbs exceptions that are thrown by the package module's serialize method",
            "suites": [
                "PackageManager",
                "::serialize"
            ],
            "updatePoint": {
                "line": 1113,
                "column": 83
            },
            "line": 1113,
            "code": "    it(\"absorbs exceptions that are thrown by the package module's serialize method\", async () => {\n      spyOn(console, 'error');\n      await atom.packages.activatePackage('package-with-serialize-error');\n      await atom.packages.activatePackage('package-with-serialization');\n      atom.packages.serialize();\n      expect(atom.packages.packageStates['package-with-serialize-error']).toBeUndefined();\n      expect(atom.packages.packageStates['package-with-serialization']).toEqual({\n        someNumber: 1\n      });\n      expect(console.error).toHaveBeenCalled();\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deactivates all packages but does not serialize them",
            "suites": [
                "PackageManager",
                "::deactivatePackages()"
            ],
            "updatePoint": {
                "line": 1126,
                "column": 60
            },
            "line": 1126,
            "code": "    it('deactivates all packages but does not serialize them', async () => {\n      const pack1 = await atom.packages.activatePackage('package-with-deactivate');\n      const pack2 = await atom.packages.activatePackage('package-with-serialization');\n      spyOn(pack1.mainModule, 'deactivate');\n      spyOn(pack2.mainModule, 'serialize');\n      await atom.packages.deactivatePackages();\n      expect(pack1.mainModule.deactivate).toHaveBeenCalled();\n      expect(pack2.mainModule.serialize).not.toHaveBeenCalled();\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls `deactivate` on the package's main module if activate was successful",
            "suites": [
                "PackageManager",
                "::deactivatePackage(id)"
            ],
            "updatePoint": {
                "line": 1138,
                "column": 82
            },
            "line": 1138,
            "code": "    it(\"calls `deactivate` on the package's main module if activate was successful\", async () => {\n      spyOn(atom, 'inSpecMode').andReturn(false);\n      const pack = await atom.packages.activatePackage('package-with-deactivate');\n      expect(atom.packages.isPackageActive('package-with-deactivate')).toBeTruthy();\n      spyOn(pack.mainModule, 'deactivate').andCallThrough();\n      await atom.packages.deactivatePackage('package-with-deactivate');\n      expect(pack.mainModule.deactivate).toHaveBeenCalled();\n      expect(atom.packages.isPackageActive('package-with-module')).toBeFalsy();\n      spyOn(console, 'warn');\n      const badPack = await atom.packages.activatePackage('package-that-throws-on-activate');\n      expect(atom.packages.isPackageActive('package-that-throws-on-activate')).toBeTruthy();\n      spyOn(badPack.mainModule, 'deactivate').andCallThrough();\n      await atom.packages.deactivatePackage('package-that-throws-on-activate');\n      expect(badPack.mainModule.deactivate).not.toHaveBeenCalled();\n      expect(atom.packages.isPackageActive('package-that-throws-on-activate')).toBeFalsy();\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "absorbs exceptions that are thrown by the package module's deactivate method",
            "suites": [
                "PackageManager",
                "::deactivatePackage(id)"
            ],
            "updatePoint": {
                "line": 1154,
                "column": 84
            },
            "line": 1154,
            "code": "    it(\"absorbs exceptions that are thrown by the package module's deactivate method\", async () => {\n      spyOn(console, 'error');\n      await atom.packages.activatePackage('package-that-throws-on-deactivate');\n      await atom.packages.deactivatePackage('package-that-throws-on-deactivate');\n      expect(console.error).toHaveBeenCalled();\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the package's grammars",
            "suites": [
                "PackageManager",
                "::deactivatePackage(id)"
            ],
            "updatePoint": {
                "line": 1160,
                "column": 38
            },
            "line": 1160,
            "code": "    it(\"removes the package's grammars\", async () => {\n      await atom.packages.activatePackage('package-with-grammars');\n      await atom.packages.deactivatePackage('package-with-grammars');\n      expect(atom.grammars.selectGrammar('a.alot').name).toBe('Null Grammar');\n      expect(atom.grammars.selectGrammar('a.alittle').name).toBe('Null Grammar');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the package's keymaps",
            "suites": [
                "PackageManager",
                "::deactivatePackage(id)"
            ],
            "updatePoint": {
                "line": 1166,
                "column": 37
            },
            "line": 1166,
            "code": "    it(\"removes the package's keymaps\", async () => {\n      await atom.packages.activatePackage('package-with-keymaps');\n      await atom.packages.deactivatePackage('package-with-keymaps');\n      expect(atom.keymaps.findKeyBindings({\n        keystrokes: 'ctrl-z',\n        target: createTestElement('test-1')\n      })).toHaveLength(0);\n      expect(atom.keymaps.findKeyBindings({\n        keystrokes: 'ctrl-z',\n        target: createTestElement('test-2')\n      })).toHaveLength(0);\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the package's stylesheets",
            "suites": [
                "PackageManager",
                "::deactivatePackage(id)"
            ],
            "updatePoint": {
                "line": 1178,
                "column": 41
            },
            "line": 1178,
            "code": "    it(\"removes the package's stylesheets\", async () => {\n      await atom.packages.activatePackage('package-with-styles');\n      await atom.packages.deactivatePackage('package-with-styles');\n\n      const one = require.resolve('./fixtures/packages/package-with-style-sheets-manifest/styles/1.css');\n\n      const two = require.resolve('./fixtures/packages/package-with-style-sheets-manifest/styles/2.less');\n\n      const three = require.resolve('./fixtures/packages/package-with-style-sheets-manifest/styles/3.css');\n\n      expect(atom.themes.stylesheetElementForId(one)).not.toExist();\n      expect(atom.themes.stylesheetElementForId(two)).not.toExist();\n      expect(atom.themes.stylesheetElementForId(three)).not.toExist();\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the package's scoped-properties",
            "suites": [
                "PackageManager",
                "::deactivatePackage(id)"
            ],
            "updatePoint": {
                "line": 1192,
                "column": 47
            },
            "line": 1192,
            "code": "    it(\"removes the package's scoped-properties\", async () => {\n      await atom.packages.activatePackage('package-with-settings');\n      expect(atom.config.get('editor.increaseIndentPattern', {\n        scope: ['.source.omg']\n      })).toBe('^a');\n      await atom.packages.deactivatePackage('package-with-settings');\n      expect(atom.config.get('editor.increaseIndentPattern', {\n        scope: ['.source.omg']\n      })).toBeUndefined();\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidDeactivatePackage listeners with the deactivated package",
            "suites": [
                "PackageManager",
                "::deactivatePackage(id)"
            ],
            "updatePoint": {
                "line": 1202,
                "column": 79
            },
            "line": 1202,
            "code": "    it('invokes ::onDidDeactivatePackage listeners with the deactivated package', async () => {\n      await atom.packages.activatePackage('package-with-main');\n      let deactivatedPackage;\n      atom.packages.onDidDeactivatePackage(pack => {\n        deactivatedPackage = pack;\n      });\n      await atom.packages.deactivatePackage('package-with-main');\n      expect(deactivatedPackage.name).toBe('package-with-main');\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets hasActivatedInitialPackages",
            "suites": [
                "PackageManager",
                "::activate()"
            ],
            "updatePoint": {
                "line": 1226,
                "column": 40
            },
            "line": 1226,
            "code": "    it('sets hasActivatedInitialPackages', async () => {\n      spyOn(atom.styles, 'getUserStyleSheetPath').andReturn(null);\n      spyOn(atom.packages, 'activatePackages');\n      expect(atom.packages.hasActivatedInitialPackages()).toBe(false);\n      await atom.packages.activate();\n      expect(atom.packages.hasActivatedInitialPackages()).toBe(true);\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates all the packages, and none of the themes",
            "suites": [
                "PackageManager",
                "::activate()"
            ],
            "updatePoint": {
                "line": 1233,
                "column": 58
            },
            "line": 1233,
            "code": "    it('activates all the packages, and none of the themes', () => {\n      const packageActivator = spyOn(atom.packages, 'activatePackages');\n      const themeActivator = spyOn(atom.themes, 'activatePackages');\n      atom.packages.activate();\n      expect(packageActivator).toHaveBeenCalled();\n      expect(themeActivator).toHaveBeenCalled();\n      const packages = packageActivator.mostRecentCall.args[0];\n\n      for (let pack of packages) {\n        expect(['atom', 'textmate']).toContain(pack.getType());\n      }\n\n      const themes = themeActivator.mostRecentCall.args[0];\n      themes.map(theme => expect(['theme']).toContain(theme.getType()));\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls callbacks registered with ::onDidActivateInitialPackages",
            "suites": [
                "PackageManager",
                "::activate()"
            ],
            "updatePoint": {
                "line": 1248,
                "column": 70
            },
            "line": 1248,
            "code": "    it('calls callbacks registered with ::onDidActivateInitialPackages', async () => {\n      const package1 = atom.packages.loadPackage('package-with-main');\n      const package2 = atom.packages.loadPackage('package-with-index');\n      const package3 = atom.packages.loadPackage('package-with-activation-commands');\n      spyOn(atom.packages, 'getLoadedPackages').andReturn([package1, package2, package3]);\n      spyOn(atom.themes, 'activatePackages');\n      atom.packages.activate();\n      await new Promise(resolve => atom.packages.onDidActivateInitialPackages(resolve));\n      jasmine.unspy(atom.packages, 'getLoadedPackages');\n      expect(atom.packages.getActivePackages().includes(package1)).toBe(true);\n      expect(atom.packages.getActivePackages().includes(package2)).toBe(true);\n      expect(atom.packages.getActivePackages().includes(package3)).toBe(false);\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables a disabled package",
            "suites": [
                "PackageManager",
                "::enablePackage(id) and ::disablePackage(id)",
                "with packages"
            ],
            "updatePoint": {
                "line": 1264,
                "column": 36
            },
            "line": 1264,
            "code": "      it('enables a disabled package', async () => {\n        const packageName = 'package-with-main';\n        atom.config.pushAtKeyPath('core.disabledPackages', packageName);\n        atom.packages.observeDisabledPackages();\n        expect(atom.config.get('core.disabledPackages')).toContain(packageName);\n        const pack = atom.packages.enablePackage(packageName);\n        await new Promise(resolve => atom.packages.onDidActivatePackage(resolve));\n        expect(atom.packages.getLoadedPackages()).toContain(pack);\n        expect(atom.packages.getActivePackages()).toContain(pack);\n        expect(atom.config.get('core.disabledPackages')).not.toContain(packageName);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "disables an enabled package",
            "suites": [
                "PackageManager",
                "::enablePackage(id) and ::disablePackage(id)",
                "with packages"
            ],
            "updatePoint": {
                "line": 1275,
                "column": 37
            },
            "line": 1275,
            "code": "      it('disables an enabled package', async () => {\n        const packageName = 'package-with-main';\n        const pack = await atom.packages.activatePackage(packageName);\n        atom.packages.observeDisabledPackages();\n        expect(atom.config.get('core.disabledPackages')).not.toContain(packageName);\n        await new Promise(resolve => {\n          atom.packages.onDidDeactivatePackage(resolve);\n          atom.packages.disablePackage(packageName);\n        });\n        expect(atom.packages.getActivePackages()).not.toContain(pack);\n        expect(atom.config.get('core.disabledPackages')).toContain(packageName);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null if the package cannot be loaded",
            "suites": [
                "PackageManager",
                "::enablePackage(id) and ::disablePackage(id)",
                "with packages"
            ],
            "updatePoint": {
                "line": 1287,
                "column": 54
            },
            "line": 1287,
            "code": "      it('returns null if the package cannot be loaded', () => {\n        spyOn(console, 'warn');\n        expect(atom.packages.enablePackage('this-doesnt-exist')).toBeNull();\n        expect(console.warn.callCount).toBe(1);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not disable an already disabled package",
            "suites": [
                "PackageManager",
                "::enablePackage(id) and ::disablePackage(id)",
                "with packages"
            ],
            "updatePoint": {
                "line": 1292,
                "column": 54
            },
            "line": 1292,
            "code": "      it('does not disable an already disabled package', () => {\n        const packageName = 'package-with-main';\n        atom.config.pushAtKeyPath('core.disabledPackages', packageName);\n        atom.packages.observeDisabledPackages();\n        expect(atom.config.get('core.disabledPackages')).toContain(packageName);\n        atom.packages.disablePackage(packageName);\n        const packagesDisabled = atom.config.get('core.disabledPackages').filter(pack => pack === packageName);\n        expect(packagesDisabled.length).toEqual(1);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables and disables a theme",
            "suites": [
                "PackageManager",
                "::enablePackage(id) and ::disablePackage(id)",
                "with themes"
            ],
            "updatePoint": {
                "line": 1305,
                "column": 38
            },
            "line": 1305,
            "code": "      it('enables and disables a theme', async () => {\n        const packageName = 'theme-with-package-file';\n        expect(atom.config.get('core.themes')).not.toContain(packageName);\n        expect(atom.config.get('core.disabledPackages')).not.toContain(packageName); // enabling of theme\n\n        const pack = atom.packages.enablePackage(packageName);\n        await new Promise(resolve => atom.packages.onDidActivatePackage(resolve));\n        expect(atom.packages.isPackageActive(packageName)).toBe(true);\n        expect(atom.config.get('core.themes')).toContain(packageName);\n        expect(atom.config.get('core.disabledPackages')).not.toContain(packageName);\n        await new Promise(resolve => {\n          atom.themes.onDidChangeActiveThemes(resolve);\n          atom.packages.disablePackage(packageName);\n        });\n        expect(atom.packages.getActivePackages()).not.toContain(pack);\n        expect(atom.config.get('core.themes')).not.toContain(packageName);\n        expect(atom.config.get('core.themes')).not.toContain(packageName);\n        expect(atom.config.get('core.disabledPackages')).not.toContain(packageName);\n      });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "detects a symlinked package",
            "suites": [
                "PackageManager",
                "::getAvailablePackageNames"
            ],
            "updatePoint": {
                "line": 1327,
                "column": 35
            },
            "line": 1327,
            "code": "    it('detects a symlinked package', () => {\n      const packageSymLinkedSource = path.join(__dirname, 'fixtures', 'packages', 'folder', 'package-symlinked');\n      const destination = path.join(atom.packages.getPackageDirPaths()[0], 'package-symlinked');\n\n      if (!fs.isDirectorySync(destination)) {\n        fs.symlinkSync(packageSymLinkedSource, destination, 'junction');\n      }\n\n      const availablePackages = atom.packages.getAvailablePackageNames();\n      expect(availablePackages.includes('package-symlinked')).toBe(true);\n      fs.removeSync(destination);\n    });",
            "file": "package-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not activate it",
            "suites": [
                "Package",
                "when the package contains incompatible native modules"
            ],
            "updatePoint": {
                "line": 38,
                "column": 28
            },
            "line": 38,
            "code": "    it('does not activate it', function () {\n      const packagePath = atom.project.getDirectories()[0].resolve('packages/package-with-incompatible-native-module');\n      const pack = buildPackage(packagePath);\n      expect(pack.isCompatible()).toBe(false);\n      expect(pack.incompatibleModules[0].name).toBe('native-module');\n      expect(pack.incompatibleModules[0].path).toBe(path.join(packagePath, 'node_modules', 'native-module'));\n    });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "detects the package as incompatible even if .node file is loaded conditionally",
            "suites": [
                "Package",
                "when the package contains incompatible native modules"
            ],
            "updatePoint": {
                "line": 45,
                "column": 86
            },
            "line": 45,
            "code": "    it('detects the package as incompatible even if .node file is loaded conditionally', function () {\n      const packagePath = atom.project.getDirectories()[0].resolve('packages/package-with-incompatible-native-module-loaded-conditionally');\n      const pack = buildPackage(packagePath);\n      expect(pack.isCompatible()).toBe(false);\n      expect(pack.incompatibleModules[0].name).toBe('native-module');\n      expect(pack.incompatibleModules[0].path).toBe(path.join(packagePath, 'node_modules', 'native-module'));\n    });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "utilizes _atomModuleCache if present to determine the package's native dependencies",
            "suites": [
                "Package",
                "when the package contains incompatible native modules"
            ],
            "updatePoint": {
                "line": 52,
                "column": 91
            },
            "line": 52,
            "code": "    it(\"utilizes _atomModuleCache if present to determine the package's native dependencies\", function () {\n      let packagePath = atom.project.getDirectories()[0].resolve('packages/package-with-ignored-incompatible-native-module');\n      let pack = buildPackage(packagePath);\n      expect(pack.getNativeModuleDependencyPaths().length).toBe(1); // doesn't see the incompatible module\n\n      expect(pack.isCompatible()).toBe(true);\n      packagePath = __guard__(atom.project.getDirectories()[0], x => x.resolve('packages/package-with-cached-incompatible-native-module'));\n      pack = buildPackage(packagePath);\n      expect(pack.isCompatible()).toBe(false);\n    });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "caches the incompatible native modules in local storage",
            "suites": [
                "Package",
                "when the package contains incompatible native modules"
            ],
            "updatePoint": {
                "line": 62,
                "column": 63
            },
            "line": 62,
            "code": "    it('caches the incompatible native modules in local storage', function () {\n      const packagePath = atom.project.getDirectories()[0].resolve('packages/package-with-incompatible-native-module');\n      expect(buildPackage(packagePath).isCompatible()).toBe(false);\n      expect(global.localStorage.getItem.callCount).toBe(1);\n      expect(global.localStorage.setItem.callCount).toBe(1);\n      expect(buildPackage(packagePath).isCompatible()).toBe(false);\n      expect(global.localStorage.getItem.callCount).toBe(2);\n      expect(global.localStorage.setItem.callCount).toBe(1);\n    });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "logs an error to the console describing the problem",
            "suites": [
                "Package",
                "when the package contains incompatible native modules"
            ],
            "updatePoint": {
                "line": 71,
                "column": 59
            },
            "line": 71,
            "code": "    it('logs an error to the console describing the problem', function () {\n      const packagePath = atom.project.getDirectories()[0].resolve('packages/package-with-incompatible-native-module');\n      spyOn(console, 'warn');\n      spyOn(atom.notifications, 'addFatalError');\n      buildPackage(packagePath).activateNow();\n      expect(atom.notifications.addFatalError).not.toHaveBeenCalled();\n      expect(console.warn.callCount).toBe(1);\n      expect(console.warn.mostRecentCall.args[0]).toContain('it requires one or more incompatible native modules (native-module)');\n    });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a promise resolving to the results of `apm rebuild`",
            "suites": [
                "Package",
                "::rebuild()"
            ],
            "updatePoint": {
                "line": 87,
                "column": 67
            },
            "line": 87,
            "code": "    it('returns a promise resolving to the results of `apm rebuild`', function () {\n      const packagePath = __guard__(atom.project.getDirectories()[0], x => x.resolve('packages/package-with-index'));\n\n      const pack = buildPackage(packagePath);\n      const rebuildCallbacks = [];\n      spyOn(pack, 'runRebuildProcess').andCallFake(callback => rebuildCallbacks.push(callback));\n      const promise = pack.rebuild();\n      rebuildCallbacks[0]({\n        code: 0,\n        stdout: 'stdout output',\n        stderr: 'stderr output'\n      });\n      waitsFor(done => promise.then(function (result) {\n        expect(result).toEqual({\n          code: 0,\n          stdout: 'stdout output',\n          stderr: 'stderr output'\n        });\n        done();\n      }));\n    });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "persists build failures in local storage",
            "suites": [
                "Package",
                "::rebuild()"
            ],
            "updatePoint": {
                "line": 108,
                "column": 48
            },
            "line": 108,
            "code": "    it('persists build failures in local storage', function () {\n      const packagePath = __guard__(atom.project.getDirectories()[0], x => x.resolve('packages/package-with-index'));\n\n      const pack = buildPackage(packagePath);\n      expect(pack.isCompatible()).toBe(true);\n      expect(pack.getBuildFailureOutput()).toBeNull();\n      const rebuildCallbacks = [];\n      spyOn(pack, 'runRebuildProcess').andCallFake(callback => rebuildCallbacks.push(callback));\n      pack.rebuild();\n      rebuildCallbacks[0]({\n        code: 13,\n        stderr: 'It is broken'\n      });\n      expect(pack.getBuildFailureOutput()).toBe('It is broken');\n      expect(pack.getIncompatibleNativeModules()).toEqual([]);\n      expect(pack.isCompatible()).toBe(false); // A different package instance has the same failure output (simulates reload)\n\n      const pack2 = buildPackage(packagePath);\n      expect(pack2.getBuildFailureOutput()).toBe('It is broken');\n      expect(pack2.isCompatible()).toBe(false); // Clears the build failure after a successful build\n\n      pack.rebuild();\n      rebuildCallbacks[1]({\n        code: 0,\n        stdout: 'It worked'\n      });\n      expect(pack.getBuildFailureOutput()).toBeNull();\n      expect(pack2.getBuildFailureOutput()).toBeNull();\n    });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets cached incompatible modules to an empty array when the rebuild completes (there may be a build error, but rebuilding *deletes* native modules)",
            "suites": [
                "Package",
                "::rebuild()"
            ],
            "updatePoint": {
                "line": 137,
                "column": 155
            },
            "line": 137,
            "code": "    it('sets cached incompatible modules to an empty array when the rebuild completes (there may be a build error, but rebuilding *deletes* native modules)', function () {\n      const packagePath = __guard__(atom.project.getDirectories()[0], x => x.resolve('packages/package-with-incompatible-native-module'));\n\n      const pack = buildPackage(packagePath);\n      expect(pack.getIncompatibleNativeModules().length).toBeGreaterThan(0);\n      const rebuildCallbacks = [];\n      spyOn(pack, 'runRebuildProcess').andCallFake(callback => rebuildCallbacks.push(callback));\n      pack.rebuild();\n      expect(pack.getIncompatibleNativeModules().length).toBeGreaterThan(0);\n      rebuildCallbacks[0]({\n        code: 0,\n        stdout: 'It worked'\n      });\n      expect(pack.getIncompatibleNativeModules().length).toBe(0);\n    });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads and applies css",
            "suites": [
                "Package",
                "theme",
                "when the theme contains a single style file"
            ],
            "updatePoint": {
                "line": 165,
                "column": 31
            },
            "line": 165,
            "code": "      it('loads and applies css', function () {\n        expect(getComputedStyle(editorElement).paddingBottom).not.toBe('1234px');\n\n        const themePath = __guard__(atom.project.getDirectories()[0], x => x.resolve('packages/theme-with-index-css'));\n\n        theme = buildThemePackage(themePath);\n        theme.activate();\n        expect(getComputedStyle(editorElement).paddingTop).toBe('1234px');\n      });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "parses, loads and applies less",
            "suites": [
                "Package",
                "theme",
                "when the theme contains a single style file"
            ],
            "updatePoint": {
                "line": 174,
                "column": 40
            },
            "line": 174,
            "code": "      it('parses, loads and applies less', function () {\n        expect(getComputedStyle(editorElement).paddingBottom).not.toBe('1234px');\n\n        const themePath = __guard__(atom.project.getDirectories()[0], x => x.resolve('packages/theme-with-index-less'));\n\n        theme = buildThemePackage(themePath);\n        theme.activate();\n        expect(getComputedStyle(editorElement).paddingTop).toBe('4321px');\n      });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads and applies stylesheets from package.json in the correct order",
            "suites": [
                "Package",
                "theme",
                "when the theme contains a package.json file"
            ],
            "updatePoint": {
                "line": 184,
                "column": 138
            },
            "line": 184,
            "code": "    describe('when the theme contains a package.json file', () => it('loads and applies stylesheets from package.json in the correct order', function () {\n      expect(getComputedStyle(editorElement).paddingTop).not.toBe('101px');\n      expect(getComputedStyle(editorElement).paddingRight).not.toBe('102px');\n      expect(getComputedStyle(editorElement).paddingBottom).not.toBe('103px');\n\n      const themePath = __guard__(atom.project.getDirectories()[0], x => x.resolve('packages/theme-with-package-file'));\n\n      theme = buildThemePackage(themePath);\n      theme.activate();\n      expect(getComputedStyle(editorElement).paddingTop).toBe('101px');\n      expect(getComputedStyle(editorElement).paddingRight).toBe('102px');\n      expect(getComputedStyle(editorElement).paddingBottom).toBe('103px');\n    }));",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads all stylesheet files in the directory",
            "suites": [
                "Package",
                "theme",
                "when the theme does not contain a package.json file and is a directory"
            ],
            "updatePoint": {
                "line": 197,
                "column": 140
            },
            "line": 197,
            "code": "    describe('when the theme does not contain a package.json file and is a directory', () => it('loads all stylesheet files in the directory', function () {\n      expect(getComputedStyle(editorElement).paddingTop).not.toBe('10px');\n      expect(getComputedStyle(editorElement).paddingRight).not.toBe('20px');\n      expect(getComputedStyle(editorElement).paddingBottom).not.toBe('30px');\n\n      const themePath = __guard__(atom.project.getDirectories()[0], x => x.resolve('packages/theme-without-package-file'));\n\n      theme = buildThemePackage(themePath);\n      theme.activate();\n      expect(getComputedStyle(editorElement).paddingTop).toBe('10px');\n      expect(getComputedStyle(editorElement).paddingRight).toBe('20px');\n      expect(getComputedStyle(editorElement).paddingBottom).toBe('30px');\n    }));",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reloads without readding to the stylesheets list",
            "suites": [
                "Package",
                "theme",
                "reloading a theme"
            ],
            "updatePoint": {
                "line": 217,
                "column": 58
            },
            "line": 217,
            "code": "      it('reloads without readding to the stylesheets list', function () {\n        expect(theme.getStylesheetPaths().length).toBe(3);\n        theme.reloadStylesheets();\n        expect(theme.getStylesheetPaths().length).toBe(3);\n      });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deactivated event fires on .deactivate()",
            "suites": [
                "Package",
                "theme",
                "events"
            ],
            "updatePoint": {
                "line": 230,
                "column": 50
            },
            "line": 230,
            "code": "      it('deactivated event fires on .deactivate()', function () {\n        let spy;\n        theme.onDidDeactivate(spy = jasmine.createSpy());\n        waitsForPromise(() => Promise.resolve(theme.deactivate()));\n        runs(() => expect(spy).toHaveBeenCalled());\n      });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the package name defined in package.json",
            "suites": [
                "Package",
                ".loadMetadata()"
            ],
            "updatePoint": {
                "line": 244,
                "column": 53
            },
            "line": 244,
            "code": "    it('uses the package name defined in package.json', () => expect(metadata.name).toBe('package-with-a-totally-different-name'));",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gets called when the package is activated",
            "suites": [
                "Package",
                "the initialize() hook"
            ],
            "updatePoint": {
                "line": 247,
                "column": 49
            },
            "line": 247,
            "code": "    it('gets called when the package is activated', function () {\n      const packagePath = atom.project.getDirectories()[0].resolve('packages/package-with-deserializers');\n      const pack = buildPackage(packagePath);\n      pack.requireMainModule();\n      const {\n        mainModule\n      } = pack;\n      spyOn(mainModule, 'initialize');\n      expect(mainModule.initialize).not.toHaveBeenCalled();\n      pack.activate();\n      expect(mainModule.initialize).toHaveBeenCalled();\n      expect(mainModule.initialize.callCount).toBe(1);\n    });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gets called when a deserializer is used",
            "suites": [
                "Package",
                "the initialize() hook"
            ],
            "updatePoint": {
                "line": 260,
                "column": 47
            },
            "line": 260,
            "code": "    it('gets called when a deserializer is used', function () {\n      const packagePath = atom.project.getDirectories()[0].resolve('packages/package-with-deserializers');\n      const pack = buildPackage(packagePath);\n      pack.requireMainModule();\n      const {\n        mainModule\n      } = pack;\n      spyOn(mainModule, 'initialize');\n      pack.load();\n      expect(mainModule.initialize).not.toHaveBeenCalled();\n      atom.deserializers.deserialize({\n        deserializer: 'Deserializer1',\n        a: 'b'\n      });\n      expect(mainModule.initialize).toHaveBeenCalled();\n    });",
            "file": "package-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "falls through to the original compiler by default",
            "suites": [
                "PackageTranspilationRegistry"
            ],
            "updatePoint": {
                "line": 22,
                "column": 55
            },
            "line": 22,
            "code": "  it('falls through to the original compiler by default', () => {\n    spyOn(originalCompiler, 'getCachePath');\n    spyOn(originalCompiler, 'compile');\n    spyOn(originalCompiler, 'shouldCompile');\n    wrappedCompiler.getCachePath('source', '/path/to/file.js');\n    wrappedCompiler.compile('source', '/path/to/filejs');\n    wrappedCompiler.shouldCompile('source', '/path/to/file.js');\n    expect(originalCompiler.getCachePath).toHaveBeenCalled();\n    expect(originalCompiler.compile).toHaveBeenCalled();\n    expect(originalCompiler.shouldCompile).toHaveBeenCalled();\n  });",
            "file": "package-transpilation-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "always returns true from shouldCompile for a file in that dir that match a glob",
            "suites": [
                "PackageTranspilationRegistry",
                "when a file is contained in a path that has custom transpilation"
            ],
            "updatePoint": {
                "line": 113,
                "column": 87
            },
            "line": 113,
            "code": "    it('always returns true from shouldCompile for a file in that dir that match a glob', () => {\n      spyOn(originalCompiler, 'shouldCompile').andReturn(false);\n      expect(wrappedCompiler.shouldCompile('source', hitPath)).toBe(true);\n      expect(wrappedCompiler.shouldCompile('source', hitPathCoffee)).toBe(true);\n      expect(wrappedCompiler.shouldCompile('source', hitNonStandardExt)).toBe(true);\n      expect(wrappedCompiler.shouldCompile('source', hitPathMissExt)).toBe(false);\n      expect(wrappedCompiler.shouldCompile('source', hitPathMissSubdir)).toBe(false);\n      expect(wrappedCompiler.shouldCompile('source', missPath)).toBe(false);\n      expect(wrappedCompiler.shouldCompile('source', nodeModulesFolder)).toBe(false);\n    });",
            "file": "package-transpilation-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls getCacheKeyData on the transpiler to get additional cache key data",
            "suites": [
                "PackageTranspilationRegistry",
                "when a file is contained in a path that has custom transpilation"
            ],
            "updatePoint": {
                "line": 123,
                "column": 80
            },
            "line": 123,
            "code": "    it('calls getCacheKeyData on the transpiler to get additional cache key data', () => {\n      spyOn(registry, 'getTranspilerPath').andReturn('./transpiler-js');\n      spyOn(jsTranspiler, 'getCacheKeyData').andCallThrough();\n      wrappedCompiler.getCachePath('source', missPath, jsSpec);\n      expect(jsTranspiler.getCacheKeyData).not.toHaveBeenCalledWith('source', missPath, jsSpec.options, expectedMeta);\n      wrappedCompiler.getCachePath('source', hitPath, jsSpec);\n      expect(jsTranspiler.getCacheKeyData).toHaveBeenCalledWith('source', hitPath, jsSpec.options, expectedMeta);\n    });",
            "file": "package-transpilation-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "compiles files matching a glob with the associated transpiler, and the old one otherwise",
            "suites": [
                "PackageTranspilationRegistry",
                "when a file is contained in a path that has custom transpilation"
            ],
            "updatePoint": {
                "line": 131,
                "column": 96
            },
            "line": 131,
            "code": "    it('compiles files matching a glob with the associated transpiler, and the old one otherwise', () => {\n      spyOn(jsTranspiler, 'transpile').andCallThrough();\n      spyOn(coffeeTranspiler, 'transpile').andCallThrough();\n      spyOn(omgTranspiler, 'transpile').andCallThrough();\n      expect(wrappedCompiler.compile('source', hitPath)).toEqual('source-transpiler-js');\n      expect(jsTranspiler.transpile).toHaveBeenCalledWith('source', hitPath, jsSpec.options, expectedMeta);\n      expect(wrappedCompiler.compile('source', hitPathCoffee)).toEqual('source-transpiler-coffee');\n      expect(coffeeTranspiler.transpile).toHaveBeenCalledWith('source', hitPathCoffee, coffeeSpec.options, expectedMeta);\n      expect(wrappedCompiler.compile('source', hitNonStandardExt)).toEqual('source-transpiler-omg');\n      expect(omgTranspiler.transpile).toHaveBeenCalledWith('source', hitNonStandardExt, omgSpec.options, expectedMeta);\n      expect(wrappedCompiler.compile('source', missPath)).toEqual('source-original-compiler');\n      expect(wrappedCompiler.compile('source', hitPathMissExt)).toEqual('source-original-compiler');\n      expect(wrappedCompiler.compile('source', hitPathMissSubdir)).toEqual('source-original-compiler');\n      expect(wrappedCompiler.compile('source', nodeModulesFolder)).toEqual('source-original-compiler');\n    });",
            "file": "package-transpilation-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns appropriate values from shouldCompile",
            "suites": [
                "PackageTranspilationRegistry",
                "when a file is contained in a path that has custom transpilation",
                "when the packages root path contains node_modules"
            ],
            "updatePoint": {
                "line": 152,
                "column": 55
            },
            "line": 152,
            "code": "      it('returns appropriate values from shouldCompile', () => {\n        spyOn(originalCompiler, 'shouldCompile').andReturn(false);\n        expect(wrappedCompiler.shouldCompile('source', '/path/with/node_modules/in/root/lib/test.js')).toBe(true);\n        expect(wrappedCompiler.shouldCompile('source', '/path/with/node_modules/in/root/lib/node_modules/test.js')).toBe(false);\n      });",
            "file": "package-transpilation-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly subscribes and unsubscribes to the underlying model events on attach/detach",
            "suites": [
                "PaneAxisElement"
            ],
            "updatePoint": {
                "line": 15,
                "column": 123
            },
            "line": 15,
            "code": "describe('PaneAxisElement', () => it('correctly subscribes and unsubscribes to the underlying model events on attach/detach', function () {\n  const container = new PaneContainer({\n    config: atom.config,\n    applicationDelegate: atom.applicationDelegate,\n    viewRegistry: atom.views\n  });\n  const axis = new PaneAxis({}, atom.views);\n  axis.setContainer(container);\n  const axisElement = axis.getElement();\n  const panes = [buildPane(), buildPane(), buildPane()];\n  jasmine.attachToDOM(axisElement);\n  axis.addChild(panes[0]);\n  expect(axisElement.children[0]).toBe(panes[0].getElement());\n  axisElement.remove();\n  axis.addChild(panes[1]);\n  expect(axisElement.children[2]).toBeUndefined();\n  jasmine.attachToDOM(axisElement);\n  expect(axisElement.children[2]).toBe(panes[1].getElement());\n  axis.addChild(panes[2]);\n  expect(axisElement.children[4]).toBe(panes[2].getElement());\n}));",
            "file": "pane-axis-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts or removes resize elements",
            "suites": [
                "PaneContainerElement",
                "when panes are added or removed"
            ],
            "updatePoint": {
                "line": 14,
                "column": 42
            },
            "line": 14,
            "code": "    it('inserts or removes resize elements', function () {\n      const childTagNames = () => Array.from(paneAxisElement.children).map(child => child.nodeName.toLowerCase());\n\n      const paneAxis = new PaneAxis({}, atom.views);\n      var paneAxisElement = paneAxis.getElement();\n      expect(childTagNames()).toEqual([]);\n      paneAxis.addChild(new PaneAxis({}, atom.views));\n      expect(childTagNames()).toEqual(['atom-pane-axis']);\n      paneAxis.addChild(new PaneAxis({}, atom.views));\n      expect(childTagNames()).toEqual(['atom-pane-axis', 'atom-pane-resize-handle', 'atom-pane-axis']);\n      paneAxis.addChild(new PaneAxis({}, atom.views));\n      expect(childTagNames()).toEqual(['atom-pane-axis', 'atom-pane-resize-handle', 'atom-pane-axis', 'atom-pane-resize-handle', 'atom-pane-axis']);\n      paneAxis.removeChild(paneAxis.getChildren()[2]);\n      expect(childTagNames()).toEqual(['atom-pane-axis', 'atom-pane-resize-handle', 'atom-pane-axis']);\n    });",
            "file": "pane-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "transfers focus to the next pane if a focused pane is removed",
            "suites": [
                "PaneContainerElement",
                "when panes are added or removed"
            ],
            "updatePoint": {
                "line": 29,
                "column": 69
            },
            "line": 29,
            "code": "    it('transfers focus to the next pane if a focused pane is removed', function () {\n      const container = new PaneContainer(params);\n      const containerElement = container.getElement();\n      const leftPane = container.getActivePane();\n      const leftPaneElement = leftPane.getElement();\n      const rightPane = leftPane.splitRight();\n      const rightPaneElement = rightPane.getElement();\n      jasmine.attachToDOM(containerElement);\n      rightPaneElement.focus();\n      expect(document.activeElement).toBe(rightPaneElement);\n      rightPane.destroy();\n      expect(containerElement).toHaveClass('panes');\n      expect(document.activeElement).toBe(leftPaneElement);\n    });",
            "file": "pane-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "builds appropriately-oriented atom-pane-axis elements",
            "suites": [
                "PaneContainerElement",
                "when a pane is split"
            ],
            "updatePoint": {
                "line": 44,
                "column": 98
            },
            "line": 44,
            "code": "  describe('when a pane is split', () => it('builds appropriately-oriented atom-pane-axis elements', function () {\n    const container = new PaneContainer(params);\n    const containerElement = container.getElement();\n    const pane1 = container.getActivePane();\n    const pane2 = pane1.splitRight();\n    const pane3 = pane2.splitDown();\n    const horizontalPanes = containerElement.querySelectorAll('atom-pane-container > atom-pane-axis.horizontal > atom-pane');\n    expect(horizontalPanes.length).toBe(1);\n    expect(horizontalPanes[0]).toBe(pane1.getElement());\n    let verticalPanes = containerElement.querySelectorAll('atom-pane-container > atom-pane-axis.horizontal > atom-pane-axis.vertical > atom-pane');\n    expect(verticalPanes.length).toBe(2);\n    expect(verticalPanes[0]).toBe(pane2.getElement());\n    expect(verticalPanes[1]).toBe(pane3.getElement());\n    pane1.destroy();\n    verticalPanes = containerElement.querySelectorAll('atom-pane-container > atom-pane-axis.vertical > atom-pane');\n    expect(verticalPanes.length).toBe(2);\n    expect(verticalPanes[0]).toBe(pane2.getElement());\n    expect(verticalPanes[1]).toBe(pane3.getElement());\n  }));",
            "file": "pane-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds and removes panes in the direction that the pane is being dragged",
            "suites": [
                "PaneContainerElement",
                "when the resize element is dragged "
            ],
            "updatePoint": {
                "line": 105,
                "column": 78
            },
            "line": 105,
            "code": "    it('adds and removes panes in the direction that the pane is being dragged', function () {\n      const leftPane = container.getActivePane();\n      expectPaneScale([leftPane, 1]);\n      const middlePane = leftPane.splitRight();\n      expectPaneScale([leftPane, 1], [middlePane, 1]);\n      dragElementToPosition(getResizeElement(0), getElementWidth(getPaneElement(0)) / 2);\n      expectPaneScale([leftPane, 0.5], [middlePane, 1.5]);\n      const rightPane = middlePane.splitRight();\n      expectPaneScale([leftPane, 0.5], [middlePane, 1.5], [rightPane, 1]);\n      dragElementToPosition(getResizeElement(1), getElementWidth(getPaneElement(0)) + getElementWidth(getPaneElement(1)) / 2);\n      expectPaneScale([leftPane, 0.5], [middlePane, 0.75], [rightPane, 1.75]);\n      waitsForPromise(() => middlePane.close());\n      runs(() => expectPaneScale([leftPane, 0.44], [rightPane, 1.55]));\n      waitsForPromise(() => leftPane.close());\n      runs(() => expectPaneScale([rightPane, 1]));\n    });",
            "file": "pane-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "splits or closes panes in orthogonal direction that the pane is being dragged",
            "suites": [
                "PaneContainerElement",
                "when the resize element is dragged "
            ],
            "updatePoint": {
                "line": 121,
                "column": 85
            },
            "line": 121,
            "code": "    it('splits or closes panes in orthogonal direction that the pane is being dragged', function () {\n      const leftPane = container.getActivePane();\n      expectPaneScale([leftPane, 1]);\n      const rightPane = leftPane.splitRight();\n      expectPaneScale([leftPane, 1], [rightPane, 1]);\n      dragElementToPosition(getResizeElement(0), getElementWidth(getPaneElement(0)) / 2);\n      expectPaneScale([leftPane, 0.5], [rightPane, 1.5]); // dynamically split pane, pane's flexScale will become to 1\n\n      const lowerPane = leftPane.splitDown();\n      expectPaneScale([lowerPane, 1], [leftPane, 1], [leftPane.getParent(), 0.5]); // dynamically close pane, the pane's flexscale will recover to origin value\n\n      waitsForPromise(() => lowerPane.close());\n      runs(() => expectPaneScale([leftPane, 0.5], [rightPane, 1.5]));\n    });",
            "file": "pane-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "unsubscribes from mouse events when the pane is detached",
            "suites": [
                "PaneContainerElement",
                "when the resize element is dragged "
            ],
            "updatePoint": {
                "line": 135,
                "column": 64
            },
            "line": 135,
            "code": "    it('unsubscribes from mouse events when the pane is detached', function () {\n      container.getActivePane().splitRight();\n      const element = getResizeElement(0);\n      spyOn(document, 'addEventListener').andCallThrough();\n      spyOn(document, 'removeEventListener').andCallThrough();\n      spyOn(element, 'resizeStopped').andCallThrough();\n      element.dispatchEvent(new MouseEvent('mousedown', {\n        view: window,\n        bubbles: true,\n        button: 0\n      }));\n      waitsFor(() => document.addEventListener.callCount === 2);\n      runs(function () {\n        expect(element.resizeStopped.callCount).toBe(0);\n        container.destroy();\n        expect(element.resizeStopped.callCount).toBe(1);\n        expect(document.removeEventListener.callCount).toBe(2);\n      });\n    });",
            "file": "pane-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw an error when resized to fit content in a detached state",
            "suites": [
                "PaneContainerElement",
                "when the resize element is dragged "
            ],
            "updatePoint": {
                "line": 154,
                "column": 79
            },
            "line": 154,
            "code": "    it('does not throw an error when resized to fit content in a detached state', function () {\n      container.getActivePane().splitRight();\n      const element = getResizeElement(0);\n      element.remove();\n      expect(() => element.resizeToFitContent()).not.toThrow();\n    });",
            "file": "pane-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "increases the size of the pane",
            "suites": [
                "PaneContainerElement",
                "pane resizing",
                "when pane:increase-size is triggered"
            ],
            "updatePoint": {
                "line": 168,
                "column": 93
            },
            "line": 168,
            "code": "    describe('when pane:increase-size is triggered', () => it('increases the size of the pane', function () {\n      expect(leftPane.getFlexScale()).toBe(1);\n      expect(rightPane.getFlexScale()).toBe(1);\n      atom.commands.dispatch(leftPane.getElement(), 'pane:increase-size');\n      expect(leftPane.getFlexScale()).toBe(1.1);\n      expect(rightPane.getFlexScale()).toBe(1);\n      atom.commands.dispatch(rightPane.getElement(), 'pane:increase-size');\n      expect(leftPane.getFlexScale()).toBe(1.1);\n      expect(rightPane.getFlexScale()).toBe(1.1);\n    }));",
            "file": "pane-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "decreases the size of the pane",
            "suites": [
                "PaneContainerElement",
                "pane resizing",
                "when pane:decrease-size is triggered"
            ],
            "updatePoint": {
                "line": 178,
                "column": 93
            },
            "line": 178,
            "code": "    describe('when pane:decrease-size is triggered', () => it('decreases the size of the pane', function () {\n      expect(leftPane.getFlexScale()).toBe(1);\n      expect(rightPane.getFlexScale()).toBe(1);\n      atom.commands.dispatch(leftPane.getElement(), 'pane:decrease-size');\n      expect(leftPane.getFlexScale()).toBe(1 / 1.1);\n      expect(rightPane.getFlexScale()).toBe(1);\n      atom.commands.dispatch(rightPane.getElement(), 'pane:decrease-size');\n      expect(leftPane.getFlexScale()).toBe(1 / 1.1);\n      expect(rightPane.getFlexScale()).toBe(1 / 1.1);\n    }));",
            "file": "pane-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not increases the size of the pane",
            "suites": [
                "PaneContainerElement",
                "when only a single pane is present",
                "when pane:increase-size is triggered"
            ],
            "updatePoint": {
                "line": 195,
                "column": 102
            },
            "line": 195,
            "code": "    describe('when pane:increase-size is triggered', () => it('does not increases the size of the pane', function () {\n      expect(singlePane.getFlexScale()).toBe(1);\n      atom.commands.dispatch(singlePane.getElement(), 'pane:increase-size');\n      expect(singlePane.getFlexScale()).toBe(1);\n      atom.commands.dispatch(singlePane.getElement(), 'pane:increase-size');\n      expect(singlePane.getFlexScale()).toBe(1);\n    }));",
            "file": "pane-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not decreases the size of the pane",
            "suites": [
                "PaneContainerElement",
                "when only a single pane is present",
                "when pane:decrease-size is triggered"
            ],
            "updatePoint": {
                "line": 202,
                "column": 102
            },
            "line": 202,
            "code": "    describe('when pane:decrease-size is triggered', () => it('does not decreases the size of the pane', function () {\n      expect(singlePane.getFlexScale()).toBe(1);\n      atom.commands.dispatch(singlePane.getElement(), 'pane:decrease-size');\n      expect(singlePane.getFlexScale()).toBe(1);\n      atom.commands.dispatch(singlePane.getElement(), 'pane:decrease-size');\n      expect(singlePane.getFlexScale()).toBe(1);\n    }));",
            "file": "pane-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "preserves the focused pane across serialization",
            "suites": [
                "PaneContainer",
                "serialization"
            ],
            "updatePoint": {
                "line": 44,
                "column": 55
            },
            "line": 44,
            "code": "    it('preserves the focused pane across serialization', () => {\n      expect(pane3A.focused).toBe(true);\n      const containerB = new PaneContainer(params);\n      containerB.deserialize(containerA.serialize(), atom.deserializers);\n      const pane3B = containerB.getPanes()[2];\n      expect(pane3B.focused).toBe(true);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "preserves the active pane across serialization, independent of focus",
            "suites": [
                "PaneContainer",
                "serialization"
            ],
            "updatePoint": {
                "line": 51,
                "column": 76
            },
            "line": 51,
            "code": "    it('preserves the active pane across serialization, independent of focus', () => {\n      pane3A.activate();\n      expect(containerA.getActivePane()).toBe(pane3A);\n      const containerB = new PaneContainer(params);\n      containerB.deserialize(containerA.serialize(), atom.deserializers);\n      const pane3B = containerB.getPanes()[2];\n      expect(containerB.getActivePane()).toBe(pane3B);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "makes the first pane active if no pane exists for the activePaneId",
            "suites": [
                "PaneContainer",
                "serialization"
            ],
            "updatePoint": {
                "line": 59,
                "column": 74
            },
            "line": 59,
            "code": "    it('makes the first pane active if no pane exists for the activePaneId', () => {\n      pane3A.activate();\n      const state = containerA.serialize();\n      state.activePaneId = -22;\n      const containerB = new PaneContainer(params);\n      containerB.deserialize(state, atom.deserializers);\n      expect(containerB.getActivePane()).toBe(containerB.getPanes()[0]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "leaves the empty panes intact",
            "suites": [
                "PaneContainer",
                "serialization",
                "if there are empty panes after deserialization",
                "if the 'core.destroyEmptyPanes' config option is false (the default)"
            ],
            "updatePoint": {
                "line": 73,
                "column": 126
            },
            "line": 73,
            "code": "      describe(\"if the 'core.destroyEmptyPanes' config option is false (the default)\", () => it('leaves the empty panes intact', () => {\n        const state = containerA.serialize();\n        const containerB = new PaneContainer(params);\n        containerB.deserialize(state, atom.deserializers);\n        const [leftPane, column] = containerB.getRoot().getChildren();\n        const [topPane, bottomPane] = column.getChildren();\n        expect(leftPane.getItems().length).toBe(1);\n        expect(topPane.getItems().length).toBe(1);\n        expect(bottomPane.getItems().length).toBe(0);\n      }));",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes empty panes on deserialization",
            "suites": [
                "PaneContainer",
                "serialization",
                "if there are empty panes after deserialization",
                "if the 'core.destroyEmptyPanes' config option is true"
            ],
            "updatePoint": {
                "line": 83,
                "column": 120
            },
            "line": 83,
            "code": "      describe(\"if the 'core.destroyEmptyPanes' config option is true\", () => it('removes empty panes on deserialization', () => {\n        atom.config.set('core.destroyEmptyPanes', true);\n        const state = containerA.serialize();\n        const containerB = new PaneContainer(params);\n        containerB.deserialize(state, atom.deserializers);\n        const [leftPane, rightPane] = containerB.getRoot().getChildren();\n        expect(leftPane.getItems().length).toBe(1);\n        expect(rightPane.getItems().length).toBe(1);\n      }));",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not allow the root pane to be destroyed",
            "suites": [
                "PaneContainer",
                "serialization",
                "if there are empty panes after deserialization",
                "if the 'core.destroyEmptyPanes' config option is true"
            ],
            "updatePoint": {
                "line": 94,
                "column": 50
            },
            "line": 94,
            "code": "  it('does not allow the root pane to be destroyed', () => {\n    const container = new PaneContainer(params);\n    container.getRoot().destroy();\n    expect(container.getRoot()).toBeDefined();\n    expect(container.getRoot().isDestroyed()).toBe(false);\n  });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the first pane if no pane has been made active",
            "suites": [
                "PaneContainer",
                "::getActivePane()"
            ],
            "updatePoint": {
                "line": 106,
                "column": 62
            },
            "line": 106,
            "code": "    it('returns the first pane if no pane has been made active', () => {\n      expect(container.getActivePane()).toBe(pane1);\n      expect(pane1.isActive()).toBe(true);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the most pane on which ::activate() was most recently called",
            "suites": [
                "PaneContainer",
                "::getActivePane()"
            ],
            "updatePoint": {
                "line": 110,
                "column": 76
            },
            "line": 110,
            "code": "    it('returns the most pane on which ::activate() was most recently called', () => {\n      pane2 = pane1.splitRight();\n      pane2.activate();\n      expect(container.getActivePane()).toBe(pane2);\n      expect(pane1.isActive()).toBe(false);\n      expect(pane2.isActive()).toBe(true);\n      pane1.activate();\n      expect(container.getActivePane()).toBe(pane1);\n      expect(pane1.isActive()).toBe(true);\n      expect(pane2.isActive()).toBe(false);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the next pane if the current active pane is destroyed",
            "suites": [
                "PaneContainer",
                "::getActivePane()"
            ],
            "updatePoint": {
                "line": 121,
                "column": 69
            },
            "line": 121,
            "code": "    it('returns the next pane if the current active pane is destroyed', () => {\n      pane2 = pane1.splitRight();\n      pane2.activate();\n      pane2.destroy();\n      expect(container.getActivePane()).toBe(pane1);\n      expect(pane1.isActive()).toBe(true);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes observers when the active pane changes",
            "suites": [
                "PaneContainer",
                "::onDidChangeActivePane()"
            ],
            "updatePoint": {
                "line": 141,
                "column": 54
            },
            "line": 141,
            "code": "    it('invokes observers when the active pane changes', () => {\n      pane1.activate();\n      pane2.activate();\n      expect(observed).toEqual([pane1, pane2]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes observers when the active item of the active pane changes",
            "suites": [
                "PaneContainer",
                "::onDidChangeActivePaneItem()"
            ],
            "updatePoint": {
                "line": 159,
                "column": 73
            },
            "line": 159,
            "code": "    it('invokes observers when the active item of the active pane changes', () => {\n      pane2.activateNextItem();\n      pane2.activateNextItem();\n      expect(observed).toEqual([pane2.itemAtIndex(1), pane2.itemAtIndex(0)]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes observers when the active pane changes",
            "suites": [
                "PaneContainer",
                "::onDidChangeActivePaneItem()"
            ],
            "updatePoint": {
                "line": 164,
                "column": 54
            },
            "line": 164,
            "code": "    it('invokes observers when the active pane changes', () => {\n      pane1.activate();\n      pane2.activate();\n      expect(observed).toEqual([pane1.itemAtIndex(0), pane2.itemAtIndex(0)]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes observers once when the active item of the active pane changes",
            "suites": [
                "PaneContainer",
                "::onDidStopChangingActivePaneItem()"
            ],
            "updatePoint": {
                "line": 182,
                "column": 78
            },
            "line": 182,
            "code": "    it('invokes observers once when the active item of the active pane changes', () => {\n      pane2.activateNextItem();\n      pane2.activateNextItem();\n      expect(observed).toEqual([]);\n      advanceClock(100);\n      expect(observed).toEqual([pane2.itemAtIndex(0)]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes observers once when the active pane changes",
            "suites": [
                "PaneContainer",
                "::onDidStopChangingActivePaneItem()"
            ],
            "updatePoint": {
                "line": 189,
                "column": 59
            },
            "line": 189,
            "code": "    it('invokes observers once when the active pane changes', () => {\n      pane1.activate();\n      pane2.activate();\n      expect(observed).toEqual([]);\n      advanceClock(100);\n      expect(observed).toEqual([pane2.itemAtIndex(0)]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes observers when a pane is activated (even if it was already active)",
            "suites": [
                "PaneContainer",
                "::onDidActivatePane"
            ],
            "updatePoint": {
                "line": 198,
                "column": 82
            },
            "line": 198,
            "code": "    it('invokes observers when a pane is activated (even if it was already active)', () => {\n      const container = new PaneContainer(params);\n      container.getRoot().splitRight();\n      const [pane1, pane2] = container.getPanes();\n      const activatedPanes = [];\n      container.onDidActivatePane(pane => activatedPanes.push(pane));\n      pane1.activate();\n      pane1.activate();\n      pane2.activate();\n      pane2.activate();\n      expect(activatedPanes).toEqual([pane1, pane1, pane2, pane2]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes observers with all current and future panes",
            "suites": [
                "PaneContainer",
                "::observePanes()"
            ],
            "updatePoint": {
                "line": 212,
                "column": 59
            },
            "line": 212,
            "code": "    it('invokes observers with all current and future panes', () => {\n      const container = new PaneContainer(params);\n      container.getRoot().splitRight();\n      const [pane1, pane2] = container.getPanes();\n      const observed = [];\n      container.observePanes(pane => observed.push(pane));\n      const pane3 = pane2.splitDown();\n      const pane4 = pane2.splitRight();\n      expect(observed).toEqual([pane1, pane2, pane3, pane4]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes observers with all current and future pane items",
            "suites": [
                "PaneContainer",
                "::observePaneItems()"
            ],
            "updatePoint": {
                "line": 223,
                "column": 101
            },
            "line": 223,
            "code": "  describe('::observePaneItems()', () => it('invokes observers with all current and future pane items', () => {\n    const container = new PaneContainer(params);\n    container.getRoot().addItems([{}, {}]);\n    container.getRoot().splitRight({\n      items: [{}]\n    });\n    const pane2 = container.getPanes()[1];\n    const observed = [];\n    container.observePaneItems(pane => observed.push(pane));\n    const pane3 = pane2.splitDown({\n      items: [{}]\n    });\n    pane3.addItems([{}, {}]);\n    expect(observed).toEqual(container.getPaneItems());\n  }));",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true if the user saves all modified files when prompted",
            "suites": [
                "PaneContainer",
                "::confirmClose()"
            ],
            "updatePoint": {
                "line": 258,
                "column": 71
            },
            "line": 258,
            "code": "    it('returns true if the user saves all modified files when prompted', async () => {\n      confirm.andCallFake((options, callback) => callback(0));\n      const saved = await container.confirmClose();\n      expect(confirm).toHaveBeenCalled();\n      expect(saved).toBeTruthy();\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false if the user cancels saving any modified file",
            "suites": [
                "PaneContainer",
                "::confirmClose()"
            ],
            "updatePoint": {
                "line": 264,
                "column": 66
            },
            "line": 264,
            "code": "    it('returns false if the user cancels saving any modified file', async () => {\n      confirm.andCallFake((options, callback) => callback(1));\n      const saved = await container.confirmClose();\n      expect(confirm).toHaveBeenCalled();\n      expect(saved).toBeFalsy();\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the given callback when panes are added",
            "suites": [
                "PaneContainer",
                "::onDidAddPane(callback)"
            ],
            "updatePoint": {
                "line": 272,
                "column": 55
            },
            "line": 272,
            "code": "    it('invokes the given callback when panes are added', () => {\n      const container = new PaneContainer(params);\n      const events = [];\n      container.onDidAddPane(event => {\n        expect(container.getPanes().includes(event.pane)).toBe(true);\n        events.push(event);\n      });\n      const pane1 = container.getActivePane();\n      const pane2 = pane1.splitRight();\n      const pane3 = pane2.splitDown();\n      expect(events).toEqual([{\n        pane: pane2\n      }, {\n        pane: pane3\n      }]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the given callback before panes or their items are destroyed",
            "suites": [
                "PaneContainer",
                "::onWillDestroyPane(callback)"
            ],
            "updatePoint": {
                "line": 290,
                "column": 76
            },
            "line": 290,
            "code": "    it('invokes the given callback before panes or their items are destroyed', () => {\n      class TestItem {\n        constructor() {\n          this._isDestroyed = false;\n        }\n\n        destroy() {\n          this._isDestroyed = true;\n        }\n\n        isDestroyed() {\n          return this._isDestroyed;\n        }\n\n      }\n\n      const container = new PaneContainer(params);\n      const events = [];\n      container.onWillDestroyPane(event => {\n        const itemsDestroyed = event.pane.getItems().map(item => item.isDestroyed());\n        events.push([event, {\n          itemsDestroyed\n        }]);\n      });\n      const pane1 = container.getActivePane();\n      const pane2 = pane1.splitRight();\n      pane2.addItem(new TestItem());\n      pane2.destroy();\n      expect(events).toEqual([[{\n        pane: pane2\n      }, {\n        itemsDestroyed: [false]\n      }]]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the given callback when panes are destroyed",
            "suites": [
                "PaneContainer",
                "::onDidDestroyPane(callback)"
            ],
            "updatePoint": {
                "line": 326,
                "column": 59
            },
            "line": 326,
            "code": "    it('invokes the given callback when panes are destroyed', () => {\n      const container = new PaneContainer(params);\n      const events = [];\n      container.onDidDestroyPane(event => {\n        expect(container.getPanes().includes(event.pane)).toBe(false);\n        events.push(event);\n      });\n      const pane1 = container.getActivePane();\n      const pane2 = pane1.splitRight();\n      const pane3 = pane2.splitDown();\n      pane2.destroy();\n      pane3.destroy();\n      expect(events).toEqual([{\n        pane: pane2\n      }, {\n        pane: pane3\n      }]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the given callback when the container is destroyed",
            "suites": [
                "PaneContainer",
                "::onDidDestroyPane(callback)"
            ],
            "updatePoint": {
                "line": 344,
                "column": 66
            },
            "line": 344,
            "code": "    it('invokes the given callback when the container is destroyed', () => {\n      const container = new PaneContainer(params);\n      const events = [];\n      container.onDidDestroyPane(event => {\n        expect(container.getPanes().includes(event.pane)).toBe(false);\n        events.push(event);\n      });\n      const pane1 = container.getActivePane();\n      const pane2 = pane1.splitRight();\n      const pane3 = pane2.splitDown();\n      container.destroy();\n      expect(events).toEqual([{\n        pane: pane1\n      }, {\n        pane: pane2\n      }, {\n        pane: pane3\n      }]);\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the given callbacks when an item will be destroyed on any pane",
            "suites": [
                "PaneContainer",
                "::onWillDestroyPaneItem() and ::onDidDestroyPaneItem()"
            ],
            "updatePoint": {
                "line": 365,
                "column": 78
            },
            "line": 365,
            "code": "    it('invokes the given callbacks when an item will be destroyed on any pane', async () => {\n      const container = new PaneContainer(params);\n      const pane1 = container.getRoot();\n      const item1 = {};\n      const item2 = {};\n      const item3 = {};\n      pane1.addItem(item1);\n      const events = [];\n      container.onWillDestroyPaneItem(event => events.push(['will', event]));\n      container.onDidDestroyPaneItem(event => events.push(['did', event]));\n      const pane2 = pane1.splitRight({\n        items: [item2, item3]\n      });\n      await pane1.destroyItem(item1);\n      await pane2.destroyItem(item3);\n      await pane2.destroyItem(item2);\n      expect(events.length).toBe(6);\n      expect(events[1]).toEqual(['did', {\n        item: item1,\n        pane: pane1,\n        index: 0\n      }]);\n      expect(events[3]).toEqual(['did', {\n        item: item3,\n        pane: pane2,\n        index: 1\n      }]);\n      expect(events[5]).toEqual(['did', {\n        item: item2,\n        pane: pane2,\n        index: 0\n      }]);\n      expect(events[0][0]).toEqual('will');\n      expect(events[0][1].item).toEqual(item1);\n      expect(events[0][1].pane).toEqual(pane1);\n      expect(events[0][1].index).toEqual(0);\n      expect(typeof events[0][1].prevent).toEqual('function');\n      expect(events[2][0]).toEqual('will');\n      expect(events[2][1].item).toEqual(item3);\n      expect(events[2][1].pane).toEqual(pane2);\n      expect(events[2][1].index).toEqual(1);\n      expect(typeof events[2][1].prevent).toEqual('function');\n      expect(events[4][0]).toEqual('will');\n      expect(events[4][1].item).toEqual(item2);\n      expect(events[4][1].pane).toEqual(pane2);\n      expect(events[4][1].index).toEqual(0);\n      expect(typeof events[4][1].prevent).toEqual('function');\n    });",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "saves all modified pane items",
            "suites": [
                "PaneContainer",
                "::saveAll()"
            ],
            "updatePoint": {
                "line": 414,
                "column": 65
            },
            "line": 414,
            "code": "  describe('::saveAll()', () => it('saves all modified pane items', async () => {\n    const container = new PaneContainer(params);\n    const pane1 = container.getRoot();\n    pane1.splitRight();\n    const item1 = {\n      saved: false,\n\n      getURI() {\n        return '';\n      },\n\n      isModified() {\n        return true;\n      },\n\n      save() {\n        this.saved = true;\n      }\n\n    };\n    const item2 = {\n      saved: false,\n\n      getURI() {\n        return '';\n      },\n\n      isModified() {\n        return false;\n      },\n\n      save() {\n        this.saved = true;\n      }\n\n    };\n    const item3 = {\n      saved: false,\n\n      getURI() {\n        return '';\n      },\n\n      isModified() {\n        return true;\n      },\n\n      save() {\n        this.saved = true;\n      }\n\n    };\n    pane1.addItem(item1);\n    pane1.addItem(item2);\n    pane1.addItem(item3);\n    container.saveAll();\n    expect(item1.saved).toBe(true);\n    expect(item2.saved).toBe(false);\n    expect(item3.saved).toBe(true);\n  }));",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves active item to given pane and focuses it",
            "suites": [
                "PaneContainer",
                "::moveActiveItemToPane(destPane) and ::copyActiveItemToPane(destPane)",
                "::::moveActiveItemToPane(destPane)"
            ],
            "updatePoint": {
                "line": 495,
                "column": 107
            },
            "line": 495,
            "code": "    describe('::::moveActiveItemToPane(destPane)', () => it('moves active item to given pane and focuses it', () => {\n      container.moveActiveItemToPane(pane1);\n      expect(pane1.getActiveItem()).toBe(item1);\n    }));",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "copies active item to given pane and focuses it",
            "suites": [
                "PaneContainer",
                "::moveActiveItemToPane(destPane) and ::copyActiveItemToPane(destPane)",
                "::::copyActiveItemToPane(destPane)"
            ],
            "updatePoint": {
                "line": 499,
                "column": 108
            },
            "line": 499,
            "code": "    describe('::::copyActiveItemToPane(destPane)', () => it('copies active item to given pane and focuses it', () => {\n      container.copyActiveItemToPane(pane1);\n      expect(container.paneForItem(item1)).toBe(pane2);\n      expect(pane1.getActiveItem().id).toBe(item1.id);\n    }));",
            "file": "pane-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds or removes the .active class as appropriate",
            "suites": [
                "PaneElement",
                "when the pane's active status changes"
            ],
            "updatePoint": {
                "line": 18,
                "column": 110
            },
            "line": 18,
            "code": "  describe(\"when the pane's active status changes\", () => it('adds or removes the .active class as appropriate', function () {\n    const pane2 = pane.splitRight();\n    expect(pane2.isActive()).toBe(true);\n    expect(paneElement.className).not.toMatch(/active/);\n    pane.activate();\n    expect(paneElement.className).toMatch(/active/);\n    pane2.activate();\n    expect(paneElement.className).not.toMatch(/active/);\n  }));",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "hides all item elements except the active one",
            "suites": [
                "PaneElement",
                "when the active item changes"
            ],
            "updatePoint": {
                "line": 28,
                "column": 53
            },
            "line": 28,
            "code": "    it('hides all item elements except the active one', function () {\n      const item1 = document.createElement('div');\n      const item2 = document.createElement('div');\n      const item3 = document.createElement('div');\n      pane.addItem(item1);\n      pane.addItem(item2);\n      pane.addItem(item3);\n      expect(pane.getActiveItem()).toBe(item1);\n      expect(item1.parentElement).toBeDefined();\n      expect(item1.style.display).toBe('');\n      expect(item2.parentElement).toBeNull();\n      expect(item3.parentElement).toBeNull();\n      pane.activateItem(item2);\n      expect(item2.parentElement).toBeDefined();\n      expect(item1.style.display).toBe('none');\n      expect(item2.style.display).toBe('');\n      expect(item3.parentElement).toBeNull();\n      pane.activateItem(item3);\n      expect(item3.parentElement).toBeDefined();\n      expect(item1.style.display).toBe('none');\n      expect(item2.style.display).toBe('none');\n      expect(item3.style.display).toBe('');\n    });",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "transfers focus to the new item if the previous item was focused",
            "suites": [
                "PaneElement",
                "when the active item changes"
            ],
            "updatePoint": {
                "line": 51,
                "column": 72
            },
            "line": 51,
            "code": "    it('transfers focus to the new item if the previous item was focused', function () {\n      const item1 = document.createElement('div');\n      item1.tabIndex = -1;\n      const item2 = document.createElement('div');\n      item2.tabIndex = -1;\n      pane.addItem(item1);\n      pane.addItem(item2);\n      jasmine.attachToDOM(paneElement);\n      paneElement.focus();\n      expect(document.activeElement).toBe(item1);\n      pane.activateItem(item2);\n      expect(document.activeElement).toBe(item2);\n    });",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "retrieves the associated view from atom.views and appends it to the itemViews div",
            "suites": [
                "PaneElement",
                "when the active item changes",
                "if the active item is a model object"
            ],
            "updatePoint": {
                "line": 64,
                "column": 144
            },
            "line": 64,
            "code": "    describe('if the active item is a model object', () => it('retrieves the associated view from atom.views and appends it to the itemViews div', function () {\n      class TestModel {}\n\n      atom.views.addViewProvider(TestModel, function (model) {\n        const view = document.createElement('div');\n        view.model = model;\n        return view;\n      });\n      const item1 = new TestModel();\n      const item2 = new TestModel();\n      pane.addItem(item1);\n      pane.addItem(item2);\n      expect(paneElement.itemViews.children[0].model).toBe(item1);\n      expect(paneElement.itemViews.children[0].style.display).toBe('');\n      pane.activateItem(item2);\n      expect(paneElement.itemViews.children[1].model).toBe(item2);\n      expect(paneElement.itemViews.children[0].style.display).toBe('none');\n      expect(paneElement.itemViews.children[1].style.display).toBe('');\n    }));",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the file path and file name as a data attribute on the pane",
            "suites": [
                "PaneElement",
                "when the active item changes",
                "when the new active implements .getPath()"
            ],
            "updatePoint": {
                "line": 84,
                "column": 74
            },
            "line": 84,
            "code": "      it('adds the file path and file name as a data attribute on the pane', function () {\n        const item1 = document.createElement('div');\n\n        item1.getPath = () => '/foo/bar.txt';\n\n        const item2 = document.createElement('div');\n        pane.addItem(item1);\n        pane.addItem(item2);\n        expect(paneElement.dataset.activeItemPath).toBe('/foo/bar.txt');\n        expect(paneElement.dataset.activeItemName).toBe('bar.txt');\n        pane.activateItem(item2);\n        expect(paneElement.dataset.activeItemPath).toBeUndefined();\n        expect(paneElement.dataset.activeItemName).toBeUndefined();\n        pane.activateItem(item1);\n        expect(paneElement.dataset.activeItemPath).toBe('/foo/bar.txt');\n        expect(paneElement.dataset.activeItemName).toBe('bar.txt');\n        pane.destroyItems();\n        expect(paneElement.dataset.activeItemPath).toBeUndefined();\n        expect(paneElement.dataset.activeItemName).toBeUndefined();\n      });",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "changes the file path and file name data attributes on the pane if the active item path is changed",
            "suites": [
                "PaneElement",
                "when the active item changes",
                "when the new active implements .getPath()",
                "when the path of the item changes"
            ],
            "updatePoint": {
                "line": 136,
                "column": 110
            },
            "line": 136,
            "code": "        it('changes the file path and file name data attributes on the pane if the active item path is changed', function () {\n          expect(paneElement.dataset.activeItemPath).toBe('/foo/bar.txt');\n          expect(paneElement.dataset.activeItemName).toBe('bar.txt');\n          item1.setPath('/foo/bar1.txt');\n          expect(paneElement.dataset.activeItemPath).toBe('/foo/bar1.txt');\n          expect(paneElement.dataset.activeItemName).toBe('bar1.txt');\n          pane.activateItem(item2);\n          expect(paneElement.dataset.activeItemPath).toBeUndefined();\n          expect(paneElement.dataset.activeItemName).toBeUndefined();\n          item1.setPath('/foo/bar2.txt');\n          expect(paneElement.dataset.activeItemPath).toBeUndefined();\n          expect(paneElement.dataset.activeItemName).toBeUndefined();\n          pane.activateItem(item1);\n          expect(paneElement.dataset.activeItemPath).toBe('/foo/bar2.txt');\n          expect(paneElement.dataset.activeItemName).toBe('bar2.txt');\n        });",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the item from the itemViews div",
            "suites": [
                "PaneElement",
                "when an item is removed from the pane",
                "when the destroyed item is an element"
            ],
            "updatePoint": {
                "line": 156,
                "column": 103
            },
            "line": 156,
            "code": "    describe('when the destroyed item is an element', () => it('removes the item from the itemViews div', function () {\n      const item1 = document.createElement('div');\n      const item2 = document.createElement('div');\n      pane.addItem(item1);\n      pane.addItem(item2);\n      paneElement = pane.getElement();\n      expect(item1.parentElement).toBe(paneElement.itemViews);\n      pane.destroyItem(item1);\n      expect(item1.parentElement).toBeNull();\n      expect(item2.parentElement).toBe(paneElement.itemViews);\n      pane.destroyItem(item2);\n      expect(item2.parentElement).toBeNull();\n    }));",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the model's associated view",
            "suites": [
                "PaneElement",
                "when an item is removed from the pane",
                "when the destroyed item is a model"
            ],
            "updatePoint": {
                "line": 169,
                "column": 96
            },
            "line": 169,
            "code": "    describe('when the destroyed item is a model', () => it(\"removes the model's associated view\", function () {\n      class TestModel {}\n\n      atom.views.addViewProvider(TestModel, function (model) {\n        const view = document.createElement('div');\n        model.element = view;\n        view.model = model;\n        return view;\n      });\n      const item1 = new TestModel();\n      const item2 = new TestModel();\n      pane.addItem(item1);\n      pane.addItem(item2);\n      expect(item1.element.parentElement).toBe(paneElement.itemViews);\n      pane.destroyItem(item1);\n      expect(item1.element.parentElement).toBeNull();\n      expect(item2.element.parentElement).toBe(paneElement.itemViews);\n      pane.destroyItem(item2);\n      expect(item2.element.parentElement).toBeNull();\n    }));",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "transfers focus to the active view",
            "suites": [
                "PaneElement",
                "when the pane element is focused"
            ],
            "updatePoint": {
                "line": 191,
                "column": 42
            },
            "line": 191,
            "code": "    it('transfers focus to the active view', function () {\n      const item = document.createElement('div');\n      item.tabIndex = -1;\n      pane.activateItem(item);\n      jasmine.attachToDOM(paneElement);\n      expect(document.activeElement).toBe(document.body);\n      paneElement.focus();\n      expect(document.activeElement).toBe(item);\n      document.body.focus();\n      pane.activate();\n      expect(document.activeElement).toBe(item);\n    });",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "makes the pane active",
            "suites": [
                "PaneElement",
                "when the pane element is focused"
            ],
            "updatePoint": {
                "line": 203,
                "column": 29
            },
            "line": 203,
            "code": "    it('makes the pane active', function () {\n      pane.splitRight();\n      expect(pane.isActive()).toBe(false);\n      jasmine.attachToDOM(paneElement);\n      paneElement.focus();\n      expect(pane.isActive()).toBe(true);\n    });",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not re-activate the pane when focus changes within the pane",
            "suites": [
                "PaneElement",
                "when the pane element is focused"
            ],
            "updatePoint": {
                "line": 210,
                "column": 72
            },
            "line": 210,
            "code": "    it('does not re-activate the pane when focus changes within the pane', function () {\n      const item = document.createElement('div');\n      const itemChild = document.createElement('div');\n      item.tabIndex = -1;\n      itemChild.tabIndex = -1;\n      item.appendChild(itemChild);\n      jasmine.attachToDOM(paneElement);\n      pane.activateItem(item);\n      pane.activate();\n      let activationCount = 0;\n      pane.onDidActivate(() => activationCount++);\n      itemChild.focus();\n      expect(activationCount).toBe(0);\n    });",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses the pane element if isFocused() returns true on its model",
            "suites": [
                "PaneElement",
                "when the pane element is attached"
            ],
            "updatePoint": {
                "line": 225,
                "column": 123
            },
            "line": 225,
            "code": "  describe('when the pane element is attached', () => it('focuses the pane element if isFocused() returns true on its model', function () {\n    pane.focus();\n    jasmine.attachToDOM(paneElement);\n    expect(document.activeElement).toBe(paneElement);\n  }));",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens it",
            "suites": [
                "PaneElement",
                "drag and drop",
                "when a file is dragged to the pane"
            ],
            "updatePoint": {
                "line": 250,
                "column": 69
            },
            "line": 250,
            "code": "    describe('when a file is dragged to the pane', () => it('opens it', function () {\n      const event = buildDragEvent('drop', [{\n        path: '/fake1'\n      }, {\n        path: '/fake2'\n      }]);\n      paneElement.dispatchEvent(event);\n      expect(atom.applicationDelegate.open.callCount).toBe(1);\n      expect(atom.applicationDelegate.open.argsForCall[0][0]).toEqual({\n        pathsToOpen: ['/fake1', '/fake2'],\n        here: true\n      });\n    }));",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing",
            "suites": [
                "PaneElement",
                "drag and drop",
                "when a non-file is dragged to the pane"
            ],
            "updatePoint": {
                "line": 263,
                "column": 77
            },
            "line": 263,
            "code": "    describe('when a non-file is dragged to the pane', () => it('does nothing', function () {\n      const event = buildDragEvent('drop', []);\n      paneElement.dispatchEvent(event);\n      expect(atom.applicationDelegate.open).not.toHaveBeenCalled();\n    }));",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shrinks independently of its contents' width",
            "suites": [
                "PaneElement",
                "resize"
            ],
            "updatePoint": {
                "line": 269,
                "column": 75
            },
            "line": 269,
            "code": "  describe('resize', () => it(\"shrinks independently of its contents' width\", function () {\n    jasmine.attachToDOM(containerElement);\n    const item = document.createElement('div');\n    item.style.width = '2000px';\n    item.style.height = '30px';\n    paneElement.insertBefore(item, paneElement.children[0]);\n    paneElement.style.flexGrow = 0.1;\n    expect(paneElement.getBoundingClientRect().width).toBeGreaterThan(0);\n    expect(paneElement.getBoundingClientRect().width).toBeLessThan(item.getBoundingClientRect().width);\n    paneElement.style.flexGrow = 0;\n    expect(paneElement.getBoundingClientRect().width).toBe(0);\n  }));",
            "file": "pane-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the active item to the first item",
            "suites": [
                "Pane",
                "construction"
            ],
            "updatePoint": {
                "line": 108,
                "column": 46
            },
            "line": 108,
            "code": "    it('sets the active item to the first item', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B')]\n      }));\n      expect(pane.getActiveItem()).toBe(pane.itemAtIndex(0));\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "compacts the items array",
            "suites": [
                "Pane",
                "construction"
            ],
            "updatePoint": {
                "line": 114,
                "column": 32
            },
            "line": 114,
            "code": "    it('compacts the items array', () => {\n      const pane = new Pane(paneParams({\n        items: [undefined, new Item('A'), null, new Item('B')]\n      }));\n      expect(pane.getItems().length).toBe(2);\n      expect(pane.getActiveItem()).toBe(pane.itemAtIndex(0));\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "changes the active pane on the container",
            "suites": [
                "Pane",
                "::activate()"
            ],
            "updatePoint": {
                "line": 133,
                "column": 48
            },
            "line": 133,
            "code": "    it('changes the active pane on the container', () => {\n      expect(container.getActivePane()).toBe(pane2);\n      pane1.activate();\n      expect(container.getActivePane()).toBe(pane1);\n      pane2.activate();\n      expect(container.getActivePane()).toBe(pane2);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidChangeActivePane observers on the container",
            "suites": [
                "Pane",
                "::activate()"
            ],
            "updatePoint": {
                "line": 140,
                "column": 66
            },
            "line": 140,
            "code": "    it('invokes ::onDidChangeActivePane observers on the container', () => {\n      const observed = [];\n      container.onDidChangeActivePane(activePane => observed.push(activePane));\n      pane1.activate();\n      pane1.activate();\n      pane2.activate();\n      pane1.activate();\n      expect(observed).toEqual([pane1, pane2, pane1]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidChangeActive observers on the relevant panes",
            "suites": [
                "Pane",
                "::activate()"
            ],
            "updatePoint": {
                "line": 149,
                "column": 67
            },
            "line": 149,
            "code": "    it('invokes ::onDidChangeActive observers on the relevant panes', () => {\n      const observed = [];\n      pane1.onDidChangeActive(active => observed.push(active));\n      pane1.activate();\n      pane2.activate();\n      expect(observed).toEqual([true, false]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidActivate() observers",
            "suites": [
                "Pane",
                "::activate()"
            ],
            "updatePoint": {
                "line": 156,
                "column": 43
            },
            "line": 156,
            "code": "    it('invokes ::onDidActivate() observers', () => {\n      let eventCount = 0;\n      pane1.onDidActivate(() => eventCount++);\n      pane1.activate();\n      pane1.activate();\n      pane2.activate();\n      expect(eventCount).toBe(2);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the item at the given index",
            "suites": [
                "Pane",
                "::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 166,
                "column": 40
            },
            "line": 166,
            "code": "    it('adds the item at the given index', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B')]\n      }));\n      const [item1, item2] = pane.getItems();\n      const item3 = new Item('C');\n      pane.addItem(item3, {\n        index: 1\n      });\n      expect(pane.getItems()).toEqual([item1, item3, item2]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the item after the active item if no index is provided",
            "suites": [
                "Pane",
                "::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 177,
                "column": 67
            },
            "line": 177,
            "code": "    it('adds the item after the active item if no index is provided', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B'), new Item('C')]\n      }));\n      const [item1, item2, item3] = pane.getItems();\n      pane.activateItem(item2);\n      const item4 = new Item('D');\n      pane.addItem(item4);\n      expect(pane.getItems()).toEqual([item1, item2, item4, item3]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the active item after adding the first item",
            "suites": [
                "Pane",
                "::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 187,
                "column": 56
            },
            "line": 187,
            "code": "    it('sets the active item after adding the first item', () => {\n      const pane = new Pane(paneParams());\n      const item = new Item('A');\n      pane.addItem(item);\n      expect(pane.getActiveItem()).toBe(item);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidAddItem() observers",
            "suites": [
                "Pane",
                "::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 193,
                "column": 42
            },
            "line": 193,
            "code": "    it('invokes ::onDidAddItem() observers', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B')]\n      }));\n      const events = [];\n      pane.onDidAddItem(event => events.push(event));\n      const item = new Item('C');\n      pane.addItem(item, {\n        index: 1\n      });\n      expect(events).toEqual([{\n        item,\n        index: 1,\n        moved: false\n      }]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an exception if the item is already present on a pane",
            "suites": [
                "Pane",
                "::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 209,
                "column": 68
            },
            "line": 209,
            "code": "    it('throws an exception if the item is already present on a pane', () => {\n      const item = new Item('A');\n      const container = new PaneContainer({\n        config: atom.config,\n        applicationDelegate: atom.applicationDelegate\n      });\n      const pane1 = container.getActivePane();\n      pane1.addItem(item);\n      const pane2 = pane1.splitRight();\n      expect(() => pane2.addItem(item)).toThrow();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an exception if the item isn't an object",
            "suites": [
                "Pane",
                "::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 220,
                "column": 55
            },
            "line": 220,
            "code": "    it(\"throws an exception if the item isn't an object\", () => {\n      const pane = new Pane(paneParams({\n        items: []\n      }));\n      expect(() => pane.addItem(null)).toThrow();\n      expect(() => pane.addItem('foo')).toThrow();\n      expect(() => pane.addItem(1)).toThrow();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys any existing pending item",
            "suites": [
                "Pane",
                "::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 228,
                "column": 42
            },
            "line": 228,
            "code": "    it('destroys any existing pending item', () => {\n      const pane = new Pane(paneParams({\n        items: []\n      }));\n      const itemA = new Item('A');\n      const itemB = new Item('B');\n      const itemC = new Item('C');\n      pane.addItem(itemA, {\n        pending: false\n      });\n      pane.addItem(itemB, {\n        pending: true\n      });\n      pane.addItem(itemC, {\n        pending: false\n      });\n      expect(itemB.isDestroyed()).toBe(true);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the new item before destroying any existing pending item",
            "suites": [
                "Pane",
                "::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 246,
                "column": 69
            },
            "line": 246,
            "code": "    it('adds the new item before destroying any existing pending item', () => {\n      const eventOrder = [];\n      const pane = new Pane(paneParams({\n        items: []\n      }));\n      const itemA = new Item('A');\n      const itemB = new Item('B');\n      pane.addItem(itemA, {\n        pending: true\n      });\n      pane.onDidAddItem(function ({\n        item\n      }) {\n        if (item === itemB) eventOrder.push('add');\n      });\n      pane.onDidRemoveItem(function ({\n        item\n      }) {\n        if (item === itemA) eventOrder.push('remove');\n      });\n      pane.addItem(itemB);\n      waitsFor(() => eventOrder.length === 2);\n      runs(() => expect(eventOrder).toEqual(['add', 'remove']));\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "subscribes to be notified when item terminates its pending state",
            "suites": [
                "Pane",
                "::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 270,
                "column": 72
            },
            "line": 270,
            "code": "    it('subscribes to be notified when item terminates its pending state', () => {\n      const fakeDisposable = {\n        dispose: () => {}\n      };\n      const spy = jasmine.createSpy('onDidTerminatePendingState').andReturn(fakeDisposable);\n      const pane = new Pane(paneParams({\n        items: []\n      }));\n      const item = {\n        getTitle: () => '',\n        onDidTerminatePendingState: spy\n      };\n      pane.addItem(item);\n      expect(spy).toHaveBeenCalled();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "subscribes to be notified when item is destroyed",
            "suites": [
                "Pane",
                "::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 285,
                "column": 56
            },
            "line": 285,
            "code": "    it('subscribes to be notified when item is destroyed', () => {\n      const fakeDisposable = {\n        dispose: () => {}\n      };\n      const spy = jasmine.createSpy('onDidDestroy').andReturn(fakeDisposable);\n      const pane = new Pane(paneParams({\n        items: []\n      }));\n      const item = {\n        getTitle: () => '',\n        onDidDestroy: spy\n      };\n      pane.addItem(item);\n      expect(spy).toHaveBeenCalled();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "supports the older public API",
            "suites": [
                "Pane",
                "::addItem(item, index)",
                "when using the old API of ::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 302,
                "column": 39
            },
            "line": 302,
            "code": "      it('supports the older public API', () => {\n        const pane = new Pane(paneParams({\n          items: []\n        }));\n        const itemA = new Item('A');\n        const itemB = new Item('B');\n        const itemC = new Item('C');\n        pane.addItem(itemA, 0);\n        pane.addItem(itemB, 0);\n        pane.addItem(itemC, 0);\n        expect(pane.getItems()).toEqual([itemC, itemB, itemA]);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shows a deprecation warning",
            "suites": [
                "Pane",
                "::addItem(item, index)",
                "when using the old API of ::addItem(item, index)"
            ],
            "updatePoint": {
                "line": 314,
                "column": 37
            },
            "line": 314,
            "code": "      it('shows a deprecation warning', () => {\n        const pane = new Pane(paneParams({\n          items: []\n        }));\n        pane.addItem(new Item(), 2);\n        expect(Grim.deprecate).toHaveBeenCalledWith('Pane::addItem(item, 2) is deprecated in favor of Pane::addItem(item, {index: 2})');\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "changes the active item to the current item",
            "suites": [
                "Pane",
                "::activateItem(item)"
            ],
            "updatePoint": {
                "line": 330,
                "column": 51
            },
            "line": 330,
            "code": "    it('changes the active item to the current item', () => {\n      expect(pane.getActiveItem()).toBe(pane.itemAtIndex(0));\n      pane.activateItem(pane.itemAtIndex(1));\n      expect(pane.getActiveItem()).toBe(pane.itemAtIndex(1));\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the given item if it isn't present in ::items",
            "suites": [
                "Pane",
                "::activateItem(item)"
            ],
            "updatePoint": {
                "line": 335,
                "column": 58
            },
            "line": 335,
            "code": "    it(\"adds the given item if it isn't present in ::items\", () => {\n      const item = new Item('C');\n      pane.activateItem(item);\n      expect(pane.getItems().includes(item)).toBe(true);\n      expect(pane.getActiveItem()).toBe(item);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidChangeActiveItem() observers",
            "suites": [
                "Pane",
                "::activateItem(item)"
            ],
            "updatePoint": {
                "line": 341,
                "column": 51
            },
            "line": 341,
            "code": "    it('invokes ::onDidChangeActiveItem() observers', () => {\n      const observed = [];\n      pane.onDidChangeActiveItem(item => observed.push(item));\n      pane.activateItem(pane.itemAtIndex(1));\n      expect(observed).toEqual([pane.itemAtIndex(1)]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces the active item if it is pending",
            "suites": [
                "Pane",
                "::activateItem(item)",
                "when the item being activated is pending"
            ],
            "updatePoint": {
                "line": 354,
                "column": 51
            },
            "line": 354,
            "code": "      it('replaces the active item if it is pending', () => {\n        pane.activateItem(itemC, {\n          pending: true\n        });\n        expect(pane.getItems().map(item => item.name)).toEqual(['A', 'C', 'B']);\n        pane.activateItem(itemD, {\n          pending: true\n        });\n        expect(pane.getItems().map(item => item.name)).toEqual(['A', 'D', 'B']);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the item after the active item if it is not pending",
            "suites": [
                "Pane",
                "::activateItem(item)",
                "when the item being activated is pending"
            ],
            "updatePoint": {
                "line": 364,
                "column": 66
            },
            "line": 364,
            "code": "      it('adds the item after the active item if it is not pending', () => {\n        pane.activateItem(itemC, {\n          pending: true\n        });\n        pane.activateItemAtIndex(2);\n        pane.activateItem(itemD, {\n          pending: true\n        });\n        expect(pane.getItems().map(item => item.name)).toEqual(['A', 'B', 'D']);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "changes the pending item",
            "suites": [
                "Pane",
                "::setPendingItem"
            ],
            "updatePoint": {
                "line": 381,
                "column": 32
            },
            "line": 381,
            "code": "    it('changes the pending item', () => {\n      expect(pane.getPendingItem()).toBeNull();\n      pane.setPendingItem('fake item');\n      expect(pane.getPendingItem()).toEqual('fake item');\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is called when the pending item changes",
            "suites": [
                "Pane",
                "::onItemDidTerminatePendingState callback"
            ],
            "updatePoint": {
                "line": 394,
                "column": 47
            },
            "line": 394,
            "code": "    it('is called when the pending item changes', () => {\n      pane.setPendingItem('fake item one');\n      pane.onItemDidTerminatePendingState(function (item) {\n        callbackCalled = true;\n        expect(item).toEqual('fake item one');\n      });\n      pane.setPendingItem('fake item two');\n      expect(callbackCalled).toBeTruthy();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "has access to the new pending item via ::getPendingItem",
            "suites": [
                "Pane",
                "::onItemDidTerminatePendingState callback"
            ],
            "updatePoint": {
                "line": 403,
                "column": 63
            },
            "line": 403,
            "code": "    it('has access to the new pending item via ::getPendingItem', () => {\n      pane.setPendingItem('fake item one');\n      pane.onItemDidTerminatePendingState(function (item) {\n        callbackCalled = true;\n        expect(pane.getPendingItem()).toEqual('fake item two');\n      });\n      pane.setPendingItem('fake item two');\n      expect(callbackCalled).toBeTruthy();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "isn't called when a pending item is replaced with a new one",
            "suites": [
                "Pane",
                "::onItemDidTerminatePendingState callback"
            ],
            "updatePoint": {
                "line": 412,
                "column": 67
            },
            "line": 412,
            "code": "    it(\"isn't called when a pending item is replaced with a new one\", async () => {\n      pane = null;\n      const pendingSpy = jasmine.createSpy('onItemDidTerminatePendingState');\n      const destroySpy = jasmine.createSpy('onWillDestroyItem');\n      await atom.workspace.open('sample.txt', {\n        pending: true\n      });\n      pane = atom.workspace.getActivePane();\n      pane.onItemDidTerminatePendingState(pendingSpy);\n      pane.onWillDestroyItem(destroySpy);\n      await atom.workspace.open('sample.js', {\n        pending: true\n      });\n      expect(destroySpy).toHaveBeenCalled();\n      expect(pendingSpy).not.toHaveBeenCalled();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the active item to the next/previous item in the itemStack, looping around at either end",
            "suites": [
                "Pane",
                "::activateNextRecentlyUsedItem() and ::activatePreviousRecentlyUsedItem()"
            ],
            "updatePoint": {
                "line": 430,
                "column": 101
            },
            "line": 430,
            "code": "    it('sets the active item to the next/previous item in the itemStack, looping around at either end', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B'), new Item('C'), new Item('D'), new Item('E')]\n      }));\n      const [item1, item2, item3, item4, item5] = pane.getItems();\n      pane.itemStack = [item3, item1, item2, item5, item4];\n      pane.activateItem(item4);\n      expect(pane.getActiveItem()).toBe(item4);\n      pane.activateNextRecentlyUsedItem();\n      expect(pane.getActiveItem()).toBe(item5);\n      pane.activateNextRecentlyUsedItem();\n      expect(pane.getActiveItem()).toBe(item2);\n      pane.activatePreviousRecentlyUsedItem();\n      expect(pane.getActiveItem()).toBe(item5);\n      pane.activatePreviousRecentlyUsedItem();\n      expect(pane.getActiveItem()).toBe(item4);\n      pane.activatePreviousRecentlyUsedItem();\n      expect(pane.getActiveItem()).toBe(item3);\n      pane.activatePreviousRecentlyUsedItem();\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.activateNextRecentlyUsedItem();\n      expect(pane.getActiveItem()).toBe(item3);\n      pane.activateNextRecentlyUsedItem();\n      expect(pane.getActiveItem()).toBe(item4);\n      pane.activateNextRecentlyUsedItem();\n      pane.moveActiveItemToTopOfStack();\n      expect(pane.getActiveItem()).toBe(item5);\n      expect(pane.itemStack[4]).toBe(item5);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the active item to the next/previous item, looping around at either end",
            "suites": [
                "Pane",
                "::activateNextItem() and ::activatePreviousItem()"
            ],
            "updatePoint": {
                "line": 461,
                "column": 84
            },
            "line": 461,
            "code": "    it('sets the active item to the next/previous item, looping around at either end', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B'), new Item('C')]\n      }));\n      const [item1, item2, item3] = pane.getItems();\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.activatePreviousItem();\n      expect(pane.getActiveItem()).toBe(item3);\n      pane.activatePreviousItem();\n      expect(pane.getActiveItem()).toBe(item2);\n      pane.activateNextItem();\n      expect(pane.getActiveItem()).toBe(item3);\n      pane.activateNextItem();\n      expect(pane.getActiveItem()).toBe(item1);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the active item to the last item",
            "suites": [
                "Pane",
                "::activateLastItem()"
            ],
            "updatePoint": {
                "line": 478,
                "column": 45
            },
            "line": 478,
            "code": "    it('sets the active item to the last item', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B'), new Item('C')]\n      }));\n      const [item1,, item3] = pane.getItems();\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.activateLastItem();\n      expect(pane.getActiveItem()).toBe(item3);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the active item to the right and left, without looping around at either end",
            "suites": [
                "Pane",
                "::moveItemRight() and ::moveItemLeft()"
            ],
            "updatePoint": {
                "line": 489,
                "column": 89
            },
            "line": 489,
            "code": "    it('moves the active item to the right and left, without looping around at either end', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B'), new Item('C')]\n      }));\n      const [item1, item2, item3] = pane.getItems();\n      pane.activateItemAtIndex(0);\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.moveItemLeft();\n      expect(pane.getItems()).toEqual([item1, item2, item3]);\n      pane.moveItemRight();\n      expect(pane.getItems()).toEqual([item2, item1, item3]);\n      pane.moveItemLeft();\n      expect(pane.getItems()).toEqual([item1, item2, item3]);\n      pane.activateItemAtIndex(2);\n      expect(pane.getActiveItem()).toBe(item3);\n      pane.moveItemRight();\n      expect(pane.getItems()).toEqual([item1, item2, item3]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the item at the given index",
            "suites": [
                "Pane",
                "::activateItemAtIndex(index)"
            ],
            "updatePoint": {
                "line": 509,
                "column": 45
            },
            "line": 509,
            "code": "    it('activates the item at the given index', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B'), new Item('C')]\n      }));\n      const [item1, item2, item3] = pane.getItems();\n      pane.activateItemAtIndex(2);\n      expect(pane.getActiveItem()).toBe(item3);\n      pane.activateItemAtIndex(1);\n      expect(pane.getActiveItem()).toBe(item2);\n      pane.activateItemAtIndex(0);\n      expect(pane.getActiveItem()).toBe(item1); // Doesn't fail with out-of-bounds indices\n\n      pane.activateItemAtIndex(100);\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.activateItemAtIndex(-1);\n      expect(pane.getActiveItem()).toBe(item1);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the item from the items list and destroys it",
            "suites": [
                "Pane",
                "::destroyItem(item)"
            ],
            "updatePoint": {
                "line": 535,
                "column": 60
            },
            "line": 535,
            "code": "    it('removes the item from the items list and destroys it', () => {\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.destroyItem(item2);\n      expect(pane.getItems().includes(item2)).toBe(false);\n      expect(item2.isDestroyed()).toBe(true);\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.destroyItem(item1);\n      expect(pane.getItems().includes(item1)).toBe(false);\n      expect(item1.isDestroyed()).toBe(true);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the item from the itemStack",
            "suites": [
                "Pane",
                "::destroyItem(item)"
            ],
            "updatePoint": {
                "line": 545,
                "column": 43
            },
            "line": 545,
            "code": "    it('removes the item from the itemStack', () => {\n      pane.itemStack = [item2, item3, item1];\n      pane.activateItem(item1);\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.destroyItem(item3);\n      expect(pane.itemStack).toEqual([item2, item1]);\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.destroyItem(item1);\n      expect(pane.itemStack).toEqual([item2]);\n      expect(pane.getActiveItem()).toBe(item2);\n      pane.destroyItem(item2);\n      expect(pane.itemStack).toEqual([]);\n      expect(pane.getActiveItem()).toBeUndefined();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing if prevented",
            "suites": [
                "Pane",
                "::destroyItem(item)"
            ],
            "updatePoint": {
                "line": 559,
                "column": 33
            },
            "line": 559,
            "code": "    it('does nothing if prevented', () => {\n      const container = new PaneContainer({\n        config: atom.config,\n        deserializerManager: atom.deserializers,\n        applicationDelegate: atom.applicationDelegate\n      });\n      pane.setContainer(container);\n      container.onWillDestroyPaneItem(e => e.prevent());\n      pane.itemStack = [item2, item3, item1];\n      pane.activateItem(item1);\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.destroyItem(item3);\n      expect(pane.itemStack).toEqual([item2, item3, item1]);\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.destroyItem(item1);\n      expect(pane.itemStack).toEqual([item2, item3, item1]);\n      expect(pane.getActiveItem()).toBe(item1);\n      pane.destroyItem(item2);\n      expect(pane.itemStack).toEqual([item2, item3, item1]);\n      expect(pane.getActiveItem()).toBe(item1);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onWillDestroyItem() and PaneContainer::onWillDestroyPaneItem observers before destroying the item",
            "suites": [
                "Pane",
                "::destroyItem(item)"
            ],
            "updatePoint": {
                "line": 580,
                "column": 115
            },
            "line": 580,
            "code": "    it('invokes ::onWillDestroyItem() and PaneContainer::onWillDestroyPaneItem observers before destroying the item', async () => {\n      jasmine.useRealClock();\n      pane.container = new PaneContainer({\n        config: atom.config,\n        confirm\n      });\n      const events = [];\n      pane.onWillDestroyItem(async event => {\n        expect(item2.isDestroyed()).toBe(false);\n        await timeoutPromise(50);\n        expect(item2.isDestroyed()).toBe(false);\n        events.push(['will-destroy-item', event]);\n      });\n      pane.container.onWillDestroyPaneItem(async event => {\n        expect(item2.isDestroyed()).toBe(false);\n        await timeoutPromise(50);\n        expect(item2.isDestroyed()).toBe(false);\n        events.push(['will-destroy-pane-item', event]);\n      });\n      await pane.destroyItem(item2);\n      expect(item2.isDestroyed()).toBe(true);\n      expect(events[0][0]).toEqual('will-destroy-item');\n      expect(events[0][1].item).toEqual(item2);\n      expect(events[0][1].index).toEqual(1);\n      expect(events[1][0]).toEqual('will-destroy-pane-item');\n      expect(events[1][1].item).toEqual(item2);\n      expect(events[1][1].index).toEqual(1);\n      expect(typeof events[1][1].prevent).toEqual('function');\n      expect(events[1][1].pane).toEqual(pane);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onWillRemoveItem() observers",
            "suites": [
                "Pane",
                "::destroyItem(item)"
            ],
            "updatePoint": {
                "line": 610,
                "column": 46
            },
            "line": 610,
            "code": "    it('invokes ::onWillRemoveItem() observers', () => {\n      const events = [];\n      pane.onWillRemoveItem(event => events.push(event));\n      pane.destroyItem(item2);\n      expect(events).toEqual([{\n        item: item2,\n        index: 1,\n        moved: false,\n        destroyed: true\n      }]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidRemoveItem() observers",
            "suites": [
                "Pane",
                "::destroyItem(item)"
            ],
            "updatePoint": {
                "line": 621,
                "column": 45
            },
            "line": 621,
            "code": "    it('invokes ::onDidRemoveItem() observers', () => {\n      const events = [];\n      pane.onDidRemoveItem(event => events.push(event));\n      pane.destroyItem(item2);\n      expect(events).toEqual([{\n        item: item2,\n        index: 1,\n        moved: false,\n        destroyed: true\n      }]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the next item",
            "suites": [
                "Pane",
                "::destroyItem(item)",
                "when the destroyed item is the active item and is the first item"
            ],
            "updatePoint": {
                "line": 633,
                "column": 33
            },
            "line": 633,
            "code": "      it('activates the next item', () => {\n        expect(pane.getActiveItem()).toBe(item1);\n        pane.destroyItem(item1);\n        expect(pane.getActiveItem()).toBe(item2);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the previous item",
            "suites": [
                "Pane",
                "::destroyItem(item)",
                "when the destroyed item is the active item and is not the first item"
            ],
            "updatePoint": {
                "line": 641,
                "column": 37
            },
            "line": 641,
            "code": "      it('activates the previous item', () => {\n        expect(pane.getActiveItem()).toBe(item2);\n        pane.destroyItem(item2);\n        expect(pane.getActiveItem()).toBe(item1);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "saves the item before destroying it",
            "suites": [
                "Pane",
                "::destroyItem(item)",
                "if the item is modified",
                "if the [Save] option is selected",
                "when the item has a uri"
            ],
            "updatePoint": {
                "line": 659,
                "column": 49
            },
            "line": 659,
            "code": "          it('saves the item before destroying it', async () => {\n            itemURI = 'test';\n            confirm.andCallFake((options, callback) => callback(0));\n            const success = await pane.destroyItem(item1);\n            expect(item1.save).toHaveBeenCalled();\n            expect(pane.getItems().includes(item1)).toBe(false);\n            expect(item1.isDestroyed()).toBe(true);\n            expect(success).toBe(true);\n          });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "presents a save-as dialog, then saves the item with the given uri before removing and destroying it",
            "suites": [
                "Pane",
                "::destroyItem(item)",
                "if the item is modified",
                "if the [Save] option is selected",
                "when the item has no uri"
            ],
            "updatePoint": {
                "line": 670,
                "column": 113
            },
            "line": 670,
            "code": "          it('presents a save-as dialog, then saves the item with the given uri before removing and destroying it', async () => {\n            jasmine.useRealClock();\n            itemURI = null;\n            showSaveDialog.andCallFake((options, callback) => callback('/selected/path'));\n            confirm.andCallFake((options, callback) => callback(0));\n            const success = await pane.destroyItem(item1);\n            expect(showSaveDialog.mostRecentCall.args[0]).toEqual({});\n            await conditionPromise(() => item1.saveAs.callCount === 1);\n            expect(item1.saveAs).toHaveBeenCalledWith('/selected/path');\n            expect(pane.getItems().includes(item1)).toBe(false);\n            expect(item1.isDestroyed()).toBe(true);\n            expect(success).toBe(true);\n          });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes and destroys the item without saving it",
            "suites": [
                "Pane",
                "::destroyItem(item)",
                "if the item is modified",
                "if the [Don't Save] option is selected"
            ],
            "updatePoint": {
                "line": 686,
                "column": 59
            },
            "line": 686,
            "code": "        it('removes and destroys the item without saving it', async () => {\n          confirm.andCallFake((options, callback) => callback(2));\n          const success = await pane.destroyItem(item1);\n          expect(item1.save).not.toHaveBeenCalled();\n          expect(pane.getItems().includes(item1)).toBe(false);\n          expect(item1.isDestroyed()).toBe(true);\n          expect(success).toBe(true);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not save, remove, or destroy the item",
            "suites": [
                "Pane",
                "::destroyItem(item)",
                "if the item is modified",
                "if the [Cancel] option is selected"
            ],
            "updatePoint": {
                "line": 696,
                "column": 54
            },
            "line": 696,
            "code": "        it('does not save, remove, or destroy the item', async () => {\n          confirm.andCallFake((options, callback) => callback(1));\n          const success = await pane.destroyItem(item1);\n          expect(item1.save).not.toHaveBeenCalled();\n          expect(pane.getItems().includes(item1)).toBe(true);\n          expect(item1.isDestroyed()).toBe(false);\n          expect(success).toBe(false);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys the item immediately",
            "suites": [
                "Pane",
                "::destroyItem(item)",
                "if the item is modified",
                "when force=true"
            ],
            "updatePoint": {
                "line": 706,
                "column": 41
            },
            "line": 706,
            "code": "        it('destroys the item immediately', async () => {\n          const success = await pane.destroyItem(item1, true);\n          expect(item1.save).not.toHaveBeenCalled();\n          expect(pane.getItems().includes(item1)).toBe(false);\n          expect(item1.isDestroyed()).toBe(true);\n          expect(success).toBe(true);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not destroy the pane, but leaves it in place with empty items",
            "suites": [
                "Pane",
                "::destroyItem(item)",
                "when the last item is destroyed",
                "when the 'core.destroyEmptyPanes' config option is false (the default)"
            ],
            "updatePoint": {
                "line": 717,
                "column": 78
            },
            "line": 717,
            "code": "        it('does not destroy the pane, but leaves it in place with empty items', () => {\n          expect(atom.config.get('core.destroyEmptyPanes')).toBe(false);\n\n          for (let item of pane.getItems()) {\n            pane.destroyItem(item);\n          }\n\n          expect(pane.isDestroyed()).toBe(false);\n          expect(pane.getActiveItem()).toBeUndefined();\n          expect(() => pane.saveActiveItem()).not.toThrow();\n          expect(() => pane.saveActiveItemAs()).not.toThrow();\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys the pane",
            "suites": [
                "Pane",
                "::destroyItem(item)",
                "when the last item is destroyed",
                "when the 'core.destroyEmptyPanes' config option is true"
            ],
            "updatePoint": {
                "line": 731,
                "column": 29
            },
            "line": 731,
            "code": "        it('destroys the pane', () => {\n          atom.config.set('core.destroyEmptyPanes', true);\n\n          for (let item of pane.getItems()) {\n            pane.destroyItem(item);\n          }\n\n          expect(pane.isDestroyed()).toBe(true);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't destroy the item",
            "suites": [
                "Pane",
                "::destroyItem(item)",
                "when passed a permanent dock item"
            ],
            "updatePoint": {
                "line": 743,
                "column": 34
            },
            "line": 743,
            "code": "      it(\"doesn't destroy the item\", async () => {\n        spyOn(item1, 'isPermanentDockItem').andReturn(true);\n        const success = await pane.destroyItem(item1);\n        expect(pane.getItems().includes(item1)).toBe(true);\n        expect(item1.isDestroyed()).toBe(false);\n        expect(success).toBe(false);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroy the item if force=true",
            "suites": [
                "Pane",
                "::destroyItem(item)",
                "when passed a permanent dock item"
            ],
            "updatePoint": {
                "line": 750,
                "column": 40
            },
            "line": 750,
            "code": "      it('destroy the item if force=true', async () => {\n        spyOn(item1, 'isPermanentDockItem').andReturn(true);\n        const success = await pane.destroyItem(item1, true);\n        expect(pane.getItems().includes(item1)).toBe(false);\n        expect(item1.isDestroyed()).toBe(true);\n        expect(success).toBe(true);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys the active item",
            "suites": [
                "Pane",
                "::destroyActiveItem()"
            ],
            "updatePoint": {
                "line": 760,
                "column": 32
            },
            "line": 760,
            "code": "    it('destroys the active item', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B')]\n      }));\n      const activeItem = pane.getActiveItem();\n      pane.destroyActiveItem();\n      expect(activeItem.isDestroyed()).toBe(true);\n      expect(pane.getItems().includes(activeItem)).toBe(false);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw an exception if there are no more items",
            "suites": [
                "Pane",
                "::destroyActiveItem()"
            ],
            "updatePoint": {
                "line": 769,
                "column": 62
            },
            "line": 769,
            "code": "    it('does not throw an exception if there are no more items', () => {\n      const pane = new Pane(paneParams());\n      pane.destroyActiveItem();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys all items",
            "suites": [
                "Pane",
                "::destroyItems()"
            ],
            "updatePoint": {
                "line": 775,
                "column": 26
            },
            "line": 775,
            "code": "    it('destroys all items', async () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B'), new Item('C')]\n      }));\n      const [item1, item2, item3] = pane.getItems();\n      await pane.destroyItems();\n      expect(item1.isDestroyed()).toBe(true);\n      expect(item2.isDestroyed()).toBe(true);\n      expect(item3.isDestroyed()).toBe(true);\n      expect(pane.getItems()).toEqual([]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the observer with all current and future items",
            "suites": [
                "Pane",
                "::observeItems()"
            ],
            "updatePoint": {
                "line": 788,
                "column": 62
            },
            "line": 788,
            "code": "    it('invokes the observer with all current and future items', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item(), new Item()]\n      }));\n      const [item1, item2] = pane.getItems();\n      const observed = [];\n      pane.observeItems(item => observed.push(item));\n      const item3 = new Item();\n      pane.addItem(item3);\n      expect(observed).toEqual([item1, item2, item3]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes it from the list of items",
            "suites": [
                "Pane",
                "when an item emits a destroyed event"
            ],
            "updatePoint": {
                "line": 801,
                "column": 41
            },
            "line": 801,
            "code": "    it('removes it from the list of items', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B'), new Item('C')]\n      }));\n      const [item1,, item3] = pane.getItems();\n      pane.itemAtIndex(1).destroy();\n      expect(pane.getItems()).toEqual([item1, item3]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys all items but the active item",
            "suites": [
                "Pane",
                "::destroyInactiveItems()"
            ],
            "updatePoint": {
                "line": 811,
                "column": 46
            },
            "line": 811,
            "code": "    it('destroys all items but the active item', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B'), new Item('C')]\n      }));\n      const [, item2] = pane.getItems();\n      pane.activateItem(item2);\n      pane.destroyInactiveItems();\n      expect(pane.getItems()).toEqual([item2]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "saves the current item",
            "suites": [
                "Pane",
                "::saveActiveItem()",
                "when the active item has a uri",
                "when the active item has a save method"
            ],
            "updatePoint": {
                "line": 834,
                "column": 34
            },
            "line": 834,
            "code": "        it('saves the current item', () => {\n          pane.getActiveItem().save = jasmine.createSpy('save');\n          pane.saveActiveItem();\n          expect(pane.getActiveItem().save).toHaveBeenCalled();\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing",
            "suites": [
                "Pane",
                "::saveActiveItem()",
                "when the active item has a uri",
                "when the current item has no save method"
            ],
            "updatePoint": {
                "line": 841,
                "column": 24
            },
            "line": 841,
            "code": "        it('does nothing', () => {\n          expect(pane.getActiveItem().save).toBeUndefined();\n          pane.saveActiveItem();\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens a save dialog and saves the current item as the selected path",
            "suites": [
                "Pane",
                "::saveActiveItem()",
                "when the current item has no uri",
                "when the current item has a saveAs method"
            ],
            "updatePoint": {
                "line": 849,
                "column": 79
            },
            "line": 849,
            "code": "        it('opens a save dialog and saves the current item as the selected path', async () => {\n          pane.getActiveItem().saveAs = jasmine.createSpy('saveAs');\n          await pane.saveActiveItem();\n          expect(showSaveDialog.mostRecentCall.args[0]).toEqual({});\n          expect(pane.getActiveItem().saveAs).toHaveBeenCalledWith('/selected/path');\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing",
            "suites": [
                "Pane",
                "::saveActiveItem()",
                "when the current item has no uri",
                "when the current item has no saveAs method"
            ],
            "updatePoint": {
                "line": 857,
                "column": 24
            },
            "line": 857,
            "code": "        it('does nothing', async () => {\n          expect(pane.getActiveItem().saveAs).toBeUndefined();\n          await pane.saveActiveItem();\n          expect(showSaveDialog).not.toHaveBeenCalled();\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing if the user cancels choosing a path",
            "suites": [
                "Pane",
                "::saveActiveItem()",
                "when the current item has no uri",
                "when the current item has no saveAs method"
            ],
            "updatePoint": {
                "line": 863,
                "column": 58
            },
            "line": 863,
            "code": "      it('does nothing if the user cancels choosing a path', async () => {\n        pane.getActiveItem().saveAs = jasmine.createSpy('saveAs');\n        showSaveDialog.andCallFake((options, callback) => callback(undefined));\n        await pane.saveActiveItem();\n        expect(pane.getActiveItem().saveAs).not.toHaveBeenCalled();\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a notification",
            "suites": [
                "Pane",
                "::saveActiveItem()",
                "when the item's saveAs rejects with a well-known IO error"
            ],
            "updatePoint": {
                "line": 871,
                "column": 32
            },
            "line": 871,
            "code": "      it('creates a notification', () => {\n        pane.getActiveItem().saveAs = () => {\n          const error = new Error(\"EACCES, permission denied '/foo'\");\n          error.path = '/foo';\n          error.code = 'EACCES';\n          return Promise.reject(error);\n        };\n\n        waitsFor(done => {\n          const subscription = atom.notifications.onDidAddNotification(function (notification) {\n            expect(notification.getType()).toBe('warning');\n            expect(notification.getMessage()).toContain('Permission denied');\n            expect(notification.getMessage()).toContain('/foo');\n            subscription.dispose();\n            done();\n          });\n          pane.saveActiveItem();\n        });\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a notification",
            "suites": [
                "Pane",
                "::saveActiveItem()",
                "when the item's saveAs throws a well-known IO error"
            ],
            "updatePoint": {
                "line": 892,
                "column": 32
            },
            "line": 892,
            "code": "      it('creates a notification', () => {\n        pane.getActiveItem().saveAs = () => {\n          const error = new Error(\"EACCES, permission denied '/foo'\");\n          error.path = '/foo';\n          error.code = 'EACCES';\n          throw error;\n        };\n\n        waitsFor(done => {\n          const subscription = atom.notifications.onDidAddNotification(function (notification) {\n            expect(notification.getType()).toBe('warning');\n            expect(notification.getMessage()).toContain('Permission denied');\n            expect(notification.getMessage()).toContain('/foo');\n            subscription.dispose();\n            done();\n          });\n          pane.saveActiveItem();\n        });\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the save dialog and calls saveAs on the item with the selected path",
            "suites": [
                "Pane",
                "::saveActiveItemAs()",
                "when the current item has a saveAs method"
            ],
            "updatePoint": {
                "line": 922,
                "column": 83
            },
            "line": 922,
            "code": "      it('opens the save dialog and calls saveAs on the item with the selected path', async () => {\n        jasmine.useRealClock();\n        pane.getActiveItem().path = __filename;\n        pane.getActiveItem().saveAs = jasmine.createSpy('saveAs');\n        pane.saveActiveItemAs();\n        expect(showSaveDialog.mostRecentCall.args[0]).toEqual({\n          defaultPath: __filename\n        });\n        await conditionPromise(() => pane.getActiveItem().saveAs.callCount === 1);\n        expect(pane.getActiveItem().saveAs).toHaveBeenCalledWith('/selected/path');\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing",
            "suites": [
                "Pane",
                "::saveActiveItemAs()",
                "when the current item does not have a saveAs method"
            ],
            "updatePoint": {
                "line": 935,
                "column": 22
            },
            "line": 935,
            "code": "      it('does nothing', () => {\n        expect(pane.getActiveItem().saveAs).toBeUndefined();\n        pane.saveActiveItemAs();\n        expect(showSaveDialog).not.toHaveBeenCalled();\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a notification",
            "suites": [
                "Pane",
                "::saveActiveItemAs()",
                "when the item's saveAs method throws a well-known IO error"
            ],
            "updatePoint": {
                "line": 942,
                "column": 32
            },
            "line": 942,
            "code": "      it('creates a notification', () => {\n        pane.getActiveItem().saveAs = () => {\n          const error = new Error(\"EACCES, permission denied '/foo'\");\n          error.path = '/foo';\n          error.code = 'EACCES';\n          return Promise.reject(error);\n        };\n\n        waitsFor(done => {\n          const subscription = atom.notifications.onDidAddNotification(function (notification) {\n            expect(notification.getType()).toBe('warning');\n            expect(notification.getMessage()).toContain('Permission denied');\n            expect(notification.getMessage()).toContain('/foo');\n            subscription.dispose();\n            done();\n          });\n          pane.saveActiveItemAs();\n        });\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the item for which a call to .getURI() returns the given uri",
            "suites": [
                "Pane",
                "::itemForURI(uri)"
            ],
            "updatePoint": {
                "line": 964,
                "column": 76
            },
            "line": 964,
            "code": "    it('returns the item for which a call to .getURI() returns the given uri', () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B'), new Item('C'), new Item('D')]\n      }));\n      const [item1, item2] = pane.getItems();\n      item1.uri = 'a';\n      item2.uri = 'b';\n      expect(pane.itemForURI('a')).toBe(item1);\n      expect(pane.itemForURI('b')).toBe(item2);\n      expect(pane.itemForURI('bogus')).toBeUndefined();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the item to the given index and invokes ::onDidMoveItem observers",
            "suites": [
                "Pane",
                "::moveItem(item, index)"
            ],
            "updatePoint": {
                "line": 984,
                "column": 79
            },
            "line": 984,
            "code": "    it('moves the item to the given index and invokes ::onDidMoveItem observers', () => {\n      pane.moveItem(item1, 2);\n      expect(pane.getItems()).toEqual([item2, item3, item1, item4]);\n      pane.moveItem(item2, 3);\n      expect(pane.getItems()).toEqual([item3, item1, item4, item2]);\n      pane.moveItem(item2, 1);\n      expect(pane.getItems()).toEqual([item3, item2, item1, item4]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidMoveItem() observers",
            "suites": [
                "Pane",
                "::moveItem(item, index)"
            ],
            "updatePoint": {
                "line": 992,
                "column": 43
            },
            "line": 992,
            "code": "    it('invokes ::onDidMoveItem() observers', () => {\n      const events = [];\n      pane.onDidMoveItem(event => events.push(event));\n      pane.moveItem(item1, 2);\n      pane.moveItem(item2, 3);\n      expect(events).toEqual([{\n        item: item1,\n        oldIndex: 0,\n        newIndex: 2\n      }, {\n        item: item2,\n        oldIndex: 0,\n        newIndex: 3\n      }]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the item to the given pane at the given index",
            "suites": [
                "Pane",
                "::moveItemToPane(item, pane, index)"
            ],
            "updatePoint": {
                "line": 1024,
                "column": 59
            },
            "line": 1024,
            "code": "    it('moves the item to the given pane at the given index', () => {\n      pane1.moveItemToPane(item2, pane2, 1);\n      expect(pane1.getItems()).toEqual([item1, item3]);\n      expect(pane2.getItems()).toEqual([item4, item2, item5]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onWillRemoveItem() observers",
            "suites": [
                "Pane",
                "::moveItemToPane(item, pane, index)"
            ],
            "updatePoint": {
                "line": 1029,
                "column": 46
            },
            "line": 1029,
            "code": "    it('invokes ::onWillRemoveItem() observers', () => {\n      const events = [];\n      pane1.onWillRemoveItem(event => events.push(event));\n      pane1.moveItemToPane(item2, pane2, 1);\n      expect(events).toEqual([{\n        item: item2,\n        index: 1,\n        moved: true,\n        destroyed: false\n      }]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onDidRemoveItem() observers",
            "suites": [
                "Pane",
                "::moveItemToPane(item, pane, index)"
            ],
            "updatePoint": {
                "line": 1040,
                "column": 45
            },
            "line": 1040,
            "code": "    it('invokes ::onDidRemoveItem() observers', () => {\n      const events = [];\n      pane1.onDidRemoveItem(event => events.push(event));\n      pane1.moveItemToPane(item2, pane2, 1);\n      expect(events).toEqual([{\n        item: item2,\n        index: 1,\n        moved: true,\n        destroyed: false\n      }]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not invoke ::onDidAddPaneItem observers on the container",
            "suites": [
                "Pane",
                "::moveItemToPane(item, pane, index)"
            ],
            "updatePoint": {
                "line": 1051,
                "column": 69
            },
            "line": 1051,
            "code": "    it('does not invoke ::onDidAddPaneItem observers on the container', () => {\n      const addedItems = [];\n      container.onDidAddPaneItem(item => addedItems.push(item));\n      pane1.moveItemToPane(item2, pane2, 1);\n      expect(addedItems).toEqual([]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not destroy the pane or the item",
            "suites": [
                "Pane",
                "::moveItemToPane(item, pane, index)",
                "when the moved item the last item in the source pane",
                "when the 'core.destroyEmptyPanes' config option is false (the default)"
            ],
            "updatePoint": {
                "line": 1060,
                "column": 49
            },
            "line": 1060,
            "code": "        it('does not destroy the pane or the item', () => {\n          pane2.moveItemToPane(item4, pane1, 0);\n          expect(pane2.isDestroyed()).toBe(false);\n          expect(item4.isDestroyed()).toBe(false);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys the pane, but not the item",
            "suites": [
                "Pane",
                "::moveItemToPane(item, pane, index)",
                "when the moved item the last item in the source pane",
                "when the 'core.destroyEmptyPanes' config option is true"
            ],
            "updatePoint": {
                "line": 1067,
                "column": 47
            },
            "line": 1067,
            "code": "        it('destroys the pane, but not the item', () => {\n          atom.config.set('core.destroyEmptyPanes', true);\n          pane2.moveItemToPane(item4, pane1, 0);\n          expect(pane2.isDestroyed()).toBe(true);\n          expect(item4.isDestroyed()).toBe(false);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is made permanent in the new pane",
            "suites": [
                "Pane",
                "::moveItemToPane(item, pane, index)",
                "when the item being moved is pending"
            ],
            "updatePoint": {
                "line": 1076,
                "column": 43
            },
            "line": 1076,
            "code": "      it('is made permanent in the new pane', () => {\n        const item6 = new Item('F');\n        pane1.addItem(item6, {\n          pending: true\n        });\n        expect(pane1.getPendingItem()).toEqual(item6);\n        pane1.moveItemToPane(item6, pane2, 0);\n        expect(pane2.getPendingItem()).not.toEqual(item6);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not destroy the pending item",
            "suites": [
                "Pane",
                "::moveItemToPane(item, pane, index)",
                "when the target pane has a pending item"
            ],
            "updatePoint": {
                "line": 1087,
                "column": 43
            },
            "line": 1087,
            "code": "      it('does not destroy the pending item', () => {\n        const item6 = new Item('F');\n        pane1.addItem(item6, {\n          pending: true\n        });\n        expect(pane1.getPendingItem()).toEqual(item6);\n        pane2.moveItemToPane(item5, pane1, 0);\n        expect(pane1.getPendingItem()).toEqual(item6);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces itself with a row and inserts a new pane to the left of itself",
            "suites": [
                "Pane",
                "split methods",
                "::splitLeft(params)",
                "when the parent is the container root"
            ],
            "updatePoint": {
                "line": 1112,
                "column": 83
            },
            "line": 1112,
            "code": "        it('replaces itself with a row and inserts a new pane to the left of itself', () => {\n          const pane2 = pane1.splitLeft({\n            items: [new Item('B')]\n          });\n          const pane3 = pane1.splitLeft({\n            items: [new Item('C')]\n          });\n          expect(container.root.orientation).toBe('horizontal');\n          expect(container.root.children).toEqual([pane2, pane3, pane1]);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the active item",
            "suites": [
                "Pane",
                "split methods",
                "::splitLeft(params)",
                "when `moveActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1124,
                "column": 33
            },
            "line": 1124,
            "code": "        it('moves the active item', () => {\n          const pane2 = pane1.splitLeft({\n            moveActiveItem: true\n          });\n          expect(pane2.getActiveItem()).toBe(item1);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "duplicates the active item",
            "suites": [
                "Pane",
                "split methods",
                "::splitLeft(params)",
                "when `copyActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1132,
                "column": 38
            },
            "line": 1132,
            "code": "        it('duplicates the active item', () => {\n          const pane2 = pane1.splitLeft({\n            copyActiveItem: true\n          });\n          expect(pane2.getActiveItem()).toEqual(pane1.getActiveItem());\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing if the active item doesn't implement .copy()",
            "suites": [
                "Pane",
                "split methods",
                "::splitLeft(params)",
                "when `copyActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1138,
                "column": 69
            },
            "line": 1138,
            "code": "        it(\"does nothing if the active item doesn't implement .copy()\", () => {\n          item1.copy = null;\n          const pane2 = pane1.splitLeft({\n            copyActiveItem: true\n          });\n          expect(pane2.getActiveItem()).toBeUndefined();\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces itself with a row and inserts a new pane to the left of itself",
            "suites": [
                "Pane",
                "split methods",
                "::splitLeft(params)",
                "when the parent is a column"
            ],
            "updatePoint": {
                "line": 1147,
                "column": 83
            },
            "line": 1147,
            "code": "        it('replaces itself with a row and inserts a new pane to the left of itself', () => {\n          pane1.splitDown();\n          const pane2 = pane1.splitLeft({\n            items: [new Item('B')]\n          });\n          const pane3 = pane1.splitLeft({\n            items: [new Item('C')]\n          });\n          const row = container.root.children[0];\n          expect(row.orientation).toBe('horizontal');\n          expect(row.children).toEqual([pane2, pane3, pane1]);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces itself with a row and inserts a new pane to the right of itself",
            "suites": [
                "Pane",
                "split methods",
                "::splitRight(params)",
                "when the parent is the container root"
            ],
            "updatePoint": {
                "line": 1163,
                "column": 84
            },
            "line": 1163,
            "code": "        it('replaces itself with a row and inserts a new pane to the right of itself', () => {\n          const pane2 = pane1.splitRight({\n            items: [new Item('B')]\n          });\n          const pane3 = pane1.splitRight({\n            items: [new Item('C')]\n          });\n          expect(container.root.orientation).toBe('horizontal');\n          expect(container.root.children).toEqual([pane1, pane3, pane2]);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the active item",
            "suites": [
                "Pane",
                "split methods",
                "::splitRight(params)",
                "when `moveActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1175,
                "column": 33
            },
            "line": 1175,
            "code": "        it('moves the active item', () => {\n          const pane2 = pane1.splitRight({\n            moveActiveItem: true\n          });\n          expect(pane2.getActiveItem()).toBe(item1);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "duplicates the active item",
            "suites": [
                "Pane",
                "split methods",
                "::splitRight(params)",
                "when `copyActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1183,
                "column": 38
            },
            "line": 1183,
            "code": "        it('duplicates the active item', () => {\n          const pane2 = pane1.splitRight({\n            copyActiveItem: true\n          });\n          expect(pane2.getActiveItem()).toEqual(pane1.getActiveItem());\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces itself with a row and inserts a new pane to the right of itself",
            "suites": [
                "Pane",
                "split methods",
                "::splitRight(params)",
                "when the parent is a column"
            ],
            "updatePoint": {
                "line": 1191,
                "column": 84
            },
            "line": 1191,
            "code": "        it('replaces itself with a row and inserts a new pane to the right of itself', () => {\n          pane1.splitDown();\n          const pane2 = pane1.splitRight({\n            items: [new Item('B')]\n          });\n          const pane3 = pane1.splitRight({\n            items: [new Item('C')]\n          });\n          const row = container.root.children[0];\n          expect(row.orientation).toBe('horizontal');\n          expect(row.children).toEqual([pane1, pane3, pane2]);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces itself with a column and inserts a new pane above itself",
            "suites": [
                "Pane",
                "split methods",
                "::splitUp(params)",
                "when the parent is the container root"
            ],
            "updatePoint": {
                "line": 1207,
                "column": 77
            },
            "line": 1207,
            "code": "        it('replaces itself with a column and inserts a new pane above itself', () => {\n          const pane2 = pane1.splitUp({\n            items: [new Item('B')]\n          });\n          const pane3 = pane1.splitUp({\n            items: [new Item('C')]\n          });\n          expect(container.root.orientation).toBe('vertical');\n          expect(container.root.children).toEqual([pane2, pane3, pane1]);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the active item",
            "suites": [
                "Pane",
                "split methods",
                "::splitUp(params)",
                "when `moveActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1219,
                "column": 33
            },
            "line": 1219,
            "code": "        it('moves the active item', () => {\n          const pane2 = pane1.splitUp({\n            moveActiveItem: true\n          });\n          expect(pane2.getActiveItem()).toBe(item1);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "duplicates the active item",
            "suites": [
                "Pane",
                "split methods",
                "::splitUp(params)",
                "when `copyActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1227,
                "column": 38
            },
            "line": 1227,
            "code": "        it('duplicates the active item', () => {\n          const pane2 = pane1.splitUp({\n            copyActiveItem: true\n          });\n          expect(pane2.getActiveItem()).toEqual(pane1.getActiveItem());\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces itself with a column and inserts a new pane above itself",
            "suites": [
                "Pane",
                "split methods",
                "::splitUp(params)",
                "when the parent is a row"
            ],
            "updatePoint": {
                "line": 1235,
                "column": 77
            },
            "line": 1235,
            "code": "        it('replaces itself with a column and inserts a new pane above itself', () => {\n          pane1.splitRight();\n          const pane2 = pane1.splitUp({\n            items: [new Item('B')]\n          });\n          const pane3 = pane1.splitUp({\n            items: [new Item('C')]\n          });\n          const column = container.root.children[0];\n          expect(column.orientation).toBe('vertical');\n          expect(column.children).toEqual([pane2, pane3, pane1]);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces itself with a column and inserts a new pane below itself",
            "suites": [
                "Pane",
                "split methods",
                "::splitDown(params)",
                "when the parent is the container root"
            ],
            "updatePoint": {
                "line": 1251,
                "column": 77
            },
            "line": 1251,
            "code": "        it('replaces itself with a column and inserts a new pane below itself', () => {\n          const pane2 = pane1.splitDown({\n            items: [new Item('B')]\n          });\n          const pane3 = pane1.splitDown({\n            items: [new Item('C')]\n          });\n          expect(container.root.orientation).toBe('vertical');\n          expect(container.root.children).toEqual([pane1, pane3, pane2]);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the active item",
            "suites": [
                "Pane",
                "split methods",
                "::splitDown(params)",
                "when `moveActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1263,
                "column": 33
            },
            "line": 1263,
            "code": "        it('moves the active item', () => {\n          const pane2 = pane1.splitDown({\n            moveActiveItem: true\n          });\n          expect(pane2.getActiveItem()).toBe(item1);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "duplicates the active item",
            "suites": [
                "Pane",
                "split methods",
                "::splitDown(params)",
                "when `copyActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1271,
                "column": 38
            },
            "line": 1271,
            "code": "        it('duplicates the active item', () => {\n          const pane2 = pane1.splitDown({\n            copyActiveItem: true\n          });\n          expect(pane2.getActiveItem()).toEqual(pane1.getActiveItem());\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces itself with a column and inserts a new pane below itself",
            "suites": [
                "Pane",
                "split methods",
                "::splitDown(params)",
                "when the parent is a row"
            ],
            "updatePoint": {
                "line": 1279,
                "column": 77
            },
            "line": 1279,
            "code": "        it('replaces itself with a column and inserts a new pane below itself', () => {\n          pane1.splitRight();\n          const pane2 = pane1.splitDown({\n            items: [new Item('B')]\n          });\n          const pane3 = pane1.splitDown({\n            items: [new Item('C')]\n          });\n          const column = container.root.children[0];\n          expect(column.orientation).toBe('vertical');\n          expect(column.children).toEqual([pane1, pane3, pane2]);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gracefully ignores the moveActiveItem parameter",
            "suites": [
                "Pane",
                "split methods",
                "when the pane is empty",
                "when `moveActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1295,
                "column": 59
            },
            "line": 1295,
            "code": "        it('gracefully ignores the moveActiveItem parameter', () => {\n          pane1.destroyItem(item1);\n          expect(pane1.getActiveItem()).toBe(undefined);\n          const pane2 = pane1.split('horizontal', 'before', {\n            moveActiveItem: true\n          });\n          expect(container.root.children).toEqual([pane2, pane1]);\n          expect(pane2.getActiveItem()).toBe(undefined);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gracefully ignores the copyActiveItem parameter",
            "suites": [
                "Pane",
                "split methods",
                "when the pane is empty",
                "when `copyActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1306,
                "column": 59
            },
            "line": 1306,
            "code": "        it('gracefully ignores the copyActiveItem parameter', () => {\n          pane1.destroyItem(item1);\n          expect(pane1.getActiveItem()).toBe(undefined);\n          const pane2 = pane1.split('horizontal', 'before', {\n            copyActiveItem: true\n          });\n          expect(container.root.children).toEqual([pane2, pane1]);\n          expect(pane2.getActiveItem()).toBe(undefined);\n        });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the new pane",
            "suites": [
                "Pane",
                "split methods",
                "when the pane is empty",
                "when `copyActiveItem: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 1317,
                "column": 30
            },
            "line": 1317,
            "code": "    it('activates the new pane', () => {\n      expect(pane1.isActive()).toBe(true);\n      const pane2 = pane1.splitRight();\n      expect(pane1.isActive()).toBe(false);\n      expect(pane2.isActive()).toBe(true);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prompts to save unsaved items before destroying the pane",
            "suites": [
                "Pane",
                "::close()"
            ],
            "updatePoint": {
                "line": 1325,
                "column": 64
            },
            "line": 1325,
            "code": "    it('prompts to save unsaved items before destroying the pane', async () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B')]\n      }));\n      const [item1] = pane.getItems();\n\n      item1.shouldPromptToSave = () => true;\n\n      item1.getURI = () => '/test/path';\n\n      item1.save = jasmine.createSpy('save');\n      confirm.andCallFake((options, callback) => callback(0));\n      await pane.close();\n      expect(confirm).toHaveBeenCalled();\n      expect(item1.save).toHaveBeenCalled();\n      expect(pane.isDestroyed()).toBe(true);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not destroy the pane if the user clicks cancel",
            "suites": [
                "Pane",
                "::close()"
            ],
            "updatePoint": {
                "line": 1342,
                "column": 59
            },
            "line": 1342,
            "code": "    it('does not destroy the pane if the user clicks cancel', async () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B')]\n      }));\n      const [item1] = pane.getItems();\n\n      item1.shouldPromptToSave = () => true;\n\n      item1.getURI = () => '/test/path';\n\n      item1.save = jasmine.createSpy('save');\n      confirm.andCallFake((options, callback) => callback(1));\n      await pane.close();\n      expect(confirm).toHaveBeenCalled();\n      expect(item1.save).not.toHaveBeenCalled();\n      expect(pane.isDestroyed()).toBe(false);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not destroy the pane if the user starts to save but then does not choose a path",
            "suites": [
                "Pane",
                "::close()"
            ],
            "updatePoint": {
                "line": 1359,
                "column": 92
            },
            "line": 1359,
            "code": "    it('does not destroy the pane if the user starts to save but then does not choose a path', async () => {\n      const pane = new Pane(paneParams({\n        items: [new Item('A'), new Item('B')]\n      }));\n      const [item1] = pane.getItems();\n\n      item1.shouldPromptToSave = () => true;\n\n      item1.saveAs = jasmine.createSpy('saveAs');\n      confirm.andCallFake((options, callback) => callback(0));\n      showSaveDialog.andCallFake((options, callback) => callback(undefined));\n      await pane.close();\n      expect(atom.applicationDelegate.confirm).toHaveBeenCalled();\n      expect(confirm.callCount).toBe(1);\n      expect(item1.saveAs).not.toHaveBeenCalled();\n      expect(pane.isDestroyed()).toBe(false);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not destroy the pane if save fails and user clicks cancel",
            "suites": [
                "Pane",
                "::close()",
                "when item fails to save"
            ],
            "updatePoint": {
                "line": 1397,
                "column": 72
            },
            "line": 1397,
            "code": "      it('does not destroy the pane if save fails and user clicks cancel', async () => {\n        let confirmations = 0;\n        confirm.andCallFake((options, callback) => {\n          confirmations++;\n\n          if (confirmations === 1) {\n            callback(0); // click save\n          } else {\n            callback(1);\n          }\n        }); // click cancel\n\n        await pane.close();\n        expect(atom.applicationDelegate.confirm).toHaveBeenCalled();\n        expect(confirmations).toBe(2);\n        expect(item1.save).toHaveBeenCalled();\n        expect(pane.isDestroyed()).toBe(false);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does destroy the pane if the user saves the file under a new name",
            "suites": [
                "Pane",
                "::close()",
                "when item fails to save"
            ],
            "updatePoint": {
                "line": 1415,
                "column": 75
            },
            "line": 1415,
            "code": "      it('does destroy the pane if the user saves the file under a new name', async () => {\n        item1.saveAs = jasmine.createSpy('saveAs').andReturn(true);\n        let confirmations = 0;\n        confirm.andCallFake((options, callback) => {\n          confirmations++;\n          callback(0);\n        }); // save and then save as\n\n        showSaveDialog.andCallFake((options, callback) => callback('new/path'));\n        await pane.close();\n        expect(atom.applicationDelegate.confirm).toHaveBeenCalled();\n        expect(confirmations).toBe(2);\n        expect(atom.applicationDelegate.showSaveDialog.mostRecentCall.args[0]).toEqual({});\n        expect(item1.save).toHaveBeenCalled();\n        expect(item1.saveAs).toHaveBeenCalled();\n        expect(pane.isDestroyed()).toBe(true);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "asks again if the saveAs also fails",
            "suites": [
                "Pane",
                "::close()",
                "when item fails to save"
            ],
            "updatePoint": {
                "line": 1432,
                "column": 45
            },
            "line": 1432,
            "code": "      it('asks again if the saveAs also fails', async () => {\n        item1.saveAs = jasmine.createSpy('saveAs').andCallFake(() => {\n          const error = new Error(\"EACCES, permission denied '/test/path'\");\n          error.path = '/test/path';\n          error.code = 'EACCES';\n          throw error;\n        });\n        let confirmations = 0;\n        confirm.andCallFake((options, callback) => {\n          confirmations++;\n\n          if (confirmations < 3) {\n            callback(0); // save, save as, save as\n          } else {\n            callback(2); // don't save\n          }\n        });\n        showSaveDialog.andCallFake((options, callback) => callback('new/path'));\n        await pane.close();\n        expect(atom.applicationDelegate.confirm).toHaveBeenCalled();\n        expect(confirmations).toBe(3);\n        expect(atom.applicationDelegate.showSaveDialog.mostRecentCall.args[0]).toEqual({});\n        expect(item1.save).toHaveBeenCalled();\n        expect(item1.saveAs).toHaveBeenCalled();\n        expect(pane.isDestroyed()).toBe(true);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes ::onWillDestroy observers before destroying items",
            "suites": [
                "Pane",
                "::destroy()"
            ],
            "updatePoint": {
                "line": 1471,
                "column": 65
            },
            "line": 1471,
            "code": "    it('invokes ::onWillDestroy observers before destroying items', () => {\n      let itemsDestroyed = null;\n      pane1.onWillDestroy(() => {\n        itemsDestroyed = pane1.getItems().map(item => item.isDestroyed());\n      });\n      pane1.destroy();\n      expect(itemsDestroyed).toEqual([false, false]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys the pane's destroyable items",
            "suites": [
                "Pane",
                "::destroy()"
            ],
            "updatePoint": {
                "line": 1479,
                "column": 45
            },
            "line": 1479,
            "code": "    it(\"destroys the pane's destroyable items\", () => {\n      const [item1, item2] = pane1.getItems();\n      pane1.destroy();\n      expect(item1.isDestroyed()).toBe(true);\n      expect(item2.isDestroyed()).toBe(true);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "makes the next pane active",
            "suites": [
                "Pane",
                "::destroy()",
                "if the pane is active"
            ],
            "updatePoint": {
                "line": 1486,
                "column": 36
            },
            "line": 1486,
            "code": "      it('makes the next pane active', () => {\n        expect(pane2.isActive()).toBe(true);\n        pane2.destroy();\n        expect(pane1.isActive()).toBe(true);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the pane from its parent",
            "suites": [
                "Pane",
                "::destroy()",
                "if the pane's parent has more than two children"
            ],
            "updatePoint": {
                "line": 1493,
                "column": 42
            },
            "line": 1493,
            "code": "      it('removes the pane from its parent', () => {\n        const pane3 = pane2.splitRight();\n        expect(container.root.children).toEqual([pane1, pane2, pane3]);\n        pane2.destroy();\n        expect(container.root.children).toEqual([pane1, pane3]);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces the parent with its last remaining child",
            "suites": [
                "Pane",
                "::destroy()",
                "if the pane's parent has two children"
            ],
            "updatePoint": {
                "line": 1501,
                "column": 59
            },
            "line": 1501,
            "code": "      it('replaces the parent with its last remaining child', () => {\n        const pane3 = pane2.splitDown();\n        expect(container.root.children[0]).toBe(pane1);\n        expect(container.root.children[1].children).toEqual([pane2, pane3]);\n        pane3.destroy();\n        expect(container.root.children).toEqual([pane1, pane2]);\n        pane2.destroy();\n        expect(container.root).toBe(pane1);\n      });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not open file in pending state by default",
            "suites": [
                "Pane",
                "pending state"
            ],
            "updatePoint": {
                "line": 1522,
                "column": 54
            },
            "line": 1522,
            "code": "    it('does not open file in pending state by default', async () => {\n      await atom.workspace.open('sample.js');\n      expect(pane.getPendingItem()).toBeNull();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens file in pending state if 'pending' option is true",
            "suites": [
                "Pane",
                "pending state"
            ],
            "updatePoint": {
                "line": 1526,
                "column": 63
            },
            "line": 1526,
            "code": "    it(\"opens file in pending state if 'pending' option is true\", () => {\n      expect(pane.getPendingItem()).toEqual(editor1);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "terminates pending state if ::terminatePendingState is invoked",
            "suites": [
                "Pane",
                "pending state"
            ],
            "updatePoint": {
                "line": 1529,
                "column": 70
            },
            "line": 1529,
            "code": "    it('terminates pending state if ::terminatePendingState is invoked', () => {\n      editor1.terminatePendingState();\n      expect(pane.getPendingItem()).toBeNull();\n      expect(eventCount).toBe(1);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "terminates pending state when buffer is changed",
            "suites": [
                "Pane",
                "pending state"
            ],
            "updatePoint": {
                "line": 1534,
                "column": 55
            },
            "line": 1534,
            "code": "    it('terminates pending state when buffer is changed', () => {\n      editor1.insertText(\"I'll be back!\");\n      advanceClock(editor1.getBuffer().stoppedChangingDelay);\n      expect(pane.getPendingItem()).toBeNull();\n      expect(eventCount).toBe(1);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only calls terminate handler once when text is modified twice",
            "suites": [
                "Pane",
                "pending state"
            ],
            "updatePoint": {
                "line": 1540,
                "column": 69
            },
            "line": 1540,
            "code": "    it('only calls terminate handler once when text is modified twice', async () => {\n      const originalText = editor1.getText();\n      editor1.insertText('Some text');\n      advanceClock(editor1.getBuffer().stoppedChangingDelay);\n      await editor1.save();\n      editor1.insertText('More text');\n      advanceClock(editor1.getBuffer().stoppedChangingDelay);\n      expect(pane.getPendingItem()).toBeNull();\n      expect(eventCount).toBe(1); // Reset fixture back to original state\n\n      editor1.setText(originalText);\n      await editor1.save();\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only calls clearPendingItem if there is a pending item to clear",
            "suites": [
                "Pane",
                "pending state"
            ],
            "updatePoint": {
                "line": 1553,
                "column": 71
            },
            "line": 1553,
            "code": "    it('only calls clearPendingItem if there is a pending item to clear', () => {\n      spyOn(pane, 'clearPendingItem').andCallThrough();\n      editor1.terminatePendingState();\n      editor1.terminatePendingState();\n      expect(pane.getPendingItem()).toBeNull();\n      expect(pane.clearPendingItem.callCount).toBe(1);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can serialize and deserialize the pane and all its items",
            "suites": [
                "Pane",
                "serialization"
            ],
            "updatePoint": {
                "line": 1569,
                "column": 64
            },
            "line": 1569,
            "code": "    it('can serialize and deserialize the pane and all its items', () => {\n      const newPane = Pane.deserialize(pane.serialize(), atom);\n      expect(newPane.getItems()).toEqual(pane.getItems());\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the active item on deserialization",
            "suites": [
                "Pane",
                "serialization"
            ],
            "updatePoint": {
                "line": 1573,
                "column": 51
            },
            "line": 1573,
            "code": "    it('restores the active item on deserialization', () => {\n      pane.activateItemAtIndex(1);\n      const newPane = Pane.deserialize(pane.serialize(), atom);\n      expect(newPane.getActiveItem()).toEqual(newPane.itemAtIndex(1));\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the active item when it doesn't implement getURI()",
            "suites": [
                "Pane",
                "serialization"
            ],
            "updatePoint": {
                "line": 1578,
                "column": 67
            },
            "line": 1578,
            "code": "    it(\"restores the active item when it doesn't implement getURI()\", () => {\n      pane.items[1].getURI = null;\n      pane.activateItemAtIndex(1);\n      const newPane = Pane.deserialize(pane.serialize(), atom);\n      expect(newPane.getActiveItem()).toEqual(newPane.itemAtIndex(1));\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the correct item when it doesn't implement getURI() and some items weren't deserialized",
            "suites": [
                "Pane",
                "serialization"
            ],
            "updatePoint": {
                "line": 1584,
                "column": 104
            },
            "line": 1584,
            "code": "    it(\"restores the correct item when it doesn't implement getURI() and some items weren't deserialized\", () => {\n      const unserializable = {};\n      pane.addItem(unserializable, {\n        index: 0\n      });\n      pane.items[2].getURI = null;\n      pane.activateItemAtIndex(2);\n      const newPane = Pane.deserialize(pane.serialize(), atom);\n      expect(newPane.getActiveItem()).toEqual(newPane.itemAtIndex(1));\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not include items that cannot be deserialized",
            "suites": [
                "Pane",
                "serialization"
            ],
            "updatePoint": {
                "line": 1594,
                "column": 58
            },
            "line": 1594,
            "code": "    it('does not include items that cannot be deserialized', () => {\n      spyOn(console, 'warn');\n      const unserializable = {};\n      pane.activateItem(unserializable);\n      const newPane = Pane.deserialize(pane.serialize(), atom);\n      expect(newPane.getActiveItem()).toEqual(pane.itemAtIndex(0));\n      expect(newPane.getItems().length).toBe(pane.getItems().length - 1);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes the pane's focus state in the serialized state",
            "suites": [
                "Pane",
                "serialization"
            ],
            "updatePoint": {
                "line": 1602,
                "column": 63
            },
            "line": 1602,
            "code": "    it(\"includes the pane's focus state in the serialized state\", () => {\n      pane.focus();\n      const newPane = Pane.deserialize(pane.serialize(), atom);\n      expect(newPane.focused).toBe(true);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can serialize and deserialize the order of the items in the itemStack",
            "suites": [
                "Pane",
                "serialization"
            ],
            "updatePoint": {
                "line": 1607,
                "column": 77
            },
            "line": 1607,
            "code": "    it('can serialize and deserialize the order of the items in the itemStack', () => {\n      const [item1, item2, item3] = pane.getItems();\n      pane.itemStack = [item3, item1, item2];\n      const newPane = Pane.deserialize(pane.serialize(), atom);\n      expect(newPane.itemStack).toEqual(pane.itemStack);\n      expect(newPane.itemStack[2]).toEqual(item2);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "builds the itemStack if the itemStack is not serialized",
            "suites": [
                "Pane",
                "serialization"
            ],
            "updatePoint": {
                "line": 1614,
                "column": 63
            },
            "line": 1614,
            "code": "    it('builds the itemStack if the itemStack is not serialized', () => {\n      const newPane = Pane.deserialize(pane.serialize(), atom);\n      expect(newPane.getItems()).toEqual(newPane.itemStack);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "rebuilds the itemStack if items.length does not match itemStack.length",
            "suites": [
                "Pane",
                "serialization"
            ],
            "updatePoint": {
                "line": 1618,
                "column": 78
            },
            "line": 1618,
            "code": "    it('rebuilds the itemStack if items.length does not match itemStack.length', () => {\n      const [, item2, item3] = pane.getItems();\n      pane.itemStack = [item2, item3];\n      const newPane = Pane.deserialize(pane.serialize(), atom);\n      expect(newPane.getItems()).toEqual(newPane.itemStack);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not serialize the reference to the items in the itemStack for pane items that will not be serialized",
            "suites": [
                "Pane",
                "serialization"
            ],
            "updatePoint": {
                "line": 1624,
                "column": 113
            },
            "line": 1624,
            "code": "    it('does not serialize the reference to the items in the itemStack for pane items that will not be serialized', () => {\n      const [item1, item2, item3] = pane.getItems();\n      pane.itemStack = [item2, item1, item3];\n      const unserializable = {};\n      pane.activateItem(unserializable);\n      const newPane = Pane.deserialize(pane.serialize(), atom);\n      expect(newPane.itemStack).toEqual([item2, item1, item3]);\n    });",
            "file": "pane-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "has a location class with value from the model",
            "suites": [
                "PanelContainerElement"
            ],
            "updatePoint": {
                "line": 38,
                "column": 52
            },
            "line": 38,
            "code": "  it('has a location class with value from the model', () => {\n    expect(element).toHaveClass('left');\n  });",
            "file": "panel-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the element when the container is destroyed",
            "suites": [
                "PanelContainerElement"
            ],
            "updatePoint": {
                "line": 41,
                "column": 57
            },
            "line": 41,
            "code": "  it('removes the element when the container is destroyed', () => {\n    expect(element.parentNode).toBe(jasmineContent);\n    container.destroy();\n    expect(element.parentNode).not.toBe(jasmineContent);\n  });",
            "file": "panel-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows panels to be inserted at any position",
            "suites": [
                "PanelContainerElement",
                "adding and removing panels"
            ],
            "updatePoint": {
                "line": 47,
                "column": 52
            },
            "line": 47,
            "code": "    it('allows panels to be inserted at any position', () => {\n      const panel1 = new Panel({\n        item: new TestPanelContainerItem(),\n        priority: 10\n      }, atom.views);\n      const panel2 = new Panel({\n        item: new TestPanelContainerItem(),\n        priority: 5\n      }, atom.views);\n      const panel3 = new Panel({\n        item: new TestPanelContainerItem(),\n        priority: 8\n      }, atom.views);\n      container.addPanel(panel1);\n      container.addPanel(panel2);\n      container.addPanel(panel3);\n      expect(element.childNodes[2]).toBe(panel1.getElement());\n      expect(element.childNodes[1]).toBe(panel3.getElement());\n      expect(element.childNodes[0]).toBe(panel2.getElement());\n    });",
            "file": "panel-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds atom-panel elements when a new panel is added to the container; removes them when the panels are destroyed",
            "suites": [
                "PanelContainerElement",
                "adding and removing panels",
                "when the container is at the left location"
            ],
            "updatePoint": {
                "line": 67,
                "column": 180
            },
            "line": 67,
            "code": "    describe('when the container is at the left location', () => it('adds atom-panel elements when a new panel is added to the container; removes them when the panels are destroyed', () => {\n      expect(element.childNodes.length).toBe(0);\n      const panel1 = new Panel({\n        item: new TestPanelContainerItem()\n      }, atom.views);\n      container.addPanel(panel1);\n      expect(element.childNodes.length).toBe(1);\n      expect(element.childNodes[0]).toHaveClass('left');\n      expect(element.childNodes[0]).toHaveClass('tool-panel'); // legacy selector support\n\n      expect(element.childNodes[0]).toHaveClass('panel-left'); // legacy selector support\n\n      expect(element.childNodes[0].tagName).toBe('ATOM-PANEL');\n      const panel2 = new Panel({\n        item: new TestPanelContainerItem()\n      }, atom.views);\n      container.addPanel(panel2);\n      expect(element.childNodes.length).toBe(2);\n      expect(panel1.getElement().style.display).not.toBe('none');\n      expect(panel2.getElement().style.display).not.toBe('none');\n      panel1.destroy();\n      expect(element.childNodes.length).toBe(1);\n      panel2.destroy();\n      expect(element.childNodes.length).toBe(0);\n    }));",
            "file": "panel-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds atom-panel elements when a new panel is added to the container; removes them when the panels are destroyed",
            "suites": [
                "PanelContainerElement",
                "adding and removing panels",
                "when the container is at the bottom location"
            ],
            "updatePoint": {
                "line": 101,
                "column": 121
            },
            "line": 101,
            "code": "      it('adds atom-panel elements when a new panel is added to the container; removes them when the panels are destroyed', () => {\n        expect(element.childNodes.length).toBe(0);\n        const panel1 = new Panel({\n          item: new TestPanelContainerItem(),\n          className: 'one'\n        }, atom.views);\n        container.addPanel(panel1);\n        expect(element.childNodes.length).toBe(1);\n        expect(element.childNodes[0]).toHaveClass('bottom');\n        expect(element.childNodes[0]).toHaveClass('tool-panel'); // legacy selector support\n\n        expect(element.childNodes[0]).toHaveClass('panel-bottom'); // legacy selector support\n\n        expect(element.childNodes[0].tagName).toBe('ATOM-PANEL');\n        expect(panel1.getElement()).toHaveClass('one');\n        const panel2 = new Panel({\n          item: new TestPanelContainerItem(),\n          className: 'two'\n        }, atom.views);\n        container.addPanel(panel2);\n        expect(element.childNodes.length).toBe(2);\n        expect(panel2.getElement()).toHaveClass('two');\n        panel1.destroy();\n        expect(element.childNodes.length).toBe(1);\n        panel2.destroy();\n        expect(element.childNodes.length).toBe(0);\n      });",
            "file": "panel-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows only one panel to be visible at a time",
            "suites": [
                "PanelContainerElement",
                "when the container is modal"
            ],
            "updatePoint": {
                "line": 139,
                "column": 53
            },
            "line": 139,
            "code": "    it('allows only one panel to be visible at a time', () => {\n      const panel1 = new Panel({\n        item: new TestPanelContainerItem()\n      }, atom.views);\n      container.addPanel(panel1);\n      expect(panel1.getElement().style.display).not.toBe('none');\n      const panel2 = new Panel({\n        item: new TestPanelContainerItem()\n      }, atom.views);\n      container.addPanel(panel2);\n      expect(panel1.getElement().style.display).toBe('none');\n      expect(panel2.getElement().style.display).not.toBe('none');\n      panel1.show();\n      expect(panel1.getElement().style.display).not.toBe('none');\n      expect(panel2.getElement().style.display).toBe('none');\n    });",
            "file": "panel-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the 'modal' class to panels",
            "suites": [
                "PanelContainerElement",
                "when the container is modal"
            ],
            "updatePoint": {
                "line": 155,
                "column": 40
            },
            "line": 155,
            "code": "    it(\"adds the 'modal' class to panels\", () => {\n      const panel1 = new Panel({\n        item: new TestPanelContainerItem()\n      }, atom.views);\n      container.addPanel(panel1);\n      expect(panel1.getElement()).toHaveClass('modal'); // legacy selector support\n\n      expect(panel1.getElement()).not.toHaveClass('tool-panel');\n      expect(panel1.getElement()).toHaveClass('overlay');\n      expect(panel1.getElement()).toHaveClass('from-top');\n    });",
            "file": "panel-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses the first tabbable item if available",
            "suites": [
                "PanelContainerElement",
                "when the container is modal",
                "autoFocus"
            ],
            "updatePoint": {
                "line": 177,
                "column": 54
            },
            "line": 177,
            "code": "      it('focuses the first tabbable item if available', () => {\n        const panel = createPanel();\n        const panelEl = panel.getElement();\n        const inputEl = document.createElement('input');\n        panelEl.appendChild(inputEl);\n        expect(document.activeElement).not.toBe(inputEl);\n        panel.show();\n        expect(document.activeElement).toBe(inputEl);\n      });",
            "file": "panel-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses the autoFocus element if available",
            "suites": [
                "PanelContainerElement",
                "when the container is modal",
                "autoFocus"
            ],
            "updatePoint": {
                "line": 186,
                "column": 52
            },
            "line": 186,
            "code": "      it('focuses the autoFocus element if available', () => {\n        const inputEl1 = document.createElement('input');\n        const inputEl2 = document.createElement('input');\n        const panel = createPanel(inputEl2);\n        const panelEl = panel.getElement();\n        panelEl.appendChild(inputEl1);\n        panelEl.appendChild(inputEl2);\n        expect(document.activeElement).not.toBe(inputEl2);\n        panel.show();\n        expect(document.activeElement).toBe(inputEl2);\n      });",
            "file": "panel-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses the entire panel item when no tabbable item is available and the panel is focusable",
            "suites": [
                "PanelContainerElement",
                "when the container is modal",
                "autoFocus"
            ],
            "updatePoint": {
                "line": 197,
                "column": 101
            },
            "line": 197,
            "code": "      it('focuses the entire panel item when no tabbable item is available and the panel is focusable', () => {\n        const panel = createPanel();\n        const panelEl = panel.getElement();\n        spyOn(panelEl, 'focus');\n        panel.show();\n        expect(panelEl.focus).toHaveBeenCalled();\n      });",
            "file": "panel-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns focus to the original activeElement",
            "suites": [
                "PanelContainerElement",
                "when the container is modal",
                "autoFocus"
            ],
            "updatePoint": {
                "line": 204,
                "column": 53
            },
            "line": 204,
            "code": "      it('returns focus to the original activeElement', () => {\n        const panel = createPanel();\n        const previousActiveElement = document.activeElement;\n        const panelEl = panel.getElement();\n        panelEl.appendChild(document.createElement('input'));\n        panel.show();\n        panel.hide();\n        waitsFor(() => document.activeElement === previousActiveElement);\n        runs(() => {\n          expect(document.activeElement).toBe(previousActiveElement);\n        });\n      });",
            "file": "panel-container-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits an onDidAddPanel event with the index the panel was inserted at",
            "suites": [
                "PanelContainer",
                "::addPanel(panel)"
            ],
            "updatePoint": {
                "line": 18,
                "column": 77
            },
            "line": 18,
            "code": "    it('emits an onDidAddPanel event with the index the panel was inserted at', () => {\n      const addPanelSpy = jasmine.createSpy();\n      container.onDidAddPanel(addPanelSpy);\n      const panel1 = new Panel({\n        item: new TestPanelItem()\n      }, atom.views);\n      container.addPanel(panel1);\n      expect(addPanelSpy).toHaveBeenCalledWith({\n        panel: panel1,\n        index: 0\n      });\n      const panel2 = new Panel({\n        item: new TestPanelItem()\n      }, atom.views);\n      container.addPanel(panel2);\n      expect(addPanelSpy).toHaveBeenCalledWith({\n        panel: panel2,\n        index: 1\n      });\n    });",
            "file": "panel-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits an onDidRemovePanel event with the index of the removed item",
            "suites": [
                "PanelContainer",
                "when a panel is destroyed"
            ],
            "updatePoint": {
                "line": 40,
                "column": 74
            },
            "line": 40,
            "code": "    it('emits an onDidRemovePanel event with the index of the removed item', () => {\n      const removePanelSpy = jasmine.createSpy();\n      container.onDidRemovePanel(removePanelSpy);\n      const panel1 = new Panel({\n        item: new TestPanelItem()\n      }, atom.views);\n      container.addPanel(panel1);\n      const panel2 = new Panel({\n        item: new TestPanelItem()\n      }, atom.views);\n      container.addPanel(panel2);\n      expect(removePanelSpy).not.toHaveBeenCalled();\n      panel2.destroy();\n      expect(removePanelSpy).toHaveBeenCalledWith({\n        panel: panel2,\n        index: 1\n      });\n      panel1.destroy();\n      expect(removePanelSpy).toHaveBeenCalledWith({\n        panel: panel1,\n        index: 0\n      });\n    });",
            "file": "panel-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys the container and all of its panels",
            "suites": [
                "PanelContainer",
                "::destroy()"
            ],
            "updatePoint": {
                "line": 65,
                "column": 52
            },
            "line": 65,
            "code": "    it('destroys the container and all of its panels', () => {\n      const destroyedPanels = [];\n      const panel1 = new Panel({\n        item: new TestPanelItem()\n      }, atom.views);\n      panel1.onDidDestroy(() => {\n        destroyedPanels.push(panel1);\n      });\n      container.addPanel(panel1);\n      const panel2 = new Panel({\n        item: new TestPanelItem()\n      }, atom.views);\n      panel2.onDidDestroy(() => {\n        destroyedPanels.push(panel2);\n      });\n      container.addPanel(panel2);\n      container.destroy();\n      expect(container.getPanels().length).toBe(0);\n      expect(destroyedPanels).toEqual([panel1, panel2]);\n    });",
            "file": "panel-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is inserted at the beginning of the list",
            "suites": [
                "PanelContainer",
                "panel priority",
                "left / top panel container",
                "when a panel with low priority is added"
            ],
            "updatePoint": {
                "line": 100,
                "column": 52
            },
            "line": 100,
            "code": "        it('is inserted at the beginning of the list', () => {\n          const addPanelSpy = jasmine.createSpy();\n          container.onDidAddPanel(addPanelSpy);\n          const panel = new Panel({\n            item: new TestPanelItem(),\n            priority: 0\n          }, atom.views);\n          container.addPanel(panel);\n          expect(addPanelSpy).toHaveBeenCalledWith({\n            panel,\n            index: 0\n          });\n          expect(container.getPanels()[0]).toBe(panel);\n        });",
            "file": "panel-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is inserted at the between the two panels",
            "suites": [
                "PanelContainer",
                "panel priority",
                "left / top panel container",
                "when a panel with priority between two other panels is added"
            ],
            "updatePoint": {
                "line": 116,
                "column": 53
            },
            "line": 116,
            "code": "        it('is inserted at the between the two panels', () => {\n          const addPanelSpy = jasmine.createSpy();\n          let panel = new Panel({\n            item: new TestPanelItem(),\n            priority: 1000\n          }, atom.views);\n          container.addPanel(panel);\n          container.onDidAddPanel(addPanelSpy);\n          panel = new Panel({\n            item: new TestPanelItem(),\n            priority: 101\n          }, atom.views);\n          container.addPanel(panel);\n          expect(addPanelSpy).toHaveBeenCalledWith({\n            panel,\n            index: 1\n          });\n          expect(container.getPanels()[1]).toBe(panel);\n        });",
            "file": "panel-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is inserted at the beginning of the list",
            "suites": [
                "PanelContainer",
                "panel priority",
                "right / bottom panel container",
                "when a panel with high priority is added"
            ],
            "updatePoint": {
                "line": 150,
                "column": 52
            },
            "line": 150,
            "code": "        it('is inserted at the beginning of the list', () => {\n          const addPanelSpy = jasmine.createSpy();\n          container.onDidAddPanel(addPanelSpy);\n          const panel = new Panel({\n            item: new TestPanelItem(),\n            priority: 1000\n          }, atom.views);\n          container.addPanel(panel);\n          expect(addPanelSpy).toHaveBeenCalledWith({\n            panel,\n            index: 0\n          });\n          expect(container.getPanels()[0]).toBe(panel);\n        });",
            "file": "panel-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is inserted at the end of the list",
            "suites": [
                "PanelContainer",
                "panel priority",
                "right / bottom panel container",
                "when a panel with low priority is added"
            ],
            "updatePoint": {
                "line": 166,
                "column": 46
            },
            "line": 166,
            "code": "        it('is inserted at the end of the list', () => {\n          const addPanelSpy = jasmine.createSpy();\n          container.onDidAddPanel(addPanelSpy);\n          const panel = new Panel({\n            item: new TestPanelItem(),\n            priority: 0\n          }, atom.views);\n          container.addPanel(panel);\n          expect(addPanelSpy).toHaveBeenCalledWith({\n            panel,\n            index: 1\n          });\n          expect(container.getPanels()[1]).toBe(panel);\n        });",
            "file": "panel-container-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the item's element as a child of the panel",
            "suites": [
                "Panel"
            ],
            "updatePoint": {
                "line": 17,
                "column": 53
            },
            "line": 17,
            "code": "  it(\"adds the item's element as a child of the panel\", () => {\n    const panel = new Panel({\n      item: new TestPanelItem()\n    }, atom.views);\n    const element = panel.getElement();\n    expect(element.tagName.toLowerCase()).toBe('atom-panel');\n    expect(element.firstChild).toBe(panel.getItem().getElement());\n  });",
            "file": "panel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the element when the panel is destroyed",
            "suites": [
                "Panel",
                "destroying the panel"
            ],
            "updatePoint": {
                "line": 26,
                "column": 55
            },
            "line": 26,
            "code": "    it('removes the element when the panel is destroyed', () => {\n      const panel = new Panel({\n        item: new TestPanelItem()\n      }, atom.views);\n      const element = panel.getElement();\n      const jasmineContent = document.getElementById('jasmine-content');\n      jasmineContent.appendChild(element);\n      expect(element.parentNode).toBe(jasmineContent);\n      panel.destroy();\n      expect(element.parentNode).not.toBe(jasmineContent);\n    });",
            "file": "panel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not try to remove the element twice",
            "suites": [
                "Panel",
                "destroying the panel"
            ],
            "updatePoint": {
                "line": 37,
                "column": 48
            },
            "line": 37,
            "code": "    it('does not try to remove the element twice', () => {\n      const item = new TestPanelItem();\n      const panel = new Panel({\n        item\n      }, atom.views);\n      const element = panel.getElement();\n      const jasmineContent = document.getElementById('jasmine-content');\n      jasmineContent.appendChild(element);\n      item.getElement().focus();\n      expect(item.getElement()).toHaveFocus(); // Avoid this error:\n      //   NotFoundError: Failed to execute 'remove' on 'Element':\n      //   The node to be removed is no longer a child of this node.\n      //   Perhaps it was moved in a 'blur' event handler?\n\n      item.getElement().addEventListener('blur', () => panel.destroy());\n      panel.destroy();\n    });",
            "file": "panel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies observers added with onDidChangeVisible",
            "suites": [
                "Panel",
                "changing panel visibility"
            ],
            "updatePoint": {
                "line": 56,
                "column": 56
            },
            "line": 56,
            "code": "    it('notifies observers added with onDidChangeVisible', () => {\n      const panel = new Panel({\n        item: new TestPanelItem()\n      }, atom.views);\n      const spy = jasmine.createSpy();\n      panel.onDidChangeVisible(spy);\n      panel.hide();\n      expect(panel.isVisible()).toBe(false);\n      expect(spy).toHaveBeenCalledWith(false);\n      spy.reset();\n      panel.show();\n      expect(panel.isVisible()).toBe(true);\n      expect(spy).toHaveBeenCalledWith(true);\n      panel.destroy();\n      expect(panel.isVisible()).toBe(false);\n      expect(spy).toHaveBeenCalledWith(false);\n    });",
            "file": "panel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "initially renders panel created with visible: false",
            "suites": [
                "Panel",
                "changing panel visibility"
            ],
            "updatePoint": {
                "line": 73,
                "column": 59
            },
            "line": 73,
            "code": "    it('initially renders panel created with visible: false', () => {\n      const panel = new Panel({\n        visible: false,\n        item: new TestPanelItem()\n      }, atom.views);\n      const element = panel.getElement();\n      expect(element.style.display).toBe('none');\n    });",
            "file": "panel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "hides and shows the panel element when Panel::hide() and Panel::show() are called",
            "suites": [
                "Panel",
                "changing panel visibility"
            ],
            "updatePoint": {
                "line": 81,
                "column": 89
            },
            "line": 81,
            "code": "    it('hides and shows the panel element when Panel::hide() and Panel::show() are called', () => {\n      const panel = new Panel({\n        item: new TestPanelItem()\n      }, atom.views);\n      const element = panel.getElement();\n      expect(element.style.display).not.toBe('none');\n      panel.hide();\n      expect(element.style.display).toBe('none');\n      panel.show();\n      expect(element.style.display).not.toBe('none');\n    });",
            "file": "panel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "initially renders panel created with visible: false",
            "suites": [
                "Panel",
                "when a class name is specified"
            ],
            "updatePoint": {
                "line": 94,
                "column": 59
            },
            "line": 94,
            "code": "    it('initially renders panel created with visible: false', () => {\n      const panel = new Panel({\n        className: 'some classes',\n        item: new TestPanelItem()\n      }, atom.views);\n      const element = panel.getElement();\n      expect(element).toHaveClass('some');\n      expect(element).toHaveClass('classes');\n    });",
            "file": "panel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw an error",
            "suites": [
                "Panel",
                "creating an atom-panel via markup"
            ],
            "updatePoint": {
                "line": 105,
                "column": 31
            },
            "line": 105,
            "code": "    it('does not throw an error', () => {\n      document.createElement('atom-panel');\n    });",
            "file": "panel-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves the returned promise when the watcher begins listening",
            "suites": [
                "watchPath",
                "watchPath()"
            ],
            "updatePoint": {
                "line": 46,
                "column": 71
            },
            "line": 46,
            "code": "    it('resolves the returned promise when the watcher begins listening', async function () {\n      const rootDir = await tempMkdir('atom-fsmanager-test-');\n      const watcher = await watchPath(rootDir, {}, () => {});\n      expect(watcher.constructor.name).toBe('PathWatcher');\n    });",
            "file": "path-watcher-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reuses an existing native watcher and resolves getStartPromise immediately if attached to a running watcher",
            "suites": [
                "watchPath",
                "watchPath()"
            ],
            "updatePoint": {
                "line": 51,
                "column": 115
            },
            "line": 51,
            "code": "    it('reuses an existing native watcher and resolves getStartPromise immediately if attached to a running watcher', async function () {\n      const rootDir = await tempMkdir('atom-fsmanager-test-');\n      const watcher0 = await watchPath(rootDir, {}, () => {});\n      const watcher1 = await watchPath(rootDir, {}, () => {});\n      expect(watcher0.native).toBe(watcher1.native);\n    });",
            "file": "path-watcher-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reuses existing native watchers even while they're still starting",
            "suites": [
                "watchPath",
                "watchPath()"
            ],
            "updatePoint": {
                "line": 57,
                "column": 73
            },
            "line": 57,
            "code": "    it(\"reuses existing native watchers even while they're still starting\", async function () {\n      const rootDir = await tempMkdir('atom-fsmanager-test-');\n      const [watcher0, watcher1] = await Promise.all([watchPath(rootDir, {}, () => {}), watchPath(rootDir, {}, () => {})]);\n      expect(watcher0.native).toBe(watcher1.native);\n    });",
            "file": "path-watcher-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't attach new watchers to a native watcher that's stopping",
            "suites": [
                "watchPath",
                "watchPath()"
            ],
            "updatePoint": {
                "line": 62,
                "column": 71
            },
            "line": 62,
            "code": "    it(\"doesn't attach new watchers to a native watcher that's stopping\", async function () {\n      const rootDir = await tempMkdir('atom-fsmanager-test-');\n      const watcher0 = await watchPath(rootDir, {}, () => {});\n      const native0 = watcher0.native;\n      watcher0.dispose();\n      const watcher1 = await watchPath(rootDir, {}, () => {});\n      expect(watcher1.native).not.toBe(native0);\n    });",
            "file": "path-watcher-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reuses an existing native watcher on a parent directory and filters events",
            "suites": [
                "watchPath",
                "watchPath()"
            ],
            "updatePoint": {
                "line": 70,
                "column": 82
            },
            "line": 70,
            "code": "    it('reuses an existing native watcher on a parent directory and filters events', async function () {\n      const rootDir = await tempMkdir('atom-fsmanager-test-').then(realpath);\n      const rootFile = path.join(rootDir, 'rootfile.txt');\n      const subDir = path.join(rootDir, 'subdir');\n      const subFile = path.join(subDir, 'subfile.txt');\n      await mkdir(subDir); // Keep the watchers alive with an undisposed subscription\n\n      const rootWatcher = await watchPath(rootDir, {}, () => {});\n      const childWatcher = await watchPath(subDir, {}, () => {});\n      expect(rootWatcher.native).toBe(childWatcher.native);\n      expect(rootWatcher.native.isRunning()).toBe(true);\n      const firstChanges = Promise.all([waitForChanges(rootWatcher, subFile), waitForChanges(childWatcher, subFile)]);\n      await writeFile(subFile, 'subfile\\n', {\n        encoding: 'utf8'\n      });\n      await firstChanges;\n      const nextRootEvent = waitForChanges(rootWatcher, rootFile);\n      await writeFile(rootFile, 'rootfile\\n', {\n        encoding: 'utf8'\n      });\n      await nextRootEvent;\n    });",
            "file": "path-watcher-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adopts existing child watchers and filters events appropriately to them",
            "suites": [
                "watchPath",
                "watchPath()"
            ],
            "updatePoint": {
                "line": 92,
                "column": 79
            },
            "line": 92,
            "code": "    it('adopts existing child watchers and filters events appropriately to them', async function () {\n      const parentDir = await tempMkdir('atom-fsmanager-test-').then(realpath); // Create the directory tree\n\n      const rootFile = path.join(parentDir, 'rootfile.txt');\n      const subDir0 = path.join(parentDir, 'subdir0');\n      const subFile0 = path.join(subDir0, 'subfile0.txt');\n      const subDir1 = path.join(parentDir, 'subdir1');\n      const subFile1 = path.join(subDir1, 'subfile1.txt');\n      await mkdir(subDir0);\n      await mkdir(subDir1);\n      await Promise.all([writeFile(rootFile, 'rootfile\\n', {\n        encoding: 'utf8'\n      }), writeFile(subFile0, 'subfile 0\\n', {\n        encoding: 'utf8'\n      }), writeFile(subFile1, 'subfile 1\\n', {\n        encoding: 'utf8'\n      })]); // Begin the child watchers and keep them alive\n\n      const subWatcher0 = await watchPath(subDir0, {}, () => {});\n      const subWatcherChanges0 = waitForChanges(subWatcher0, subFile0);\n      const subWatcher1 = await watchPath(subDir1, {}, () => {});\n      const subWatcherChanges1 = waitForChanges(subWatcher1, subFile1);\n      expect(subWatcher0.native).not.toBe(subWatcher1.native); // Create the parent watcher\n\n      const parentWatcher = await watchPath(parentDir, {}, () => {});\n      const parentWatcherChanges = waitForChanges(parentWatcher, rootFile, subFile0, subFile1);\n      expect(subWatcher0.native).toBe(parentWatcher.native);\n      expect(subWatcher1.native).toBe(parentWatcher.native); // Ensure events are filtered correctly\n\n      await Promise.all([appendFile(rootFile, 'change\\n', {\n        encoding: 'utf8'\n      }), appendFile(subFile0, 'change\\n', {\n        encoding: 'utf8'\n      }), appendFile(subFile1, 'change\\n', {\n        encoding: 'utf8'\n      })]);\n      await Promise.all([subWatcherChanges0, subWatcherChanges1, parentWatcherChanges]);\n    });",
            "file": "path-watcher-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not deserialize paths to directories that don't exist",
            "suites": [
                "Project",
                "serialization"
            ],
            "updatePoint": {
                "line": 46,
                "column": 66
            },
            "line": 46,
            "code": "    it(\"does not deserialize paths to directories that don't exist\", () => {\n      deserializedProject = new Project({\n        notificationManager: atom.notifications,\n        packageManager: atom.packages,\n        confirm: atom.confirm,\n        grammarRegistry: atom.grammars\n      });\n      const state = atom.project.serialize();\n      state.paths.push('/directory/that/does/not/exist');\n      let err = null;\n      waitsForPromise(() => deserializedProject.deserialize(state, atom.deserializers).catch(e => {\n        err = e;\n      }));\n      runs(() => {\n        expect(deserializedProject.getPaths()).toEqual(atom.project.getPaths());\n        expect(err.missingProjectPaths).toEqual(['/directory/that/does/not/exist']);\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not deserialize paths that are now files",
            "suites": [
                "Project",
                "serialization"
            ],
            "updatePoint": {
                "line": 64,
                "column": 53
            },
            "line": 64,
            "code": "    it('does not deserialize paths that are now files', () => {\n      const childPath = path.join(temp.mkdirSync('atom-spec-project'), 'child');\n      fs.mkdirSync(childPath);\n      deserializedProject = new Project({\n        notificationManager: atom.notifications,\n        packageManager: atom.packages,\n        confirm: atom.confirm,\n        grammarRegistry: atom.grammars\n      });\n      atom.project.setPaths([childPath]);\n      const state = atom.project.serialize();\n      fs.rmdirSync(childPath);\n      fs.writeFileSync(childPath, 'surprise!\\n');\n      let err = null;\n      waitsForPromise(() => deserializedProject.deserialize(state, atom.deserializers).catch(e => {\n        err = e;\n      }));\n      runs(() => {\n        expect(deserializedProject.getPaths()).toEqual([]);\n        expect(err.missingProjectPaths).toEqual([childPath]);\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not include unretained buffers in the serialized state",
            "suites": [
                "Project",
                "serialization"
            ],
            "updatePoint": {
                "line": 86,
                "column": 67
            },
            "line": 86,
            "code": "    it('does not include unretained buffers in the serialized state', () => {\n      waitsForPromise(() => atom.project.bufferForPath('a'));\n      runs(() => {\n        expect(atom.project.getBuffers().length).toBe(1);\n        deserializedProject = new Project({\n          notificationManager: atom.notifications,\n          packageManager: atom.packages,\n          confirm: atom.confirm,\n          grammarRegistry: atom.grammars\n        });\n      });\n      waitsForPromise(() => deserializedProject.deserialize(atom.project.serialize({\n        isUnloading: false\n      })));\n      runs(() => expect(deserializedProject.getBuffers().length).toBe(0));\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "listens for destroyed events on deserialized buffers and removes them when they are destroyed",
            "suites": [
                "Project",
                "serialization"
            ],
            "updatePoint": {
                "line": 102,
                "column": 101
            },
            "line": 102,
            "code": "    it('listens for destroyed events on deserialized buffers and removes them when they are destroyed', () => {\n      waitsForPromise(() => atom.workspace.open('a'));\n      runs(() => {\n        expect(atom.project.getBuffers().length).toBe(1);\n        deserializedProject = new Project({\n          notificationManager: atom.notifications,\n          packageManager: atom.packages,\n          confirm: atom.confirm,\n          grammarRegistry: atom.grammars\n        });\n      });\n      waitsForPromise(() => deserializedProject.deserialize(atom.project.serialize({\n        isUnloading: false\n      })));\n      runs(() => {\n        expect(deserializedProject.getBuffers().length).toBe(1);\n        deserializedProject.getBuffers()[0].destroy();\n        expect(deserializedProject.getBuffers().length).toBe(0);\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not deserialize buffers when their path is now a directory",
            "suites": [
                "Project",
                "serialization"
            ],
            "updatePoint": {
                "line": 122,
                "column": 71
            },
            "line": 122,
            "code": "    it('does not deserialize buffers when their path is now a directory', () => {\n      const pathToOpen = path.join(temp.mkdirSync('atom-spec-project'), 'file.txt');\n      waitsForPromise(() => atom.workspace.open(pathToOpen));\n      runs(() => {\n        expect(atom.project.getBuffers().length).toBe(1);\n        fs.mkdirSync(pathToOpen);\n        deserializedProject = new Project({\n          notificationManager: atom.notifications,\n          packageManager: atom.packages,\n          confirm: atom.confirm,\n          grammarRegistry: atom.grammars\n        });\n      });\n      waitsForPromise(() => deserializedProject.deserialize(atom.project.serialize({\n        isUnloading: false\n      })));\n      runs(() => expect(deserializedProject.getBuffers().length).toBe(0));\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not deserialize buffers when their path is inaccessible",
            "suites": [
                "Project",
                "serialization"
            ],
            "updatePoint": {
                "line": 140,
                "column": 68
            },
            "line": 140,
            "code": "    it('does not deserialize buffers when their path is inaccessible', () => {\n      if (process.platform === 'win32') {\n        return;\n      } // chmod not supported on win32\n\n\n      const pathToOpen = path.join(temp.mkdirSync('atom-spec-project'), 'file.txt');\n      fs.writeFileSync(pathToOpen, '');\n      waitsForPromise(() => atom.workspace.open(pathToOpen));\n      runs(() => {\n        expect(atom.project.getBuffers().length).toBe(1);\n        fs.chmodSync(pathToOpen, '000');\n        deserializedProject = new Project({\n          notificationManager: atom.notifications,\n          packageManager: atom.packages,\n          confirm: atom.confirm,\n          grammarRegistry: atom.grammars\n        });\n      });\n      waitsForPromise(() => deserializedProject.deserialize(atom.project.serialize({\n        isUnloading: false\n      })));\n      runs(() => expect(deserializedProject.getBuffers().length).toBe(0));\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not deserialize buffers with their path is no longer present",
            "suites": [
                "Project",
                "serialization"
            ],
            "updatePoint": {
                "line": 164,
                "column": 73
            },
            "line": 164,
            "code": "    it('does not deserialize buffers with their path is no longer present', () => {\n      const pathToOpen = path.join(temp.mkdirSync('atom-spec-project'), 'file.txt');\n      fs.writeFileSync(pathToOpen, '');\n      waitsForPromise(() => atom.workspace.open(pathToOpen));\n      runs(() => {\n        expect(atom.project.getBuffers().length).toBe(1);\n        fs.unlinkSync(pathToOpen);\n        deserializedProject = new Project({\n          notificationManager: atom.notifications,\n          packageManager: atom.packages,\n          confirm: atom.confirm,\n          grammarRegistry: atom.grammars\n        });\n      });\n      waitsForPromise(() => deserializedProject.deserialize(atom.project.serialize({\n        isUnloading: false\n      })));\n      runs(() => expect(deserializedProject.getBuffers().length).toBe(0));\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deserializes buffers that have never been saved before",
            "suites": [
                "Project",
                "serialization"
            ],
            "updatePoint": {
                "line": 183,
                "column": 62
            },
            "line": 183,
            "code": "    it('deserializes buffers that have never been saved before', () => {\n      const pathToOpen = path.join(temp.mkdirSync('atom-spec-project'), 'file.txt');\n      waitsForPromise(() => atom.workspace.open(pathToOpen));\n      runs(() => {\n        atom.workspace.getActiveTextEditor().setText('unsaved\\n');\n        expect(atom.project.getBuffers().length).toBe(1);\n        deserializedProject = new Project({\n          notificationManager: atom.notifications,\n          packageManager: atom.packages,\n          confirm: atom.confirm,\n          grammarRegistry: atom.grammars\n        });\n      });\n      waitsForPromise(() => deserializedProject.deserialize(atom.project.serialize({\n        isUnloading: false\n      })));\n      runs(() => {\n        expect(deserializedProject.getBuffers().length).toBe(1);\n        expect(deserializedProject.getBuffers()[0].getPath()).toBe(pathToOpen);\n        expect(deserializedProject.getBuffers()[0].getText()).toBe('unsaved\\n');\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "serializes marker layers and history only if Atom is quitting",
            "suites": [
                "Project",
                "serialization"
            ],
            "updatePoint": {
                "line": 205,
                "column": 69
            },
            "line": 205,
            "code": "    it('serializes marker layers and history only if Atom is quitting', () => {\n      waitsForPromise(() => atom.workspace.open('a'));\n      let bufferA = null;\n      let layerA = null;\n      let markerA = null;\n      runs(() => {\n        bufferA = atom.project.getBuffers()[0];\n        layerA = bufferA.addMarkerLayer({\n          persistent: true\n        });\n        markerA = layerA.markPosition([0, 3]);\n        bufferA.append('!');\n        notQuittingProject = new Project({\n          notificationManager: atom.notifications,\n          packageManager: atom.packages,\n          confirm: atom.confirm,\n          grammarRegistry: atom.grammars\n        });\n      });\n      waitsForPromise(() => notQuittingProject.deserialize(atom.project.serialize({\n        isUnloading: false\n      })));\n      runs(() => {\n        expect(notQuittingProject.getBuffers()[0].getMarkerLayer(layerA.id), x => x.getMarker(markerA.id)).toBeUndefined();\n        expect(notQuittingProject.getBuffers()[0].undo()).toBe(false);\n        quittingProject = new Project({\n          notificationManager: atom.notifications,\n          packageManager: atom.packages,\n          confirm: atom.confirm,\n          grammarRegistry: atom.grammars\n        });\n      });\n      waitsForPromise(() => quittingProject.deserialize(atom.project.serialize({\n        isUnloading: true\n      })));\n      runs(() => {\n        expect(quittingProject.getBuffers()[0].getMarkerLayer(layerA.id), x => x.getMarker(markerA.id)).not.toBeUndefined();\n        expect(quittingProject.getBuffers()[0].undo()).toBe(true);\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the project's path to the saved file's parent directory",
            "suites": [
                "Project",
                "when an editor is saved and the project has no path"
            ],
            "updatePoint": {
                "line": 247,
                "column": 68
            },
            "line": 247,
            "code": "    it(\"sets the project's path to the saved file's parent directory\", () => {\n      const tempFile = temp.openSync().path;\n      atom.project.setPaths([]);\n      expect(atom.project.getPaths()[0]).toBeUndefined();\n      let editor = null;\n      waitsForPromise(() => atom.workspace.open().then(o => {\n        editor = o;\n      }));\n      waitsForPromise(() => editor.saveAs(tempFile));\n      runs(() => expect(atom.project.getPaths()[0]).toBe(path.dirname(tempFile)));\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets a project specification",
            "suites": [
                "Project",
                ".replace"
            ],
            "updatePoint": {
                "line": 273,
                "column": 36
            },
            "line": 273,
            "code": "    it('sets a project specification', () => {\n      expect(atom.config.get('baz')).toBeUndefined();\n      atom.project.replace(projectSpecification);\n      expect(atom.project.getPaths()).toEqual([projectPath1, projectPath2]);\n      expect(atom.config.get('baz')).toBe('buzz');\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears a project through replace with no params",
            "suites": [
                "Project",
                ".replace"
            ],
            "updatePoint": {
                "line": 279,
                "column": 55
            },
            "line": 279,
            "code": "    it('clears a project through replace with no params', () => {\n      expect(atom.config.get('baz')).toBeUndefined();\n      atom.project.replace(projectSpecification);\n      expect(atom.config.get('baz')).toBe('buzz');\n      expect(atom.project.getPaths()).toEqual([projectPath1, projectPath2]);\n      atom.project.replace();\n      expect(atom.config.get('baz')).toBeUndefined();\n      expect(atom.project.getPaths()).toEqual([]);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "responds to change of project specification",
            "suites": [
                "Project",
                ".replace"
            ],
            "updatePoint": {
                "line": 288,
                "column": 51
            },
            "line": 288,
            "code": "    it('responds to change of project specification', () => {\n      let wasCalled = false;\n\n      const callback = () => {\n        wasCalled = true;\n      };\n\n      atom.project.onDidReplace(callback);\n      atom.project.replace(projectSpecification);\n      expect(wasCalled).toBe(true);\n      wasCalled = false;\n      atom.project.replace();\n      expect(wasCalled).toBe(true);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits save events on the main process",
            "suites": [
                "Project",
                "before and after saving a buffer"
            ],
            "updatePoint": {
                "line": 310,
                "column": 45
            },
            "line": 310,
            "code": "    it('emits save events on the main process', () => {\n      spyOn(atom.project.applicationDelegate, 'emitDidSavePath');\n      spyOn(atom.project.applicationDelegate, 'emitWillSavePath');\n      waitsForPromise(() => buffer.save());\n      runs(() => {\n        expect(atom.project.applicationDelegate.emitDidSavePath.calls.length).toBe(1);\n        expect(atom.project.applicationDelegate.emitDidSavePath).toHaveBeenCalledWith(buffer.getPath());\n        expect(atom.project.applicationDelegate.emitWillSavePath.calls.length).toBe(1);\n        expect(atom.project.applicationDelegate.emitWillSavePath).toHaveBeenCalledWith(buffer.getPath());\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a warning notification",
            "suites": [
                "Project",
                "when a watch error is thrown from the TextBuffer"
            ],
            "updatePoint": {
                "line": 327,
                "column": 38
            },
            "line": 327,
            "code": "    it('creates a warning notification', () => {\n      let noteSpy;\n      atom.notifications.onDidAddNotification(noteSpy = jasmine.createSpy());\n      const error = new Error('SomeError');\n      error.eventType = 'resurrect';\n      editor.buffer.emitter.emit('will-throw-watch-error', {\n        handle: jasmine.createSpy(),\n        error\n      });\n      expect(noteSpy).toHaveBeenCalled();\n      const notification = noteSpy.mostRecentCall.args[0];\n      expect(notification.getType()).toBe('warning');\n      expect(notification.getDetail()).toBe('SomeError');\n      expect(notification.getMessage()).toContain('`resurrect`');\n      expect(notification.getMessage()).toContain(path.join('fixtures', 'dir', 'a'));\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses it to create repositories for any directories that need one",
            "suites": [
                "Project",
                "when a custom repository-provider service is provided"
            ],
            "updatePoint": {
                "line": 364,
                "column": 72
            },
            "line": 364,
            "code": "    it('uses it to create repositories for any directories that need one', () => {\n      const projectPath = temp.mkdirSync('atom-project');\n      atom.project.setPaths([projectPath]);\n      expect(atom.project.getRepositories()).toEqual([null]);\n      atom.packages.serviceHub.provide('atom.repository-provider', '0.1.0', fakeRepositoryProvider);\n      waitsFor(() => atom.project.repositoryProviders.length > 1);\n      runs(() => atom.project.getRepositories()[0] === fakeRepository);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not create any new repositories if every directory has a repository",
            "suites": [
                "Project",
                "when a custom repository-provider service is provided"
            ],
            "updatePoint": {
                "line": 372,
                "column": 80
            },
            "line": 372,
            "code": "    it('does not create any new repositories if every directory has a repository', () => {\n      const repositories = atom.project.getRepositories();\n      expect(repositories.length).toEqual(1);\n      expect(repositories[0]).toBeTruthy();\n      atom.packages.serviceHub.provide('atom.repository-provider', '0.1.0', fakeRepositoryProvider);\n      waitsFor(() => atom.project.repositoryProviders.length > 1);\n      runs(() => expect(atom.project.getRepositories()).toBe(repositories));\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stops using it to create repositories when the service is removed",
            "suites": [
                "Project",
                "when a custom repository-provider service is provided"
            ],
            "updatePoint": {
                "line": 380,
                "column": 73
            },
            "line": 380,
            "code": "    it('stops using it to create repositories when the service is removed', () => {\n      atom.project.setPaths([]);\n      const disposable = atom.packages.serviceHub.provide('atom.repository-provider', '0.1.0', fakeRepositoryProvider);\n      waitsFor(() => atom.project.repositoryProviders.length > 1);\n      runs(() => {\n        disposable.dispose();\n        atom.project.addPath(temp.mkdirSync('atom-project'));\n        expect(atom.project.getRepositories()).toEqual([null]);\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the provider's custom directories for any paths that it handles",
            "suites": [
                "Project",
                "when a custom directory-provider service is provided"
            ],
            "updatePoint": {
                "line": 456,
                "column": 76
            },
            "line": 456,
            "code": "    it(\"uses the provider's custom directories for any paths that it handles\", () => {\n      const localPath = temp.mkdirSync('local-path');\n      const remotePath = 'ssh://foreign-directory:8080/does-exist';\n      atom.project.setPaths([localPath, remotePath]);\n      let directories = atom.project.getDirectories();\n      expect(directories[0].getPath()).toBe(localPath);\n      expect(directories[0] instanceof Directory).toBe(true);\n      expect(directories[1].getPath()).toBe(remotePath);\n      expect(directories[1] instanceof DummyDirectory).toBe(true); // It does not add new remote paths that do not exist\n\n      const nonExistentRemotePath = 'ssh://another-directory:8080/does-not-exist';\n      atom.project.addPath(nonExistentRemotePath);\n      expect(atom.project.getDirectories().length).toBe(2); // It adds new remote paths if their directories exist.\n\n      const newRemotePath = 'ssh://another-directory:8080/does-exist';\n      atom.project.addPath(newRemotePath);\n      directories = atom.project.getDirectories();\n      expect(directories[2].getPath()).toBe(newRemotePath);\n      expect(directories[2] instanceof DummyDirectory).toBe(true);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stops using the provider when the service is removed",
            "suites": [
                "Project",
                "when a custom directory-provider service is provided"
            ],
            "updatePoint": {
                "line": 476,
                "column": 60
            },
            "line": 476,
            "code": "    it('stops using the provider when the service is removed', () => {\n      serviceDisposable.dispose();\n      atom.project.setPaths(['ssh://foreign-directory:8080/does-exist']);\n      expect(atom.project.getDirectories().length).toBe(0);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the custom onDidChangeFiles as the watcher if available",
            "suites": [
                "Project",
                "when a custom directory-provider service is provided"
            ],
            "updatePoint": {
                "line": 481,
                "column": 68
            },
            "line": 481,
            "code": "    it('uses the custom onDidChangeFiles as the watcher if available', () => {\n      // Ensure that all preexisting watchers are stopped\n      waitsForPromise(() => stopAllWatchers());\n      const remotePath = 'ssh://another-directory:8080/does-exist';\n      runs(() => atom.project.setPaths([remotePath]));\n      waitsForPromise(() => atom.project.getWatcherPromise(remotePath));\n      runs(() => {\n        expect(onDidChangeFilesCallback).not.toBeNull();\n        const changeSpy = jasmine.createSpy('atom.project.onDidChangeFiles');\n        const disposable = atom.project.onDidChangeFiles(changeSpy);\n        const events = [{\n          action: 'created',\n          path: remotePath + '/test.txt'\n        }];\n        onDidChangeFilesCallback(events);\n        expect(changeSpy).toHaveBeenCalledWith(events);\n        disposable.dispose();\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a new edit session for the given path and emits 'buffer-created'",
            "suites": [
                "Project",
                ".open(path)",
                "when given an absolute path that isn't currently open"
            ],
            "updatePoint": {
                "line": 509,
                "column": 82
            },
            "line": 509,
            "code": "      it(\"returns a new edit session for the given path and emits 'buffer-created'\", () => {\n        let editor = null;\n        waitsForPromise(() => atom.workspace.open(absolutePath).then(o => {\n          editor = o;\n        }));\n        runs(() => {\n          expect(editor.buffer.getPath()).toBe(absolutePath);\n          expect(newBufferHandler).toHaveBeenCalledWith(editor.buffer);\n        });\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a new edit session for the given path (relative to the project root) and emits 'buffer-created'",
            "suites": [
                "Project",
                ".open(path)",
                "when given a relative path that isn't currently opened"
            ],
            "updatePoint": {
                "line": 521,
                "column": 113
            },
            "line": 521,
            "code": "      it(\"returns a new edit session for the given path (relative to the project root) and emits 'buffer-created'\", () => {\n        let editor = null;\n        waitsForPromise(() => atom.workspace.open(absolutePath).then(o => {\n          editor = o;\n        }));\n        runs(() => {\n          expect(editor.buffer.getPath()).toBe(absolutePath);\n          expect(newBufferHandler).toHaveBeenCalledWith(editor.buffer);\n        });\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a new edit session containing currently opened buffer",
            "suites": [
                "Project",
                ".open(path)",
                "when passed the path to a buffer that is currently opened"
            ],
            "updatePoint": {
                "line": 533,
                "column": 71
            },
            "line": 533,
            "code": "      it('returns a new edit session containing currently opened buffer', () => {\n        let editor = null;\n        waitsForPromise(() => atom.workspace.open(absolutePath).then(o => {\n          editor = o;\n        }));\n        runs(() => newBufferHandler.reset());\n        waitsForPromise(() => atom.workspace.open(absolutePath).then(({\n          buffer\n        }) => expect(buffer).toBe(editor.buffer)));\n        waitsForPromise(() => atom.workspace.open('a').then(({\n          buffer\n        }) => {\n          expect(buffer).toBe(editor.buffer);\n          expect(newBufferHandler).not.toHaveBeenCalled();\n        }));\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a new edit session and emits 'buffer-created'",
            "suites": [
                "Project",
                ".open(path)",
                "when not passed a path"
            ],
            "updatePoint": {
                "line": 551,
                "column": 63
            },
            "line": 551,
            "code": "      it(\"returns a new edit session and emits 'buffer-created'\", () => {\n        let editor = null;\n        waitsForPromise(() => atom.workspace.open().then(o => {\n          editor = o;\n        }));\n        runs(() => {\n          expect(editor.buffer.getPath()).toBeUndefined();\n          expect(newBufferHandler).toHaveBeenCalledWith(editor.buffer);\n        });\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not create a new buffer",
            "suites": [
                "Project",
                ".bufferForPath(path)",
                "when opening a previously opened path"
            ],
            "updatePoint": {
                "line": 571,
                "column": 38
            },
            "line": 571,
            "code": "      it('does not create a new buffer', () => {\n        waitsForPromise(() => atom.project.bufferForPath('a').then(anotherBuffer => expect(anotherBuffer).toBe(buffer)));\n        waitsForPromise(() => atom.project.bufferForPath('b').then(anotherBuffer => expect(anotherBuffer).not.toBe(buffer)));\n        waitsForPromise(() => Promise.all([atom.project.bufferForPath('c'), atom.project.bufferForPath('c')]).then(([buffer1, buffer2]) => {\n          expect(buffer1).toBe(buffer2);\n        }));\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "retries loading the buffer if it previously failed",
            "suites": [
                "Project",
                ".bufferForPath(path)",
                "when opening a previously opened path"
            ],
            "updatePoint": {
                "line": 578,
                "column": 60
            },
            "line": 578,
            "code": "      it('retries loading the buffer if it previously failed', () => {\n        waitsForPromise({\n          shouldReject: true\n        }, () => {\n          spyOn(TextBuffer, 'load').andCallFake(() => Promise.reject(new Error('Could not open file')));\n          return atom.project.bufferForPath('b');\n        });\n        waitsForPromise({\n          shouldReject: false\n        }, () => {\n          TextBuffer.load.andCallThrough();\n          return atom.project.bufferForPath('b');\n        });\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new buffer if the previous buffer was destroyed",
            "suites": [
                "Project",
                ".bufferForPath(path)",
                "when opening a previously opened path"
            ],
            "updatePoint": {
                "line": 592,
                "column": 67
            },
            "line": 592,
            "code": "      it('creates a new buffer if the previous buffer was destroyed', () => {\n        buffer.release();\n        waitsForPromise(() => atom.project.bufferForPath('b').then(anotherBuffer => expect(anotherBuffer).not.toBe(buffer)));\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves to null when the directory does not have a repository",
            "suites": [
                "Project",
                ".repositoryForDirectory(directory)"
            ],
            "updatePoint": {
                "line": 599,
                "column": 70
            },
            "line": 599,
            "code": "    it('resolves to null when the directory does not have a repository', () => {\n      waitsForPromise(() => {\n        const directory = new Directory('/tmp');\n        return atom.project.repositoryForDirectory(directory).then(result => {\n          expect(result).toBeNull();\n          expect(atom.project.repositoryProviders.length).toBeGreaterThan(0);\n          expect(atom.project.repositoryPromisesByPath.size).toBe(0);\n        });\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves to a GitRepository and is cached when the given directory is a Git repo",
            "suites": [
                "Project",
                ".repositoryForDirectory(directory)"
            ],
            "updatePoint": {
                "line": 609,
                "column": 88
            },
            "line": 609,
            "code": "    it('resolves to a GitRepository and is cached when the given directory is a Git repo', () => {\n      waitsForPromise(() => {\n        const directory = new Directory(path.join(__dirname, '..'));\n        const promise = atom.project.repositoryForDirectory(directory);\n        return promise.then(result => {\n          expect(result).toBeInstanceOf(GitRepository);\n          const dirPath = directory.getRealPathSync();\n          expect(result.getPath()).toBe(path.join(dirPath, '.git')); // Verify that the result is cached.\n\n          expect(atom.project.repositoryForDirectory(directory)).toBe(promise);\n        });\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new repository if a previous one with the same directory had been destroyed",
            "suites": [
                "Project",
                ".repositoryForDirectory(directory)"
            ],
            "updatePoint": {
                "line": 622,
                "column": 93
            },
            "line": 622,
            "code": "    it('creates a new repository if a previous one with the same directory had been destroyed', () => {\n      let repository = null;\n      const directory = new Directory(path.join(__dirname, '..'));\n      waitsForPromise(() => atom.project.repositoryForDirectory(directory).then(repo => {\n        repository = repo;\n      }));\n      runs(() => {\n        expect(repository.isDestroyed()).toBe(false);\n        repository.destroy();\n        expect(repository.isDestroyed()).toBe(true);\n      });\n      waitsForPromise(() => atom.project.repositoryForDirectory(directory).then(repo => {\n        repository = repo;\n      }));\n      runs(() => expect(repository.isDestroyed()).toBe(false));\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets its path to the file's parent directory and updates the root directory",
            "suites": [
                "Project",
                ".setPaths(paths, options)",
                "when path is a file"
            ],
            "updatePoint": {
                "line": 641,
                "column": 85
            },
            "line": 641,
            "code": "      it(\"sets its path to the file's parent directory and updates the root directory\", () => {\n        const filePath = require.resolve('./fixtures/dir/a');\n\n        atom.project.setPaths([filePath]);\n        expect(atom.project.getPaths()[0]).toEqual(path.dirname(filePath));\n        expect(atom.project.getDirectories()[0].path).toEqual(path.dirname(filePath));\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "assigns the directories and repositories",
            "suites": [
                "Project",
                ".setPaths(paths, options)",
                "when path is a directory"
            ],
            "updatePoint": {
                "line": 650,
                "column": 50
            },
            "line": 650,
            "code": "      it('assigns the directories and repositories', () => {\n        const directory1 = temp.mkdirSync('non-git-repo');\n        const directory2 = temp.mkdirSync('git-repo1');\n        const directory3 = temp.mkdirSync('git-repo2');\n        const gitDirPath = fs.absolute(path.join(__dirname, 'fixtures', 'git', 'master.git'));\n        fs.copySync(gitDirPath, path.join(directory2, '.git'));\n        fs.copySync(gitDirPath, path.join(directory3, '.git'));\n        atom.project.setPaths([directory1, directory2, directory3]);\n        const [repo1, repo2, repo3] = atom.project.getRepositories();\n        expect(repo1).toBeNull();\n        expect(repo2.getShortHead()).toBe('master');\n        expect(repo2.getPath()).toBe(fs.realpathSync(path.join(directory2, '.git')));\n        expect(repo3.getShortHead()).toBe('master');\n        expect(repo3.getPath()).toBe(fs.realpathSync(path.join(directory3, '.git')));\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls callbacks registered with ::onDidChangePaths",
            "suites": [
                "Project",
                ".setPaths(paths, options)",
                "when path is a directory"
            ],
            "updatePoint": {
                "line": 665,
                "column": 60
            },
            "line": 665,
            "code": "      it('calls callbacks registered with ::onDidChangePaths', () => {\n        const onDidChangePathsSpy = jasmine.createSpy('onDidChangePaths spy');\n        atom.project.onDidChangePaths(onDidChangePathsSpy);\n        const paths = [temp.mkdirSync('dir1'), temp.mkdirSync('dir2')];\n        atom.project.setPaths(paths);\n        expect(onDidChangePathsSpy.callCount).toBe(1);\n        expect(onDidChangePathsSpy.mostRecentCall.args[0]).toEqual(paths);\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "optionally throws an error with any paths that did not exist",
            "suites": [
                "Project",
                ".setPaths(paths, options)",
                "when path is a directory"
            ],
            "updatePoint": {
                "line": 673,
                "column": 70
            },
            "line": 673,
            "code": "      it('optionally throws an error with any paths that did not exist', () => {\n        const paths = [temp.mkdirSync('exists0'), '/doesnt-exists/0', temp.mkdirSync('exists1'), '/doesnt-exists/1'];\n\n        try {\n          atom.project.setPaths(paths, {\n            mustExist: true\n          });\n          expect('no exception thrown').toBeUndefined();\n        } catch (e) {\n          expect(e.missingProjectPaths).toEqual([paths[1], paths[3]]);\n        }\n\n        expect(atom.project.getPaths()).toEqual([paths[0], paths[2]]);\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears its path",
            "suites": [
                "Project",
                ".setPaths(paths, options)",
                "when no paths are given"
            ],
            "updatePoint": {
                "line": 689,
                "column": 25
            },
            "line": 689,
            "code": "      it('clears its path', () => {\n        atom.project.setPaths([]);\n        expect(atom.project.getPaths()).toEqual([]);\n        expect(atom.project.getDirectories()).toEqual([]);\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "normalizes the path to remove consecutive slashes, ., and .. segments",
            "suites": [
                "Project",
                ".setPaths(paths, options)",
                "when no paths are given"
            ],
            "updatePoint": {
                "line": 695,
                "column": 77
            },
            "line": 695,
            "code": "    it('normalizes the path to remove consecutive slashes, ., and .. segments', () => {\n      atom.project.setPaths([`${require.resolve('./fixtures/dir/a')}${path.sep}b${path.sep}${path.sep}..`]);\n      expect(atom.project.getPaths()[0]).toEqual(path.dirname(require.resolve('./fixtures/dir/a')));\n      expect(atom.project.getDirectories()[0].path).toEqual(path.dirname(require.resolve('./fixtures/dir/a')));\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls callbacks registered with ::onDidChangePaths",
            "suites": [
                "Project",
                ".addPath(path, options)"
            ],
            "updatePoint": {
                "line": 702,
                "column": 58
            },
            "line": 702,
            "code": "    it('calls callbacks registered with ::onDidChangePaths', () => {\n      const onDidChangePathsSpy = jasmine.createSpy('onDidChangePaths spy');\n      atom.project.onDidChangePaths(onDidChangePathsSpy);\n      const [oldPath] = atom.project.getPaths();\n      const newPath = temp.mkdirSync('dir');\n      atom.project.addPath(newPath);\n      expect(onDidChangePathsSpy.callCount).toBe(1);\n      expect(onDidChangePathsSpy.mostRecentCall.args[0]).toEqual([oldPath, newPath]);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't add redundant paths",
            "suites": [
                "Project",
                ".addPath(path, options)"
            ],
            "updatePoint": {
                "line": 711,
                "column": 35
            },
            "line": 711,
            "code": "    it(\"doesn't add redundant paths\", () => {\n      const onDidChangePathsSpy = jasmine.createSpy('onDidChangePaths spy');\n      atom.project.onDidChangePaths(onDidChangePathsSpy);\n      const [oldPath] = atom.project.getPaths(); // Doesn't re-add an existing root directory\n\n      atom.project.addPath(oldPath);\n      expect(atom.project.getPaths()).toEqual([oldPath]);\n      expect(onDidChangePathsSpy).not.toHaveBeenCalled(); // Doesn't add an entry for a file-path within an existing root directory\n\n      atom.project.addPath(path.join(oldPath, 'some-file.txt'));\n      expect(atom.project.getPaths()).toEqual([oldPath]);\n      expect(onDidChangePathsSpy).not.toHaveBeenCalled(); // Does add an entry for a directory within an existing directory\n\n      const newPath = path.join(oldPath, 'a-dir');\n      atom.project.addPath(newPath);\n      expect(atom.project.getPaths()).toEqual([oldPath, newPath]);\n      expect(onDidChangePathsSpy).toHaveBeenCalled();\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't add non-existent directories",
            "suites": [
                "Project",
                ".addPath(path, options)"
            ],
            "updatePoint": {
                "line": 729,
                "column": 44
            },
            "line": 729,
            "code": "    it(\"doesn't add non-existent directories\", () => {\n      const previousPaths = atom.project.getPaths();\n      atom.project.addPath('/this-definitely/does-not-exist');\n      expect(atom.project.getPaths()).toEqual(previousPaths);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "optionally throws on non-existent directories",
            "suites": [
                "Project",
                ".addPath(path, options)"
            ],
            "updatePoint": {
                "line": 734,
                "column": 53
            },
            "line": 734,
            "code": "    it('optionally throws on non-existent directories', () => {\n      expect(() => atom.project.addPath('/this-definitely/does-not-exist', {\n        mustExist: true\n      })).toThrow();\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the directory and repository for the path",
            "suites": [
                "Project",
                ".removePath(path)"
            ],
            "updatePoint": {
                "line": 746,
                "column": 57
            },
            "line": 746,
            "code": "    it('removes the directory and repository for the path', () => {\n      const result = atom.project.removePath(atom.project.getPaths()[0]);\n      expect(atom.project.getDirectories()).toEqual([]);\n      expect(atom.project.getRepositories()).toEqual([]);\n      expect(atom.project.getPaths()).toEqual([]);\n      expect(result).toBe(true);\n      expect(onDidChangePathsSpy).toHaveBeenCalled();\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing if the path is not one of the project's root paths",
            "suites": [
                "Project",
                ".removePath(path)"
            ],
            "updatePoint": {
                "line": 754,
                "column": 71
            },
            "line": 754,
            "code": "    it(\"does nothing if the path is not one of the project's root paths\", () => {\n      const originalPaths = atom.project.getPaths();\n      const result = atom.project.removePath(originalPaths[0] + 'xyz');\n      expect(result).toBe(false);\n      expect(atom.project.getPaths()).toEqual(originalPaths);\n      expect(onDidChangePathsSpy).not.toHaveBeenCalled();\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't destroy the repository if it is shared by another root directory",
            "suites": [
                "Project",
                ".removePath(path)"
            ],
            "updatePoint": {
                "line": 761,
                "column": 80
            },
            "line": 761,
            "code": "    it(\"doesn't destroy the repository if it is shared by another root directory\", () => {\n      atom.project.setPaths([__dirname, path.join(__dirname, '..', 'src')]);\n      atom.project.removePath(__dirname);\n      expect(atom.project.getPaths()).toEqual([path.join(__dirname, '..', 'src')]);\n      expect(atom.project.getRepositories()[0].isSubmodule('src')).toBe(false);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes a path that is represented as a URI",
            "suites": [
                "Project",
                ".removePath(path)"
            ],
            "updatePoint": {
                "line": 767,
                "column": 51
            },
            "line": 767,
            "code": "    it('removes a path that is represented as a URI', () => {\n      atom.packages.serviceHub.provide('atom.directory-provider', '0.1.0', {\n        directoryForURISync(uri) {\n          return {\n            getPath() {\n              return uri;\n            },\n\n            getSubdirectory() {\n              return {};\n            },\n\n            isRoot() {\n              return true;\n            },\n\n            existsSync() {\n              return true;\n            },\n\n            off() {}\n\n          };\n        }\n\n      });\n      const ftpURI = 'ftp://example.com/some/folder';\n      atom.project.setPaths([ftpURI]);\n      expect(atom.project.getPaths()).toEqual([ftpURI]);\n      atom.project.removePath(ftpURI);\n      expect(atom.project.getPaths()).toEqual([]);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reports filesystem changes within project paths",
            "suites": [
                "Project",
                ".onDidChangeFiles()"
            ],
            "updatePoint": {
                "line": 843,
                "column": 55
            },
            "line": 843,
            "code": "    it('reports filesystem changes within project paths', async () => {\n      jasmine.useRealClock();\n      const dirOne = temp.mkdirSync('atom-spec-project-one');\n      const fileOne = path.join(dirOne, 'file-one.txt');\n      const fileTwo = path.join(dirOne, 'file-two.txt');\n      const dirTwo = temp.mkdirSync('atom-spec-project-two');\n      const fileThree = path.join(dirTwo, 'file-three.txt'); // Ensure that all preexisting watchers are stopped\n\n      await stopAllWatchers();\n      atom.project.setPaths([dirOne]);\n      await atom.project.getWatcherPromise(dirOne);\n      expect(atom.project.watcherPromisesByPath[dirTwo]).toEqual(undefined);\n      fs.writeFileSync(fileThree, 'three\\n');\n      fs.writeFileSync(fileTwo, 'two\\n');\n      fs.writeFileSync(fileOne, 'one\\n');\n      await waitForEvents([fileOne, fileTwo]);\n      expect(events.some(event => event.path === fileThree)).toBeFalsy();\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the callback with added text buffers",
            "suites": [
                "Project",
                ".onDidAddBuffer()"
            ],
            "updatePoint": {
                "line": 863,
                "column": 52
            },
            "line": 863,
            "code": "    it('invokes the callback with added text buffers', () => {\n      const buffers = [];\n      const added = [];\n      waitsForPromise(() => atom.project.buildBuffer(require.resolve('./fixtures/dir/a')).then(o => buffers.push(o)));\n      runs(() => {\n        expect(buffers.length).toBe(1);\n        atom.project.onDidAddBuffer(buffer => added.push(buffer));\n      });\n      waitsForPromise(() => atom.project.buildBuffer(require.resolve('./fixtures/dir/b')).then(o => buffers.push(o)));\n      runs(() => {\n        expect(buffers.length).toBe(2);\n        expect(added).toEqual([buffers[1]]);\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the observer with current and future text buffers",
            "suites": [
                "Project",
                ".observeBuffers()"
            ],
            "updatePoint": {
                "line": 879,
                "column": 65
            },
            "line": 879,
            "code": "    it('invokes the observer with current and future text buffers', () => {\n      const buffers = [];\n      const observed = [];\n      waitsForPromise(() => atom.project.buildBuffer(require.resolve('./fixtures/dir/a')).then(o => buffers.push(o)));\n      waitsForPromise(() => atom.project.buildBuffer(require.resolve('./fixtures/dir/b')).then(o => buffers.push(o)));\n      runs(() => {\n        expect(buffers.length).toBe(2);\n        atom.project.observeBuffers(buffer => observed.push(buffer));\n        expect(observed).toEqual(buffers);\n      });\n      waitsForPromise(() => atom.project.buildBuffer(require.resolve('./fixtures/dir/b')).then(o => buffers.push(o)));\n      runs(() => {\n        expect(observed.length).toBe(3);\n        expect(buffers.length).toBe(3);\n        expect(observed).toEqual(buffers);\n      });\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the observer with current and future repositories",
            "suites": [
                "Project",
                ".observeRepositories()"
            ],
            "updatePoint": {
                "line": 898,
                "column": 65
            },
            "line": 898,
            "code": "    it('invokes the observer with current and future repositories', () => {\n      const observed = [];\n      const directory1 = temp.mkdirSync('git-repo1');\n      const gitDirPath1 = fs.absolute(path.join(__dirname, 'fixtures', 'git', 'master.git'));\n      fs.copySync(gitDirPath1, path.join(directory1, '.git'));\n      const directory2 = temp.mkdirSync('git-repo2');\n      const gitDirPath2 = fs.absolute(path.join(__dirname, 'fixtures', 'git', 'repo-with-submodules', 'git.git'));\n      fs.copySync(gitDirPath2, path.join(directory2, '.git'));\n      atom.project.setPaths([directory1]);\n      const disposable = atom.project.observeRepositories(repo => observed.push(repo));\n      expect(observed.length).toBe(1);\n      expect(observed[0].getReferenceTarget('refs/heads/master')).toBe('ef046e9eecaa5255ea5e9817132d4001724d6ae1');\n      atom.project.addPath(directory2);\n      expect(observed.length).toBe(2);\n      expect(observed[1].getReferenceTarget('refs/heads/master')).toBe('d2b0ad9cbc6f6c4372e8956e5cc5af771b2342e5');\n      disposable.dispose();\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes callback when a path is added and the path is the root of a repository",
            "suites": [
                "Project",
                ".onDidAddRepository()"
            ],
            "updatePoint": {
                "line": 917,
                "column": 86
            },
            "line": 917,
            "code": "    it('invokes callback when a path is added and the path is the root of a repository', () => {\n      const observed = [];\n      const disposable = atom.project.onDidAddRepository(repo => observed.push(repo));\n      const projectRootPath = temp.mkdirSync();\n      const fixtureRepoPath = fs.absolute(path.join(__dirname, 'fixtures', 'git', 'master.git'));\n      fs.copySync(fixtureRepoPath, path.join(projectRootPath, '.git'));\n      atom.project.addPath(projectRootPath);\n      expect(observed.length).toBe(1);\n      expect(observed[0].getOriginURL()).toEqual('https://github.com/example-user/example-repo.git');\n      disposable.dispose();\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes callback when a path is added and the path is subdirectory of a repository",
            "suites": [
                "Project",
                ".onDidAddRepository()"
            ],
            "updatePoint": {
                "line": 928,
                "column": 90
            },
            "line": 928,
            "code": "    it('invokes callback when a path is added and the path is subdirectory of a repository', () => {\n      const observed = [];\n      const disposable = atom.project.onDidAddRepository(repo => observed.push(repo));\n      const projectRootPath = temp.mkdirSync();\n      const fixtureRepoPath = fs.absolute(path.join(__dirname, 'fixtures', 'git', 'master.git'));\n      fs.copySync(fixtureRepoPath, path.join(projectRootPath, '.git'));\n      const projectSubDirPath = path.join(projectRootPath, 'sub-dir');\n      fs.mkdirSync(projectSubDirPath);\n      atom.project.addPath(projectSubDirPath);\n      expect(observed.length).toBe(1);\n      expect(observed[0].getOriginURL()).toEqual('https://github.com/example-user/example-repo.git');\n      disposable.dispose();\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not invoke callback when a path is added and the path is not part of a repository",
            "suites": [
                "Project",
                ".onDidAddRepository()"
            ],
            "updatePoint": {
                "line": 941,
                "column": 94
            },
            "line": 941,
            "code": "    it('does not invoke callback when a path is added and the path is not part of a repository', () => {\n      const observed = [];\n      const disposable = atom.project.onDidAddRepository(repo => observed.push(repo));\n      atom.project.addPath(temp.mkdirSync('not-a-repository'));\n      expect(observed.length).toBe(0);\n      disposable.dispose();\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the path, relative to whichever root directory it is inside of",
            "suites": [
                "Project",
                ".relativize(path)"
            ],
            "updatePoint": {
                "line": 950,
                "column": 78
            },
            "line": 950,
            "code": "    it('returns the path, relative to whichever root directory it is inside of', () => {\n      atom.project.addPath(temp.mkdirSync('another-path'));\n      let rootPath = atom.project.getPaths()[0];\n      let childPath = path.join(rootPath, 'some', 'child', 'directory');\n      expect(atom.project.relativize(childPath)).toBe(path.join('some', 'child', 'directory'));\n      rootPath = atom.project.getPaths()[1];\n      childPath = path.join(rootPath, 'some', 'child', 'directory');\n      expect(atom.project.relativize(childPath)).toBe(path.join('some', 'child', 'directory'));\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the given path if it is not in any of the root directories",
            "suites": [
                "Project",
                ".relativize(path)"
            ],
            "updatePoint": {
                "line": 959,
                "column": 74
            },
            "line": 959,
            "code": "    it('returns the given path if it is not in any of the root directories', () => {\n      const randomPath = path.join('some', 'random', 'path');\n      expect(atom.project.relativize(randomPath)).toBe(randomPath);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the root path that contains the given path, and the path relativized to that root path",
            "suites": [
                "Project",
                ".relativizePath(path)"
            ],
            "updatePoint": {
                "line": 965,
                "column": 102
            },
            "line": 965,
            "code": "    it('returns the root path that contains the given path, and the path relativized to that root path', () => {\n      atom.project.addPath(temp.mkdirSync('another-path'));\n      let rootPath = atom.project.getPaths()[0];\n      let childPath = path.join(rootPath, 'some', 'child', 'directory');\n      expect(atom.project.relativizePath(childPath)).toEqual([rootPath, path.join('some', 'child', 'directory')]);\n      rootPath = atom.project.getPaths()[1];\n      childPath = path.join(rootPath, 'some', 'child', 'directory');\n      expect(atom.project.relativizePath(childPath)).toEqual([rootPath, path.join('some', 'child', 'directory')]);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null for the root path, and the given path unchanged",
            "suites": [
                "Project",
                ".relativizePath(path)",
                "when the given path isn't inside of any of the project's path"
            ],
            "updatePoint": {
                "line": 975,
                "column": 70
            },
            "line": 975,
            "code": "      it('returns null for the root path, and the given path unchanged', () => {\n        const randomPath = path.join('some', 'random', 'path');\n        expect(atom.project.relativizePath(randomPath)).toEqual([null, randomPath]);\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null for the root path, and the given path unchanged",
            "suites": [
                "Project",
                ".relativizePath(path)",
                "when the given path is a URL"
            ],
            "updatePoint": {
                "line": 981,
                "column": 70
            },
            "line": 981,
            "code": "      it('returns null for the root path, and the given path unchanged', () => {\n        const url = 'http://the-path';\n        expect(atom.project.relativizePath(url)).toEqual([null, url]);\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the root folder that is closest to the given path",
            "suites": [
                "Project",
                ".relativizePath(path)",
                "when the given path is inside more than one root folder"
            ],
            "updatePoint": {
                "line": 987,
                "column": 64
            },
            "line": 987,
            "code": "      it('uses the root folder that is closest to the given path', () => {\n        atom.project.addPath(path.join(atom.project.getPaths()[0], 'a-dir'));\n        const inputPath = path.join(atom.project.getPaths()[1], 'somewhere/something.txt');\n        expect(atom.project.getDirectories()[0].contains(inputPath)).toBe(true);\n        expect(atom.project.getDirectories()[1].contains(inputPath)).toBe(true);\n        expect(atom.project.relativizePath(inputPath)).toEqual([atom.project.getPaths()[1], path.join('somewhere', 'something.txt')]);\n      });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns whether or not the given path is in one of the root directories",
            "suites": [
                "Project",
                ".contains(path)"
            ],
            "updatePoint": {
                "line": 997,
                "column": 79
            },
            "line": 997,
            "code": "    it('returns whether or not the given path is in one of the root directories', () => {\n      const rootPath = atom.project.getPaths()[0];\n      const childPath = path.join(rootPath, 'some', 'child', 'directory');\n      expect(atom.project.contains(childPath)).toBe(true);\n      const randomPath = path.join('some', 'random', 'path');\n      expect(atom.project.contains(randomPath)).toBe(false);\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "normalizes disk drive letter in passed path on #win32",
            "suites": [
                "Project",
                ".resolvePath(uri)"
            ],
            "updatePoint": {
                "line": 1006,
                "column": 61
            },
            "line": 1006,
            "code": "    it('normalizes disk drive letter in passed path on #win32', () => {\n      expect(atom.project.resolvePath('d:\\\\file.txt')).toEqual('D:\\\\file.txt');\n    });",
            "file": "project-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "registers the 'reopen-project' command function",
            "suites": [
                "ReopenProjectMenuManager",
                "constructor"
            ],
            "updatePoint": {
                "line": 50,
                "column": 55
            },
            "line": 50,
            "code": "    it(\"registers the 'reopen-project' command function\", () => {\n      expect(commandRegistry.add).toHaveBeenCalled();\n      const cmdCall = commandRegistry.add.calls[0];\n      expect(cmdCall.args.length).toBe(2);\n      expect(cmdCall.args[0]).toBe('atom-workspace');\n      expect(typeof cmdCall.args[1]['application:reopen-project']).toBe('function');\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "disposes of the history, command and config disposables",
            "suites": [
                "ReopenProjectMenuManager",
                "dispose"
            ],
            "updatePoint": {
                "line": 59,
                "column": 63
            },
            "line": 59,
            "code": "    it('disposes of the history, command and config disposables', () => {\n      reopenProjects.dispose();\n      expect(historyDisposable.dispose).toHaveBeenCalled();\n      expect(configDisposable.dispose).toHaveBeenCalled();\n      expect(commandDisposable.dispose).toHaveBeenCalled();\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "disposes of the menu disposable once used",
            "suites": [
                "ReopenProjectMenuManager",
                "dispose"
            ],
            "updatePoint": {
                "line": 65,
                "column": 49
            },
            "line": 65,
            "code": "    it('disposes of the menu disposable once used', () => {\n      const menuDisposable = jasmine.createSpyObj('Disposable', ['dispose']);\n      menuManager.add.andReturn(menuDisposable);\n      reopenProjects.update();\n      expect(menuDisposable.dispose).not.toHaveBeenCalled();\n      reopenProjects.dispose();\n      expect(menuDisposable.dispose).toHaveBeenCalled();\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls open with the paths of the project specified by the detail index",
            "suites": [
                "ReopenProjectMenuManager",
                "the command"
            ],
            "updatePoint": {
                "line": 75,
                "column": 78
            },
            "line": 75,
            "code": "    it('calls open with the paths of the project specified by the detail index', () => {\n      historyManager.getProjects.andReturn([{\n        paths: ['/a']\n      }, {\n        paths: ['/b', 'c:\\\\']\n      }]);\n      reopenProjects.update();\n      const reopenProjectCommand = commandRegistry.add.calls[0].args[1]['application:reopen-project'];\n      reopenProjectCommand({\n        detail: {\n          index: 1\n        }\n      });\n      expect(openFunction).toHaveBeenCalled();\n      expect(openFunction.calls[0].args[0]).toEqual(['/b', 'c:\\\\']);\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not call open when no command detail is supplied",
            "suites": [
                "ReopenProjectMenuManager",
                "the command"
            ],
            "updatePoint": {
                "line": 91,
                "column": 61
            },
            "line": 91,
            "code": "    it('does not call open when no command detail is supplied', () => {\n      const reopenProjectCommand = commandRegistry.add.calls[0].args[1]['application:reopen-project'];\n      reopenProjectCommand({});\n      expect(openFunction).not.toHaveBeenCalled();\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not call open when no command detail index is supplied",
            "suites": [
                "ReopenProjectMenuManager",
                "the command"
            ],
            "updatePoint": {
                "line": 96,
                "column": 67
            },
            "line": 96,
            "code": "    it('does not call open when no command detail index is supplied', () => {\n      const reopenProjectCommand = commandRegistry.add.calls[0].args[1]['application:reopen-project'];\n      reopenProjectCommand({\n        detail: {\n          anything: 'here'\n        }\n      });\n      expect(openFunction).not.toHaveBeenCalled();\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds menu items to MenuManager based on projects from HistoryManager",
            "suites": [
                "ReopenProjectMenuManager",
                "update"
            ],
            "updatePoint": {
                "line": 107,
                "column": 76
            },
            "line": 107,
            "code": "    it('adds menu items to MenuManager based on projects from HistoryManager', () => {\n      historyManager.getProjects.andReturn([{\n        paths: ['/a']\n      }, {\n        paths: ['/b', 'c:\\\\']\n      }]);\n      reopenProjects.update();\n      expect(historyManager.getProjects).toHaveBeenCalled();\n      expect(menuManager.add).toHaveBeenCalled();\n      const menuArg = menuManager.add.calls[0].args[0];\n      expect(menuArg.length).toBe(1);\n      expect(menuArg[0].label).toBe('File');\n      expect(menuArg[0].submenu.length).toBe(1);\n      const projectsMenu = menuArg[0].submenu[0];\n      expect(projectsMenu.label).toBe('Reopen Project');\n      expect(projectsMenu.submenu.length).toBe(2);\n      const first = projectsMenu.submenu[0];\n      expect(first.label).toBe('/a');\n      expect(first.command).toBe('application:reopen-project');\n      expect(first.commandDetail).toEqual({\n        index: 0,\n        paths: ['/a']\n      });\n      const second = projectsMenu.submenu[1];\n      expect(second.label).toBe('b, c:\\\\');\n      expect(second.command).toBe('application:reopen-project');\n      expect(second.commandDetail).toEqual({\n        index: 1,\n        paths: ['/b', 'c:\\\\']\n      });\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds only the number of menu items specified in the 'core.reopenProjectMenuCount' config",
            "suites": [
                "ReopenProjectMenuManager",
                "update"
            ],
            "updatePoint": {
                "line": 138,
                "column": 96
            },
            "line": 138,
            "code": "    it(\"adds only the number of menu items specified in the 'core.reopenProjectMenuCount' config\", () => {\n      historyManager.getProjects.andReturn(numberRange(1, 100).map(i => ({\n        paths: ['/test/' + i]\n      })));\n      reopenProjects.update();\n      expect(menuManager.add).toHaveBeenCalled();\n      const menu = menuManager.add.calls[0].args[0][0];\n      expect(menu.label).toBe('File');\n      expect(menu.submenu.length).toBe(1);\n      expect(menu.submenu[0].label).toBe('Reopen Project');\n      expect(menu.submenu[0].submenu.length).toBe(10);\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "disposes the previously menu built",
            "suites": [
                "ReopenProjectMenuManager",
                "update"
            ],
            "updatePoint": {
                "line": 150,
                "column": 42
            },
            "line": 150,
            "code": "    it('disposes the previously menu built', () => {\n      const menuDisposable = jasmine.createSpyObj('Disposable', ['dispose']);\n      menuManager.add.andReturn(menuDisposable);\n      reopenProjects.update();\n      expect(menuDisposable.dispose).not.toHaveBeenCalled();\n      reopenProjects.update();\n      expect(menuDisposable.dispose).toHaveBeenCalled();\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is called when the Config changes for 'core.reopenProjectMenuCount'",
            "suites": [
                "ReopenProjectMenuManager",
                "update"
            ],
            "updatePoint": {
                "line": 158,
                "column": 75
            },
            "line": 158,
            "code": "    it(\"is called when the Config changes for 'core.reopenProjectMenuCount'\", () => {\n      historyManager.getProjects.andReturn(numberRange(1, 100).map(i => ({\n        paths: ['/test/' + i]\n      })));\n      reopenProjects.update();\n      config.get.andReturn(25);\n      config.didChangeListener['core.reopenProjectMenuCount']({\n        oldValue: 10,\n        newValue: 25\n      });\n      const finalArgs = menuManager.add.calls[1].args[0];\n      const projectsMenu = finalArgs[0].submenu[0].submenu;\n      expect(projectsMenu.length).toBe(25);\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "is called when the HistoryManager's projects change",
            "suites": [
                "ReopenProjectMenuManager",
                "update"
            ],
            "updatePoint": {
                "line": 172,
                "column": 59
            },
            "line": 172,
            "code": "    it(\"is called when the HistoryManager's projects change\", () => {\n      reopenProjects.update();\n      historyManager.getProjects.andReturn([{\n        paths: ['/a']\n      }, {\n        paths: ['/b', 'c:\\\\']\n      }]);\n      historyManager.changeProjectsListener();\n      expect(menuManager.add.calls.length).toBe(2);\n      const finalArgs = menuManager.add.calls[1].args[0];\n      const projectsMenu = finalArgs[0].submenu[0];\n      const first = projectsMenu.submenu[0];\n      expect(first.label).toBe('/a');\n      expect(first.command).toBe('application:reopen-project');\n      expect(first.commandDetail).toEqual({\n        index: 0,\n        paths: ['/a']\n      });\n      const second = projectsMenu.submenu[1];\n      expect(second.label).toBe('b, c:\\\\');\n      expect(second.command).toBe('application:reopen-project');\n      expect(second.commandDetail).toEqual({\n        index: 1,\n        paths: ['/b', 'c:\\\\']\n      });\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates correct menu items commands for recent projects",
            "suites": [
                "ReopenProjectMenuManager",
                "updateProjects"
            ],
            "updatePoint": {
                "line": 200,
                "column": 63
            },
            "line": 200,
            "code": "    it('creates correct menu items commands for recent projects', () => {\n      const projects = [{\n        paths: ['/users/neila']\n      }, {\n        paths: ['/users/buzza', 'users/michaelc']\n      }];\n      const menu = ReopenProjectMenuManager.createProjectsMenu(projects);\n      expect(menu.label).toBe('File');\n      expect(menu.submenu.length).toBe(1);\n      const recentMenu = menu.submenu[0];\n      expect(recentMenu.label).toBe('Reopen Project');\n      expect(recentMenu.submenu.length).toBe(2);\n      const first = recentMenu.submenu[0];\n      expect(first.label).toBe('/users/neila');\n      expect(first.command).toBe('application:reopen-project');\n      expect(first.commandDetail).toEqual({\n        index: 0,\n        paths: ['/users/neila']\n      });\n      const second = recentMenu.submenu[1];\n      expect(second.label).toBe('buzza, michaelc');\n      expect(second.command).toBe('application:reopen-project');\n      expect(second.commandDetail).toEqual({\n        index: 1,\n        paths: ['/users/buzza', 'users/michaelc']\n      });\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the Unix path unchanged if there is only one",
            "suites": [
                "ReopenProjectMenuManager",
                "createLabel"
            ],
            "updatePoint": {
                "line": 229,
                "column": 60
            },
            "line": 229,
            "code": "    it('returns the Unix path unchanged if there is only one', () => {\n      const label = ReopenProjectMenuManager.createLabel({\n        paths: ['/a/b/c/d/e/f']\n      });\n      expect(label).toBe('/a/b/c/d/e/f');\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the Windows path unchanged if there is only one",
            "suites": [
                "ReopenProjectMenuManager",
                "createLabel"
            ],
            "updatePoint": {
                "line": 235,
                "column": 63
            },
            "line": 235,
            "code": "    it('returns the Windows path unchanged if there is only one', () => {\n      const label = ReopenProjectMenuManager.createLabel({\n        paths: ['c:\\\\missions\\\\apollo11']\n      });\n      expect(label).toBe('c:\\\\missions\\\\apollo11');\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the URL unchanged if there is only one",
            "suites": [
                "ReopenProjectMenuManager",
                "createLabel"
            ],
            "updatePoint": {
                "line": 241,
                "column": 54
            },
            "line": 241,
            "code": "    it('returns the URL unchanged if there is only one', () => {\n      const label = ReopenProjectMenuManager.createLabel({\n        paths: ['https://launch.pad/apollo/11']\n      });\n      expect(label).toBe('https://launch.pad/apollo/11');\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a comma-separated list of base names if there are multiple",
            "suites": [
                "ReopenProjectMenuManager",
                "createLabel"
            ],
            "updatePoint": {
                "line": 247,
                "column": 74
            },
            "line": 247,
            "code": "    it('returns a comma-separated list of base names if there are multiple', () => {\n      const project = {\n        paths: ['/var/one', '/usr/bin/two', '/etc/mission/control/three']\n      };\n      const label = ReopenProjectMenuManager.createLabel(project);\n      expect(label).toBe('one, two, three');\n    });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the standard base name for an absolute Unix path",
            "suites": [
                "ReopenProjectMenuManager",
                "createLabel",
                "betterBaseName"
            ],
            "updatePoint": {
                "line": 255,
                "column": 66
            },
            "line": 255,
            "code": "      it('returns the standard base name for an absolute Unix path', () => {\n        const name = ReopenProjectMenuManager.betterBaseName('/one/to/three');\n        expect(name).toBe('three');\n      });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the standard base name for a relative Windows path",
            "suites": [
                "ReopenProjectMenuManager",
                "createLabel",
                "betterBaseName"
            ],
            "updatePoint": {
                "line": 259,
                "column": 68
            },
            "line": 259,
            "code": "      it('returns the standard base name for a relative Windows path', () => {\n        if (process.platform === 'win32') {\n          const name = ReopenProjectMenuManager.betterBaseName('.\\\\one\\\\two');\n          expect(name).toBe('two');\n        }\n      });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the standard base name for an absolute Windows path",
            "suites": [
                "ReopenProjectMenuManager",
                "createLabel",
                "betterBaseName"
            ],
            "updatePoint": {
                "line": 265,
                "column": 69
            },
            "line": 265,
            "code": "      it('returns the standard base name for an absolute Windows path', () => {\n        if (process.platform === 'win32') {\n          const name = ReopenProjectMenuManager.betterBaseName('c:\\\\missions\\\\apollo\\\\11');\n          expect(name).toBe('11');\n        }\n      });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the drive root for a Windows drive name",
            "suites": [
                "ReopenProjectMenuManager",
                "createLabel",
                "betterBaseName"
            ],
            "updatePoint": {
                "line": 271,
                "column": 57
            },
            "line": 271,
            "code": "      it('returns the drive root for a Windows drive name', () => {\n        const name = ReopenProjectMenuManager.betterBaseName('d:');\n        expect(name).toBe('d:\\\\');\n      });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the drive root for a Windows drive root",
            "suites": [
                "ReopenProjectMenuManager",
                "createLabel",
                "betterBaseName"
            ],
            "updatePoint": {
                "line": 275,
                "column": 57
            },
            "line": 275,
            "code": "      it('returns the drive root for a Windows drive root', () => {\n        const name = ReopenProjectMenuManager.betterBaseName('e:\\\\');\n        expect(name).toBe('e:\\\\');\n      });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the final path for a URI",
            "suites": [
                "ReopenProjectMenuManager",
                "createLabel",
                "betterBaseName"
            ],
            "updatePoint": {
                "line": 279,
                "column": 42
            },
            "line": 279,
            "code": "      it('returns the final path for a URI', () => {\n        const name = ReopenProjectMenuManager.betterBaseName('https://something/else');\n        expect(name).toBe('else');\n      });",
            "file": "reopen-project-menu-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes nothing",
            "suites": [
                "Selection",
                ".deleteSelectedText()",
                "when nothing is selected"
            ],
            "updatePoint": {
                "line": 16,
                "column": 25
            },
            "line": 16,
            "code": "      it('deletes nothing', () => {\n        selection.setBufferRange([[0, 3], [0, 3]]);\n        selection.deleteSelectedText();\n        expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');\n      });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes selected text and clears the selection",
            "suites": [
                "Selection",
                ".deleteSelectedText()",
                "when one line is selected"
            ],
            "updatePoint": {
                "line": 23,
                "column": 56
            },
            "line": 23,
            "code": "      it('deletes selected text and clears the selection', () => {\n        selection.setBufferRange([[0, 4], [0, 14]]);\n        selection.deleteSelectedText();\n        expect(buffer.lineForRow(0)).toBe('var = function () {');\n        const endOfLine = buffer.lineForRow(0).length;\n        selection.setBufferRange([[0, 0], [0, endOfLine]]);\n        selection.deleteSelectedText();\n        expect(buffer.lineForRow(0)).toBe('');\n        expect(selection.isEmpty()).toBeTruthy();\n      });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes selected text and clears the selection",
            "suites": [
                "Selection",
                ".deleteSelectedText()",
                "when multiple lines are selected"
            ],
            "updatePoint": {
                "line": 35,
                "column": 56
            },
            "line": 35,
            "code": "      it('deletes selected text and clears the selection', () => {\n        selection.setBufferRange([[0, 1], [2, 39]]);\n        selection.deleteSelectedText();\n        expect(buffer.lineForRow(0)).toBe('v;');\n        expect(selection.isEmpty()).toBeTruthy();\n      });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes selected text and clears the selection",
            "suites": [
                "Selection",
                ".deleteSelectedText()",
                "when the cursor precedes the tail"
            ],
            "updatePoint": {
                "line": 43,
                "column": 56
            },
            "line": 43,
            "code": "      it('deletes selected text and clears the selection', () => {\n        selection.cursor.setScreenPosition([0, 13]);\n        selection.selectToScreenPosition([0, 4]);\n        selection.delete();\n        expect(buffer.lineForRow(0)).toBe('var  = function () {');\n        expect(selection.isEmpty()).toBeTruthy();\n      });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true if the cursor precedes the tail",
            "suites": [
                "Selection",
                ".isReversed()"
            ],
            "updatePoint": {
                "line": 53,
                "column": 52
            },
            "line": 53,
            "code": "    it('returns true if the cursor precedes the tail', () => {\n      selection.cursor.setScreenPosition([0, 20]);\n      selection.selectToScreenPosition([0, 10]);\n      expect(selection.isReversed()).toBeTruthy();\n      selection.selectToScreenPosition([0, 25]);\n      expect(selection.isReversed()).toBeFalsy();\n    });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects the specified row",
            "suites": [
                "Selection",
                ".selectLine(row)",
                "when passed a row"
            ],
            "updatePoint": {
                "line": 63,
                "column": 35
            },
            "line": 63,
            "code": "      it('selects the specified row', () => {\n        selection.setBufferRange([[2, 4], [3, 4]]);\n        selection.selectLine(5);\n        expect(selection.getBufferRange()).toEqual([[5, 0], [6, 0]]);\n      });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects all rows spanned by the selection",
            "suites": [
                "Selection",
                ".selectLine(row)",
                "when not passed a row"
            ],
            "updatePoint": {
                "line": 70,
                "column": 51
            },
            "line": 70,
            "code": "      it('selects all rows spanned by the selection', () => {\n        selection.setBufferRange([[2, 4], [3, 4]]);\n        selection.selectLine();\n        expect(selection.getBufferRange()).toEqual([[2, 0], [4, 0]]);\n      });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies ::onDidChangeRange observers",
            "suites": [
                "Selection",
                "when the selection's range is moved"
            ],
            "updatePoint": {
                "line": 78,
                "column": 45
            },
            "line": 78,
            "code": "    it('notifies ::onDidChangeRange observers', () => {\n      selection.setBufferRange([[2, 0], [2, 10]]);\n      const changeScreenRangeHandler = jasmine.createSpy('changeScreenRangeHandler');\n      selection.onDidChangeRange(changeScreenRangeHandler);\n      buffer.insert([2, 5], 'abc');\n      expect(changeScreenRangeHandler).toHaveBeenCalled();\n      expect(changeScreenRangeHandler.mostRecentCall.args[0]).not.toBeUndefined();\n    });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies ::onDidChangeRange observers",
            "suites": [
                "Selection",
                "when only the selection's tail is moved (regression)"
            ],
            "updatePoint": {
                "line": 88,
                "column": 45
            },
            "line": 88,
            "code": "    it('notifies ::onDidChangeRange observers', () => {\n      selection.setBufferRange([[2, 0], [2, 10]], {\n        reversed: true\n      });\n      const changeScreenRangeHandler = jasmine.createSpy('changeScreenRangeHandler');\n      selection.onDidChangeRange(changeScreenRangeHandler);\n      buffer.insert([2, 5], 'abc');\n      expect(changeScreenRangeHandler).toHaveBeenCalled();\n      expect(changeScreenRangeHandler.mostRecentCall.args[0]).not.toBeUndefined();\n    });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys its marker",
            "suites": [
                "Selection",
                "when the selection is destroyed"
            ],
            "updatePoint": {
                "line": 100,
                "column": 27
            },
            "line": 100,
            "code": "    it('destroys its marker', () => {\n      selection.setBufferRange([[2, 0], [2, 10]]);\n      const {\n        marker\n      } = selection;\n      selection.destroy();\n      expect(marker.isDestroyed()).toBeTruthy();\n    });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows pasting white space only lines when autoIndent is enabled",
            "suites": [
                "Selection",
                ".insertText(text, options)"
            ],
            "updatePoint": {
                "line": 110,
                "column": 72
            },
            "line": 110,
            "code": "    it('allows pasting white space only lines when autoIndent is enabled', () => {\n      selection.setBufferRange([[0, 0], [0, 0]]);\n      selection.insertText('    \\n    \\n\\n', {\n        autoIndent: true\n      });\n      expect(buffer.lineForRow(0)).toBe('    ');\n      expect(buffer.lineForRow(1)).toBe('    ');\n      expect(buffer.lineForRow(2)).toBe('');\n    });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "auto-indents if only a newline is inserted",
            "suites": [
                "Selection",
                ".insertText(text, options)"
            ],
            "updatePoint": {
                "line": 119,
                "column": 50
            },
            "line": 119,
            "code": "    it('auto-indents if only a newline is inserted', () => {\n      selection.setBufferRange([[2, 0], [3, 0]]);\n      selection.insertText('\\n', {\n        autoIndent: true\n      });\n      expect(buffer.lineForRow(2)).toBe('  ');\n    });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "auto-indents if only a carriage return + newline is inserted",
            "suites": [
                "Selection",
                ".insertText(text, options)"
            ],
            "updatePoint": {
                "line": 126,
                "column": 68
            },
            "line": 126,
            "code": "    it('auto-indents if only a carriage return + newline is inserted', () => {\n      selection.setBufferRange([[2, 0], [3, 0]]);\n      selection.insertText('\\r\\n', {\n        autoIndent: true\n      });\n      expect(buffer.lineForRow(2)).toBe('  ');\n    });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not adjust the indent of trailing lines if preserveTrailingLineIndentation is true",
            "suites": [
                "Selection",
                ".insertText(text, options)"
            ],
            "updatePoint": {
                "line": 133,
                "column": 95
            },
            "line": 133,
            "code": "    it('does not adjust the indent of trailing lines if preserveTrailingLineIndentation is true', () => {\n      selection.setBufferRange([[5, 0], [5, 0]]);\n      selection.insertText('      foo\\n    bar\\n', {\n        preserveTrailingLineIndentation: true,\n        indentBasis: 1\n      });\n      expect(buffer.lineForRow(6)).toBe('    bar');\n    });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "folds the buffer range spanned by the selection",
            "suites": [
                "Selection",
                ".fold()"
            ],
            "updatePoint": {
                "line": 143,
                "column": 55
            },
            "line": 143,
            "code": "    it('folds the buffer range spanned by the selection', () => {\n      selection.setBufferRange([[0, 3], [1, 6]]);\n      selection.fold();\n      expect(selection.getScreenRange()).toEqual([[0, 4], [0, 4]]);\n      expect(selection.getBufferRange()).toEqual([[1, 6], [1, 6]]);\n      expect(editor.lineTextForScreenRow(0)).toBe(`var${editor.displayLayer.foldCharacter}sort = function(items) {`);\n      expect(editor.isFoldedAtBufferRow(0)).toBe(true);\n    });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't create a fold when the selection is empty",
            "suites": [
                "Selection",
                ".fold()"
            ],
            "updatePoint": {
                "line": 151,
                "column": 57
            },
            "line": 151,
            "code": "    it(\"doesn't create a fold when the selection is empty\", () => {\n      selection.setBufferRange([[0, 3], [0, 3]]);\n      selection.fold();\n      expect(selection.getScreenRange()).toEqual([[0, 3], [0, 3]]);\n      expect(selection.getBufferRange()).toEqual([[0, 3], [0, 3]]);\n      expect(editor.lineTextForScreenRow(0)).toBe('var quicksort = function () {');\n      expect(editor.isFoldedAtBufferRow(0)).toBe(false);\n    });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error on ",
            "suites": [
                "Selection",
                "within a read-only editor",
                "without bypassReadOnly"
            ],
            "updatePoint": {
                "line": 237,
                "column": 38
            },
            "line": 237,
            "code": "        it(`throws an error on ${name}`, () => {\n          expect(op).toThrow();\n        });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "permits ",
            "suites": [
                "Selection",
                "within a read-only editor",
                "with bypassReadOnly"
            ],
            "updatePoint": {
                "line": 247,
                "column": 27
            },
            "line": 247,
            "code": "        it(`permits ${name}`, () => {\n          op({\n            bypassReadOnly: true\n          });\n        });",
            "file": "selection-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "quits the app on all squirrel events",
            "suites": [
                "Windows Squirrel Update"
            ],
            "updatePoint": {
                "line": 79,
                "column": 42
            },
            "line": 79,
            "code": "  it('quits the app on all squirrel events', function () {\n    expect(SquirrelUpdate.handleStartupEvent('--squirrel-install')).toBe(true);\n    waitsFor(() => electron.app.quit.callCount === 1);\n    runs(function () {\n      electron.app.quit.reset();\n      expect(SquirrelUpdate.handleStartupEvent('--squirrel-updated')).toBe(true);\n    });\n    waitsFor(() => electron.app.quit.callCount === 1);\n    runs(function () {\n      electron.app.quit.reset();\n      expect(SquirrelUpdate.handleStartupEvent('--squirrel-uninstall')).toBe(true);\n    });\n    waitsFor(() => electron.app.quit.callCount === 1);\n    runs(function () {\n      electron.app.quit.reset();\n      expect(SquirrelUpdate.handleStartupEvent('--squirrel-obsolete')).toBe(true);\n    });\n    waitsFor(() => electron.app.quit.callCount === 1);\n    runs(() => expect(SquirrelUpdate.handleStartupEvent('--not-squirrel')).toBe(false));\n  });",
            "file": "squirrel-update-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not exist before install",
            "suites": [
                "Windows Squirrel Update",
                "Desktop shortcut"
            ],
            "updatePoint": {
                "line": 113,
                "column": 37
            },
            "line": 113,
            "code": "    it('does not exist before install', () => expect(fs.existsSync(desktopShortcutPath)).toBe(false));",
            "file": "squirrel-update-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates desktop shortcut",
            "suites": [
                "Windows Squirrel Update",
                "Desktop shortcut",
                "on install"
            ],
            "updatePoint": {
                "line": 119,
                "column": 34
            },
            "line": 119,
            "code": "      it('creates desktop shortcut', () => expect(fs.existsSync(desktopShortcutPath)).toBe(true));",
            "file": "squirrel-update-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not recreate shortcut",
            "suites": [
                "Windows Squirrel Update",
                "Desktop shortcut",
                "on install",
                "when shortcut is deleted and then app is updated"
            ],
            "updatePoint": {
                "line": 127,
                "column": 38
            },
            "line": 127,
            "code": "        it('does not recreate shortcut', () => expect(fs.existsSync(desktopShortcutPath)).toBe(false));",
            "file": "squirrel-update-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "still has desktop shortcut",
            "suites": [
                "Windows Squirrel Update",
                "Desktop shortcut",
                "on install",
                "when shortcut is kept and app is updated"
            ],
            "updatePoint": {
                "line": 134,
                "column": 38
            },
            "line": 134,
            "code": "        it('still has desktop shortcut', () => expect(fs.existsSync(desktopShortcutPath)).toBe(true));",
            "file": "squirrel-update-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can save, load, and delete states",
            "suites": [
                "StateStore"
            ],
            "updatePoint": {
                "line": 7,
                "column": 39
            },
            "line": 7,
            "code": "  it('can save, load, and delete states', () => {\n    const store = new StateStore(databaseName, version);\n    return store.save('key', {\n      foo: 'bar'\n    }).then(() => store.load('key')).then(state => {\n      expect(state).toEqual({\n        foo: 'bar'\n      });\n    }).then(() => store.delete('key')).then(() => store.load('key')).then(value => {\n      expect(value).toBeNull();\n    }).then(() => store.count()).then(count => {\n      expect(count).toBe(0);\n    });\n  });",
            "file": "state-store-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resolves with null when a non-existent key is loaded",
            "suites": [
                "StateStore"
            ],
            "updatePoint": {
                "line": 21,
                "column": 58
            },
            "line": 21,
            "code": "  it('resolves with null when a non-existent key is loaded', () => {\n    const store = new StateStore(databaseName, version);\n    return store.load('no-such-key').then(value => {\n      expect(value).toBeNull();\n    });\n  });",
            "file": "state-store-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can clear the state object store",
            "suites": [
                "StateStore"
            ],
            "updatePoint": {
                "line": 27,
                "column": 38
            },
            "line": 27,
            "code": "  it('can clear the state object store', () => {\n    const store = new StateStore(databaseName, version);\n    return store.save('key', {\n      foo: 'bar'\n    }).then(() => store.count()).then(count => expect(count).toBe(1)).then(() => store.clear()).then(() => store.count()).then(count => {\n      expect(count).toBe(0);\n    });\n  });",
            "file": "state-store-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "rejects the promise returned by load",
            "suites": [
                "StateStore",
                "when there is an error reading from the database"
            ],
            "updatePoint": {
                "line": 36,
                "column": 44
            },
            "line": 36,
            "code": "    it('rejects the promise returned by load', () => {\n      const store = new StateStore(databaseName, version);\n      const fakeErrorEvent = {\n        target: {\n          errorCode: 'Something bad happened'\n        }\n      };\n      spyOn(IDBObjectStore.prototype, 'get').andCallFake(key => {\n        let request = {};\n        process.nextTick(() => request.onerror(fakeErrorEvent));\n        return request;\n      });\n      return store.load('nonexistentKey').then(() => {\n        throw new Error('Promise should have been rejected');\n      }).catch(event => {\n        expect(event).toBe(fakeErrorEvent);\n      });\n    });",
            "file": "state-store-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a style sheet based on the given source and returns a disposable allowing it to be removed",
            "suites": [
                "StyleManager",
                "::addStyleSheet(source, params)"
            ],
            "updatePoint": {
                "line": 31,
                "column": 103
            },
            "line": 31,
            "code": "    it('adds a style sheet based on the given source and returns a disposable allowing it to be removed', () => {\n      const disposable = styleManager.addStyleSheet('a {color: red}');\n      expect(addEvents.length).toBe(1);\n      expect(addEvents[0].textContent).toBe('a {color: red}');\n      const styleElements = styleManager.getStyleElements();\n      expect(styleElements.length).toBe(1);\n      expect(styleElements[0].textContent).toBe('a {color: red}');\n      disposable.dispose();\n      expect(removeEvents.length).toBe(1);\n      expect(removeEvents[0].textContent).toBe('a {color: red}');\n      expect(styleManager.getStyleElements().length).toBe(0);\n    });",
            "file": "style-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the ::shadow pseudo-element from atom-text-editor selectors",
            "suites": [
                "StyleManager",
                "::addStyleSheet(source, params)",
                "atom-text-editor shadow DOM selectors upgrades"
            ],
            "updatePoint": {
                "line": 50,
                "column": 77
            },
            "line": 50,
            "code": "      it('removes the ::shadow pseudo-element from atom-text-editor selectors', () => {\n        styleManager.addStyleSheet(`\n          atom-text-editor::shadow .class-1, atom-text-editor::shadow .class-2 { color: red }\n          atom-text-editor::shadow > .class-3 { color: yellow }\n          atom-text-editor .class-4 { color: blue }\n          atom-text-editor[data-grammar*=\"js\"]::shadow .class-6 { color: green; }\n          atom-text-editor[mini].is-focused::shadow .class-7 { color: green; }\n        `);\n        expect(Array.from(styleManager.getStyleElements()[0].sheet.cssRules).map(r => r.selectorText)).toEqual(['atom-text-editor.editor .class-1, atom-text-editor.editor .class-2', 'atom-text-editor.editor > .class-3', 'atom-text-editor .class-4', 'atom-text-editor[data-grammar*=\"js\"].editor .class-6', 'atom-text-editor[mini].is-focused.editor .class-7']);\n      });",
            "file": "style-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prepends \"--syntax\" to class selectors matching a grammar scope name and not already starting with \"syntax--\"",
            "suites": [
                "StyleManager",
                "::addStyleSheet(source, params)",
                "atom-text-editor shadow DOM selectors upgrades",
                "when a selector targets the atom-text-editor shadow DOM"
            ],
            "updatePoint": {
                "line": 61,
                "column": 121
            },
            "line": 61,
            "code": "        it('prepends \"--syntax\" to class selectors matching a grammar scope name and not already starting with \"syntax--\"', () => {\n          styleManager.addStyleSheet(`\n            .class-1 { color: red }\n            .source > .js, .source.coffee { color: green }\n            .syntax--source { color: gray }\n            #id-1 { color: blue }\n          `, {\n            context: 'atom-text-editor'\n          });\n          expect(Array.from(styleManager.getStyleElements()[0].sheet.cssRules).map(r => r.selectorText)).toEqual(['.class-1', '.syntax--source > .syntax--js, .syntax--source.syntax--coffee', '.syntax--source', '#id-1']);\n          styleManager.addStyleSheet(`\n            .source > .js, .source.coffee { color: green }\n            atom-text-editor::shadow .source > .js { color: yellow }\n            atom-text-editor[mini].is-focused::shadow .source > .js { color: gray }\n            atom-text-editor .source > .js { color: red }\n          `);\n          expect(Array.from(styleManager.getStyleElements()[1].sheet.cssRules).map(r => r.selectorText)).toEqual(['.source > .js, .source.coffee', 'atom-text-editor.editor .syntax--source > .syntax--js', 'atom-text-editor[mini].is-focused.editor .syntax--source > .syntax--js', 'atom-text-editor .source > .js']);\n        });",
            "file": "style-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces \":host\" with \"atom-text-editor\" only when the context of a style sheet is \"atom-text-editor\"",
            "suites": [
                "StyleManager",
                "::addStyleSheet(source, params)",
                "atom-text-editor shadow DOM selectors upgrades",
                "when a selector targets the atom-text-editor shadow DOM"
            ],
            "updatePoint": {
                "line": 80,
                "column": 111
            },
            "line": 80,
            "code": "      it('replaces \":host\" with \"atom-text-editor\" only when the context of a style sheet is \"atom-text-editor\"', () => {\n        styleManager.addStyleSheet(':host .class-1, :host .class-2 { color: red; }');\n        expect(Array.from(styleManager.getStyleElements()[0].sheet.cssRules).map(r => r.selectorText)).toEqual([':host .class-1, :host .class-2']);\n        styleManager.addStyleSheet(':host .class-1, :host .class-2 { color: red; }', {\n          context: 'atom-text-editor'\n        });\n        expect(Array.from(styleManager.getStyleElements()[1].sheet.cssRules).map(r => r.selectorText)).toEqual(['atom-text-editor .class-1, atom-text-editor .class-2']);\n      });",
            "file": "style-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw exceptions on rules with no selectors",
            "suites": [
                "StyleManager",
                "::addStyleSheet(source, params)",
                "atom-text-editor shadow DOM selectors upgrades",
                "when a selector targets the atom-text-editor shadow DOM"
            ],
            "updatePoint": {
                "line": 88,
                "column": 62
            },
            "line": 88,
            "code": "      it('does not throw exceptions on rules with no selectors', () => {\n        styleManager.addStyleSheet('@media screen {font-size: 10px}', {\n          context: 'atom-text-editor'\n        });\n      });",
            "file": "style-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ensures a maximum of one style element for the given source path, updating a previous if it exists",
            "suites": [
                "StyleManager",
                "::addStyleSheet(source, params)",
                "when a sourcePath parameter is specified"
            ],
            "updatePoint": {
                "line": 95,
                "column": 108
            },
            "line": 95,
            "code": "      it('ensures a maximum of one style element for the given source path, updating a previous if it exists', () => {\n        styleManager.addStyleSheet('a {color: red}', {\n          sourcePath: '/foo/bar'\n        });\n        expect(addEvents.length).toBe(1);\n        expect(addEvents[0].getAttribute('source-path')).toBe('/foo/bar');\n        const disposable2 = styleManager.addStyleSheet('a {color: blue}', {\n          sourcePath: '/foo/bar'\n        });\n        expect(addEvents.length).toBe(1);\n        expect(updateEvents.length).toBe(1);\n        expect(updateEvents[0].getAttribute('source-path')).toBe('/foo/bar');\n        expect(updateEvents[0].textContent).toBe('a {color: blue}');\n        disposable2.dispose();\n        addEvents = [];\n        styleManager.addStyleSheet('a {color: yellow}', {\n          sourcePath: '/foo/bar'\n        });\n        expect(addEvents.length).toBe(1);\n        expect(addEvents[0].getAttribute('source-path')).toBe('/foo/bar');\n        expect(addEvents[0].textContent).toBe('a {color: yellow}');\n      });",
            "file": "style-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts the style sheet based on the priority",
            "suites": [
                "StyleManager",
                "::addStyleSheet(source, params)",
                "when a priority parameter is specified"
            ],
            "updatePoint": {
                "line": 119,
                "column": 55
            },
            "line": 119,
            "code": "      it('inserts the style sheet based on the priority', () => {\n        styleManager.addStyleSheet('a {color: red}', {\n          priority: 1\n        });\n        styleManager.addStyleSheet('a {color: blue}', {\n          priority: 0\n        });\n        styleManager.addStyleSheet('a {color: green}', {\n          priority: 2\n        });\n        styleManager.addStyleSheet('a {color: yellow}', {\n          priority: 1\n        });\n        expect(styleManager.getStyleElements().map(elt => elt.textContent)).toEqual(['a {color: blue}', 'a {color: red}', 'a {color: yellow}', 'a {color: green}']);\n      });",
            "file": "style-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "renders a style tag for all currently active stylesheets in the style manager",
            "suites": [
                "StylesElement"
            ],
            "updatePoint": {
                "line": 18,
                "column": 83
            },
            "line": 18,
            "code": "  it('renders a style tag for all currently active stylesheets in the style manager', function () {\n    const initialChildCount = element.children.length;\n    const disposable1 = atom.styles.addStyleSheet('a {color: red;}');\n    expect(element.children.length).toBe(initialChildCount + 1);\n    expect(element.children[initialChildCount].textContent).toBe('a {color: red;}');\n    expect(addedStyleElements).toEqual([element.children[initialChildCount]]);\n    atom.styles.addStyleSheet('a {color: blue;}');\n    expect(element.children.length).toBe(initialChildCount + 2);\n    expect(element.children[initialChildCount + 1].textContent).toBe('a {color: blue;}');\n    expect(addedStyleElements).toEqual([element.children[initialChildCount], element.children[initialChildCount + 1]]);\n    disposable1.dispose();\n    expect(element.children.length).toBe(initialChildCount + 1);\n    expect(element.children[initialChildCount].textContent).toBe('a {color: blue;}');\n    expect(removedStyleElements).toEqual([addedStyleElements[0]]);\n  });",
            "file": "styles-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "orders style elements by priority",
            "suites": [
                "StylesElement"
            ],
            "updatePoint": {
                "line": 33,
                "column": 39
            },
            "line": 33,
            "code": "  it('orders style elements by priority', function () {\n    const initialChildCount = element.children.length;\n    atom.styles.addStyleSheet('a {color: red}', {\n      priority: 1\n    });\n    atom.styles.addStyleSheet('a {color: blue}', {\n      priority: 0\n    });\n    atom.styles.addStyleSheet('a {color: green}', {\n      priority: 2\n    });\n    atom.styles.addStyleSheet('a {color: yellow}', {\n      priority: 1\n    });\n    expect(element.children[initialChildCount].textContent).toBe('a {color: blue}');\n    expect(element.children[initialChildCount + 1].textContent).toBe('a {color: red}');\n    expect(element.children[initialChildCount + 2].textContent).toBe('a {color: yellow}');\n    expect(element.children[initialChildCount + 3].textContent).toBe('a {color: green}');\n  });",
            "file": "styles-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates existing style nodes when style elements are updated",
            "suites": [
                "StylesElement"
            ],
            "updatePoint": {
                "line": 52,
                "column": 66
            },
            "line": 52,
            "code": "  it('updates existing style nodes when style elements are updated', function () {\n    const initialChildCount = element.children.length;\n    atom.styles.addStyleSheet('a {color: red;}', {\n      sourcePath: '/foo/bar'\n    });\n    atom.styles.addStyleSheet('a {color: blue;}', {\n      sourcePath: '/foo/bar'\n    });\n    expect(element.children.length).toBe(initialChildCount + 1);\n    expect(element.children[initialChildCount].textContent).toBe('a {color: blue;}');\n    expect(updatedStyleElements).toEqual([element.children[initialChildCount]]);\n  });",
            "file": "styles-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only includes style elements matching the 'context' attribute",
            "suites": [
                "StylesElement"
            ],
            "updatePoint": {
                "line": 64,
                "column": 67
            },
            "line": 64,
            "code": "  it(\"only includes style elements matching the 'context' attribute\", function () {\n    const initialChildCount = element.children.length;\n    atom.styles.addStyleSheet('a {color: red;}', {\n      context: 'test-context'\n    });\n    atom.styles.addStyleSheet('a {color: green;}');\n    expect(element.children.length).toBe(initialChildCount + 2);\n    expect(element.children[initialChildCount].textContent).toBe('a {color: red;}');\n    expect(element.children[initialChildCount + 1].textContent).toBe('a {color: green;}');\n    element.setAttribute('context', 'test-context');\n    expect(element.children.length).toBe(1);\n    expect(element.children[0].textContent).toBe('a {color: red;}');\n    atom.styles.addStyleSheet('a {color: blue;}', {\n      context: 'test-context'\n    });\n    atom.styles.addStyleSheet('a {color: yellow;}');\n    expect(element.children.length).toBe(2);\n    expect(element.children[0].textContent).toBe('a {color: red;}');\n    expect(element.children[1].textContent).toBe('a {color: blue;}');\n  });",
            "file": "styles-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can match immediate child selectors",
            "suites": [
                "SyntaxScopeMap"
            ],
            "updatePoint": {
                "line": 4,
                "column": 41
            },
            "line": 4,
            "code": "  it('can match immediate child selectors', () => {\n    const map = new SyntaxScopeMap({\n      'a > b > c': 'x',\n      'b > c': 'y',\n      c: 'z'\n    });\n    expect(map.get(['a', 'b', 'c'], [0, 0, 0])).toBe('x');\n    expect(map.get(['d', 'b', 'c'], [0, 0, 0])).toBe('y');\n    expect(map.get(['d', 'e', 'c'], [0, 0, 0])).toBe('z');\n    expect(map.get(['e', 'c'], [0, 0, 0])).toBe('z');\n    expect(map.get(['c'], [0, 0, 0])).toBe('z');\n    expect(map.get(['d'], [0, 0, 0])).toBe(undefined);\n  });",
            "file": "syntax-scope-map-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can match :nth-child pseudo-selectors on leaves",
            "suites": [
                "SyntaxScopeMap"
            ],
            "updatePoint": {
                "line": 17,
                "column": 53
            },
            "line": 17,
            "code": "  it('can match :nth-child pseudo-selectors on leaves', () => {\n    const map = new SyntaxScopeMap({\n      'a > b': 'w',\n      'a > b:nth-child(1)': 'x',\n      b: 'y',\n      'b:nth-child(2)': 'z'\n    });\n    expect(map.get(['a', 'b'], [0, 0])).toBe('w');\n    expect(map.get(['a', 'b'], [0, 1])).toBe('x');\n    expect(map.get(['a', 'b'], [0, 2])).toBe('w');\n    expect(map.get(['b'], [0])).toBe('y');\n    expect(map.get(['b'], [1])).toBe('y');\n    expect(map.get(['b'], [2])).toBe('z');\n  });",
            "file": "syntax-scope-map-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can match :nth-child pseudo-selectors on interior nodes",
            "suites": [
                "SyntaxScopeMap"
            ],
            "updatePoint": {
                "line": 31,
                "column": 61
            },
            "line": 31,
            "code": "  it('can match :nth-child pseudo-selectors on interior nodes', () => {\n    const map = new SyntaxScopeMap({\n      'b:nth-child(1) > c': 'w',\n      'a > b > c': 'x',\n      'a > b:nth-child(2) > c': 'y'\n    });\n    expect(map.get(['b', 'c'], [0, 0])).toBe(undefined);\n    expect(map.get(['b', 'c'], [1, 0])).toBe('w');\n    expect(map.get(['a', 'b', 'c'], [1, 0, 0])).toBe('x');\n    expect(map.get(['a', 'b', 'c'], [1, 2, 0])).toBe('y');\n  });",
            "file": "syntax-scope-map-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows anonymous tokens to be referred to by their string value",
            "suites": [
                "SyntaxScopeMap"
            ],
            "updatePoint": {
                "line": 42,
                "column": 69
            },
            "line": 42,
            "code": "  it('allows anonymous tokens to be referred to by their string value', () => {\n    const map = new SyntaxScopeMap({\n      '\"b\"': 'w',\n      'a > \"b\"': 'x',\n      'a > \"b\":nth-child(1)': 'y',\n      '\"\\\\\"\"': 'z'\n    });\n    expect(map.get(['b'], [0], true)).toBe(undefined);\n    expect(map.get(['b'], [0], false)).toBe('w');\n    expect(map.get(['a', 'b'], [0, 0], false)).toBe('x');\n    expect(map.get(['a', 'b'], [0, 1], false)).toBe('y');\n    expect(map.get(['a', '\"'], [0, 1], false)).toBe('z');\n  });",
            "file": "syntax-scope-map-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "supports the wildcard selector",
            "suites": [
                "SyntaxScopeMap"
            ],
            "updatePoint": {
                "line": 55,
                "column": 36
            },
            "line": 55,
            "code": "  it('supports the wildcard selector', () => {\n    const map = new SyntaxScopeMap({\n      '*': 'w',\n      'a > *': 'x',\n      'a > *:nth-child(1)': 'y',\n      'a > *:nth-child(1) > b': 'z'\n    });\n    expect(map.get(['b'], [0])).toBe('w');\n    expect(map.get(['c'], [0])).toBe('w');\n    expect(map.get(['a', 'b'], [0, 0])).toBe('x');\n    expect(map.get(['a', 'b'], [0, 1])).toBe('y');\n    expect(map.get(['a', 'c'], [0, 1])).toBe('y');\n    expect(map.get(['a', 'c', 'b'], [0, 1, 1])).toBe('z');\n    expect(map.get(['a', 'c', 'b'], [0, 2, 1])).toBe('w');\n  });",
            "file": "syntax-scope-map-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "distinguishes between an anonymous * token and the wildcard selector",
            "suites": [
                "SyntaxScopeMap"
            ],
            "updatePoint": {
                "line": 70,
                "column": 74
            },
            "line": 70,
            "code": "  it('distinguishes between an anonymous * token and the wildcard selector', () => {\n    const map = new SyntaxScopeMap({\n      '\"*\"': 'x',\n      'a > \"b\"': 'y'\n    });\n    expect(map.get(['b'], [0], false)).toBe(undefined);\n    expect(map.get(['*'], [0], false)).toBe('x');\n  });",
            "file": "syntax-scope-map-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "terminates the process after it completes",
            "suites": [
                "Task",
                "@once(taskPath, args..., callback)"
            ],
            "updatePoint": {
                "line": 6,
                "column": 100
            },
            "line": 6,
            "code": "  describe('@once(taskPath, args..., callback)', () => it('terminates the process after it completes', function () {\n    let handlerResult = null;\n    const task = Task.once(require.resolve('./fixtures/task-spec-handler'), result => handlerResult = result);\n    let processErrored = false;\n    const {\n      childProcess\n    } = task;\n    spyOn(childProcess, 'kill').andCallThrough();\n    task.childProcess.on('error', () => processErrored = true);\n    waitsFor(() => handlerResult != null);\n    runs(function () {\n      expect(handlerResult).toBe('hello');\n      expect(childProcess.kill).toHaveBeenCalled();\n      expect(processErrored).toBe(false);\n    });\n  }));",
            "file": "task-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls listeners registered with ::on when events are emitted in the task",
            "suites": [
                "Task",
                "@once(taskPath, args..., callback)"
            ],
            "updatePoint": {
                "line": 22,
                "column": 78
            },
            "line": 22,
            "code": "  it('calls listeners registered with ::on when events are emitted in the task', function () {\n    const task = new Task(require.resolve('./fixtures/task-spec-handler'));\n    const eventSpy = jasmine.createSpy('eventSpy');\n    task.on('some-event', eventSpy);\n    waitsFor(done => task.start(done));\n    runs(() => expect(eventSpy).toHaveBeenCalledWith(1, 2, 3));\n  });",
            "file": "task-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "unregisters listeners when the Disposable returned by ::on is disposed",
            "suites": [
                "Task",
                "@once(taskPath, args..., callback)"
            ],
            "updatePoint": {
                "line": 29,
                "column": 76
            },
            "line": 29,
            "code": "  it('unregisters listeners when the Disposable returned by ::on is disposed', function () {\n    const task = new Task(require.resolve('./fixtures/task-spec-handler'));\n    const eventSpy = jasmine.createSpy('eventSpy');\n    const disposable = task.on('some-event', eventSpy);\n    disposable.dispose();\n    waitsFor(done => task.start(done));\n    runs(() => expect(eventSpy).not.toHaveBeenCalled());\n  });",
            "file": "task-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reports deprecations in tasks",
            "suites": [
                "Task",
                "@once(taskPath, args..., callback)"
            ],
            "updatePoint": {
                "line": 37,
                "column": 35
            },
            "line": 37,
            "code": "  it('reports deprecations in tasks', function () {\n    jasmine.snapshotDeprecations();\n\n    const handlerPath = require.resolve('./fixtures/task-handler-with-deprecations');\n\n    const task = new Task(handlerPath);\n    waitsFor(done => task.start(done));\n    runs(function () {\n      const deprecations = Grim.getDeprecations();\n      expect(deprecations.length).toBe(1);\n      expect(deprecations[0].getStacks()[0][1].fileName).toBe(handlerPath);\n      jasmine.restoreDeprecationsSnapshot();\n    });\n  });",
            "file": "task-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds data listeners to standard out and error to report output",
            "suites": [
                "Task",
                "@once(taskPath, args..., callback)"
            ],
            "updatePoint": {
                "line": 51,
                "column": 68
            },
            "line": 51,
            "code": "  it('adds data listeners to standard out and error to report output', function () {\n    const task = new Task(require.resolve('./fixtures/task-spec-handler'));\n    const {\n      stdout,\n      stderr\n    } = task.childProcess;\n    task.start();\n    task.start();\n    expect(stdout.listeners('data').length).toBe(1);\n    expect(stderr.listeners('data').length).toBe(1);\n    task.terminate();\n    expect(stdout.listeners('data').length).toBe(0);\n    expect(stderr.listeners('data').length).toBe(0);\n  });",
            "file": "task-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw an error for forked processes missing stdout/stderr",
            "suites": [
                "Task",
                "@once(taskPath, args..., callback)"
            ],
            "updatePoint": {
                "line": 65,
                "column": 72
            },
            "line": 65,
            "code": "  it('does not throw an error for forked processes missing stdout/stderr', function () {\n    spyOn(require('child_process'), 'fork').andCallFake(function () {\n      const Events = require('events');\n\n      const fakeProcess = new Events();\n\n      fakeProcess.send = function () {};\n\n      fakeProcess.kill = function () {};\n\n      return fakeProcess;\n    });\n    const task = new Task(require.resolve('./fixtures/task-spec-handler'));\n    expect(() => task.start()).not.toThrow();\n    expect(() => task.terminate()).not.toThrow();\n  });",
            "file": "task-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "dispatches 'task:cancelled' when invoked on an active task",
            "suites": [
                "Task",
                "::cancel()"
            ],
            "updatePoint": {
                "line": 82,
                "column": 66
            },
            "line": 82,
            "code": "    it(\"dispatches 'task:cancelled' when invoked on an active task\", function () {\n      const task = new Task(require.resolve('./fixtures/task-spec-handler'));\n      const cancelledEventSpy = jasmine.createSpy('eventSpy');\n      task.on('task:cancelled', cancelledEventSpy);\n      const completedEventSpy = jasmine.createSpy('eventSpy');\n      task.on('task:completed', completedEventSpy);\n      expect(task.cancel()).toBe(true);\n      expect(cancelledEventSpy).toHaveBeenCalled();\n      expect(completedEventSpy).not.toHaveBeenCalled();\n    });",
            "file": "task-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not dispatch 'task:cancelled' when invoked on an inactive task",
            "suites": [
                "Task",
                "::cancel()"
            ],
            "updatePoint": {
                "line": 92,
                "column": 75
            },
            "line": 92,
            "code": "    it(\"does not dispatch 'task:cancelled' when invoked on an inactive task\", function () {\n      let handlerResult = null;\n      const task = Task.once(require.resolve('./fixtures/task-spec-handler'), result => handlerResult = result);\n      waitsFor(() => handlerResult != null);\n      runs(function () {\n        const cancelledEventSpy = jasmine.createSpy('eventSpy');\n        task.on('task:cancelled', cancelledEventSpy);\n        expect(task.cancel()).toBe(false);\n        expect(cancelledEventSpy).not.toHaveBeenCalled();\n      });\n    });",
            "file": "task-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "renders lines and line numbers for the visible region",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 76,
                "column": 61
            },
            "line": 76,
            "code": "    it('renders lines and line numbers for the visible region', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 3,\n        autoHeight: false\n      });\n      expect(queryOnScreenLineNumberElements(element).length).toBe(13);\n      expect(queryOnScreenLineElements(element).length).toBe(13);\n      element.style.height = 4 * component.measurements.lineHeight + 'px';\n      await component.getNextUpdatePromise();\n      expect(queryOnScreenLineNumberElements(element).length).toBe(9);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n      await setScrollTop(component, 5 * component.getLineHeight()); // After scrolling down beyond > 3 rows, the order of line numbers and lines\n      // in the DOM is a bit weird because the first tile is recycled to the bottom\n      // when it is scrolled out of view\n\n      expect(queryOnScreenLineNumberElements(element).map(element => element.textContent.trim())).toEqual(['10', '11', '12', '4', '5', '6', '7', '8', '9']);\n      expect(queryOnScreenLineElements(element).map(element => element.dataset.screenRow)).toEqual(['9', '10', '11', '3', '4', '5', '6', '7', '8']);\n      expect(queryOnScreenLineElements(element).map(element => element.textContent)).toEqual([editor.lineTextForScreenRow(9), ' ', // this line is blank in the model, but we render a space to prevent the line from collapsing vertically\n      editor.lineTextForScreenRow(11), editor.lineTextForScreenRow(3), editor.lineTextForScreenRow(4), editor.lineTextForScreenRow(5), editor.lineTextForScreenRow(6), editor.lineTextForScreenRow(7), editor.lineTextForScreenRow(8)]);\n      await setScrollTop(component, 2.5 * component.getLineHeight());\n      expect(queryOnScreenLineNumberElements(element).map(element => element.textContent.trim())).toEqual(['1', '2', '3', '4', '5', '6', '7', '8', '9']);\n      expect(queryOnScreenLineElements(element).map(element => element.dataset.screenRow)).toEqual(['0', '1', '2', '3', '4', '5', '6', '7', '8']);\n      expect(queryOnScreenLineElements(element).map(element => element.textContent)).toEqual([editor.lineTextForScreenRow(0), editor.lineTextForScreenRow(1), editor.lineTextForScreenRow(2), editor.lineTextForScreenRow(3), editor.lineTextForScreenRow(4), editor.lineTextForScreenRow(5), editor.lineTextForScreenRow(6), editor.lineTextForScreenRow(7), editor.lineTextForScreenRow(8)]);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "bases the width of the lines div on the width of the longest initially-visible screen line",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 104,
                "column": 98
            },
            "line": 104,
            "code": "    it('bases the width of the lines div on the width of the longest initially-visible screen line', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 2,\n        height: 20,\n        width: 100\n      });\n      {\n        expect(editor.getApproximateLongestScreenRow()).toBe(3);\n        const expectedWidth = Math.ceil(component.pixelPositionForScreenPosition(Point(3, Infinity)).left + component.getBaseCharacterWidth());\n        expect(element.querySelector('.lines').style.width).toBe(expectedWidth + 'px');\n      }\n      {\n        // Get the next update promise synchronously here to ensure we don't\n        // miss the update while polling the condition.\n        const nextUpdatePromise = component.getNextUpdatePromise();\n        await conditionPromise(() => editor.getApproximateLongestScreenRow() === 6);\n        await nextUpdatePromise; // Capture the width of the lines before requesting the width of\n        // longest line, because making that request forces a DOM update\n\n        const actualWidth = element.querySelector('.lines').style.width;\n        const expectedWidth = Math.ceil(component.pixelPositionForScreenPosition(Point(6, Infinity)).left + component.getBaseCharacterWidth());\n        expect(actualWidth).toBe(expectedWidth + 'px');\n      } // eslint-disable-next-line no-lone-blocks\n\n      {\n        // Make sure we do not throw an error if a synchronous update is\n        // triggered before measuring the longest line from a\n        // previously-scheduled update.\n        editor.getBuffer().insert(Point(12, Infinity), 'x'.repeat(100));\n        expect(editor.getLongestScreenRow()).toBe(12);\n        TextEditorComponent.getScheduler().readDocument(() => {\n          // This will happen before the measurement phase of the update\n          // triggered above.\n          component.pixelPositionForScreenPosition(Point(11, Infinity));\n        });\n        await component.getNextUpdatePromise();\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "re-renders lines when their height changes",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 146,
                "column": 50
            },
            "line": 146,
            "code": "    it('re-renders lines when their height changes', async () => {\n      const {\n        component,\n        element\n      } = buildComponent({\n        rowsPerTile: 3,\n        autoHeight: false\n      });\n      element.style.height = 4 * component.measurements.lineHeight + 'px';\n      await component.getNextUpdatePromise();\n      expect(queryOnScreenLineNumberElements(element).length).toBe(9);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n      element.style.lineHeight = '2.0';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      expect(queryOnScreenLineNumberElements(element).length).toBe(6);\n      expect(queryOnScreenLineElements(element).length).toBe(6);\n      element.style.lineHeight = '0.7';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      expect(queryOnScreenLineNumberElements(element).length).toBe(12);\n      expect(queryOnScreenLineElements(element).length).toBe(12);\n      element.style.lineHeight = '0.05';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      expect(queryOnScreenLineNumberElements(element).length).toBe(13);\n      expect(queryOnScreenLineElements(element).length).toBe(13);\n      element.style.lineHeight = '0';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      expect(queryOnScreenLineNumberElements(element).length).toBe(13);\n      expect(queryOnScreenLineElements(element).length).toBe(13);\n      element.style.lineHeight = '1';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      expect(queryOnScreenLineNumberElements(element).length).toBe(9);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "makes the content at least as tall as the scroll container client height",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 184,
                "column": 80
            },
            "line": 184,
            "code": "    it('makes the content at least as tall as the scroll container client height', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        text: 'a'.repeat(100),\n        width: 50,\n        height: 100\n      });\n      expect(component.refs.content.offsetHeight).toBe(100 - getHorizontalScrollbarHeight(component));\n      editor.setText('a\\n'.repeat(30));\n      await component.getNextUpdatePromise();\n      expect(component.refs.content.offsetHeight).toBeGreaterThan(100);\n      expect(component.refs.content.offsetHeight).toBeNear(component.getContentHeight(), 2);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "honors the scrollPastEnd option by adding empty space equivalent to the clientHeight to the end of the content area",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 199,
                "column": 123
            },
            "line": 199,
            "code": "    it('honors the scrollPastEnd option by adding empty space equivalent to the clientHeight to the end of the content area', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        autoHeight: false,\n        autoWidth: false\n      });\n      await editor.update({\n        scrollPastEnd: true\n      });\n      await setEditorHeightInLines(component, 6); // scroll to end\n\n      await setScrollTop(component, Infinity);\n      expect(component.getFirstVisibleRow()).toBe(editor.getScreenLineCount() - 3);\n      editor.update({\n        scrollPastEnd: false\n      });\n      await component.getNextUpdatePromise(); // wait for scrollable content resize\n\n      expect(component.getFirstVisibleRow()).toBe(editor.getScreenLineCount() - 6); // Always allows at least 3 lines worth of overscroll if the editor is short\n\n      await setEditorHeightInLines(component, 2);\n      await editor.update({\n        scrollPastEnd: true\n      });\n      await setScrollTop(component, Infinity);\n      expect(component.getFirstVisibleRow()).toBe(editor.getScreenLineCount() + 1);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not fire onDidChangeScrollTop listeners when assigning the same maximal value and the content height has fractional pixels (regression)",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 228,
                "column": 148
            },
            "line": 228,
            "code": "    it('does not fire onDidChangeScrollTop listeners when assigning the same maximal value and the content height has fractional pixels (regression)', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        autoHeight: false,\n        autoWidth: false\n      });\n      await setEditorHeightInLines(component, 3); // Force a fractional content height with a block decoration\n\n      const item = document.createElement('div');\n      item.style.height = '10.6px';\n      editor.decorateMarker(editor.markBufferPosition([0, 0]), {\n        type: 'block',\n        item\n      });\n      await component.getNextUpdatePromise();\n      component.setScrollTop(Infinity);\n      element.onDidChangeScrollTop(newScrollTop => {\n        throw new Error('Scroll top should not have changed');\n      });\n      component.setScrollTop(component.getScrollTop());\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gives the line number tiles an explicit width and height so their layout can be strictly contained",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 252,
                "column": 106
            },
            "line": 252,
            "code": "    it('gives the line number tiles an explicit width and height so their layout can be strictly contained', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        rowsPerTile: 3\n      });\n      const lineNumberGutterElement = component.refs.gutterContainer.refs.lineNumberGutter.element;\n      expect(lineNumberGutterElement.offsetHeight).toBeNear(component.getScrollHeight());\n\n      for (const child of lineNumberGutterElement.children) {\n        expect(child.offsetWidth).toBe(lineNumberGutterElement.offsetWidth);\n\n        if (!child.classList.contains('line-number')) {\n          for (const lineNumberElement of child.children) {\n            expect(lineNumberElement.offsetWidth).toBe(lineNumberGutterElement.offsetWidth);\n          }\n        }\n      }\n\n      editor.setText('x\\n'.repeat(99));\n      await component.getNextUpdatePromise();\n      expect(lineNumberGutterElement.offsetHeight).toBeNear(component.getScrollHeight());\n\n      for (const child of lineNumberGutterElement.children) {\n        expect(child.offsetWidth).toBe(lineNumberGutterElement.offsetWidth);\n\n        if (!child.classList.contains('line-number')) {\n          for (const lineNumberElement of child.children) {\n            expect(lineNumberElement.offsetWidth).toBe(lineNumberGutterElement.offsetWidth);\n          }\n        }\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the number of tiles stable when the visible line count changes during vertical scrolling",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 286,
                "column": 102
            },
            "line": 286,
            "code": "    it('keeps the number of tiles stable when the visible line count changes during vertical scrolling', async () => {\n      const {\n        component\n      } = buildComponent({\n        rowsPerTile: 3,\n        autoHeight: false\n      });\n      await setEditorHeightInLines(component, 5.5);\n      expect(component.refs.lineTiles.children.length).toBe(3 + 2); // account for cursors and highlights containers\n\n      await setScrollTop(component, 0.5 * component.getLineHeight());\n      expect(component.refs.lineTiles.children.length).toBe(3 + 2); // account for cursors and highlights containers\n\n      await setScrollTop(component, 1 * component.getLineHeight());\n      expect(component.refs.lineTiles.children.length).toBe(3 + 2); // account for cursors and highlights containers\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "recycles tiles on resize",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 302,
                "column": 32
            },
            "line": 302,
            "code": "    it('recycles tiles on resize', async () => {\n      const {\n        component\n      } = buildComponent({\n        rowsPerTile: 2,\n        autoHeight: false\n      });\n      await setEditorHeightInLines(component, 7);\n      await setScrollTop(component, 3.5 * component.getLineHeight());\n      const lineNode = lineNodeForScreenRow(component, 7);\n      await setEditorHeightInLines(component, 4);\n      expect(lineNodeForScreenRow(component, 7)).toBe(lineNode);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates lines numbers when a row's foldability changes (regression)",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 315,
                "column": 75
            },
            "line": 315,
            "code": "    it(\"updates lines numbers when a row's foldability changes (regression)\", async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        text: 'abc\\n'\n      });\n      editor.setCursorBufferPosition([1, 0]);\n      await component.getNextUpdatePromise();\n      expect(lineNumberNodeForScreenRow(component, 0).querySelector('.foldable')).toBeNull();\n      editor.insertText('  def');\n      await component.getNextUpdatePromise();\n      expect(lineNumberNodeForScreenRow(component, 0).querySelector('.foldable')).toBeDefined();\n      editor.undo();\n      await component.getNextUpdatePromise();\n      expect(lineNumberNodeForScreenRow(component, 0).querySelector('.foldable')).toBeNull();\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shows the foldable icon on the last screen row of a buffer row that can be folded",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 332,
                "column": 89
            },
            "line": 332,
            "code": "    it('shows the foldable icon on the last screen row of a buffer row that can be folded', async () => {\n      const {\n        component\n      } = buildComponent({\n        text: 'abc\\n  de\\nfghijklm\\n  no',\n        softWrapped: true\n      });\n      await setEditorWidthInCharacters(component, 5);\n      expect(lineNumberNodeForScreenRow(component, 0).classList.contains('foldable')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 1).classList.contains('foldable')).toBe(false);\n      expect(lineNumberNodeForScreenRow(component, 2).classList.contains('foldable')).toBe(false);\n      expect(lineNumberNodeForScreenRow(component, 3).classList.contains('foldable')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 4).classList.contains('foldable')).toBe(false);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "renders dummy vertical and horizontal scrollbars when content overflows",
            "suites": [
                "TextEditorComponent",
                "rendering"
            ],
            "updatePoint": {
                "line": 346,
                "column": 79
            },
            "line": 346,
            "code": "    it('renders dummy vertical and horizontal scrollbars when content overflows', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        height: 100,\n        width: 100\n      });\n      const verticalScrollbar = component.refs.verticalScrollbar.element;\n      const horizontalScrollbar = component.refs.horizontalScrollbar.element;\n      expect(verticalScrollbar.scrollHeight).toBeNear(component.getContentHeight());\n      expect(horizontalScrollbar.scrollWidth).toBeNear(component.getContentWidth());\n      expect(getVerticalScrollbarWidth(component)).toBeGreaterThan(0);\n      expect(getHorizontalScrollbarHeight(component)).toBeGreaterThan(0);\n      expect(verticalScrollbar.style.bottom).toBe(getVerticalScrollbarWidth(component) + 'px');\n      expect(verticalScrollbar.style.visibility).toBe('');\n      expect(horizontalScrollbar.style.right).toBe(getHorizontalScrollbarHeight(component) + 'px');\n      expect(horizontalScrollbar.style.visibility).toBe('');\n      expect(component.refs.scrollbarCorner).toBeDefined();\n      setScrollTop(component, 100);\n      await setScrollLeft(component, 100);\n      expect(verticalScrollbar.scrollTop).toBe(100);\n      expect(horizontalScrollbar.scrollLeft).toBe(100);\n      verticalScrollbar.scrollTop = 120;\n      horizontalScrollbar.scrollLeft = 120;\n      await component.getNextUpdatePromise();\n      expect(component.getScrollTop()).toBe(120);\n      expect(component.getScrollLeft()).toBe(120);\n      editor.setText('a\\n'.repeat(15));\n      await component.getNextUpdatePromise();\n      expect(getVerticalScrollbarWidth(component)).toBeGreaterThan(0);\n      expect(getHorizontalScrollbarHeight(component)).toBe(0);\n      expect(verticalScrollbar.style.visibility).toBe('');\n      expect(horizontalScrollbar.style.visibility).toBe('hidden');\n      editor.setText('a'.repeat(100));\n      await component.getNextUpdatePromise();\n      expect(getVerticalScrollbarWidth(component)).toBe(0);\n      expect(getHorizontalScrollbarHeight(component)).toBeGreaterThan(0);\n      expect(verticalScrollbar.style.visibility).toBe('hidden');\n      expect(horizontalScrollbar.style.visibility).toBe('');\n      editor.setText('');\n      await component.getNextUpdatePromise();\n      expect(getVerticalScrollbarWidth(component)).toBe(0);\n      expect(getHorizontalScrollbarHeight(component)).toBe(0);\n      expect(verticalScrollbar.style.visibility).toBe('hidden');\n      expect(horizontalScrollbar.style.visibility).toBe('hidden');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the bottom/right of dummy scrollbars and client height/width measurements",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 394,
                "column": 91
            },
            "line": 394,
            "code": "      it('updates the bottom/right of dummy scrollbars and client height/width measurements', async () => {\n        const {\n          component,\n          element,\n          editor\n        } = buildComponent({\n          height: 100,\n          width: 100\n        });\n        expect(getHorizontalScrollbarHeight(component)).toBeGreaterThan(10);\n        expect(getVerticalScrollbarWidth(component)).toBeGreaterThan(10);\n        setScrollTop(component, 20);\n        setScrollLeft(component, 10);\n        await component.getNextUpdatePromise(); // Updating scrollbar styles.\n\n        const style = document.createElement('style');\n        style.textContent = '::-webkit-scrollbar { height: 10px; width: 10px; }';\n        jasmine.attachToDOM(style);\n        TextEditor.didUpdateScrollbarStyles();\n        await component.getNextUpdatePromise();\n        expect(getHorizontalScrollbarHeight(component)).toBeNear(10);\n        expect(getVerticalScrollbarWidth(component)).toBeNear(10);\n        expect(component.refs.horizontalScrollbar.element.style.right).toHaveNearPixels('10px');\n        expect(component.refs.verticalScrollbar.element.style.bottom).toHaveNearPixels('10px');\n        expect(component.refs.horizontalScrollbar.element.scrollLeft).toBeNear(10);\n        expect(component.refs.verticalScrollbar.element.scrollTop).toBeNear(20);\n        expect(component.getScrollContainerClientHeight()).toBeNear(100 - 10);\n        expect(component.getScrollContainerClientWidth()).toBeNear(100 - component.getGutterContainerWidth() - 10); // Detaching and re-attaching the editor element.\n\n        element.remove();\n        jasmine.attachToDOM(element);\n        expect(getHorizontalScrollbarHeight(component)).toBeNear(10);\n        expect(getVerticalScrollbarWidth(component)).toBeNear(10);\n        expect(component.refs.horizontalScrollbar.element.style.right).toHaveNearPixels('10px');\n        expect(component.refs.verticalScrollbar.element.style.bottom).toHaveNearPixels('10px');\n        expect(component.refs.horizontalScrollbar.element.scrollLeft).toBeNear(10);\n        expect(component.refs.verticalScrollbar.element.scrollTop).toBeNear(20);\n        expect(component.getScrollContainerClientHeight()).toBeNear(100 - 10);\n        expect(component.getScrollContainerClientWidth()).toBeNear(100 - component.getGutterContainerWidth() - 10); // Ensure we don't throw an error trying to remeasure non-existent scrollbars for mini editors.\n\n        await editor.update({\n          mini: true\n        });\n        TextEditor.didUpdateScrollbarStyles();\n        component.scheduleUpdate();\n        await component.getNextUpdatePromise();\n      });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "renders cursors within the visible row range",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 442,
                "column": 52
            },
            "line": 442,
            "code": "    it('renders cursors within the visible row range', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        height: 40,\n        rowsPerTile: 2\n      });\n      await setScrollTop(component, 100);\n      expect(component.getRenderedStartRow()).toBe(4);\n      expect(component.getRenderedEndRow()).toBe(10);\n      editor.setCursorScreenPosition([0, 0], {\n        autoscroll: false\n      }); // out of view\n\n      editor.addCursorAtScreenPosition([2, 2], {\n        autoscroll: false\n      }); // out of view\n\n      editor.addCursorAtScreenPosition([4, 0], {\n        autoscroll: false\n      }); // line start\n\n      editor.addCursorAtScreenPosition([4, 4], {\n        autoscroll: false\n      }); // at token boundary\n\n      editor.addCursorAtScreenPosition([4, 6], {\n        autoscroll: false\n      }); // within token\n\n      editor.addCursorAtScreenPosition([5, Infinity], {\n        autoscroll: false\n      }); // line end\n\n      editor.addCursorAtScreenPosition([10, 2], {\n        autoscroll: false\n      }); // out of view\n\n      await component.getNextUpdatePromise();\n      let cursorNodes = Array.from(element.querySelectorAll('.cursor'));\n      expect(cursorNodes.length).toBe(4);\n      verifyCursorPosition(component, cursorNodes[0], 4, 0);\n      verifyCursorPosition(component, cursorNodes[1], 4, 4);\n      verifyCursorPosition(component, cursorNodes[2], 4, 6);\n      verifyCursorPosition(component, cursorNodes[3], 5, 30);\n      editor.setCursorScreenPosition([8, 11], {\n        autoscroll: false\n      });\n      await component.getNextUpdatePromise();\n      cursorNodes = Array.from(element.querySelectorAll('.cursor'));\n      expect(cursorNodes.length).toBe(1);\n      verifyCursorPosition(component, cursorNodes[0], 8, 11);\n      editor.setCursorScreenPosition([0, 0], {\n        autoscroll: false\n      });\n      await component.getNextUpdatePromise();\n      cursorNodes = Array.from(element.querySelectorAll('.cursor'));\n      expect(cursorNodes.length).toBe(0);\n      editor.setSelectedScreenRange([[8, 0], [12, 0]], {\n        autoscroll: false\n      });\n      await component.getNextUpdatePromise();\n      cursorNodes = Array.from(element.querySelectorAll('.cursor'));\n      expect(cursorNodes.length).toBe(0);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "hides cursors with non-empty selections when showCursorOnSelection is false",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 509,
                "column": 83
            },
            "line": 509,
            "code": "    it('hides cursors with non-empty selections when showCursorOnSelection is false', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      editor.setSelectedScreenRanges([[[0, 0], [0, 3]], [[1, 0], [1, 0]]]);\n      await component.getNextUpdatePromise();\n      {\n        const cursorNodes = Array.from(element.querySelectorAll('.cursor'));\n        expect(cursorNodes.length).toBe(2);\n        verifyCursorPosition(component, cursorNodes[0], 0, 3);\n        verifyCursorPosition(component, cursorNodes[1], 1, 0);\n      }\n      editor.update({\n        showCursorOnSelection: false\n      });\n      await component.getNextUpdatePromise();\n      {\n        const cursorNodes = Array.from(element.querySelectorAll('.cursor'));\n        expect(cursorNodes.length).toBe(1);\n        verifyCursorPosition(component, cursorNodes[0], 1, 0);\n      }\n      editor.setSelectedScreenRanges([[[0, 0], [0, 3]], [[1, 0], [1, 4]]]);\n      await component.getNextUpdatePromise();\n      {\n        const cursorNodes = Array.from(element.querySelectorAll('.cursor'));\n        expect(cursorNodes.length).toBe(0);\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "blinks cursors when the editor is focused and the cursors are not moving",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 539,
                "column": 80
            },
            "line": 539,
            "code": "    it('blinks cursors when the editor is focused and the cursors are not moving', async () => {\n      assertDocumentFocused();\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      component.props.cursorBlinkPeriod = 30;\n      component.props.cursorBlinkResumeDelay = 30;\n      editor.addCursorAtScreenPosition([1, 0]);\n      element.focus();\n      await component.getNextUpdatePromise();\n      const [cursor1, cursor2] = element.querySelectorAll('.cursor');\n      await conditionPromise(() => getComputedStyle(cursor1).opacity === '1' && getComputedStyle(cursor2).opacity === '1');\n      await conditionPromise(() => getComputedStyle(cursor1).opacity === '0' && getComputedStyle(cursor2).opacity === '0');\n      await conditionPromise(() => getComputedStyle(cursor1).opacity === '1' && getComputedStyle(cursor2).opacity === '1');\n      editor.moveRight();\n      await component.getNextUpdatePromise();\n      expect(getComputedStyle(cursor1).opacity).toBe('1');\n      expect(getComputedStyle(cursor2).opacity).toBe('1');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gives cursors at the end of lines the width of an \"x\" character",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 560,
                "column": 71
            },
            "line": 560,
            "code": "    it('gives cursors at the end of lines the width of an \"x\" character', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      editor.setText('abcde');\n      await setEditorWidthInCharacters(component, 5.5);\n      editor.setCursorScreenPosition([0, Infinity]);\n      await component.getNextUpdatePromise();\n      expect(element.querySelector('.cursor').offsetWidth).toBe(Math.round(component.getBaseCharacterWidth())); // Clip cursor width when soft-wrap is on and the cursor is at the end of\n      // the line. This prevents the parent tile from disabling sub-pixel\n      // anti-aliasing. For some reason, adding overflow: hidden to the cursor\n      // container doesn't solve this issue so we're adding this workaround instead.\n\n      editor.setSoftWrapped(true);\n      await component.getNextUpdatePromise();\n      expect(element.querySelector('.cursor').offsetWidth).toBeLessThan(Math.round(component.getBaseCharacterWidth()));\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "positions and sizes cursors correctly when they are located next to a fold marker",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 579,
                "column": 89
            },
            "line": 579,
            "code": "    it('positions and sizes cursors correctly when they are located next to a fold marker', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      editor.foldBufferRange([[0, 3], [0, 6]]);\n      editor.setCursorScreenPosition([0, 3]);\n      await component.getNextUpdatePromise();\n      verifyCursorPosition(component, element.querySelector('.cursor'), 0, 3);\n      editor.setCursorScreenPosition([0, 4]);\n      await component.getNextUpdatePromise();\n      verifyCursorPosition(component, element.querySelector('.cursor'), 0, 4);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "positions cursors and placeholder text correctly when the lines container has a margin and/or is padded",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 593,
                "column": 111
            },
            "line": 593,
            "code": "    it('positions cursors and placeholder text correctly when the lines container has a margin and/or is padded', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        placeholderText: 'testing'\n      });\n      component.refs.lineTiles.style.marginLeft = '10px';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      editor.setCursorBufferPosition([0, 3]);\n      await component.getNextUpdatePromise();\n      verifyCursorPosition(component, element.querySelector('.cursor'), 0, 3);\n      editor.setCursorScreenPosition([1, 0]);\n      await component.getNextUpdatePromise();\n      verifyCursorPosition(component, element.querySelector('.cursor'), 1, 0);\n      component.refs.lineTiles.style.paddingTop = '5px';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      verifyCursorPosition(component, element.querySelector('.cursor'), 1, 0);\n      editor.setCursorScreenPosition([2, 2]);\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      verifyCursorPosition(component, element.querySelector('.cursor'), 2, 2);\n      editor.setText('');\n      await component.getNextUpdatePromise();\n      const placeholderTextLeft = element.querySelector('.placeholder-text').getBoundingClientRect().left;\n      const linesLeft = component.refs.lineTiles.getBoundingClientRect().left;\n      expect(placeholderTextLeft).toBe(linesLeft);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "places the hidden input element at the location of the last cursor if it is visible",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 624,
                "column": 91
            },
            "line": 624,
            "code": "    it('places the hidden input element at the location of the last cursor if it is visible', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        height: 60,\n        width: 120,\n        rowsPerTile: 2\n      });\n      const {\n        hiddenInput\n      } = component.refs.cursorsAndInput.refs;\n      setScrollTop(component, 100);\n      await setScrollLeft(component, 40);\n      expect(component.getRenderedStartRow()).toBe(4);\n      expect(component.getRenderedEndRow()).toBe(10); // When out of view, the hidden input is positioned at 0, 0\n\n      expect(editor.getCursorScreenPosition()).toEqual([0, 0]);\n      expect(hiddenInput.offsetTop).toBe(0);\n      expect(hiddenInput.offsetLeft).toBe(0); // Otherwise it is positioned at the last cursor position\n\n      editor.addCursorAtScreenPosition([7, 4]);\n      await component.getNextUpdatePromise();\n      expect(hiddenInput.getBoundingClientRect().top).toBe(clientTopForLine(component, 7));\n      expect(Math.round(hiddenInput.getBoundingClientRect().left)).toBeNear(clientLeftForCharacter(component, 7, 4));\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "soft wraps lines based on the content width when soft wrap is enabled",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 650,
                "column": 77
            },
            "line": 650,
            "code": "    it('soft wraps lines based on the content width when soft wrap is enabled', async () => {\n      let baseCharacterWidth, gutterContainerWidth;\n      {\n        const {\n          component,\n          editor\n        } = buildComponent();\n        baseCharacterWidth = component.getBaseCharacterWidth();\n        gutterContainerWidth = component.getGutterContainerWidth();\n        editor.destroy();\n      }\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        width: gutterContainerWidth + baseCharacterWidth * 55,\n        attach: false\n      });\n      editor.setSoftWrapped(true);\n      jasmine.attachToDOM(element);\n      expect(getEditorWidthInBaseCharacters(component)).toBe(55);\n      expect(lineNodeForScreenRow(component, 3).textContent).toBe('    var pivot = items.shift(), current, left = [], ');\n      expect(lineNodeForScreenRow(component, 4).textContent).toBe('    right = [];');\n      const {\n        scrollContainer\n      } = component.refs;\n      expect(scrollContainer.clientWidth).toBe(scrollContainer.scrollWidth);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly forces the display layer to index visible rows when resizing (regression)",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 679,
                "column": 91
            },
            "line": 679,
            "code": "    it('correctly forces the display layer to index visible rows when resizing (regression)', async () => {\n      const text = 'a'.repeat(30) + '\\n' + 'b'.repeat(1000);\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        height: 300,\n        width: 800,\n        attach: false,\n        text\n      });\n      editor.setSoftWrapped(true);\n      jasmine.attachToDOM(element);\n      element.style.width = 200 + 'px';\n      await component.getNextUpdatePromise();\n      expect(queryOnScreenLineElements(element).length).toBe(24);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "decorates the line numbers of folded lines",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 697,
                "column": 50
            },
            "line": 697,
            "code": "    it('decorates the line numbers of folded lines', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      editor.foldBufferRow(1);\n      await component.getNextUpdatePromise();\n      expect(lineNumberNodeForScreenRow(component, 1).classList.contains('folded')).toBe(true);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "makes lines at least as wide as the scrollContainer",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 706,
                "column": 59
            },
            "line": 706,
            "code": "    it('makes lines at least as wide as the scrollContainer', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      const {\n        scrollContainer\n      } = component.refs;\n      editor.setText('a');\n      await component.getNextUpdatePromise();\n      expect(element.querySelector('.line').offsetWidth).toBe(scrollContainer.offsetWidth - verticalScrollbarWidth);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resizes based on the content when the autoHeight and/or autoWidth options are true",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 719,
                "column": 90
            },
            "line": 719,
            "code": "    it('resizes based on the content when the autoHeight and/or autoWidth options are true', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        autoHeight: true,\n        autoWidth: true\n      });\n      const editorPadding = 3;\n      element.style.padding = editorPadding + 'px';\n      const initialWidth = element.offsetWidth;\n      const initialHeight = element.offsetHeight;\n      expect(initialWidth).toBe(component.getGutterContainerWidth() + component.getContentWidth() + verticalScrollbarWidth + 2 * editorPadding);\n      expect(initialHeight).toBeNear(component.getContentHeight() + horizontalScrollbarHeight + 2 * editorPadding); // When autoWidth is enabled, width adjusts to content\n\n      editor.setCursorScreenPosition([6, Infinity]);\n      editor.insertText('x'.repeat(50));\n      await component.getNextUpdatePromise();\n      expect(element.offsetWidth).toBe(component.getGutterContainerWidth() + component.getContentWidth() + verticalScrollbarWidth + 2 * editorPadding);\n      expect(element.offsetWidth).toBeGreaterThan(initialWidth); // When autoHeight is enabled, height adjusts to content\n\n      editor.insertText('\\n'.repeat(5));\n      await component.getNextUpdatePromise();\n      expect(element.offsetHeight).toBeNear(component.getContentHeight() + horizontalScrollbarHeight + 2 * editorPadding);\n      expect(element.offsetHeight).toBeGreaterThan(initialHeight);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not render the line number gutter at all if the isLineNumberGutterVisible parameter is false",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 746,
                "column": 105
            },
            "line": 746,
            "code": "    it('does not render the line number gutter at all if the isLineNumberGutterVisible parameter is false', () => {\n      const {\n        element\n      } = buildComponent({\n        lineNumberGutterVisible: false\n      });\n      expect(element.querySelector('.line-number')).toBe(null);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not render the line numbers but still renders the line number gutter if showLineNumbers is false",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 754,
                "column": 109
            },
            "line": 754,
            "code": "    it('does not render the line numbers but still renders the line number gutter if showLineNumbers is false', async () => {\n      function checkScrollContainerLeft(component) {\n        const {\n          scrollContainer,\n          gutterContainer\n        } = component.refs;\n        expect(scrollContainer.getBoundingClientRect().left).toBeNear(Math.round(gutterContainer.element.getBoundingClientRect().right));\n      }\n\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        showLineNumbers: false\n      });\n      expect(Array.from(element.querySelectorAll('.line-number')).every(e => e.textContent === '')).toBe(true);\n      checkScrollContainerLeft(component);\n      await editor.update({\n        showLineNumbers: true\n      });\n      expect(Array.from(element.querySelectorAll('.line-number')).map(e => e.textContent)).toEqual(['00', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13']);\n      checkScrollContainerLeft(component);\n      await editor.update({\n        showLineNumbers: false\n      });\n      expect(Array.from(element.querySelectorAll('.line-number')).every(e => e.textContent === '')).toBe(true);\n      checkScrollContainerLeft(component);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "supports the placeholderText parameter",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 783,
                "column": 46
            },
            "line": 783,
            "code": "    it('supports the placeholderText parameter', () => {\n      const placeholderText = 'Placeholder Test';\n      const {\n        element\n      } = buildComponent({\n        placeholderText,\n        text: ''\n      });\n      expect(element.textContent).toContain(placeholderText);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the data-grammar attribute and updates it when the grammar changes",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 793,
                "column": 79
            },
            "line": 793,
            "code": "    it('adds the data-grammar attribute and updates it when the grammar changes', async () => {\n      await atom.packages.activatePackage('language-javascript');\n      const {\n        editor,\n        element,\n        component\n      } = buildComponent();\n      expect(element.dataset.grammar).toBe('text plain null-grammar');\n      atom.grammars.assignLanguageMode(editor.getBuffer(), 'source.js');\n      await component.getNextUpdatePromise();\n      expect(element.dataset.grammar).toBe('source js');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the data-encoding attribute and updates it when the encoding changes",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 805,
                "column": 81
            },
            "line": 805,
            "code": "    it('adds the data-encoding attribute and updates it when the encoding changes', async () => {\n      const {\n        editor,\n        element,\n        component\n      } = buildComponent();\n      expect(element.dataset.encoding).toBe('utf8');\n      editor.setEncoding('ascii');\n      await component.getNextUpdatePromise();\n      expect(element.dataset.encoding).toBe('ascii');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the has-selection class when the editor has a non-empty selection",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 816,
                "column": 78
            },
            "line": 816,
            "code": "    it('adds the has-selection class when the editor has a non-empty selection', async () => {\n      const {\n        editor,\n        element,\n        component\n      } = buildComponent();\n      expect(element.classList.contains('has-selection')).toBe(false);\n      editor.setSelectedBufferRanges([[[0, 0], [0, 0]], [[1, 0], [1, 10]]]);\n      await component.getNextUpdatePromise();\n      expect(element.classList.contains('has-selection')).toBe(true);\n      editor.setSelectedBufferRanges([[[0, 0], [0, 0]], [[1, 0], [1, 0]]]);\n      await component.getNextUpdatePromise();\n      expect(element.classList.contains('has-selection')).toBe(false);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "assigns buffer-row and screen-row to each line number as data fields",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 830,
                "column": 76
            },
            "line": 830,
            "code": "    it('assigns buffer-row and screen-row to each line number as data fields', async () => {\n      const {\n        editor,\n        element,\n        component\n      } = buildComponent();\n      editor.setSoftWrapped(true);\n      await component.getNextUpdatePromise();\n      await setEditorWidthInCharacters(component, 40);\n      {\n        const bufferRows = queryOnScreenLineNumberElements(element).map(e => e.dataset.bufferRow);\n        const screenRows = queryOnScreenLineNumberElements(element).map(e => e.dataset.screenRow);\n        expect(bufferRows).toEqual(['0', '1', '2', '2', '3', '3', '4', '5', '6', '6', '6', '7', '8', '8', '8', '9', '10', '11', '11', '12']);\n        expect(screenRows).toEqual(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19']);\n      }\n      editor.getBuffer().insert([2, 0], '\\n');\n      await component.getNextUpdatePromise();\n      {\n        const bufferRows = queryOnScreenLineNumberElements(element).map(e => e.dataset.bufferRow);\n        const screenRows = queryOnScreenLineNumberElements(element).map(e => e.dataset.screenRow);\n        expect(bufferRows).toEqual(['0', '1', '2', '3', '3', '4', '4', '5', '6', '7', '7', '7', '8', '9', '9', '9', '10', '11', '12', '12', '13']);\n        expect(screenRows).toEqual(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20']);\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not blow away class names added to the element by packages when changing the class name",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 854,
                "column": 100
            },
            "line": 854,
            "code": "    it('does not blow away class names added to the element by packages when changing the class name', async () => {\n      assertDocumentFocused();\n      const {\n        component,\n        element\n      } = buildComponent();\n      element.classList.add('a', 'b');\n      expect(element.className).toBe('editor a b');\n      element.focus();\n      await component.getNextUpdatePromise();\n      expect(element.className).toBe('editor a b is-focused');\n      document.body.focus();\n      await component.getNextUpdatePromise();\n      expect(element.className).toBe('editor a b');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not blow away class names managed by the component when packages change the element class name",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 869,
                "column": 107
            },
            "line": 869,
            "code": "    it('does not blow away class names managed by the component when packages change the element class name', async () => {\n      assertDocumentFocused();\n      const {\n        component,\n        element\n      } = buildComponent({\n        mini: true\n      });\n      element.classList.add('a', 'b');\n      element.focus();\n      await component.getNextUpdatePromise();\n      expect(element.className).toBe('editor mini a b is-focused');\n      element.className = 'a c d';\n      await component.getNextUpdatePromise();\n      expect(element.className).toBe('a c d editor is-focused mini');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores resize events when the editor is hidden",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "when scrollbar styles change or the editor element is detached and then reattached"
            ],
            "updatePoint": {
                "line": 885,
                "column": 55
            },
            "line": 885,
            "code": "    it('ignores resize events when the editor is hidden', async () => {\n      const {\n        component,\n        element\n      } = buildComponent({\n        autoHeight: false\n      });\n      element.style.height = 5 * component.getLineHeight() + 'px';\n      await component.getNextUpdatePromise();\n      const originalClientContainerHeight = component.getClientContainerHeight();\n      const originalGutterContainerWidth = component.getGutterContainerWidth();\n      const originalLineNumberGutterWidth = component.getLineNumberGutterWidth();\n      expect(originalClientContainerHeight).toBeGreaterThan(0);\n      expect(originalGutterContainerWidth).toBeGreaterThan(0);\n      expect(originalLineNumberGutterWidth).toBeGreaterThan(0);\n      element.style.display = 'none'; // In production, resize events are triggered before the intersection\n      // observer detects the editor's visibility has changed. In tests, we are\n      // unable to reproduce this scenario and so we simulate them.\n\n      expect(component.visible).toBe(true);\n      component.didResize();\n      component.didResizeGutterContainer();\n      expect(component.getClientContainerHeight()).toBe(originalClientContainerHeight);\n      expect(component.getGutterContainerWidth()).toBe(originalGutterContainerWidth);\n      expect(component.getLineNumberGutterWidth()).toBe(originalLineNumberGutterWidth); // Ensure measurements stay the same after receiving the intersection\n      // observer events.\n\n      await conditionPromise(() => !component.visible);\n      expect(component.getClientContainerHeight()).toBe(originalClientContainerHeight);\n      expect(component.getGutterContainerWidth()).toBe(originalGutterContainerWidth);\n      expect(component.getLineNumberGutterWidth()).toBe(originalLineNumberGutterWidth);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "renders the visible rows correctly after randomly mutating the editor",
            "suites": [
                "TextEditorComponent",
                "rendering",
                "randomized tests"
            ],
            "updatePoint": {
                "line": 926,
                "column": 79
            },
            "line": 926,
            "code": "      it('renders the visible rows correctly after randomly mutating the editor', async () => {\n        const initialSeed = Date.now();\n\n        for (var i = 0; i < 20; i++) {\n          let seed = initialSeed + i; // seed = 1520247533732\n\n          const failureMessage = 'Randomized test failed with seed: ' + seed;\n          const random = Random(seed);\n          const rowsPerTile = random.intBetween(1, 6);\n          const {\n            component,\n            element,\n            editor\n          } = buildComponent({\n            rowsPerTile,\n            autoHeight: false\n          });\n          editor.setSoftWrapped(Boolean(random(2)));\n          await setEditorWidthInCharacters(component, random(20));\n          await setEditorHeightInLines(component, random(10));\n          element.style.fontSize = random(20) + 'px';\n          element.style.lineHeight = random.floatBetween(0.1, 2.0);\n          TextEditor.didUpdateStyles();\n          await component.getNextUpdatePromise();\n          element.focus();\n\n          for (var j = 0; j < 5; j++) {\n            const k = random(100);\n            const range = getRandomBufferRange(random, editor.buffer);\n\n            if (k < 10) {\n              editor.setSoftWrapped(!editor.isSoftWrapped());\n            } else if (k < 15) {\n              if (random(2)) setEditorWidthInCharacters(component, random(20));\n              if (random(2)) setEditorHeightInLines(component, random(10));\n            } else if (k < 40) {\n              editor.setSelectedBufferRange(range);\n              editor.backspace();\n            } else if (k < 80) {\n              const linesToInsert = buildRandomLines(random, 5);\n              editor.setCursorBufferPosition(range.start);\n              editor.insertText(linesToInsert);\n            } else if (k < 90) {\n              if (random(2)) {\n                editor.foldBufferRange(range);\n              } else {\n                editor.destroyFoldsIntersectingBufferRange(range);\n              }\n            } else if (k < 95) {\n              editor.setSelectedBufferRange(range);\n            } else {\n              if (random(2)) {\n                component.setScrollTop(random(component.getScrollHeight()));\n              }\n\n              if (random(2)) {\n                component.setScrollLeft(random(component.getScrollWidth()));\n              }\n            }\n\n            component.scheduleUpdate();\n            await component.getNextUpdatePromise();\n            const renderedLines = queryOnScreenLineElements(element).sort((a, b) => a.dataset.screenRow - b.dataset.screenRow);\n            const renderedLineNumbers = queryOnScreenLineNumberElements(element).sort((a, b) => a.dataset.screenRow - b.dataset.screenRow);\n            const renderedStartRow = component.getRenderedStartRow();\n            const expectedLines = editor.displayLayer.getScreenLines(renderedStartRow, component.getRenderedEndRow());\n            expect(renderedLines.length).toBe(expectedLines.length, failureMessage);\n            expect(renderedLineNumbers.length).toBe(expectedLines.length, failureMessage);\n\n            for (let k = 0; k < renderedLines.length; k++) {\n              const expectedLine = expectedLines[k];\n              const expectedText = expectedLine.lineText || ' ';\n              const renderedLine = renderedLines[k];\n              const renderedLineNumber = renderedLineNumbers[k];\n              let renderedText = renderedLine.textContent; // We append zero width NBSPs after folds at the end of the\n              // line in order to support measurement.\n\n              if (expectedText.endsWith(editor.displayLayer.foldCharacter)) {\n                renderedText = renderedText.substring(0, renderedText.length - 1);\n              }\n\n              expect(renderedText).toBe(expectedText, failureMessage);\n              expect(parseInt(renderedLine.dataset.screenRow)).toBe(renderedStartRow + k, failureMessage);\n              expect(parseInt(renderedLineNumber.dataset.screenRow)).toBe(renderedStartRow + k, failureMessage);\n            }\n          }\n\n          element.remove();\n          editor.destroy();\n        }\n      });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the mini attribute and class even when the element is not attached",
            "suites": [
                "TextEditorComponent",
                "mini editors"
            ],
            "updatePoint": {
                "line": 1020,
                "column": 79
            },
            "line": 1020,
            "code": "    it('adds the mini attribute and class even when the element is not attached', () => {\n      {\n        const {\n          element\n        } = buildComponent({\n          mini: true\n        });\n        expect(element.hasAttribute('mini')).toBe(true);\n        expect(element.classList.contains('mini')).toBe(true);\n      }\n      {\n        const {\n          element\n        } = buildComponent({\n          mini: true,\n          attach: false\n        });\n        expect(element.hasAttribute('mini')).toBe(true);\n        expect(element.classList.contains('mini')).toBe(true);\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not render the gutter container",
            "suites": [
                "TextEditorComponent",
                "mini editors"
            ],
            "updatePoint": {
                "line": 1041,
                "column": 44
            },
            "line": 1041,
            "code": "    it('does not render the gutter container', () => {\n      const {\n        component,\n        element\n      } = buildComponent({\n        mini: true\n      });\n      expect(component.refs.gutterContainer).toBeUndefined();\n      expect(element.querySelector('gutter-container')).toBeNull();\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not render line decorations for the cursor line",
            "suites": [
                "TextEditorComponent",
                "mini editors"
            ],
            "updatePoint": {
                "line": 1051,
                "column": 60
            },
            "line": 1051,
            "code": "    it('does not render line decorations for the cursor line', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        mini: true\n      });\n      expect(element.querySelector('.line').classList.contains('cursor-line')).toBe(false);\n      editor.update({\n        mini: false\n      });\n      await component.getNextUpdatePromise();\n      expect(element.querySelector('.line').classList.contains('cursor-line')).toBe(true);\n      editor.update({\n        mini: true\n      });\n      await component.getNextUpdatePromise();\n      expect(element.querySelector('.line').classList.contains('cursor-line')).toBe(false);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not render scrollbars",
            "suites": [
                "TextEditorComponent",
                "mini editors"
            ],
            "updatePoint": {
                "line": 1071,
                "column": 34
            },
            "line": 1071,
            "code": "    it('does not render scrollbars', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        mini: true,\n        autoHeight: false\n      });\n      await setEditorWidthInCharacters(component, 10);\n      editor.setText('x'.repeat(20) + 'y'.repeat(20));\n      await component.getNextUpdatePromise();\n      expect(component.canScrollVertically()).toBe(false);\n      expect(component.canScrollHorizontally()).toBe(false);\n      expect(component.refs.horizontalScrollbar).toBeUndefined();\n      expect(component.refs.verticalScrollbar).toBeUndefined();\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses the hidden input element and adds the is-focused class when focused",
            "suites": [
                "TextEditorComponent",
                "focus"
            ],
            "updatePoint": {
                "line": 1092,
                "column": 83
            },
            "line": 1092,
            "code": "    it('focuses the hidden input element and adds the is-focused class when focused', async () => {\n      const {\n        component,\n        element\n      } = buildComponent();\n      const {\n        hiddenInput\n      } = component.refs.cursorsAndInput.refs;\n      expect(document.activeElement).not.toBe(hiddenInput);\n      element.focus();\n      expect(document.activeElement).toBe(hiddenInput);\n      await component.getNextUpdatePromise();\n      expect(element.classList.contains('is-focused')).toBe(true);\n      element.focus(); // focusing back to the element does not blur\n\n      expect(document.activeElement).toBe(hiddenInput);\n      expect(element.classList.contains('is-focused')).toBe(true);\n      document.body.focus();\n      expect(document.activeElement).not.toBe(hiddenInput);\n      await component.getNextUpdatePromise();\n      expect(element.classList.contains('is-focused')).toBe(false);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the component when the hidden input is focused directly",
            "suites": [
                "TextEditorComponent",
                "focus"
            ],
            "updatePoint": {
                "line": 1114,
                "column": 71
            },
            "line": 1114,
            "code": "    it('updates the component when the hidden input is focused directly', async () => {\n      const {\n        component,\n        element\n      } = buildComponent();\n      const {\n        hiddenInput\n      } = component.refs.cursorsAndInput.refs;\n      expect(element.classList.contains('is-focused')).toBe(false);\n      expect(document.activeElement).not.toBe(hiddenInput);\n      hiddenInput.focus();\n      await component.getNextUpdatePromise();\n      expect(element.classList.contains('is-focused')).toBe(true);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gracefully handles a focus event that occurs prior to the attachedCallback of the element",
            "suites": [
                "TextEditorComponent",
                "focus"
            ],
            "updatePoint": {
                "line": 1128,
                "column": 97
            },
            "line": 1128,
            "code": "    it('gracefully handles a focus event that occurs prior to the attachedCallback of the element', () => {\n      const {\n        component,\n        element\n      } = buildComponent({\n        attach: false\n      });\n      const parent = document.createElement('text-editor-component-test-element');\n      parent.appendChild(element);\n\n      parent.didAttach = () => element.focus();\n\n      jasmine.attachToDOM(parent);\n      expect(document.activeElement).toBe(component.refs.cursorsAndInput.refs.hiddenInput);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gracefully handles a focus event that occurs prior to detecting the element has become visible",
            "suites": [
                "TextEditorComponent",
                "focus"
            ],
            "updatePoint": {
                "line": 1143,
                "column": 102
            },
            "line": 1143,
            "code": "    it('gracefully handles a focus event that occurs prior to detecting the element has become visible', async () => {\n      const {\n        component,\n        element\n      } = buildComponent({\n        attach: false\n      });\n      element.style.display = 'none';\n      jasmine.attachToDOM(element);\n      element.style.display = 'block';\n      element.focus();\n      await component.getNextUpdatePromise();\n      expect(document.activeElement).toBe(component.refs.cursorsAndInput.refs.hiddenInput);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits blur events only when focus shifts to something other than the editor itself or its hidden input",
            "suites": [
                "TextEditorComponent",
                "focus"
            ],
            "updatePoint": {
                "line": 1157,
                "column": 110
            },
            "line": 1157,
            "code": "    it('emits blur events only when focus shifts to something other than the editor itself or its hidden input', () => {\n      const {\n        element\n      } = buildComponent();\n      let blurEventCount = 0;\n      element.addEventListener('blur', () => blurEventCount++);\n      element.focus();\n      expect(blurEventCount).toBe(0);\n      element.focus();\n      expect(blurEventCount).toBe(0);\n      document.body.focus();\n      expect(blurEventCount).toBe(1);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "automatically scrolls vertically when the requested range is within the vertical scroll margin of the top or bottom",
            "suites": [
                "TextEditorComponent",
                "autoscroll"
            ],
            "updatePoint": {
                "line": 1172,
                "column": 123
            },
            "line": 1172,
            "code": "    it('automatically scrolls vertically when the requested range is within the vertical scroll margin of the top or bottom', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        height: 120 + horizontalScrollbarHeight\n      });\n      expect(component.getLastVisibleRow()).toBe(7);\n      editor.scrollToScreenRange([[4, 0], [6, 0]]);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollBottom()).toBeNear((6 + 1 + editor.verticalScrollMargin) * component.getLineHeight());\n      editor.scrollToScreenPosition([8, 0]);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollBottom()).toBeNear((8 + 1 + editor.verticalScrollMargin) * component.measurements.lineHeight);\n      editor.scrollToScreenPosition([3, 0]);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollTop()).toBeNear((3 - editor.verticalScrollMargin) * component.measurements.lineHeight);\n      editor.scrollToScreenPosition([2, 0]);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollTop()).toBe(0);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not vertically autoscroll by more than half of the visible lines if the editor is shorter than twice the scroll margin",
            "suites": [
                "TextEditorComponent",
                "autoscroll"
            ],
            "updatePoint": {
                "line": 1193,
                "column": 131
            },
            "line": 1193,
            "code": "    it('does not vertically autoscroll by more than half of the visible lines if the editor is shorter than twice the scroll margin', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        autoHeight: false\n      });\n      element.style.height = 5.5 * component.measurements.lineHeight + horizontalScrollbarHeight + 'px';\n      await component.getNextUpdatePromise();\n      expect(component.getLastVisibleRow()).toBe(5);\n      const scrollMarginInLines = 2;\n      editor.scrollToScreenPosition([6, 0]);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollBottom()).toBeNear((6 + 1 + scrollMarginInLines) * component.measurements.lineHeight);\n      editor.scrollToScreenPosition([6, 4]);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollBottom()).toBeNear((6 + 1 + scrollMarginInLines) * component.measurements.lineHeight);\n      editor.scrollToScreenRange([[4, 4], [6, 4]]);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollTop()).toBeNear((4 - scrollMarginInLines) * component.measurements.lineHeight);\n      editor.scrollToScreenRange([[4, 4], [6, 4]], {\n        reversed: false\n      });\n      await component.getNextUpdatePromise();\n      expect(component.getScrollBottom()).toBeNear((6 + 1 + scrollMarginInLines) * component.measurements.lineHeight);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "autoscrolls the given range to the center of the screen if the `center` option is true",
            "suites": [
                "TextEditorComponent",
                "autoscroll"
            ],
            "updatePoint": {
                "line": 1220,
                "column": 94
            },
            "line": 1220,
            "code": "    it('autoscrolls the given range to the center of the screen if the `center` option is true', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        height: 50\n      });\n      expect(component.getLastVisibleRow()).toBe(2);\n      editor.scrollToScreenRange([[4, 0], [6, 0]], {\n        center: true\n      });\n      await component.getNextUpdatePromise();\n      const actualScrollCenter = (component.getScrollTop() + component.getScrollBottom()) / 2;\n      const expectedScrollCenter = (4 + 7) / 2 * component.getLineHeight();\n      expect(actualScrollCenter).toBeCloseTo(expectedScrollCenter, 0);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "automatically scrolls horizontally when the requested range is within the horizontal scroll margin of the right edge of the gutter or right edge of the scroll container",
            "suites": [
                "TextEditorComponent",
                "autoscroll"
            ],
            "updatePoint": {
                "line": 1236,
                "column": 176
            },
            "line": 1236,
            "code": "    it('automatically scrolls horizontally when the requested range is within the horizontal scroll margin of the right edge of the gutter or right edge of the scroll container', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      element.style.width = component.getGutterContainerWidth() + 3 * editor.horizontalScrollMargin * component.measurements.baseCharacterWidth + 'px';\n      await component.getNextUpdatePromise();\n      editor.scrollToScreenRange([[1, 12], [2, 28]]);\n      await component.getNextUpdatePromise();\n      let expectedScrollLeft = clientLeftForCharacter(component, 1, 12) - lineNodeForScreenRow(component, 1).getBoundingClientRect().left - editor.horizontalScrollMargin * component.measurements.baseCharacterWidth;\n      expect(component.getScrollLeft()).toBeNear(expectedScrollLeft);\n      editor.scrollToScreenRange([[1, 12], [2, 28]], {\n        reversed: false\n      });\n      await component.getNextUpdatePromise();\n      expectedScrollLeft = component.getGutterContainerWidth() + clientLeftForCharacter(component, 2, 28) - lineNodeForScreenRow(component, 2).getBoundingClientRect().left + editor.horizontalScrollMargin * component.measurements.baseCharacterWidth - component.getScrollContainerClientWidth();\n      expect(component.getScrollLeft()).toBeNear(expectedScrollLeft);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not horizontally autoscroll by more than half of the visible \"base-width\" characters if the editor is narrower than twice the scroll margin",
            "suites": [
                "TextEditorComponent",
                "autoscroll"
            ],
            "updatePoint": {
                "line": 1255,
                "column": 152
            },
            "line": 1255,
            "code": "    it('does not horizontally autoscroll by more than half of the visible \"base-width\" characters if the editor is narrower than twice the scroll margin', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        autoHeight: false\n      });\n      await setEditorWidthInCharacters(component, 1.5 * editor.horizontalScrollMargin);\n      const editorWidthInChars = component.getScrollContainerClientWidth() / component.getBaseCharacterWidth();\n      expect(Math.round(editorWidthInChars)).toBe(9);\n      editor.scrollToScreenRange([[6, 10], [6, 15]]);\n      await component.getNextUpdatePromise();\n      let expectedScrollLeft = Math.floor(clientLeftForCharacter(component, 6, 10) - lineNodeForScreenRow(component, 1).getBoundingClientRect().left - Math.floor((editorWidthInChars - 1) / 2) * component.getBaseCharacterWidth());\n      expect(component.getScrollLeft()).toBeNear(expectedScrollLeft);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly autoscrolls after inserting a line that exceeds the current content width",
            "suites": [
                "TextEditorComponent",
                "autoscroll"
            ],
            "updatePoint": {
                "line": 1270,
                "column": 91
            },
            "line": 1270,
            "code": "    it('correctly autoscrolls after inserting a line that exceeds the current content width', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      element.style.width = component.getGutterContainerWidth() + component.getContentWidth() + 'px';\n      await component.getNextUpdatePromise();\n      editor.setCursorScreenPosition([0, Infinity]);\n      editor.insertText('x'.repeat(100));\n      await component.getNextUpdatePromise();\n      expect(component.getScrollLeft()).toBeNear(component.getScrollWidth() - component.getScrollContainerClientWidth());\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not try to measure lines that do not exist when the animation frame is delivered",
            "suites": [
                "TextEditorComponent",
                "autoscroll"
            ],
            "updatePoint": {
                "line": 1283,
                "column": 93
            },
            "line": 1283,
            "code": "    it('does not try to measure lines that do not exist when the animation frame is delivered', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        autoHeight: false,\n        height: 30,\n        rowsPerTile: 2\n      });\n      editor.scrollToBufferPosition([11, 5]);\n      editor.getBuffer().deleteRows(11, 12);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollBottom()).toBeNear((10 + 1) * component.measurements.lineHeight);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "accounts for the presence of horizontal scrollbars that appear during the same frame as the autoscroll",
            "suites": [
                "TextEditorComponent",
                "autoscroll"
            ],
            "updatePoint": {
                "line": 1297,
                "column": 110
            },
            "line": 1297,
            "code": "    it('accounts for the presence of horizontal scrollbars that appear during the same frame as the autoscroll', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        autoHeight: false\n      });\n      element.style.height = component.getContentHeight() / 2 + 'px';\n      element.style.width = component.getScrollWidth() + 'px';\n      await component.getNextUpdatePromise();\n      editor.setCursorScreenPosition([10, Infinity]);\n      editor.insertText('\\n\\n' + 'x'.repeat(100));\n      await component.getNextUpdatePromise();\n      expect(component.getScrollTop()).toBeNear(component.getScrollHeight() - component.getScrollContainerClientHeight());\n      expect(component.getScrollLeft()).toBeNear(component.getScrollWidth() - component.getScrollContainerClientWidth()); // Scrolling to the top should not throw an error. This failed\n      // previously due to horizontalPositionsToMeasure not being empty after\n      // autoscrolling vertically to account for the horizontal scrollbar.\n\n      spyOn(window, 'onerror');\n      await setScrollTop(component, 0);\n      expect(window.onerror).not.toHaveBeenCalled();\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows the scrollTop to be changed and queried in terms of rows via setScrollTopRow and getScrollTopRow",
            "suites": [
                "TextEditorComponent",
                "logical scroll positions"
            ],
            "updatePoint": {
                "line": 1322,
                "column": 111
            },
            "line": 1322,
            "code": "    it('allows the scrollTop to be changed and queried in terms of rows via setScrollTopRow and getScrollTopRow', () => {\n      const {\n        component,\n        element\n      } = buildComponent({\n        attach: false,\n        height: 80\n      }); // Caches the scrollTopRow if we don't have measurements\n\n      component.setScrollTopRow(6);\n      expect(component.getScrollTopRow()).toBe(6); // Assigns the scrollTop based on the logical position when attached\n\n      jasmine.attachToDOM(element);\n      const expectedScrollTop = Math.round(6 * component.getLineHeight());\n      expect(component.getScrollTopRow()).toBeNear(6);\n      expect(component.getScrollTop()).toBeNear(expectedScrollTop);\n      expect(component.refs.content.style.transform).toBe(`translate(0px, -${expectedScrollTop}px)`); // Allows the scrollTopRow to be updated while attached\n\n      component.setScrollTopRow(4);\n      expect(component.getScrollTopRow()).toBeNear(4);\n      expect(component.getScrollTop()).toBeNear(Math.round(4 * component.getLineHeight())); // Preserves the scrollTopRow when detached\n\n      element.remove();\n      expect(component.getScrollTopRow()).toBeNear(4);\n      expect(component.getScrollTop()).toBeNear(Math.round(4 * component.getLineHeight()));\n      component.setScrollTopRow(6);\n      expect(component.getScrollTopRow()).toBeNear(6);\n      expect(component.getScrollTop()).toBeNear(Math.round(6 * component.getLineHeight()));\n      jasmine.attachToDOM(element);\n      element.style.height = '60px';\n      expect(component.getScrollTopRow()).toBeNear(6);\n      expect(component.getScrollTop()).toBeNear(Math.round(6 * component.getLineHeight()));\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows the scrollLeft to be changed and queried in terms of base character columns via setScrollLeftColumn and getScrollLeftColumn",
            "suites": [
                "TextEditorComponent",
                "logical scroll positions"
            ],
            "updatePoint": {
                "line": 1355,
                "column": 138
            },
            "line": 1355,
            "code": "    it('allows the scrollLeft to be changed and queried in terms of base character columns via setScrollLeftColumn and getScrollLeftColumn', () => {\n      const {\n        component,\n        element\n      } = buildComponent({\n        attach: false,\n        width: 80\n      }); // Caches the scrollTopRow if we don't have measurements\n\n      component.setScrollLeftColumn(2);\n      expect(component.getScrollLeftColumn()).toBe(2); // Assigns the scrollTop based on the logical position when attached\n\n      jasmine.attachToDOM(element);\n      expect(component.getScrollLeft()).toBeCloseTo(2 * component.getBaseCharacterWidth(), 0); // Allows the scrollTopRow to be updated while attached\n\n      component.setScrollLeftColumn(4);\n      expect(component.getScrollLeft()).toBeCloseTo(4 * component.getBaseCharacterWidth(), 0); // Preserves the scrollTopRow when detached\n\n      element.remove();\n      expect(component.getScrollLeft()).toBeCloseTo(4 * component.getBaseCharacterWidth(), 0);\n      component.setScrollLeftColumn(6);\n      expect(component.getScrollLeft()).toBeCloseTo(6 * component.getBaseCharacterWidth(), 0);\n      jasmine.attachToDOM(element);\n      element.style.width = '60px';\n      expect(component.getScrollLeft()).toBeCloseTo(6 * component.getBaseCharacterWidth(), 0);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "scrolls vertically or horizontally depending on whether deltaX or deltaY is larger",
            "suites": [
                "TextEditorComponent",
                "scrolling via the mouse wheel"
            ],
            "updatePoint": {
                "line": 1383,
                "column": 90
            },
            "line": 1383,
            "code": "    it('scrolls vertically or horizontally depending on whether deltaX or deltaY is larger', () => {\n      const scrollSensitivity = 30;\n      const {\n        component\n      } = buildComponent({\n        height: 50,\n        width: 50,\n        scrollSensitivity\n      }); // stub in place for Event.preventDefault()\n\n      const eventPreventDefaultStub = function () {};\n\n      {\n        const expectedScrollTop = 20 * (scrollSensitivity / 100);\n        const expectedScrollLeft = component.getScrollLeft();\n        component.didMouseWheel({\n          wheelDeltaX: -5,\n          wheelDeltaY: -20,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollTop()).toBeNear(expectedScrollTop);\n        expect(component.getScrollLeft()).toBeNear(expectedScrollLeft);\n        expect(component.refs.content.style.transform).toBe(`translate(${-expectedScrollLeft}px, ${-expectedScrollTop}px)`);\n      }\n      {\n        const expectedScrollTop = component.getScrollTop() - 10 * (scrollSensitivity / 100);\n        const expectedScrollLeft = component.getScrollLeft();\n        component.didMouseWheel({\n          wheelDeltaX: -5,\n          wheelDeltaY: 10,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollTop()).toBeNear(expectedScrollTop);\n        expect(component.getScrollLeft()).toBeNear(expectedScrollLeft);\n        expect(component.refs.content.style.transform).toBe(`translate(${-expectedScrollLeft}px, ${-expectedScrollTop}px)`);\n      }\n      {\n        const expectedScrollTop = component.getScrollTop();\n        const expectedScrollLeft = 20 * (scrollSensitivity / 100);\n        component.didMouseWheel({\n          wheelDeltaX: -20,\n          wheelDeltaY: 10,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollTop()).toBeNear(expectedScrollTop);\n        expect(component.getScrollLeft()).toBeNear(expectedScrollLeft);\n        expect(component.refs.content.style.transform).toBe(`translate(${-expectedScrollLeft}px, ${-expectedScrollTop}px)`);\n      }\n      {\n        const expectedScrollTop = component.getScrollTop();\n        const expectedScrollLeft = component.getScrollLeft() - 10 * (scrollSensitivity / 100);\n        component.didMouseWheel({\n          wheelDeltaX: 10,\n          wheelDeltaY: -8,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollTop()).toBeNear(expectedScrollTop);\n        expect(component.getScrollLeft()).toBeNear(expectedScrollLeft);\n        expect(component.refs.content.style.transform).toBe(`translate(${-expectedScrollLeft}px, ${-expectedScrollTop}px)`);\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inverts deltaX and deltaY when holding shift on Windows and Linux",
            "suites": [
                "TextEditorComponent",
                "scrolling via the mouse wheel"
            ],
            "updatePoint": {
                "line": 1444,
                "column": 73
            },
            "line": 1444,
            "code": "    it('inverts deltaX and deltaY when holding shift on Windows and Linux', async () => {\n      const scrollSensitivity = 50;\n      const {\n        component\n      } = buildComponent({\n        height: 50,\n        width: 50,\n        scrollSensitivity\n      }); // stub in place for Event.preventDefault()\n\n      const eventPreventDefaultStub = function () {};\n\n      component.props.platform = 'linux';\n      {\n        const expectedScrollTop = 20 * (scrollSensitivity / 100);\n        component.didMouseWheel({\n          wheelDeltaX: 0,\n          wheelDeltaY: -20,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollTop()).toBeNear(expectedScrollTop);\n        expect(component.refs.content.style.transform).toBe(`translate(0px, -${expectedScrollTop}px)`);\n        await setScrollTop(component, 0);\n      }\n      {\n        const expectedScrollLeft = 20 * (scrollSensitivity / 100);\n        component.didMouseWheel({\n          wheelDeltaX: 0,\n          wheelDeltaY: -20,\n          shiftKey: true,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollLeft()).toBeNear(expectedScrollLeft);\n        expect(component.refs.content.style.transform).toBe(`translate(-${expectedScrollLeft}px, 0px)`);\n        await setScrollLeft(component, 0);\n      }\n      {\n        const expectedScrollTop = 20 * (scrollSensitivity / 100);\n        component.didMouseWheel({\n          wheelDeltaX: -20,\n          wheelDeltaY: 0,\n          shiftKey: true,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollTop()).toBe(expectedScrollTop);\n        expect(component.refs.content.style.transform).toBe(`translate(0px, -${expectedScrollTop}px)`);\n        await setScrollTop(component, 0);\n      }\n      component.props.platform = 'win32';\n      {\n        const expectedScrollTop = 20 * (scrollSensitivity / 100);\n        component.didMouseWheel({\n          wheelDeltaX: 0,\n          wheelDeltaY: -20,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollTop()).toBe(expectedScrollTop);\n        expect(component.refs.content.style.transform).toBe(`translate(0px, -${expectedScrollTop}px)`);\n        await setScrollTop(component, 0);\n      }\n      {\n        const expectedScrollLeft = 20 * (scrollSensitivity / 100);\n        component.didMouseWheel({\n          wheelDeltaX: 0,\n          wheelDeltaY: -20,\n          shiftKey: true,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollLeft()).toBe(expectedScrollLeft);\n        expect(component.refs.content.style.transform).toBe(`translate(-${expectedScrollLeft}px, 0px)`);\n        await setScrollLeft(component, 0);\n      }\n      {\n        const expectedScrollTop = 20 * (scrollSensitivity / 100);\n        component.didMouseWheel({\n          wheelDeltaX: -20,\n          wheelDeltaY: 0,\n          shiftKey: true,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollTop()).toBe(expectedScrollTop);\n        expect(component.refs.content.style.transform).toBe(`translate(0px, -${expectedScrollTop}px)`);\n        await setScrollTop(component, 0);\n      }\n      component.props.platform = 'darwin';\n      {\n        const expectedScrollTop = 20 * (scrollSensitivity / 100);\n        component.didMouseWheel({\n          wheelDeltaX: 0,\n          wheelDeltaY: -20,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollTop()).toBe(expectedScrollTop);\n        expect(component.refs.content.style.transform).toBe(`translate(0px, -${expectedScrollTop}px)`);\n        await setScrollTop(component, 0);\n      }\n      {\n        const expectedScrollTop = 20 * (scrollSensitivity / 100);\n        component.didMouseWheel({\n          wheelDeltaX: 0,\n          wheelDeltaY: -20,\n          shiftKey: true,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollTop()).toBe(expectedScrollTop);\n        expect(component.refs.content.style.transform).toBe(`translate(0px, -${expectedScrollTop}px)`);\n        await setScrollTop(component, 0);\n      }\n      {\n        const expectedScrollLeft = 20 * (scrollSensitivity / 100);\n        component.didMouseWheel({\n          wheelDeltaX: -20,\n          wheelDeltaY: 0,\n          shiftKey: true,\n          preventDefault: eventPreventDefaultStub\n        });\n        expect(component.getScrollLeft()).toBe(expectedScrollLeft);\n        expect(component.refs.content.style.transform).toBe(`translate(-${expectedScrollLeft}px, 0px)`);\n        await setScrollLeft(component, 0);\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores scroll requests to NaN, null or undefined positions",
            "suites": [
                "TextEditorComponent",
                "scrolling via the API"
            ],
            "updatePoint": {
                "line": 1567,
                "column": 67
            },
            "line": 1567,
            "code": "    it('ignores scroll requests to NaN, null or undefined positions', async () => {\n      const {\n        component\n      } = buildComponent({\n        rowsPerTile: 2,\n        autoHeight: false\n      });\n      await setEditorHeightInLines(component, 3);\n      await setEditorWidthInCharacters(component, 10);\n      const initialScrollTop = Math.round(2 * component.getLineHeight());\n      const initialScrollLeft = Math.round(5 * component.getBaseCharacterWidth());\n      setScrollTop(component, initialScrollTop);\n      setScrollLeft(component, initialScrollLeft);\n      await component.getNextUpdatePromise();\n      setScrollTop(component, NaN);\n      setScrollLeft(component, NaN);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollTop()).toBeNear(initialScrollTop);\n      expect(component.getScrollLeft()).toBeNear(initialScrollLeft);\n      setScrollTop(component, null);\n      setScrollLeft(component, null);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollTop()).toBeNear(initialScrollTop);\n      expect(component.getScrollLeft()).toBeNear(initialScrollLeft);\n      setScrollTop(component, undefined);\n      setScrollLeft(component, undefined);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollTop()).toBeNear(initialScrollTop);\n      expect(component.getScrollLeft()).toBeNear(initialScrollLeft);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds decoration classes on screen lines spanned by decorated markers",
            "suites": [
                "TextEditorComponent",
                "line and line number decorations"
            ],
            "updatePoint": {
                "line": 1599,
                "column": 76
            },
            "line": 1599,
            "code": "    it('adds decoration classes on screen lines spanned by decorated markers', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        softWrapped: true\n      });\n      await setEditorWidthInCharacters(component, 55);\n      expect(lineNodeForScreenRow(component, 3).textContent).toBe('    var pivot = items.shift(), current, left = [], ');\n      expect(lineNodeForScreenRow(component, 4).textContent).toBe('    right = [];');\n      const marker1 = editor.markScreenRange([[1, 10], [3, 10]]);\n      const layer = editor.addMarkerLayer();\n      layer.markScreenPosition([5, 0]);\n      layer.markScreenPosition([8, 0]);\n      const marker4 = layer.markScreenPosition([10, 0]);\n      editor.decorateMarker(marker1, {\n        type: ['line', 'line-number'],\n        class: 'a'\n      });\n      const layerDecoration = editor.decorateMarkerLayer(layer, {\n        type: ['line', 'line-number'],\n        class: 'b'\n      });\n      layerDecoration.setPropertiesForMarker(marker4, {\n        type: 'line',\n        class: 'c'\n      });\n      await component.getNextUpdatePromise();\n      expect(lineNodeForScreenRow(component, 1).classList.contains('a')).toBe(true);\n      expect(lineNodeForScreenRow(component, 2).classList.contains('a')).toBe(true);\n      expect(lineNodeForScreenRow(component, 3).classList.contains('a')).toBe(true);\n      expect(lineNodeForScreenRow(component, 4).classList.contains('a')).toBe(false);\n      expect(lineNodeForScreenRow(component, 5).classList.contains('b')).toBe(true);\n      expect(lineNodeForScreenRow(component, 8).classList.contains('b')).toBe(true);\n      expect(lineNodeForScreenRow(component, 10).classList.contains('b')).toBe(false);\n      expect(lineNodeForScreenRow(component, 10).classList.contains('c')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 1).classList.contains('a')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 2).classList.contains('a')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 3).classList.contains('a')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 4).classList.contains('a')).toBe(false);\n      expect(lineNumberNodeForScreenRow(component, 5).classList.contains('b')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 8).classList.contains('b')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 10).classList.contains('b')).toBe(false);\n      expect(lineNumberNodeForScreenRow(component, 10).classList.contains('c')).toBe(false);\n      marker1.setScreenRange([[5, 0], [8, 0]]);\n      await component.getNextUpdatePromise();\n      expect(lineNodeForScreenRow(component, 1).classList.contains('a')).toBe(false);\n      expect(lineNodeForScreenRow(component, 2).classList.contains('a')).toBe(false);\n      expect(lineNodeForScreenRow(component, 3).classList.contains('a')).toBe(false);\n      expect(lineNodeForScreenRow(component, 4).classList.contains('a')).toBe(false);\n      expect(lineNodeForScreenRow(component, 5).classList.contains('a')).toBe(true);\n      expect(lineNodeForScreenRow(component, 5).classList.contains('b')).toBe(true);\n      expect(lineNodeForScreenRow(component, 6).classList.contains('a')).toBe(true);\n      expect(lineNodeForScreenRow(component, 7).classList.contains('a')).toBe(true);\n      expect(lineNodeForScreenRow(component, 8).classList.contains('a')).toBe(true);\n      expect(lineNodeForScreenRow(component, 8).classList.contains('b')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 1).classList.contains('a')).toBe(false);\n      expect(lineNumberNodeForScreenRow(component, 2).classList.contains('a')).toBe(false);\n      expect(lineNumberNodeForScreenRow(component, 3).classList.contains('a')).toBe(false);\n      expect(lineNumberNodeForScreenRow(component, 4).classList.contains('a')).toBe(false);\n      expect(lineNumberNodeForScreenRow(component, 5).classList.contains('a')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 5).classList.contains('b')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 6).classList.contains('a')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 7).classList.contains('a')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 8).classList.contains('a')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 8).classList.contains('b')).toBe(true);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "honors the onlyEmpty and onlyNonEmpty decoration options",
            "suites": [
                "TextEditorComponent",
                "line and line number decorations"
            ],
            "updatePoint": {
                "line": 1666,
                "column": 64
            },
            "line": 1666,
            "code": "    it('honors the onlyEmpty and onlyNonEmpty decoration options', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      const marker = editor.markScreenPosition([1, 0]);\n      editor.decorateMarker(marker, {\n        type: ['line', 'line-number'],\n        class: 'a',\n        onlyEmpty: true\n      });\n      editor.decorateMarker(marker, {\n        type: ['line', 'line-number'],\n        class: 'b',\n        onlyNonEmpty: true\n      });\n      editor.decorateMarker(marker, {\n        type: ['line', 'line-number'],\n        class: 'c'\n      });\n      await component.getNextUpdatePromise();\n      expect(lineNodeForScreenRow(component, 1).classList.contains('a')).toBe(true);\n      expect(lineNodeForScreenRow(component, 1).classList.contains('b')).toBe(false);\n      expect(lineNodeForScreenRow(component, 1).classList.contains('c')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 1).classList.contains('a')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 1).classList.contains('b')).toBe(false);\n      expect(lineNumberNodeForScreenRow(component, 1).classList.contains('c')).toBe(true);\n      marker.setScreenRange([[1, 0], [2, 4]]);\n      await component.getNextUpdatePromise();\n      expect(lineNodeForScreenRow(component, 1).classList.contains('a')).toBe(false);\n      expect(lineNodeForScreenRow(component, 1).classList.contains('b')).toBe(true);\n      expect(lineNodeForScreenRow(component, 1).classList.contains('c')).toBe(true);\n      expect(lineNodeForScreenRow(component, 2).classList.contains('b')).toBe(true);\n      expect(lineNodeForScreenRow(component, 2).classList.contains('c')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 1).classList.contains('a')).toBe(false);\n      expect(lineNumberNodeForScreenRow(component, 1).classList.contains('b')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 1).classList.contains('c')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 2).classList.contains('b')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 2).classList.contains('c')).toBe(true);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "honors the onlyHead option",
            "suites": [
                "TextEditorComponent",
                "line and line number decorations"
            ],
            "updatePoint": {
                "line": 1706,
                "column": 34
            },
            "line": 1706,
            "code": "    it('honors the onlyHead option', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      const marker = editor.markScreenRange([[1, 4], [3, 4]]);\n      editor.decorateMarker(marker, {\n        type: ['line', 'line-number'],\n        class: 'a',\n        onlyHead: true\n      });\n      await component.getNextUpdatePromise();\n      expect(lineNodeForScreenRow(component, 1).classList.contains('a')).toBe(false);\n      expect(lineNodeForScreenRow(component, 3).classList.contains('a')).toBe(true);\n      expect(lineNumberNodeForScreenRow(component, 1).classList.contains('a')).toBe(false);\n      expect(lineNumberNodeForScreenRow(component, 3).classList.contains('a')).toBe(true);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only decorates the last row of non-empty ranges that end at column 0 if omitEmptyLastRow is false",
            "suites": [
                "TextEditorComponent",
                "line and line number decorations"
            ],
            "updatePoint": {
                "line": 1723,
                "column": 105
            },
            "line": 1723,
            "code": "    it('only decorates the last row of non-empty ranges that end at column 0 if omitEmptyLastRow is false', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      const marker = editor.markScreenRange([[1, 0], [3, 0]]);\n      editor.decorateMarker(marker, {\n        type: ['line', 'line-number'],\n        class: 'a'\n      });\n      editor.decorateMarker(marker, {\n        type: ['line', 'line-number'],\n        class: 'b',\n        omitEmptyLastRow: false\n      });\n      await component.getNextUpdatePromise();\n      expect(lineNodeForScreenRow(component, 1).classList.contains('a')).toBe(true);\n      expect(lineNodeForScreenRow(component, 2).classList.contains('a')).toBe(true);\n      expect(lineNodeForScreenRow(component, 3).classList.contains('a')).toBe(false);\n      expect(lineNodeForScreenRow(component, 1).classList.contains('b')).toBe(true);\n      expect(lineNodeForScreenRow(component, 2).classList.contains('b')).toBe(true);\n      expect(lineNodeForScreenRow(component, 3).classList.contains('b')).toBe(true);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not decorate invalidated markers",
            "suites": [
                "TextEditorComponent",
                "line and line number decorations"
            ],
            "updatePoint": {
                "line": 1746,
                "column": 45
            },
            "line": 1746,
            "code": "    it('does not decorate invalidated markers', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      const marker = editor.markScreenRange([[1, 0], [3, 0]], {\n        invalidate: 'touch'\n      });\n      editor.decorateMarker(marker, {\n        type: ['line', 'line-number'],\n        class: 'a'\n      });\n      await component.getNextUpdatePromise();\n      expect(lineNodeForScreenRow(component, 2).classList.contains('a')).toBe(true);\n      editor.getBuffer().insert([2, 0], 'x');\n      expect(marker.isValid()).toBe(false);\n      await component.getNextUpdatePromise();\n      expect(lineNodeForScreenRow(component, 2).classList.contains('a')).toBe(false);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "renders single-line highlights",
            "suites": [
                "TextEditorComponent",
                "highlight decorations"
            ],
            "updatePoint": {
                "line": 1767,
                "column": 38
            },
            "line": 1767,
            "code": "    it('renders single-line highlights', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      const marker = editor.markScreenRange([[1, 2], [1, 10]]);\n      editor.decorateMarker(marker, {\n        type: 'highlight',\n        class: 'a'\n      });\n      await component.getNextUpdatePromise();\n      {\n        const regions = element.querySelectorAll('.highlight.a .region.a');\n        expect(regions.length).toBe(1);\n        const regionRect = regions[0].getBoundingClientRect();\n        expect(regionRect.top).toBe(lineNodeForScreenRow(component, 1).getBoundingClientRect().top);\n        expect(Math.round(regionRect.left)).toBeNear(clientLeftForCharacter(component, 1, 2));\n        expect(Math.round(regionRect.right)).toBeNear(clientLeftForCharacter(component, 1, 10));\n      }\n      marker.setScreenRange([[1, 4], [1, 8]]);\n      await component.getNextUpdatePromise();\n      {\n        const regions = element.querySelectorAll('.highlight.a .region.a');\n        expect(regions.length).toBe(1);\n        const regionRect = regions[0].getBoundingClientRect();\n        expect(regionRect.top).toBe(lineNodeForScreenRow(component, 1).getBoundingClientRect().top);\n        expect(regionRect.bottom).toBe(lineNodeForScreenRow(component, 1).getBoundingClientRect().bottom);\n        expect(Math.round(regionRect.left)).toBeNear(clientLeftForCharacter(component, 1, 4));\n        expect(Math.round(regionRect.right)).toBeNear(clientLeftForCharacter(component, 1, 8));\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "renders multi-line highlights",
            "suites": [
                "TextEditorComponent",
                "highlight decorations"
            ],
            "updatePoint": {
                "line": 1799,
                "column": 37
            },
            "line": 1799,
            "code": "    it('renders multi-line highlights', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 3\n      });\n      const marker = editor.markScreenRange([[2, 4], [3, 4]]);\n      editor.decorateMarker(marker, {\n        type: 'highlight',\n        class: 'a'\n      });\n      await component.getNextUpdatePromise();\n      {\n        expect(element.querySelectorAll('.highlight.a').length).toBe(1);\n        const regions = element.querySelectorAll('.highlight.a .region.a');\n        expect(regions.length).toBe(2);\n        const region0Rect = regions[0].getBoundingClientRect();\n        expect(region0Rect.top).toBe(lineNodeForScreenRow(component, 2).getBoundingClientRect().top);\n        expect(region0Rect.bottom).toBe(lineNodeForScreenRow(component, 2).getBoundingClientRect().bottom);\n        expect(Math.round(region0Rect.left)).toBeNear(clientLeftForCharacter(component, 2, 4));\n        expect(Math.round(region0Rect.right)).toBeNear(component.refs.content.getBoundingClientRect().right);\n        const region1Rect = regions[1].getBoundingClientRect();\n        expect(region1Rect.top).toBeNear(lineNodeForScreenRow(component, 3).getBoundingClientRect().top);\n        expect(region1Rect.bottom).toBeNear(lineNodeForScreenRow(component, 3).getBoundingClientRect().bottom);\n        expect(Math.round(region1Rect.left)).toBeNear(clientLeftForCharacter(component, 3, 0));\n        expect(Math.round(region1Rect.right)).toBeNear(clientLeftForCharacter(component, 3, 4));\n      }\n      marker.setScreenRange([[2, 4], [5, 4]]);\n      await component.getNextUpdatePromise();\n      {\n        expect(element.querySelectorAll('.highlight.a').length).toBe(1);\n        const regions = element.querySelectorAll('.highlight.a .region.a');\n        expect(regions.length).toBe(3);\n        const region0Rect = regions[0].getBoundingClientRect();\n        expect(region0Rect.top).toBeNear(lineNodeForScreenRow(component, 2).getBoundingClientRect().top);\n        expect(region0Rect.bottom).toBeNear(lineNodeForScreenRow(component, 2).getBoundingClientRect().bottom);\n        expect(Math.round(region0Rect.left)).toBeNear(clientLeftForCharacter(component, 2, 4));\n        expect(Math.round(region0Rect.right)).toBeNear(component.refs.content.getBoundingClientRect().right);\n        const region1Rect = regions[1].getBoundingClientRect();\n        expect(region1Rect.top).toBeNear(lineNodeForScreenRow(component, 3).getBoundingClientRect().top);\n        expect(region1Rect.bottom).toBeNear(lineNodeForScreenRow(component, 5).getBoundingClientRect().top);\n        expect(Math.round(region1Rect.left)).toBeNear(component.refs.content.getBoundingClientRect().left);\n        expect(Math.round(region1Rect.right)).toBeNear(component.refs.content.getBoundingClientRect().right);\n        const region2Rect = regions[2].getBoundingClientRect();\n        expect(region2Rect.top).toBeNear(lineNodeForScreenRow(component, 5).getBoundingClientRect().top);\n        expect(region2Rect.bottom).toBeNear(lineNodeForScreenRow(component, 6).getBoundingClientRect().top);\n        expect(Math.round(region2Rect.left)).toBeNear(component.refs.content.getBoundingClientRect().left);\n        expect(Math.round(region2Rect.right)).toBeNear(clientLeftForCharacter(component, 5, 4));\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can flash highlight decorations",
            "suites": [
                "TextEditorComponent",
                "highlight decorations"
            ],
            "updatePoint": {
                "line": 1851,
                "column": 39
            },
            "line": 1851,
            "code": "    it('can flash highlight decorations', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 3,\n        height: 200\n      });\n      const marker = editor.markScreenRange([[2, 4], [3, 4]]);\n      const decoration = editor.decorateMarker(marker, {\n        type: 'highlight',\n        class: 'a'\n      });\n      decoration.flash('b', 10); // Flash on initial appearance of highlight\n\n      await component.getNextUpdatePromise();\n      const highlights = element.querySelectorAll('.highlight.a');\n      expect(highlights.length).toBe(1);\n      expect(highlights[0].classList.contains('b')).toBe(true);\n      await conditionPromise(() => !highlights[0].classList.contains('b')); // Don't flash on next update if another flash wasn't requested\n\n      await setScrollTop(component, 100);\n      expect(highlights[0].classList.contains('b')).toBe(false); // Flashing the same class again before the first flash completes\n      // removes the flash class and adds it back on the next frame to ensure\n      // CSS transitions apply to the second flash.\n\n      decoration.flash('e', 100);\n      await component.getNextUpdatePromise();\n      expect(highlights[0].classList.contains('e')).toBe(true);\n      decoration.flash('e', 100);\n      await component.getNextUpdatePromise();\n      expect(highlights[0].classList.contains('e')).toBe(false);\n      await conditionPromise(() => highlights[0].classList.contains('e'));\n      await conditionPromise(() => !highlights[0].classList.contains('e'));\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "flashing a highlight decoration doesn't unflash other highlight decorations",
            "suites": [
                "TextEditorComponent",
                "highlight decorations"
            ],
            "updatePoint": {
                "line": 1887,
                "column": 83
            },
            "line": 1887,
            "code": "    it(\"flashing a highlight decoration doesn't unflash other highlight decorations\", async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 3,\n        height: 200\n      });\n      const marker = editor.markScreenRange([[2, 4], [3, 4]]);\n      const decoration = editor.decorateMarker(marker, {\n        type: 'highlight',\n        class: 'a'\n      }); // Flash one class\n\n      decoration.flash('c', 1000);\n      await component.getNextUpdatePromise();\n      const highlights = element.querySelectorAll('.highlight.a');\n      expect(highlights.length).toBe(1);\n      expect(highlights[0].classList.contains('c')).toBe(true); // Flash another class while the previously-flashed class is still highlighted\n\n      decoration.flash('d', 100);\n      await component.getNextUpdatePromise();\n      expect(highlights[0].classList.contains('c')).toBe(true);\n      expect(highlights[0].classList.contains('d')).toBe(true);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "supports layer decorations",
            "suites": [
                "TextEditorComponent",
                "highlight decorations"
            ],
            "updatePoint": {
                "line": 1913,
                "column": 34
            },
            "line": 1913,
            "code": "    it('supports layer decorations', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 12\n      });\n      const markerLayer = editor.addMarkerLayer();\n      const marker1 = markerLayer.markScreenRange([[2, 4], [3, 4]]);\n      const marker2 = markerLayer.markScreenRange([[5, 6], [7, 8]]);\n      const decoration = editor.decorateMarkerLayer(markerLayer, {\n        type: 'highlight',\n        class: 'a'\n      });\n      await component.getNextUpdatePromise();\n      const highlights = element.querySelectorAll('.highlight');\n      expect(highlights[0].classList.contains('a')).toBe(true);\n      expect(highlights[1].classList.contains('a')).toBe(true);\n      decoration.setPropertiesForMarker(marker1, {\n        type: 'highlight',\n        class: 'b'\n      });\n      await component.getNextUpdatePromise();\n      expect(highlights[0].classList.contains('b')).toBe(true);\n      expect(highlights[1].classList.contains('a')).toBe(true);\n      decoration.setPropertiesForMarker(marker1, null);\n      decoration.setPropertiesForMarker(marker2, {\n        type: 'highlight',\n        class: 'c'\n      });\n      await component.getNextUpdatePromise();\n      expect(highlights[0].classList.contains('a')).toBe(true);\n      expect(highlights[1].classList.contains('c')).toBe(true);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears highlights when recycling a tile that previously contained highlights and now does not",
            "suites": [
                "TextEditorComponent",
                "highlight decorations"
            ],
            "updatePoint": {
                "line": 1948,
                "column": 101
            },
            "line": 1948,
            "code": "    it('clears highlights when recycling a tile that previously contained highlights and now does not', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 2,\n        autoHeight: false\n      });\n      await setEditorHeightInLines(component, 2);\n      const marker = editor.markScreenRange([[1, 2], [1, 10]]);\n      editor.decorateMarker(marker, {\n        type: 'highlight',\n        class: 'a'\n      });\n      await component.getNextUpdatePromise();\n      expect(element.querySelectorAll('.highlight.a').length).toBe(1);\n      await setScrollTop(component, component.getLineHeight() * 3);\n      expect(element.querySelectorAll('.highlight.a').length).toBe(0);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not move existing highlights when adding or removing other highlight decorations (regression)",
            "suites": [
                "TextEditorComponent",
                "highlight decorations"
            ],
            "updatePoint": {
                "line": 1968,
                "column": 106
            },
            "line": 1968,
            "code": "    it('does not move existing highlights when adding or removing other highlight decorations (regression)', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      const marker1 = editor.markScreenRange([[1, 6], [1, 10]]);\n      editor.decorateMarker(marker1, {\n        type: 'highlight',\n        class: 'a'\n      });\n      await component.getNextUpdatePromise();\n      const marker1Region = element.querySelector('.highlight.a');\n      expect(Array.from(marker1Region.parentElement.children).indexOf(marker1Region)).toBe(0);\n      const marker2 = editor.markScreenRange([[1, 2], [1, 4]]);\n      editor.decorateMarker(marker2, {\n        type: 'highlight',\n        class: 'b'\n      });\n      await component.getNextUpdatePromise();\n      const marker2Region = element.querySelector('.highlight.b');\n      expect(Array.from(marker1Region.parentElement.children).indexOf(marker1Region)).toBe(0);\n      expect(Array.from(marker2Region.parentElement.children).indexOf(marker2Region)).toBe(1);\n      marker2.destroy();\n      await component.getNextUpdatePromise();\n      expect(Array.from(marker1Region.parentElement.children).indexOf(marker1Region)).toBe(0);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly positions highlights that end on rows preceding or following block decorations",
            "suites": [
                "TextEditorComponent",
                "highlight decorations"
            ],
            "updatePoint": {
                "line": 1995,
                "column": 96
            },
            "line": 1995,
            "code": "    it('correctly positions highlights that end on rows preceding or following block decorations', async () => {\n      const {\n        editor,\n        element,\n        component\n      } = buildComponent();\n      const item1 = document.createElement('div');\n      item1.style.height = '30px';\n      item1.style.backgroundColor = 'blue';\n      editor.decorateMarker(editor.markBufferPosition([4, 0]), {\n        type: 'block',\n        position: 'after',\n        item: item1\n      });\n      const item2 = document.createElement('div');\n      item2.style.height = '30px';\n      item2.style.backgroundColor = 'yellow';\n      editor.decorateMarker(editor.markBufferPosition([4, 0]), {\n        type: 'block',\n        position: 'before',\n        item: item2\n      });\n      editor.decorateMarker(editor.markBufferRange([[3, 0], [4, Infinity]]), {\n        type: 'highlight',\n        class: 'highlight'\n      });\n      await component.getNextUpdatePromise();\n      const regions = element.querySelectorAll('.highlight .region');\n      expect(regions[0].offsetTop).toBeNear(3 * component.getLineHeight());\n      expect(regions[0].offsetHeight).toBeNear(component.getLineHeight());\n      expect(regions[1].offsetTop).toBeNear(4 * component.getLineHeight() + 30);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "renders overlay elements at the specified screen position unless it would overflow the window",
            "suites": [
                "TextEditorComponent",
                "overlay decorations"
            ],
            "updatePoint": {
                "line": 2041,
                "column": 101
            },
            "line": 2041,
            "code": "    it('renders overlay elements at the specified screen position unless it would overflow the window', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        width: 200,\n        height: 100,\n        attach: false\n      });\n      const fakeWindow = attachFakeWindow(component);\n      await setScrollTop(component, 50);\n      await setScrollLeft(component, 100);\n      const marker = editor.markScreenPosition([4, 25]);\n      const overlayElement = document.createElement('div');\n      overlayElement.style.width = '50px';\n      overlayElement.style.height = '50px';\n      overlayElement.style.margin = '3px';\n      overlayElement.style.backgroundColor = 'red';\n      const decoration = editor.decorateMarker(marker, {\n        type: 'overlay',\n        item: overlayElement,\n        class: 'a'\n      });\n      await component.getNextUpdatePromise();\n      const overlayComponent = component.overlayComponents.values().next().value;\n      const overlayWrapper = overlayElement.parentElement;\n      expect(overlayWrapper.classList.contains('a')).toBe(true);\n      expect(overlayWrapper.getBoundingClientRect().top).toBeNear(clientTopForLine(component, 5));\n      expect(overlayWrapper.getBoundingClientRect().left).toBeNear(clientLeftForCharacter(component, 4, 25)); // Updates the horizontal position on scroll\n\n      await setScrollLeft(component, 150);\n      expect(overlayWrapper.getBoundingClientRect().left).toBeNear(clientLeftForCharacter(component, 4, 25)); // Shifts the overlay horizontally to ensure the overlay element does not\n      // overflow the window\n\n      await setScrollLeft(component, 30);\n      expect(overlayElement.getBoundingClientRect().right).toBeNear(fakeWindow.getBoundingClientRect().right);\n      await setScrollLeft(component, 280);\n      expect(overlayElement.getBoundingClientRect().left).toBeNear(fakeWindow.getBoundingClientRect().left); // Updates the vertical position on scroll\n\n      await setScrollTop(component, 60);\n      expect(overlayWrapper.getBoundingClientRect().top).toBeNear(clientTopForLine(component, 5)); // Flips the overlay vertically to ensure the overlay element does not\n      // overflow the bottom of the window\n\n      setScrollLeft(component, 100);\n      await setScrollTop(component, 0);\n      expect(overlayWrapper.getBoundingClientRect().bottom).toBeNear(clientTopForLine(component, 4)); // Flips the overlay vertically on overlay resize if necessary\n\n      await setScrollTop(component, 20);\n      expect(overlayWrapper.getBoundingClientRect().top).toBeNear(clientTopForLine(component, 5));\n      overlayElement.style.height = 60 + 'px';\n      await overlayComponent.getNextUpdatePromise();\n      expect(overlayWrapper.getBoundingClientRect().bottom).toBeNear(clientTopForLine(component, 4)); // Does not flip the overlay vertically if it would overflow the top of the window\n\n      overlayElement.style.height = 80 + 'px';\n      await overlayComponent.getNextUpdatePromise();\n      expect(overlayWrapper.getBoundingClientRect().top).toBeNear(clientTopForLine(component, 5)); // Can update overlay wrapper class\n\n      decoration.setProperties({\n        type: 'overlay',\n        item: overlayElement,\n        class: 'b'\n      });\n      await component.getNextUpdatePromise();\n      expect(overlayWrapper.classList.contains('a')).toBe(false);\n      expect(overlayWrapper.classList.contains('b')).toBe(true);\n      decoration.setProperties({\n        type: 'overlay',\n        item: overlayElement\n      });\n      await component.getNextUpdatePromise();\n      expect(overlayWrapper.classList.contains('b')).toBe(false);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not attempt to avoid overflowing the window if `avoidOverflow` is false on the decoration",
            "suites": [
                "TextEditorComponent",
                "overlay decorations"
            ],
            "updatePoint": {
                "line": 2113,
                "column": 102
            },
            "line": 2113,
            "code": "    it('does not attempt to avoid overflowing the window if `avoidOverflow` is false on the decoration', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        width: 200,\n        height: 100,\n        attach: false\n      });\n      const fakeWindow = attachFakeWindow(component);\n      const overlayElement = document.createElement('div');\n      overlayElement.style.width = '50px';\n      overlayElement.style.height = '50px';\n      overlayElement.style.margin = '3px';\n      overlayElement.style.backgroundColor = 'red';\n      const marker = editor.markScreenPosition([4, 25]);\n      editor.decorateMarker(marker, {\n        type: 'overlay',\n        item: overlayElement,\n        avoidOverflow: false\n      });\n      await component.getNextUpdatePromise();\n      await setScrollLeft(component, 30);\n      expect(overlayElement.getBoundingClientRect().right).toBeGreaterThan(fakeWindow.getBoundingClientRect().right);\n      await setScrollLeft(component, 280);\n      expect(overlayElement.getBoundingClientRect().left).toBeLessThan(fakeWindow.getBoundingClientRect().left);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "arranges custom gutters based on their priority",
            "suites": [
                "TextEditorComponent",
                "custom gutter decorations"
            ],
            "updatePoint": {
                "line": 2142,
                "column": 55
            },
            "line": 2142,
            "code": "    it('arranges custom gutters based on their priority', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      editor.addGutter({\n        name: 'e',\n        priority: 2\n      });\n      editor.addGutter({\n        name: 'a',\n        priority: -2\n      });\n      editor.addGutter({\n        name: 'd',\n        priority: 1\n      });\n      editor.addGutter({\n        name: 'b',\n        priority: -1\n      });\n      editor.addGutter({\n        name: 'c',\n        priority: 0\n      });\n      await component.getNextUpdatePromise();\n      const gutters = component.refs.gutterContainer.element.querySelectorAll('.gutter');\n      expect(Array.from(gutters).map(g => g.getAttribute('gutter-name'))).toEqual(['a', 'b', 'c', 'line-number', 'd', 'e']);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adjusts the left edge of the scroll container based on changes to the gutter container width",
            "suites": [
                "TextEditorComponent",
                "custom gutter decorations"
            ],
            "updatePoint": {
                "line": 2171,
                "column": 100
            },
            "line": 2171,
            "code": "    it('adjusts the left edge of the scroll container based on changes to the gutter container width', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      const {\n        scrollContainer,\n        gutterContainer\n      } = component.refs;\n\n      function checkScrollContainerLeft() {\n        expect(scrollContainer.getBoundingClientRect().left).toBeNear(Math.round(gutterContainer.element.getBoundingClientRect().right));\n      }\n\n      checkScrollContainerLeft();\n      const gutterA = editor.addGutter({\n        name: 'a'\n      });\n      await component.getNextUpdatePromise();\n      checkScrollContainerLeft();\n      const gutterB = editor.addGutter({\n        name: 'b'\n      });\n      await component.getNextUpdatePromise();\n      checkScrollContainerLeft();\n      gutterA.getElement().style.width = 100 + 'px';\n      await component.getNextUpdatePromise();\n      checkScrollContainerLeft();\n      gutterA.hide();\n      await component.getNextUpdatePromise();\n      checkScrollContainerLeft();\n      gutterA.show();\n      await component.getNextUpdatePromise();\n      checkScrollContainerLeft();\n      gutterA.destroy();\n      await component.getNextUpdatePromise();\n      checkScrollContainerLeft();\n      gutterB.destroy();\n      await component.getNextUpdatePromise();\n      checkScrollContainerLeft();\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows the element of custom gutters to be retrieved before being rendered in the editor component",
            "suites": [
                "TextEditorComponent",
                "custom gutter decorations"
            ],
            "updatePoint": {
                "line": 2212,
                "column": 106
            },
            "line": 2212,
            "code": "    it('allows the element of custom gutters to be retrieved before being rendered in the editor component', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      const [lineNumberGutter] = editor.getGutters();\n      const gutterA = editor.addGutter({\n        name: 'a',\n        priority: -1\n      });\n      const gutterB = editor.addGutter({\n        name: 'b',\n        priority: 1\n      });\n      const lineNumberGutterElement = lineNumberGutter.getElement();\n      const gutterAElement = gutterA.getElement();\n      const gutterBElement = gutterB.getElement();\n      await component.getNextUpdatePromise();\n      expect(element.contains(lineNumberGutterElement)).toBe(true);\n      expect(element.contains(gutterAElement)).toBe(true);\n      expect(element.contains(gutterBElement)).toBe(true);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can show and hide custom gutters",
            "suites": [
                "TextEditorComponent",
                "custom gutter decorations"
            ],
            "updatePoint": {
                "line": 2235,
                "column": 40
            },
            "line": 2235,
            "code": "    it('can show and hide custom gutters', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      const gutterA = editor.addGutter({\n        name: 'a',\n        priority: -1\n      });\n      const gutterB = editor.addGutter({\n        name: 'b',\n        priority: 1\n      });\n      const gutterAElement = gutterA.getElement();\n      const gutterBElement = gutterB.getElement();\n      await component.getNextUpdatePromise();\n      expect(gutterAElement.style.display).toBe('');\n      expect(gutterBElement.style.display).toBe('');\n      gutterA.hide();\n      await component.getNextUpdatePromise();\n      expect(gutterAElement.style.display).toBe('none');\n      expect(gutterBElement.style.display).toBe('');\n      gutterB.hide();\n      await component.getNextUpdatePromise();\n      expect(gutterAElement.style.display).toBe('none');\n      expect(gutterBElement.style.display).toBe('none');\n      gutterA.show();\n      await component.getNextUpdatePromise();\n      expect(gutterAElement.style.display).toBe('');\n      expect(gutterBElement.style.display).toBe('none');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "renders decorations in custom gutters",
            "suites": [
                "TextEditorComponent",
                "custom gutter decorations"
            ],
            "updatePoint": {
                "line": 2266,
                "column": 45
            },
            "line": 2266,
            "code": "    it('renders decorations in custom gutters', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      const gutterA = editor.addGutter({\n        name: 'a',\n        priority: -1\n      });\n      const gutterB = editor.addGutter({\n        name: 'b',\n        priority: 1\n      });\n      const marker1 = editor.markScreenRange([[2, 0], [4, 0]]);\n      const marker2 = editor.markScreenRange([[6, 0], [7, 0]]);\n      const marker3 = editor.markScreenRange([[9, 0], [12, 0]]);\n      const decorationElement1 = document.createElement('div');\n      const decorationElement2 = document.createElement('div'); // Packages may adopt this class name for decorations to be styled the same as line numbers\n\n      decorationElement2.className = 'line-number';\n      const decoration1 = gutterA.decorateMarker(marker1, {\n        class: 'a'\n      });\n      const decoration2 = gutterA.decorateMarker(marker2, {\n        class: 'b',\n        item: decorationElement1\n      });\n      const decoration3 = gutterB.decorateMarker(marker3, {\n        item: decorationElement2\n      });\n      await component.getNextUpdatePromise();\n      let [decorationNode1, decorationNode2] = gutterA.getElement().firstChild.children;\n      const [decorationNode3] = gutterB.getElement().firstChild.children;\n      expect(decorationNode1.className).toBe('decoration a');\n      expect(decorationNode1.getBoundingClientRect().top).toBeNear(clientTopForLine(component, 2));\n      expect(decorationNode1.getBoundingClientRect().bottom).toBeNear(clientTopForLine(component, 5));\n      expect(decorationNode1.firstChild).toBeNull();\n      expect(decorationNode2.className).toBe('decoration b');\n      expect(decorationNode2.getBoundingClientRect().top).toBeNear(clientTopForLine(component, 6));\n      expect(decorationNode2.getBoundingClientRect().bottom).toBeNear(clientTopForLine(component, 8));\n      expect(decorationNode2.firstChild).toBe(decorationElement1);\n      expect(decorationElement1.offsetHeight).toBe(decorationNode2.offsetHeight);\n      expect(decorationElement1.offsetWidth).toBe(decorationNode2.offsetWidth);\n      expect(decorationNode3.className).toBe('decoration');\n      expect(decorationNode3.getBoundingClientRect().top).toBeNear(clientTopForLine(component, 9));\n      expect(decorationNode3.getBoundingClientRect().bottom).toBeNear(clientTopForLine(component, 12) + component.getLineHeight());\n      expect(decorationNode3.firstChild).toBe(decorationElement2);\n      expect(decorationElement2.offsetHeight).toBe(decorationNode3.offsetHeight);\n      expect(decorationElement2.offsetWidth).toBe(decorationNode3.offsetWidth); // Inline styled height is updated when line height changes\n\n      element.style.fontSize = parseInt(getComputedStyle(element).fontSize) + 10 + 'px';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      expect(decorationElement1.offsetHeight).toBe(decorationNode2.offsetHeight);\n      expect(decorationElement2.offsetHeight).toBe(decorationNode3.offsetHeight);\n      decoration1.setProperties({\n        type: 'gutter',\n        gutterName: 'a',\n        class: 'c',\n        item: decorationElement1\n      });\n      decoration2.setProperties({\n        type: 'gutter',\n        gutterName: 'a'\n      });\n      decoration3.destroy();\n      await component.getNextUpdatePromise();\n      expect(decorationNode1.className).toBe('decoration c');\n      expect(decorationNode1.firstChild).toBe(decorationElement1);\n      expect(decorationElement1.offsetHeight).toBe(decorationNode1.offsetHeight);\n      expect(decorationNode2.className).toBe('decoration');\n      expect(decorationNode2.firstChild).toBeNull();\n      expect(gutterB.getElement().firstChild.children.length).toBe(0);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "renders custom line number gutters",
            "suites": [
                "TextEditorComponent",
                "custom gutter decorations"
            ],
            "updatePoint": {
                "line": 2341,
                "column": 42
            },
            "line": 2341,
            "code": "    it('renders custom line number gutters', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      const gutterA = editor.addGutter({\n        name: 'a',\n        priority: 1,\n        type: 'line-number',\n        class: 'a-number',\n        labelFn: ({\n          bufferRow\n        }) => `a - ${bufferRow}`\n      });\n      const gutterB = editor.addGutter({\n        name: 'b',\n        priority: 1,\n        type: 'line-number',\n        class: 'b-number',\n        labelFn: ({\n          bufferRow\n        }) => `b - ${bufferRow}`\n      });\n      editor.setText('0000\\n0001\\n0002\\n0003\\n0004\\n');\n      await component.getNextUpdatePromise();\n      const gutterAElement = gutterA.getElement();\n      const aNumbers = gutterAElement.querySelectorAll('div.line-number[data-buffer-row]');\n      const aLabels = Array.from(aNumbers, e => e.textContent);\n      expect(aLabels).toEqual(['a - 0', 'a - 1', 'a - 2', 'a - 3', 'a - 4', 'a - 5']);\n      const gutterBElement = gutterB.getElement();\n      const bNumbers = gutterBElement.querySelectorAll('div.line-number[data-buffer-row]');\n      const bLabels = Array.from(bNumbers, e => e.textContent);\n      expect(bLabels).toEqual(['b - 0', 'b - 1', 'b - 2', 'b - 3', 'b - 4', 'b - 5']);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the editor's soft wrap width when a custom gutter's measurement is available",
            "suites": [
                "TextEditorComponent",
                "custom gutter decorations"
            ],
            "updatePoint": {
                "line": 2375,
                "column": 92
            },
            "line": 2375,
            "code": "    it(\"updates the editor's soft wrap width when a custom gutter's measurement is available\", () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        lineNumberGutterVisible: false,\n        width: 400,\n        softWrapped: true,\n        attach: false\n      });\n      const gutter = editor.addGutter({\n        name: 'a',\n        priority: 10\n      });\n      gutter.getElement().style.width = '100px';\n      jasmine.attachToDOM(element);\n      expect(component.getGutterContainerWidth()).toBe(100); // Component client width - gutter container width - vertical scrollbar width\n\n      const softWrapColumn = Math.floor((400 - 100 - component.getVerticalScrollbarWidth()) / component.getBaseCharacterWidth());\n      expect(editor.getSoftWrapColumn()).toBe(softWrapColumn);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "renders visible block decorations between the appropriate lines, refreshing and measuring them as needed",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 2399,
                "column": 112
            },
            "line": 2399,
            "code": "    it('renders visible block decorations between the appropriate lines, refreshing and measuring them as needed', async () => {\n      const editor = buildEditor({\n        autoHeight: false\n      });\n      const {\n        item: item1,\n        decoration: decoration1\n      } = createBlockDecorationAtScreenRow(editor, 0, {\n        height: 11,\n        position: 'before'\n      });\n      const {\n        item: item2,\n        decoration: decoration2\n      } = createBlockDecorationAtScreenRow(editor, 2, {\n        height: 22,\n        margin: 10,\n        position: 'before'\n      }); // render an editor that already contains some block decorations\n\n      const {\n        component,\n        element\n      } = buildComponent({\n        editor,\n        rowsPerTile: 3\n      });\n      element.style.height = 4 * component.getLineHeight() + horizontalScrollbarHeight + 'px';\n      await component.getNextUpdatePromise();\n      expect(component.getRenderedStartRow()).toBe(0);\n      expect(component.getRenderedEndRow()).toBe(9);\n      expect(component.getScrollHeight()).toBeNear(editor.getScreenLineCount() * component.getLineHeight() + getElementHeight(item1) + getElementHeight(item2));\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + getElementHeight(item1) + getElementHeight(item2)\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }]);\n      assertLinesAreAlignedWithLineNumbers(component);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n      expect(item1.previousSibling).toBeNull();\n      expect(item1.nextSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item2.previousSibling).toBe(lineNodeForScreenRow(component, 1));\n      expect(item2.nextSibling).toBe(lineNodeForScreenRow(component, 2)); // add block decorations\n\n      const {\n        item: item3,\n        decoration: decoration3\n      } = createBlockDecorationAtScreenRow(editor, 4, {\n        height: 33,\n        position: 'before'\n      });\n      const {\n        item: item4\n      } = createBlockDecorationAtScreenRow(editor, 7, {\n        height: 44,\n        position: 'before'\n      });\n      const {\n        item: item5\n      } = createBlockDecorationAtScreenRow(editor, 7, {\n        height: 50,\n        marginBottom: 5,\n        position: 'after'\n      });\n      const {\n        item: item6\n      } = createBlockDecorationAtScreenRow(editor, 12, {\n        height: 60,\n        marginTop: 6,\n        position: 'after'\n      });\n      await component.getNextUpdatePromise();\n      expect(component.getRenderedStartRow()).toBe(0);\n      expect(component.getRenderedEndRow()).toBe(9);\n      expect(component.getScrollHeight()).toBeNear(editor.getScreenLineCount() * component.getLineHeight() + getElementHeight(item1) + getElementHeight(item2) + getElementHeight(item3) + getElementHeight(item4) + getElementHeight(item5) + getElementHeight(item6));\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + getElementHeight(item1) + getElementHeight(item2)\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight() + getElementHeight(item3)\n      }]);\n      assertLinesAreAlignedWithLineNumbers(component);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n      expect(item1.previousSibling).toBeNull();\n      expect(item1.nextSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item2.previousSibling).toBe(lineNodeForScreenRow(component, 1));\n      expect(item2.nextSibling).toBe(lineNodeForScreenRow(component, 2));\n      expect(item3.previousSibling).toBe(lineNodeForScreenRow(component, 3));\n      expect(item3.nextSibling).toBe(lineNodeForScreenRow(component, 4));\n      expect(item4.nextSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(item5.previousSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(element.contains(item6)).toBe(false); // destroy decoration1\n\n      decoration1.destroy();\n      await component.getNextUpdatePromise();\n      expect(component.getRenderedStartRow()).toBe(0);\n      expect(component.getRenderedEndRow()).toBe(9);\n      expect(component.getScrollHeight()).toBeNear(editor.getScreenLineCount() * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3) + getElementHeight(item4) + getElementHeight(item5) + getElementHeight(item6));\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + getElementHeight(item2)\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight() + getElementHeight(item3)\n      }]);\n      assertLinesAreAlignedWithLineNumbers(component);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n      expect(element.contains(item1)).toBe(false);\n      expect(item2.previousSibling).toBe(lineNodeForScreenRow(component, 1));\n      expect(item2.nextSibling).toBe(lineNodeForScreenRow(component, 2));\n      expect(item3.previousSibling).toBe(lineNodeForScreenRow(component, 3));\n      expect(item3.nextSibling).toBe(lineNodeForScreenRow(component, 4));\n      expect(item4.nextSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(item5.previousSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(element.contains(item6)).toBe(false); // move decoration2 and decoration3\n\n      decoration2.getMarker().setHeadScreenPosition([1, 0]);\n      decoration3.getMarker().setHeadScreenPosition([0, 0]);\n      await component.getNextUpdatePromise();\n      expect(component.getRenderedStartRow()).toBe(0);\n      expect(component.getRenderedEndRow()).toBe(9);\n      expect(component.getScrollHeight()).toBeNear(editor.getScreenLineCount() * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3) + getElementHeight(item4) + getElementHeight(item5) + getElementHeight(item6));\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3)\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }]);\n      assertLinesAreAlignedWithLineNumbers(component);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n      expect(element.contains(item1)).toBe(false);\n      expect(item2.previousSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item2.nextSibling).toBe(lineNodeForScreenRow(component, 1));\n      expect(item3.previousSibling).toBeNull();\n      expect(item3.nextSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item4.nextSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(item5.previousSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(element.contains(item6)).toBe(false); // change the text\n\n      editor.getBuffer().setTextInRange([[0, 5], [0, 5]], '\\n\\n');\n      await component.getNextUpdatePromise();\n      expect(component.getRenderedStartRow()).toBe(0);\n      expect(component.getRenderedEndRow()).toBe(9);\n      expect(component.getScrollHeight()).toBeNear(editor.getScreenLineCount() * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3) + getElementHeight(item4) + getElementHeight(item5) + getElementHeight(item6));\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + getElementHeight(item3)\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight() + getElementHeight(item2)\n      }]);\n      assertLinesAreAlignedWithLineNumbers(component);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n      expect(element.contains(item1)).toBe(false);\n      expect(item2.previousSibling).toBeNull();\n      expect(item2.nextSibling).toBe(lineNodeForScreenRow(component, 3));\n      expect(item3.previousSibling).toBeNull();\n      expect(item3.nextSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(element.contains(item4)).toBe(false);\n      expect(element.contains(item5)).toBe(false);\n      expect(element.contains(item6)).toBe(false); // scroll past the first tile\n\n      await setScrollTop(component, 3 * component.getLineHeight() + getElementHeight(item3));\n      expect(component.getRenderedStartRow()).toBe(3);\n      expect(component.getRenderedEndRow()).toBe(12);\n      expect(component.getScrollHeight()).toBeNear(editor.getScreenLineCount() * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3) + getElementHeight(item4) + getElementHeight(item5) + getElementHeight(item6));\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight() + getElementHeight(item2)\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight()\n      }]);\n      assertLinesAreAlignedWithLineNumbers(component);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n      expect(element.contains(item1)).toBe(false);\n      expect(item2.previousSibling).toBeNull();\n      expect(item2.nextSibling).toBe(lineNodeForScreenRow(component, 3));\n      expect(element.contains(item3)).toBe(false);\n      expect(item4.nextSibling).toBe(lineNodeForScreenRow(component, 9));\n      expect(item5.previousSibling).toBe(lineNodeForScreenRow(component, 9));\n      expect(element.contains(item6)).toBe(false);\n      await setScrollTop(component, 0); // undo the previous change\n\n      editor.undo();\n      await component.getNextUpdatePromise();\n      expect(component.getRenderedStartRow()).toBe(0);\n      expect(component.getRenderedEndRow()).toBe(9);\n      expect(component.getScrollHeight()).toBeNear(editor.getScreenLineCount() * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3) + getElementHeight(item4) + getElementHeight(item5) + getElementHeight(item6));\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3)\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }]);\n      assertLinesAreAlignedWithLineNumbers(component);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n      expect(element.contains(item1)).toBe(false);\n      expect(item2.previousSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item2.nextSibling).toBe(lineNodeForScreenRow(component, 1));\n      expect(item3.previousSibling).toBeNull();\n      expect(item3.nextSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item4.nextSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(item5.previousSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(element.contains(item6)).toBe(false); // invalidate decorations. this also tests a case where two decorations in\n      // the same tile change their height without affecting the tile height nor\n      // the content height.\n\n      item3.style.height = '22px';\n      item3.style.margin = '10px';\n      item2.style.height = '33px';\n      item2.style.margin = '0px';\n      await component.getNextUpdatePromise();\n      expect(component.getRenderedStartRow()).toBe(0);\n      expect(component.getRenderedEndRow()).toBe(9);\n      expect(component.getScrollHeight()).toBeNear(editor.getScreenLineCount() * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3) + getElementHeight(item4) + getElementHeight(item5) + getElementHeight(item6));\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3)\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }]);\n      assertLinesAreAlignedWithLineNumbers(component);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n      expect(element.contains(item1)).toBe(false);\n      expect(item2.previousSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item2.nextSibling).toBe(lineNodeForScreenRow(component, 1));\n      expect(item3.previousSibling).toBeNull();\n      expect(item3.nextSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item4.nextSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(item5.previousSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(element.contains(item6)).toBe(false); // make decoration before row 0 as wide as the editor, and insert some text into it so that it wraps.\n\n      item3.style.height = '';\n      item3.style.margin = '';\n      item3.style.width = '';\n      item3.style.wordWrap = 'break-word';\n      const contentWidthInCharacters = Math.floor(component.getScrollContainerClientWidth() / component.getBaseCharacterWidth());\n      item3.textContent = 'x'.repeat(contentWidthInCharacters * 2);\n      await component.getNextUpdatePromise(); // make the editor wider, so that the decoration doesn't wrap anymore.\n\n      component.element.style.width = component.getGutterContainerWidth() + component.getScrollContainerClientWidth() * 2 + verticalScrollbarWidth + 'px';\n      await component.getNextUpdatePromise();\n      expect(component.getRenderedStartRow()).toBe(0);\n      expect(component.getRenderedEndRow()).toBe(9);\n      expect(component.getScrollHeight()).toBeNear(editor.getScreenLineCount() * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3) + getElementHeight(item4) + getElementHeight(item5) + getElementHeight(item6));\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3)\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }]);\n      assertLinesAreAlignedWithLineNumbers(component);\n      expect(queryOnScreenLineElements(element).length).toBe(9);\n      expect(element.contains(item1)).toBe(false);\n      expect(item2.previousSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item2.nextSibling).toBe(lineNodeForScreenRow(component, 1));\n      expect(item3.previousSibling).toBeNull();\n      expect(item3.nextSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item3.nextSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item4.nextSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(element.contains(item6)).toBe(false); // make the editor taller and wider and the same time, ensuring the number\n      // of rendered lines is correct.\n\n      setEditorHeightInLines(component, 13);\n      setEditorWidthInCharacters(component, 50);\n      await conditionPromise(() => component.getRenderedStartRow() === 0 && component.getRenderedEndRow() === 13);\n      expect(component.getScrollHeight()).toBeNear(editor.getScreenLineCount() * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3) + getElementHeight(item4) + getElementHeight(item5) + getElementHeight(item6));\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + getElementHeight(item2) + getElementHeight(item3)\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight() + getElementHeight(item4) + getElementHeight(item5)\n      }]);\n      assertLinesAreAlignedWithLineNumbers(component);\n      expect(queryOnScreenLineElements(element).length).toBe(13);\n      expect(element.contains(item1)).toBe(false);\n      expect(item2.previousSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item2.nextSibling).toBe(lineNodeForScreenRow(component, 1));\n      expect(item3.previousSibling).toBeNull();\n      expect(item3.nextSibling).toBe(lineNodeForScreenRow(component, 0));\n      expect(item4.previousSibling).toBe(lineNodeForScreenRow(component, 6));\n      expect(item4.nextSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(item5.previousSibling).toBe(lineNodeForScreenRow(component, 7));\n      expect(item5.nextSibling).toBe(lineNodeForScreenRow(component, 8));\n      expect(item6.previousSibling).toBe(lineNodeForScreenRow(component, 12));\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly positions line numbers when block decorations are located at tile boundaries",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 2697,
                "column": 94
            },
            "line": 2697,
            "code": "    it('correctly positions line numbers when block decorations are located at tile boundaries', async () => {\n      const {\n        editor,\n        component\n      } = buildComponent({\n        rowsPerTile: 3\n      });\n      createBlockDecorationAtScreenRow(editor, 0, {\n        height: 5,\n        position: 'before'\n      });\n      createBlockDecorationAtScreenRow(editor, 2, {\n        height: 7,\n        position: 'after'\n      });\n      createBlockDecorationAtScreenRow(editor, 3, {\n        height: 9,\n        position: 'before'\n      });\n      createBlockDecorationAtScreenRow(editor, 3, {\n        height: 11,\n        position: 'after'\n      });\n      createBlockDecorationAtScreenRow(editor, 5, {\n        height: 13,\n        position: 'after'\n      });\n      await component.getNextUpdatePromise();\n      assertLinesAreAlignedWithLineNumbers(component);\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + 5 + 7\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight() + 9 + 11 + 13\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight()\n      }]);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes block decorations whose markers have been destroyed",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 2737,
                "column": 67
            },
            "line": 2737,
            "code": "    it('removes block decorations whose markers have been destroyed', async () => {\n      const {\n        editor,\n        component\n      } = buildComponent({\n        rowsPerTile: 3\n      });\n      const {\n        marker\n      } = createBlockDecorationAtScreenRow(editor, 2, {\n        height: 5,\n        position: 'before'\n      });\n      await component.getNextUpdatePromise();\n      assertLinesAreAlignedWithLineNumbers(component);\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + 5\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight()\n      }]);\n      marker.destroy();\n      await component.getNextUpdatePromise();\n      assertLinesAreAlignedWithLineNumbers(component);\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight()\n      }]);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes block decorations whose markers are invalidated, and adds them back when they become valid again",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 2776,
                "column": 112
            },
            "line": 2776,
            "code": "    it('removes block decorations whose markers are invalidated, and adds them back when they become valid again', async () => {\n      const editor = buildEditor({\n        rowsPerTile: 3,\n        autoHeight: false\n      });\n      const {\n        item,\n        decoration,\n        marker\n      } = createBlockDecorationAtScreenRow(editor, 3, {\n        height: 44,\n        position: 'before',\n        invalidate: 'touch'\n      });\n      const {\n        component\n      } = buildComponent({\n        editor,\n        rowsPerTile: 3\n      }); // Invalidating the marker removes the block decoration.\n\n      editor.getBuffer().deleteRows(2, 3);\n      await component.getNextUpdatePromise();\n      expect(item.parentElement).toBeNull();\n      assertLinesAreAlignedWithLineNumbers(component);\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight()\n      }]); // Moving invalid markers is ignored.\n\n      marker.setScreenRange([[2, 0], [2, 0]]);\n      await component.getNextUpdatePromise();\n      expect(item.parentElement).toBeNull();\n      assertLinesAreAlignedWithLineNumbers(component);\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight()\n      }]); // Making the marker valid again adds back the block decoration.\n\n      marker.bufferMarker.valid = true;\n      marker.setScreenRange([[3, 0], [3, 0]]);\n      await component.getNextUpdatePromise();\n      expect(item.nextSibling).toBe(lineNodeForScreenRow(component, 3));\n      assertLinesAreAlignedWithLineNumbers(component);\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight() + 44\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight()\n      }]); // Destroying the decoration and invalidating the marker at the same time\n      // removes the block decoration correctly.\n\n      editor.getBuffer().deleteRows(2, 3);\n      decoration.destroy();\n      await component.getNextUpdatePromise();\n      expect(item.parentElement).toBeNull();\n      assertLinesAreAlignedWithLineNumbers(component);\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight()\n      }]);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not render block decorations when decorating invalid markers",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 2860,
                "column": 73
            },
            "line": 2860,
            "code": "    it('does not render block decorations when decorating invalid markers', async () => {\n      const editor = buildEditor({\n        rowsPerTile: 3,\n        autoHeight: false\n      });\n      const {\n        component\n      } = buildComponent({\n        editor,\n        rowsPerTile: 3\n      });\n      const marker = editor.markScreenPosition([3, 0], {\n        invalidate: 'touch'\n      });\n      const item = document.createElement('div');\n      item.style.height = 30 + 'px';\n      item.style.width = 30 + 'px';\n      editor.getBuffer().deleteRows(1, 4);\n      editor.decorateMarker(marker, {\n        type: 'block',\n        item,\n        position: 'before'\n      });\n      await component.getNextUpdatePromise();\n      expect(item.parentElement).toBeNull();\n      assertLinesAreAlignedWithLineNumbers(component);\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight()\n      }]); // Making the marker valid again causes the corresponding block decoration\n      // to be added to the editor.\n\n      marker.bufferMarker.valid = true;\n      marker.setScreenRange([[2, 0], [2, 0]]);\n      await component.getNextUpdatePromise();\n      expect(item.nextSibling).toBe(lineNodeForScreenRow(component, 2));\n      assertLinesAreAlignedWithLineNumbers(component);\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight() + 30\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight()\n      }]);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not try to remeasure block decorations whose markers are invalid (regression)",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 2914,
                "column": 90
            },
            "line": 2914,
            "code": "    it('does not try to remeasure block decorations whose markers are invalid (regression)', async () => {\n      const editor = buildEditor({\n        rowsPerTile: 3,\n        autoHeight: false\n      });\n      const {\n        component\n      } = buildComponent({\n        editor,\n        rowsPerTile: 3\n      });\n      createBlockDecorationAtScreenRow(editor, 2, {\n        height: '12px',\n        invalidate: 'touch'\n      });\n      editor.getBuffer().deleteRows(0, 3);\n      await component.getNextUpdatePromise(); // Trigger a re-measurement of all block decorations.\n\n      await setEditorWidthInCharacters(component, 20);\n      assertLinesAreAlignedWithLineNumbers(component);\n      assertTilesAreSizedAndPositionedCorrectly(component, [{\n        tileStartRow: 0,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 3,\n        height: 3 * component.getLineHeight()\n      }, {\n        tileStartRow: 6,\n        height: 3 * component.getLineHeight()\n      }]);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw exceptions when destroying a block decoration inside a marker change event (regression)",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 2945,
                "column": 110
            },
            "line": 2945,
            "code": "    it('does not throw exceptions when destroying a block decoration inside a marker change event (regression)', async () => {\n      const {\n        editor,\n        component\n      } = buildComponent({\n        rowsPerTile: 3\n      });\n      const marker = editor.markScreenPosition([2, 0]);\n      marker.onDidChange(() => {\n        marker.destroy();\n      });\n      const item = document.createElement('div');\n      editor.decorateMarker(marker, {\n        type: 'block',\n        item\n      });\n      await component.getNextUpdatePromise();\n      expect(item.nextSibling).toBe(lineNodeForScreenRow(component, 2));\n      marker.setBufferRange([[0, 0], [0, 0]]);\n      expect(marker.isDestroyed()).toBe(true);\n      await component.getNextUpdatePromise();\n      expect(item.parentElement).toBeNull();\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not attempt to render block decorations located outside the visible range",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 2968,
                "column": 86
            },
            "line": 2968,
            "code": "    it('does not attempt to render block decorations located outside the visible range', async () => {\n      const {\n        editor,\n        component\n      } = buildComponent({\n        autoHeight: false,\n        rowsPerTile: 2\n      });\n      await setEditorHeightInLines(component, 2);\n      expect(component.getRenderedStartRow()).toBe(0);\n      expect(component.getRenderedEndRow()).toBe(4);\n      const marker1 = editor.markScreenRange([[3, 0], [5, 0]], {\n        reversed: false\n      });\n      const item1 = document.createElement('div');\n      editor.decorateMarker(marker1, {\n        type: 'block',\n        item: item1\n      });\n      const marker2 = editor.markScreenRange([[3, 0], [5, 0]], {\n        reversed: true\n      });\n      const item2 = document.createElement('div');\n      editor.decorateMarker(marker2, {\n        type: 'block',\n        item: item2\n      });\n      await component.getNextUpdatePromise();\n      expect(item1.parentElement).toBeNull();\n      expect(item2.nextSibling).toBe(lineNodeForScreenRow(component, 3));\n      await setScrollTop(component, 4 * component.getLineHeight());\n      expect(component.getRenderedStartRow()).toBe(4);\n      expect(component.getRenderedEndRow()).toBe(8);\n      expect(item1.nextSibling).toBe(lineNodeForScreenRow(component, 5));\n      expect(item2.parentElement).toBeNull();\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "measures block decorations correctly when they are added before the component width has been updated",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 3004,
                "column": 108
            },
            "line": 3004,
            "code": "    it('measures block decorations correctly when they are added before the component width has been updated', async () => {\n      {\n        const {\n          editor,\n          component,\n          element\n        } = buildComponent({\n          autoHeight: false,\n          width: 500,\n          attach: false\n        });\n        const marker = editor.markScreenPosition([0, 0]);\n        const item = document.createElement('div');\n        item.textContent = 'block decoration';\n        editor.decorateMarker(marker, {\n          type: 'block',\n          item\n        });\n        jasmine.attachToDOM(element);\n        assertLinesAreAlignedWithLineNumbers(component);\n      }\n      {\n        const {\n          editor,\n          component,\n          element\n        } = buildComponent({\n          autoHeight: false,\n          width: 800\n        });\n        const marker = editor.markScreenPosition([0, 0]);\n        const item = document.createElement('div');\n        item.textContent = 'block decoration that could wrap many times';\n        editor.decorateMarker(marker, {\n          type: 'block',\n          item\n        });\n        element.style.width = '50px';\n        await component.getNextUpdatePromise();\n        assertLinesAreAlignedWithLineNumbers(component);\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "bases the width of the block decoration measurement area on the editor scroll width",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 3046,
                "column": 91
            },
            "line": 3046,
            "code": "    it('bases the width of the block decoration measurement area on the editor scroll width', async () => {\n      const {\n        component,\n        element\n      } = buildComponent({\n        autoHeight: false,\n        width: 150\n      });\n      expect(component.refs.blockDecorationMeasurementArea.offsetWidth).toBe(component.getScrollWidth());\n      element.style.width = '800px';\n      await component.getNextUpdatePromise();\n      expect(component.refs.blockDecorationMeasurementArea.offsetWidth).toBe(component.getScrollWidth());\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not change the cursor position when clicking on a block decoration",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 3059,
                "column": 79
            },
            "line": 3059,
            "code": "    it('does not change the cursor position when clicking on a block decoration', async () => {\n      const {\n        editor,\n        component\n      } = buildComponent();\n      const decorationElement = document.createElement('div');\n      decorationElement.textContent = 'Parent';\n      const childElement = document.createElement('div');\n      childElement.textContent = 'Child';\n      decorationElement.appendChild(childElement);\n      const marker = editor.markScreenPosition([4, 0]);\n      editor.decorateMarker(marker, {\n        type: 'block',\n        item: decorationElement\n      });\n      await component.getNextUpdatePromise();\n      const decorationElementClientRect = decorationElement.getBoundingClientRect();\n      component.didMouseDownOnContent({\n        target: decorationElement,\n        detail: 1,\n        button: 0,\n        clientX: decorationElementClientRect.left,\n        clientY: decorationElementClientRect.top\n      });\n      expect(editor.getCursorScreenPosition()).toEqual([0, 0]);\n      const childElementClientRect = childElement.getBoundingClientRect();\n      component.didMouseDownOnContent({\n        target: childElement,\n        detail: 1,\n        button: 0,\n        clientX: childElementClientRect.left,\n        clientY: childElementClientRect.top\n      });\n      expect(editor.getCursorScreenPosition()).toEqual([0, 0]);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the order property to control the order of block decorations at the same screen row",
            "suites": [
                "TextEditorComponent",
                "block decorations"
            ],
            "updatePoint": {
                "line": 3094,
                "column": 96
            },
            "line": 3094,
            "code": "    it('uses the order property to control the order of block decorations at the same screen row', async () => {\n      const editor = buildEditor({\n        autoHeight: false\n      });\n      const {\n        component,\n        element\n      } = buildComponent({\n        editor\n      });\n      element.style.height = 10 * component.getLineHeight() + horizontalScrollbarHeight + 'px';\n      await component.getNextUpdatePromise(); // Order parameters that differ from creation order; that collide; and that are not provided.\n\n      const [beforeItems, beforeDecorations] = [30, 20, undefined, 20, 10, undefined].map(order => {\n        return createBlockDecorationAtScreenRow(editor, 2, {\n          height: 10,\n          position: 'before',\n          order\n        });\n      }).reduce((lists, result) => {\n        lists[0].push(result.item);\n        lists[1].push(result.decoration);\n        return lists;\n      }, [[], []]);\n      const [afterItems] = [undefined, 1, 6, undefined, 6, 2].map(order => {\n        return createBlockDecorationAtScreenRow(editor, 2, {\n          height: 10,\n          position: 'after',\n          order\n        });\n      }).reduce((lists, result) => {\n        lists[0].push(result.item);\n        lists[1].push(result.decoration);\n        return lists;\n      }, [[], []]);\n      await component.getNextUpdatePromise();\n      expect(beforeItems[4].previousSibling).toBe(lineNodeForScreenRow(component, 1));\n      expect(beforeItems[4].nextSibling).toBe(beforeItems[1]);\n      expect(beforeItems[1].nextSibling).toBe(beforeItems[3]);\n      expect(beforeItems[3].nextSibling).toBe(beforeItems[0]);\n      expect(beforeItems[0].nextSibling).toBe(beforeItems[2]);\n      expect(beforeItems[2].nextSibling).toBe(beforeItems[5]);\n      expect(beforeItems[5].nextSibling).toBe(lineNodeForScreenRow(component, 2));\n      expect(afterItems[1].previousSibling).toBe(lineNodeForScreenRow(component, 2));\n      expect(afterItems[1].nextSibling).toBe(afterItems[5]);\n      expect(afterItems[5].nextSibling).toBe(afterItems[2]);\n      expect(afterItems[2].nextSibling).toBe(afterItems[4]);\n      expect(afterItems[4].nextSibling).toBe(afterItems[0]);\n      expect(afterItems[0].nextSibling).toBe(afterItems[3]); // Create a decoration somewhere else and move it to the same screen row as the existing decorations\n\n      const {\n        item: later,\n        decoration\n      } = createBlockDecorationAtScreenRow(editor, 4, {\n        height: 20,\n        position: 'after',\n        order: 3\n      });\n      await component.getNextUpdatePromise();\n      expect(later.previousSibling).toBe(lineNodeForScreenRow(component, 4));\n      expect(later.nextSibling).toBe(lineNodeForScreenRow(component, 5));\n      decoration.getMarker().setHeadScreenPosition([2, 0]);\n      await component.getNextUpdatePromise();\n      expect(later.previousSibling).toBe(afterItems[5]);\n      expect(later.nextSibling).toBe(afterItems[2]); // Move a decoration away from its screen row and ensure the rest maintain their order\n\n      beforeDecorations[3].getMarker().setHeadScreenPosition([5, 0]);\n      await component.getNextUpdatePromise();\n      expect(beforeItems[3].previousSibling).toBe(lineNodeForScreenRow(component, 4));\n      expect(beforeItems[3].nextSibling).toBe(lineNodeForScreenRow(component, 5));\n      expect(beforeItems[4].previousSibling).toBe(lineNodeForScreenRow(component, 1));\n      expect(beforeItems[4].nextSibling).toBe(beforeItems[1]);\n      expect(beforeItems[1].nextSibling).toBe(beforeItems[0]);\n      expect(beforeItems[0].nextSibling).toBe(beforeItems[2]);\n      expect(beforeItems[2].nextSibling).toBe(beforeItems[5]);\n      expect(beforeItems[5].nextSibling).toBe(lineNodeForScreenRow(component, 2));\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows default cursors to be customized",
            "suites": [
                "TextEditorComponent",
                "cursor decorations"
            ],
            "updatePoint": {
                "line": 3231,
                "column": 47
            },
            "line": 3231,
            "code": "    it('allows default cursors to be customized', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      editor.addCursorAtScreenPosition([1, 0]);\n      const [cursorMarker1, cursorMarker2] = editor.getCursors().map(c => c.getMarker());\n      editor.decorateMarker(cursorMarker1, {\n        type: 'cursor',\n        class: 'a'\n      });\n      editor.decorateMarker(cursorMarker2, {\n        type: 'cursor',\n        class: 'b',\n        style: {\n          visibility: 'hidden'\n        }\n      });\n      editor.decorateMarker(cursorMarker2, {\n        type: 'cursor',\n        style: {\n          backgroundColor: 'red'\n        }\n      });\n      await component.getNextUpdatePromise();\n      const cursorNodes = element.querySelectorAll('.cursor');\n      expect(cursorNodes.length).toBe(2);\n      expect(cursorNodes[0].className).toBe('cursor a');\n      expect(cursorNodes[1].className).toBe('cursor b');\n      expect(cursorNodes[1].style.visibility).toBe('hidden');\n      expect(cursorNodes[1].style.backgroundColor).toBe('red');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows markers that are not actually associated with cursors to be decorated as if they were cursors",
            "suites": [
                "TextEditorComponent",
                "cursor decorations"
            ],
            "updatePoint": {
                "line": 3264,
                "column": 108
            },
            "line": 3264,
            "code": "    it('allows markers that are not actually associated with cursors to be decorated as if they were cursors', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      const marker = editor.markScreenPosition([1, 0]);\n      editor.decorateMarker(marker, {\n        type: 'cursor',\n        class: 'a'\n      });\n      await component.getNextUpdatePromise();\n      const cursorNodes = element.querySelectorAll('.cursor');\n      expect(cursorNodes.length).toBe(2);\n      expect(cursorNodes[0].className).toBe('cursor');\n      expect(cursorNodes[1].className).toBe('cursor a');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "injects spans with custom class names and inline styles based on text decorations",
            "suites": [
                "TextEditorComponent",
                "text decorations"
            ],
            "updatePoint": {
                "line": 3283,
                "column": 89
            },
            "line": 3283,
            "code": "    it('injects spans with custom class names and inline styles based on text decorations', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 2\n      });\n      const markerLayer = editor.addMarkerLayer();\n      const marker1 = markerLayer.markBufferRange([[0, 2], [2, 7]]);\n      const marker2 = markerLayer.markBufferRange([[0, 2], [3, 8]]);\n      const marker3 = markerLayer.markBufferRange([[1, 13], [2, 7]]);\n      editor.decorateMarker(marker1, {\n        type: 'text',\n        class: 'a',\n        style: {\n          color: 'red'\n        }\n      });\n      editor.decorateMarker(marker2, {\n        type: 'text',\n        class: 'b',\n        style: {\n          color: 'blue'\n        }\n      });\n      editor.decorateMarker(marker3, {\n        type: 'text',\n        class: 'c',\n        style: {\n          color: 'green'\n        }\n      });\n      await component.getNextUpdatePromise();\n      expect(textContentOnRowMatchingSelector(component, 0, '.a')).toBe(editor.lineTextForScreenRow(0).slice(2));\n      expect(textContentOnRowMatchingSelector(component, 1, '.a')).toBe(editor.lineTextForScreenRow(1));\n      expect(textContentOnRowMatchingSelector(component, 2, '.a')).toBe(editor.lineTextForScreenRow(2).slice(0, 7));\n      expect(textContentOnRowMatchingSelector(component, 3, '.a')).toBe('');\n      expect(textContentOnRowMatchingSelector(component, 0, '.b')).toBe(editor.lineTextForScreenRow(0).slice(2));\n      expect(textContentOnRowMatchingSelector(component, 1, '.b')).toBe(editor.lineTextForScreenRow(1));\n      expect(textContentOnRowMatchingSelector(component, 2, '.b')).toBe(editor.lineTextForScreenRow(2));\n      expect(textContentOnRowMatchingSelector(component, 3, '.b')).toBe(editor.lineTextForScreenRow(3).slice(0, 8));\n      expect(textContentOnRowMatchingSelector(component, 0, '.c')).toBe('');\n      expect(textContentOnRowMatchingSelector(component, 1, '.c')).toBe(editor.lineTextForScreenRow(1).slice(13));\n      expect(textContentOnRowMatchingSelector(component, 2, '.c')).toBe(editor.lineTextForScreenRow(2).slice(0, 7));\n      expect(textContentOnRowMatchingSelector(component, 3, '.c')).toBe('');\n\n      for (const span of element.querySelectorAll('.a:not(.c)')) {\n        expect(span.style.color).toBe('red');\n      }\n\n      for (const span of element.querySelectorAll('.b:not(.c):not(.a)')) {\n        expect(span.style.color).toBe('blue');\n      }\n\n      for (const span of element.querySelectorAll('.c')) {\n        expect(span.style.color).toBe('green');\n      }\n\n      marker2.setHeadScreenPosition([3, 10]);\n      await component.getNextUpdatePromise();\n      expect(textContentOnRowMatchingSelector(component, 3, '.b')).toBe(editor.lineTextForScreenRow(3).slice(0, 10));\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly handles text decorations starting before the first rendered row and/or ending after the last rendered row",
            "suites": [
                "TextEditorComponent",
                "text decorations"
            ],
            "updatePoint": {
                "line": 3346,
                "column": 123
            },
            "line": 3346,
            "code": "    it('correctly handles text decorations starting before the first rendered row and/or ending after the last rendered row', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        autoHeight: false,\n        rowsPerTile: 1\n      });\n      element.style.height = 4 * component.getLineHeight() + 'px';\n      await component.getNextUpdatePromise();\n      await setScrollTop(component, 4 * component.getLineHeight());\n      expect(component.getRenderedStartRow()).toBeNear(4);\n      expect(component.getRenderedEndRow()).toBeNear(9);\n      const markerLayer = editor.addMarkerLayer();\n      const marker1 = markerLayer.markBufferRange([[0, 0], [4, 5]]);\n      const marker2 = markerLayer.markBufferRange([[7, 2], [10, 8]]);\n      editor.decorateMarker(marker1, {\n        type: 'text',\n        class: 'a'\n      });\n      editor.decorateMarker(marker2, {\n        type: 'text',\n        class: 'b'\n      });\n      await component.getNextUpdatePromise();\n      expect(textContentOnRowMatchingSelector(component, 4, '.a')).toBe(editor.lineTextForScreenRow(4).slice(0, 5));\n      expect(textContentOnRowMatchingSelector(component, 5, '.a')).toBe('');\n      expect(textContentOnRowMatchingSelector(component, 6, '.a')).toBe('');\n      expect(textContentOnRowMatchingSelector(component, 7, '.a')).toBe('');\n      expect(textContentOnRowMatchingSelector(component, 8, '.a')).toBe('');\n      expect(textContentOnRowMatchingSelector(component, 4, '.b')).toBe('');\n      expect(textContentOnRowMatchingSelector(component, 5, '.b')).toBe('');\n      expect(textContentOnRowMatchingSelector(component, 6, '.b')).toBe('');\n      expect(textContentOnRowMatchingSelector(component, 7, '.b')).toBe(editor.lineTextForScreenRow(7).slice(2));\n      expect(textContentOnRowMatchingSelector(component, 8, '.b')).toBe(editor.lineTextForScreenRow(8));\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not create empty spans when a text decoration contains a row but another text decoration starts or ends at the beginning of it",
            "suites": [
                "TextEditorComponent",
                "text decorations"
            ],
            "updatePoint": {
                "line": 3383,
                "column": 139
            },
            "line": 3383,
            "code": "    it('does not create empty spans when a text decoration contains a row but another text decoration starts or ends at the beginning of it', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent();\n      const markerLayer = editor.addMarkerLayer();\n      const marker1 = markerLayer.markBufferRange([[0, 2], [4, 0]]);\n      const marker2 = markerLayer.markBufferRange([[2, 0], [5, 8]]);\n      editor.decorateMarker(marker1, {\n        type: 'text',\n        class: 'a'\n      });\n      editor.decorateMarker(marker2, {\n        type: 'text',\n        class: 'b'\n      });\n      await component.getNextUpdatePromise();\n\n      for (const decorationSpan of element.querySelectorAll('.a, .b')) {\n        expect(decorationSpan.textContent).not.toBe('');\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not create empty text nodes when a text decoration ends right after a text tag",
            "suites": [
                "TextEditorComponent",
                "text decorations"
            ],
            "updatePoint": {
                "line": 3406,
                "column": 91
            },
            "line": 3406,
            "code": "    it('does not create empty text nodes when a text decoration ends right after a text tag', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      const marker = editor.markBufferRange([[0, 8], [0, 29]]);\n      editor.decorateMarker(marker, {\n        type: 'text',\n        class: 'a'\n      });\n      await component.getNextUpdatePromise();\n\n      for (const textNode of textNodesForScreenRow(component, 0)) {\n        expect(textNode.textContent).not.toBe('');\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "positions the cursor on single-click or when middle-clicking",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when there is only one cursor"
            ],
            "updatePoint": {
                "line": 3430,
                "column": 72
            },
            "line": 3430,
            "code": "        it('positions the cursor on single-click or when middle-clicking', async () => {\n          atom.config.set('editor.selectionClipboard', true);\n\n          for (const button of [0, 1]) {\n            const {\n              component,\n              editor\n            } = buildComponent();\n            const {\n              lineHeight\n            } = component.measurements;\n            editor.setCursorScreenPosition([Infinity, Infinity], {\n              autoscroll: false\n            });\n            component.didMouseDownOnContent({\n              detail: 1,\n              button,\n              clientX: clientLeftForCharacter(component, 0, 0) - 1,\n              clientY: clientTopForLine(component, 0) - 1\n            });\n            expect(editor.getCursorScreenPosition()).toEqual([0, 0]);\n            const maxRow = editor.getLastScreenRow();\n            editor.setCursorScreenPosition([Infinity, Infinity], {\n              autoscroll: false\n            });\n            component.didMouseDownOnContent({\n              detail: 1,\n              button,\n              clientX: clientLeftForCharacter(component, maxRow, editor.lineLengthForScreenRow(maxRow)) + 1,\n              clientY: clientTopForLine(component, maxRow) + 1\n            });\n            expect(editor.getCursorScreenPosition()).toEqual([maxRow, editor.lineLengthForScreenRow(maxRow)]);\n            component.didMouseDownOnContent({\n              detail: 1,\n              button,\n              clientX: clientLeftForCharacter(component, 0, editor.lineLengthForScreenRow(0)) + 1,\n              clientY: clientTopForLine(component, 0) + lineHeight / 2\n            });\n            expect(editor.getCursorScreenPosition()).toEqual([0, editor.lineLengthForScreenRow(0)]);\n            component.didMouseDownOnContent({\n              detail: 1,\n              button,\n              clientX: (clientLeftForCharacter(component, 3, 0) + clientLeftForCharacter(component, 3, 1)) / 2,\n              clientY: clientTopForLine(component, 1) + lineHeight / 2\n            });\n            expect(editor.getCursorScreenPosition()).toEqual([1, 0]);\n            component.didMouseDownOnContent({\n              detail: 1,\n              button,\n              clientX: (clientLeftForCharacter(component, 3, 14) + clientLeftForCharacter(component, 3, 15)) / 2,\n              clientY: clientTopForLine(component, 3) + lineHeight / 2\n            });\n            expect(editor.getCursorScreenPosition()).toEqual([3, 14]);\n            component.didMouseDownOnContent({\n              detail: 1,\n              button,\n              clientX: (clientLeftForCharacter(component, 3, 14) + clientLeftForCharacter(component, 3, 15)) / 2 + 1,\n              clientY: clientTopForLine(component, 3) + lineHeight / 2\n            });\n            expect(editor.getCursorScreenPosition()).toEqual([3, 15]);\n            editor.getBuffer().setTextInRange([[3, 14], [3, 15]], '🐣');\n            await component.getNextUpdatePromise();\n            component.didMouseDownOnContent({\n              detail: 1,\n              button,\n              clientX: (clientLeftForCharacter(component, 3, 14) + clientLeftForCharacter(component, 3, 16)) / 2,\n              clientY: clientTopForLine(component, 3) + lineHeight / 2\n            });\n            expect(editor.getCursorScreenPosition()).toEqual([3, 14]);\n            component.didMouseDownOnContent({\n              detail: 1,\n              button,\n              clientX: (clientLeftForCharacter(component, 3, 14) + clientLeftForCharacter(component, 3, 16)) / 2 + 1,\n              clientY: clientTopForLine(component, 3) + lineHeight / 2\n            });\n            expect(editor.getCursorScreenPosition()).toEqual([3, 16]);\n            expect(editor.testAutoscrollRequests).toEqual([]);\n          }\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects words on double-click",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3511,
                "column": 41
            },
            "line": 3511,
            "code": "        it('selects words on double-click', () => {\n          const {\n            component,\n            editor\n          } = buildComponent();\n          const {\n            clientX,\n            clientY\n          } = clientPositionForCharacter(component, 1, 16);\n          component.didMouseDownOnContent({\n            detail: 1,\n            button: 0,\n            clientX,\n            clientY\n          });\n          component.didMouseDownOnContent({\n            detail: 2,\n            button: 0,\n            clientX,\n            clientY\n          });\n          expect(editor.getSelectedScreenRange()).toEqual([[1, 13], [1, 21]]);\n          expect(editor.testAutoscrollRequests).toEqual([]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects lines on triple-click",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3535,
                "column": 41
            },
            "line": 3535,
            "code": "        it('selects lines on triple-click', () => {\n          const {\n            component,\n            editor\n          } = buildComponent();\n          const {\n            clientX,\n            clientY\n          } = clientPositionForCharacter(component, 1, 16);\n          component.didMouseDownOnContent({\n            detail: 1,\n            button: 0,\n            clientX,\n            clientY\n          });\n          component.didMouseDownOnContent({\n            detail: 2,\n            button: 0,\n            clientX,\n            clientY\n          });\n          component.didMouseDownOnContent({\n            detail: 3,\n            button: 0,\n            clientX,\n            clientY\n          });\n          expect(editor.getSelectedScreenRange()).toEqual([[1, 0], [2, 0]]);\n          expect(editor.testAutoscrollRequests).toEqual([]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds or removes cursors when holding cmd or ctrl when single-clicking",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3565,
                "column": 81
            },
            "line": 3565,
            "code": "        it('adds or removes cursors when holding cmd or ctrl when single-clicking', () => {\n          atom.config.set('editor.multiCursorOnClick', true);\n          const {\n            component,\n            editor\n          } = buildComponent({\n            platform: 'darwin'\n          });\n          expect(editor.getCursorScreenPositions()).toEqual([[0, 0]]); // add cursor at 1, 16\n\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 1, 16), {\n            detail: 1,\n            button: 0,\n            metaKey: true\n          }));\n          expect(editor.getCursorScreenPositions()).toEqual([[0, 0], [1, 16]]); // remove cursor at 0, 0\n\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 0, 0), {\n            detail: 1,\n            button: 0,\n            metaKey: true\n          }));\n          expect(editor.getCursorScreenPositions()).toEqual([[1, 16]]); // cmd-click cursor at 1, 16 but don't remove it because it's the last one\n\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 1, 16), {\n            detail: 1,\n            button: 0,\n            metaKey: true\n          }));\n          expect(editor.getCursorScreenPositions()).toEqual([[1, 16]]); // cmd-clicking within a selection destroys it\n\n          editor.addSelectionForScreenRange([[2, 10], [2, 15]], {\n            autoscroll: false\n          });\n          expect(editor.getSelectedScreenRanges()).toEqual([[[1, 16], [1, 16]], [[2, 10], [2, 15]]]);\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 2, 13), {\n            detail: 1,\n            button: 0,\n            metaKey: true\n          }));\n          expect(editor.getSelectedScreenRanges()).toEqual([[[1, 16], [1, 16]]]); // ctrl-click does not add cursors on macOS, nor does it move the cursor\n\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 1, 4), {\n            detail: 1,\n            button: 0,\n            ctrlKey: true\n          }));\n          expect(editor.getSelectedScreenRanges()).toEqual([[[1, 16], [1, 16]]]); // ctrl-click adds cursors on platforms *other* than macOS\n\n          component.props.platform = 'win32';\n          editor.setCursorScreenPosition([1, 4], {\n            autoscroll: false\n          });\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 1, 16), {\n            detail: 1,\n            button: 0,\n            ctrlKey: true\n          }));\n          expect(editor.getCursorScreenPositions()).toEqual([[1, 4], [1, 16]]);\n          expect(editor.testAutoscrollRequests).toEqual([]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds word selections when holding cmd or ctrl when double-clicking",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3626,
                "column": 78
            },
            "line": 3626,
            "code": "        it('adds word selections when holding cmd or ctrl when double-clicking', () => {\n          atom.config.set('editor.multiCursorOnClick', true);\n          const {\n            component,\n            editor\n          } = buildComponent();\n          editor.addCursorAtScreenPosition([1, 16], {\n            autoscroll: false\n          });\n          expect(editor.getCursorScreenPositions()).toEqual([[0, 0], [1, 16]]);\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 1, 16), {\n            detail: 1,\n            button: 0,\n            metaKey: true\n          }));\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 1, 16), {\n            detail: 2,\n            button: 0,\n            metaKey: true\n          }));\n          expect(editor.getSelectedScreenRanges()).toEqual([[[0, 0], [0, 0]], [[1, 13], [1, 21]]]);\n          expect(editor.testAutoscrollRequests).toEqual([]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds line selections when holding cmd or ctrl when triple-clicking",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3649,
                "column": 78
            },
            "line": 3649,
            "code": "        it('adds line selections when holding cmd or ctrl when triple-clicking', () => {\n          atom.config.set('editor.multiCursorOnClick', true);\n          const {\n            component,\n            editor\n          } = buildComponent();\n          editor.addCursorAtScreenPosition([1, 16], {\n            autoscroll: false\n          });\n          expect(editor.getCursorScreenPositions()).toEqual([[0, 0], [1, 16]]);\n          const {\n            clientX,\n            clientY\n          } = clientPositionForCharacter(component, 1, 16);\n          component.didMouseDownOnContent({\n            detail: 1,\n            button: 0,\n            metaKey: true,\n            clientX,\n            clientY\n          });\n          component.didMouseDownOnContent({\n            detail: 2,\n            button: 0,\n            metaKey: true,\n            clientX,\n            clientY\n          });\n          component.didMouseDownOnContent({\n            detail: 3,\n            button: 0,\n            metaKey: true,\n            clientX,\n            clientY\n          });\n          expect(editor.getSelectedScreenRanges()).toEqual([[[0, 0], [0, 0]], [[1, 0], [2, 0]]]);\n          expect(editor.testAutoscrollRequests).toEqual([]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not add cursors when holding cmd or ctrl when single-clicking",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3687,
                "column": 78
            },
            "line": 3687,
            "code": "        it('does not add cursors when holding cmd or ctrl when single-clicking', () => {\n          atom.config.set('editor.multiCursorOnClick', false);\n          const {\n            component,\n            editor\n          } = buildComponent({\n            platform: 'darwin'\n          });\n          expect(editor.getCursorScreenPositions()).toEqual([[0, 0]]); // moves cursor to 1, 16\n\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 1, 16), {\n            detail: 1,\n            button: 0,\n            metaKey: true\n          }));\n          expect(editor.getCursorScreenPositions()).toEqual([[1, 16]]); // ctrl-click does not add cursors on macOS, nor does it move the cursor\n\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 1, 4), {\n            detail: 1,\n            button: 0,\n            ctrlKey: true\n          }));\n          expect(editor.getSelectedScreenRanges()).toEqual([[[1, 16], [1, 16]]]); // ctrl-click does not add cursors on platforms *other* than macOS\n\n          component.props.platform = 'win32';\n          editor.setCursorScreenPosition([1, 4], {\n            autoscroll: false\n          });\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 1, 16), {\n            detail: 1,\n            button: 0,\n            ctrlKey: true\n          }));\n          expect(editor.getCursorScreenPositions()).toEqual([[1, 16]]);\n          expect(editor.testAutoscrollRequests).toEqual([]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not add word selections when holding cmd or ctrl when double-clicking",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3723,
                "column": 86
            },
            "line": 3723,
            "code": "        it('does not add word selections when holding cmd or ctrl when double-clicking', () => {\n          atom.config.set('editor.multiCursorOnClick', false);\n          const {\n            component,\n            editor\n          } = buildComponent();\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 1, 16), {\n            detail: 1,\n            button: 0,\n            metaKey: true\n          }));\n          component.didMouseDownOnContent(Object.assign(clientPositionForCharacter(component, 1, 16), {\n            detail: 2,\n            button: 0,\n            metaKey: true\n          }));\n          expect(editor.getSelectedScreenRanges()).toEqual([[[1, 13], [1, 21]]]);\n          expect(editor.testAutoscrollRequests).toEqual([]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not add line selections when holding cmd or ctrl when triple-clicking",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3742,
                "column": 86
            },
            "line": 3742,
            "code": "        it('does not add line selections when holding cmd or ctrl when triple-clicking', () => {\n          atom.config.set('editor.multiCursorOnClick', false);\n          const {\n            component,\n            editor\n          } = buildComponent();\n          const {\n            clientX,\n            clientY\n          } = clientPositionForCharacter(component, 1, 16);\n          component.didMouseDownOnContent({\n            detail: 1,\n            button: 0,\n            metaKey: true,\n            clientX,\n            clientY\n          });\n          component.didMouseDownOnContent({\n            detail: 2,\n            button: 0,\n            metaKey: true,\n            clientX,\n            clientY\n          });\n          component.didMouseDownOnContent({\n            detail: 3,\n            button: 0,\n            metaKey: true,\n            clientX,\n            clientY\n          });\n          expect(editor.getSelectedScreenRanges()).toEqual([[[1, 0], [2, 0]]]);\n          expect(editor.testAutoscrollRequests).toEqual([]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands the last selection on shift-click",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3776,
                "column": 53
            },
            "line": 3776,
            "code": "        it('expands the last selection on shift-click', () => {\n          const {\n            component,\n            editor\n          } = buildComponent();\n          editor.setCursorScreenPosition([2, 18], {\n            autoscroll: false\n          });\n          component.didMouseDownOnContent(Object.assign({\n            detail: 1,\n            button: 0,\n            shiftKey: true\n          }, clientPositionForCharacter(component, 1, 4)));\n          expect(editor.getSelectedScreenRange()).toEqual([[1, 4], [2, 18]]);\n          component.didMouseDownOnContent(Object.assign({\n            detail: 1,\n            button: 0,\n            shiftKey: true\n          }, clientPositionForCharacter(component, 4, 4)));\n          expect(editor.getSelectedScreenRange()).toEqual([[2, 18], [4, 4]]); // reorients word-wise selections to keep the word selected regardless of\n          // where the subsequent shift-click occurs\n\n          editor.setCursorScreenPosition([2, 18], {\n            autoscroll: false\n          });\n          editor.getLastSelection().selectWord({\n            autoscroll: false\n          });\n          component.didMouseDownOnContent(Object.assign({\n            detail: 1,\n            button: 0,\n            shiftKey: true\n          }, clientPositionForCharacter(component, 1, 4)));\n          expect(editor.getSelectedScreenRange()).toEqual([[1, 2], [2, 20]]);\n          component.didMouseDownOnContent(Object.assign({\n            detail: 1,\n            button: 0,\n            shiftKey: true\n          }, clientPositionForCharacter(component, 3, 11)));\n          expect(editor.getSelectedScreenRange()).toEqual([[2, 14], [3, 13]]); // reorients line-wise selections to keep the line selected regardless of\n          // where the subsequent shift-click occurs\n\n          editor.setCursorScreenPosition([2, 18], {\n            autoscroll: false\n          });\n          editor.getLastSelection().selectLine(null, {\n            autoscroll: false\n          });\n          component.didMouseDownOnContent(Object.assign({\n            detail: 1,\n            button: 0,\n            shiftKey: true\n          }, clientPositionForCharacter(component, 1, 4)));\n          expect(editor.getSelectedScreenRange()).toEqual([[1, 0], [3, 0]]);\n          component.didMouseDownOnContent(Object.assign({\n            detail: 1,\n            button: 0,\n            shiftKey: true\n          }, clientPositionForCharacter(component, 3, 11)));\n          expect(editor.getSelectedScreenRange()).toEqual([[2, 0], [4, 0]]);\n          expect(editor.testAutoscrollRequests).toEqual([]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands the last selection on drag",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3838,
                "column": 46
            },
            "line": 3838,
            "code": "        it('expands the last selection on drag', () => {\n          atom.config.set('editor.multiCursorOnClick', true);\n          const {\n            component,\n            editor\n          } = buildComponent();\n          spyOn(component, 'handleMouseDragUntilMouseUp');\n          component.didMouseDownOnContent(Object.assign({\n            detail: 1,\n            button: 0\n          }, clientPositionForCharacter(component, 1, 4)));\n          {\n            const {\n              didDrag,\n              didStopDragging\n            } = component.handleMouseDragUntilMouseUp.argsForCall[0][0];\n            didDrag(clientPositionForCharacter(component, 8, 8));\n            expect(editor.getSelectedScreenRange()).toEqual([[1, 4], [8, 8]]);\n            didDrag(clientPositionForCharacter(component, 4, 8));\n            expect(editor.getSelectedScreenRange()).toEqual([[1, 4], [4, 8]]);\n            didStopDragging();\n            expect(editor.getSelectedScreenRange()).toEqual([[1, 4], [4, 8]]);\n          } // Click-drag a second selection... selections are not merged until the\n          // drag stops.\n\n          component.didMouseDownOnContent(Object.assign({\n            detail: 1,\n            button: 0,\n            metaKey: 1\n          }, clientPositionForCharacter(component, 8, 8)));\n          {\n            const {\n              didDrag,\n              didStopDragging\n            } = component.handleMouseDragUntilMouseUp.argsForCall[1][0];\n            didDrag(clientPositionForCharacter(component, 2, 8));\n            expect(editor.getSelectedScreenRanges()).toEqual([[[1, 4], [4, 8]], [[2, 8], [8, 8]]]);\n            didDrag(clientPositionForCharacter(component, 6, 8));\n            expect(editor.getSelectedScreenRanges()).toEqual([[[1, 4], [4, 8]], [[6, 8], [8, 8]]]);\n            didDrag(clientPositionForCharacter(component, 2, 8));\n            expect(editor.getSelectedScreenRanges()).toEqual([[[1, 4], [4, 8]], [[2, 8], [8, 8]]]);\n            didStopDragging();\n            expect(editor.getSelectedScreenRanges()).toEqual([[[1, 4], [8, 8]]]);\n          }\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands the selection word-wise on double-click-drag",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3883,
                "column": 64
            },
            "line": 3883,
            "code": "        it('expands the selection word-wise on double-click-drag', () => {\n          const {\n            component,\n            editor\n          } = buildComponent();\n          spyOn(component, 'handleMouseDragUntilMouseUp');\n          component.didMouseDownOnContent(Object.assign({\n            detail: 1,\n            button: 0\n          }, clientPositionForCharacter(component, 1, 4)));\n          component.didMouseDownOnContent(Object.assign({\n            detail: 2,\n            button: 0\n          }, clientPositionForCharacter(component, 1, 4)));\n          const {\n            didDrag\n          } = component.handleMouseDragUntilMouseUp.argsForCall[1][0];\n          didDrag(clientPositionForCharacter(component, 0, 8));\n          expect(editor.getSelectedScreenRange()).toEqual([[0, 4], [1, 5]]);\n          didDrag(clientPositionForCharacter(component, 2, 10));\n          expect(editor.getSelectedScreenRange()).toEqual([[1, 2], [2, 13]]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands the selection line-wise on triple-click-drag",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3905,
                "column": 64
            },
            "line": 3905,
            "code": "        it('expands the selection line-wise on triple-click-drag', () => {\n          const {\n            component,\n            editor\n          } = buildComponent();\n          spyOn(component, 'handleMouseDragUntilMouseUp');\n          const tripleClickPosition = clientPositionForCharacter(component, 2, 8);\n          component.didMouseDownOnContent(Object.assign({\n            detail: 1,\n            button: 0\n          }, tripleClickPosition));\n          component.didMouseDownOnContent(Object.assign({\n            detail: 2,\n            button: 0\n          }, tripleClickPosition));\n          component.didMouseDownOnContent(Object.assign({\n            detail: 3,\n            button: 0\n          }, tripleClickPosition));\n          const {\n            didDrag\n          } = component.handleMouseDragUntilMouseUp.argsForCall[2][0];\n          didDrag(clientPositionForCharacter(component, 1, 8));\n          expect(editor.getSelectedScreenRange()).toEqual([[1, 0], [3, 0]]);\n          didDrag(clientPositionForCharacter(component, 4, 10));\n          expect(editor.getSelectedScreenRange()).toEqual([[2, 0], [5, 0]]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys folds when clicking on their fold markers",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3932,
                "column": 62
            },
            "line": 3932,
            "code": "        it('destroys folds when clicking on their fold markers', async () => {\n          const {\n            component,\n            element,\n            editor\n          } = buildComponent();\n          editor.foldBufferRow(1);\n          await component.getNextUpdatePromise();\n          const target = element.querySelector('.fold-marker');\n          const {\n            clientX,\n            clientY\n          } = clientPositionForCharacter(component, 1, editor.lineLengthForScreenRow(1));\n          component.didMouseDownOnContent({\n            detail: 1,\n            button: 0,\n            target,\n            clientX,\n            clientY\n          });\n          expect(editor.isFoldedAtBufferRow(1)).toBe(false);\n          expect(editor.getCursorScreenPosition()).toEqual([0, 0]);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "autoscrolls the content when dragging near the edge of the scroll container",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 3955,
                "column": 87
            },
            "line": 3955,
            "code": "        it('autoscrolls the content when dragging near the edge of the scroll container', async () => {\n          const {\n            component\n          } = buildComponent({\n            width: 200,\n            height: 200\n          });\n          spyOn(component, 'handleMouseDragUntilMouseUp');\n          let previousScrollTop = 0;\n          let previousScrollLeft = 0;\n\n          function assertScrolledDownAndRight() {\n            expect(component.getScrollTop()).toBeGreaterThan(previousScrollTop);\n            previousScrollTop = component.getScrollTop();\n            expect(component.getScrollLeft()).toBeGreaterThan(previousScrollLeft);\n            previousScrollLeft = component.getScrollLeft();\n          }\n\n          function assertScrolledUpAndLeft() {\n            expect(component.getScrollTop()).toBeLessThan(previousScrollTop);\n            previousScrollTop = component.getScrollTop();\n            expect(component.getScrollLeft()).toBeLessThan(previousScrollLeft);\n            previousScrollLeft = component.getScrollLeft();\n          }\n\n          component.didMouseDownOnContent({\n            detail: 1,\n            button: 0,\n            clientX: 100,\n            clientY: 100\n          });\n          const {\n            didDrag\n          } = component.handleMouseDragUntilMouseUp.argsForCall[0][0];\n          didDrag({\n            clientX: 199,\n            clientY: 199\n          });\n          assertScrolledDownAndRight();\n          didDrag({\n            clientX: 199,\n            clientY: 199\n          });\n          assertScrolledDownAndRight();\n          didDrag({\n            clientX: 199,\n            clientY: 199\n          });\n          assertScrolledDownAndRight();\n          didDrag({\n            clientX: component.getGutterContainerWidth() + 1,\n            clientY: 1\n          });\n          assertScrolledUpAndLeft();\n          didDrag({\n            clientX: component.getGutterContainerWidth() + 1,\n            clientY: 1\n          });\n          assertScrolledUpAndLeft();\n          didDrag({\n            clientX: component.getGutterContainerWidth() + 1,\n            clientY: 1\n          });\n          assertScrolledUpAndLeft(); // Don't artificially update scroll position beyond possible values\n\n          expect(component.getScrollTop()).toBe(0);\n          expect(component.getScrollLeft()).toBe(0);\n          didDrag({\n            clientX: component.getGutterContainerWidth() + 1,\n            clientY: 1\n          });\n          expect(component.getScrollTop()).toBe(0);\n          expect(component.getScrollLeft()).toBe(0);\n          const maxScrollTop = component.getMaxScrollTop();\n          const maxScrollLeft = component.getMaxScrollLeft();\n          setScrollTop(component, maxScrollTop);\n          await setScrollLeft(component, maxScrollLeft);\n          didDrag({\n            clientX: 199,\n            clientY: 199\n          });\n          didDrag({\n            clientX: 199,\n            clientY: 199\n          });\n          didDrag({\n            clientX: 199,\n            clientY: 199\n          });\n          expect(component.getScrollTop()).toBeNear(maxScrollTop);\n          expect(component.getScrollLeft()).toBeNear(maxScrollLeft);\n        });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "pastes the previously selected text when clicking the middle mouse button on Linux",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 4048,
                "column": 92
            },
            "line": 4048,
            "code": "      it('pastes the previously selected text when clicking the middle mouse button on Linux', async () => {\n        spyOn(electron.ipcRenderer, 'send').andCallFake(function (eventName, selectedText) {\n          if (eventName === 'write-text-to-selection-clipboard') {\n            clipboard.writeText(selectedText, 'selection');\n          }\n        });\n        const {\n          component,\n          editor\n        } = buildComponent({\n          platform: 'linux'\n        }); // Middle mouse pasting.\n\n        atom.config.set('editor.selectionClipboard', true);\n        editor.setSelectedBufferRange([[1, 6], [1, 10]]);\n        await conditionPromise(() => TextEditor.clipboard.read() === 'sort');\n        component.didMouseDownOnContent({\n          button: 1,\n          clientX: clientLeftForCharacter(component, 10, 0),\n          clientY: clientTopForLine(component, 10)\n        });\n        expect(TextEditor.clipboard.read()).toBe('sort');\n        expect(editor.lineTextForBufferRow(10)).toBe('sort');\n        editor.undo(); // Doesn't paste when middle mouse button is clicked\n\n        atom.config.set('editor.selectionClipboard', false);\n        editor.setSelectedBufferRange([[1, 6], [1, 10]]);\n        component.didMouseDownOnContent({\n          button: 1,\n          clientX: clientLeftForCharacter(component, 10, 0),\n          clientY: clientTopForLine(component, 10)\n        });\n        expect(TextEditor.clipboard.read()).toBe('sort');\n        expect(editor.lineTextForBufferRow(10)).toBe(''); // Ensure left clicks don't interfere.\n\n        atom.config.set('editor.selectionClipboard', true);\n        editor.setSelectedBufferRange([[1, 2], [1, 5]]);\n        await conditionPromise(() => TextEditor.clipboard.read() === 'var');\n        component.didMouseDownOnContent({\n          button: 0,\n          detail: 1,\n          clientX: clientLeftForCharacter(component, 10, 0),\n          clientY: clientTopForLine(component, 10)\n        });\n        component.didMouseDownOnContent({\n          button: 1,\n          clientX: clientLeftForCharacter(component, 10, 0),\n          clientY: clientTopForLine(component, 10)\n        });\n        expect(editor.lineTextForBufferRow(10)).toBe('var');\n      });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not paste into a read only editor when clicking the middle mouse button on Linux",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the lines",
                "when the input is for the primary mouse button"
            ],
            "updatePoint": {
                "line": 4099,
                "column": 95
            },
            "line": 4099,
            "code": "      it('does not paste into a read only editor when clicking the middle mouse button on Linux', async () => {\n        spyOn(electron.ipcRenderer, 'send').andCallFake(function (eventName, selectedText) {\n          if (eventName === 'write-text-to-selection-clipboard') {\n            clipboard.writeText(selectedText, 'selection');\n          }\n        });\n        const {\n          component,\n          editor\n        } = buildComponent({\n          platform: 'linux',\n          readOnly: true\n        }); // Select the word 'sort' on line 2 and copy to clipboard\n\n        editor.setSelectedBufferRange([[1, 6], [1, 10]]);\n        await conditionPromise(() => TextEditor.clipboard.read() === 'sort'); // Middle-click in the buffer at line 11, column 1\n\n        component.didMouseDownOnContent({\n          button: 1,\n          clientX: clientLeftForCharacter(component, 10, 0),\n          clientY: clientTopForLine(component, 10)\n        }); // Ensure that the correct text was copied but not pasted\n\n        expect(TextEditor.clipboard.read()).toBe('sort');\n        expect(editor.lineTextForBufferRow(10)).toBe('');\n      });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects all buffer rows intersecting the clicked screen row when a line number is clicked",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the line number gutter"
            ],
            "updatePoint": {
                "line": 4127,
                "column": 99
            },
            "line": 4127,
            "code": "      it('selects all buffer rows intersecting the clicked screen row when a line number is clicked', async () => {\n        const {\n          component,\n          editor\n        } = buildComponent();\n        spyOn(component, 'handleMouseDragUntilMouseUp');\n        editor.setSoftWrapped(true);\n        await component.getNextUpdatePromise();\n        await setEditorWidthInCharacters(component, 50);\n        editor.foldBufferRange([[4, Infinity], [7, Infinity]]);\n        await component.getNextUpdatePromise(); // Selects entire buffer line when clicked screen line is soft-wrapped\n\n        component.didMouseDownOnLineNumberGutter({\n          button: 0,\n          clientY: clientTopForLine(component, 3)\n        });\n        expect(editor.getSelectedScreenRange()).toEqual([[3, 0], [5, 0]]);\n        expect(editor.getSelectedBufferRange()).toEqual([[3, 0], [4, 0]]); // Selects entire screen line, even if folds cause that selection to\n        // span multiple buffer lines\n\n        component.didMouseDownOnLineNumberGutter({\n          button: 0,\n          clientY: clientTopForLine(component, 5)\n        });\n        expect(editor.getSelectedScreenRange()).toEqual([[5, 0], [6, 0]]);\n        expect(editor.getSelectedBufferRange()).toEqual([[4, 0], [8, 0]]);\n      });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds new selections when a line number is meta-clicked",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the line number gutter"
            ],
            "updatePoint": {
                "line": 4154,
                "column": 64
            },
            "line": 4154,
            "code": "      it('adds new selections when a line number is meta-clicked', async () => {\n        const {\n          component,\n          editor\n        } = buildComponent();\n        editor.setSoftWrapped(true);\n        await component.getNextUpdatePromise();\n        await setEditorWidthInCharacters(component, 50);\n        editor.foldBufferRange([[4, Infinity], [7, Infinity]]);\n        await component.getNextUpdatePromise(); // Selects entire buffer line when clicked screen line is soft-wrapped\n\n        component.didMouseDownOnLineNumberGutter({\n          button: 0,\n          metaKey: true,\n          clientY: clientTopForLine(component, 3)\n        });\n        expect(editor.getSelectedScreenRanges()).toEqual([[[0, 0], [0, 0]], [[3, 0], [5, 0]]]);\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [0, 0]], [[3, 0], [4, 0]]]); // Selects entire screen line, even if folds cause that selection to\n        // span multiple buffer lines\n\n        component.didMouseDownOnLineNumberGutter({\n          button: 0,\n          metaKey: true,\n          clientY: clientTopForLine(component, 5)\n        });\n        expect(editor.getSelectedScreenRanges()).toEqual([[[0, 0], [0, 0]], [[3, 0], [5, 0]], [[5, 0], [6, 0]]]);\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [0, 0]], [[3, 0], [4, 0]], [[4, 0], [8, 0]]]);\n      });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands the last selection when a line number is shift-clicked",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the line number gutter"
            ],
            "updatePoint": {
                "line": 4182,
                "column": 72
            },
            "line": 4182,
            "code": "      it('expands the last selection when a line number is shift-clicked', async () => {\n        const {\n          component,\n          editor\n        } = buildComponent();\n        spyOn(component, 'handleMouseDragUntilMouseUp');\n        editor.setSoftWrapped(true);\n        await component.getNextUpdatePromise();\n        await setEditorWidthInCharacters(component, 50);\n        editor.foldBufferRange([[4, Infinity], [7, Infinity]]);\n        await component.getNextUpdatePromise();\n        editor.setSelectedScreenRange([[3, 4], [3, 8]]);\n        editor.addCursorAtScreenPosition([2, 10]);\n        component.didMouseDownOnLineNumberGutter({\n          button: 0,\n          shiftKey: true,\n          clientY: clientTopForLine(component, 5)\n        });\n        expect(editor.getSelectedBufferRanges()).toEqual([[[3, 4], [3, 8]], [[2, 10], [8, 0]]]); // Original selection is preserved when shift-click-dragging\n\n        const {\n          didDrag,\n          didStopDragging\n        } = component.handleMouseDragUntilMouseUp.argsForCall[0][0];\n        didDrag({\n          clientY: clientTopForLine(component, 1)\n        });\n        expect(editor.getSelectedBufferRanges()).toEqual([[[3, 4], [3, 8]], [[1, 0], [2, 10]]]);\n        didDrag({\n          clientY: clientTopForLine(component, 5)\n        });\n        didStopDragging();\n        expect(editor.getSelectedBufferRanges()).toEqual([[[2, 10], [8, 0]]]);\n      });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands the selection when dragging",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the line number gutter"
            ],
            "updatePoint": {
                "line": 4216,
                "column": 45
            },
            "line": 4216,
            "code": "      it('expands the selection when dragging', async () => {\n        const {\n          component,\n          editor\n        } = buildComponent();\n        spyOn(component, 'handleMouseDragUntilMouseUp');\n        editor.setSoftWrapped(true);\n        await component.getNextUpdatePromise();\n        await setEditorWidthInCharacters(component, 50);\n        editor.foldBufferRange([[4, Infinity], [7, Infinity]]);\n        await component.getNextUpdatePromise();\n        editor.setSelectedScreenRange([[3, 4], [3, 6]]);\n        component.didMouseDownOnLineNumberGutter({\n          button: 0,\n          metaKey: true,\n          clientY: clientTopForLine(component, 2)\n        });\n        const {\n          didDrag,\n          didStopDragging\n        } = component.handleMouseDragUntilMouseUp.argsForCall[0][0];\n        didDrag({\n          clientY: clientTopForLine(component, 1)\n        });\n        expect(editor.getSelectedScreenRanges()).toEqual([[[3, 4], [3, 6]], [[1, 0], [3, 0]]]);\n        didDrag({\n          clientY: clientTopForLine(component, 5)\n        });\n        expect(editor.getSelectedScreenRanges()).toEqual([[[3, 4], [3, 6]], [[2, 0], [6, 0]]]);\n        expect(editor.isFoldedAtBufferRow(4)).toBe(true);\n        didDrag({\n          clientY: clientTopForLine(component, 3)\n        });\n        expect(editor.getSelectedScreenRanges()).toEqual([[[3, 4], [3, 6]], [[2, 0], [4, 4]]]);\n        didStopDragging();\n        expect(editor.getSelectedScreenRanges()).toEqual([[[2, 0], [4, 4]]]);\n      });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "toggles folding when clicking on the right icon of a foldable line number",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the line number gutter"
            ],
            "updatePoint": {
                "line": 4253,
                "column": 83
            },
            "line": 4253,
            "code": "      it('toggles folding when clicking on the right icon of a foldable line number', async () => {\n        const {\n          component,\n          element,\n          editor\n        } = buildComponent();\n        let target = element.querySelectorAll('.line-number')[1].querySelector('.icon-right');\n        expect(editor.isFoldedAtScreenRow(1)).toBe(false);\n        component.didMouseDownOnLineNumberGutter({\n          target,\n          button: 0,\n          clientY: clientTopForLine(component, 1)\n        });\n        expect(editor.isFoldedAtScreenRow(1)).toBe(true);\n        await component.getNextUpdatePromise();\n        component.didMouseDownOnLineNumberGutter({\n          target,\n          button: 0,\n          clientY: clientTopForLine(component, 1)\n        });\n        await component.getNextUpdatePromise();\n        expect(editor.isFoldedAtScreenRow(1)).toBe(false);\n        editor.foldBufferRange([[5, 12], [5, 17]]);\n        await component.getNextUpdatePromise();\n        expect(editor.isFoldedAtScreenRow(5)).toBe(true);\n        target = element.querySelectorAll('.line-number')[4].querySelector('.icon-right');\n        component.didMouseDownOnLineNumberGutter({\n          target,\n          button: 0,\n          clientY: clientTopForLine(component, 4)\n        });\n        expect(editor.isFoldedAtScreenRow(4)).toBe(false);\n      });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "autoscrolls when dragging near the top or bottom of the gutter",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the line number gutter"
            ],
            "updatePoint": {
                "line": 4286,
                "column": 72
            },
            "line": 4286,
            "code": "      it('autoscrolls when dragging near the top or bottom of the gutter', async () => {\n        const {\n          component\n        } = buildComponent({\n          width: 200,\n          height: 200\n        });\n        spyOn(component, 'handleMouseDragUntilMouseUp');\n        let previousScrollTop = 0;\n        let previousScrollLeft = 0;\n\n        function assertScrolledDown() {\n          expect(component.getScrollTop()).toBeGreaterThan(previousScrollTop);\n          previousScrollTop = component.getScrollTop();\n          expect(component.getScrollLeft()).toBe(previousScrollLeft);\n          previousScrollLeft = component.getScrollLeft();\n        }\n\n        function assertScrolledUp() {\n          expect(component.getScrollTop()).toBeLessThan(previousScrollTop);\n          previousScrollTop = component.getScrollTop();\n          expect(component.getScrollLeft()).toBe(previousScrollLeft);\n          previousScrollLeft = component.getScrollLeft();\n        }\n\n        component.didMouseDownOnLineNumberGutter({\n          detail: 1,\n          button: 0,\n          clientX: 0,\n          clientY: 100\n        });\n        const {\n          didDrag\n        } = component.handleMouseDragUntilMouseUp.argsForCall[0][0];\n        didDrag({\n          clientX: 199,\n          clientY: 199\n        });\n        assertScrolledDown();\n        didDrag({\n          clientX: 199,\n          clientY: 199\n        });\n        assertScrolledDown();\n        didDrag({\n          clientX: 199,\n          clientY: 199\n        });\n        assertScrolledDown();\n        didDrag({\n          clientX: component.getGutterContainerWidth() + 1,\n          clientY: 1\n        });\n        assertScrolledUp();\n        didDrag({\n          clientX: component.getGutterContainerWidth() + 1,\n          clientY: 1\n        });\n        assertScrolledUp();\n        didDrag({\n          clientX: component.getGutterContainerWidth() + 1,\n          clientY: 1\n        });\n        assertScrolledUp(); // Don't artificially update scroll measurements beyond the minimum or\n        // maximum possible scroll positions\n\n        expect(component.getScrollTop()).toBe(0);\n        expect(component.getScrollLeft()).toBe(0);\n        didDrag({\n          clientX: component.getGutterContainerWidth() + 1,\n          clientY: 1\n        });\n        expect(component.getScrollTop()).toBe(0);\n        expect(component.getScrollLeft()).toBe(0);\n        const maxScrollTop = component.getMaxScrollTop();\n        const maxScrollLeft = component.getMaxScrollLeft();\n        setScrollTop(component, maxScrollTop);\n        await setScrollLeft(component, maxScrollLeft);\n        didDrag({\n          clientX: 199,\n          clientY: 199\n        });\n        didDrag({\n          clientX: 199,\n          clientY: 199\n        });\n        didDrag({\n          clientX: 199,\n          clientY: 199\n        });\n        expect(component.getScrollTop()).toBeNear(maxScrollTop);\n        expect(component.getScrollLeft()).toBeNear(maxScrollLeft);\n      });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "delegates the mousedown events to the parent component unless the mousedown was on the actual scrollbar",
            "suites": [
                "TextEditorComponent",
                "mouse input",
                "on the scrollbars"
            ],
            "updatePoint": {
                "line": 4381,
                "column": 113
            },
            "line": 4381,
            "code": "      it('delegates the mousedown events to the parent component unless the mousedown was on the actual scrollbar', async () => {\n        const {\n          component,\n          editor\n        } = buildComponent({\n          height: 100\n        });\n        await setEditorWidthInCharacters(component, 6);\n        const verticalScrollbar = component.refs.verticalScrollbar;\n        const horizontalScrollbar = component.refs.horizontalScrollbar;\n        const leftEdgeOfVerticalScrollbar = verticalScrollbar.element.getBoundingClientRect().right - verticalScrollbarWidth;\n        const topEdgeOfHorizontalScrollbar = horizontalScrollbar.element.getBoundingClientRect().bottom - horizontalScrollbarHeight;\n        verticalScrollbar.didMouseDown({\n          button: 0,\n          detail: 1,\n          clientY: clientTopForLine(component, 4),\n          clientX: leftEdgeOfVerticalScrollbar\n        });\n        expect(editor.getCursorScreenPosition()).toEqual([0, 0]);\n        verticalScrollbar.didMouseDown({\n          button: 0,\n          detail: 1,\n          clientY: clientTopForLine(component, 4),\n          clientX: leftEdgeOfVerticalScrollbar - 1\n        });\n        expect(editor.getCursorScreenPosition()).toEqual([4, 6]);\n        horizontalScrollbar.didMouseDown({\n          button: 0,\n          detail: 1,\n          clientY: topEdgeOfHorizontalScrollbar,\n          clientX: component.refs.content.getBoundingClientRect().left\n        });\n        expect(editor.getCursorScreenPosition()).toEqual([4, 6]);\n        horizontalScrollbar.didMouseDown({\n          button: 0,\n          detail: 1,\n          clientY: topEdgeOfHorizontalScrollbar - 1,\n          clientX: component.refs.content.getBoundingClientRect().left\n        });\n        expect(editor.getCursorScreenPosition()).toEqual([4, 0]);\n      });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prevents the browser's default processing for the event on Linux",
            "suites": [
                "TextEditorComponent",
                "paste event"
            ],
            "updatePoint": {
                "line": 4425,
                "column": 72
            },
            "line": 4425,
            "code": "    it(\"prevents the browser's default processing for the event on Linux\", () => {\n      const {\n        component\n      } = buildComponent({\n        platform: 'linux'\n      });\n      const event = {\n        preventDefault: () => {}\n      };\n      spyOn(event, 'preventDefault');\n      component.didPaste(event);\n      expect(event.preventDefault).toHaveBeenCalled();\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "handles inserted accented characters via the press-and-hold menu on macOS correctly",
            "suites": [
                "TextEditorComponent",
                "keyboard input"
            ],
            "updatePoint": {
                "line": 4440,
                "column": 91
            },
            "line": 4440,
            "code": "    it('handles inserted accented characters via the press-and-hold menu on macOS correctly', () => {\n      const {\n        editor,\n        component\n      } = buildComponent({\n        text: '',\n        chromeVersion: 57\n      });\n      editor.insertText('x');\n      editor.setCursorBufferPosition([0, 1]); // Simulate holding the A key to open the press-and-hold menu,\n      // then closing it via ESC.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'Escape'\n      });\n      component.didKeyup({\n        code: 'Escape'\n      });\n      expect(editor.getText()).toBe('xa'); // Ensure another \"a\" can be typed correctly.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      expect(editor.getText()).toBe('xaa');\n      editor.undo();\n      expect(editor.getText()).toBe('x'); // Simulate holding the A key to open the press-and-hold menu,\n      // then selecting an alternative by typing a number.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'Digit2'\n      });\n      component.didKeyup({\n        code: 'Digit2'\n      });\n      component.didTextInput({\n        data: 'á',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      expect(editor.getText()).toBe('xá'); // Ensure another \"a\" can be typed correctly.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      expect(editor.getText()).toBe('xáa');\n      editor.undo();\n      expect(editor.getText()).toBe('x'); // Simulate holding the A key to open the press-and-hold menu,\n      // then selecting an alternative by clicking on it.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'á',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      expect(editor.getText()).toBe('xá'); // Ensure another \"a\" can be typed correctly.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      expect(editor.getText()).toBe('xáa');\n      editor.undo();\n      expect(editor.getText()).toBe('x'); // Simulate holding the A key to open the press-and-hold menu,\n      // cycling through the alternatives with the arrows, then selecting one of them with Enter.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'ArrowRight'\n      });\n      component.didCompositionStart({\n        data: ''\n      });\n      component.didCompositionUpdate({\n        data: 'à'\n      });\n      component.didKeyup({\n        code: 'ArrowRight'\n      });\n      expect(editor.getText()).toBe('xà');\n      component.didKeydown({\n        code: 'ArrowRight'\n      });\n      component.didCompositionUpdate({\n        data: 'á'\n      });\n      component.didKeyup({\n        code: 'ArrowRight'\n      });\n      expect(editor.getText()).toBe('xá');\n      component.didKeydown({\n        code: 'Enter'\n      });\n      component.didCompositionUpdate({\n        data: 'á'\n      });\n      component.didTextInput({\n        data: 'á',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didCompositionEnd({\n        data: 'á',\n        target: component.refs.cursorsAndInput.refs.hiddenInput\n      });\n      component.didKeyup({\n        code: 'Enter'\n      });\n      expect(editor.getText()).toBe('xá'); // Ensure another \"a\" can be typed correctly.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      expect(editor.getText()).toBe('xáa');\n      editor.undo();\n      expect(editor.getText()).toBe('x'); // Simulate holding the A key to open the press-and-hold menu,\n      // cycling through the alternatives with the arrows, then closing it via ESC.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'ArrowRight'\n      });\n      component.didCompositionStart({\n        data: ''\n      });\n      component.didCompositionUpdate({\n        data: 'à'\n      });\n      component.didKeyup({\n        code: 'ArrowRight'\n      });\n      expect(editor.getText()).toBe('xà');\n      component.didKeydown({\n        code: 'ArrowRight'\n      });\n      component.didCompositionUpdate({\n        data: 'á'\n      });\n      component.didKeyup({\n        code: 'ArrowRight'\n      });\n      expect(editor.getText()).toBe('xá');\n      component.didKeydown({\n        code: 'Escape'\n      });\n      component.didCompositionUpdate({\n        data: 'a'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didCompositionEnd({\n        data: 'a',\n        target: component.refs.cursorsAndInput.refs.hiddenInput\n      });\n      component.didKeyup({\n        code: 'Escape'\n      });\n      expect(editor.getText()).toBe('xa'); // Ensure another \"a\" can be typed correctly.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      expect(editor.getText()).toBe('xaa');\n      editor.undo();\n      expect(editor.getText()).toBe('x'); // Simulate pressing the O key and holding the A key to open the press-and-hold menu right before releasing the O key,\n      // cycling through the alternatives with the arrows, then closing it via ESC.\n\n      component.didKeydown({\n        code: 'KeyO'\n      });\n      component.didKeypress({\n        code: 'KeyO'\n      });\n      component.didTextInput({\n        data: 'o',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeyup({\n        code: 'KeyO'\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'ArrowRight'\n      });\n      component.didCompositionStart({\n        data: ''\n      });\n      component.didCompositionUpdate({\n        data: 'à'\n      });\n      component.didKeyup({\n        code: 'ArrowRight'\n      });\n      expect(editor.getText()).toBe('xoà');\n      component.didKeydown({\n        code: 'ArrowRight'\n      });\n      component.didCompositionUpdate({\n        data: 'á'\n      });\n      component.didKeyup({\n        code: 'ArrowRight'\n      });\n      expect(editor.getText()).toBe('xoá');\n      component.didKeydown({\n        code: 'Escape'\n      });\n      component.didCompositionUpdate({\n        data: 'a'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didCompositionEnd({\n        data: 'a',\n        target: component.refs.cursorsAndInput.refs.hiddenInput\n      });\n      component.didKeyup({\n        code: 'Escape'\n      });\n      expect(editor.getText()).toBe('xoa'); // Ensure another \"a\" can be typed correctly.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      editor.undo();\n      expect(editor.getText()).toBe('x'); // Simulate holding the A key to open the press-and-hold menu,\n      // cycling through the alternatives with the arrows, then closing it by changing focus.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      component.didKeydown({\n        code: 'ArrowRight'\n      });\n      component.didCompositionStart({\n        data: ''\n      });\n      component.didCompositionUpdate({\n        data: 'à'\n      });\n      component.didKeyup({\n        code: 'ArrowRight'\n      });\n      expect(editor.getText()).toBe('xà');\n      component.didKeydown({\n        code: 'ArrowRight'\n      });\n      component.didCompositionUpdate({\n        data: 'á'\n      });\n      component.didKeyup({\n        code: 'ArrowRight'\n      });\n      expect(editor.getText()).toBe('xá');\n      component.didCompositionUpdate({\n        data: 'á'\n      });\n      component.didTextInput({\n        data: 'á',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didCompositionEnd({\n        data: 'á',\n        target: component.refs.cursorsAndInput.refs.hiddenInput\n      });\n      expect(editor.getText()).toBe('xá'); // Ensure another \"a\" can be typed correctly.\n\n      component.didKeydown({\n        code: 'KeyA'\n      });\n      component.didKeypress({\n        code: 'KeyA'\n      });\n      component.didTextInput({\n        data: 'a',\n        stopPropagation: () => {},\n        preventDefault: () => {}\n      });\n      component.didKeyup({\n        code: 'KeyA'\n      });\n      expect(editor.getText()).toBe('xáa');\n      editor.undo();\n      expect(editor.getText()).toBe('x');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the rendered content based on new measurements when the font dimensions change",
            "suites": [
                "TextEditorComponent",
                "styling changes"
            ],
            "updatePoint": {
                "line": 4930,
                "column": 94
            },
            "line": 4930,
            "code": "    it('updates the rendered content based on new measurements when the font dimensions change', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 1,\n        autoHeight: false\n      });\n      await setEditorHeightInLines(component, 3);\n      editor.setCursorScreenPosition([1, 29], {\n        autoscroll: false\n      });\n      await component.getNextUpdatePromise();\n      let cursorNode = element.querySelector('.cursor');\n      const initialBaseCharacterWidth = editor.getDefaultCharWidth();\n      const initialDoubleCharacterWidth = editor.getDoubleWidthCharWidth();\n      const initialHalfCharacterWidth = editor.getHalfWidthCharWidth();\n      const initialKoreanCharacterWidth = editor.getKoreanCharWidth();\n      const initialRenderedLineCount = queryOnScreenLineElements(element).length;\n      const initialFontSize = parseInt(getComputedStyle(element).fontSize);\n      expect(initialKoreanCharacterWidth).toBeDefined();\n      expect(initialDoubleCharacterWidth).toBeDefined();\n      expect(initialHalfCharacterWidth).toBeDefined();\n      expect(initialBaseCharacterWidth).toBeDefined();\n      expect(initialDoubleCharacterWidth).not.toBe(initialBaseCharacterWidth);\n      expect(initialHalfCharacterWidth).not.toBe(initialBaseCharacterWidth);\n      expect(initialKoreanCharacterWidth).not.toBe(initialBaseCharacterWidth);\n      verifyCursorPosition(component, cursorNode, 1, 29);\n      element.style.fontSize = initialFontSize - 5 + 'px';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      expect(editor.getDefaultCharWidth()).toBeLessThan(initialBaseCharacterWidth);\n      expect(editor.getDoubleWidthCharWidth()).toBeLessThan(initialDoubleCharacterWidth);\n      expect(editor.getHalfWidthCharWidth()).toBeLessThan(initialHalfCharacterWidth);\n      expect(editor.getKoreanCharWidth()).toBeLessThan(initialKoreanCharacterWidth);\n      expect(queryOnScreenLineElements(element).length).toBeGreaterThan(initialRenderedLineCount);\n      verifyCursorPosition(component, cursorNode, 1, 29);\n      element.style.fontSize = initialFontSize + 10 + 'px';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      expect(editor.getDefaultCharWidth()).toBeGreaterThan(initialBaseCharacterWidth);\n      expect(editor.getDoubleWidthCharWidth()).toBeGreaterThan(initialDoubleCharacterWidth);\n      expect(editor.getHalfWidthCharWidth()).toBeGreaterThan(initialHalfCharacterWidth);\n      expect(editor.getKoreanCharWidth()).toBeGreaterThan(initialKoreanCharacterWidth);\n      expect(queryOnScreenLineElements(element).length).toBeLessThan(initialRenderedLineCount);\n      verifyCursorPosition(component, cursorNode, 1, 29);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "maintains the scrollTopRow and scrollLeftColumn when the font size changes",
            "suites": [
                "TextEditorComponent",
                "styling changes"
            ],
            "updatePoint": {
                "line": 4978,
                "column": 82
            },
            "line": 4978,
            "code": "    it('maintains the scrollTopRow and scrollLeftColumn when the font size changes', async () => {\n      const {\n        component,\n        element\n      } = buildComponent({\n        rowsPerTile: 1,\n        autoHeight: false\n      });\n      await setEditorHeightInLines(component, 3);\n      await setEditorWidthInCharacters(component, 20);\n      component.setScrollTopRow(4);\n      component.setScrollLeftColumn(10);\n      await component.getNextUpdatePromise();\n      const initialFontSize = parseInt(getComputedStyle(element).fontSize);\n      element.style.fontSize = initialFontSize - 5 + 'px';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      expect(component.getScrollTopRow()).toBe(4);\n      element.style.fontSize = initialFontSize + 5 + 'px';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n      expect(component.getScrollTopRow()).toBe(4);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gracefully handles the editor being hidden after a styling change",
            "suites": [
                "TextEditorComponent",
                "styling changes"
            ],
            "updatePoint": {
                "line": 5001,
                "column": 73
            },
            "line": 5001,
            "code": "    it('gracefully handles the editor being hidden after a styling change', async () => {\n      const {\n        component,\n        element\n      } = buildComponent({\n        autoHeight: false\n      });\n      element.style.fontSize = parseInt(getComputedStyle(element).fontSize) + 5 + 'px';\n      TextEditor.didUpdateStyles();\n      element.style.display = 'none';\n      await component.getNextUpdatePromise();\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw an exception when the editor is soft-wrapped and changing the font size changes also the longest screen line",
            "suites": [
                "TextEditorComponent",
                "styling changes"
            ],
            "updatePoint": {
                "line": 5013,
                "column": 131
            },
            "line": 5013,
            "code": "    it('does not throw an exception when the editor is soft-wrapped and changing the font size changes also the longest screen line', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 3,\n        autoHeight: false\n      });\n      editor.setText('Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do\\n' + 'eiusmod tempor incididunt ut labore et dolore magna' + 'aliqua. Ut enim ad minim veniam, quis nostrud exercitation');\n      editor.setSoftWrapped(true);\n      await setEditorHeightInLines(component, 2);\n      await setEditorWidthInCharacters(component, 56);\n      await setScrollTop(component, 3 * component.getLineHeight());\n      element.style.fontSize = '20px';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise();\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the width of the lines div based on the longest screen line",
            "suites": [
                "TextEditorComponent",
                "styling changes"
            ],
            "updatePoint": {
                "line": 5031,
                "column": 75
            },
            "line": 5031,
            "code": "    it('updates the width of the lines div based on the longest screen line', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 1,\n        autoHeight: false\n      });\n      editor.setText('Lorem ipsum dolor sit\\n' + 'amet, consectetur adipisicing\\n' + 'elit, sed do\\n' + 'eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation');\n      await setEditorHeightInLines(component, 2);\n      element.style.fontSize = '20px';\n      TextEditor.didUpdateStyles();\n      await component.getNextUpdatePromise(); // Capture the width of the lines before requesting the width of\n      // longest line, because making that request forces a DOM update\n\n      const actualWidth = element.querySelector('.lines').style.width;\n      const expectedWidth = Math.ceil(component.pixelPositionForScreenPosition(Point(3, Infinity)).left + component.getBaseCharacterWidth());\n      expect(actualWidth).toBe(expectedWidth + 'px');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates synchronously when updatedSynchronously is true",
            "suites": [
                "TextEditorComponent",
                "synchronous updates"
            ],
            "updatePoint": {
                "line": 5060,
                "column": 63
            },
            "line": 5060,
            "code": "    it('updates synchronously when updatedSynchronously is true', () => {\n      const editor = buildEditor();\n      const {\n        element\n      } = new TextEditorComponent({\n        model: editor,\n        updatedSynchronously: true\n      });\n      jasmine.attachToDOM(element);\n      editor.setText('Lorem ipsum dolor');\n      expect(queryOnScreenLineElements(element).map(l => l.textContent)).toEqual([editor.lineTextForScreenRow(0)]);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw an exception on attachment when setting the soft-wrap column",
            "suites": [
                "TextEditorComponent",
                "synchronous updates"
            ],
            "updatePoint": {
                "line": 5072,
                "column": 83
            },
            "line": 5072,
            "code": "    it('does not throw an exception on attachment when setting the soft-wrap column', () => {\n      const {\n        element,\n        editor\n      } = buildComponent({\n        width: 435,\n        attach: false,\n        updatedSynchronously: true\n      });\n      editor.setSoftWrapped(true);\n      spyOn(window, 'onerror').andCallThrough();\n      jasmine.attachToDOM(element); // should not throw an exception\n\n      expect(window.onerror).not.toHaveBeenCalled();\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates synchronously when creating a component via TextEditor and TextEditorElement.prototype.updatedSynchronously is true",
            "suites": [
                "TextEditorComponent",
                "synchronous updates"
            ],
            "updatePoint": {
                "line": 5087,
                "column": 131
            },
            "line": 5087,
            "code": "    it('updates synchronously when creating a component via TextEditor and TextEditorElement.prototype.updatedSynchronously is true', () => {\n      TextEditorElement.prototype.setUpdatedSynchronously(true);\n      const editor = buildEditor();\n      const element = editor.element;\n      jasmine.attachToDOM(element);\n      editor.setText('Lorem ipsum dolor');\n      expect(queryOnScreenLineElements(element).map(l => l.textContent)).toEqual([editor.lineTextForScreenRow(0)]);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "measures dimensions synchronously when measureDimensions is called on the component",
            "suites": [
                "TextEditorComponent",
                "synchronous updates"
            ],
            "updatePoint": {
                "line": 5095,
                "column": 91
            },
            "line": 5095,
            "code": "    it('measures dimensions synchronously when measureDimensions is called on the component', () => {\n      TextEditorElement.prototype.setUpdatedSynchronously(true);\n      const editor = buildEditor({\n        autoHeight: false\n      });\n      const element = editor.element;\n      jasmine.attachToDOM(element);\n      element.style.height = '100px';\n      expect(element.component.getClientContainerHeight()).not.toBe(100);\n      element.component.measureDimensions();\n      expect(element.component.getClientContainerHeight()).toBe(100);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pixel position for the given point, regardless of whether or not it is currently on screen",
            "suites": [
                "TextEditorComponent",
                "pixelPositionForScreenPosition(point)"
            ],
            "updatePoint": {
                "line": 5109,
                "column": 110
            },
            "line": 5109,
            "code": "    it('returns the pixel position for the given point, regardless of whether or not it is currently on screen', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        rowsPerTile: 2,\n        autoHeight: false\n      });\n      await setEditorHeightInLines(component, 3);\n      await setScrollTop(component, 3 * component.getLineHeight());\n      const {\n        component: referenceComponent\n      } = buildComponent();\n      const referenceContentRect = referenceComponent.refs.content.getBoundingClientRect();\n      {\n        const {\n          top,\n          left\n        } = component.pixelPositionForScreenPosition({\n          row: 0,\n          column: 0\n        });\n        expect(top).toBe(clientTopForLine(referenceComponent, 0) - referenceContentRect.top);\n        expect(left).toBe(clientLeftForCharacter(referenceComponent, 0, 0) - referenceContentRect.left);\n      }\n      {\n        const {\n          top,\n          left\n        } = component.pixelPositionForScreenPosition({\n          row: 0,\n          column: 5\n        });\n        expect(top).toBe(clientTopForLine(referenceComponent, 0) - referenceContentRect.top);\n        expect(left).toBeNear(clientLeftForCharacter(referenceComponent, 0, 5) - referenceContentRect.left);\n      }\n      {\n        const {\n          top,\n          left\n        } = component.pixelPositionForScreenPosition({\n          row: 12,\n          column: 1\n        });\n        expect(top).toBeNear(clientTopForLine(referenceComponent, 12) - referenceContentRect.top);\n        expect(left).toBeNear(clientLeftForCharacter(referenceComponent, 12, 1) - referenceContentRect.left);\n      } // Measuring a currently rendered line while an autoscroll that causes\n      // that line to go off-screen is in progress.\n\n      {\n        editor.setCursorScreenPosition([10, 0]);\n        const {\n          top,\n          left\n        } = component.pixelPositionForScreenPosition({\n          row: 3,\n          column: 5\n        });\n        expect(top).toBeNear(clientTopForLine(referenceComponent, 3) - referenceContentRect.top);\n        expect(left).toBeNear(clientLeftForCharacter(referenceComponent, 3, 5) - referenceContentRect.left);\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not get the component into an inconsistent state when the model has unflushed changes (regression)",
            "suites": [
                "TextEditorComponent",
                "pixelPositionForScreenPosition(point)"
            ],
            "updatePoint": {
                "line": 5171,
                "column": 111
            },
            "line": 5171,
            "code": "    it('does not get the component into an inconsistent state when the model has unflushed changes (regression)', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        rowsPerTile: 2,\n        autoHeight: false,\n        text: ''\n      });\n      await setEditorHeightInLines(component, 10);\n      const updatePromise = editor.getBuffer().append('hi\\n');\n      component.screenPositionForPixelPosition({\n        top: 800,\n        left: 1\n      });\n      await updatePromise;\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not shift cursors downward or render off-screen content when measuring off-screen lines (regression)",
            "suites": [
                "TextEditorComponent",
                "pixelPositionForScreenPosition(point)"
            ],
            "updatePoint": {
                "line": 5188,
                "column": 113
            },
            "line": 5188,
            "code": "    it('does not shift cursors downward or render off-screen content when measuring off-screen lines (regression)', async () => {\n      const {\n        component,\n        element\n      } = buildComponent({\n        rowsPerTile: 2,\n        autoHeight: false\n      });\n      await setEditorHeightInLines(component, 3);\n      component.pixelPositionForScreenPosition({\n        row: 12,\n        column: 1\n      });\n      expect(element.querySelector('.cursor').getBoundingClientRect().top).toBe(component.refs.lineTiles.getBoundingClientRect().top);\n      expect(element.querySelector('.line[data-screen-row=\"12\"]').style.visibility).toBe('hidden'); // Ensure previously measured off screen lines don't have any weird\n      // styling when they come on screen in the next frame\n\n      await setEditorHeightInLines(component, 13);\n      const previouslyMeasuredLineElement = element.querySelector('.line[data-screen-row=\"12\"]');\n      expect(previouslyMeasuredLineElement.style.display).toBe('');\n      expect(previouslyMeasuredLineElement.style.visibility).toBe('');\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the screen position for the given pixel position, regardless of whether or not it is currently on screen",
            "suites": [
                "TextEditorComponent",
                "screenPositionForPixelPosition"
            ],
            "updatePoint": {
                "line": 5212,
                "column": 120
            },
            "line": 5212,
            "code": "    it('returns the screen position for the given pixel position, regardless of whether or not it is currently on screen', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        rowsPerTile: 2,\n        autoHeight: false\n      });\n      await setEditorHeightInLines(component, 3);\n      await setScrollTop(component, 3 * component.getLineHeight());\n      const {\n        component: referenceComponent\n      } = buildComponent();\n      {\n        const pixelPosition = referenceComponent.pixelPositionForScreenPosition({\n          row: 0,\n          column: 0\n        });\n        pixelPosition.top += component.getLineHeight() / 3;\n        pixelPosition.left += component.getBaseCharacterWidth() / 3;\n        expect(component.screenPositionForPixelPosition(pixelPosition)).toEqual([0, 0]);\n      }\n      {\n        const pixelPosition = referenceComponent.pixelPositionForScreenPosition({\n          row: 0,\n          column: 5\n        });\n        pixelPosition.top += component.getLineHeight() / 3;\n        pixelPosition.left += component.getBaseCharacterWidth() / 3;\n        expect(component.screenPositionForPixelPosition(pixelPosition)).toEqual([0, 5]);\n      }\n      {\n        const pixelPosition = referenceComponent.pixelPositionForScreenPosition({\n          row: 5,\n          column: 7\n        });\n        pixelPosition.top += component.getLineHeight() / 3;\n        pixelPosition.left += component.getBaseCharacterWidth() / 3;\n        expect(component.screenPositionForPixelPosition(pixelPosition)).toEqual([5, 7]);\n      }\n      {\n        const pixelPosition = referenceComponent.pixelPositionForScreenPosition({\n          row: 12,\n          column: 1\n        });\n        pixelPosition.top += component.getLineHeight() / 3;\n        pixelPosition.left += component.getBaseCharacterWidth() / 3;\n        expect(component.screenPositionForPixelPosition(pixelPosition)).toEqual([12, 1]);\n      } // Measuring a currently rendered line while an autoscroll that causes\n      // that line to go off-screen is in progress.\n\n      {\n        const pixelPosition = referenceComponent.pixelPositionForScreenPosition({\n          row: 3,\n          column: 4\n        });\n        pixelPosition.top += component.getLineHeight() / 3;\n        pixelPosition.left += component.getBaseCharacterWidth() / 3;\n        editor.setCursorBufferPosition([10, 0]);\n        expect(component.screenPositionForPixelPosition(pixelPosition)).toEqual([3, 4]);\n      }\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "delegates setHeight and getHeight to the component",
            "suites": [
                "TextEditorComponent",
                "model methods that delegate to the component / element"
            ],
            "updatePoint": {
                "line": 5276,
                "column": 58
            },
            "line": 5276,
            "code": "    it('delegates setHeight and getHeight to the component', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent({\n        autoHeight: false\n      });\n      spyOn(Grim, 'deprecate');\n      expect(editor.getHeight()).toBe(component.getScrollContainerHeight());\n      expect(Grim.deprecate.callCount).toBe(1);\n      editor.setHeight(100);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollContainerHeight()).toBe(100);\n      expect(Grim.deprecate.callCount).toBe(2);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "delegates setWidth and getWidth to the component",
            "suites": [
                "TextEditorComponent",
                "model methods that delegate to the component / element"
            ],
            "updatePoint": {
                "line": 5291,
                "column": 56
            },
            "line": 5291,
            "code": "    it('delegates setWidth and getWidth to the component', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      spyOn(Grim, 'deprecate');\n      expect(editor.getWidth()).toBe(component.getScrollContainerWidth());\n      expect(Grim.deprecate.callCount).toBe(1);\n      editor.setWidth(100);\n      await component.getNextUpdatePromise();\n      expect(component.getScrollContainerWidth()).toBe(100);\n      expect(Grim.deprecate.callCount).toBe(2);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "delegates getFirstVisibleScreenRow, getLastVisibleScreenRow, and getVisibleRowRange to the component",
            "suites": [
                "TextEditorComponent",
                "model methods that delegate to the component / element"
            ],
            "updatePoint": {
                "line": 5304,
                "column": 108
            },
            "line": 5304,
            "code": "    it('delegates getFirstVisibleScreenRow, getLastVisibleScreenRow, and getVisibleRowRange to the component', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 3,\n        autoHeight: false\n      });\n      element.style.height = 4 * component.measurements.lineHeight + 'px';\n      await component.getNextUpdatePromise();\n      await setScrollTop(component, 5 * component.getLineHeight());\n      expect(editor.getFirstVisibleScreenRow()).toBe(component.getFirstVisibleRow());\n      expect(editor.getLastVisibleScreenRow()).toBe(component.getLastVisibleRow());\n      expect(editor.getVisibleRowRange()).toEqual([component.getFirstVisibleRow(), component.getLastVisibleRow()]);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "assigns scrollTop on the component when calling setFirstVisibleScreenRow",
            "suites": [
                "TextEditorComponent",
                "model methods that delegate to the component / element"
            ],
            "updatePoint": {
                "line": 5320,
                "column": 80
            },
            "line": 5320,
            "code": "    it('assigns scrollTop on the component when calling setFirstVisibleScreenRow', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 3,\n        autoHeight: false\n      });\n      element.style.height = 4 * component.measurements.lineHeight + horizontalScrollbarHeight + 'px';\n      await component.getNextUpdatePromise();\n      expect(component.getMaxScrollTop() / component.getLineHeight()).toBeNear(9);\n      expect(component.refs.verticalScrollbar.element.scrollTop).toBe(0 * component.getLineHeight());\n      editor.setFirstVisibleScreenRow(1);\n      expect(component.getFirstVisibleRow()).toBe(1);\n      await component.getNextUpdatePromise();\n      expect(component.refs.verticalScrollbar.element.scrollTop).toBeNear(1 * component.getLineHeight());\n      editor.setFirstVisibleScreenRow(5);\n      expect(component.getFirstVisibleRow()).toBe(5);\n      await component.getNextUpdatePromise();\n      expect(component.refs.verticalScrollbar.element.scrollTop).toBeNear(5 * component.getLineHeight());\n      editor.setFirstVisibleScreenRow(11);\n      expect(component.getFirstVisibleRow()).toBe(9);\n      await component.getNextUpdatePromise();\n      expect(component.refs.verticalScrollbar.element.scrollTop).toBeNear(9 * component.getLineHeight());\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "delegates setFirstVisibleScreenColumn and getFirstVisibleScreenColumn to the component",
            "suites": [
                "TextEditorComponent",
                "model methods that delegate to the component / element"
            ],
            "updatePoint": {
                "line": 5346,
                "column": 94
            },
            "line": 5346,
            "code": "    it('delegates setFirstVisibleScreenColumn and getFirstVisibleScreenColumn to the component', async () => {\n      const {\n        component,\n        element,\n        editor\n      } = buildComponent({\n        rowsPerTile: 3,\n        autoHeight: false\n      });\n      element.style.width = 30 * component.getBaseCharacterWidth() + 'px';\n      await component.getNextUpdatePromise();\n      expect(editor.getFirstVisibleScreenColumn()).toBe(0);\n      expect(component.refs.horizontalScrollbar.element.scrollLeft).toBe(0);\n      setScrollLeft(component, 5.5 * component.getBaseCharacterWidth());\n      expect(editor.getFirstVisibleScreenColumn()).toBe(5);\n      await component.getNextUpdatePromise();\n      expect(component.refs.horizontalScrollbar.element.scrollLeft).toBeCloseTo(5.5 * component.getBaseCharacterWidth(), -1);\n      editor.setFirstVisibleScreenColumn(12);\n      expect(component.getScrollLeft()).toBeCloseTo(12 * component.getBaseCharacterWidth(), -1);\n      await component.getNextUpdatePromise();\n      expect(component.refs.horizontalScrollbar.element.scrollLeft).toBeCloseTo(12 * component.getBaseCharacterWidth(), -1);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "repeatedly schedules `didDrag` calls on new animation frames after moving the mouse, and calls `didStopDragging` on mouseup",
            "suites": [
                "TextEditorComponent",
                "handleMouseDragUntilMouseUp"
            ],
            "updatePoint": {
                "line": 5370,
                "column": 131
            },
            "line": 5370,
            "code": "    it('repeatedly schedules `didDrag` calls on new animation frames after moving the mouse, and calls `didStopDragging` on mouseup', async () => {\n      const {\n        component\n      } = buildComponent();\n      let dragEvents;\n      let dragging = false;\n      component.handleMouseDragUntilMouseUp({\n        didDrag: event => {\n          dragging = true;\n          dragEvents.push(event);\n        },\n        didStopDragging: () => {\n          dragging = false;\n        }\n      });\n      expect(dragging).toBe(false);\n      dragEvents = [];\n      const moveEvent1 = new MouseEvent('mousemove');\n      window.dispatchEvent(moveEvent1);\n      expect(dragging).toBe(false);\n      await getNextAnimationFramePromise();\n      expect(dragging).toBe(true);\n      expect(dragEvents).toEqual([moveEvent1]);\n      await getNextAnimationFramePromise();\n      expect(dragging).toBe(true);\n      expect(dragEvents).toEqual([moveEvent1, moveEvent1]);\n      dragEvents = [];\n      const moveEvent2 = new MouseEvent('mousemove');\n      window.dispatchEvent(moveEvent2);\n      expect(dragging).toBe(true);\n      expect(dragEvents).toEqual([]);\n      await getNextAnimationFramePromise();\n      expect(dragging).toBe(true);\n      expect(dragEvents).toEqual([moveEvent2]);\n      await getNextAnimationFramePromise();\n      expect(dragging).toBe(true);\n      expect(dragEvents).toEqual([moveEvent2, moveEvent2]);\n      dragEvents = [];\n      window.dispatchEvent(new MouseEvent('mouseup'));\n      expect(dragging).toBe(false);\n      expect(dragEvents).toEqual([]);\n      window.dispatchEvent(new MouseEvent('mousemove'));\n      await getNextAnimationFramePromise();\n      expect(dragging).toBe(false);\n      expect(dragEvents).toEqual([]);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls `didStopDragging` if the user interacts with the keyboard while dragging",
            "suites": [
                "TextEditorComponent",
                "handleMouseDragUntilMouseUp"
            ],
            "updatePoint": {
                "line": 5416,
                "column": 86
            },
            "line": 5416,
            "code": "    it('calls `didStopDragging` if the user interacts with the keyboard while dragging', async () => {\n      const {\n        component,\n        editor\n      } = buildComponent();\n      let dragging = false;\n\n      function startDragging() {\n        component.handleMouseDragUntilMouseUp({\n          didDrag: event => {\n            dragging = true;\n          },\n          didStopDragging: () => {\n            dragging = false;\n          }\n        });\n      }\n\n      startDragging();\n      window.dispatchEvent(new MouseEvent('mousemove'));\n      await getNextAnimationFramePromise();\n      expect(dragging).toBe(true); // Buffer changes don't cause dragging to be stopped.\n\n      editor.insertText('X');\n      expect(dragging).toBe(true); // Keyboard interaction prevents users from dragging further.\n\n      component.didKeydown({\n        code: 'KeyX'\n      });\n      expect(dragging).toBe(false);\n      window.dispatchEvent(new MouseEvent('mousemove'));\n      await getNextAnimationFramePromise();\n      expect(dragging).toBe(false); // Pressing a modifier key does not terminate dragging, (to ensure we can add new selections with the mouse)\n\n      startDragging();\n      window.dispatchEvent(new MouseEvent('mousemove'));\n      await getNextAnimationFramePromise();\n      expect(dragging).toBe(true);\n      component.didKeydown({\n        key: 'Control'\n      });\n      component.didKeydown({\n        key: 'Alt'\n      });\n      component.didKeydown({\n        key: 'Shift'\n      });\n      component.didKeydown({\n        key: 'Meta'\n      });\n      expect(dragging).toBe(true);\n    });",
            "file": "text-editor-component-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "honors the 'mini' attribute",
            "suites": [
                "TextEditorElement"
            ],
            "updatePoint": {
                "line": 22,
                "column": 33
            },
            "line": 22,
            "code": "  it(\"honors the 'mini' attribute\", () => {\n    jasmineContent.innerHTML = '<atom-text-editor mini>';\n    const element = jasmineContent.firstChild;\n    expect(element.getModel().isMini()).toBe(true);\n    element.removeAttribute('mini');\n    expect(element.getModel().isMini()).toBe(false);\n    expect(element.getComponent().getGutterContainerWidth()).toBe(0);\n    element.setAttribute('mini', '');\n    expect(element.getModel().isMini()).toBe(true);\n  });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the editor to mini if the model is accessed prior to attaching the element",
            "suites": [
                "TextEditorElement"
            ],
            "updatePoint": {
                "line": 32,
                "column": 85
            },
            "line": 32,
            "code": "  it('sets the editor to mini if the model is accessed prior to attaching the element', () => {\n    const parent = document.createElement('div');\n    parent.innerHTML = '<atom-text-editor mini>';\n    const element = parent.firstChild;\n    expect(element.getModel().isMini()).toBe(true);\n  });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "honors the 'placeholder-text' attribute",
            "suites": [
                "TextEditorElement"
            ],
            "updatePoint": {
                "line": 38,
                "column": 45
            },
            "line": 38,
            "code": "  it(\"honors the 'placeholder-text' attribute\", () => {\n    jasmineContent.innerHTML = \"<atom-text-editor placeholder-text='testing'>\";\n    const element = jasmineContent.firstChild;\n    expect(element.getModel().getPlaceholderText()).toBe('testing');\n    element.setAttribute('placeholder-text', 'placeholder');\n    expect(element.getModel().getPlaceholderText()).toBe('placeholder');\n    element.removeAttribute('placeholder-text');\n    expect(element.getModel().getPlaceholderText()).toBeNull();\n  });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only assigns 'placeholder-text' on the model if the attribute is present",
            "suites": [
                "TextEditorElement"
            ],
            "updatePoint": {
                "line": 47,
                "column": 78
            },
            "line": 47,
            "code": "  it(\"only assigns 'placeholder-text' on the model if the attribute is present\", () => {\n    const editor = new TextEditor({\n      placeholderText: 'placeholder'\n    });\n    editor.getElement();\n    expect(editor.getPlaceholderText()).toBe('placeholder');\n  });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "honors the 'gutter-hidden' attribute",
            "suites": [
                "TextEditorElement"
            ],
            "updatePoint": {
                "line": 54,
                "column": 42
            },
            "line": 54,
            "code": "  it(\"honors the 'gutter-hidden' attribute\", () => {\n    jasmineContent.innerHTML = '<atom-text-editor gutter-hidden>';\n    const element = jasmineContent.firstChild;\n    expect(element.getModel().isLineNumberGutterVisible()).toBe(false);\n    element.removeAttribute('gutter-hidden');\n    expect(element.getModel().isLineNumberGutterVisible()).toBe(true);\n    element.setAttribute('gutter-hidden', '');\n    expect(element.getModel().isLineNumberGutterVisible()).toBe(false);\n  });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "honors the 'readonly' attribute",
            "suites": [
                "TextEditorElement"
            ],
            "updatePoint": {
                "line": 63,
                "column": 37
            },
            "line": 63,
            "code": "  it(\"honors the 'readonly' attribute\", async function () {\n    jasmineContent.innerHTML = '<atom-text-editor readonly>';\n    const element = jasmineContent.firstChild;\n    expect(element.getComponent().isInputEnabled()).toBe(false);\n    element.removeAttribute('readonly');\n    expect(element.getComponent().isInputEnabled()).toBe(true);\n    element.setAttribute('readonly', true);\n    expect(element.getComponent().isInputEnabled()).toBe(false);\n  });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "honors the text content",
            "suites": [
                "TextEditorElement"
            ],
            "updatePoint": {
                "line": 72,
                "column": 29
            },
            "line": 72,
            "code": "  it('honors the text content', () => {\n    jasmineContent.innerHTML = '<atom-text-editor>testing</atom-text-editor>';\n    const element = jasmineContent.firstChild;\n    expect(element.getModel().getText()).toBe('testing');\n  });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses a default value of -1",
            "suites": [
                "TextEditorElement",
                "tabIndex"
            ],
            "updatePoint": {
                "line": 78,
                "column": 34
            },
            "line": 78,
            "code": "    it('uses a default value of -1', () => {\n      jasmineContent.innerHTML = '<atom-text-editor />';\n      const element = jasmineContent.firstChild;\n      expect(element.tabIndex).toBe(-1);\n      expect(element.querySelector('input').tabIndex).toBe(-1);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the custom value when given",
            "suites": [
                "TextEditorElement",
                "tabIndex"
            ],
            "updatePoint": {
                "line": 84,
                "column": 40
            },
            "line": 84,
            "code": "    it('uses the custom value when given', () => {\n      jasmineContent.innerHTML = '<atom-text-editor tabIndex=\"42\" />';\n      const element = jasmineContent.firstChild;\n      expect(element.tabIndex).toBe(-1);\n      expect(element.querySelector('input').tabIndex).toBe(42);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the 'mini' attribute if .isMini() returns true on the model",
            "suites": [
                "TextEditorElement",
                "when the model is assigned"
            ],
            "updatePoint": {
                "line": 91,
                "column": 115
            },
            "line": 91,
            "code": "  describe('when the model is assigned', () => it(\"adds the 'mini' attribute if .isMini() returns true on the model\", async () => {\n    const element = buildTextEditorElement();\n    element.getModel().update({\n      mini: true\n    });\n    await atom.views.getNextUpdatePromise();\n    expect(element.hasAttribute('mini')).toBe(true);\n  }));",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "mounts the component and unmounts when removed from the dom",
            "suites": [
                "TextEditorElement",
                "when the editor is attached to the DOM"
            ],
            "updatePoint": {
                "line": 99,
                "column": 122
            },
            "line": 99,
            "code": "  describe('when the editor is attached to the DOM', () => it('mounts the component and unmounts when removed from the dom', () => {\n    const element = buildTextEditorElement();\n    const {\n      component\n    } = element;\n    expect(component.attached).toBe(true);\n    element.remove();\n    expect(component.attached).toBe(false);\n    jasmine.attachToDOM(element);\n    expect(element.component.attached).toBe(true);\n  }));",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not render duplicate line numbers",
            "suites": [
                "TextEditorElement",
                "when the editor is detached from the DOM and then reattached"
            ],
            "updatePoint": {
                "line": 111,
                "column": 46
            },
            "line": 111,
            "code": "    it('does not render duplicate line numbers', () => {\n      const editor = new TextEditor();\n      editor.setText('1\\n2\\n3');\n      const element = editor.getElement();\n      jasmine.attachToDOM(element);\n      const initialCount = element.querySelectorAll('.line-number').length;\n      element.remove();\n      jasmine.attachToDOM(element);\n      expect(element.querySelectorAll('.line-number').length).toBe(initialCount);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not render duplicate decorations in custom gutters",
            "suites": [
                "TextEditorElement",
                "when the editor is detached from the DOM and then reattached"
            ],
            "updatePoint": {
                "line": 121,
                "column": 63
            },
            "line": 121,
            "code": "    it('does not render duplicate decorations in custom gutters', () => {\n      const editor = new TextEditor();\n      editor.setText('1\\n2\\n3');\n      editor.addGutter({\n        name: 'test-gutter'\n      });\n      const marker = editor.markBufferRange([[0, 0], [2, 0]]);\n      editor.decorateMarker(marker, {\n        type: 'gutter',\n        gutterName: 'test-gutter'\n      });\n      const element = editor.getElement();\n      jasmine.attachToDOM(element);\n      const initialDecorationCount = element.querySelectorAll('.decoration').length;\n      element.remove();\n      jasmine.attachToDOM(element);\n      expect(element.querySelectorAll('.decoration').length).toBe(initialDecorationCount);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can be re-focused using the previous `document.activeElement`",
            "suites": [
                "TextEditorElement",
                "when the editor is detached from the DOM and then reattached"
            ],
            "updatePoint": {
                "line": 139,
                "column": 69
            },
            "line": 139,
            "code": "    it('can be re-focused using the previous `document.activeElement`', () => {\n      const editorElement = buildTextEditorElement();\n      editorElement.focus();\n      const {\n        activeElement\n      } = document;\n      editorElement.remove();\n      jasmine.attachToDOM(editorElement);\n      activeElement.focus();\n      expect(editorElement.hasFocus()).toBe(true);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "proxies focus/blur events to/from the hidden input",
            "suites": [
                "TextEditorElement",
                "focus and blur handling"
            ],
            "updatePoint": {
                "line": 152,
                "column": 58
            },
            "line": 152,
            "code": "    it('proxies focus/blur events to/from the hidden input', () => {\n      const element = buildTextEditorElement();\n      jasmineContent.appendChild(element);\n      let blurCalled = false;\n      element.addEventListener('blur', () => {\n        blurCalled = true;\n      });\n      element.focus();\n      expect(blurCalled).toBe(false);\n      expect(element.hasFocus()).toBe(true);\n      expect(document.activeElement).toBe(element.querySelector('input'));\n      document.body.focus();\n      expect(blurCalled).toBe(true);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't trigger a blur event on the editor element when focusing an already focused editor element",
            "suites": [
                "TextEditorElement",
                "focus and blur handling"
            ],
            "updatePoint": {
                "line": 166,
                "column": 106
            },
            "line": 166,
            "code": "    it(\"doesn't trigger a blur event on the editor element when focusing an already focused editor element\", () => {\n      let blurCalled = false;\n      const element = buildTextEditorElement();\n      element.addEventListener('blur', () => {\n        blurCalled = true;\n      });\n      jasmineContent.appendChild(element);\n      expect(document.activeElement).toBe(document.body);\n      expect(blurCalled).toBe(false);\n      element.focus();\n      expect(document.activeElement).toBe(element.querySelector('input'));\n      expect(blurCalled).toBe(false);\n      element.focus();\n      expect(document.activeElement).toBe(element.querySelector('input'));\n      expect(blurCalled).toBe(false);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "proxies the focus event to the hidden input",
            "suites": [
                "TextEditorElement",
                "focus and blur handling",
                "when focused while a parent node is being attached to the DOM"
            ],
            "updatePoint": {
                "line": 191,
                "column": 53
            },
            "line": 191,
            "code": "      it('proxies the focus event to the hidden input', () => {\n        const element = buildTextEditorElement();\n        const parentElement = document.createElement('element-that-focuses-child');\n        parentElement.appendChild(element);\n        jasmineContent.appendChild(parentElement);\n        expect(document.activeElement).toBe(element.querySelector('input'));\n      });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses the hidden input and does not throw an exception",
            "suites": [
                "TextEditorElement",
                "focus and blur handling",
                "if focused when invisible due to a zero height and width"
            ],
            "updatePoint": {
                "line": 200,
                "column": 66
            },
            "line": 200,
            "code": "      it('focuses the hidden input and does not throw an exception', () => {\n        const parentElement = document.createElement('div');\n        parentElement.style.position = 'absolute';\n        parentElement.style.width = '0px';\n        parentElement.style.height = '0px';\n        const element = buildTextEditorElement({\n          attach: false\n        });\n        parentElement.appendChild(element);\n        jasmineContent.appendChild(parentElement);\n        element.focus();\n        expect(document.activeElement).toBe(element.component.getHiddenInput());\n      });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the supplied one",
            "suites": [
                "TextEditorElement",
                "::setModel",
                "when the element does not have an editor yet"
            ],
            "updatePoint": {
                "line": 217,
                "column": 31
            },
            "line": 217,
            "code": "      it('uses the supplied one', () => {\n        const element = buildTextEditorElement({\n          attach: false\n        });\n        const editor = new TextEditor();\n        element.setModel(editor);\n        jasmine.attachToDOM(element);\n        expect(editor.element).toBe(element);\n        expect(element.getModel()).toBe(editor);\n      });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "unbinds it and then swaps it with the supplied one",
            "suites": [
                "TextEditorElement",
                "::setModel",
                "when the element already has an editor"
            ],
            "updatePoint": {
                "line": 229,
                "column": 60
            },
            "line": 229,
            "code": "      it('unbinds it and then swaps it with the supplied one', async () => {\n        const element = buildTextEditorElement({\n          attach: true\n        });\n        const previousEditor = element.getModel();\n        expect(previousEditor.element).toBe(element);\n        const newEditor = new TextEditor();\n        element.setModel(newEditor);\n        expect(previousEditor.element).not.toBe(element);\n        expect(newEditor.element).toBe(element);\n        expect(element.getModel()).toBe(newEditor);\n      });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes callbacks when the element is attached and detached",
            "suites": [
                "TextEditorElement",
                "::onDidAttach and ::onDidDetach"
            ],
            "updatePoint": {
                "line": 243,
                "column": 115
            },
            "line": 243,
            "code": "  describe('::onDidAttach and ::onDidDetach', () => it('invokes callbacks when the element is attached and detached', () => {\n    const element = buildTextEditorElement({\n      attach: false\n    });\n    const attachedCallback = jasmine.createSpy('attachedCallback');\n    const detachedCallback = jasmine.createSpy('detachedCallback');\n    element.onDidAttach(attachedCallback);\n    element.onDidDetach(detachedCallback);\n    jasmine.attachToDOM(element);\n    expect(attachedCallback).toHaveBeenCalled();\n    expect(detachedCallback).not.toHaveBeenCalled();\n    attachedCallback.reset();\n    element.remove();\n    expect(attachedCallback).not.toHaveBeenCalled();\n    expect(detachedCallback).toHaveBeenCalled();\n  }));",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "controls whether the text editor is updated synchronously",
            "suites": [
                "TextEditorElement",
                "::setUpdatedSynchronously"
            ],
            "updatePoint": {
                "line": 260,
                "column": 65
            },
            "line": 260,
            "code": "    it('controls whether the text editor is updated synchronously', () => {\n      spyOn(window, 'requestAnimationFrame').andCallFake(fn => fn());\n      const element = buildTextEditorElement();\n      expect(element.isUpdatedSynchronously()).toBe(false);\n      element.getModel().setText('hello');\n      expect(window.requestAnimationFrame).toHaveBeenCalled();\n      expect(element.textContent).toContain('hello');\n      window.requestAnimationFrame.reset();\n      element.setUpdatedSynchronously(true);\n      element.getModel().setText('goodbye');\n      expect(window.requestAnimationFrame).not.toHaveBeenCalled();\n      expect(element.textContent).toContain('goodbye');\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns 0 before the element is attached",
            "suites": [
                "TextEditorElement",
                "::getDefaultCharacterWidth"
            ],
            "updatePoint": {
                "line": 275,
                "column": 48
            },
            "line": 275,
            "code": "    it('returns 0 before the element is attached', () => {\n      const element = buildTextEditorElement({\n        attach: false\n      });\n      expect(element.getDefaultCharacterWidth()).toBe(0);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the width of a character in the root scope",
            "suites": [
                "TextEditorElement",
                "::getDefaultCharacterWidth"
            ],
            "updatePoint": {
                "line": 281,
                "column": 58
            },
            "line": 281,
            "code": "    it('returns the width of a character in the root scope', () => {\n      const element = buildTextEditorElement();\n      jasmine.attachToDOM(element);\n      expect(element.getDefaultCharacterWidth()).toBeGreaterThan(0);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the maximum scroll top that can be applied to the element",
            "suites": [
                "TextEditorElement",
                "::getMaxScrollTop"
            ],
            "updatePoint": {
                "line": 287,
                "column": 107
            },
            "line": 287,
            "code": "  describe('::getMaxScrollTop', () => it('returns the maximum scroll top that can be applied to the element', async () => {\n    const editor = new TextEditor();\n    editor.setText('1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10\\n11\\n12\\n13\\n14\\n15\\n16');\n    const element = editor.getElement();\n    element.style.lineHeight = '10px';\n    element.style.width = '200px';\n    jasmine.attachToDOM(element);\n    const horizontalScrollbarHeight = element.component.getHorizontalScrollbarHeight();\n    expect(element.getMaxScrollTop()).toBe(0);\n    await editor.update({\n      autoHeight: false\n    });\n    element.style.height = 100 + horizontalScrollbarHeight + 'px';\n    await element.getNextUpdatePromise();\n    expect(element.getMaxScrollTop()).toBe(60);\n    element.style.height = 120 + horizontalScrollbarHeight + 'px';\n    await element.getNextUpdatePromise();\n    expect(element.getMaxScrollTop()).toBe(40);\n    element.style.height = 200 + horizontalScrollbarHeight + 'px';\n    await element.getNextUpdatePromise();\n    expect(element.getMaxScrollTop()).toBe(0);\n  }));",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "changes the scroll position",
            "suites": [
                "TextEditorElement",
                "::setScrollTop and ::setScrollLeft"
            ],
            "updatePoint": {
                "line": 310,
                "column": 35
            },
            "line": 310,
            "code": "    it('changes the scroll position', async () => {\n      const element = buildTextEditorElement();\n      element.getModel().update({\n        autoHeight: false\n      });\n      element.getModel().setText('lorem\\nipsum\\ndolor\\nsit\\namet');\n      element.setHeight(20);\n      await element.getNextUpdatePromise();\n      element.setWidth(20);\n      await element.getNextUpdatePromise();\n      element.setScrollTop(22);\n      await element.getNextUpdatePromise();\n      expect(element.getScrollTop()).toBe(22);\n      element.setScrollLeft(32);\n      await element.getNextUpdatePromise();\n      expect(element.getScrollLeft()).toBe(32);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "changes the element's 'mini' attribute",
            "suites": [
                "TextEditorElement",
                "on TextEditor::setMini"
            ],
            "updatePoint": {
                "line": 328,
                "column": 85
            },
            "line": 328,
            "code": "  describe('on TextEditor::setMini', () => it(\"changes the element's 'mini' attribute\", async () => {\n    const element = buildTextEditorElement();\n    expect(element.hasAttribute('mini')).toBe(false);\n    element.getModel().setMini(true);\n    await element.getNextUpdatePromise();\n    expect(element.hasAttribute('mini')).toBe(true);\n    element.getModel().setMini(false);\n    await element.getNextUpdatePromise();\n    expect(element.hasAttribute('mini')).toBe(false);\n  }));",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true if the given row range intersects the visible row range",
            "suites": [
                "TextEditorElement",
                "::intersectsVisibleRowRange(start, end)"
            ],
            "updatePoint": {
                "line": 339,
                "column": 76
            },
            "line": 339,
            "code": "    it('returns true if the given row range intersects the visible row range', async () => {\n      const element = buildTextEditorElement();\n      const editor = element.getModel();\n      const horizontalScrollbarHeight = element.component.getHorizontalScrollbarHeight();\n      editor.update({\n        autoHeight: false\n      });\n      element.getModel().setText('x\\n'.repeat(20));\n      element.style.height = 120 + horizontalScrollbarHeight + 'px';\n      await element.getNextUpdatePromise();\n      element.setScrollTop(80);\n      await element.getNextUpdatePromise();\n      expect(element.getVisibleRowRange()).toEqual([4, 11]);\n      expect(element.intersectsVisibleRowRange(0, 4)).toBe(false);\n      expect(element.intersectsVisibleRowRange(0, 5)).toBe(true);\n      expect(element.intersectsVisibleRowRange(5, 8)).toBe(true);\n      expect(element.intersectsVisibleRowRange(11, 12)).toBe(false);\n      expect(element.intersectsVisibleRowRange(12, 13)).toBe(false);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a {top/left/width/height} object describing the rectangle between two screen positions, even if they are not on screen",
            "suites": [
                "TextEditorElement",
                "::pixelRectForScreenRange(range)"
            ],
            "updatePoint": {
                "line": 360,
                "column": 134
            },
            "line": 360,
            "code": "    it('returns a {top/left/width/height} object describing the rectangle between two screen positions, even if they are not on screen', async () => {\n      const element = buildTextEditorElement();\n      const editor = element.getModel();\n      const horizontalScrollbarHeight = element.component.getHorizontalScrollbarHeight();\n      editor.update({\n        autoHeight: false\n      });\n      element.getModel().setText('xxxxxxxxxxxxxxxxxxxxxx\\n'.repeat(20));\n      element.style.height = 120 + horizontalScrollbarHeight + 'px';\n      await element.getNextUpdatePromise();\n      element.setScrollTop(80);\n      await element.getNextUpdatePromise();\n      expect(element.getVisibleRowRange()).toEqual([4, 11]);\n      const top = 2 * editor.getLineHeightInPixels();\n      const bottom = 13 * editor.getLineHeightInPixels();\n      const left = Math.round(3 * editor.getDefaultCharWidth());\n      const right = Math.round(11 * editor.getDefaultCharWidth());\n      const pixelRect = element.pixelRectForScreenRange([[2, 3], [13, 11]]);\n      expect(pixelRect.top).toEqual(top);\n      expect(pixelRect.left).toEqual(left);\n      expect(pixelRect.height).toEqual(bottom + editor.getLineHeightInPixels() - top);\n      expect(pixelRect.width).toBeNear(right - left);\n    });",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "triggers even when subscribing before attaching the element",
            "suites": [
                "TextEditorElement",
                "events",
                "::onDidChangeScrollTop(callback)"
            ],
            "updatePoint": {
                "line": 397,
                "column": 118
            },
            "line": 397,
            "code": "    describe('::onDidChangeScrollTop(callback)', () => it('triggers even when subscribing before attaching the element', () => {\n      const positions = [];\n      const subscription1 = element.onDidChangeScrollTop(p => positions.push(p));\n      element.onDidChangeScrollTop(p => positions.push(p));\n      positions.length = 0;\n      element.setScrollTop(10);\n      expect(positions).toEqual([10, 10]);\n      element.remove();\n      jasmine.attachToDOM(element);\n      positions.length = 0;\n      element.setScrollTop(20);\n      expect(positions).toEqual([20, 20]);\n      subscription1.dispose();\n      positions.length = 0;\n      element.setScrollTop(30);\n      expect(positions).toEqual([30]);\n    }));",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "triggers even when subscribing before attaching the element",
            "suites": [
                "TextEditorElement",
                "events",
                "::onDidChangeScrollLeft(callback)"
            ],
            "updatePoint": {
                "line": 414,
                "column": 119
            },
            "line": 414,
            "code": "    describe('::onDidChangeScrollLeft(callback)', () => it('triggers even when subscribing before attaching the element', () => {\n      const positions = [];\n      const subscription1 = element.onDidChangeScrollLeft(p => positions.push(p));\n      element.onDidChangeScrollLeft(p => positions.push(p));\n      positions.length = 0;\n      element.setScrollLeft(10);\n      expect(positions).toEqual([10, 10]);\n      element.remove();\n      jasmine.attachToDOM(element);\n      positions.length = 0;\n      element.setScrollLeft(20);\n      expect(positions).toEqual([20, 20]);\n      subscription1.dispose();\n      positions.length = 0;\n      element.setScrollLeft(30);\n      expect(positions).toEqual([30]);\n    }));",
            "file": "text-editor-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds an editor to the list of registered editors",
            "suites": [
                "TextEditorRegistry",
                ".add"
            ],
            "updatePoint": {
                "line": 40,
                "column": 56
            },
            "line": 40,
            "code": "    it('adds an editor to the list of registered editors', function () {\n      registry.add(editor);\n      expect(editor.registered).toBe(true);\n      expect(registry.editors.size).toBe(1);\n      expect(registry.editors.has(editor)).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a Disposable that can unregister the editor",
            "suites": [
                "TextEditorRegistry",
                ".add"
            ],
            "updatePoint": {
                "line": 46,
                "column": 59
            },
            "line": 46,
            "code": "    it('returns a Disposable that can unregister the editor', function () {\n      const disposable = registry.add(editor);\n      expect(registry.editors.size).toBe(1);\n      disposable.dispose();\n      expect(registry.editors.size).toBe(0);\n      expect(editor.registered).toBe(false);\n      expect(retainedEditorCount(registry)).toBe(0);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the callback for current and future editors until unsubscribed",
            "suites": [
                "TextEditorRegistry",
                ".observe"
            ],
            "updatePoint": {
                "line": 56,
                "column": 76
            },
            "line": 56,
            "code": "    it('calls the callback for current and future editors until unsubscribed', function () {\n      const spy = jasmine.createSpy();\n      const [editor1, editor2, editor3] = [{}, {}, {}];\n      registry.add(editor1);\n      const subscription = registry.observe(spy);\n      expect(spy.calls.length).toBe(1);\n      registry.add(editor2);\n      expect(spy.calls.length).toBe(2);\n      expect(spy.argsForCall[0][0]).toBe(editor1);\n      expect(spy.argsForCall[1][0]).toBe(editor2);\n      subscription.dispose();\n      registry.add(editor3);\n      expect(spy.calls.length).toBe(2);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "constructs a TextEditor with the right parameters based on its path and text",
            "suites": [
                "TextEditorRegistry",
                ".build"
            ],
            "updatePoint": {
                "line": 72,
                "column": 84
            },
            "line": 72,
            "code": "    it('constructs a TextEditor with the right parameters based on its path and text', function () {\n      atom.config.set('editor.tabLength', 8, {\n        scope: '.source.js'\n      });\n      const languageMode = {\n        grammar: NullGrammar,\n        onDidChangeHighlighting: jasmine.createSpy()\n      };\n      const buffer = new TextBuffer({\n        filePath: 'test.js'\n      });\n      buffer.setLanguageMode(languageMode);\n      const editor = registry.build({\n        buffer\n      });\n      expect(editor.getTabLength()).toBe(8);\n      expect(editor.getGrammar()).toEqual(NullGrammar);\n      expect(languageMode.onDidChangeHighlighting.calls.length).toBe(1);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gets the currently focused text editor",
            "suites": [
                "TextEditorRegistry",
                ".getActiveTextEditor"
            ],
            "updatePoint": {
                "line": 93,
                "column": 46
            },
            "line": 93,
            "code": "    it('gets the currently focused text editor', function () {\n      const disposable = registry.add(editor);\n      var editorElement = editor.getElement();\n      jasmine.attachToDOM(editorElement);\n      editorElement.focus();\n      expect(registry.getActiveTextEditor()).toBe(editor);\n      disposable.dispose();\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not update the editor when config settings change for unrelated scope selectors",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)"
            ],
            "updatePoint": {
                "line": 103,
                "column": 92
            },
            "line": 103,
            "code": "    it('does not update the editor when config settings change for unrelated scope selectors', async function () {\n      await atom.packages.activatePackage('language-javascript');\n      const editor2 = new TextEditor();\n      atom.grammars.assignLanguageMode(editor2, 'source.js');\n      registry.maintainConfig(editor);\n      registry.maintainConfig(editor2);\n      await initialPackageActivation;\n      expect(editor.getRootScopeDescriptor().getScopesArray()).toEqual(['text.plain.null-grammar']);\n      expect(editor2.getRootScopeDescriptor().getScopesArray()).toEqual(['source.js']);\n      expect(editor.getEncoding()).toBe('utf8');\n      expect(editor2.getEncoding()).toBe('utf8');\n      atom.config.set('core.fileEncoding', 'utf16le', {\n        scopeSelector: '.text.plain.null-grammar'\n      });\n      atom.config.set('core.fileEncoding', 'utf16be', {\n        scopeSelector: '.source.js'\n      });\n      expect(editor.getEncoding()).toBe('utf16le');\n      expect(editor2.getEncoding()).toBe('utf16be');\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not update the editor before the initial packages have loaded",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)"
            ],
            "updatePoint": {
                "line": 123,
                "column": 74
            },
            "line": 123,
            "code": "    it('does not update the editor before the initial packages have loaded', async function () {\n      let resolveActivatePromise;\n      initialPackageActivation = new Promise(resolve => {\n        resolveActivatePromise = resolve;\n      });\n      atom.config.set('core.fileEncoding', 'utf16le');\n      registry.maintainConfig(editor);\n      await Promise.resolve();\n      expect(editor.getEncoding()).toBe('utf8');\n      atom.config.set('core.fileEncoding', 'utf16be');\n      await Promise.resolve();\n      expect(editor.getEncoding()).toBe('utf8');\n      resolveActivatePromise();\n      await initialPackageActivation;\n      expect(editor.getEncoding()).toBe('utf16be');\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the editor's settings when its grammar changes",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)"
            ],
            "updatePoint": {
                "line": 139,
                "column": 62
            },
            "line": 139,
            "code": "    it(\"updates the editor's settings when its grammar changes\", async function () {\n      await atom.packages.activatePackage('language-javascript');\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      atom.config.set('core.fileEncoding', 'utf16be', {\n        scopeSelector: '.source.js'\n      });\n      expect(editor.getEncoding()).toBe('utf8');\n      atom.config.set('core.fileEncoding', 'utf16le', {\n        scopeSelector: '.source.js'\n      });\n      expect(editor.getEncoding()).toBe('utf8');\n      atom.grammars.assignLanguageMode(editor, 'source.js');\n      await initialPackageActivation;\n      expect(editor.getEncoding()).toBe('utf16le');\n      atom.config.set('core.fileEncoding', 'utf16be', {\n        scopeSelector: '.source.js'\n      });\n      expect(editor.getEncoding()).toBe('utf16be');\n      atom.grammars.assignLanguageMode(editor, 'text.plain.null-grammar');\n      await initialPackageActivation;\n      expect(editor.getEncoding()).toBe('utf8');\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "preserves editor settings that haven't changed between previous and current language modes",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)"
            ],
            "updatePoint": {
                "line": 162,
                "column": 98
            },
            "line": 162,
            "code": "    it(\"preserves editor settings that haven't changed between previous and current language modes\", async function () {\n      await atom.packages.activatePackage('language-javascript');\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getEncoding()).toBe('utf8');\n      editor.setEncoding('utf16le');\n      expect(editor.getEncoding()).toBe('utf16le');\n      expect(editor.isSoftWrapped()).toBe(false);\n      editor.setSoftWrapped(true);\n      expect(editor.isSoftWrapped()).toBe(true);\n      atom.grammars.assignLanguageMode(editor, 'source.js');\n      await initialPackageActivation;\n      expect(editor.getEncoding()).toBe('utf16le');\n      expect(editor.isSoftWrapped()).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates editor settings that have changed between previous and current language modes",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)"
            ],
            "updatePoint": {
                "line": 177,
                "column": 93
            },
            "line": 177,
            "code": "    it('updates editor settings that have changed between previous and current language modes', async function () {\n      await atom.packages.activatePackage('language-javascript');\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getEncoding()).toBe('utf8');\n      atom.config.set('core.fileEncoding', 'utf16be', {\n        scopeSelector: '.text.plain.null-grammar'\n      });\n      atom.config.set('core.fileEncoding', 'utf16le', {\n        scopeSelector: '.source.js'\n      });\n      expect(editor.getEncoding()).toBe('utf16be');\n      editor.setEncoding('utf8');\n      expect(editor.getEncoding()).toBe('utf8');\n      atom.grammars.assignLanguageMode(editor, 'source.js');\n      await initialPackageActivation;\n      expect(editor.getEncoding()).toBe('utf16le');\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a disposable that can be used to stop the registry from updating the editor's config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)"
            ],
            "updatePoint": {
                "line": 195,
                "column": 100
            },
            "line": 195,
            "code": "    it(\"returns a disposable that can be used to stop the registry from updating the editor's config\", async function () {\n      await atom.packages.activatePackage('language-javascript');\n      const previousSubscriptionCount = getSubscriptionCount(editor);\n      const disposable = registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(getSubscriptionCount(editor)).toBeGreaterThan(previousSubscriptionCount);\n      expect(registry.editorsWithMaintainedConfig.size).toBe(1);\n      atom.config.set('core.fileEncoding', 'utf16be');\n      expect(editor.getEncoding()).toBe('utf16be');\n      atom.config.set('core.fileEncoding', 'utf8');\n      expect(editor.getEncoding()).toBe('utf8');\n      disposable.dispose();\n      atom.config.set('core.fileEncoding', 'utf16be');\n      expect(editor.getEncoding()).toBe('utf8');\n      expect(getSubscriptionCount(editor)).toBe(previousSubscriptionCount);\n      expect(retainedEditorCount(registry)).toBe(0);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the encoding based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)"
            ],
            "updatePoint": {
                "line": 212,
                "column": 45
            },
            "line": 212,
            "code": "    it('sets the encoding based on the config', async function () {\n      editor.update({\n        encoding: 'utf8'\n      });\n      expect(editor.getEncoding()).toBe('utf8');\n      atom.config.set('core.fileEncoding', 'utf16le');\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getEncoding()).toBe('utf16le');\n      atom.config.set('core.fileEncoding', 'utf8');\n      expect(editor.getEncoding()).toBe('utf8');\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the tab length based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)"
            ],
            "updatePoint": {
                "line": 224,
                "column": 47
            },
            "line": 224,
            "code": "    it('sets the tab length based on the config', async function () {\n      editor.update({\n        tabLength: 4\n      });\n      expect(editor.getTabLength()).toBe(4);\n      atom.config.set('editor.tabLength', 8);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getTabLength()).toBe(8);\n      atom.config.set('editor.tabLength', 4);\n      expect(editor.getTabLength()).toBe(4);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables soft tabs when the tabType config setting is \"soft\"",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)"
            ],
            "updatePoint": {
                "line": 236,
                "column": 67
            },
            "line": 236,
            "code": "    it('enables soft tabs when the tabType config setting is \"soft\"', async function () {\n      atom.config.set('editor.tabType', 'soft');\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getSoftTabs()).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "disables soft tabs when the tabType config setting is \"hard\"",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)"
            ],
            "updatePoint": {
                "line": 242,
                "column": 68
            },
            "line": 242,
            "code": "    it('disables soft tabs when the tabType config setting is \"hard\"', async function () {\n      atom.config.set('editor.tabType', 'hard');\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getSoftTabs()).toBe(false);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables soft tabs based on the editor's content",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 249,
                "column": 69
            },
            "line": 249,
            "code": "      it(\"enables or disables soft tabs based on the editor's content\", async function () {\n        await initialPackageActivation;\n        await atom.packages.activatePackage('language-javascript');\n        atom.grammars.assignLanguageMode(editor, 'source.js');\n        atom.config.set('editor.tabType', 'auto');\n        await initialPackageActivation;\n        editor.setText(dedent`\n          {\n            hello;\n          }\n        `);\n        let disposable = registry.maintainConfig(editor);\n        expect(editor.getSoftTabs()).toBe(true);\n        /* eslint-disable no-tabs */\n\n        editor.setText(dedent`\n          {\n          \thello;\n          }\n        `);\n        /* eslint-enable no-tabs */\n\n        disposable.dispose();\n        disposable = registry.maintainConfig(editor);\n        expect(editor.getSoftTabs()).toBe(false);\n        editor.setTextInBufferRange(new Range(Point.ZERO, Point.ZERO), dedent`\n          /*\n           * Comment with a leading space.\n           */\n        ` + '\\n');\n        disposable.dispose();\n        disposable = registry.maintainConfig(editor);\n        expect(editor.getSoftTabs()).toBe(false);\n        /* eslint-disable no-tabs */\n\n        editor.setText(dedent`\n          /*\n           * Comment with a leading space.\n           */\n\n          {\n          \thello;\n          }\n        `);\n        /* eslint-enable no-tabs */\n\n        disposable.dispose();\n        disposable = registry.maintainConfig(editor);\n        expect(editor.getSoftTabs()).toBe(false);\n        editor.setText(dedent`\n          /*\n           * Comment with a leading space.\n           */\n\n          {\n            hello;\n          }\n        `);\n        disposable.dispose();\n        disposable = registry.maintainConfig(editor);\n        expect(editor.getSoftTabs()).toBe(true);\n      });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables soft tabs based on the \"softTabs\" config setting",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 313,
                "column": 78
            },
            "line": 313,
            "code": "      it('enables or disables soft tabs based on the \"softTabs\" config setting', async function () {\n        registry.maintainConfig(editor);\n        await initialPackageActivation;\n        editor.setText('abc\\ndef');\n        atom.config.set('editor.softTabs', true);\n        atom.config.set('editor.tabType', 'auto');\n        expect(editor.getSoftTabs()).toBe(true);\n        atom.config.set('editor.softTabs', false);\n        expect(editor.getSoftTabs()).toBe(false);\n      });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables soft tabs based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 324,
                "column": 57
            },
            "line": 324,
            "code": "    it('enables or disables soft tabs based on the config', async function () {\n      editor.update({\n        softTabs: true\n      });\n      expect(editor.getSoftTabs()).toBe(true);\n      atom.config.set('editor.tabType', 'hard');\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getSoftTabs()).toBe(false);\n      atom.config.set('editor.tabType', 'soft');\n      expect(editor.getSoftTabs()).toBe(true);\n      atom.config.set('editor.tabType', 'auto');\n      atom.config.set('editor.softTabs', true);\n      expect(editor.getSoftTabs()).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables atomic soft tabs based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 339,
                "column": 64
            },
            "line": 339,
            "code": "    it('enables or disables atomic soft tabs based on the config', async function () {\n      editor.update({\n        atomicSoftTabs: true\n      });\n      expect(editor.hasAtomicSoftTabs()).toBe(true);\n      atom.config.set('editor.atomicSoftTabs', false);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.hasAtomicSoftTabs()).toBe(false);\n      atom.config.set('editor.atomicSoftTabs', true);\n      expect(editor.hasAtomicSoftTabs()).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables cursor on selection visibility based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 351,
                "column": 78
            },
            "line": 351,
            "code": "    it('enables or disables cursor on selection visibility based on the config', async function () {\n      editor.update({\n        showCursorOnSelection: true\n      });\n      expect(editor.getShowCursorOnSelection()).toBe(true);\n      atom.config.set('editor.showCursorOnSelection', false);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getShowCursorOnSelection()).toBe(false);\n      atom.config.set('editor.showCursorOnSelection', true);\n      expect(editor.getShowCursorOnSelection()).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables line numbers based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 363,
                "column": 60
            },
            "line": 363,
            "code": "    it('enables or disables line numbers based on the config', async function () {\n      editor.update({\n        showLineNumbers: true\n      });\n      expect(editor.showLineNumbers).toBe(true);\n      atom.config.set('editor.showLineNumbers', false);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.showLineNumbers).toBe(false);\n      atom.config.set('editor.showLineNumbers', true);\n      expect(editor.showLineNumbers).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the invisibles based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 375,
                "column": 47
            },
            "line": 375,
            "code": "    it('sets the invisibles based on the config', async function () {\n      const invisibles1 = {\n        tab: 'a',\n        cr: false,\n        eol: false,\n        space: false\n      };\n      const invisibles2 = {\n        tab: 'b',\n        cr: false,\n        eol: false,\n        space: false\n      };\n      editor.update({\n        showInvisibles: true,\n        invisibles: invisibles1\n      });\n      expect(editor.getInvisibles()).toEqual(invisibles1);\n      atom.config.set('editor.showInvisibles', true);\n      atom.config.set('editor.invisibles', invisibles2);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getInvisibles()).toEqual(invisibles2);\n      atom.config.set('editor.invisibles', invisibles1);\n      expect(editor.getInvisibles()).toEqual(invisibles1);\n      atom.config.set('editor.showInvisibles', false);\n      expect(editor.getInvisibles()).toEqual({});\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables the indent guide based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 403,
                "column": 64
            },
            "line": 403,
            "code": "    it('enables or disables the indent guide based on the config', async function () {\n      editor.update({\n        showIndentGuide: true\n      });\n      expect(editor.doesShowIndentGuide()).toBe(true);\n      atom.config.set('editor.showIndentGuide', false);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.doesShowIndentGuide()).toBe(false);\n      atom.config.set('editor.showIndentGuide', true);\n      expect(editor.doesShowIndentGuide()).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables soft wrap based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 415,
                "column": 57
            },
            "line": 415,
            "code": "    it('enables or disables soft wrap based on the config', async function () {\n      editor.update({\n        softWrapped: true\n      });\n      expect(editor.isSoftWrapped()).toBe(true);\n      atom.config.set('editor.softWrap', false);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.isSoftWrapped()).toBe(false);\n      atom.config.set('editor.softWrap', true);\n      expect(editor.isSoftWrapped()).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the soft wrap indent length based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 427,
                "column": 60
            },
            "line": 427,
            "code": "    it('sets the soft wrap indent length based on the config', async function () {\n      editor.update({\n        softWrapHangingIndentLength: 4\n      });\n      expect(editor.getSoftWrapHangingIndentLength()).toBe(4);\n      atom.config.set('editor.softWrapHangingIndent', 2);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getSoftWrapHangingIndentLength()).toBe(2);\n      atom.config.set('editor.softWrapHangingIndent', 4);\n      expect(editor.getSoftWrapHangingIndentLength()).toBe(4);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables preferred line length-based soft wrap based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 439,
                "column": 85
            },
            "line": 439,
            "code": "    it('enables or disables preferred line length-based soft wrap based on the config', async function () {\n      editor.update({\n        softWrapped: true,\n        preferredLineLength: 80,\n        editorWidthInChars: 120,\n        softWrapAtPreferredLineLength: true\n      });\n      expect(editor.getSoftWrapColumn()).toBe(80);\n      atom.config.set('editor.softWrap', true);\n      atom.config.set('editor.softWrapAtPreferredLineLength', false);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getSoftWrapColumn()).toBe(120);\n      atom.config.set('editor.softWrapAtPreferredLineLength', true);\n      expect(editor.getSoftWrapColumn()).toBe(80);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows for custom definition of maximum soft wrap based on config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 455,
                "column": 73
            },
            "line": 455,
            "code": "    it('allows for custom definition of maximum soft wrap based on config', async function () {\n      editor.update({\n        softWrapped: false,\n        maxScreenLineLength: 1500\n      });\n      expect(editor.getSoftWrapColumn()).toBe(1500);\n      atom.config.set('editor.softWrap', false);\n      atom.config.set('editor.maxScreenLineLength', 500);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getSoftWrapColumn()).toBe(500);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the preferred line length based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 467,
                "column": 58
            },
            "line": 467,
            "code": "    it('sets the preferred line length based on the config', async function () {\n      editor.update({\n        preferredLineLength: 80\n      });\n      expect(editor.getPreferredLineLength()).toBe(80);\n      atom.config.set('editor.preferredLineLength', 110);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getPreferredLineLength()).toBe(110);\n      atom.config.set('editor.preferredLineLength', 80);\n      expect(editor.getPreferredLineLength()).toBe(80);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables auto-indent based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 479,
                "column": 59
            },
            "line": 479,
            "code": "    it('enables or disables auto-indent based on the config', async function () {\n      editor.update({\n        autoIndent: true\n      });\n      expect(editor.shouldAutoIndent()).toBe(true);\n      atom.config.set('editor.autoIndent', false);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.shouldAutoIndent()).toBe(false);\n      atom.config.set('editor.autoIndent', true);\n      expect(editor.shouldAutoIndent()).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables auto-indent-on-paste based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 491,
                "column": 68
            },
            "line": 491,
            "code": "    it('enables or disables auto-indent-on-paste based on the config', async function () {\n      editor.update({\n        autoIndentOnPaste: true\n      });\n      expect(editor.shouldAutoIndentOnPaste()).toBe(true);\n      atom.config.set('editor.autoIndentOnPaste', false);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.shouldAutoIndentOnPaste()).toBe(false);\n      atom.config.set('editor.autoIndentOnPaste', true);\n      expect(editor.shouldAutoIndentOnPaste()).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "enables or disables scrolling past the end of the buffer based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 503,
                "column": 84
            },
            "line": 503,
            "code": "    it('enables or disables scrolling past the end of the buffer based on the config', async function () {\n      editor.update({\n        scrollPastEnd: true\n      });\n      expect(editor.getScrollPastEnd()).toBe(true);\n      atom.config.set('editor.scrollPastEnd', false);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getScrollPastEnd()).toBe(false);\n      atom.config.set('editor.scrollPastEnd', true);\n      expect(editor.getScrollPastEnd()).toBe(true);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the undo grouping interval based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 515,
                "column": 59
            },
            "line": 515,
            "code": "    it('sets the undo grouping interval based on the config', async function () {\n      editor.update({\n        undoGroupingInterval: 300\n      });\n      expect(editor.getUndoGroupingInterval()).toBe(300);\n      atom.config.set('editor.undoGroupingInterval', 600);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getUndoGroupingInterval()).toBe(600);\n      atom.config.set('editor.undoGroupingInterval', 300);\n      expect(editor.getUndoGroupingInterval()).toBe(300);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the scroll sensitivity based on the config",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when the \"tabType\" config setting is \"auto\""
            ],
            "updatePoint": {
                "line": 527,
                "column": 55
            },
            "line": 527,
            "code": "    it('sets the scroll sensitivity based on the config', async function () {\n      editor.update({\n        scrollSensitivity: 50\n      });\n      expect(editor.getScrollSensitivity()).toBe(50);\n      atom.config.set('editor.scrollSensitivity', 60);\n      registry.maintainConfig(editor);\n      await initialPackageActivation;\n      expect(editor.getScrollSensitivity()).toBe(60);\n      atom.config.set('editor.scrollSensitivity', 70);\n      expect(editor.getScrollSensitivity()).toBe(70);\n    });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing the second time",
            "suites": [
                "TextEditorRegistry",
                ".maintainConfig(editor)",
                "when called twice with a given editor"
            ],
            "updatePoint": {
                "line": 540,
                "column": 38
            },
            "line": 540,
            "code": "      it('does nothing the second time', async function () {\n        editor.update({\n          scrollSensitivity: 50\n        });\n        const disposable1 = registry.maintainConfig(editor);\n        const disposable2 = registry.maintainConfig(editor);\n        await initialPackageActivation;\n        atom.config.set('editor.scrollSensitivity', 60);\n        expect(editor.getScrollSensitivity()).toBe(60);\n        disposable2.dispose();\n        atom.config.set('editor.scrollSensitivity', 70);\n        expect(editor.getScrollSensitivity()).toBe(70);\n        disposable1.dispose();\n        atom.config.set('editor.scrollSensitivity', 80);\n        expect(editor.getScrollSensitivity()).toBe(70);\n      });",
            "file": "text-editor-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "generates unique ids for each editor",
            "suites": [
                "TextEditor"
            ],
            "updatePoint": {
                "line": 34,
                "column": 42
            },
            "line": 34,
            "code": "  it('generates unique ids for each editor', async () => {\n    // Deserialized editors are initialized with the serialized id. We can\n    // initialize an editor with what we expect to be the next id:\n    const deserialized = new TextEditor({\n      id: editor.id + 1\n    });\n    expect(deserialized.id).toEqual(editor.id + 1); // The id generator should skip the id used up by the deserialized one:\n\n    const fresh = new TextEditor();\n    expect(fresh.id).toNotEqual(deserialized.id);\n  });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores selections and folds based on markers in the buffer",
            "suites": [
                "TextEditor",
                "when the editor is deserialized"
            ],
            "updatePoint": {
                "line": 46,
                "column": 68
            },
            "line": 46,
            "code": "    it('restores selections and folds based on markers in the buffer', async () => {\n      editor.setSelectedBufferRange([[1, 2], [3, 4]]);\n      editor.addSelectionForBufferRange([[5, 6], [7, 5]], {\n        reversed: true\n      });\n      editor.foldBufferRow(4);\n      expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n      const buffer2 = await TextBuffer.deserialize(editor.buffer.serialize());\n      const editor2 = TextEditor.deserialize(editor.serialize(), {\n        assert: atom.assert,\n        textEditors: atom.textEditors,\n        project: {\n          bufferForIdSync() {\n            return buffer2;\n          }\n\n        }\n      });\n      expect(editor2.id).toBe(editor.id);\n      expect(editor2.getBuffer().getPath()).toBe(editor.getBuffer().getPath());\n      expect(editor2.getSelectedBufferRanges()).toEqual([[[1, 2], [3, 4]], [[5, 6], [7, 5]]]);\n      expect(editor2.getSelections()[1].isReversed()).toBeTruthy();\n      expect(editor2.isFoldedAtBufferRow(4)).toBeTruthy();\n      editor2.destroy();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the editor's layout configuration",
            "suites": [
                "TextEditor",
                "when the editor is deserialized"
            ],
            "updatePoint": {
                "line": 71,
                "column": 50
            },
            "line": 71,
            "code": "    it(\"restores the editor's layout configuration\", async () => {\n      editor.update({\n        softTabs: true,\n        atomicSoftTabs: false,\n        tabLength: 12,\n        softWrapped: true,\n        softWrapAtPreferredLineLength: true,\n        softWrapHangingIndentLength: 8,\n        invisibles: {\n          space: 'S'\n        },\n        showInvisibles: true,\n        editorWidthInChars: 120\n      }); // Force buffer and display layer to be deserialized as well, rather than\n      // reusing the same buffer instance\n\n      const buffer2 = await TextBuffer.deserialize(editor.buffer.serialize());\n      const editor2 = TextEditor.deserialize(editor.serialize(), {\n        assert: atom.assert,\n        textEditors: atom.textEditors,\n        project: {\n          bufferForIdSync() {\n            return buffer2;\n          }\n\n        }\n      });\n      expect(editor2.getSoftTabs()).toBe(editor.getSoftTabs());\n      expect(editor2.hasAtomicSoftTabs()).toBe(editor.hasAtomicSoftTabs());\n      expect(editor2.getTabLength()).toBe(editor.getTabLength());\n      expect(editor2.getSoftWrapColumn()).toBe(editor.getSoftWrapColumn());\n      expect(editor2.getSoftWrapHangingIndentLength()).toBe(editor.getSoftWrapHangingIndentLength());\n      expect(editor2.getInvisibles()).toEqual(editor.getInvisibles());\n      expect(editor2.getEditorWidthInChars()).toBe(editor.getEditorWidthInChars());\n      expect(editor2.displayLayer.tabLength).toBe(editor2.getTabLength());\n      expect(editor2.displayLayer.softWrapColumn).toBe(editor2.getSoftWrapColumn());\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores buffers with retired IDs",
            "suites": [
                "TextEditor",
                "when the editor is deserialized"
            ],
            "updatePoint": {
                "line": 108,
                "column": 40
            },
            "line": 108,
            "code": "    it('ignores buffers with retired IDs', () => {\n      const editor2 = TextEditor.deserialize(editor.serialize(), {\n        assert: atom.assert,\n        textEditors: atom.textEditors,\n        project: {\n          bufferForIdSync() {\n            return null;\n          }\n\n        }\n      });\n      expect(editor2).toBeNull();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a different editor with the same initial state",
            "suites": [
                "TextEditor",
                ".copy()"
            ],
            "updatePoint": {
                "line": 123,
                "column": 62
            },
            "line": 123,
            "code": "    it('returns a different editor with the same initial state', () => {\n      expect(editor.getAutoHeight()).toBeFalsy();\n      expect(editor.getAutoWidth()).toBeFalsy();\n      expect(editor.getShowCursorOnSelection()).toBeTruthy();\n      const element = editor.getElement();\n      element.setHeight(100);\n      element.setWidth(100);\n      jasmine.attachToDOM(element);\n      editor.update({\n        showCursorOnSelection: false\n      });\n      editor.setSelectedBufferRange([[1, 2], [3, 4]]);\n      editor.addSelectionForBufferRange([[5, 6], [7, 8]], {\n        reversed: true\n      });\n      editor.setScrollTopRow(3);\n      expect(editor.getScrollTopRow()).toBe(3);\n      editor.setScrollLeftColumn(4);\n      expect(editor.getScrollLeftColumn()).toBe(4);\n      editor.foldBufferRow(4);\n      expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n      const editor2 = editor.copy();\n      const element2 = editor2.getElement();\n      element2.setHeight(100);\n      element2.setWidth(100);\n      jasmine.attachToDOM(element2);\n      expect(editor2.id).not.toBe(editor.id);\n      expect(editor2.getSelectedBufferRanges()).toEqual(editor.getSelectedBufferRanges());\n      expect(editor2.getSelections()[1].isReversed()).toBeTruthy();\n      expect(editor2.getScrollTopRow()).toBe(3);\n      expect(editor2.getScrollLeftColumn()).toBe(4);\n      expect(editor2.isFoldedAtBufferRow(4)).toBeTruthy();\n      expect(editor2.getAutoWidth()).toBe(false);\n      expect(editor2.getAutoHeight()).toBe(false);\n      expect(editor2.getShowCursorOnSelection()).toBeFalsy(); // editor2 can now diverge from its origin edit session\n\n      editor2.getLastSelection().setBufferRange([[2, 1], [4, 3]]);\n      expect(editor2.getSelectedBufferRanges()).not.toEqual(editor.getSelectedBufferRanges());\n      editor2.unfoldBufferRow(4);\n      expect(editor2.isFoldedAtBufferRow(4)).not.toBe(editor.isFoldedAtBufferRow(4));\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the editor with the supplied config parameters",
            "suites": [
                "TextEditor",
                ".update()"
            ],
            "updatePoint": {
                "line": 166,
                "column": 62
            },
            "line": 166,
            "code": "    it('updates the editor with the supplied config parameters', () => {\n      let changeSpy;\n      const {\n        element\n      } = editor; // force element initialization\n\n      element.setUpdatedSynchronously(false);\n      editor.update({\n        showInvisibles: true\n      });\n      editor.onDidChange(changeSpy = jasmine.createSpy('onDidChange'));\n      const returnedPromise = editor.update({\n        tabLength: 6,\n        softTabs: false,\n        softWrapped: true,\n        editorWidthInChars: 40,\n        showInvisibles: false,\n        mini: false,\n        lineNumberGutterVisible: false,\n        scrollPastEnd: true,\n        autoHeight: false,\n        maxScreenLineLength: 1000\n      });\n      expect(returnedPromise).toBe(element.component.getNextUpdatePromise());\n      expect(changeSpy.callCount).toBe(1);\n      expect(editor.getTabLength()).toBe(6);\n      expect(editor.getSoftTabs()).toBe(false);\n      expect(editor.isSoftWrapped()).toBe(true);\n      expect(editor.getEditorWidthInChars()).toBe(40);\n      expect(editor.getInvisibles()).toEqual({});\n      expect(editor.isMini()).toBe(false);\n      expect(editor.isLineNumberGutterVisible()).toBe(false);\n      expect(editor.getScrollPastEnd()).toBe(true);\n      expect(editor.getAutoHeight()).toBe(false);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the basename of the buffer's path as its title, or 'untitled' if the path is undefined",
            "suites": [
                "TextEditor",
                "title",
                ".getTitle()"
            ],
            "updatePoint": {
                "line": 204,
                "column": 101
            },
            "line": 204,
            "code": "      it(\"uses the basename of the buffer's path as its title, or 'untitled' if the path is undefined\", () => {\n        expect(editor.getTitle()).toBe('sample.js');\n        buffer.setPath(undefined);\n        expect(editor.getTitle()).toBe('untitled');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns file name when there is no opened file with identical name",
            "suites": [
                "TextEditor",
                "title",
                ".getLongTitle()"
            ],
            "updatePoint": {
                "line": 211,
                "column": 76
            },
            "line": 211,
            "code": "      it('returns file name when there is no opened file with identical name', () => {\n        expect(editor.getLongTitle()).toBe('sample.js');\n        buffer.setPath(undefined);\n        expect(editor.getLongTitle()).toBe('untitled');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns '<filename> — <parent-directory>' when opened files have identical file names",
            "suites": [
                "TextEditor",
                "title",
                ".getLongTitle()"
            ],
            "updatePoint": {
                "line": 216,
                "column": 95
            },
            "line": 216,
            "code": "      it(\"returns '<filename> — <parent-directory>' when opened files have identical file names\", async () => {\n        const editor1 = await atom.workspace.open(path.join('sample-theme-1', 'readme'));\n        const editor2 = await atom.workspace.open(path.join('sample-theme-2', 'readme'));\n        expect(editor1.getLongTitle()).toBe('readme \\u2014 sample-theme-1');\n        expect(editor2.getLongTitle()).toBe('readme \\u2014 sample-theme-2');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns '<filename> — <parent-directories>' when opened files have identical file names in subdirectories",
            "suites": [
                "TextEditor",
                "title",
                ".getLongTitle()"
            ],
            "updatePoint": {
                "line": 222,
                "column": 115
            },
            "line": 222,
            "code": "      it(\"returns '<filename> — <parent-directories>' when opened files have identical file names in subdirectories\", async () => {\n        const path1 = path.join('sample-theme-1', 'src', 'js');\n        const path2 = path.join('sample-theme-2', 'src', 'js');\n        const editor1 = await atom.workspace.open(path.join(path1, 'main.js'));\n        const editor2 = await atom.workspace.open(path.join(path2, 'main.js'));\n        expect(editor1.getLongTitle()).toBe(`main.js \\u2014 ${path1}`);\n        expect(editor2.getLongTitle()).toBe(`main.js \\u2014 ${path2}`);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns '<filename> — <parent-directories>' when opened files have identical file and same parent dir name",
            "suites": [
                "TextEditor",
                "title",
                ".getLongTitle()"
            ],
            "updatePoint": {
                "line": 230,
                "column": 116
            },
            "line": 230,
            "code": "      it(\"returns '<filename> — <parent-directories>' when opened files have identical file and same parent dir name\", async () => {\n        const editor1 = await atom.workspace.open(path.join('sample-theme-2', 'src', 'js', 'main.js'));\n        const editor2 = await atom.workspace.open(path.join('sample-theme-2', 'src', 'js', 'plugin', 'main.js'));\n        expect(editor1.getLongTitle()).toBe('main.js \\u2014 js');\n        expect(editor2.getLongTitle()).toBe(`main.js \\u2014 ${path.join('js', 'plugin')}`);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the filename when the editor is not in the workspace",
            "suites": [
                "TextEditor",
                "title",
                ".getLongTitle()"
            ],
            "updatePoint": {
                "line": 236,
                "column": 70
            },
            "line": 236,
            "code": "      it('returns the filename when the editor is not in the workspace', async () => {\n        editor.onDidDestroy(() => {\n          expect(editor.getLongTitle()).toBe('sample.js');\n        });\n        await atom.workspace.getActivePane().close();\n        expect(editor.isDestroyed()).toBe(true);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies ::onDidChangeTitle observers when the underlying buffer path changes",
            "suites": [
                "TextEditor",
                "title",
                ".getLongTitle()"
            ],
            "updatePoint": {
                "line": 244,
                "column": 85
            },
            "line": 244,
            "code": "    it('notifies ::onDidChangeTitle observers when the underlying buffer path changes', () => {\n      const observed = [];\n      editor.onDidChangeTitle(title => observed.push(title));\n      buffer.setPath('/foo/bar/baz.txt');\n      buffer.setPath(undefined);\n      expect(observed).toEqual(['baz.txt', 'untitled']);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies ::onDidChangePath observers when the underlying buffer path changes",
            "suites": [
                "TextEditor",
                "path"
            ],
            "updatePoint": {
                "line": 253,
                "column": 84
            },
            "line": 253,
            "code": "    it('notifies ::onDidChangePath observers when the underlying buffer path changes', () => {\n      const observed = [];\n      editor.onDidChangePath(filePath => observed.push(filePath));\n      buffer.setPath(__filename);\n      buffer.setPath(undefined);\n      expect(observed).toEqual([__filename, undefined]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies ::onDidChangeEncoding observers when the editor encoding changes",
            "suites": [
                "TextEditor",
                "encoding"
            ],
            "updatePoint": {
                "line": 262,
                "column": 81
            },
            "line": 262,
            "code": "    it('notifies ::onDidChangeEncoding observers when the editor encoding changes', () => {\n      const observed = [];\n      editor.onDidChangeEncoding(encoding => observed.push(encoding));\n      editor.setEncoding('utf16le');\n      editor.setEncoding('utf16le');\n      editor.setEncoding('utf16be');\n      editor.setEncoding();\n      editor.setEncoding();\n      expect(observed).toEqual(['utf16le', 'utf16be', 'utf8']);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the most recently created cursor",
            "suites": [
                "TextEditor",
                "cursor",
                ".getLastCursor()"
            ],
            "updatePoint": {
                "line": 275,
                "column": 50
            },
            "line": 275,
            "code": "      it('returns the most recently created cursor', () => {\n        editor.addCursorAtScreenPosition([1, 0]);\n        const lastCursor = editor.addCursorAtScreenPosition([2, 0]);\n        expect(editor.getLastCursor()).toBe(lastCursor);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new cursor at (0, 0) if the last cursor has been destroyed",
            "suites": [
                "TextEditor",
                "cursor",
                ".getLastCursor()"
            ],
            "updatePoint": {
                "line": 280,
                "column": 78
            },
            "line": 280,
            "code": "      it('creates a new cursor at (0, 0) if the last cursor has been destroyed', () => {\n        editor.getLastCursor().destroy();\n        expect(editor.getLastCursor().getBufferPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new cursor at (0, 0) if the last cursor has been destroyed",
            "suites": [
                "TextEditor",
                "cursor",
                ".getCursors()"
            ],
            "updatePoint": {
                "line": 286,
                "column": 78
            },
            "line": 286,
            "code": "      it('creates a new cursor at (0, 0) if the last cursor has been destroyed', () => {\n        editor.getLastCursor().destroy();\n        expect(editor.getCursors()[0].getBufferPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears a goal column established by vertical movement",
            "suites": [
                "TextEditor",
                "cursor",
                "when the cursor moves"
            ],
            "updatePoint": {
                "line": 292,
                "column": 63
            },
            "line": 292,
            "code": "      it('clears a goal column established by vertical movement', () => {\n        editor.setText('b');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.insertNewline();\n        editor.moveUp();\n        editor.insertText('a');\n        editor.moveDown();\n        expect(editor.getCursorBufferPosition()).toEqual([1, 1]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits an event with the old position, new position, and the cursor that moved",
            "suites": [
                "TextEditor",
                "cursor",
                "when the cursor moves"
            ],
            "updatePoint": {
                "line": 301,
                "column": 87
            },
            "line": 301,
            "code": "      it('emits an event with the old position, new position, and the cursor that moved', () => {\n        const cursorCallback = jasmine.createSpy('cursor-changed-position');\n        const editorCallback = jasmine.createSpy('editor-changed-cursor-position');\n        editor.getLastCursor().onDidChangePosition(cursorCallback);\n        editor.onDidChangeCursorPosition(editorCallback);\n        editor.setCursorBufferPosition([2, 4]);\n        expect(editorCallback).toHaveBeenCalled();\n        expect(cursorCallback).toHaveBeenCalled();\n        const eventObject = editorCallback.mostRecentCall.args[0];\n        expect(cursorCallback.mostRecentCall.args[0]).toEqual(eventObject);\n        expect(eventObject.oldBufferPosition).toEqual([0, 0]);\n        expect(eventObject.oldScreenPosition).toEqual([0, 0]);\n        expect(eventObject.newBufferPosition).toEqual([2, 4]);\n        expect(eventObject.newScreenPosition).toEqual([2, 4]);\n        expect(eventObject.cursor).toBe(editor.getLastCursor());\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears a goal column established by vertical movement",
            "suites": [
                "TextEditor",
                "cursor",
                ".setCursorScreenPosition(screenPosition)"
            ],
            "updatePoint": {
                "line": 319,
                "column": 63
            },
            "line": 319,
            "code": "      it('clears a goal column established by vertical movement', () => {\n        // set a goal column by moving down\n        editor.setCursorScreenPosition({\n          row: 3,\n          column: lineLengths[3]\n        });\n        editor.moveDown();\n        expect(editor.getCursorScreenPosition().column).not.toBe(6); // clear the goal column by explicitly setting the cursor position\n\n        editor.setCursorScreenPosition([4, 6]);\n        expect(editor.getCursorScreenPosition().column).toBe(6);\n        editor.moveDown();\n        expect(editor.getCursorScreenPosition().column).toBe(6);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges multiple cursors",
            "suites": [
                "TextEditor",
                "cursor",
                ".setCursorScreenPosition(screenPosition)"
            ],
            "updatePoint": {
                "line": 333,
                "column": 33
            },
            "line": 333,
            "code": "      it('merges multiple cursors', () => {\n        editor.setCursorScreenPosition([0, 0]);\n        editor.addCursorAtScreenPosition([0, 1]);\n        const [cursor1] = editor.getCursors();\n        editor.setCursorScreenPosition([4, 7]);\n        expect(editor.getCursors().length).toBe(1);\n        expect(editor.getCursors()).toEqual([cursor1]);\n        expect(editor.getCursorScreenPosition()).toEqual([4, 7]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "positions the cursor at the buffer position that corresponds to the given screen position",
            "suites": [
                "TextEditor",
                "cursor",
                ".setCursorScreenPosition(screenPosition)",
                "when soft-wrap is enabled and code is folded"
            ],
            "updatePoint": {
                "line": 349,
                "column": 101
            },
            "line": 349,
            "code": "        it('positions the cursor at the buffer position that corresponds to the given screen position', () => {\n          editor.setCursorScreenPosition([9, 0]);\n          expect(editor.getCursorBufferPosition()).toEqual([8, 11]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor up",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveUp()"
            ],
            "updatePoint": {
                "line": 356,
                "column": 29
            },
            "line": 356,
            "code": "      it('moves the cursor up', () => {\n        editor.setCursorScreenPosition([2, 2]);\n        editor.moveUp();\n        expect(editor.getCursorScreenPosition()).toEqual([1, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "retains the goal column across lines of differing length",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveUp()"
            ],
            "updatePoint": {
                "line": 361,
                "column": 66
            },
            "line": 361,
            "code": "      it('retains the goal column across lines of differing length', () => {\n        expect(lineLengths[6]).toBeGreaterThan(32);\n        editor.setCursorScreenPosition({\n          row: 6,\n          column: 32\n        });\n        editor.moveUp();\n        expect(editor.getCursorScreenPosition().column).toBe(lineLengths[5]);\n        editor.moveUp();\n        expect(editor.getCursorScreenPosition().column).toBe(lineLengths[4]);\n        editor.moveUp();\n        expect(editor.getCursorScreenPosition().column).toBe(32);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the beginning of the line, but retains the goal column",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveUp()",
                "when the cursor is on the first line"
            ],
            "updatePoint": {
                "line": 375,
                "column": 86
            },
            "line": 375,
            "code": "        it('moves the cursor to the beginning of the line, but retains the goal column', () => {\n          editor.setCursorScreenPosition([0, 4]);\n          editor.moveUp();\n          expect(editor.getCursorScreenPosition()).toEqual([0, 0]);\n          editor.moveDown();\n          expect(editor.getCursorScreenPosition()).toEqual([1, 4]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves above the selection",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveUp()",
                "when there is a selection"
            ],
            "updatePoint": {
                "line": 385,
                "column": 37
            },
            "line": 385,
            "code": "        it('moves above the selection', () => {\n          const cursor = editor.getLastCursor();\n          editor.moveUp();\n          expect(cursor.getBufferPosition()).toEqual([3, 9]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges cursors when they overlap",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveUp()",
                "when there is a selection"
            ],
            "updatePoint": {
                "line": 391,
                "column": 42
            },
            "line": 391,
            "code": "      it('merges cursors when they overlap', () => {\n        editor.addCursorAtScreenPosition([1, 0]);\n        const [cursor1] = editor.getCursors();\n        editor.moveUp();\n        expect(editor.getCursors()).toEqual([cursor1]);\n        expect(cursor1.getBufferPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves to the beginning of the previous line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveUp()",
                "when the cursor was moved down from the beginning of an indented soft-wrapped line"
            ],
            "updatePoint": {
                "line": 399,
                "column": 55
            },
            "line": 399,
            "code": "        it('moves to the beginning of the previous line', () => {\n          editor.setSoftWrapped(true);\n          editor.setDefaultCharWidth(1);\n          editor.setEditorWidthInChars(50);\n          editor.setCursorScreenPosition([3, 0]);\n          editor.moveDown();\n          editor.moveDown();\n          editor.moveUp();\n          expect(editor.getCursorScreenPosition()).toEqual([4, 4]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor down",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveDown()"
            ],
            "updatePoint": {
                "line": 412,
                "column": 31
            },
            "line": 412,
            "code": "      it('moves the cursor down', () => {\n        editor.setCursorScreenPosition([2, 2]);\n        editor.moveDown();\n        expect(editor.getCursorScreenPosition()).toEqual([3, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "retains the goal column across lines of differing length",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveDown()"
            ],
            "updatePoint": {
                "line": 417,
                "column": 66
            },
            "line": 417,
            "code": "      it('retains the goal column across lines of differing length', () => {\n        editor.setCursorScreenPosition({\n          row: 3,\n          column: lineLengths[3]\n        });\n        editor.moveDown();\n        expect(editor.getCursorScreenPosition().column).toBe(lineLengths[4]);\n        editor.moveDown();\n        expect(editor.getCursorScreenPosition().column).toBe(lineLengths[5]);\n        editor.moveDown();\n        expect(editor.getCursorScreenPosition().column).toBe(lineLengths[3]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the end of line, but retains the goal column when moving back up",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveDown()",
                "when the cursor is on the last line"
            ],
            "updatePoint": {
                "line": 430,
                "column": 96
            },
            "line": 430,
            "code": "        it('moves the cursor to the end of line, but retains the goal column when moving back up', () => {\n          const lastLineIndex = buffer.getLines().length - 1;\n          const lastLine = buffer.lineForRow(lastLineIndex);\n          expect(lastLine.length).toBeGreaterThan(0);\n          editor.setCursorScreenPosition({\n            row: lastLineIndex,\n            column: editor.getTabLength()\n          });\n          editor.moveDown();\n          expect(editor.getCursorScreenPosition()).toEqual({\n            row: lastLineIndex,\n            column: lastLine.length\n          });\n          editor.moveUp();\n          expect(editor.getCursorScreenPosition().column).toBe(editor.getTabLength());\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "retains a goal column of 0 when moving back up",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveDown()",
                "when the cursor is on the last line"
            ],
            "updatePoint": {
                "line": 446,
                "column": 58
            },
            "line": 446,
            "code": "        it('retains a goal column of 0 when moving back up', () => {\n          const lastLineIndex = buffer.getLines().length - 1;\n          const lastLine = buffer.lineForRow(lastLineIndex);\n          expect(lastLine.length).toBeGreaterThan(0);\n          editor.setCursorScreenPosition({\n            row: lastLineIndex,\n            column: 0\n          });\n          editor.moveDown();\n          editor.moveUp();\n          expect(editor.getCursorScreenPosition().column).toBe(0);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves to the beginning of the line's continuation on the next screen row",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveDown()",
                "when the cursor is at the beginning of an indented soft-wrapped line"
            ],
            "updatePoint": {
                "line": 460,
                "column": 84
            },
            "line": 460,
            "code": "        it(\"moves to the beginning of the line's continuation on the next screen row\", () => {\n          editor.setSoftWrapped(true);\n          editor.setDefaultCharWidth(1);\n          editor.setEditorWidthInChars(50);\n          editor.setCursorScreenPosition([3, 0]);\n          editor.moveDown();\n          expect(editor.getCursorScreenPosition()).toEqual([4, 4]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves below the selection",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveDown()",
                "when there is a selection"
            ],
            "updatePoint": {
                "line": 471,
                "column": 37
            },
            "line": 471,
            "code": "        it('moves below the selection', () => {\n          const cursor = editor.getLastCursor();\n          editor.moveDown();\n          expect(cursor.getBufferPosition()).toEqual([6, 10]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges cursors when they overlap",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveDown()",
                "when there is a selection"
            ],
            "updatePoint": {
                "line": 477,
                "column": 42
            },
            "line": 477,
            "code": "      it('merges cursors when they overlap', () => {\n        editor.setCursorScreenPosition([12, 2]);\n        editor.addCursorAtScreenPosition([11, 2]);\n        const [cursor1] = editor.getCursors();\n        editor.moveDown();\n        expect(editor.getCursors()).toEqual([cursor1]);\n        expect(cursor1.getBufferPosition()).toEqual([12, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor by one column to the left",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()"
            ],
            "updatePoint": {
                "line": 487,
                "column": 52
            },
            "line": 487,
            "code": "      it('moves the cursor by one column to the left', () => {\n        editor.setCursorScreenPosition([1, 8]);\n        editor.moveLeft();\n        expect(editor.getCursorScreenPosition()).toEqual([1, 7]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor by n columns to the left",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()"
            ],
            "updatePoint": {
                "line": 492,
                "column": 51
            },
            "line": 492,
            "code": "      it('moves the cursor by n columns to the left', () => {\n        editor.setCursorScreenPosition([1, 8]);\n        editor.moveLeft(4);\n        expect(editor.getCursorScreenPosition()).toEqual([1, 4]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor by two rows up when the columnCount is longer than an entire line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()"
            ],
            "updatePoint": {
                "line": 497,
                "column": 92
            },
            "line": 497,
            "code": "      it('moves the cursor by two rows up when the columnCount is longer than an entire line', () => {\n        editor.setCursorScreenPosition([2, 2]);\n        editor.moveLeft(34);\n        expect(editor.getCursorScreenPosition()).toEqual([0, 29]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the beginning columnCount is longer than the position in the buffer",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()"
            ],
            "updatePoint": {
                "line": 502,
                "column": 97
            },
            "line": 502,
            "code": "      it('moves the cursor to the beginning columnCount is longer than the position in the buffer', () => {\n        editor.setCursorScreenPosition([1, 0]);\n        editor.moveLeft(100);\n        expect(editor.getCursorScreenPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "wraps to the end of the previous line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()",
                "when the cursor is in the first column",
                "when there is a previous line"
            ],
            "updatePoint": {
                "line": 509,
                "column": 51
            },
            "line": 509,
            "code": "          it('wraps to the end of the previous line', () => {\n            editor.setCursorScreenPosition({\n              row: 1,\n              column: 0\n            });\n            editor.moveLeft();\n            expect(editor.getCursorScreenPosition()).toEqual({\n              row: 0,\n              column: buffer.lineForRow(0).length\n            });\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor by one row up and n columns to the left",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()",
                "when the cursor is in the first column",
                "when there is a previous line"
            ],
            "updatePoint": {
                "line": 520,
                "column": 70
            },
            "line": 520,
            "code": "          it('moves the cursor by one row up and n columns to the left', () => {\n            editor.setCursorScreenPosition([1, 0]);\n            editor.moveLeft(4);\n            expect(editor.getCursorScreenPosition()).toEqual([0, 26]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "wraps to the beginning of the previous line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()",
                "when the cursor is in the first column",
                "when the next line is empty"
            ],
            "updatePoint": {
                "line": 527,
                "column": 57
            },
            "line": 527,
            "code": "          it('wraps to the beginning of the previous line', () => {\n            editor.setCursorScreenPosition([11, 0]);\n            editor.moveLeft();\n            expect(editor.getCursorScreenPosition()).toEqual([10, 0]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "wraps to the end of the previous line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()",
                "when the cursor is in the first column",
                "when line is wrapped and follow previous line indentation"
            ],
            "updatePoint": {
                "line": 539,
                "column": 51
            },
            "line": 539,
            "code": "          it('wraps to the end of the previous line', () => {\n            editor.setCursorScreenPosition([4, 4]);\n            editor.moveLeft();\n            expect(editor.getCursorScreenPosition()).toEqual([3, 46]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "remains in the same position (0,0)",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()",
                "when the cursor is in the first column",
                "when the cursor is on the first line"
            ],
            "updatePoint": {
                "line": 546,
                "column": 48
            },
            "line": 546,
            "code": "          it('remains in the same position (0,0)', () => {\n            editor.setCursorScreenPosition({\n              row: 0,\n              column: 0\n            });\n            editor.moveLeft();\n            expect(editor.getCursorScreenPosition()).toEqual({\n              row: 0,\n              column: 0\n            });\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "remains in the same position (0,0) when columnCount is specified",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()",
                "when the cursor is in the first column",
                "when the cursor is on the first line"
            ],
            "updatePoint": {
                "line": 557,
                "column": 78
            },
            "line": 557,
            "code": "          it('remains in the same position (0,0) when columnCount is specified', () => {\n            editor.setCursorScreenPosition([0, 0]);\n            editor.moveLeft(4);\n            expect(editor.getCursorScreenPosition()).toEqual([0, 0]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips tabLength worth of whitespace at a time",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()",
                "when softTabs is enabled and the cursor is preceded by leading whitespace"
            ],
            "updatePoint": {
                "line": 565,
                "column": 57
            },
            "line": 565,
            "code": "        it('skips tabLength worth of whitespace at a time', () => {\n          editor.setCursorBufferPosition([5, 6]);\n          editor.moveLeft();\n          expect(editor.getCursorBufferPosition()).toEqual([5, 4]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves to the left of the selection",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()",
                "when there is a selection"
            ],
            "updatePoint": {
                "line": 573,
                "column": 46
            },
            "line": 573,
            "code": "        it('moves to the left of the selection', () => {\n          const cursor = editor.getLastCursor();\n          editor.moveLeft();\n          expect(cursor.getBufferPosition()).toEqual([5, 22]);\n          editor.moveLeft();\n          expect(cursor.getBufferPosition()).toEqual([5, 21]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges cursors when they overlap",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveLeft()",
                "when there is a selection"
            ],
            "updatePoint": {
                "line": 581,
                "column": 42
            },
            "line": 581,
            "code": "      it('merges cursors when they overlap', () => {\n        editor.setCursorScreenPosition([0, 0]);\n        editor.addCursorAtScreenPosition([0, 1]);\n        const [cursor1] = editor.getCursors();\n        editor.moveLeft();\n        expect(editor.getCursors()).toEqual([cursor1]);\n        expect(cursor1.getBufferPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor by one column to the right",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveRight()"
            ],
            "updatePoint": {
                "line": 591,
                "column": 53
            },
            "line": 591,
            "code": "      it('moves the cursor by one column to the right', () => {\n        editor.setCursorScreenPosition([3, 3]);\n        editor.moveRight();\n        expect(editor.getCursorScreenPosition()).toEqual([3, 4]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor by n columns to the right",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveRight()"
            ],
            "updatePoint": {
                "line": 596,
                "column": 52
            },
            "line": 596,
            "code": "      it('moves the cursor by n columns to the right', () => {\n        editor.setCursorScreenPosition([3, 7]);\n        editor.moveRight(4);\n        expect(editor.getCursorScreenPosition()).toEqual([3, 11]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor by two rows down when the columnCount is longer than an entire line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveRight()"
            ],
            "updatePoint": {
                "line": 601,
                "column": 94
            },
            "line": 601,
            "code": "      it('moves the cursor by two rows down when the columnCount is longer than an entire line', () => {\n        editor.setCursorScreenPosition([0, 29]);\n        editor.moveRight(34);\n        expect(editor.getCursorScreenPosition()).toEqual([2, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the end of the buffer when columnCount is longer than the number of characters following the cursor position",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveRight()"
            ],
            "updatePoint": {
                "line": 606,
                "column": 138
            },
            "line": 606,
            "code": "      it('moves the cursor to the end of the buffer when columnCount is longer than the number of characters following the cursor position', () => {\n        editor.setCursorScreenPosition([11, 5]);\n        editor.moveRight(100);\n        expect(editor.getCursorScreenPosition()).toEqual([12, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "wraps to the beginning of the next line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveRight()",
                "when the cursor is on the last column of a line",
                "when there is a subsequent line"
            ],
            "updatePoint": {
                "line": 613,
                "column": 53
            },
            "line": 613,
            "code": "          it('wraps to the beginning of the next line', () => {\n            editor.setCursorScreenPosition([0, buffer.lineForRow(0).length]);\n            editor.moveRight();\n            expect(editor.getCursorScreenPosition()).toEqual([1, 0]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor by one row down and n columns to the right",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveRight()",
                "when the cursor is on the last column of a line",
                "when there is a subsequent line"
            ],
            "updatePoint": {
                "line": 618,
                "column": 73
            },
            "line": 618,
            "code": "          it('moves the cursor by one row down and n columns to the right', () => {\n            editor.setCursorScreenPosition([0, buffer.lineForRow(0).length]);\n            editor.moveRight(4);\n            expect(editor.getCursorScreenPosition()).toEqual([1, 3]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "wraps to the beginning of the next line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveRight()",
                "when the cursor is on the last column of a line",
                "when the next line is empty"
            ],
            "updatePoint": {
                "line": 625,
                "column": 53
            },
            "line": 625,
            "code": "          it('wraps to the beginning of the next line', () => {\n            editor.setCursorScreenPosition([9, 4]);\n            editor.moveRight();\n            expect(editor.getCursorScreenPosition()).toEqual([10, 0]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "remains in the same position",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveRight()",
                "when the cursor is on the last column of a line",
                "when the cursor is on the last line"
            ],
            "updatePoint": {
                "line": 632,
                "column": 42
            },
            "line": 632,
            "code": "          it('remains in the same position', () => {\n            const lastLineIndex = buffer.getLines().length - 1;\n            const lastLine = buffer.lineForRow(lastLineIndex);\n            expect(lastLine.length).toBeGreaterThan(0);\n            const lastPosition = {\n              row: lastLineIndex,\n              column: lastLine.length\n            };\n            editor.setCursorScreenPosition(lastPosition);\n            editor.moveRight();\n            expect(editor.getCursorScreenPosition()).toEqual(lastPosition);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves to the left of the selection",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveRight()",
                "when there is a selection"
            ],
            "updatePoint": {
                "line": 648,
                "column": 46
            },
            "line": 648,
            "code": "        it('moves to the left of the selection', () => {\n          const cursor = editor.getLastCursor();\n          editor.moveRight();\n          expect(cursor.getBufferPosition()).toEqual([5, 27]);\n          editor.moveRight();\n          expect(cursor.getBufferPosition()).toEqual([5, 28]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges cursors when they overlap",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveRight()",
                "when there is a selection"
            ],
            "updatePoint": {
                "line": 656,
                "column": 42
            },
            "line": 656,
            "code": "      it('merges cursors when they overlap', () => {\n        editor.setCursorScreenPosition([12, 2]);\n        editor.addCursorAtScreenPosition([12, 1]);\n        const [cursor1] = editor.getCursors();\n        editor.moveRight();\n        expect(editor.getCursors()).toEqual([cursor1]);\n        expect(cursor1.getBufferPosition()).toEqual([12, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the top of the buffer",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToTop()"
            ],
            "updatePoint": {
                "line": 666,
                "column": 51
            },
            "line": 666,
            "code": "      it('moves the cursor to the top of the buffer', () => {\n        editor.setCursorScreenPosition([11, 1]);\n        editor.addCursorAtScreenPosition([12, 0]);\n        editor.moveToTop();\n        expect(editor.getCursors().length).toBe(1);\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the bottom of the buffer",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBottom()"
            ],
            "updatePoint": {
                "line": 675,
                "column": 54
            },
            "line": 675,
            "code": "      it('moves the cursor to the bottom of the buffer', () => {\n        editor.setCursorScreenPosition([0, 0]);\n        editor.addCursorAtScreenPosition([1, 0]);\n        editor.moveToBottom();\n        expect(editor.getCursors().length).toBe(1);\n        expect(editor.getCursorBufferPosition()).toEqual([12, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves cursor to the beginning of the screen line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfScreenLine()",
                "when soft wrap is on"
            ],
            "updatePoint": {
                "line": 685,
                "column": 60
            },
            "line": 685,
            "code": "        it('moves cursor to the beginning of the screen line', () => {\n          editor.setSoftWrapped(true);\n          editor.setEditorWidthInChars(10);\n          editor.setCursorScreenPosition([1, 2]);\n          editor.moveToBeginningOfScreenLine();\n          const cursor = editor.getLastCursor();\n          expect(cursor.getScreenPosition()).toEqual([1, 0]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves cursor to the beginning of the line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfScreenLine()",
                "when soft wrap is off"
            ],
            "updatePoint": {
                "line": 695,
                "column": 53
            },
            "line": 695,
            "code": "        it('moves cursor to the beginning of the line', () => {\n          editor.setCursorScreenPosition([0, 5]);\n          editor.addCursorAtScreenPosition([1, 7]);\n          editor.moveToBeginningOfScreenLine();\n          expect(editor.getCursors().length).toBe(2);\n          const [cursor1, cursor2] = editor.getCursors();\n          expect(cursor1.getBufferPosition()).toEqual([0, 0]);\n          expect(cursor2.getBufferPosition()).toEqual([1, 0]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves cursor to the beginning of the screen line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToEndOfScreenLine()",
                "when soft wrap is on"
            ],
            "updatePoint": {
                "line": 708,
                "column": 60
            },
            "line": 708,
            "code": "        it('moves cursor to the beginning of the screen line', () => {\n          editor.setSoftWrapped(true);\n          editor.setDefaultCharWidth(1);\n          editor.setEditorWidthInChars(10);\n          editor.setCursorScreenPosition([1, 2]);\n          editor.moveToEndOfScreenLine();\n          const cursor = editor.getLastCursor();\n          expect(cursor.getScreenPosition()).toEqual([1, 9]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves cursor to the end of line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToEndOfScreenLine()",
                "when soft wrap is off"
            ],
            "updatePoint": {
                "line": 719,
                "column": 43
            },
            "line": 719,
            "code": "        it('moves cursor to the end of line', () => {\n          editor.setCursorScreenPosition([0, 0]);\n          editor.addCursorAtScreenPosition([1, 0]);\n          editor.moveToEndOfScreenLine();\n          expect(editor.getCursors().length).toBe(2);\n          const [cursor1, cursor2] = editor.getCursors();\n          expect(cursor1.getBufferPosition()).toEqual([0, 29]);\n          expect(cursor2.getBufferPosition()).toEqual([1, 30]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves cursor to the beginning of the buffer line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfLine()"
            ],
            "updatePoint": {
                "line": 731,
                "column": 58
            },
            "line": 731,
            "code": "      it('moves cursor to the beginning of the buffer line', () => {\n        editor.setSoftWrapped(true);\n        editor.setDefaultCharWidth(1);\n        editor.setEditorWidthInChars(10);\n        editor.setCursorScreenPosition([1, 2]);\n        editor.moveToBeginningOfLine();\n        const cursor = editor.getLastCursor();\n        expect(cursor.getScreenPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves cursor to the end of the buffer line",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToEndOfLine()"
            ],
            "updatePoint": {
                "line": 742,
                "column": 52
            },
            "line": 742,
            "code": "      it('moves cursor to the end of the buffer line', () => {\n        editor.setSoftWrapped(true);\n        editor.setDefaultCharWidth(1);\n        editor.setEditorWidthInChars(10);\n        editor.setCursorScreenPosition([0, 2]);\n        editor.moveToEndOfLine();\n        const cursor = editor.getLastCursor();\n        expect(cursor.getScreenPosition()).toEqual([4, 4]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves to the first character of the current screen line or the beginning of the screen line if it's already on the first character",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToFirstCharacterOfLine()",
                "when soft wrap is on"
            ],
            "updatePoint": {
                "line": 754,
                "column": 142
            },
            "line": 754,
            "code": "        it(\"moves to the first character of the current screen line or the beginning of the screen line if it's already on the first character\", () => {\n          editor.setSoftWrapped(true);\n          editor.setDefaultCharWidth(1);\n          editor.setEditorWidthInChars(10);\n          editor.setCursorScreenPosition([2, 5]);\n          editor.addCursorAtScreenPosition([8, 7]);\n          editor.moveToFirstCharacterOfLine();\n          const [cursor1, cursor2] = editor.getCursors();\n          expect(cursor1.getScreenPosition()).toEqual([2, 0]);\n          expect(cursor2.getScreenPosition()).toEqual([8, 2]);\n          editor.moveToFirstCharacterOfLine();\n          expect(cursor1.getScreenPosition()).toEqual([2, 0]);\n          expect(cursor2.getScreenPosition()).toEqual([8, 2]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves to the first character of the current line or the beginning of the line if it's already on the first character",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToFirstCharacterOfLine()",
                "when soft wrap is off"
            ],
            "updatePoint": {
                "line": 770,
                "column": 128
            },
            "line": 770,
            "code": "        it(\"moves to the first character of the current line or the beginning of the line if it's already on the first character\", () => {\n          editor.setCursorScreenPosition([0, 5]);\n          editor.addCursorAtScreenPosition([1, 7]);\n          editor.moveToFirstCharacterOfLine();\n          const [cursor1, cursor2] = editor.getCursors();\n          expect(cursor1.getBufferPosition()).toEqual([0, 0]);\n          expect(cursor2.getBufferPosition()).toEqual([1, 2]);\n          editor.moveToFirstCharacterOfLine();\n          expect(cursor1.getBufferPosition()).toEqual([0, 0]);\n          expect(cursor2.getBufferPosition()).toEqual([1, 0]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves to the beginning of the line if it only contains whitespace ",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToFirstCharacterOfLine()",
                "when soft wrap is off"
            ],
            "updatePoint": {
                "line": 781,
                "column": 78
            },
            "line": 781,
            "code": "        it('moves to the beginning of the line if it only contains whitespace ', () => {\n          editor.setText('first\\n    \\nthird');\n          editor.setCursorScreenPosition([1, 2]);\n          editor.moveToFirstCharacterOfLine();\n          const cursor = editor.getLastCursor();\n          expect(cursor.getBufferPosition()).toEqual([1, 0]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves to the first character of the current line without being confused by the invisible characters",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToFirstCharacterOfLine()",
                "when soft wrap is off",
                "when invisible characters are enabled with soft tabs"
            ],
            "updatePoint": {
                "line": 789,
                "column": 113
            },
            "line": 789,
            "code": "          it('moves to the first character of the current line without being confused by the invisible characters', () => {\n            editor.update({\n              showInvisibles: true\n            });\n            editor.setCursorScreenPosition([1, 7]);\n            editor.moveToFirstCharacterOfLine();\n            expect(editor.getCursorBufferPosition()).toEqual([1, 2]);\n            editor.moveToFirstCharacterOfLine();\n            expect(editor.getCursorBufferPosition()).toEqual([1, 0]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves to the first character of the current line without being confused by the invisible characters",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToFirstCharacterOfLine()",
                "when soft wrap is off",
                "when invisible characters are enabled with hard tabs"
            ],
            "updatePoint": {
                "line": 801,
                "column": 113
            },
            "line": 801,
            "code": "          it('moves to the first character of the current line without being confused by the invisible characters', () => {\n            editor.update({\n              showInvisibles: true\n            });\n            buffer.setTextInRange([[1, 0], [1, Infinity]], '\\t\\t\\ta', {\n              normalizeLineEndings: false\n            });\n            editor.setCursorScreenPosition([1, 7]);\n            editor.moveToFirstCharacterOfLine();\n            expect(editor.getCursorBufferPosition()).toEqual([1, 3]);\n            editor.moveToFirstCharacterOfLine();\n            expect(editor.getCursorBufferPosition()).toEqual([1, 0]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears the goal column",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToFirstCharacterOfLine()",
                "when soft wrap is off",
                "when invisible characters are enabled with hard tabs"
            ],
            "updatePoint": {
                "line": 816,
                "column": 32
            },
            "line": 816,
            "code": "      it('clears the goal column', () => {\n        editor.setText('first\\n\\nthird');\n        editor.setCursorScreenPosition([0, 3]);\n        editor.moveDown();\n        editor.moveToFirstCharacterOfLine();\n        editor.moveDown();\n        expect(editor.getCursorBufferPosition()).toEqual([2, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the beginning of the word",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfWord()"
            ],
            "updatePoint": {
                "line": 826,
                "column": 55
            },
            "line": 826,
            "code": "      it('moves the cursor to the beginning of the word', () => {\n        editor.setCursorBufferPosition([0, 8]);\n        editor.addCursorAtBufferPosition([1, 12]);\n        editor.addCursorAtBufferPosition([3, 0]);\n        const [cursor1, cursor2, cursor3] = editor.getCursors();\n        editor.moveToBeginningOfWord();\n        expect(cursor1.getBufferPosition()).toEqual([0, 4]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 11]);\n        expect(cursor3.getBufferPosition()).toEqual([2, 39]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not fail at position [0, 0]",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfWord()"
            ],
            "updatePoint": {
                "line": 836,
                "column": 42
            },
            "line": 836,
            "code": "      it('does not fail at position [0, 0]', () => {\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToBeginningOfWord();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "treats lines with only whitespace as a word",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfWord()"
            ],
            "updatePoint": {
                "line": 840,
                "column": 53
            },
            "line": 840,
            "code": "      it('treats lines with only whitespace as a word', () => {\n        editor.setCursorBufferPosition([11, 0]);\n        editor.moveToBeginningOfWord();\n        expect(editor.getCursorBufferPosition()).toEqual([10, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "treats lines with only whitespace as a word (CRLF line ending)",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfWord()"
            ],
            "updatePoint": {
                "line": 845,
                "column": 72
            },
            "line": 845,
            "code": "      it('treats lines with only whitespace as a word (CRLF line ending)', () => {\n        editor.buffer.setText(buffer.getText().replace(/\\n/g, '\\r\\n'));\n        editor.setCursorBufferPosition([11, 0]);\n        editor.moveToBeginningOfWord();\n        expect(editor.getCursorBufferPosition()).toEqual([10, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works when the current line is blank",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfWord()"
            ],
            "updatePoint": {
                "line": 851,
                "column": 46
            },
            "line": 851,
            "code": "      it('works when the current line is blank', () => {\n        editor.setCursorBufferPosition([10, 0]);\n        editor.moveToBeginningOfWord();\n        expect(editor.getCursorBufferPosition()).toEqual([9, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works when the current line is blank (CRLF line ending)",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfWord()"
            ],
            "updatePoint": {
                "line": 856,
                "column": 65
            },
            "line": 856,
            "code": "      it('works when the current line is blank (CRLF line ending)', () => {\n        editor.buffer.setText(buffer.getText().replace(/\\n/g, '\\r\\n'));\n        editor.setCursorBufferPosition([10, 0]);\n        editor.moveToBeginningOfWord();\n        expect(editor.getCursorBufferPosition()).toEqual([9, 2]);\n        editor.buffer.setText(buffer.getText().replace(/\\r\\n/g, '\\n'));\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the previous word boundary",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToPreviousWordBoundary()"
            ],
            "updatePoint": {
                "line": 865,
                "column": 56
            },
            "line": 865,
            "code": "      it('moves the cursor to the previous word boundary', () => {\n        editor.setCursorBufferPosition([0, 8]);\n        editor.addCursorAtBufferPosition([2, 0]);\n        editor.addCursorAtBufferPosition([2, 4]);\n        editor.addCursorAtBufferPosition([3, 14]);\n        const [cursor1, cursor2, cursor3, cursor4] = editor.getCursors();\n        editor.moveToPreviousWordBoundary();\n        expect(cursor1.getBufferPosition()).toEqual([0, 4]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 30]);\n        expect(cursor3.getBufferPosition()).toEqual([2, 0]);\n        expect(cursor4.getBufferPosition()).toEqual([3, 13]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the previous word boundary",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToNextWordBoundary()"
            ],
            "updatePoint": {
                "line": 879,
                "column": 56
            },
            "line": 879,
            "code": "      it('moves the cursor to the previous word boundary', () => {\n        editor.setCursorBufferPosition([0, 8]);\n        editor.addCursorAtBufferPosition([2, 40]);\n        editor.addCursorAtBufferPosition([3, 0]);\n        editor.addCursorAtBufferPosition([3, 30]);\n        const [cursor1, cursor2, cursor3, cursor4] = editor.getCursors();\n        editor.moveToNextWordBoundary();\n        expect(cursor1.getBufferPosition()).toEqual([0, 13]);\n        expect(cursor2.getBufferPosition()).toEqual([3, 0]);\n        expect(cursor3.getBufferPosition()).toEqual([3, 4]);\n        expect(cursor4.getBufferPosition()).toEqual([3, 31]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the end of the word",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToEndOfWord()"
            ],
            "updatePoint": {
                "line": 893,
                "column": 49
            },
            "line": 893,
            "code": "      it('moves the cursor to the end of the word', () => {\n        editor.setCursorBufferPosition([0, 6]);\n        editor.addCursorAtBufferPosition([1, 10]);\n        editor.addCursorAtBufferPosition([2, 40]);\n        const [cursor1, cursor2, cursor3] = editor.getCursors();\n        editor.moveToEndOfWord();\n        expect(cursor1.getBufferPosition()).toEqual([0, 13]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 12]);\n        expect(cursor3.getBufferPosition()).toEqual([3, 7]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not blow up when there is no next word",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToEndOfWord()"
            ],
            "updatePoint": {
                "line": 903,
                "column": 53
            },
            "line": 903,
            "code": "      it('does not blow up when there is no next word', () => {\n        editor.setCursorBufferPosition([Infinity, Infinity]);\n        const endPosition = editor.getCursorBufferPosition();\n        editor.moveToEndOfWord();\n        expect(editor.getCursorBufferPosition()).toEqual(endPosition);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "treats lines with only whitespace as a word",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToEndOfWord()"
            ],
            "updatePoint": {
                "line": 909,
                "column": 53
            },
            "line": 909,
            "code": "      it('treats lines with only whitespace as a word', () => {\n        editor.setCursorBufferPosition([9, 4]);\n        editor.moveToEndOfWord();\n        expect(editor.getCursorBufferPosition()).toEqual([10, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "treats lines with only whitespace as a word (CRLF line ending)",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToEndOfWord()"
            ],
            "updatePoint": {
                "line": 914,
                "column": 72
            },
            "line": 914,
            "code": "      it('treats lines with only whitespace as a word (CRLF line ending)', () => {\n        editor.buffer.setText(buffer.getText().replace(/\\n/g, '\\r\\n'));\n        editor.setCursorBufferPosition([9, 4]);\n        editor.moveToEndOfWord();\n        expect(editor.getCursorBufferPosition()).toEqual([10, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works when the current line is blank",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToEndOfWord()"
            ],
            "updatePoint": {
                "line": 920,
                "column": 46
            },
            "line": 920,
            "code": "      it('works when the current line is blank', () => {\n        editor.setCursorBufferPosition([10, 0]);\n        editor.moveToEndOfWord();\n        expect(editor.getCursorBufferPosition()).toEqual([11, 8]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works when the current line is blank (CRLF line ending)",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToEndOfWord()"
            ],
            "updatePoint": {
                "line": 925,
                "column": 65
            },
            "line": 925,
            "code": "      it('works when the current line is blank (CRLF line ending)', () => {\n        editor.buffer.setText(buffer.getText().replace(/\\n/g, '\\r\\n'));\n        editor.setCursorBufferPosition([10, 0]);\n        editor.moveToEndOfWord();\n        expect(editor.getCursorBufferPosition()).toEqual([11, 8]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor before the first character of the next word",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfNextWord()"
            ],
            "updatePoint": {
                "line": 933,
                "column": 70
            },
            "line": 933,
            "code": "      it('moves the cursor before the first character of the next word', () => {\n        editor.setCursorBufferPosition([0, 6]);\n        editor.addCursorAtBufferPosition([1, 11]);\n        editor.addCursorAtBufferPosition([2, 0]);\n        const [cursor1, cursor2, cursor3] = editor.getCursors();\n        editor.moveToBeginningOfNextWord();\n        expect(cursor1.getBufferPosition()).toEqual([0, 14]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 13]);\n        expect(cursor3.getBufferPosition()).toEqual([2, 4]); // When the cursor is on whitespace\n\n        editor.setText('ab cde- ');\n        editor.setCursorBufferPosition([0, 2]);\n        const cursor = editor.getLastCursor();\n        editor.moveToBeginningOfNextWord();\n        expect(cursor.getBufferPosition()).toEqual([0, 3]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not blow up when there is no next word",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfNextWord()"
            ],
            "updatePoint": {
                "line": 949,
                "column": 53
            },
            "line": 949,
            "code": "      it('does not blow up when there is no next word', () => {\n        editor.setCursorBufferPosition([Infinity, Infinity]);\n        const endPosition = editor.getCursorBufferPosition();\n        editor.moveToBeginningOfNextWord();\n        expect(editor.getCursorBufferPosition()).toEqual(endPosition);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "treats lines with only whitespace as a word",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfNextWord()"
            ],
            "updatePoint": {
                "line": 955,
                "column": 53
            },
            "line": 955,
            "code": "      it('treats lines with only whitespace as a word', () => {\n        editor.setCursorBufferPosition([9, 4]);\n        editor.moveToBeginningOfNextWord();\n        expect(editor.getCursorBufferPosition()).toEqual([10, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works when the current line is blank",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfNextWord()"
            ],
            "updatePoint": {
                "line": 960,
                "column": 46
            },
            "line": 960,
            "code": "      it('works when the current line is blank', () => {\n        editor.setCursorBufferPosition([10, 0]);\n        editor.moveToBeginningOfNextWord();\n        expect(editor.getCursorBufferPosition()).toEqual([11, 9]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not move the cursor when there is no previous subword boundary",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToPreviousSubwordBoundary"
            ],
            "updatePoint": {
                "line": 967,
                "column": 77
            },
            "line": 967,
            "code": "      it('does not move the cursor when there is no previous subword boundary', () => {\n        editor.setText('');\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stops at word and underscore boundaries",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToPreviousSubwordBoundary"
            ],
            "updatePoint": {
                "line": 972,
                "column": 49
            },
            "line": 972,
            "code": "      it('stops at word and underscore boundaries', () => {\n        editor.setText('sub_word \\n');\n        editor.setCursorBufferPosition([0, 9]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 8]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n        editor.setText(' word\\n');\n        editor.setCursorBufferPosition([0, 3]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stops at camelCase boundaries",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToPreviousSubwordBoundary"
            ],
            "updatePoint": {
                "line": 986,
                "column": 39
            },
            "line": 986,
            "code": "      it('stops at camelCase boundaries', () => {\n        editor.setText(' getPreviousWord\\n');\n        editor.setCursorBufferPosition([0, 16]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 12]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stops at camelCase boundaries with non-ascii characters",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToPreviousSubwordBoundary"
            ],
            "updatePoint": {
                "line": 996,
                "column": 65
            },
            "line": 996,
            "code": "      it('stops at camelCase boundaries with non-ascii characters', () => {\n        editor.setText(' gétÁrevìôüsWord\\n');\n        editor.setCursorBufferPosition([0, 16]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 12]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips consecutive non-word characters",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToPreviousSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1006,
                "column": 47
            },
            "line": 1006,
            "code": "      it('skips consecutive non-word characters', () => {\n        editor.setText('e, => \\n');\n        editor.setCursorBufferPosition([0, 6]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 3]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips consecutive uppercase characters",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToPreviousSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1014,
                "column": 48
            },
            "line": 1014,
            "code": "      it('skips consecutive uppercase characters', () => {\n        editor.setText(' AAADF \\n');\n        editor.setCursorBufferPosition([0, 7]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 6]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n        editor.setText('ALPhA\\n');\n        editor.setCursorBufferPosition([0, 4]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips consecutive uppercase non-ascii letters",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToPreviousSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1026,
                "column": 55
            },
            "line": 1026,
            "code": "      it('skips consecutive uppercase non-ascii letters', () => {\n        editor.setText(' ÀÁÅDF \\n');\n        editor.setCursorBufferPosition([0, 7]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 6]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n        editor.setText('ALPhA\\n');\n        editor.setCursorBufferPosition([0, 4]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips consecutive numbers",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToPreviousSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1038,
                "column": 35
            },
            "line": 1038,
            "code": "      it('skips consecutive numbers', () => {\n        editor.setText(' 88 \\n');\n        editor.setCursorBufferPosition([0, 4]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 3]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works with multiple cursors",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToPreviousSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1046,
                "column": 37
            },
            "line": 1046,
            "code": "      it('works with multiple cursors', () => {\n        editor.setText('curOp\\ncursorOptions\\n');\n        editor.setCursorBufferPosition([0, 8]);\n        editor.addCursorAtBufferPosition([1, 13]);\n        const [cursor1, cursor2] = editor.getCursors();\n        editor.moveToPreviousSubwordBoundary();\n        expect(cursor1.getBufferPosition()).toEqual([0, 3]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 6]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works with non-English characters",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToPreviousSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1055,
                "column": 43
            },
            "line": 1055,
            "code": "      it('works with non-English characters', () => {\n        editor.setText('supåTøåst \\n');\n        editor.setCursorBufferPosition([0, 9]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n        editor.setText('supaÖast \\n');\n        editor.setCursorBufferPosition([0, 8]);\n        editor.moveToPreviousSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not move the cursor when there is no next subword boundary",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToNextSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1067,
                "column": 73
            },
            "line": 1067,
            "code": "      it('does not move the cursor when there is no next subword boundary', () => {\n        editor.setText('');\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stops at word and underscore boundaries",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToNextSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1072,
                "column": 49
            },
            "line": 1072,
            "code": "      it('stops at word and underscore boundaries', () => {\n        editor.setText(' sub_word \\n');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 9]);\n        editor.setText('word \\n');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stops at camelCase boundaries",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToNextSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1086,
                "column": 39
            },
            "line": 1086,
            "code": "      it('stops at camelCase boundaries', () => {\n        editor.setText('getPreviousWord \\n');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 3]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 11]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 15]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips consecutive non-word characters",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToNextSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1096,
                "column": 47
            },
            "line": 1096,
            "code": "      it('skips consecutive non-word characters', () => {\n        editor.setText(', => \\n');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips consecutive uppercase characters",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToNextSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1104,
                "column": 48
            },
            "line": 1104,
            "code": "      it('skips consecutive uppercase characters', () => {\n        editor.setText(' AAADF \\n');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 6]);\n        editor.setText('ALPhA\\n');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips consecutive numbers",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToNextSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1116,
                "column": 35
            },
            "line": 1116,
            "code": "      it('skips consecutive numbers', () => {\n        editor.setText(' 88 \\n');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 3]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works with multiple cursors",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToNextSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1124,
                "column": 37
            },
            "line": 1124,
            "code": "      it('works with multiple cursors', () => {\n        editor.setText('curOp\\ncursorOptions\\n');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.addCursorAtBufferPosition([1, 0]);\n        const [cursor1, cursor2] = editor.getCursors();\n        editor.moveToNextSubwordBoundary();\n        expect(cursor1.getBufferPosition()).toEqual([0, 3]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 6]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works with non-English characters",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToNextSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1133,
                "column": 43
            },
            "line": 1133,
            "code": "      it('works with non-English characters', () => {\n        editor.setText('supåTøåst \\n');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n        editor.setText('supaÖast \\n');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToNextSubwordBoundary();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor before the first line of the next paragraph",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfNextParagraph()"
            ],
            "updatePoint": {
                "line": 1145,
                "column": 70
            },
            "line": 1145,
            "code": "      it('moves the cursor before the first line of the next paragraph', () => {\n        editor.setCursorBufferPosition([0, 6]);\n        editor.foldBufferRow(4);\n        editor.moveToBeginningOfNextParagraph();\n        expect(editor.getCursorBufferPosition()).toEqual([10, 0]);\n        editor.setText('');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToBeginningOfNextParagraph();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor before the first line of the next paragraph (CRLF line endings)",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfNextParagraph()"
            ],
            "updatePoint": {
                "line": 1155,
                "column": 90
            },
            "line": 1155,
            "code": "      it('moves the cursor before the first line of the next paragraph (CRLF line endings)', () => {\n        editor.setText(editor.getText().replace(/\\n/g, '\\r\\n'));\n        editor.setCursorBufferPosition([0, 6]);\n        editor.foldBufferRow(4);\n        editor.moveToBeginningOfNextParagraph();\n        expect(editor.getCursorBufferPosition()).toEqual([10, 0]);\n        editor.setText('');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToBeginningOfNextParagraph();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor before the first line of the previous paragraph",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfPreviousParagraph()"
            ],
            "updatePoint": {
                "line": 1168,
                "column": 74
            },
            "line": 1168,
            "code": "      it('moves the cursor before the first line of the previous paragraph', () => {\n        editor.setCursorBufferPosition([10, 0]);\n        editor.foldBufferRow(4);\n        editor.moveToBeginningOfPreviousParagraph();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n        editor.setText('');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToBeginningOfPreviousParagraph();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor before the first line of the previous paragraph (CRLF line endings)",
            "suites": [
                "TextEditor",
                "cursor",
                ".moveToBeginningOfPreviousParagraph()"
            ],
            "updatePoint": {
                "line": 1178,
                "column": 94
            },
            "line": 1178,
            "code": "      it('moves the cursor before the first line of the previous paragraph (CRLF line endings)', () => {\n        editor.setText(editor.getText().replace(/\\n/g, '\\r\\n'));\n        editor.setCursorBufferPosition([10, 0]);\n        editor.foldBufferRow(4);\n        editor.moveToBeginningOfPreviousParagraph();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n        editor.setText('');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveToBeginningOfPreviousParagraph();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the buffer range of the current paragraph, delimited by blank lines or the beginning / end of the file",
            "suites": [
                "TextEditor",
                "cursor",
                ".getCurrentParagraphBufferRange()"
            ],
            "updatePoint": {
                "line": 1191,
                "column": 120
            },
            "line": 1191,
            "code": "      it('returns the buffer range of the current paragraph, delimited by blank lines or the beginning / end of the file', () => {\n        buffer.setText('  ' + dedent`\n          I am the first paragraph,\n          bordered by the beginning of\n          the file\n          ${'   '}\n\n            I am the second paragraph\n          with blank lines above and below\n          me.\n\n          I am the last paragraph,\n          bordered by the end of the file.\\\n        `); // in a paragraph\n\n        editor.setCursorBufferPosition([1, 7]);\n        expect(editor.getCurrentParagraphBufferRange()).toEqual([[0, 0], [2, 8]]);\n        editor.setCursorBufferPosition([7, 1]);\n        expect(editor.getCurrentParagraphBufferRange()).toEqual([[5, 0], [7, 3]]);\n        editor.setCursorBufferPosition([9, 10]);\n        expect(editor.getCurrentParagraphBufferRange()).toEqual([[9, 0], [10, 32]]); // between paragraphs\n\n        editor.setCursorBufferPosition([3, 1]);\n        expect(editor.getCurrentParagraphBufferRange()).toBeUndefined();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will limit paragraph range to comments",
            "suites": [
                "TextEditor",
                "cursor",
                ".getCurrentParagraphBufferRange()"
            ],
            "updatePoint": {
                "line": 1216,
                "column": 48
            },
            "line": 1216,
            "code": "      it('will limit paragraph range to comments', () => {\n        atom.grammars.assignLanguageMode(editor.getBuffer(), 'source.js');\n        editor.setText(dedent`\n          var quicksort = function () {\n            /* Single line comment block */\n            var sort = function(items) {};\n\n            /*\n            A multiline\n            comment is here\n            */\n            var sort = function(items) {};\n\n            // A comment\n            //\n            // Multiple comment\n            // lines\n            var sort = function(items) {};\n            // comment line after fn\n\n            var nosort = function(items) {\n              item;\n            }\n\n          };\\\n        `);\n\n        function paragraphBufferRangeForRow(row) {\n          editor.setCursorBufferPosition([row, 0]);\n          return editor.getLastCursor().getCurrentParagraphBufferRange();\n        }\n\n        expect(paragraphBufferRangeForRow(0)).toEqual([[0, 0], [0, 29]]);\n        expect(paragraphBufferRangeForRow(1)).toEqual([[1, 0], [1, 33]]);\n        expect(paragraphBufferRangeForRow(2)).toEqual([[2, 0], [2, 32]]);\n        expect(paragraphBufferRangeForRow(3)).toBeFalsy();\n        expect(paragraphBufferRangeForRow(4)).toEqual([[4, 0], [7, 4]]);\n        expect(paragraphBufferRangeForRow(5)).toEqual([[4, 0], [7, 4]]);\n        expect(paragraphBufferRangeForRow(6)).toEqual([[4, 0], [7, 4]]);\n        expect(paragraphBufferRangeForRow(7)).toEqual([[4, 0], [7, 4]]);\n        expect(paragraphBufferRangeForRow(8)).toEqual([[8, 0], [8, 32]]);\n        expect(paragraphBufferRangeForRow(9)).toBeFalsy();\n        expect(paragraphBufferRangeForRow(10)).toEqual([[10, 0], [13, 10]]);\n        expect(paragraphBufferRangeForRow(11)).toEqual([[10, 0], [13, 10]]);\n        expect(paragraphBufferRangeForRow(12)).toEqual([[10, 0], [13, 10]]);\n        expect(paragraphBufferRangeForRow(14)).toEqual([[14, 0], [14, 32]]);\n        expect(paragraphBufferRangeForRow(15)).toEqual([[15, 0], [15, 26]]);\n        expect(paragraphBufferRangeForRow(18)).toEqual([[17, 0], [19, 3]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the cursor at the given screenPosition",
            "suites": [
                "TextEditor",
                "cursor",
                "getCursorAtScreenPosition(screenPosition)"
            ],
            "updatePoint": {
                "line": 1267,
                "column": 56
            },
            "line": 1267,
            "code": "      it('returns the cursor at the given screenPosition', () => {\n        const cursor1 = editor.addCursorAtScreenPosition([0, 2]);\n        const cursor2 = editor.getCursorAtScreenPosition(cursor1.getScreenPosition());\n        expect(cursor2).toBe(cursor1);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the cursor positions in the order they were added",
            "suites": [
                "TextEditor",
                "cursor",
                "::getCursorScreenPositions()"
            ],
            "updatePoint": {
                "line": 1274,
                "column": 67
            },
            "line": 1274,
            "code": "      it('returns the cursor positions in the order they were added', () => {\n        editor.foldBufferRow(4);\n        editor.addCursorAtBufferPosition([8, 5]);\n        editor.addCursorAtBufferPosition([3, 5]);\n        expect(editor.getCursorScreenPositions()).toEqual([[0, 0], [5, 5], [3, 5]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns all cursors ordered by buffer positions",
            "suites": [
                "TextEditor",
                "cursor",
                "::getCursorsOrderedByBufferPosition()"
            ],
            "updatePoint": {
                "line": 1282,
                "column": 57
            },
            "line": 1282,
            "code": "      it('returns all cursors ordered by buffer positions', () => {\n        const originalCursor = editor.getLastCursor();\n        const cursor1 = editor.addCursorAtBufferPosition([8, 5]);\n        const cursor2 = editor.addCursorAtBufferPosition([4, 5]);\n        expect(editor.getCursorsOrderedByBufferPosition()).toEqual([originalCursor, cursor2, cursor1]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the existing cursor",
            "suites": [
                "TextEditor",
                "cursor",
                "addCursorAtScreenPosition(screenPosition)",
                "when a cursor already exists at the position"
            ],
            "updatePoint": {
                "line": 1291,
                "column": 39
            },
            "line": 1291,
            "code": "        it('returns the existing cursor', () => {\n          const cursor1 = editor.addCursorAtScreenPosition([0, 2]);\n          const cursor2 = editor.addCursorAtScreenPosition([0, 2]);\n          expect(cursor2).toBe(cursor1);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the existing cursor",
            "suites": [
                "TextEditor",
                "cursor",
                "addCursorAtBufferPosition(bufferPosition)",
                "when a cursor already exists at the position"
            ],
            "updatePoint": {
                "line": 1300,
                "column": 39
            },
            "line": 1300,
            "code": "        it('returns the existing cursor', () => {\n          const cursor1 = editor.addCursorAtBufferPosition([1, 4]);\n          const cursor2 = editor.addCursorAtBufferPosition([1, 4]);\n          expect(cursor2.marker).toBe(cursor1.marker);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the current scope",
            "suites": [
                "TextEditor",
                "cursor",
                ".getCursorScope()"
            ],
            "updatePoint": {
                "line": 1308,
                "column": 35
            },
            "line": 1308,
            "code": "      it('returns the current scope', () => {\n        const descriptor = editor.getCursorScope();\n        expect(descriptor.scopes).toContain('source.js');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new selection at (0, 0) if the last selection has been destroyed",
            "suites": [
                "TextEditor",
                "selection",
                ".getLastSelection()"
            ],
            "updatePoint": {
                "line": 1320,
                "column": 84
            },
            "line": 1320,
            "code": "      it('creates a new selection at (0, 0) if the last selection has been destroyed', () => {\n        editor.getLastSelection().destroy();\n        expect(editor.getLastSelection().getBufferRange()).toEqual([[0, 0], [0, 0]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't get stuck in a infinite loop when called from ::onDidAddCursor after the last selection has been destroyed (regression)",
            "suites": [
                "TextEditor",
                "selection",
                ".getLastSelection()"
            ],
            "updatePoint": {
                "line": 1324,
                "column": 137
            },
            "line": 1324,
            "code": "      it(\"doesn't get stuck in a infinite loop when called from ::onDidAddCursor after the last selection has been destroyed (regression)\", () => {\n        let callCount = 0;\n        editor.getLastSelection().destroy();\n        editor.onDidAddCursor(function (cursor) {\n          callCount++;\n          editor.getLastSelection();\n        });\n        expect(editor.getLastSelection().getBufferRange()).toEqual([[0, 0], [0, 0]]);\n        expect(callCount).toBe(1);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a new selection at (0, 0) if the last selection has been destroyed",
            "suites": [
                "TextEditor",
                "selection",
                ".getSelections()"
            ],
            "updatePoint": {
                "line": 1336,
                "column": 84
            },
            "line": 1336,
            "code": "      it('creates a new selection at (0, 0) if the last selection has been destroyed', () => {\n        editor.getLastSelection().destroy();\n        expect(editor.getSelections()[0].getBufferRange()).toEqual([[0, 0], [0, 0]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits an event with the old range, new range, and the selection that moved",
            "suites": [
                "TextEditor",
                "selection",
                "when the selection range changes"
            ],
            "updatePoint": {
                "line": 1342,
                "column": 84
            },
            "line": 1342,
            "code": "      it('emits an event with the old range, new range, and the selection that moved', () => {\n        let rangeChangedHandler;\n        editor.setSelectedBufferRange([[3, 0], [4, 5]]);\n        editor.onDidChangeSelectionRange(rangeChangedHandler = jasmine.createSpy());\n        editor.selectToBufferPosition([6, 2]);\n        expect(rangeChangedHandler).toHaveBeenCalled();\n        const eventObject = rangeChangedHandler.mostRecentCall.args[0];\n        expect(eventObject.oldBufferRange).toEqual([[3, 0], [4, 5]]);\n        expect(eventObject.oldScreenRange).toEqual([[3, 0], [4, 5]]);\n        expect(eventObject.newBufferRange).toEqual([[3, 0], [6, 2]]);\n        expect(eventObject.newScreenRange).toEqual([[3, 0], [6, 2]]);\n        expect(eventObject.selection).toBe(selection);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands each selection to its cursor's new location",
            "suites": [
                "TextEditor",
                "selection",
                ".selectUp/Down/Left/Right()"
            ],
            "updatePoint": {
                "line": 1357,
                "column": 61
            },
            "line": 1357,
            "code": "      it(\"expands each selection to its cursor's new location\", () => {\n        editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[3, 16], [3, 21]]]);\n        const [selection1, selection2] = editor.getSelections();\n        editor.selectRight();\n        expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 14]]);\n        expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 22]]);\n        editor.selectLeft();\n        editor.selectLeft();\n        expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 12]]);\n        expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 20]]);\n        editor.selectDown();\n        expect(selection1.getBufferRange()).toEqual([[0, 9], [1, 12]]);\n        expect(selection2.getBufferRange()).toEqual([[3, 16], [4, 20]]);\n        editor.selectUp();\n        expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 12]]);\n        expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 20]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges selections when they intersect when moving down",
            "suites": [
                "TextEditor",
                "selection",
                ".selectUp/Down/Left/Right()"
            ],
            "updatePoint": {
                "line": 1374,
                "column": 64
            },
            "line": 1374,
            "code": "      it('merges selections when they intersect when moving down', () => {\n        editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[1, 10], [1, 20]], [[2, 15], [3, 25]]]);\n        const [selection1] = editor.getSelections();\n        editor.selectDown();\n        expect(editor.getSelections()).toEqual([selection1]);\n        expect(selection1.getScreenRange()).toEqual([[0, 9], [4, 25]]);\n        expect(selection1.isReversed()).toBeFalsy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges selections when they intersect when moving up",
            "suites": [
                "TextEditor",
                "selection",
                ".selectUp/Down/Left/Right()"
            ],
            "updatePoint": {
                "line": 1382,
                "column": 62
            },
            "line": 1382,
            "code": "      it('merges selections when they intersect when moving up', () => {\n        editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[1, 10], [1, 20]]], {\n          reversed: true\n        });\n        const [selection1] = editor.getSelections();\n        editor.selectUp();\n        expect(editor.getSelections().length).toBe(1);\n        expect(editor.getSelections()).toEqual([selection1]);\n        expect(selection1.getScreenRange()).toEqual([[0, 0], [1, 20]]);\n        expect(selection1.isReversed()).toBeTruthy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges selections when they intersect when moving left",
            "suites": [
                "TextEditor",
                "selection",
                ".selectUp/Down/Left/Right()"
            ],
            "updatePoint": {
                "line": 1393,
                "column": 64
            },
            "line": 1393,
            "code": "      it('merges selections when they intersect when moving left', () => {\n        editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[0, 13], [1, 20]]], {\n          reversed: true\n        });\n        const [selection1] = editor.getSelections();\n        editor.selectLeft();\n        expect(editor.getSelections()).toEqual([selection1]);\n        expect(selection1.getScreenRange()).toEqual([[0, 8], [1, 20]]);\n        expect(selection1.isReversed()).toBeTruthy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges selections when they intersect when moving right",
            "suites": [
                "TextEditor",
                "selection",
                ".selectUp/Down/Left/Right()"
            ],
            "updatePoint": {
                "line": 1403,
                "column": 65
            },
            "line": 1403,
            "code": "      it('merges selections when they intersect when moving right', () => {\n        editor.setSelectedBufferRanges([[[0, 9], [0, 14]], [[0, 14], [1, 20]]]);\n        const [selection1] = editor.getSelections();\n        editor.selectRight();\n        expect(editor.getSelections()).toEqual([selection1]);\n        expect(selection1.getScreenRange()).toEqual([[0, 9], [1, 21]]);\n        expect(selection1.isReversed()).toBeFalsy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands each selection to its cursor's new location",
            "suites": [
                "TextEditor",
                "selection",
                ".selectUp/Down/Left/Right()",
                "when counts are passed into the selection functions"
            ],
            "updatePoint": {
                "line": 1412,
                "column": 63
            },
            "line": 1412,
            "code": "        it(\"expands each selection to its cursor's new location\", () => {\n          editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[3, 16], [3, 21]]]);\n          const [selection1, selection2] = editor.getSelections();\n          editor.selectRight(2);\n          expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 15]]);\n          expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 23]]);\n          editor.selectLeft(3);\n          expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 12]]);\n          expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 20]]);\n          editor.selectDown(3);\n          expect(selection1.getBufferRange()).toEqual([[0, 9], [3, 12]]);\n          expect(selection2.getBufferRange()).toEqual([[3, 16], [6, 20]]);\n          editor.selectUp(2);\n          expect(selection1.getBufferRange()).toEqual([[0, 9], [1, 12]]);\n          expect(selection2.getBufferRange()).toEqual([[3, 16], [4, 20]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands the last selection to the given position",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToBufferPosition(bufferPosition)"
            ],
            "updatePoint": {
                "line": 1431,
                "column": 58
            },
            "line": 1431,
            "code": "      it('expands the last selection to the given position', () => {\n        editor.setSelectedBufferRange([[3, 0], [4, 5]]);\n        editor.addCursorAtBufferPosition([5, 6]);\n        editor.selectToBufferPosition([6, 2]);\n        const selections = editor.getSelections();\n        expect(selections.length).toBe(2);\n        const [selection1, selection2] = selections;\n        expect(selection1.getBufferRange()).toEqual([[3, 0], [4, 5]]);\n        expect(selection2.getBufferRange()).toEqual([[5, 6], [6, 2]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands the last selection to the given position",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToScreenPosition(screenPosition)"
            ],
            "updatePoint": {
                "line": 1443,
                "column": 58
            },
            "line": 1443,
            "code": "      it('expands the last selection to the given position', () => {\n        editor.setSelectedBufferRange([[3, 0], [4, 5]]);\n        editor.addCursorAtScreenPosition([5, 6]);\n        editor.selectToScreenPosition([6, 2]);\n        const selections = editor.getSelections();\n        expect(selections.length).toBe(2);\n        const [selection1, selection2] = selections;\n        expect(selection1.getScreenRange()).toEqual([[3, 0], [4, 5]]);\n        expect(selection2.getScreenRange()).toEqual([[5, 6], [6, 2]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "switches the direction of the selection when selecting to positions before/after the start of the initial range",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToScreenPosition(screenPosition)",
                "when selecting with an initial screen range"
            ],
            "updatePoint": {
                "line": 1454,
                "column": 123
            },
            "line": 1454,
            "code": "        it('switches the direction of the selection when selecting to positions before/after the start of the initial range', () => {\n          editor.setCursorScreenPosition([5, 10]);\n          editor.selectWordsContainingCursors();\n          editor.selectToScreenPosition([3, 0]);\n          expect(editor.getLastSelection().isReversed()).toBe(true);\n          editor.selectToScreenPosition([9, 0]);\n          expect(editor.getLastSelection().isReversed()).toBe(false);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects from the cursor to first line of the next paragraph",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToBeginningOfNextParagraph()"
            ],
            "updatePoint": {
                "line": 1465,
                "column": 69
            },
            "line": 1465,
            "code": "      it('selects from the cursor to first line of the next paragraph', () => {\n        editor.setSelectedBufferRange([[3, 0], [4, 5]]);\n        editor.addCursorAtScreenPosition([5, 6]);\n        editor.selectToScreenPosition([6, 2]);\n        editor.selectToBeginningOfNextParagraph();\n        const selections = editor.getSelections();\n        expect(selections.length).toBe(1);\n        expect(selections[0].getScreenRange()).toEqual([[3, 0], [10, 0]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects from the cursor to the first line of the previous paragraph",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToBeginningOfPreviousParagraph()"
            ],
            "updatePoint": {
                "line": 1476,
                "column": 77
            },
            "line": 1476,
            "code": "      it('selects from the cursor to the first line of the previous paragraph', () => {\n        editor.setSelectedBufferRange([[3, 0], [4, 5]]);\n        editor.addCursorAtScreenPosition([5, 6]);\n        editor.selectToScreenPosition([6, 2]);\n        editor.selectToBeginningOfPreviousParagraph();\n        const selections = editor.getSelections();\n        expect(selections.length).toBe(1);\n        expect(selections[0].getScreenRange()).toEqual([[0, 0], [5, 6]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges selections if they intersect, maintaining the directionality of the last selection",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToBeginningOfPreviousParagraph()"
            ],
            "updatePoint": {
                "line": 1485,
                "column": 99
            },
            "line": 1485,
            "code": "      it('merges selections if they intersect, maintaining the directionality of the last selection', () => {\n        editor.setCursorScreenPosition([4, 10]);\n        editor.selectToScreenPosition([5, 27]);\n        editor.addCursorAtScreenPosition([3, 10]);\n        editor.selectToScreenPosition([6, 27]);\n        let selections = editor.getSelections();\n        expect(selections.length).toBe(1);\n        let [selection1] = selections;\n        expect(selection1.getScreenRange()).toEqual([[3, 10], [6, 27]]);\n        expect(selection1.isReversed()).toBeFalsy();\n        editor.addCursorAtScreenPosition([7, 4]);\n        editor.selectToScreenPosition([4, 11]);\n        selections = editor.getSelections();\n        expect(selections.length).toBe(1);\n        [selection1] = selections;\n        expect(selection1.getScreenRange()).toEqual([[3, 10], [7, 4]]);\n        expect(selection1.isReversed()).toBeTruthy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects text from cursor position to the top of the buffer",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToTop()"
            ],
            "updatePoint": {
                "line": 1505,
                "column": 68
            },
            "line": 1505,
            "code": "      it('selects text from cursor position to the top of the buffer', () => {\n        editor.setCursorScreenPosition([11, 2]);\n        editor.addCursorAtScreenPosition([10, 0]);\n        editor.selectToTop();\n        expect(editor.getCursors().length).toBe(1);\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n        expect(editor.getLastSelection().getBufferRange()).toEqual([[0, 0], [11, 2]]);\n        expect(editor.getLastSelection().isReversed()).toBeTruthy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects text from cursor position to the bottom of the buffer",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToBottom()"
            ],
            "updatePoint": {
                "line": 1516,
                "column": 71
            },
            "line": 1516,
            "code": "      it('selects text from cursor position to the bottom of the buffer', () => {\n        editor.setCursorScreenPosition([10, 0]);\n        editor.addCursorAtScreenPosition([9, 3]);\n        editor.selectToBottom();\n        expect(editor.getCursors().length).toBe(1);\n        expect(editor.getCursorBufferPosition()).toEqual([12, 2]);\n        expect(editor.getLastSelection().getBufferRange()).toEqual([[9, 3], [12, 2]]);\n        expect(editor.getLastSelection().isReversed()).toBeFalsy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects the entire buffer",
            "suites": [
                "TextEditor",
                "selection",
                ".selectAll()"
            ],
            "updatePoint": {
                "line": 1527,
                "column": 35
            },
            "line": 1527,
            "code": "      it('selects the entire buffer', () => {\n        editor.selectAll();\n        expect(editor.getLastSelection().getBufferRange()).toEqual(buffer.getRange());\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects text from cursor position to beginning of line",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToBeginningOfLine()"
            ],
            "updatePoint": {
                "line": 1533,
                "column": 64
            },
            "line": 1533,
            "code": "      it('selects text from cursor position to beginning of line', () => {\n        editor.setCursorScreenPosition([12, 2]);\n        editor.addCursorAtScreenPosition([11, 3]);\n        editor.selectToBeginningOfLine();\n        expect(editor.getCursors().length).toBe(2);\n        const [cursor1, cursor2] = editor.getCursors();\n        expect(cursor1.getBufferPosition()).toEqual([12, 0]);\n        expect(cursor2.getBufferPosition()).toEqual([11, 0]);\n        expect(editor.getSelections().length).toBe(2);\n        const [selection1, selection2] = editor.getSelections();\n        expect(selection1.getBufferRange()).toEqual([[12, 0], [12, 2]]);\n        expect(selection1.isReversed()).toBeTruthy();\n        expect(selection2.getBufferRange()).toEqual([[11, 0], [11, 3]]);\n        expect(selection2.isReversed()).toBeTruthy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects text from cursor position to end of line",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToEndOfLine()"
            ],
            "updatePoint": {
                "line": 1550,
                "column": 58
            },
            "line": 1550,
            "code": "      it('selects text from cursor position to end of line', () => {\n        editor.setCursorScreenPosition([12, 0]);\n        editor.addCursorAtScreenPosition([11, 3]);\n        editor.selectToEndOfLine();\n        expect(editor.getCursors().length).toBe(2);\n        const [cursor1, cursor2] = editor.getCursors();\n        expect(cursor1.getBufferPosition()).toEqual([12, 2]);\n        expect(cursor2.getBufferPosition()).toEqual([11, 44]);\n        expect(editor.getSelections().length).toBe(2);\n        const [selection1, selection2] = editor.getSelections();\n        expect(selection1.getBufferRange()).toEqual([[12, 0], [12, 2]]);\n        expect(selection1.isReversed()).toBeFalsy();\n        expect(selection2.getBufferRange()).toEqual([[11, 3], [11, 44]]);\n        expect(selection2.isReversed()).toBeFalsy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects to the entire line (including newlines) at given row",
            "suites": [
                "TextEditor",
                "selection",
                ".selectLinesContainingCursors()"
            ],
            "updatePoint": {
                "line": 1567,
                "column": 70
            },
            "line": 1567,
            "code": "      it('selects to the entire line (including newlines) at given row', () => {\n        editor.setCursorScreenPosition([1, 2]);\n        editor.selectLinesContainingCursors();\n        expect(editor.getSelectedBufferRange()).toEqual([[1, 0], [2, 0]]);\n        expect(editor.getSelectedText()).toBe('  var sort = function(items) {\\n');\n        editor.setCursorScreenPosition([12, 2]);\n        editor.selectLinesContainingCursors();\n        expect(editor.getSelectedBufferRange()).toEqual([[12, 0], [12, 2]]);\n        editor.setCursorBufferPosition([0, 2]);\n        editor.selectLinesContainingCursors();\n        editor.selectLinesContainingCursors();\n        expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [2, 0]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects from the beginning of the first line to the last line",
            "suites": [
                "TextEditor",
                "selection",
                ".selectLinesContainingCursors()",
                "when the selection spans multiple row"
            ],
            "updatePoint": {
                "line": 1581,
                "column": 73
            },
            "line": 1581,
            "code": "        it('selects from the beginning of the first line to the last line', () => {\n          selection = editor.getLastSelection();\n          selection.setBufferRange([[1, 10], [3, 20]]);\n          editor.selectLinesContainingCursors();\n          expect(editor.getSelectedBufferRange()).toEqual([[1, 0], [4, 0]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects text from cursor position to beginning of word",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToBeginningOfWord()"
            ],
            "updatePoint": {
                "line": 1590,
                "column": 64
            },
            "line": 1590,
            "code": "      it('selects text from cursor position to beginning of word', () => {\n        editor.setCursorScreenPosition([0, 13]);\n        editor.addCursorAtScreenPosition([3, 49]);\n        editor.selectToBeginningOfWord();\n        expect(editor.getCursors().length).toBe(2);\n        const [cursor1, cursor2] = editor.getCursors();\n        expect(cursor1.getBufferPosition()).toEqual([0, 4]);\n        expect(cursor2.getBufferPosition()).toEqual([3, 47]);\n        expect(editor.getSelections().length).toBe(2);\n        const [selection1, selection2] = editor.getSelections();\n        expect(selection1.getBufferRange()).toEqual([[0, 4], [0, 13]]);\n        expect(selection1.isReversed()).toBeTruthy();\n        expect(selection2.getBufferRange()).toEqual([[3, 47], [3, 49]]);\n        expect(selection2.isReversed()).toBeTruthy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects text from cursor position to end of word",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToEndOfWord()"
            ],
            "updatePoint": {
                "line": 1607,
                "column": 58
            },
            "line": 1607,
            "code": "      it('selects text from cursor position to end of word', () => {\n        editor.setCursorScreenPosition([0, 4]);\n        editor.addCursorAtScreenPosition([3, 48]);\n        editor.selectToEndOfWord();\n        expect(editor.getCursors().length).toBe(2);\n        const [cursor1, cursor2] = editor.getCursors();\n        expect(cursor1.getBufferPosition()).toEqual([0, 13]);\n        expect(cursor2.getBufferPosition()).toEqual([3, 50]);\n        expect(editor.getSelections().length).toBe(2);\n        const [selection1, selection2] = editor.getSelections();\n        expect(selection1.getBufferRange()).toEqual([[0, 4], [0, 13]]);\n        expect(selection1.isReversed()).toBeFalsy();\n        expect(selection2.getBufferRange()).toEqual([[3, 48], [3, 50]]);\n        expect(selection2.isReversed()).toBeFalsy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects text from cursor position to beginning of next word",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToBeginningOfNextWord()"
            ],
            "updatePoint": {
                "line": 1624,
                "column": 69
            },
            "line": 1624,
            "code": "      it('selects text from cursor position to beginning of next word', () => {\n        editor.setCursorScreenPosition([0, 4]);\n        editor.addCursorAtScreenPosition([3, 48]);\n        editor.selectToBeginningOfNextWord();\n        expect(editor.getCursors().length).toBe(2);\n        const [cursor1, cursor2] = editor.getCursors();\n        expect(cursor1.getBufferPosition()).toEqual([0, 14]);\n        expect(cursor2.getBufferPosition()).toEqual([3, 51]);\n        expect(editor.getSelections().length).toBe(2);\n        const [selection1, selection2] = editor.getSelections();\n        expect(selection1.getBufferRange()).toEqual([[0, 4], [0, 14]]);\n        expect(selection1.isReversed()).toBeFalsy();\n        expect(selection2.getBufferRange()).toEqual([[3, 48], [3, 51]]);\n        expect(selection2.isReversed()).toBeFalsy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "select to the previous word boundary",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToPreviousWordBoundary()"
            ],
            "updatePoint": {
                "line": 1641,
                "column": 46
            },
            "line": 1641,
            "code": "      it('select to the previous word boundary', () => {\n        editor.setCursorBufferPosition([0, 8]);\n        editor.addCursorAtBufferPosition([2, 0]);\n        editor.addCursorAtBufferPosition([3, 4]);\n        editor.addCursorAtBufferPosition([3, 14]);\n        editor.selectToPreviousWordBoundary();\n        expect(editor.getSelections().length).toBe(4);\n        const [selection1, selection2, selection3, selection4] = editor.getSelections();\n        expect(selection1.getBufferRange()).toEqual([[0, 8], [0, 4]]);\n        expect(selection1.isReversed()).toBeTruthy();\n        expect(selection2.getBufferRange()).toEqual([[2, 0], [1, 30]]);\n        expect(selection2.isReversed()).toBeTruthy();\n        expect(selection3.getBufferRange()).toEqual([[3, 4], [3, 0]]);\n        expect(selection3.isReversed()).toBeTruthy();\n        expect(selection4.getBufferRange()).toEqual([[3, 14], [3, 13]]);\n        expect(selection4.isReversed()).toBeTruthy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "select to the next word boundary",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToNextWordBoundary()"
            ],
            "updatePoint": {
                "line": 1660,
                "column": 42
            },
            "line": 1660,
            "code": "      it('select to the next word boundary', () => {\n        editor.setCursorBufferPosition([0, 8]);\n        editor.addCursorAtBufferPosition([2, 40]);\n        editor.addCursorAtBufferPosition([4, 0]);\n        editor.addCursorAtBufferPosition([3, 30]);\n        editor.selectToNextWordBoundary();\n        expect(editor.getSelections().length).toBe(4);\n        const [selection1, selection2, selection3, selection4] = editor.getSelections();\n        expect(selection1.getBufferRange()).toEqual([[0, 8], [0, 13]]);\n        expect(selection1.isReversed()).toBeFalsy();\n        expect(selection2.getBufferRange()).toEqual([[2, 40], [3, 0]]);\n        expect(selection2.isReversed()).toBeFalsy();\n        expect(selection3.getBufferRange()).toEqual([[4, 0], [4, 4]]);\n        expect(selection3.isReversed()).toBeFalsy();\n        expect(selection4.getBufferRange()).toEqual([[3, 30], [3, 31]]);\n        expect(selection4.isReversed()).toBeFalsy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects subwords",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToPreviousSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1679,
                "column": 26
            },
            "line": 1679,
            "code": "      it('selects subwords', () => {\n        editor.setText('');\n        editor.insertText('_word\\n');\n        editor.insertText(' getPreviousWord\\n');\n        editor.insertText('e, => \\n');\n        editor.insertText(' 88 \\n');\n        editor.setCursorBufferPosition([0, 5]);\n        editor.addCursorAtBufferPosition([1, 7]);\n        editor.addCursorAtBufferPosition([2, 5]);\n        editor.addCursorAtBufferPosition([3, 3]);\n        const [selection1, selection2, selection3, selection4] = editor.getSelections();\n        editor.selectToPreviousSubwordBoundary();\n        expect(selection1.getBufferRange()).toEqual([[0, 1], [0, 5]]);\n        expect(selection1.isReversed()).toBeTruthy();\n        expect(selection2.getBufferRange()).toEqual([[1, 4], [1, 7]]);\n        expect(selection2.isReversed()).toBeTruthy();\n        expect(selection3.getBufferRange()).toEqual([[2, 3], [2, 5]]);\n        expect(selection3.isReversed()).toBeTruthy();\n        expect(selection4.getBufferRange()).toEqual([[3, 1], [3, 3]]);\n        expect(selection4.isReversed()).toBeTruthy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects subwords",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToNextSubwordBoundary"
            ],
            "updatePoint": {
                "line": 1702,
                "column": 26
            },
            "line": 1702,
            "code": "      it('selects subwords', () => {\n        editor.setText('');\n        editor.insertText('word_\\n');\n        editor.insertText('getPreviousWord\\n');\n        editor.insertText('e, => \\n');\n        editor.insertText(' 88 \\n');\n        editor.setCursorBufferPosition([0, 1]);\n        editor.addCursorAtBufferPosition([1, 7]);\n        editor.addCursorAtBufferPosition([2, 2]);\n        editor.addCursorAtBufferPosition([3, 1]);\n        const [selection1, selection2, selection3, selection4] = editor.getSelections();\n        editor.selectToNextSubwordBoundary();\n        expect(selection1.getBufferRange()).toEqual([[0, 1], [0, 4]]);\n        expect(selection1.isReversed()).toBeFalsy();\n        expect(selection2.getBufferRange()).toEqual([[1, 7], [1, 11]]);\n        expect(selection2.isReversed()).toBeFalsy();\n        expect(selection3.getBufferRange()).toEqual([[2, 2], [2, 5]]);\n        expect(selection3.isReversed()).toBeFalsy();\n        expect(selection4.getBufferRange()).toEqual([[3, 1], [3, 3]]);\n        expect(selection4.isReversed()).toBeFalsy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes subwords",
            "suites": [
                "TextEditor",
                "selection",
                ".deleteToBeginningOfSubword"
            ],
            "updatePoint": {
                "line": 1725,
                "column": 26
            },
            "line": 1725,
            "code": "      it('deletes subwords', () => {\n        editor.setText('');\n        editor.insertText('_word\\n');\n        editor.insertText(' getPreviousWord\\n');\n        editor.insertText('e, => \\n');\n        editor.insertText(' 88 \\n');\n        editor.setCursorBufferPosition([0, 5]);\n        editor.addCursorAtBufferPosition([1, 7]);\n        editor.addCursorAtBufferPosition([2, 5]);\n        editor.addCursorAtBufferPosition([3, 3]);\n        const [cursor1, cursor2, cursor3, cursor4] = editor.getCursors();\n        editor.deleteToBeginningOfSubword();\n        expect(buffer.lineForRow(0)).toBe('_');\n        expect(buffer.lineForRow(1)).toBe(' getviousWord');\n        expect(buffer.lineForRow(2)).toBe('e,  ');\n        expect(buffer.lineForRow(3)).toBe('  ');\n        expect(cursor1.getBufferPosition()).toEqual([0, 1]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 4]);\n        expect(cursor3.getBufferPosition()).toEqual([2, 3]);\n        expect(cursor4.getBufferPosition()).toEqual([3, 1]);\n        editor.deleteToBeginningOfSubword();\n        expect(buffer.lineForRow(0)).toBe('');\n        expect(buffer.lineForRow(1)).toBe(' viousWord');\n        expect(buffer.lineForRow(2)).toBe('e ');\n        expect(buffer.lineForRow(3)).toBe(' ');\n        expect(cursor1.getBufferPosition()).toEqual([0, 0]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 1]);\n        expect(cursor3.getBufferPosition()).toEqual([2, 1]);\n        expect(cursor4.getBufferPosition()).toEqual([3, 0]);\n        editor.deleteToBeginningOfSubword();\n        expect(buffer.lineForRow(0)).toBe('');\n        expect(buffer.lineForRow(1)).toBe('viousWord');\n        expect(buffer.lineForRow(2)).toBe('  ');\n        expect(buffer.lineForRow(3)).toBe('');\n        expect(cursor1.getBufferPosition()).toEqual([0, 0]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 0]);\n        expect(cursor3.getBufferPosition()).toEqual([2, 0]);\n        expect(cursor4.getBufferPosition()).toEqual([2, 1]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes subwords",
            "suites": [
                "TextEditor",
                "selection",
                ".deleteToEndOfSubword"
            ],
            "updatePoint": {
                "line": 1766,
                "column": 26
            },
            "line": 1766,
            "code": "      it('deletes subwords', () => {\n        editor.setText('');\n        editor.insertText('word_\\n');\n        editor.insertText('getPreviousWord \\n');\n        editor.insertText('e, => \\n');\n        editor.insertText(' 88 \\n');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.addCursorAtBufferPosition([1, 0]);\n        editor.addCursorAtBufferPosition([2, 2]);\n        editor.addCursorAtBufferPosition([3, 0]);\n        const [cursor1, cursor2, cursor3, cursor4] = editor.getCursors();\n        editor.deleteToEndOfSubword();\n        expect(buffer.lineForRow(0)).toBe('_');\n        expect(buffer.lineForRow(1)).toBe('PreviousWord ');\n        expect(buffer.lineForRow(2)).toBe('e, ');\n        expect(buffer.lineForRow(3)).toBe('88 ');\n        expect(cursor1.getBufferPosition()).toEqual([0, 0]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 0]);\n        expect(cursor3.getBufferPosition()).toEqual([2, 2]);\n        expect(cursor4.getBufferPosition()).toEqual([3, 0]);\n        editor.deleteToEndOfSubword();\n        expect(buffer.lineForRow(0)).toBe('');\n        expect(buffer.lineForRow(1)).toBe('Word ');\n        expect(buffer.lineForRow(2)).toBe('e,');\n        expect(buffer.lineForRow(3)).toBe(' ');\n        expect(cursor1.getBufferPosition()).toEqual([0, 0]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 0]);\n        expect(cursor3.getBufferPosition()).toEqual([2, 2]);\n        expect(cursor4.getBufferPosition()).toEqual([3, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects the entire word",
            "suites": [
                "TextEditor",
                "selection",
                ".selectWordsContainingCursors()",
                "when the cursor is inside a word"
            ],
            "updatePoint": {
                "line": 1799,
                "column": 35
            },
            "line": 1799,
            "code": "        it('selects the entire word', () => {\n          editor.setCursorScreenPosition([0, 8]);\n          editor.selectWordsContainingCursors();\n          expect(editor.getSelectedText()).toBe('quicksort');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects the word the cursor is on",
            "suites": [
                "TextEditor",
                "selection",
                ".selectWordsContainingCursors()",
                "when the cursor is between two words"
            ],
            "updatePoint": {
                "line": 1806,
                "column": 45
            },
            "line": 1806,
            "code": "        it('selects the word the cursor is on', () => {\n          editor.setCursorBufferPosition([0, 4]);\n          editor.selectWordsContainingCursors();\n          expect(editor.getSelectedText()).toBe('quicksort');\n          editor.setCursorBufferPosition([0, 3]);\n          editor.selectWordsContainingCursors();\n          expect(editor.getSelectedText()).toBe('var');\n          editor.setCursorBufferPosition([1, 22]);\n          editor.selectWordsContainingCursors();\n          expect(editor.getSelectedText()).toBe('items');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects the whitespace region",
            "suites": [
                "TextEditor",
                "selection",
                ".selectWordsContainingCursors()",
                "when the cursor is inside a region of whitespace"
            ],
            "updatePoint": {
                "line": 1819,
                "column": 41
            },
            "line": 1819,
            "code": "        it('selects the whitespace region', () => {\n          editor.setCursorScreenPosition([5, 2]);\n          editor.selectWordsContainingCursors();\n          expect(editor.getSelectedBufferRange()).toEqual([[5, 0], [5, 6]]);\n          editor.setCursorScreenPosition([5, 0]);\n          editor.selectWordsContainingCursors();\n          expect(editor.getSelectedBufferRange()).toEqual([[5, 0], [5, 6]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "select the previous word",
            "suites": [
                "TextEditor",
                "selection",
                ".selectWordsContainingCursors()",
                "when the cursor is at the end of the text"
            ],
            "updatePoint": {
                "line": 1829,
                "column": 36
            },
            "line": 1829,
            "code": "        it('select the previous word', () => {\n          editor.buffer.append('word');\n          editor.moveToBottom();\n          editor.selectWordsContainingCursors();\n          expect(editor.getSelectedBufferRange()).toEqual([[12, 2], [12, 6]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects words based on the non-word characters configured at the cursor's current scope",
            "suites": [
                "TextEditor",
                "selection",
                ".selectWordsContainingCursors()",
                "when the cursor is at the end of the text"
            ],
            "updatePoint": {
                "line": 1836,
                "column": 97
            },
            "line": 1836,
            "code": "      it(\"selects words based on the non-word characters configured at the cursor's current scope\", () => {\n        editor.setText(\"one-one; 'two-two'; three-three\");\n        editor.setCursorBufferPosition([0, 1]);\n        editor.addCursorAtBufferPosition([0, 12]);\n        const scopeDescriptors = editor.getCursors().map(c => c.getScopeDescriptor());\n        expect(scopeDescriptors[0].getScopesArray()).toEqual(['source.js']);\n        expect(scopeDescriptors[1].getScopesArray()).toEqual(['source.js', 'string.quoted']);\n        spyOn(editor.getBuffer().getLanguageMode(), 'getNonWordCharacters').andCallFake(function (position) {\n          const result = '/()\"\\':,.;<>~!@#$%^&*|+=[]{}`?';\n          const scopes = this.scopeDescriptorForPosition(position).getScopesArray();\n\n          if (scopes.some(scope => scope.startsWith('string'))) {\n            return result;\n          } else {\n            return result + '-';\n          }\n        });\n        editor.selectWordsContainingCursors();\n        expect(editor.getSelections()[0].getText()).toBe('one');\n        expect(editor.getSelections()[1].getText()).toBe('two-two');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves to the first character of the current line or the beginning of the line if it's already on the first character",
            "suites": [
                "TextEditor",
                "selection",
                ".selectToFirstCharacterOfLine()"
            ],
            "updatePoint": {
                "line": 1859,
                "column": 126
            },
            "line": 1859,
            "code": "      it(\"moves to the first character of the current line or the beginning of the line if it's already on the first character\", () => {\n        editor.setCursorScreenPosition([0, 5]);\n        editor.addCursorAtScreenPosition([1, 7]);\n        editor.selectToFirstCharacterOfLine();\n        const [cursor1, cursor2] = editor.getCursors();\n        expect(cursor1.getBufferPosition()).toEqual([0, 0]);\n        expect(cursor2.getBufferPosition()).toEqual([1, 2]);\n        expect(editor.getSelections().length).toBe(2);\n        let [selection1, selection2] = editor.getSelections();\n        expect(selection1.getBufferRange()).toEqual([[0, 0], [0, 5]]);\n        expect(selection1.isReversed()).toBeTruthy();\n        expect(selection2.getBufferRange()).toEqual([[1, 2], [1, 7]]);\n        expect(selection2.isReversed()).toBeTruthy();\n        editor.selectToFirstCharacterOfLine();\n        [selection1, selection2] = editor.getSelections();\n        expect(selection1.getBufferRange()).toEqual([[0, 0], [0, 5]]);\n        expect(selection1.isReversed()).toBeTruthy();\n        expect(selection2.getBufferRange()).toEqual([[1, 0], [1, 7]]);\n        expect(selection2.isReversed()).toBeTruthy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears existing selections and creates selections for each of the given ranges",
            "suites": [
                "TextEditor",
                "selection",
                ".setSelectedBufferRanges(ranges)"
            ],
            "updatePoint": {
                "line": 1881,
                "column": 88
            },
            "line": 1881,
            "code": "      it('clears existing selections and creates selections for each of the given ranges', () => {\n        editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[4, 4], [5, 5]]]);\n        expect(editor.getSelectedBufferRanges()).toEqual([[[2, 2], [3, 3]], [[4, 4], [5, 5]]]);\n        editor.setSelectedBufferRanges([[[5, 5], [6, 6]]]);\n        expect(editor.getSelectedBufferRanges()).toEqual([[[5, 5], [6, 6]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges intersecting selections",
            "suites": [
                "TextEditor",
                "selection",
                ".setSelectedBufferRanges(ranges)"
            ],
            "updatePoint": {
                "line": 1887,
                "column": 40
            },
            "line": 1887,
            "code": "      it('merges intersecting selections', () => {\n        editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[3, 0], [5, 5]]]);\n        expect(editor.getSelectedBufferRanges()).toEqual([[[2, 2], [5, 5]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not merge non-empty adjacent selections",
            "suites": [
                "TextEditor",
                "selection",
                ".setSelectedBufferRanges(ranges)"
            ],
            "updatePoint": {
                "line": 1891,
                "column": 54
            },
            "line": 1891,
            "code": "      it('does not merge non-empty adjacent selections', () => {\n        editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[3, 3], [5, 5]]]);\n        expect(editor.getSelectedBufferRanges()).toEqual([[[2, 2], [3, 3]], [[3, 3], [5, 5]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "recycles existing selection instances",
            "suites": [
                "TextEditor",
                "selection",
                ".setSelectedBufferRanges(ranges)"
            ],
            "updatePoint": {
                "line": 1895,
                "column": 47
            },
            "line": 1895,
            "code": "      it('recycles existing selection instances', () => {\n        selection = editor.getLastSelection();\n        editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[4, 4], [5, 5]]]);\n        const [selection1] = editor.getSelections();\n        expect(selection1).toBe(selection);\n        expect(selection1.getBufferRange()).toEqual([[2, 2], [3, 3]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes folds that contain one or both of the selection's end points",
            "suites": [
                "TextEditor",
                "selection",
                ".setSelectedBufferRanges(ranges)",
                "when the 'preserveFolds' option is false (the default)"
            ],
            "updatePoint": {
                "line": 1903,
                "column": 80
            },
            "line": 1903,
            "code": "        it(\"removes folds that contain one or both of the selection's end points\", () => {\n          editor.setSelectedBufferRange([[0, 0], [0, 0]]);\n          editor.foldBufferRowRange(1, 4);\n          editor.foldBufferRowRange(2, 3);\n          editor.foldBufferRowRange(6, 8);\n          editor.foldBufferRowRange(10, 11);\n          editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[6, 6], [7, 7]]]);\n          expect(editor.isFoldedAtScreenRow(1)).toBeFalsy();\n          expect(editor.isFoldedAtScreenRow(2)).toBeFalsy();\n          expect(editor.isFoldedAtScreenRow(6)).toBeFalsy();\n          expect(editor.isFoldedAtScreenRow(10)).toBeTruthy();\n          editor.setSelectedBufferRange([[10, 0], [12, 0]]);\n          expect(editor.isFoldedAtScreenRow(10)).toBeTruthy();\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not remove folds that contain the selections",
            "suites": [
                "TextEditor",
                "selection",
                ".setSelectedBufferRanges(ranges)",
                "when the 'preserveFolds' option is true"
            ],
            "updatePoint": {
                "line": 1919,
                "column": 61
            },
            "line": 1919,
            "code": "        it('does not remove folds that contain the selections', () => {\n          editor.setSelectedBufferRange([[0, 0], [0, 0]]);\n          editor.foldBufferRowRange(1, 4);\n          editor.foldBufferRowRange(6, 8);\n          editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[6, 0], [6, 1]]], {\n            preserveFolds: true\n          });\n          expect(editor.isFoldedAtBufferRow(1)).toBeTruthy();\n          expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears existing selections and creates selections for each of the given ranges",
            "suites": [
                "TextEditor",
                "selection",
                ".setSelectedScreenRanges(ranges)"
            ],
            "updatePoint": {
                "line": 1933,
                "column": 88
            },
            "line": 1933,
            "code": "      it('clears existing selections and creates selections for each of the given ranges', () => {\n        editor.setSelectedScreenRanges([[[3, 4], [3, 7]], [[5, 4], [5, 7]]]);\n        expect(editor.getSelectedBufferRanges()).toEqual([[[3, 4], [3, 7]], [[8, 4], [8, 7]]]);\n        editor.setSelectedScreenRanges([[[6, 2], [6, 4]]]);\n        expect(editor.getSelectedScreenRanges()).toEqual([[[6, 2], [6, 4]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges intersecting selections and unfolds the fold which contain them",
            "suites": [
                "TextEditor",
                "selection",
                ".setSelectedScreenRanges(ranges)"
            ],
            "updatePoint": {
                "line": 1939,
                "column": 80
            },
            "line": 1939,
            "code": "      it('merges intersecting selections and unfolds the fold which contain them', () => {\n        editor.foldBufferRow(0); // Use buffer ranges because only the first line is on screen\n\n        editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[3, 0], [5, 5]]]);\n        expect(editor.getSelectedBufferRanges()).toEqual([[[2, 2], [5, 5]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "recycles existing selection instances",
            "suites": [
                "TextEditor",
                "selection",
                ".setSelectedScreenRanges(ranges)"
            ],
            "updatePoint": {
                "line": 1945,
                "column": 47
            },
            "line": 1945,
            "code": "      it('recycles existing selection instances', () => {\n        selection = editor.getLastSelection();\n        editor.setSelectedScreenRanges([[[2, 2], [3, 4]], [[4, 4], [5, 5]]]);\n        const [selection1] = editor.getSelections();\n        expect(selection1).toBe(selection);\n        expect(selection1.getScreenRange()).toEqual([[2, 2], [3, 4]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects the marker's range and returns the selected range",
            "suites": [
                "TextEditor",
                "selection",
                ".selectMarker(marker)",
                "if the marker is valid"
            ],
            "updatePoint": {
                "line": 1955,
                "column": 69
            },
            "line": 1955,
            "code": "        it(\"selects the marker's range and returns the selected range\", () => {\n          const marker = editor.markBufferRange([[0, 1], [3, 3]]);\n          expect(editor.selectMarker(marker)).toEqual([[0, 1], [3, 3]]);\n          expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [3, 3]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not change the selection and returns a falsy value",
            "suites": [
                "TextEditor",
                "selection",
                ".selectMarker(marker)",
                "if the marker is invalid"
            ],
            "updatePoint": {
                "line": 1962,
                "column": 67
            },
            "line": 1962,
            "code": "        it('does not change the selection and returns a falsy value', () => {\n          const marker = editor.markBufferRange([[0, 1], [3, 3]]);\n          marker.destroy();\n          expect(editor.selectMarker(marker)).toBeFalsy();\n          expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 0]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a selection for the specified buffer range",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionForBufferRange(bufferRange)"
            ],
            "updatePoint": {
                "line": 1971,
                "column": 57
            },
            "line": 1971,
            "code": "      it('adds a selection for the specified buffer range', () => {\n        editor.addSelectionForBufferRange([[3, 4], [5, 6]]);\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [0, 0]], [[3, 4], [5, 6]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects the same region of the line below current selections if possible",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is non-empty"
            ],
            "updatePoint": {
                "line": 1978,
                "column": 84
            },
            "line": 1978,
            "code": "        it('selects the same region of the line below current selections if possible', () => {\n          editor.setSelectedBufferRange([[3, 16], [3, 21]]);\n          editor.addSelectionForBufferRange([[3, 25], [3, 34]]);\n          editor.addSelectionBelow();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[3, 16], [3, 21]], [[3, 25], [3, 34]], [[4, 16], [4, 21]], [[4, 25], [4, 29]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips lines that are too short to create a non-empty selection",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is non-empty"
            ],
            "updatePoint": {
                "line": 1984,
                "column": 74
            },
            "line": 1984,
            "code": "        it('skips lines that are too short to create a non-empty selection', () => {\n          editor.setSelectedBufferRange([[3, 31], [3, 38]]);\n          editor.addSelectionBelow();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[3, 31], [3, 38]], [[6, 31], [6, 38]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "honors the original selection's range (goal range) when adding across shorter lines",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is non-empty"
            ],
            "updatePoint": {
                "line": 1989,
                "column": 95
            },
            "line": 1989,
            "code": "        it(\"honors the original selection's range (goal range) when adding across shorter lines\", () => {\n          editor.setSelectedBufferRange([[3, 22], [3, 38]]);\n          editor.addSelectionBelow();\n          editor.addSelectionBelow();\n          editor.addSelectionBelow();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[3, 22], [3, 38]], [[4, 22], [4, 29]], [[5, 22], [5, 30]], [[6, 22], [6, 38]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears selection goal ranges when the selection changes",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is non-empty"
            ],
            "updatePoint": {
                "line": 1996,
                "column": 67
            },
            "line": 1996,
            "code": "        it('clears selection goal ranges when the selection changes', () => {\n          editor.setSelectedBufferRange([[3, 22], [3, 38]]);\n          editor.addSelectionBelow();\n          editor.selectLeft();\n          editor.addSelectionBelow();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[3, 22], [3, 37]], [[4, 22], [4, 29]], [[5, 22], [5, 28]]]); // goal range from previous add selection is honored next time\n\n          editor.addSelectionBelow();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[3, 22], [3, 37]], [[4, 22], [4, 29]], [[5, 22], [5, 30]], // select to end of line 5 because line 4's goal range was reset by line 3 previously\n          [[6, 22], [6, 28]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can add selections to soft-wrapped line segments",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is non-empty"
            ],
            "updatePoint": {
                "line": 2007,
                "column": 60
            },
            "line": 2007,
            "code": "        it('can add selections to soft-wrapped line segments', () => {\n          editor.setSoftWrapped(true);\n          editor.setEditorWidthInChars(40);\n          editor.setDefaultCharWidth(1);\n          editor.setSelectedScreenRange([[3, 10], [3, 15]]);\n          editor.addSelectionBelow();\n          expect(editor.getSelectedScreenRanges()).toEqual([[[3, 10], [3, 15]], [[4, 10], [4, 15]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "takes atomic tokens into account",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is non-empty"
            ],
            "updatePoint": {
                "line": 2015,
                "column": 44
            },
            "line": 2015,
            "code": "        it('takes atomic tokens into account', async () => {\n          editor = await atom.workspace.open('sample-with-tabs-and-leading-comment.coffee', {\n            autoIndent: false\n          });\n          editor.setSelectedBufferRange([[2, 1], [2, 3]]);\n          editor.addSelectionBelow();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[2, 1], [2, 3]], [[3, 1], [3, 2]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips soft-wrap indentation tokens",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2031,
                "column": 48
            },
            "line": 2031,
            "code": "          it('skips soft-wrap indentation tokens', () => {\n            editor.setCursorScreenPosition([3, 0]);\n            editor.addSelectionBelow();\n            expect(editor.getSelectedScreenRanges()).toEqual([[[3, 0], [3, 0]], [[4, 4], [4, 4]]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not skip them if they're shorter than the current column",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2036,
                "column": 75
            },
            "line": 2036,
            "code": "          it(\"does not skip them if they're shorter than the current column\", () => {\n            editor.setCursorScreenPosition([3, 37]);\n            editor.addSelectionBelow();\n            expect(editor.getSelectedScreenRanges()).toEqual([[[3, 37], [3, 37]], [[4, 26], [4, 26]]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not skip lines that are shorter than the current column",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2042,
                "column": 72
            },
            "line": 2042,
            "code": "        it('does not skip lines that are shorter than the current column', () => {\n          editor.setCursorBufferPosition([3, 36]);\n          editor.addSelectionBelow();\n          editor.addSelectionBelow();\n          editor.addSelectionBelow();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[3, 36], [3, 36]], [[4, 29], [4, 29]], [[5, 30], [5, 30]], [[6, 36], [6, 36]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips empty lines when the column is non-zero",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2049,
                "column": 57
            },
            "line": 2049,
            "code": "        it('skips empty lines when the column is non-zero', () => {\n          editor.setCursorBufferPosition([9, 4]);\n          editor.addSelectionBelow();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[9, 4], [9, 4]], [[11, 4], [11, 4]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not skip empty lines when the column is zero",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2054,
                "column": 61
            },
            "line": 2054,
            "code": "        it('does not skip empty lines when the column is zero', () => {\n          editor.setCursorBufferPosition([9, 0]);\n          editor.addSelectionBelow();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[9, 0], [9, 0]], [[10, 0], [10, 0]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not create a new selection if it would be fully contained within another selection",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionBelow()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2060,
                "column": 97
            },
            "line": 2060,
            "code": "      it('does not create a new selection if it would be fully contained within another selection', () => {\n        editor.setText('abc\\ndef\\nghi\\njkl\\nmno');\n        editor.setCursorBufferPosition([0, 1]);\n        let addedSelectionCount = 0;\n        editor.onDidAddSelection(() => {\n          addedSelectionCount++;\n        });\n        editor.addSelectionBelow();\n        editor.addSelectionBelow();\n        editor.addSelectionBelow();\n        expect(addedSelectionCount).toBe(3);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects the same region of the line above current selections if possible",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionAbove()",
                "when the selection is non-empty"
            ],
            "updatePoint": {
                "line": 2075,
                "column": 84
            },
            "line": 2075,
            "code": "        it('selects the same region of the line above current selections if possible', () => {\n          editor.setSelectedBufferRange([[3, 16], [3, 21]]);\n          editor.addSelectionForBufferRange([[3, 37], [3, 44]]);\n          editor.addSelectionAbove();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[3, 16], [3, 21]], [[3, 37], [3, 44]], [[2, 16], [2, 21]], [[2, 37], [2, 40]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips lines that are too short to create a non-empty selection",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionAbove()",
                "when the selection is non-empty"
            ],
            "updatePoint": {
                "line": 2081,
                "column": 74
            },
            "line": 2081,
            "code": "        it('skips lines that are too short to create a non-empty selection', () => {\n          editor.setSelectedBufferRange([[6, 31], [6, 38]]);\n          editor.addSelectionAbove();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[6, 31], [6, 38]], [[3, 31], [3, 38]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "honors the original selection's range (goal range) when adding across shorter lines",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionAbove()",
                "when the selection is non-empty"
            ],
            "updatePoint": {
                "line": 2086,
                "column": 95
            },
            "line": 2086,
            "code": "        it(\"honors the original selection's range (goal range) when adding across shorter lines\", () => {\n          editor.setSelectedBufferRange([[6, 22], [6, 38]]);\n          editor.addSelectionAbove();\n          editor.addSelectionAbove();\n          editor.addSelectionAbove();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[6, 22], [6, 38]], [[5, 22], [5, 30]], [[4, 22], [4, 29]], [[3, 22], [3, 38]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can add selections to soft-wrapped line segments",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionAbove()",
                "when the selection is non-empty"
            ],
            "updatePoint": {
                "line": 2093,
                "column": 60
            },
            "line": 2093,
            "code": "        it('can add selections to soft-wrapped line segments', () => {\n          editor.setSoftWrapped(true);\n          editor.setDefaultCharWidth(1);\n          editor.setEditorWidthInChars(40);\n          editor.setSelectedScreenRange([[4, 10], [4, 15]]);\n          editor.addSelectionAbove();\n          expect(editor.getSelectedScreenRanges()).toEqual([[[4, 10], [4, 15]], [[3, 10], [3, 15]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "takes atomic tokens into account",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionAbove()",
                "when the selection is non-empty"
            ],
            "updatePoint": {
                "line": 2101,
                "column": 44
            },
            "line": 2101,
            "code": "        it('takes atomic tokens into account', async () => {\n          editor = await atom.workspace.open('sample-with-tabs-and-leading-comment.coffee', {\n            autoIndent: false\n          });\n          editor.setSelectedBufferRange([[3, 1], [3, 2]]);\n          editor.addSelectionAbove();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[3, 1], [3, 2]], [[2, 1], [2, 3]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips soft-wrap indentation tokens",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionAbove()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2117,
                "column": 48
            },
            "line": 2117,
            "code": "          it('skips soft-wrap indentation tokens', () => {\n            editor.setCursorScreenPosition([5, 0]);\n            editor.addSelectionAbove();\n            expect(editor.getSelectedScreenRanges()).toEqual([[[5, 0], [5, 0]], [[4, 4], [4, 4]]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not skip them if they're shorter than the current column",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionAbove()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2122,
                "column": 75
            },
            "line": 2122,
            "code": "          it(\"does not skip them if they're shorter than the current column\", () => {\n            editor.setCursorScreenPosition([5, 29]);\n            editor.addSelectionAbove();\n            expect(editor.getSelectedScreenRanges()).toEqual([[[5, 29], [5, 29]], [[4, 26], [4, 26]]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not skip lines that are shorter than the current column",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionAbove()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2128,
                "column": 72
            },
            "line": 2128,
            "code": "        it('does not skip lines that are shorter than the current column', () => {\n          editor.setCursorBufferPosition([6, 36]);\n          editor.addSelectionAbove();\n          editor.addSelectionAbove();\n          editor.addSelectionAbove();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[6, 36], [6, 36]], [[5, 30], [5, 30]], [[4, 29], [4, 29]], [[3, 36], [3, 36]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips empty lines when the column is non-zero",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionAbove()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2135,
                "column": 57
            },
            "line": 2135,
            "code": "        it('skips empty lines when the column is non-zero', () => {\n          editor.setCursorBufferPosition([11, 4]);\n          editor.addSelectionAbove();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[11, 4], [11, 4]], [[9, 4], [9, 4]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not skip empty lines when the column is zero",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionAbove()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2140,
                "column": 61
            },
            "line": 2140,
            "code": "        it('does not skip empty lines when the column is zero', () => {\n          editor.setCursorBufferPosition([10, 0]);\n          editor.addSelectionAbove();\n          expect(editor.getSelectedBufferRanges()).toEqual([[[10, 0], [10, 0]], [[9, 0], [9, 0]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not create a new selection if it would be fully contained within another selection",
            "suites": [
                "TextEditor",
                "selection",
                ".addSelectionAbove()",
                "when the selection is empty",
                "when lines are soft-wrapped"
            ],
            "updatePoint": {
                "line": 2146,
                "column": 97
            },
            "line": 2146,
            "code": "      it('does not create a new selection if it would be fully contained within another selection', () => {\n        editor.setText('abc\\ndef\\nghi\\njkl\\nmno');\n        editor.setCursorBufferPosition([4, 1]);\n        let addedSelectionCount = 0;\n        editor.onDidAddSelection(() => {\n          addedSelectionCount++;\n        });\n        editor.addSelectionAbove();\n        editor.addSelectionAbove();\n        editor.addSelectionAbove();\n        expect(addedSelectionCount).toBe(3);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "splits all multi-line selections into one selection per line",
            "suites": [
                "TextEditor",
                "selection",
                ".splitSelectionsIntoLines()"
            ],
            "updatePoint": {
                "line": 2160,
                "column": 70
            },
            "line": 2160,
            "code": "      it('splits all multi-line selections into one selection per line', () => {\n        editor.setSelectedBufferRange([[0, 3], [2, 4]]);\n        editor.splitSelectionsIntoLines();\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 3], [0, 29]], [[1, 0], [1, 30]], [[2, 0], [2, 4]]]);\n        editor.setSelectedBufferRange([[0, 3], [1, 10]]);\n        editor.splitSelectionsIntoLines();\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 3], [0, 29]], [[1, 0], [1, 10]]]);\n        editor.setSelectedBufferRange([[0, 0], [0, 3]]);\n        editor.splitSelectionsIntoLines();\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [0, 3]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys all selections but the oldest selection and autoscrolls to it, returning true if any selections were destroyed",
            "suites": [
                "TextEditor",
                "selection",
                "::consolidateSelections()"
            ],
            "updatePoint": {
                "line": 2182,
                "column": 129
            },
            "line": 2182,
            "code": "      it('destroys all selections but the oldest selection and autoscrolls to it, returning true if any selections were destroyed', () => {\n        const [selection1] = makeMultipleSelections();\n        const autoscrollEvents = [];\n        editor.onDidRequestAutoscroll(event => autoscrollEvents.push(event));\n        expect(editor.consolidateSelections()).toBeTruthy();\n        expect(editor.getSelections()).toEqual([selection1]);\n        expect(selection1.isEmpty()).toBeFalsy();\n        expect(editor.consolidateSelections()).toBeFalsy();\n        expect(editor.getSelections()).toEqual([selection1]);\n        expect(autoscrollEvents).toEqual([{\n          screenRange: selection1.getScreenRange(),\n          options: {\n            center: true,\n            reversed: false\n          }\n        }]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears the selection",
            "suites": [
                "TextEditor",
                "selection",
                "when the cursor is moved while there is a selection"
            ],
            "updatePoint": {
                "line": 2203,
                "column": 30
            },
            "line": 2203,
            "code": "      it('clears the selection', () => {\n        makeSelection();\n        editor.moveDown();\n        expect(selection.isEmpty()).toBeTruthy();\n        makeSelection();\n        editor.moveUp();\n        expect(selection.isEmpty()).toBeTruthy();\n        makeSelection();\n        editor.moveLeft();\n        expect(selection.isEmpty()).toBeTruthy();\n        makeSelection();\n        editor.moveRight();\n        expect(selection.isEmpty()).toBeTruthy();\n        makeSelection();\n        editor.setCursorScreenPosition([3, 3]);\n        expect(selection.isEmpty()).toBeTruthy();\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not share selections between different edit sessions for the same buffer",
            "suites": [
                "TextEditor",
                "selection",
                "when the cursor is moved while there is a selection"
            ],
            "updatePoint": {
                "line": 2221,
                "column": 85
            },
            "line": 2221,
            "code": "    it('does not share selections between different edit sessions for the same buffer', async () => {\n      atom.workspace.getActivePane().splitRight();\n      const editor2 = await atom.workspace.open(editor.getPath());\n      expect(editor2.getText()).toBe(editor.getText());\n      editor.setSelectedBufferRanges([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]);\n      editor2.setSelectedBufferRanges([[[8, 7], [6, 5]], [[4, 3], [2, 1]]]);\n      expect(editor2.getSelectedBufferRanges()).not.toEqual(editor.getSelectedBufferRanges());\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the line under the cursor up",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp"
            ],
            "updatePoint": {
                "line": 2232,
                "column": 44
            },
            "line": 2232,
            "code": "      it('moves the line under the cursor up', () => {\n        editor.setCursorBufferPosition([1, 0]);\n        editor.moveLineUp();\n        expect(editor.getTextInBufferRange([[0, 0], [0, 30]])).toBe('  var sort = function(items) {');\n        expect(editor.indentationForBufferRow(0)).toBe(1);\n        expect(editor.indentationForBufferRow(1)).toBe(0);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the line's indentation when the the autoIndent setting is true",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp"
            ],
            "updatePoint": {
                "line": 2239,
                "column": 80
            },
            "line": 2239,
            "code": "      it(\"updates the line's indentation when the the autoIndent setting is true\", () => {\n        editor.update({\n          autoIndent: true\n        });\n        editor.setCursorBufferPosition([1, 0]);\n        editor.moveLineUp();\n        expect(editor.indentationForBufferRow(0)).toBe(0);\n        expect(editor.indentationForBufferRow(1)).toBe(0);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the line to the preceding row",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there is a single selection",
                "when the selection spans a single line",
                "when there is no fold in the preceding row"
            ],
            "updatePoint": {
                "line": 2250,
                "column": 110
            },
            "line": 2250,
            "code": "          describe('when there is no fold in the preceding row', () => it('moves the line to the preceding row', () => {\n            expect(editor.lineTextForBufferRow(2)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            editor.setSelectedBufferRange([[3, 2], [3, 9]]);\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRange()).toEqual([[2, 2], [2, 9]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(3)).toBe('    if (items.length <= 1) return items;');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the line to the previous row without breaking the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there is a single selection",
                "when the selection spans a single line",
                "when the cursor is at the beginning of a fold"
            ],
            "updatePoint": {
                "line": 2259,
                "column": 138
            },
            "line": 2259,
            "code": "          describe('when the cursor is at the beginning of a fold', () => it('moves the line to the previous row without breaking the fold', () => {\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.foldBufferRowRange(4, 7);\n            editor.setSelectedBufferRange([[4, 2], [4, 9]], {\n              preserveFolds: true\n            });\n            expect(editor.getSelectedBufferRange()).toEqual([[4, 2], [4, 9]]);\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRange()).toEqual([[3, 2], [3, 9]]);\n            expect(editor.lineTextForBufferRow(3)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(7)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.isFoldedAtBufferRow(3)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeFalsy();\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the line above the folded row and perseveres the correct folds",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there is a single selection",
                "when the selection spans a single line",
                "when the preceding row consists of folded code"
            ],
            "updatePoint": {
                "line": 2281,
                "column": 147
            },
            "line": 2281,
            "code": "          describe('when the preceding row consists of folded code', () => it('moves the line above the folded row and perseveres the correct folds', () => {\n            expect(editor.lineTextForBufferRow(8)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n            expect(editor.lineTextForBufferRow(9)).toBe('  };');\n            editor.foldBufferRowRange(4, 7);\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            editor.setSelectedBufferRange([[8, 0], [8, 4]]);\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRange()).toEqual([[4, 0], [4, 4]]);\n            expect(editor.lineTextForBufferRow(4)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n            expect(editor.lineTextForBufferRow(5)).toBe('    while(items.length > 0) {');\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeFalsy();\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the lines spanned by the selection to the preceding row",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there is a single selection",
                "when the selection spans multiple lines"
            ],
            "updatePoint": {
                "line": 2303,
                "column": 75
            },
            "line": 2303,
            "code": "          it('moves the lines spanned by the selection to the preceding row', () => {\n            expect(editor.lineTextForBufferRow(2)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.setSelectedBufferRange([[3, 2], [4, 9]]);\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRange()).toEqual([[2, 2], [3, 9]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(3)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(4)).toBe('    if (items.length <= 1) return items;');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the lines to the previous row without breaking the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there is a single selection",
                "when the selection spans multiple lines",
                "when the selection's end intersects a fold"
            ],
            "updatePoint": {
                "line": 2314,
                "column": 136
            },
            "line": 2314,
            "code": "          describe(\"when the selection's end intersects a fold\", () => it('moves the lines to the previous row without breaking the fold', () => {\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.foldBufferRowRange(4, 7);\n            editor.setSelectedBufferRange([[3, 2], [4, 9]], {\n              preserveFolds: true\n            });\n            expect(editor.isFoldedAtBufferRow(3)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRange()).toEqual([[2, 2], [3, 9]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(3)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(7)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.isFoldedAtBufferRow(2)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(3)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeFalsy();\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the lines to the previous row without breaking the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there is a single selection",
                "when the selection spans multiple lines",
                "when the selection's start intersects a fold"
            ],
            "updatePoint": {
                "line": 2338,
                "column": 138
            },
            "line": 2338,
            "code": "          describe(\"when the selection's start intersects a fold\", () => it('moves the lines to the previous row without breaking the fold', () => {\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.foldBufferRowRange(4, 7);\n            editor.setSelectedBufferRange([[4, 2], [8, 9]], {\n              preserveFolds: true\n            });\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeFalsy();\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRange()).toEqual([[3, 2], [7, 9]]);\n            expect(editor.lineTextForBufferRow(3)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(7)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n            expect(editor.lineTextForBufferRow(8)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.isFoldedAtBufferRow(3)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not move the last line of the selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there is a single selection",
                "when the selection spans multiple lines, but ends at column 0"
            ],
            "updatePoint": {
                "line": 2364,
                "column": 58
            },
            "line": 2364,
            "code": "          it('does not move the last line of the selection', () => {\n            expect(editor.lineTextForBufferRow(2)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.setSelectedBufferRange([[3, 2], [4, 0]]);\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRange()).toEqual([[2, 2], [3, 0]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(3)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the lines spanned by the selection to the preceding row, but preserves the folded code",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there is a single selection",
                "when the preceding row is a folded row"
            ],
            "updatePoint": {
                "line": 2377,
                "column": 106
            },
            "line": 2377,
            "code": "          it('moves the lines spanned by the selection to the preceding row, but preserves the folded code', () => {\n            expect(editor.lineTextForBufferRow(8)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n            expect(editor.lineTextForBufferRow(9)).toBe('  };');\n            editor.foldBufferRowRange(4, 7);\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            editor.setSelectedBufferRange([[8, 0], [9, 2]]);\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRange()).toEqual([[4, 0], [5, 2]]);\n            expect(editor.lineTextForBufferRow(4)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n            expect(editor.lineTextForBufferRow(5)).toBe('  };');\n            expect(editor.lineTextForBufferRow(6)).toBe('    while(items.length > 0) {');\n            expect(editor.isFoldedAtBufferRow(5)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(10)).toBeFalsy();\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves all lines that are spanned by a selection to the preceding row",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there are multiple selections",
                "when all the selections span different lines",
                "when there is no folds"
            ],
            "updatePoint": {
                "line": 2403,
                "column": 123
            },
            "line": 2403,
            "code": "          describe('when there is no folds', () => it('moves all lines that are spanned by a selection to the preceding row', () => {\n            editor.setSelectedBufferRanges([[[1, 2], [1, 9]], [[3, 2], [3, 9]], [[5, 2], [5, 9]]]);\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRanges()).toEqual([[[0, 2], [0, 9]], [[2, 2], [2, 9]], [[4, 2], [4, 9]]]);\n            expect(editor.lineTextForBufferRow(0)).toBe('  var sort = function(items) {');\n            expect(editor.lineTextForBufferRow(1)).toBe('var quicksort = function () {');\n            expect(editor.lineTextForBufferRow(2)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(3)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(4)).toBe('      current = items.shift();');\n            expect(editor.lineTextForBufferRow(5)).toBe('    while(items.length > 0) {');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the lines to the previous row without breaking the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there are multiple selections",
                "when all the selections span different lines",
                "when one selection intersects a fold"
            ],
            "updatePoint": {
                "line": 2414,
                "column": 130
            },
            "line": 2414,
            "code": "          describe('when one selection intersects a fold', () => it('moves the lines to the previous row without breaking the fold', () => {\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.foldBufferRowRange(4, 7);\n            editor.setSelectedBufferRanges([[[2, 2], [2, 9]], [[4, 2], [4, 9]]], {\n              preserveFolds: true\n            });\n            expect(editor.isFoldedAtBufferRow(2)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(3)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeFalsy();\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRanges()).toEqual([[[1, 2], [1, 9]], [[3, 2], [3, 9]]]);\n            expect(editor.lineTextForBufferRow(1)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(2)).toBe('  var sort = function(items) {');\n            expect(editor.lineTextForBufferRow(3)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(7)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.isFoldedAtBufferRow(1)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(2)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(3)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves all lines that spanned by a selection to preceding row, preserving all folds",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there are multiple selections",
                "when all the selections span different lines",
                "when there is a fold"
            ],
            "updatePoint": {
                "line": 2443,
                "column": 135
            },
            "line": 2443,
            "code": "          describe('when there is a fold', () => it('moves all lines that spanned by a selection to preceding row, preserving all folds', () => {\n            editor.foldBufferRowRange(4, 7);\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            editor.setSelectedBufferRanges([[[8, 0], [8, 3]], [[11, 0], [11, 5]]]);\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRanges()).toEqual([[[4, 0], [4, 3]], [[10, 0], [10, 5]]]);\n            expect(editor.lineTextForBufferRow(4)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n            expect(editor.lineTextForBufferRow(10)).toBe('  return sort(Array.apply(this, arguments));');\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeFalsy();\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves and preserves all the folds",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there are multiple selections",
                "when there are many folds",
                "and many selections intersects folded rows"
            ],
            "updatePoint": {
                "line": 2468,
                "column": 108
            },
            "line": 2468,
            "code": "          describe('and many selections intersects folded rows', () => it('moves and preserves all the folds', () => {\n            editor.foldBufferRowRange(2, 4);\n            editor.foldBufferRowRange(7, 9);\n            editor.setSelectedBufferRanges([[[1, 0], [5, 4]], [[7, 0], [7, 4]]], {\n              preserveFolds: true\n            });\n            editor.moveLineUp();\n            expect(editor.lineTextForBufferRow(1)).toEqual('function f3() {');\n            expect(editor.lineTextForBufferRow(4)).toEqual('6;');\n            expect(editor.lineTextForBufferRow(5)).toEqual('1;');\n            expect(editor.lineTextForBufferRow(6)).toEqual('function f8() {');\n            expect(editor.lineTextForBufferRow(9)).toEqual('7;');\n            expect(editor.isFoldedAtBufferRow(1)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(2)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(3)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeFalsy();\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves lines that contain multiple selections correctly",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there are multiple selections",
                "when some of the selections span the same lines"
            ],
            "updatePoint": {
                "line": 2491,
                "column": 68
            },
            "line": 2491,
            "code": "          it('moves lines that contain multiple selections correctly', () => {\n            editor.setSelectedBufferRanges([[[3, 2], [3, 9]], [[3, 12], [3, 13]]]);\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRanges()).toEqual([[[2, 2], [2, 9]], [[2, 12], [2, 13]]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't move any lines, since line 0 can't move",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there are multiple selections",
                "when one of the selections spans line 0"
            ],
            "updatePoint": {
                "line": 2499,
                "column": 61
            },
            "line": 2499,
            "code": "          it(\"doesn't move any lines, since line 0 can't move\", () => {\n            editor.setSelectedBufferRanges([[[0, 2], [1, 9]], [[2, 2], [2, 9]], [[4, 2], [4, 9]]]);\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRanges()).toEqual([[[0, 2], [1, 9]], [[2, 2], [2, 9]], [[4, 2], [4, 9]]]);\n            expect(buffer.isModified()).toBe(false);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't move any lines, since the last line can't move",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineUp",
                "when there are multiple selections",
                "when one of the selections spans the last line, and it is empty"
            ],
            "updatePoint": {
                "line": 2507,
                "column": 68
            },
            "line": 2507,
            "code": "          it(\"doesn't move any lines, since the last line can't move\", () => {\n            buffer.append('\\n');\n            editor.setSelectedBufferRanges([[[0, 2], [1, 9]], [[2, 2], [2, 9]], [[13, 0], [13, 0]]]);\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRanges()).toEqual([[[0, 2], [1, 9]], [[2, 2], [2, 9]], [[13, 0], [13, 0]]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the line under the cursor down",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown"
            ],
            "updatePoint": {
                "line": 2517,
                "column": 46
            },
            "line": 2517,
            "code": "      it('moves the line under the cursor down', () => {\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveLineDown();\n        expect(editor.getTextInBufferRange([[1, 0], [1, 31]])).toBe('var quicksort = function () {');\n        expect(editor.indentationForBufferRow(0)).toBe(1);\n        expect(editor.indentationForBufferRow(1)).toBe(0);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the line's indentation when the editor.autoIndent setting is true",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown"
            ],
            "updatePoint": {
                "line": 2524,
                "column": 83
            },
            "line": 2524,
            "code": "      it(\"updates the line's indentation when the editor.autoIndent setting is true\", () => {\n        editor.update({\n          autoIndent: true\n        });\n        editor.setCursorBufferPosition([0, 0]);\n        editor.moveLineDown();\n        expect(editor.indentationForBufferRow(0)).toBe(1);\n        expect(editor.indentationForBufferRow(1)).toBe(2);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the line to the following row",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there is a single selection",
                "when the selection spans a single line",
                "when there is no fold in the following row"
            ],
            "updatePoint": {
                "line": 2535,
                "column": 110
            },
            "line": 2535,
            "code": "          describe('when there is no fold in the following row', () => it('moves the line to the following row', () => {\n            expect(editor.lineTextForBufferRow(2)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            editor.setSelectedBufferRange([[2, 2], [2, 9]]);\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRange()).toEqual([[3, 2], [3, 9]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(3)).toBe('    if (items.length <= 1) return items;');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the line to the following row without breaking the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there is a single selection",
                "when the selection spans a single line",
                "when the cursor is at the beginning of a fold"
            ],
            "updatePoint": {
                "line": 2544,
                "column": 139
            },
            "line": 2544,
            "code": "          describe('when the cursor is at the beginning of a fold', () => it('moves the line to the following row without breaking the fold', () => {\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.foldBufferRowRange(4, 7);\n            editor.setSelectedBufferRange([[4, 2], [4, 9]], {\n              preserveFolds: true\n            });\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRange()).toEqual([[5, 2], [5, 9]]);\n            expect(editor.lineTextForBufferRow(4)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n            expect(editor.lineTextForBufferRow(5)).toBe('    while(items.length > 0) {');\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeFalsy();\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the line below the folded row and preserves the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there is a single selection",
                "when the selection spans a single line",
                "when the following row is a folded row"
            ],
            "updatePoint": {
                "line": 2565,
                "column": 129
            },
            "line": 2565,
            "code": "          describe('when the following row is a folded row', () => it('moves the line below the folded row and preserves the fold', () => {\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.foldBufferRowRange(4, 7);\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            editor.setSelectedBufferRange([[3, 0], [3, 4]]);\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRange()).toEqual([[7, 0], [7, 4]]);\n            expect(editor.lineTextForBufferRow(3)).toBe('    while(items.length > 0) {');\n            expect(editor.isFoldedAtBufferRow(3)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeFalsy();\n            expect(editor.lineTextForBufferRow(7)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the lines spanned by the selection to the following row",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there is a single selection",
                "when the selection spans multiple lines"
            ],
            "updatePoint": {
                "line": 2587,
                "column": 75
            },
            "line": 2587,
            "code": "          it('moves the lines spanned by the selection to the following row', () => {\n            expect(editor.lineTextForBufferRow(2)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.setSelectedBufferRange([[2, 2], [3, 9]]);\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRange()).toEqual([[3, 2], [4, 9]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(3)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(4)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not move the last line of the selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there is a single selection",
                "when the selection spans multiple lines, but ends at column 0"
            ],
            "updatePoint": {
                "line": 2600,
                "column": 58
            },
            "line": 2600,
            "code": "          it('does not move the last line of the selection', () => {\n            expect(editor.lineTextForBufferRow(2)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.setSelectedBufferRange([[2, 2], [3, 0]]);\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRange()).toEqual([[3, 2], [4, 0]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(3)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the lines to the following row without breaking the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there is a single selection",
                "when the selection's end intersects a fold"
            ],
            "updatePoint": {
                "line": 2613,
                "column": 76
            },
            "line": 2613,
            "code": "          it('moves the lines to the following row without breaking the fold', () => {\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.foldBufferRowRange(4, 7);\n            editor.setSelectedBufferRange([[3, 2], [4, 9]], {\n              preserveFolds: true\n            });\n            expect(editor.isFoldedAtBufferRow(3)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRange()).toEqual([[4, 2], [5, 9]]);\n            expect(editor.lineTextForBufferRow(3)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n            expect(editor.lineTextForBufferRow(4)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(5)).toBe('    while(items.length > 0) {');\n            expect(editor.isFoldedAtBufferRow(4)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeFalsy();\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the lines to the following row without breaking the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there is a single selection",
                "when the selection's start intersects a fold"
            ],
            "updatePoint": {
                "line": 2639,
                "column": 76
            },
            "line": 2639,
            "code": "          it('moves the lines to the following row without breaking the fold', () => {\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.foldBufferRowRange(4, 7);\n            editor.setSelectedBufferRange([[4, 2], [8, 9]], {\n              preserveFolds: true\n            });\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeFalsy();\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRange()).toEqual([[5, 2], [9, 9]]);\n            expect(editor.lineTextForBufferRow(4)).toBe('  };');\n            expect(editor.lineTextForBufferRow(5)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(9)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n            expect(editor.isFoldedAtBufferRow(4)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(10)).toBeFalsy();\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the lines spanned by the selection to the following row, but preserves the folded code",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there is a single selection",
                "when the following row is a folded row"
            ],
            "updatePoint": {
                "line": 2666,
                "column": 106
            },
            "line": 2666,
            "code": "          it('moves the lines spanned by the selection to the following row, but preserves the folded code', () => {\n            expect(editor.lineTextForBufferRow(2)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            editor.foldBufferRowRange(4, 7);\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            editor.setSelectedBufferRange([[2, 0], [3, 2]]);\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRange()).toEqual([[6, 0], [7, 2]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('    while(items.length > 0) {');\n            expect(editor.isFoldedAtBufferRow(1)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(2)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(3)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeFalsy();\n            expect(editor.lineTextForBufferRow(6)).toBe('    if (items.length <= 1) return items;');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "appends line ending to last line and moves the lines spanned by the selection to the preceding row",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there is a single selection",
                "when the last line of selection does not end with a valid line ending"
            ],
            "updatePoint": {
                "line": 2689,
                "column": 112
            },
            "line": 2689,
            "code": "          it('appends line ending to last line and moves the lines spanned by the selection to the preceding row', () => {\n            expect(editor.lineTextForBufferRow(9)).toBe('  };');\n            expect(editor.lineTextForBufferRow(10)).toBe('');\n            expect(editor.lineTextForBufferRow(11)).toBe('  return sort(Array.apply(this, arguments));');\n            expect(editor.lineTextForBufferRow(12)).toBe('};');\n            editor.setSelectedBufferRange([[10, 0], [12, 2]]);\n            editor.moveLineUp();\n            expect(editor.getSelectedBufferRange()).toEqual([[9, 0], [11, 2]]);\n            expect(editor.lineTextForBufferRow(9)).toBe('');\n            expect(editor.lineTextForBufferRow(10)).toBe('  return sort(Array.apply(this, arguments));');\n            expect(editor.lineTextForBufferRow(11)).toBe('};');\n            expect(editor.lineTextForBufferRow(12)).toBe('  };');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves all lines that are spanned by a selection to the following row",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there are multiple selections",
                "when all the selections span different lines",
                "when there is no folds"
            ],
            "updatePoint": {
                "line": 2706,
                "column": 123
            },
            "line": 2706,
            "code": "          describe('when there is no folds', () => it('moves all lines that are spanned by a selection to the following row', () => {\n            editor.setSelectedBufferRanges([[[1, 2], [1, 9]], [[3, 2], [3, 9]], [[5, 2], [5, 9]]]);\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRanges()).toEqual([[[6, 2], [6, 9]], [[4, 2], [4, 9]], [[2, 2], [2, 9]]]);\n            expect(editor.lineTextForBufferRow(1)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(2)).toBe('  var sort = function(items) {');\n            expect(editor.lineTextForBufferRow(3)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(4)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(5)).toBe('      current < pivot ? left.push(current) : right.push(current);');\n            expect(editor.lineTextForBufferRow(6)).toBe('      current = items.shift();');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves and preserves all the folds",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there are multiple selections",
                "when all the selections span different lines",
                "when there are many folds",
                "and many selections intersects folded rows"
            ],
            "updatePoint": {
                "line": 2723,
                "column": 110
            },
            "line": 2723,
            "code": "            describe('and many selections intersects folded rows', () => it('moves and preserves all the folds', () => {\n              editor.foldBufferRowRange(2, 4);\n              editor.foldBufferRowRange(7, 9);\n              editor.setSelectedBufferRanges([[[2, 0], [2, 4]], [[6, 0], [10, 4]]], {\n                preserveFolds: true\n              });\n              editor.moveLineDown();\n              expect(editor.lineTextForBufferRow(2)).toEqual('6;');\n              expect(editor.lineTextForBufferRow(3)).toEqual('function f3() {');\n              expect(editor.lineTextForBufferRow(6)).toEqual('12;');\n              expect(editor.lineTextForBufferRow(7)).toEqual('7;');\n              expect(editor.lineTextForBufferRow(8)).toEqual('function f8() {');\n              expect(editor.lineTextForBufferRow(11)).toEqual('11;');\n              expect(editor.isFoldedAtBufferRow(2)).toBeFalsy();\n              expect(editor.isFoldedAtBufferRow(3)).toBeTruthy();\n              expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n              expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n              expect(editor.isFoldedAtBufferRow(6)).toBeFalsy();\n              expect(editor.isFoldedAtBufferRow(7)).toBeFalsy();\n              expect(editor.isFoldedAtBufferRow(8)).toBeTruthy();\n              expect(editor.isFoldedAtBufferRow(9)).toBeTruthy();\n              expect(editor.isFoldedAtBufferRow(10)).toBeTruthy();\n              expect(editor.isFoldedAtBufferRow(11)).toBeFalsy();\n            }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves all lines spanned by a selection to the following row, preserving the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there are multiple selections",
                "when all the selections span different lines",
                "when there is a fold below one of the selected row"
            ],
            "updatePoint": {
                "line": 2748,
                "column": 163
            },
            "line": 2748,
            "code": "          describe('when there is a fold below one of the selected row', () => it('moves all lines spanned by a selection to the following row, preserving the fold', () => {\n            editor.foldBufferRowRange(4, 7);\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            editor.setSelectedBufferRanges([[[1, 2], [1, 6]], [[3, 0], [3, 4]], [[8, 0], [8, 3]]]);\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRanges()).toEqual([[[9, 0], [9, 3]], [[7, 0], [7, 4]], [[2, 2], [2, 6]]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('  var sort = function(items) {');\n            expect(editor.isFoldedAtBufferRow(3)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeFalsy();\n            expect(editor.lineTextForBufferRow(7)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(9)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves all the lines below the fold, preserving the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there are multiple selections",
                "when all the selections span different lines",
                "when there is a fold below a group of multiple selections without any lines with no selection in-between"
            ],
            "updatePoint": {
                "line": 2767,
                "column": 192
            },
            "line": 2767,
            "code": "          describe('when there is a fold below a group of multiple selections without any lines with no selection in-between', () => it('moves all the lines below the fold, preserving the fold', () => {\n            editor.foldBufferRowRange(4, 7);\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            editor.setSelectedBufferRanges([[[2, 2], [2, 6]], [[3, 0], [3, 4]]]);\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRanges()).toEqual([[[7, 0], [7, 4]], [[6, 2], [6, 6]]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('    while(items.length > 0) {');\n            expect(editor.isFoldedAtBufferRow(2)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(3)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeFalsy();\n            expect(editor.lineTextForBufferRow(6)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(7)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the lines to the previous row without breaking the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there are multiple selections",
                "when one selection intersects a fold"
            ],
            "updatePoint": {
                "line": 2788,
                "column": 75
            },
            "line": 2788,
            "code": "          it('moves the lines to the previous row without breaking the fold', () => {\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n            editor.foldBufferRowRange(4, 7);\n            editor.setSelectedBufferRanges([[[2, 2], [2, 9]], [[4, 2], [4, 9]]], {\n              preserveFolds: true\n            });\n            expect(editor.isFoldedAtBufferRow(2)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(3)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeFalsy();\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRanges()).toEqual([[[5, 2], [5, 9]], [[3, 2], [3, 9]]]);\n            expect(editor.lineTextForBufferRow(2)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(3)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(4)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n            expect(editor.lineTextForBufferRow(5)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(9)).toBe('  };');\n            expect(editor.isFoldedAtBufferRow(2)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(3)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(4)).toBeFalsy();\n            expect(editor.isFoldedAtBufferRow(5)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(7)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(8)).toBeTruthy();\n            expect(editor.isFoldedAtBufferRow(9)).toBeFalsy();\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves lines that contain multiple selections correctly",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there are multiple selections",
                "when some of the selections span the same lines"
            ],
            "updatePoint": {
                "line": 2820,
                "column": 68
            },
            "line": 2820,
            "code": "          it('moves lines that contain multiple selections correctly', () => {\n            editor.setSelectedBufferRanges([[[3, 2], [3, 9]], [[3, 12], [3, 13]]]);\n            editor.moveLineDown();\n            expect(editor.getSelectedBufferRanges()).toEqual([[[4, 12], [4, 13]], [[4, 2], [4, 9]]]);\n            expect(editor.lineTextForBufferRow(3)).toBe('    while(items.length > 0) {');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the lines past the soft wrapped line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when there are multiple selections",
                "when the selections are above a wrapped line"
            ],
            "updatePoint": {
                "line": 2839,
                "column": 56
            },
            "line": 2839,
            "code": "          it('moves the lines past the soft wrapped line', () => {\n            editor.setSelectedBufferRanges([[[0, 0], [0, 0]], [[1, 0], [1, 0]]]);\n            editor.moveLineDown();\n            expect(editor.lineTextForBufferRow(0)).not.toBe('2');\n            expect(editor.lineTextForBufferRow(1)).toBe('1');\n            expect(editor.lineTextForBufferRow(2)).toBe('2');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't move it",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveLineDown",
                "when the line is the last buffer row"
            ],
            "updatePoint": {
                "line": 2849,
                "column": 27
            },
            "line": 2849,
            "code": "        it(\"doesn't move it\", () => {\n          editor.setText('abc\\ndef');\n          editor.setCursorBufferPosition([1, 0]);\n          editor.moveLineDown();\n          expect(editor.getText()).toBe('abc\\ndef');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces the selection with the given text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertText(text)",
                "when there is a single selection"
            ],
            "updatePoint": {
                "line": 2860,
                "column": 54
            },
            "line": 2860,
            "code": "        it('replaces the selection with the given text', () => {\n          const range = editor.insertText('xxx');\n          expect(range).toEqual([[[1, 0], [1, 3]]]);\n          expect(buffer.lineForRow(1)).toBe('xxxvar sort = function(items) {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts the given text at the location of each cursor and moves the cursors to the end of each cursor's inserted text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertText(text)",
                "when there are multiple empty selections",
                "when the cursors are on the same line"
            ],
            "updatePoint": {
                "line": 2868,
                "column": 131
            },
            "line": 2868,
            "code": "          it(\"inserts the given text at the location of each cursor and moves the cursors to the end of each cursor's inserted text\", () => {\n            editor.setCursorScreenPosition([1, 2]);\n            editor.addCursorAtScreenPosition([1, 5]);\n            editor.insertText('xxx');\n            expect(buffer.lineForRow(1)).toBe('  xxxvarxxx sort = function(items) {');\n            const [cursor1, cursor2] = editor.getCursors();\n            expect(cursor1.getBufferPosition()).toEqual([1, 5]);\n            expect(cursor2.getBufferPosition()).toEqual([1, 11]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts the given text at the location of each cursor and moves the cursors to the end of each cursor's inserted text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertText(text)",
                "when there are multiple empty selections",
                "when the cursors are on different lines"
            ],
            "updatePoint": {
                "line": 2879,
                "column": 131
            },
            "line": 2879,
            "code": "          it(\"inserts the given text at the location of each cursor and moves the cursors to the end of each cursor's inserted text\", () => {\n            editor.setCursorScreenPosition([1, 2]);\n            editor.addCursorAtScreenPosition([2, 4]);\n            editor.insertText('xxx');\n            expect(buffer.lineForRow(1)).toBe('  xxxvar sort = function(items) {');\n            expect(buffer.lineForRow(2)).toBe('    xxxif (items.length <= 1) return items;');\n            const [cursor1, cursor2] = editor.getCursors();\n            expect(cursor1.getBufferPosition()).toEqual([1, 5]);\n            expect(cursor2.getBufferPosition()).toEqual([2, 7]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces each selection range with the inserted characters",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertText(text)",
                "when there are multiple non-empty selections",
                "when the selections are on the same line"
            ],
            "updatePoint": {
                "line": 2893,
                "column": 72
            },
            "line": 2893,
            "code": "          it('replaces each selection range with the inserted characters', () => {\n            editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[0, 22], [0, 24]]]);\n            editor.insertText('x');\n            const [cursor1, cursor2] = editor.getCursors();\n            const [selection1, selection2] = editor.getSelections();\n            expect(cursor1.getScreenPosition()).toEqual([0, 5]);\n            expect(cursor2.getScreenPosition()).toEqual([0, 15]);\n            expect(selection1.isEmpty()).toBeTruthy();\n            expect(selection2.isEmpty()).toBeTruthy();\n            expect(editor.lineTextForBufferRow(0)).toBe('var x = functix () {');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces each selection with the given text, clears the selections, and places the cursor at the end of each selection's inserted text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertText(text)",
                "when there are multiple non-empty selections",
                "when the selections are on different lines"
            ],
            "updatePoint": {
                "line": 2906,
                "column": 148
            },
            "line": 2906,
            "code": "          it(\"replaces each selection with the given text, clears the selections, and places the cursor at the end of each selection's inserted text\", () => {\n            editor.setSelectedBufferRanges([[[1, 0], [1, 2]], [[2, 0], [2, 4]]]);\n            editor.insertText('xxx');\n            expect(buffer.lineForRow(1)).toBe('xxxvar sort = function(items) {');\n            expect(buffer.lineForRow(2)).toBe('xxxif (items.length <= 1) return items;');\n            const [selection1, selection2] = editor.getSelections();\n            expect(selection1.isEmpty()).toBeTruthy();\n            expect(selection1.cursor.getBufferPosition()).toEqual([1, 3]);\n            expect(selection2.isEmpty()).toBeTruthy();\n            expect(selection2.cursor.getBufferPosition()).toEqual([2, 3]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys the selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertText(text)",
                "when there is a selection that ends on a folded line"
            ],
            "updatePoint": {
                "line": 2920,
                "column": 34
            },
            "line": 2920,
            "code": "        it('destroys the selection', () => {\n          editor.foldBufferRowRange(2, 4);\n          editor.setSelectedBufferRange([[1, 0], [2, 0]]);\n          editor.insertText('holy cow');\n          expect(editor.isFoldedAtScreenRow(2)).toBeFalsy();\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies the observers when inserting text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertText(text)",
                "when there are ::onWillInsertText and ::onDidInsertText observers"
            ],
            "updatePoint": {
                "line": 2929,
                "column": 54
            },
            "line": 2929,
            "code": "        it('notifies the observers when inserting text', () => {\n          const willInsertSpy = jasmine.createSpy().andCallFake(() => expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {'));\n          const didInsertSpy = jasmine.createSpy().andCallFake(() => expect(buffer.lineForRow(1)).toBe('xxxvar sort = function(items) {'));\n          editor.onWillInsertText(willInsertSpy);\n          editor.onDidInsertText(didInsertSpy);\n          expect(editor.insertText('xxx')).toBeTruthy();\n          expect(buffer.lineForRow(1)).toBe('xxxvar sort = function(items) {');\n          expect(willInsertSpy).toHaveBeenCalled();\n          expect(didInsertSpy).toHaveBeenCalled();\n          let options = willInsertSpy.mostRecentCall.args[0];\n          expect(options.text).toBe('xxx');\n          expect(options.cancel).toBeDefined();\n          options = didInsertSpy.mostRecentCall.args[0];\n          expect(options.text).toBe('xxx');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "cancels text insertion when an ::onWillInsertText observer calls cancel on an event",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertText(text)",
                "when there are ::onWillInsertText and ::onDidInsertText observers"
            ],
            "updatePoint": {
                "line": 2944,
                "column": 95
            },
            "line": 2944,
            "code": "        it('cancels text insertion when an ::onWillInsertText observer calls cancel on an event', () => {\n          const willInsertSpy = jasmine.createSpy().andCallFake(({\n            cancel\n          }) => cancel());\n          const didInsertSpy = jasmine.createSpy();\n          editor.onWillInsertText(willInsertSpy);\n          editor.onDidInsertText(didInsertSpy);\n          expect(editor.insertText('xxx')).toBe(false);\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {');\n          expect(willInsertSpy).toHaveBeenCalled();\n          expect(didInsertSpy).not.toHaveBeenCalled();\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "groups the change with the previous change for purposes of undo and redo",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertText(text)",
                "when the undo option is set to 'skip'"
            ],
            "updatePoint": {
                "line": 2958,
                "column": 84
            },
            "line": 2958,
            "code": "        it('groups the change with the previous change for purposes of undo and redo', () => {\n          editor.setSelectedBufferRanges([[[0, 0], [0, 0]], [[1, 0], [1, 0]]]);\n          editor.insertText('x');\n          editor.insertText('y', {\n            undo: 'skip'\n          });\n          editor.undo();\n          expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts an empty line before it",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewline()",
                "when there is a single cursor",
                "when the cursor is at the beginning of a line"
            ],
            "updatePoint": {
                "line": 2973,
                "column": 45
            },
            "line": 2973,
            "code": "          it('inserts an empty line before it', () => {\n            editor.setCursorScreenPosition({\n              row: 1,\n              column: 0\n            });\n            editor.insertNewline();\n            expect(buffer.lineForRow(1)).toBe('');\n            expect(editor.getCursorScreenPosition()).toEqual({\n              row: 2,\n              column: 0\n            });\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "splits the current line to form a new line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewline()",
                "when there is a single cursor",
                "when the cursor is in the middle of a line"
            ],
            "updatePoint": {
                "line": 2987,
                "column": 56
            },
            "line": 2987,
            "code": "          it('splits the current line to form a new line', () => {\n            editor.setCursorScreenPosition({\n              row: 1,\n              column: 6\n            });\n            const originalLine = buffer.lineForRow(1);\n            const lineBelowOriginalLine = buffer.lineForRow(2);\n            editor.insertNewline();\n            expect(buffer.lineForRow(1)).toBe(originalLine.slice(0, 6));\n            expect(buffer.lineForRow(2)).toBe(originalLine.slice(6));\n            expect(buffer.lineForRow(3)).toBe(lineBelowOriginalLine);\n            expect(editor.getCursorScreenPosition()).toEqual({\n              row: 2,\n              column: 0\n            });\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts an empty line after it",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewline()",
                "when there is a single cursor",
                "when the cursor is on the end of a line"
            ],
            "updatePoint": {
                "line": 3005,
                "column": 44
            },
            "line": 3005,
            "code": "          it('inserts an empty line after it', () => {\n            editor.setCursorScreenPosition({\n              row: 1,\n              column: buffer.lineForRow(1).length\n            });\n            editor.insertNewline();\n            expect(buffer.lineForRow(2)).toBe('');\n            expect(editor.getCursorScreenPosition()).toEqual({\n              row: 2,\n              column: 0\n            });\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "breaks the line at the cursor locations",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewline()",
                "when there are multiple cursors",
                "when the cursors are on the same line"
            ],
            "updatePoint": {
                "line": 3021,
                "column": 53
            },
            "line": 3021,
            "code": "          it('breaks the line at the cursor locations', () => {\n            editor.setCursorScreenPosition([3, 13]);\n            editor.addCursorAtScreenPosition([3, 38]);\n            editor.insertNewline();\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot');\n            expect(editor.lineTextForBufferRow(4)).toBe(' = items.shift(), current');\n            expect(editor.lineTextForBufferRow(5)).toBe(', left = [], right = [];');\n            expect(editor.lineTextForBufferRow(6)).toBe('    while(items.length > 0) {');\n            const [cursor1, cursor2] = editor.getCursors();\n            expect(cursor1.getBufferPosition()).toEqual([4, 0]);\n            expect(cursor2.getBufferPosition()).toEqual([5, 0]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts newlines at each cursor location",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewline()",
                "when there are multiple cursors",
                "when the cursors are on different lines"
            ],
            "updatePoint": {
                "line": 3035,
                "column": 54
            },
            "line": 3035,
            "code": "          it('inserts newlines at each cursor location', () => {\n            editor.setCursorScreenPosition([3, 0]);\n            editor.addCursorAtScreenPosition([6, 0]);\n            editor.insertText('\\n');\n            expect(editor.lineTextForBufferRow(3)).toBe('');\n            expect(editor.lineTextForBufferRow(4)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(5)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(6)).toBe('      current = items.shift();');\n            expect(editor.lineTextForBufferRow(7)).toBe('');\n            expect(editor.lineTextForBufferRow(8)).toBe('      current < pivot ? left.push(current) : right.push(current);');\n            expect(editor.lineTextForBufferRow(9)).toBe('    }');\n            const [cursor1, cursor2] = editor.getCursors();\n            expect(cursor1.getBufferPosition()).toEqual([4, 0]);\n            expect(cursor2.getBufferPosition()).toEqual([8, 0]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "places the cursor back at the previous location",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewlineBelow()",
                "when the operation is undone"
            ],
            "updatePoint": {
                "line": 3055,
                "column": 59
            },
            "line": 3055,
            "code": "        it('places the cursor back at the previous location', () => {\n          editor.setCursorBufferPosition([0, 2]);\n          editor.insertNewlineBelow();\n          expect(editor.getCursorBufferPosition()).toEqual([1, 0]);\n          editor.undo();\n          expect(editor.getCursorBufferPosition()).toEqual([0, 2]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts a newline below the cursor's current line, autoindents it, and moves the cursor to the end of the line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewlineBelow()",
                "when the operation is undone"
            ],
            "updatePoint": {
                "line": 3063,
                "column": 120
            },
            "line": 3063,
            "code": "      it(\"inserts a newline below the cursor's current line, autoindents it, and moves the cursor to the end of the line\", () => {\n        editor.update({\n          autoIndent: true\n        });\n        editor.insertNewlineBelow();\n        expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');\n        expect(buffer.lineForRow(1)).toBe('  ');\n        expect(editor.getCursorBufferPosition()).toEqual([1, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts a newline on the first line and moves the cursor to the first line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewlineAbove()",
                "when the cursor is on first line"
            ],
            "updatePoint": {
                "line": 3075,
                "column": 86
            },
            "line": 3075,
            "code": "        it('inserts a newline on the first line and moves the cursor to the first line', () => {\n          editor.setCursorBufferPosition([0]);\n          editor.insertNewlineAbove();\n          expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n          expect(editor.lineTextForBufferRow(0)).toBe('');\n          expect(editor.lineTextForBufferRow(1)).toBe('var quicksort = function () {');\n          expect(editor.buffer.getLineCount()).toBe(14);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts a newline above the current line and moves the cursor to the inserted line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewlineAbove()",
                "when the cursor is not on the first line"
            ],
            "updatePoint": {
                "line": 3085,
                "column": 94
            },
            "line": 3085,
            "code": "        it('inserts a newline above the current line and moves the cursor to the inserted line', () => {\n          editor.setCursorBufferPosition([3, 4]);\n          editor.insertNewlineAbove();\n          expect(editor.getCursorBufferPosition()).toEqual([3, 0]);\n          expect(editor.lineTextForBufferRow(3)).toBe('');\n          expect(editor.lineTextForBufferRow(4)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n          expect(editor.buffer.getLineCount()).toBe(14);\n          editor.undo();\n          expect(editor.getCursorBufferPosition()).toEqual([3, 4]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents the new line to the correct level when editor.autoIndent is true",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewlineAbove()",
                "when the cursor is not on the first line"
            ],
            "updatePoint": {
                "line": 3096,
                "column": 82
            },
            "line": 3096,
            "code": "      it('indents the new line to the correct level when editor.autoIndent is true', () => {\n        editor.update({\n          autoIndent: true\n        });\n        editor.setText('  var test');\n        editor.setCursorBufferPosition([0, 2]);\n        editor.insertNewlineAbove();\n        expect(editor.getCursorBufferPosition()).toEqual([0, 2]);\n        expect(editor.lineTextForBufferRow(0)).toBe('  ');\n        expect(editor.lineTextForBufferRow(1)).toBe('  var test');\n        editor.setText('\\n  var test');\n        editor.setCursorBufferPosition([1, 2]);\n        editor.insertNewlineAbove();\n        expect(editor.getCursorBufferPosition()).toEqual([1, 2]);\n        expect(editor.lineTextForBufferRow(0)).toBe('');\n        expect(editor.lineTextForBufferRow(1)).toBe('  ');\n        expect(editor.lineTextForBufferRow(2)).toBe('  var test');\n        editor.setText('function() {\\n}');\n        editor.setCursorBufferPosition([1, 1]);\n        editor.insertNewlineAbove();\n        expect(editor.getCursorBufferPosition()).toEqual([1, 2]);\n        expect(editor.lineTextForBufferRow(0)).toBe('function() {');\n        expect(editor.lineTextForBufferRow(1)).toBe('  ');\n        expect(editor.lineTextForBufferRow(2)).toBe('}');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the line down and keeps the indentation level the same when editor.autoIndent is true",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewLine()",
                "when a new line is appended before a closing tag (e.g. by pressing enter before a selection)"
            ],
            "updatePoint": {
                "line": 3124,
                "column": 103
            },
            "line": 3124,
            "code": "        it('moves the line down and keeps the indentation level the same when editor.autoIndent is true', () => {\n          editor.update({\n            autoIndent: true\n          });\n          editor.setCursorBufferPosition([9, 2]);\n          editor.insertNewline();\n          expect(editor.lineTextForBufferRow(10)).toBe('  };');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents the new line to the correct level when editor.autoIndent is true and using a curly-bracket language",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewLine()",
                "when a newline is appended with a trailing closing tag behind the cursor (e.g. by pressing enter in the middel of a line)"
            ],
            "updatePoint": {
                "line": 3134,
                "column": 119
            },
            "line": 3134,
            "code": "        it('indents the new line to the correct level when editor.autoIndent is true and using a curly-bracket language', () => {\n          editor.update({\n            autoIndent: true\n          });\n          atom.grammars.assignLanguageMode(editor, 'source.js');\n          editor.setText('var test = () => {\\n  return true;};');\n          editor.setCursorBufferPosition([1, 14]);\n          editor.insertNewline();\n          expect(editor.indentationForBufferRow(1)).toBe(1);\n          expect(editor.indentationForBufferRow(2)).toBe(0);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents the new line to the current level when editor.autoIndent is true and no increaseIndentPattern is specified",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewLine()",
                "when a newline is appended with a trailing closing tag behind the cursor (e.g. by pressing enter in the middel of a line)"
            ],
            "updatePoint": {
                "line": 3145,
                "column": 126
            },
            "line": 3145,
            "code": "        it('indents the new line to the current level when editor.autoIndent is true and no increaseIndentPattern is specified', () => {\n          atom.grammars.assignLanguageMode(editor, null);\n          editor.update({\n            autoIndent: true\n          });\n          editor.setText('  if true');\n          editor.setCursorBufferPosition([0, 8]);\n          editor.insertNewline();\n          expect(editor.getGrammar()).toBe(atom.grammars.nullGrammar);\n          expect(editor.indentationForBufferRow(0)).toBe(1);\n          expect(editor.indentationForBufferRow(1)).toBe(1);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents the new line to the correct level when editor.autoIndent is true and using an off-side rule language",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewLine()",
                "when a newline is appended with a trailing closing tag behind the cursor (e.g. by pressing enter in the middel of a line)"
            ],
            "updatePoint": {
                "line": 3157,
                "column": 120
            },
            "line": 3157,
            "code": "        it('indents the new line to the correct level when editor.autoIndent is true and using an off-side rule language', async () => {\n          await atom.packages.activatePackage('language-coffee-script');\n          editor.update({\n            autoIndent: true\n          });\n          atom.grammars.assignLanguageMode(editor, 'source.coffee');\n          editor.setText('if true\\n  return trueelse\\n  return false');\n          editor.setCursorBufferPosition([1, 13]);\n          editor.insertNewline();\n          expect(editor.indentationForBufferRow(1)).toBe(1);\n          expect(editor.indentationForBufferRow(2)).toBe(0);\n          expect(editor.indentationForBufferRow(3)).toBe(1);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents the new line to the correct level when editor.autoIndent is true",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".insertNewLine()",
                "when a newline is appended on a line that matches the decreaseNextIndentPattern"
            ],
            "updatePoint": {
                "line": 3172,
                "column": 84
            },
            "line": 3172,
            "code": "        it('indents the new line to the correct level when editor.autoIndent is true', async () => {\n          await atom.packages.activatePackage('language-go');\n          editor.update({\n            autoIndent: true\n          });\n          atom.grammars.assignLanguageMode(editor, 'source.go');\n          editor.setText('fmt.Printf(\"some%s\",\\n\t\"thing\")'); // eslint-disable-line no-tabs\n\n          editor.setCursorBufferPosition([1, 10]);\n          editor.insertNewline();\n          expect(editor.indentationForBufferRow(1)).toBe(1);\n          expect(editor.indentationForBufferRow(2)).toBe(0);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the character before the cursor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there is a single cursor",
                "when the cursor is on the middle of the line"
            ],
            "updatePoint": {
                "line": 3196,
                "column": 53
            },
            "line": 3196,
            "code": "          it('removes the character before the cursor', () => {\n            editor.setCursorScreenPosition({\n              row: 1,\n              column: 7\n            });\n            expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {');\n            editor.backspace();\n            const line = buffer.lineForRow(1);\n            expect(line).toBe('  var ort = function(items) {');\n            expect(editor.getCursorScreenPosition()).toEqual({\n              row: 1,\n              column: 6\n            });\n            expect(changeScreenRangeHandler).toHaveBeenCalled();\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "joins it with the line above",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there is a single cursor",
                "when the cursor is at the beginning of a line"
            ],
            "updatePoint": {
                "line": 3213,
                "column": 42
            },
            "line": 3213,
            "code": "          it('joins it with the line above', () => {\n            const originalLine0 = buffer.lineForRow(0);\n            expect(originalLine0).toBe('var quicksort = function () {');\n            expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {');\n            editor.setCursorScreenPosition({\n              row: 1,\n              column: 0\n            });\n            editor.backspace();\n            const line0 = buffer.lineForRow(0);\n            const line1 = buffer.lineForRow(1);\n            expect(line0).toBe('var quicksort = function () {  var sort = function(items) {');\n            expect(line1).toBe('    if (items.length <= 1) return items;');\n            expect(editor.getCursorScreenPosition()).toEqual([0, originalLine0.length]);\n            expect(changeScreenRangeHandler).toHaveBeenCalled();\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing, but doesn't raise an error",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there is a single cursor",
                "when the cursor is at the first column of the first line"
            ],
            "updatePoint": {
                "line": 3231,
                "column": 54
            },
            "line": 3231,
            "code": "          it(\"does nothing, but doesn't raise an error\", () => {\n            editor.setCursorScreenPosition({\n              row: 0,\n              column: 0\n            });\n            editor.backspace();\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the folded range",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there is a single cursor",
                "when the cursor is after a fold"
            ],
            "updatePoint": {
                "line": 3240,
                "column": 38
            },
            "line": 3240,
            "code": "          it('deletes the folded range', () => {\n            editor.foldBufferRange([[4, 7], [5, 8]]);\n            editor.setCursorBufferPosition([5, 8]);\n            editor.backspace();\n            expect(buffer.lineForRow(4)).toBe('    whirrent = items.shift();');\n            expect(editor.isFoldedAtBufferRow(4)).toBe(false);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "backspaces as normal",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there is a single cursor",
                "when the cursor is in the middle of a line below a fold"
            ],
            "updatePoint": {
                "line": 3249,
                "column": 34
            },
            "line": 3249,
            "code": "          it('backspaces as normal', () => {\n            editor.setCursorScreenPosition([4, 0]);\n            editor.foldCurrentRow();\n            editor.setCursorScreenPosition([5, 5]);\n            editor.backspace();\n            expect(buffer.lineForRow(7)).toBe('    }');\n            expect(buffer.lineForRow(8)).toBe('    eturn sort(left).concat(pivot).concat(sort(right));');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the contents of the fold before the cursor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there is a single cursor",
                "when the cursor is on a folded screen line"
            ],
            "updatePoint": {
                "line": 3259,
                "column": 64
            },
            "line": 3259,
            "code": "          it('deletes the contents of the fold before the cursor', () => {\n            editor.setCursorBufferPosition([3, 0]);\n            editor.foldCurrentRow();\n            editor.backspace();\n            expect(buffer.lineForRow(1)).toBe('  var sort = function(items)     var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.getCursorScreenPosition()).toEqual([1, 29]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the characters preceding each cursor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there are multiple cursors",
                "when cursors are on the same line"
            ],
            "updatePoint": {
                "line": 3270,
                "column": 58
            },
            "line": 3270,
            "code": "          it('removes the characters preceding each cursor', () => {\n            editor.setCursorScreenPosition([3, 13]);\n            editor.addCursorAtScreenPosition([3, 38]);\n            editor.backspace();\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivo = items.shift(), curren, left = [], right = [];');\n            const [cursor1, cursor2] = editor.getCursors();\n            expect(cursor1.getBufferPosition()).toEqual([3, 12]);\n            expect(cursor2.getBufferPosition()).toEqual([3, 36]);\n            const [selection1, selection2] = editor.getSelections();\n            expect(selection1.isEmpty()).toBeTruthy();\n            expect(selection2.isEmpty()).toBeTruthy();\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the characters preceding each cursor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there are multiple cursors",
                "when cursors are on different lines",
                "when the cursors are in the middle of their lines"
            ],
            "updatePoint": {
                "line": 3284,
                "column": 126
            },
            "line": 3284,
            "code": "          describe('when the cursors are in the middle of their lines', () => it('removes the characters preceding each cursor', () => {\n            editor.setCursorScreenPosition([3, 13]);\n            editor.addCursorAtScreenPosition([4, 10]);\n            editor.backspace();\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivo = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(4)).toBe('    whileitems.length > 0) {');\n            const [cursor1, cursor2] = editor.getCursors();\n            expect(cursor1.getBufferPosition()).toEqual([3, 12]);\n            expect(cursor2.getBufferPosition()).toEqual([4, 9]);\n            const [selection1, selection2] = editor.getSelections();\n            expect(selection1.isEmpty()).toBeTruthy();\n            expect(selection2.isEmpty()).toBeTruthy();\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the newlines preceding each cursor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there are multiple cursors",
                "when cursors are on different lines",
                "when the cursors are on the first column of their lines"
            ],
            "updatePoint": {
                "line": 3297,
                "column": 130
            },
            "line": 3297,
            "code": "          describe('when the cursors are on the first column of their lines', () => it('removes the newlines preceding each cursor', () => {\n            editor.setCursorScreenPosition([3, 0]);\n            editor.addCursorAtScreenPosition([6, 0]);\n            editor.backspace();\n            expect(editor.lineTextForBufferRow(2)).toBe('    if (items.length <= 1) return items;    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(3)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(4)).toBe('      current = items.shift();      current < pivot ? left.push(current) : right.push(current);');\n            expect(editor.lineTextForBufferRow(5)).toBe('    }');\n            const [cursor1, cursor2] = editor.getCursors();\n            expect(cursor1.getBufferPosition()).toEqual([2, 40]);\n            expect(cursor2.getBufferPosition()).toEqual([4, 30]);\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the selection, but not the character before it",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there is a single selection"
            ],
            "updatePoint": {
                "line": 3312,
                "column": 66
            },
            "line": 3312,
            "code": "        it('deletes the selection, but not the character before it', () => {\n          editor.setSelectedBufferRange([[0, 5], [0, 9]]);\n          editor.backspace();\n          expect(editor.buffer.lineForRow(0)).toBe('var qsort = function () {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "preserves the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there is a single selection",
                "when the selection ends on a folded line"
            ],
            "updatePoint": {
                "line": 3318,
                "column": 32
            },
            "line": 3318,
            "code": "          it('preserves the fold', () => {\n            editor.setSelectedBufferRange([[3, 0], [4, 0]]);\n            editor.foldBufferRow(4);\n            editor.backspace();\n            expect(buffer.lineForRow(3)).toBe('    while(items.length > 0) {');\n            expect(editor.isFoldedAtScreenRow(3)).toBe(true);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes all selected text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".backspace()",
                "when there are multiple selections"
            ],
            "updatePoint": {
                "line": 3328,
                "column": 37
            },
            "line": 3328,
            "code": "        it('removes all selected text', () => {\n          editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[0, 16], [0, 24]]]);\n          editor.backspace();\n          expect(editor.lineTextForBufferRow(0)).toBe('var  =  () {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes to the previous word boundary",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToPreviousWordBoundary()",
                "when no text is selected"
            ],
            "updatePoint": {
                "line": 3337,
                "column": 49
            },
            "line": 3337,
            "code": "        it('deletes to the previous word boundary', () => {\n          editor.setCursorBufferPosition([0, 16]);\n          editor.addCursorAtBufferPosition([1, 21]);\n          const [cursor1, cursor2] = editor.getCursors();\n          editor.deleteToPreviousWordBoundary();\n          expect(buffer.lineForRow(0)).toBe('var quicksort =function () {');\n          expect(buffer.lineForRow(1)).toBe('  var sort = (items) {');\n          expect(cursor1.getBufferPosition()).toEqual([0, 15]);\n          expect(cursor2.getBufferPosition()).toEqual([1, 13]);\n          editor.deleteToPreviousWordBoundary();\n          expect(buffer.lineForRow(0)).toBe('var quicksort function () {');\n          expect(buffer.lineForRow(1)).toBe('  var sort =(items) {');\n          expect(cursor1.getBufferPosition()).toEqual([0, 14]);\n          expect(cursor2.getBufferPosition()).toEqual([1, 12]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes only selected text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToPreviousWordBoundary()",
                "when text is selected"
            ],
            "updatePoint": {
                "line": 3354,
                "column": 38
            },
            "line": 3354,
            "code": "        it('deletes only selected text', () => {\n          editor.setSelectedBufferRange([[1, 24], [1, 27]]);\n          editor.deleteToPreviousWordBoundary();\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes to the next word boundary",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToNextWordBoundary()",
                "when no text is selected"
            ],
            "updatePoint": {
                "line": 3363,
                "column": 45
            },
            "line": 3363,
            "code": "        it('deletes to the next word boundary', () => {\n          editor.setCursorBufferPosition([0, 15]);\n          editor.addCursorAtBufferPosition([1, 24]);\n          const [cursor1, cursor2] = editor.getCursors();\n          editor.deleteToNextWordBoundary();\n          expect(buffer.lineForRow(0)).toBe('var quicksort =function () {');\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');\n          expect(cursor1.getBufferPosition()).toEqual([0, 15]);\n          expect(cursor2.getBufferPosition()).toEqual([1, 24]);\n          editor.deleteToNextWordBoundary();\n          expect(buffer.lineForRow(0)).toBe('var quicksort = () {');\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it {');\n          expect(cursor1.getBufferPosition()).toEqual([0, 15]);\n          expect(cursor2.getBufferPosition()).toEqual([1, 24]);\n          editor.deleteToNextWordBoundary();\n          expect(buffer.lineForRow(0)).toBe('var quicksort =() {');\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it{');\n          expect(cursor1.getBufferPosition()).toEqual([0, 15]);\n          expect(cursor2.getBufferPosition()).toEqual([1, 24]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes only selected text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToNextWordBoundary()",
                "when text is selected"
            ],
            "updatePoint": {
                "line": 3385,
                "column": 38
            },
            "line": 3385,
            "code": "        it('deletes only selected text', () => {\n          editor.setSelectedBufferRange([[1, 24], [1, 27]]);\n          editor.deleteToNextWordBoundary();\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes all text between the cursor and the beginning of the word",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToBeginningOfWord()",
                "when no text is selected"
            ],
            "updatePoint": {
                "line": 3394,
                "column": 77
            },
            "line": 3394,
            "code": "        it('deletes all text between the cursor and the beginning of the word', () => {\n          editor.setCursorBufferPosition([1, 24]);\n          editor.addCursorAtBufferPosition([3, 5]);\n          const [cursor1, cursor2] = editor.getCursors();\n          editor.deleteToBeginningOfWord();\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(ems) {');\n          expect(buffer.lineForRow(3)).toBe('    ar pivot = items.shift(), current, left = [], right = [];');\n          expect(cursor1.getBufferPosition()).toEqual([1, 22]);\n          expect(cursor2.getBufferPosition()).toEqual([3, 4]);\n          editor.deleteToBeginningOfWord();\n          expect(buffer.lineForRow(1)).toBe('  var sort = functionems) {');\n          expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return itemsar pivot = items.shift(), current, left = [], right = [];');\n          expect(cursor1.getBufferPosition()).toEqual([1, 21]);\n          expect(cursor2.getBufferPosition()).toEqual([2, 39]);\n          editor.deleteToBeginningOfWord();\n          expect(buffer.lineForRow(1)).toBe('  var sort = ems) {');\n          expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return ar pivot = items.shift(), current, left = [], right = [];');\n          expect(cursor1.getBufferPosition()).toEqual([1, 13]);\n          expect(cursor2.getBufferPosition()).toEqual([2, 34]);\n          editor.setText('  var sort');\n          editor.setCursorBufferPosition([0, 2]);\n          editor.deleteToBeginningOfWord();\n          expect(buffer.lineForRow(0)).toBe('var sort');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes only selected text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToBeginningOfWord()",
                "when text is selected"
            ],
            "updatePoint": {
                "line": 3420,
                "column": 38
            },
            "line": 3420,
            "code": "        it('deletes only selected text', () => {\n          editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);\n          editor.deleteToBeginningOfWord();\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');\n          expect(buffer.lineForRow(2)).toBe('if (items.length <= 1) return items;');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes all text between the cursor and the end of the line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToEndOfLine()",
                "when no text is selected"
            ],
            "updatePoint": {
                "line": 3430,
                "column": 71
            },
            "line": 3430,
            "code": "        it('deletes all text between the cursor and the end of the line', () => {\n          editor.setCursorBufferPosition([1, 24]);\n          editor.addCursorAtBufferPosition([2, 5]);\n          const [cursor1, cursor2] = editor.getCursors();\n          editor.deleteToEndOfLine();\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it');\n          expect(buffer.lineForRow(2)).toBe('    i');\n          expect(cursor1.getBufferPosition()).toEqual([1, 24]);\n          expect(cursor2.getBufferPosition()).toEqual([2, 5]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the next newline",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToEndOfLine()",
                "when no text is selected",
                "when at the end of the line"
            ],
            "updatePoint": {
                "line": 3441,
                "column": 38
            },
            "line": 3441,
            "code": "          it('deletes the next newline', () => {\n            editor.setCursorBufferPosition([1, 30]);\n            editor.deleteToEndOfLine();\n            expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {    if (items.length <= 1) return items;');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes only the text in the selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToEndOfLine()",
                "when text is selected"
            ],
            "updatePoint": {
                "line": 3449,
                "column": 50
            },
            "line": 3449,
            "code": "        it('deletes only the text in the selection', () => {\n          editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);\n          editor.deleteToEndOfLine();\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');\n          expect(buffer.lineForRow(2)).toBe('if (items.length <= 1) return items;');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes all text between the cursor and the beginning of the line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToBeginningOfLine()",
                "when no text is selected"
            ],
            "updatePoint": {
                "line": 3459,
                "column": 77
            },
            "line": 3459,
            "code": "        it('deletes all text between the cursor and the beginning of the line', () => {\n          editor.setCursorBufferPosition([1, 24]);\n          editor.addCursorAtBufferPosition([2, 5]);\n          const [cursor1, cursor2] = editor.getCursors();\n          editor.deleteToBeginningOfLine();\n          expect(buffer.lineForRow(1)).toBe('ems) {');\n          expect(buffer.lineForRow(2)).toBe('f (items.length <= 1) return items;');\n          expect(cursor1.getBufferPosition()).toEqual([1, 0]);\n          expect(cursor2.getBufferPosition()).toEqual([2, 0]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the newline",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToBeginningOfLine()",
                "when no text is selected",
                "when at the beginning of the line"
            ],
            "updatePoint": {
                "line": 3470,
                "column": 33
            },
            "line": 3470,
            "code": "          it('deletes the newline', () => {\n            editor.setCursorBufferPosition([2]);\n            editor.deleteToBeginningOfLine();\n            expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {    if (items.length <= 1) return items;');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "still deletes all text to beginning of the line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToBeginningOfLine()",
                "when text is selected"
            ],
            "updatePoint": {
                "line": 3478,
                "column": 59
            },
            "line": 3478,
            "code": "        it('still deletes all text to beginning of the line', () => {\n          editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);\n          editor.deleteToBeginningOfLine();\n          expect(buffer.lineForRow(1)).toBe('ems) {');\n          expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return items;');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the character following the cursor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".delete()",
                "when there is a single cursor",
                "when the cursor is on the middle of a line"
            ],
            "updatePoint": {
                "line": 3489,
                "column": 56
            },
            "line": 3489,
            "code": "          it('deletes the character following the cursor', () => {\n            editor.setCursorScreenPosition([1, 6]);\n            editor.delete();\n            expect(buffer.lineForRow(1)).toBe('  var ort = function(items) {');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "joins the line with the following line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".delete()",
                "when there is a single cursor",
                "when the cursor is on the end of a line"
            ],
            "updatePoint": {
                "line": 3496,
                "column": 52
            },
            "line": 3496,
            "code": "          it('joins the line with the following line', () => {\n            editor.setCursorScreenPosition([1, buffer.lineForRow(1).length]);\n            editor.delete();\n            expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {    if (items.length <= 1) return items;');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing, but doesn't raise an error",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".delete()",
                "when there is a single cursor",
                "when the cursor is on the last column of the last line"
            ],
            "updatePoint": {
                "line": 3503,
                "column": 54
            },
            "line": 3503,
            "code": "          it(\"does nothing, but doesn't raise an error\", () => {\n            editor.setCursorScreenPosition([12, buffer.lineForRow(12).length]);\n            editor.delete();\n            expect(buffer.lineForRow(12)).toBe('};');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only deletes the lines inside the fold",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".delete()",
                "when there is a single cursor",
                "when the cursor is before a fold"
            ],
            "updatePoint": {
                "line": 3510,
                "column": 52
            },
            "line": 3510,
            "code": "          it('only deletes the lines inside the fold', () => {\n            editor.foldBufferRange([[3, 6], [4, 8]]);\n            editor.setCursorScreenPosition([3, 6]);\n            const cursorPositionBefore = editor.getCursorScreenPosition();\n            editor.delete();\n            expect(buffer.lineForRow(3)).toBe('    vae(items.length > 0) {');\n            expect(buffer.lineForRow(4)).toBe('      current = items.shift();');\n            expect(editor.getCursorScreenPosition()).toEqual(cursorPositionBefore);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes as normal",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".delete()",
                "when there is a single cursor",
                "when the cursor is in the middle a line above a fold"
            ],
            "updatePoint": {
                "line": 3521,
                "column": 31
            },
            "line": 3521,
            "code": "          it('deletes as normal', () => {\n            editor.foldBufferRow(4);\n            editor.setCursorScreenPosition([3, 4]);\n            editor.delete();\n            expect(buffer.lineForRow(3)).toBe('    ar pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.isFoldedAtScreenRow(4)).toBe(true);\n            expect(editor.getCursorScreenPosition()).toEqual([3, 4]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the folded content after the cursor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".delete()",
                "when there is a single cursor",
                "when the cursor is inside a fold"
            ],
            "updatePoint": {
                "line": 3531,
                "column": 57
            },
            "line": 3531,
            "code": "          it('removes the folded content after the cursor', () => {\n            editor.foldBufferRange([[2, 6], [6, 21]]);\n            editor.setCursorBufferPosition([4, 9]);\n            editor.delete();\n            expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return items;');\n            expect(buffer.lineForRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(buffer.lineForRow(4)).toBe('    while ? left.push(current) : right.push(current);');\n            expect(buffer.lineForRow(5)).toBe('    }');\n            expect(editor.getCursorBufferPosition()).toEqual([4, 9]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the characters following each cursor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".delete()",
                "when there are multiple cursors",
                "when cursors are on the same line"
            ],
            "updatePoint": {
                "line": 3545,
                "column": 58
            },
            "line": 3545,
            "code": "          it('removes the characters following each cursor', () => {\n            editor.setCursorScreenPosition([3, 13]);\n            editor.addCursorAtScreenPosition([3, 38]);\n            editor.delete();\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot= items.shift(), current left = [], right = [];');\n            const [cursor1, cursor2] = editor.getCursors();\n            expect(cursor1.getBufferPosition()).toEqual([3, 13]);\n            expect(cursor2.getBufferPosition()).toEqual([3, 37]);\n            const [selection1, selection2] = editor.getSelections();\n            expect(selection1.isEmpty()).toBeTruthy();\n            expect(selection2.isEmpty()).toBeTruthy();\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the characters following each cursor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".delete()",
                "when there are multiple cursors",
                "when cursors are on different lines",
                "when the cursors are in the middle of the lines"
            ],
            "updatePoint": {
                "line": 3559,
                "column": 124
            },
            "line": 3559,
            "code": "          describe('when the cursors are in the middle of the lines', () => it('removes the characters following each cursor', () => {\n            editor.setCursorScreenPosition([3, 13]);\n            editor.addCursorAtScreenPosition([4, 10]);\n            editor.delete();\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot= items.shift(), current, left = [], right = [];');\n            expect(editor.lineTextForBufferRow(4)).toBe('    while(tems.length > 0) {');\n            const [cursor1, cursor2] = editor.getCursors();\n            expect(cursor1.getBufferPosition()).toEqual([3, 13]);\n            expect(cursor2.getBufferPosition()).toEqual([4, 10]);\n            const [selection1, selection2] = editor.getSelections();\n            expect(selection1.isEmpty()).toBeTruthy();\n            expect(selection2.isEmpty()).toBeTruthy();\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the newlines following each cursor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".delete()",
                "when there are multiple cursors",
                "when cursors are on different lines",
                "when the cursors are at the end of their lines"
            ],
            "updatePoint": {
                "line": 3572,
                "column": 121
            },
            "line": 3572,
            "code": "          describe('when the cursors are at the end of their lines', () => it('removes the newlines following each cursor', () => {\n            editor.setCursorScreenPosition([0, 29]);\n            editor.addCursorAtScreenPosition([1, 30]);\n            editor.delete();\n            expect(editor.lineTextForBufferRow(0)).toBe('var quicksort = function () {  var sort = function(items) {    if (items.length <= 1) return items;');\n            const [cursor1, cursor2] = editor.getCursors();\n            expect(cursor1.getBufferPosition()).toEqual([0, 29]);\n            expect(cursor2.getBufferPosition()).toEqual([0, 59]);\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the selection, but not the character following it",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".delete()",
                "when there is a single selection"
            ],
            "updatePoint": {
                "line": 3584,
                "column": 69
            },
            "line": 3584,
            "code": "        it('deletes the selection, but not the character following it', () => {\n          editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);\n          editor.delete();\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');\n          expect(buffer.lineForRow(2)).toBe('if (items.length <= 1) return items;');\n          expect(editor.getLastSelection().isEmpty()).toBeTruthy();\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes all selected text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".delete()",
                "when there are multiple selections",
                "when selections are on the same line"
            ],
            "updatePoint": {
                "line": 3593,
                "column": 37
            },
            "line": 3593,
            "code": "        it('removes all selected text', () => {\n          editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[0, 16], [0, 24]]]);\n          editor.delete();\n          expect(editor.lineTextForBufferRow(0)).toBe('var  =  () {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes to the end of the word",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToEndOfWord()",
                "when no text is selected"
            ],
            "updatePoint": {
                "line": 3602,
                "column": 42
            },
            "line": 3602,
            "code": "        it('deletes to the end of the word', () => {\n          editor.setCursorBufferPosition([1, 24]);\n          editor.addCursorAtBufferPosition([2, 5]);\n          const [cursor1, cursor2] = editor.getCursors();\n          editor.deleteToEndOfWord();\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');\n          expect(buffer.lineForRow(2)).toBe('    i (items.length <= 1) return items;');\n          expect(cursor1.getBufferPosition()).toEqual([1, 24]);\n          expect(cursor2.getBufferPosition()).toEqual([2, 5]);\n          editor.deleteToEndOfWord();\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it {');\n          expect(buffer.lineForRow(2)).toBe('    iitems.length <= 1) return items;');\n          expect(cursor1.getBufferPosition()).toEqual([1, 24]);\n          expect(cursor2.getBufferPosition()).toEqual([2, 5]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes only selected text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".deleteToEndOfWord()",
                "when text is selected"
            ],
            "updatePoint": {
                "line": 3619,
                "column": 38
            },
            "line": 3619,
            "code": "        it('deletes only selected text', () => {\n          editor.setSelectedBufferRange([[1, 24], [1, 27]]);\n          editor.deleteToEndOfWord();\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts 'tabLength' spaces into the buffer",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indent()",
                "when the selection is empty",
                "when autoIndent is disabled",
                "if 'softTabs' is true (the default)"
            ],
            "updatePoint": {
                "line": 3630,
                "column": 58
            },
            "line": 3630,
            "code": "            it(\"inserts 'tabLength' spaces into the buffer\", () => {\n              const tabRegex = new RegExp(`^[ ]{${editor.getTabLength()}}`);\n              expect(buffer.lineForRow(0)).not.toMatch(tabRegex);\n              editor.indent();\n              expect(buffer.lineForRow(0)).toMatch(tabRegex);\n            });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "respects the tab stops when cursor is in the middle of a tab",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indent()",
                "when the selection is empty",
                "when autoIndent is disabled",
                "if 'softTabs' is true (the default)"
            ],
            "updatePoint": {
                "line": 3636,
                "column": 76
            },
            "line": 3636,
            "code": "            it('respects the tab stops when cursor is in the middle of a tab', () => {\n              editor.setTabLength(4);\n              buffer.insert([12, 2], '\\n ');\n              editor.setCursorBufferPosition([13, 1]);\n              editor.indent();\n              expect(buffer.lineForRow(13)).toMatch(/^\\s+$/);\n              expect(buffer.lineForRow(13).length).toBe(4);\n              expect(editor.getCursorBufferPosition()).toEqual([13, 4]);\n              buffer.insert([13, 0], '  ');\n              editor.setCursorBufferPosition([13, 6]);\n              editor.indent();\n              expect(buffer.lineForRow(13).length).toBe(8);\n            });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "insert a \t into the buffer",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indent()",
                "when the selection is empty",
                "when autoIndent is disabled",
                "if 'softTabs' is false"
            ],
            "updatePoint": {
                "line": 3650,
                "column": 82
            },
            "line": 3650,
            "code": "          describe(\"if 'softTabs' is false\", () => it('insert a \\t into the buffer', () => {\n            editor.setSoftTabs(false);\n            expect(buffer.lineForRow(0)).not.toMatch(/^\\t/);\n            editor.indent();\n            expect(buffer.lineForRow(0)).toMatch(/^\\t/);\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the end of the leading whitespace and inserts enough whitespace to bring the line to the suggested level of indentation",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indent()",
                "when the selection is empty",
                "when autoIndent is enabled",
                "when the cursor's column is less than the suggested level of indentation",
                "when 'softTabs' is true (the default)"
            ],
            "updatePoint": {
                "line": 3660,
                "column": 157
            },
            "line": 3660,
            "code": "              it('moves the cursor to the end of the leading whitespace and inserts enough whitespace to bring the line to the suggested level of indentation', () => {\n                buffer.insert([5, 0], '  \\n');\n                editor.setCursorBufferPosition([5, 0]);\n                editor.indent({\n                  autoIndent: true\n                });\n                expect(buffer.lineForRow(5)).toMatch(/^\\s+$/);\n                expect(buffer.lineForRow(5).length).toBe(6);\n                expect(editor.getCursorBufferPosition()).toEqual([5, 6]);\n              });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "respects the tab stops when cursor is in the middle of a tab",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indent()",
                "when the selection is empty",
                "when autoIndent is enabled",
                "when the cursor's column is less than the suggested level of indentation",
                "when 'softTabs' is true (the default)"
            ],
            "updatePoint": {
                "line": 3670,
                "column": 78
            },
            "line": 3670,
            "code": "              it('respects the tab stops when cursor is in the middle of a tab', () => {\n                editor.setTabLength(4);\n                buffer.insert([12, 2], '\\n ');\n                editor.setCursorBufferPosition([13, 1]);\n                editor.indent({\n                  autoIndent: true\n                });\n                expect(buffer.lineForRow(13)).toMatch(/^\\s+$/);\n                expect(buffer.lineForRow(13).length).toBe(4);\n                expect(editor.getCursorBufferPosition()).toEqual([13, 4]);\n                buffer.insert([13, 0], '  ');\n                editor.setCursorBufferPosition([13, 6]);\n                editor.indent({\n                  autoIndent: true\n                });\n                expect(buffer.lineForRow(13).length).toBe(8);\n              });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the end of the leading whitespace and inserts enough tabs to bring the line to the suggested level of indentation",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indent()",
                "when the selection is empty",
                "when autoIndent is enabled",
                "when the cursor's column is less than the suggested level of indentation",
                "when 'softTabs' is false"
            ],
            "updatePoint": {
                "line": 3689,
                "column": 151
            },
            "line": 3689,
            "code": "              it('moves the cursor to the end of the leading whitespace and inserts enough tabs to bring the line to the suggested level of indentation', () => {\n                convertToHardTabs(buffer);\n                editor.setSoftTabs(false);\n                buffer.insert([5, 0], '\\t\\n');\n                editor.setCursorBufferPosition([5, 0]);\n                editor.indent({\n                  autoIndent: true\n                });\n                expect(buffer.lineForRow(5)).toMatch(/^\\t\\t\\t$/);\n                expect(editor.getCursorBufferPosition()).toEqual([5, 3]);\n              });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts one tab",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indent()",
                "when the selection is empty",
                "when autoIndent is enabled",
                "when the cursor's column is less than the suggested level of indentation",
                "when 'softTabs' is false",
                "when the difference between the suggested level of indentation and the current level of indentation is greater than 0 but less than 1"
            ],
            "updatePoint": {
                "line": 3700,
                "column": 185
            },
            "line": 3700,
            "code": "              describe('when the difference between the suggested level of indentation and the current level of indentation is greater than 0 but less than 1', () => it('inserts one tab', () => {\n                editor.setSoftTabs(false);\n                buffer.setText(' \\ntest');\n                editor.setCursorBufferPosition([1, 0]);\n                editor.indent({\n                  autoIndent: true\n                });\n                expect(buffer.lineForRow(1)).toBe('\\ttest');\n                expect(editor.getCursorBufferPosition()).toEqual([1, 1]);\n              }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the end of the leading whitespace and inserts 'tabLength' spaces into the buffer",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indent()",
                "when the selection is empty",
                "when autoIndent is enabled",
                "when the line's indent level is greater than the suggested level of indentation",
                "when 'softTabs' is true (the default)"
            ],
            "updatePoint": {
                "line": 3713,
                "column": 172
            },
            "line": 3713,
            "code": "            describe(\"when 'softTabs' is true (the default)\", () => it(\"moves the cursor to the end of the leading whitespace and inserts 'tabLength' spaces into the buffer\", () => {\n              buffer.insert([7, 0], '      \\n');\n              editor.setCursorBufferPosition([7, 2]);\n              editor.indent({\n                autoIndent: true\n              });\n              expect(buffer.lineForRow(7)).toMatch(/^\\s+$/);\n              expect(buffer.lineForRow(7).length).toBe(8);\n              expect(editor.getCursorBufferPosition()).toEqual([7, 8]);\n            }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the end of the leading whitespace and inserts \t into the buffer",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indent()",
                "when the selection is empty",
                "when autoIndent is enabled",
                "when the line's indent level is greater than the suggested level of indentation",
                "when 'softTabs' is false"
            ],
            "updatePoint": {
                "line": 3723,
                "column": 143
            },
            "line": 3723,
            "code": "            describe(\"when 'softTabs' is false\", () => it('moves the cursor to the end of the leading whitespace and inserts \\t into the buffer', () => {\n              convertToHardTabs(buffer);\n              editor.setSoftTabs(false);\n              buffer.insert([7, 0], '\\t\\t\\t\\n');\n              editor.setCursorBufferPosition([7, 1]);\n              editor.indent({\n                autoIndent: true\n              });\n              expect(buffer.lineForRow(7)).toMatch(/^\\t\\t\\t\\t$/);\n              expect(editor.getCursorBufferPosition()).toEqual([7, 4]);\n            }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents the selected lines",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indent()",
                "when the selection is not empty"
            ],
            "updatePoint": {
                "line": 3738,
                "column": 38
            },
            "line": 3738,
            "code": "        it('indents the selected lines', () => {\n          editor.setSelectedBufferRange([[0, 0], [10, 0]]);\n          const selection = editor.getLastSelection();\n          spyOn(selection, 'indentSelectedRows');\n          editor.indent();\n          expect(selection.indentSelectedRows).toHaveBeenCalled();\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts a tab character into the buffer",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indent()",
                "if editor.softTabs is false"
            ],
            "updatePoint": {
                "line": 3747,
                "column": 51
            },
            "line": 3747,
            "code": "        it('inserts a tab character into the buffer', () => {\n          editor.setSoftTabs(false);\n          expect(buffer.lineForRow(0)).not.toMatch(/^\\t/);\n          editor.indent();\n          expect(buffer.lineForRow(0)).toMatch(/^\\t/);\n          expect(editor.getCursorBufferPosition()).toEqual([0, 1]);\n          expect(editor.getCursorScreenPosition()).toEqual([0, editor.getTabLength()]);\n          editor.indent();\n          expect(buffer.lineForRow(0)).toMatch(/^\\t\\t/);\n          expect(editor.getCursorBufferPosition()).toEqual([0, 2]);\n          expect(editor.getCursorScreenPosition()).toEqual([0, editor.getTabLength() * 2]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the selected text from the buffer and places it on the clipboard",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".cutSelectedText()"
            ],
            "updatePoint": {
                "line": 3763,
                "column": 84
            },
            "line": 3763,
            "code": "        it('removes the selected text from the buffer and places it on the clipboard', () => {\n          editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]]]);\n          editor.cutSelectedText();\n          expect(buffer.lineForRow(0)).toBe('var  = function () {');\n          expect(buffer.lineForRow(1)).toBe('  var  = function(items) {');\n          expect(clipboard.readText()).toBe(['quicksort', 'sort'].join(os.EOL));\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "cuts the lines on which there are cursors",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".cutSelectedText()",
                "when no text is selected"
            ],
            "updatePoint": {
                "line": 3772,
                "column": 55
            },
            "line": 3772,
            "code": "          it('cuts the lines on which there are cursors', () => {\n            editor.cutSelectedText();\n            expect(buffer.getLineCount()).toBe(11);\n            expect(buffer.lineForRow(1)).toBe('    if (items.length <= 1) return items;');\n            expect(buffer.lineForRow(4)).toBe('      current < pivot ? left.push(current) : right.push(current);');\n            expect(atom.clipboard.read()).toEqual(['var quicksort = function () {', '', '      current = items.shift();', ''].join(os.EOL));\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "cuts them in order",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".cutSelectedText()",
                "when many selections get added in shuffle order"
            ],
            "updatePoint": {
                "line": 3781,
                "column": 32
            },
            "line": 3781,
            "code": "          it('cuts them in order', () => {\n            editor.setSelectedBufferRanges([[[2, 8], [2, 13]], [[0, 4], [0, 13]], [[1, 6], [1, 10]]]);\n            editor.cutSelectedText();\n            expect(atom.clipboard.read()).toEqual(['quicksort', 'sort', 'items'].join(os.EOL));\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "cuts up to the end of the line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".cutToEndOfLine()",
                "when soft wrap is on"
            ],
            "updatePoint": {
                "line": 3790,
                "column": 44
            },
            "line": 3790,
            "code": "          it('cuts up to the end of the line', () => {\n            editor.setSoftWrapped(true);\n            editor.setDefaultCharWidth(1);\n            editor.setEditorWidthInChars(25);\n            editor.setCursorScreenPosition([2, 6]);\n            editor.cutToEndOfLine();\n            expect(editor.lineTextForScreenRow(2)).toBe('  var  function(items) {');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "cuts up to the end of the line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".cutToEndOfLine()",
                "when soft wrap is off",
                "when nothing is selected"
            ],
            "updatePoint": {
                "line": 3800,
                "column": 87
            },
            "line": 3800,
            "code": "          describe('when nothing is selected', () => it('cuts up to the end of the line', () => {\n            editor.setCursorBufferPosition([2, 20]);\n            editor.addCursorAtBufferPosition([3, 20]);\n            editor.cutToEndOfLine();\n            expect(buffer.lineForRow(2)).toBe('    if (items.length');\n            expect(buffer.lineForRow(3)).toBe('    var pivot = item');\n            expect(atom.clipboard.read()).toBe(` <= 1) return items;${os.EOL}s.shift(), current, left = [], right = [];`);\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only cuts the selected text, not to the end of the line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".cutToEndOfLine()",
                "when soft wrap is off",
                "when text is selected"
            ],
            "updatePoint": {
                "line": 3808,
                "column": 109
            },
            "line": 3808,
            "code": "          describe('when text is selected', () => it('only cuts the selected text, not to the end of the line', () => {\n            editor.setSelectedBufferRanges([[[2, 20], [2, 30]], [[3, 20], [3, 20]]]);\n            editor.cutToEndOfLine();\n            expect(buffer.lineForRow(2)).toBe('    if (items.lengthurn items;');\n            expect(buffer.lineForRow(3)).toBe('    var pivot = item');\n            expect(atom.clipboard.read()).toBe(` <= 1) ret${os.EOL}s.shift(), current, left = [], right = [];`);\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "cuts up to the end of the buffer line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".cutToEndOfBufferLine()",
                "when nothing is selected"
            ],
            "updatePoint": {
                "line": 3823,
                "column": 51
            },
            "line": 3823,
            "code": "          it('cuts up to the end of the buffer line', () => {\n            editor.setCursorBufferPosition([2, 20]);\n            editor.addCursorAtBufferPosition([3, 20]);\n            editor.cutToEndOfBufferLine();\n            expect(buffer.lineForRow(2)).toBe('    if (items.length');\n            expect(buffer.lineForRow(3)).toBe('    var pivot = item');\n            expect(atom.clipboard.read()).toBe(` <= 1) return items;${os.EOL}s.shift(), current, left = [], right = [];`);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only cuts the selected text, not to the end of the buffer line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".cutToEndOfBufferLine()",
                "when text is selected"
            ],
            "updatePoint": {
                "line": 3833,
                "column": 76
            },
            "line": 3833,
            "code": "          it('only cuts the selected text, not to the end of the buffer line', () => {\n            editor.setSelectedBufferRanges([[[2, 20], [2, 30]], [[3, 20], [3, 20]]]);\n            editor.cutToEndOfBufferLine();\n            expect(buffer.lineForRow(2)).toBe('    if (items.lengthurn items;');\n            expect(buffer.lineForRow(3)).toBe('    var pivot = item');\n            expect(atom.clipboard.read()).toBe(` <= 1) ret${os.EOL}s.shift(), current, left = [], right = [];`);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "copies selected text onto the clipboard",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".copySelectedText()"
            ],
            "updatePoint": {
                "line": 3843,
                "column": 51
            },
            "line": 3843,
            "code": "        it('copies selected text onto the clipboard', () => {\n          editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]], [[2, 8], [2, 13]]]);\n          editor.copySelectedText();\n          expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');\n          expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {');\n          expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return items;');\n          expect(clipboard.readText()).toBe(['quicksort', 'sort', 'items'].join(os.EOL));\n          expect(atom.clipboard.read()).toEqual(['quicksort', 'sort', 'items'].join(os.EOL));\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "copies the lines on which there are cursors",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".copySelectedText()",
                "when no text is selected"
            ],
            "updatePoint": {
                "line": 3856,
                "column": 57
            },
            "line": 3856,
            "code": "          it('copies the lines on which there are cursors', () => {\n            editor.copySelectedText();\n            expect(atom.clipboard.read()).toEqual([`  var sort = function(items) {${os.EOL}`, `      current = items.shift();${os.EOL}`].join(os.EOL));\n            expect(editor.getSelectedBufferRanges()).toEqual([[[1, 5], [1, 5]], [[5, 8], [5, 8]]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "copies them in order",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".copySelectedText()",
                "when many selections get added in shuffle order"
            ],
            "updatePoint": {
                "line": 3863,
                "column": 34
            },
            "line": 3863,
            "code": "          it('copies them in order', () => {\n            editor.setSelectedBufferRanges([[[2, 8], [2, 13]], [[0, 4], [0, 13]], [[1, 6], [1, 10]]]);\n            editor.copySelectedText();\n            expect(atom.clipboard.read()).toEqual(['quicksort', 'sort', 'items'].join(os.EOL));\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "copies selected text onto the clipboard",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".copyOnlySelectedText()",
                "when thee are multiple selections"
            ],
            "updatePoint": {
                "line": 3872,
                "column": 53
            },
            "line": 3872,
            "code": "          it('copies selected text onto the clipboard', () => {\n            editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]], [[2, 8], [2, 13]]]);\n            editor.copyOnlySelectedText();\n            expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');\n            expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {');\n            expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return items;');\n            expect(clipboard.readText()).toBe(['quicksort', 'sort', 'items'].join(os.EOL));\n            expect(atom.clipboard.read()).toEqual(['quicksort', 'sort', 'items'].join(os.EOL));\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not copy anything",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".copyOnlySelectedText()",
                "when no text is selected"
            ],
            "updatePoint": {
                "line": 3883,
                "column": 36
            },
            "line": 3883,
            "code": "          it('does not copy anything', () => {\n            editor.setCursorBufferPosition([1, 5]);\n            editor.copyOnlySelectedText();\n            expect(atom.clipboard.read()).toEqual('initial clipboard content');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "pastes text into the buffer",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()"
            ],
            "updatePoint": {
                "line": 3891,
                "column": 39
            },
            "line": 3891,
            "code": "        it('pastes text into the buffer', () => {\n          editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]]]);\n          atom.clipboard.write('first');\n          editor.pasteText();\n          expect(editor.lineTextForBufferRow(0)).toBe('var first = function () {');\n          expect(editor.lineTextForBufferRow(1)).toBe('  var first = function(items) {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies ::onWillInsertText observers",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()"
            ],
            "updatePoint": {
                "line": 3898,
                "column": 49
            },
            "line": 3898,
            "code": "        it('notifies ::onWillInsertText observers', () => {\n          const insertedStrings = [];\n          editor.onWillInsertText(function ({\n            text,\n            cancel\n          }) {\n            insertedStrings.push(text);\n            cancel();\n          });\n          atom.clipboard.write('hello');\n          editor.pasteText();\n          expect(insertedStrings).toEqual(['hello']);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies ::onDidInsertText observers",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()"
            ],
            "updatePoint": {
                "line": 3911,
                "column": 48
            },
            "line": 3911,
            "code": "        it('notifies ::onDidInsertText observers', () => {\n          const insertedStrings = [];\n          editor.onDidInsertText(({\n            text,\n            range\n          }) => insertedStrings.push(text));\n          atom.clipboard.write('hello');\n          editor.pasteText();\n          expect(insertedStrings).toEqual(['hello']);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "auto-indents the lines spanned by the pasted text, based on the first pasted line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when `autoIndentOnPaste` is true",
                "when pasting multiple lines before any non-whitespace characters"
            ],
            "updatePoint": {
                "line": 3926,
                "column": 97
            },
            "line": 3926,
            "code": "            it('auto-indents the lines spanned by the pasted text, based on the first pasted line', () => {\n              atom.clipboard.write('a(x);\\n  b(x);\\n    c(x);\\n', {\n                indentBasis: 0\n              });\n              editor.setCursorBufferPosition([5, 0]);\n              editor.pasteText(); // Adjust the indentation of the pasted lines while preserving\n              // their indentation relative to each other. Also preserve the\n              // indentation of the following line.\n\n              expect(editor.lineTextForBufferRow(5)).toBe('      a(x);');\n              expect(editor.lineTextForBufferRow(6)).toBe('        b(x);');\n              expect(editor.lineTextForBufferRow(7)).toBe('          c(x);');\n              expect(editor.lineTextForBufferRow(8)).toBe('      current = items.shift();');\n            });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "auto-indents lines with a mix of hard tabs and spaces without removing spaces",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when `autoIndentOnPaste` is true",
                "when pasting multiple lines before any non-whitespace characters"
            ],
            "updatePoint": {
                "line": 3940,
                "column": 93
            },
            "line": 3940,
            "code": "            it('auto-indents lines with a mix of hard tabs and spaces without removing spaces', () => {\n              editor.setSoftTabs(false);\n              expect(editor.indentationForBufferRow(5)).toBe(3);\n              atom.clipboard.write('/**\\n\\t * testing\\n\\t * indent\\n\\t **/\\n', {\n                indentBasis: 1\n              });\n              editor.setCursorBufferPosition([5, 0]);\n              editor.pasteText(); // Do not lose the alignment spaces\n\n              expect(editor.lineTextForBufferRow(5)).toBe('\\t\\t\\t/**');\n              expect(editor.lineTextForBufferRow(6)).toBe('\\t\\t\\t * testing');\n              expect(editor.lineTextForBufferRow(7)).toBe('\\t\\t\\t * indent');\n              expect(editor.lineTextForBufferRow(8)).toBe('\\t\\t\\t **/');\n            });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "auto-indents based on the pasted line(s) only",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when `autoIndentOnPaste` is true",
                "when pasting line(s) above a line that matches the decreaseIndentPattern"
            ],
            "updatePoint": {
                "line": 3955,
                "column": 150
            },
            "line": 3955,
            "code": "          describe('when pasting line(s) above a line that matches the decreaseIndentPattern', () => it('auto-indents based on the pasted line(s) only', () => {\n            atom.clipboard.write('a(x);\\n  b(x);\\n    c(x);\\n', {\n              indentBasis: 0\n            });\n            editor.setCursorBufferPosition([7, 0]);\n            editor.pasteText();\n            expect(editor.lineTextForBufferRow(7)).toBe('      a(x);');\n            expect(editor.lineTextForBufferRow(8)).toBe('        b(x);');\n            expect(editor.lineTextForBufferRow(9)).toBe('          c(x);');\n            expect(editor.lineTextForBufferRow(10)).toBe('    }');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not auto-indent the text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when `autoIndentOnPaste` is true",
                "when pasting a line of text without line ending"
            ],
            "updatePoint": {
                "line": 3966,
                "column": 109
            },
            "line": 3966,
            "code": "          describe('when pasting a line of text without line ending', () => it('does not auto-indent the text', () => {\n            atom.clipboard.write('a(x);', {\n              indentBasis: 0\n            });\n            editor.setCursorBufferPosition([5, 0]);\n            editor.pasteText();\n            expect(editor.lineTextForBufferRow(5)).toBe('a(x);      current = items.shift();');\n            expect(editor.lineTextForBufferRow(6)).toBe('      current < pivot ? left.push(current) : right.push(current);');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not auto-indent the affected line",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when `autoIndentOnPaste` is true",
                "when pasting on a line after non-whitespace characters"
            ],
            "updatePoint": {
                "line": 3975,
                "column": 125
            },
            "line": 3975,
            "code": "          describe('when pasting on a line after non-whitespace characters', () => it('does not auto-indent the affected line', () => {\n            // Before the paste, the indentation is non-standard.\n            editor.setText(dedent`\\\n                if (x) {\n                    y();\n                }\\\n              `);\n            atom.clipboard.write(' z();\\n h();');\n            editor.setCursorBufferPosition([1, Infinity]); // The indentation of the non-standard line is unchanged.\n\n            editor.pasteText();\n            expect(editor.lineTextForBufferRow(1)).toBe('    y(); z();');\n            expect(editor.lineTextForBufferRow(2)).toBe(' h();');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "increases the indentation of the copied lines to match",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when `autoIndentOnPaste` is false",
                "when the cursor is indented further than the original copied text"
            ],
            "updatePoint": {
                "line": 3994,
                "column": 152
            },
            "line": 3994,
            "code": "          describe('when the cursor is indented further than the original copied text', () => it('increases the indentation of the copied lines to match', () => {\n            editor.setSelectedBufferRange([[1, 2], [3, 0]]);\n            editor.copySelectedText();\n            editor.setCursorBufferPosition([5, 6]);\n            editor.pasteText();\n            expect(editor.lineTextForBufferRow(5)).toBe('      var sort = function(items) {');\n            expect(editor.lineTextForBufferRow(6)).toBe('        if (items.length <= 1) return items;');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "decreases the indentation of the copied lines to match",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when `autoIndentOnPaste` is false",
                "when the cursor is indented less far than the original copied text"
            ],
            "updatePoint": {
                "line": 4002,
                "column": 153
            },
            "line": 4002,
            "code": "          describe('when the cursor is indented less far than the original copied text', () => it('decreases the indentation of the copied lines to match', () => {\n            editor.setSelectedBufferRange([[6, 6], [8, 0]]);\n            editor.copySelectedText();\n            editor.setCursorBufferPosition([1, 2]);\n            editor.pasteText();\n            expect(editor.lineTextForBufferRow(1)).toBe('  current < pivot ? left.push(current) : right.push(current);');\n            expect(editor.lineTextForBufferRow(2)).toBe('}');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "preserves the line's leading whitespace",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when `autoIndentOnPaste` is false",
                "when the first copied line has leading whitespace"
            ],
            "updatePoint": {
                "line": 4010,
                "column": 121
            },
            "line": 4010,
            "code": "          describe('when the first copied line has leading whitespace', () => it(\"preserves the line's leading whitespace\", () => {\n            editor.setSelectedBufferRange([[4, 0], [6, 0]]);\n            editor.copySelectedText();\n            editor.setCursorBufferPosition([0, 0]);\n            editor.pasteText();\n            expect(editor.lineTextForBufferRow(0)).toBe('    while(items.length > 0) {');\n            expect(editor.lineTextForBufferRow(1)).toBe('      current = items.shift();');\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "pastes each selection in order separately into the buffer",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when the clipboard has many selections"
            ],
            "updatePoint": {
                "line": 4027,
                "column": 71
            },
            "line": 4027,
            "code": "          it('pastes each selection in order separately into the buffer', () => {\n            editor.setSelectedBufferRanges([[[1, 6], [1, 10]], [[0, 4], [0, 13]]]);\n            editor.moveRight();\n            editor.insertText('_');\n            editor.pasteText();\n            expect(editor.lineTextForBufferRow(0)).toBe('var quicksort_quicksort = function () {');\n            expect(editor.lineTextForBufferRow(1)).toBe('  var sort_sort = function(items) {');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "pastes the whole text into the buffer",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when the clipboard has many selections",
                "and the selections count does not match"
            ],
            "updatePoint": {
                "line": 4037,
                "column": 53
            },
            "line": 4037,
            "code": "            it('pastes the whole text into the buffer', () => {\n              editor.pasteText();\n              expect(editor.lineTextForBufferRow(0)).toBe('var quicksort');\n              expect(editor.lineTextForBufferRow(1)).toBe('sort = function () {');\n            });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "pastes the line above the cursor and retains the cursor's column",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when a full line was cut"
            ],
            "updatePoint": {
                "line": 4050,
                "column": 78
            },
            "line": 4050,
            "code": "          it(\"pastes the line above the cursor and retains the cursor's column\", () => {\n            editor.pasteText();\n            expect(editor.lineTextForBufferRow(2)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n            expect(editor.getCursorBufferPosition()).toEqual([3, 13]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "overwrites the selection as with any copied text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when a full line was copied",
                "when there is a selection"
            ],
            "updatePoint": {
                "line": 4062,
                "column": 106
            },
            "line": 4062,
            "code": "          describe('when there is a selection', () => it('overwrites the selection as with any copied text', () => {\n            editor.setSelectedBufferRange([[1, 2], [1, Infinity]]);\n            editor.pasteText();\n            expect(editor.lineTextForBufferRow(1)).toBe('  if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(2)).toBe('');\n            expect(editor.lineTextForBufferRow(3)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.getCursorBufferPosition()).toEqual([2, 0]);\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "pastes the line above the cursor and retains the cursor's column",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when a full line was copied",
                "when there is no selection"
            ],
            "updatePoint": {
                "line": 4070,
                "column": 123
            },
            "line": 4070,
            "code": "          describe('when there is no selection', () => it(\"pastes the line above the cursor and retains the cursor's column\", () => {\n            editor.pasteText();\n            expect(editor.lineTextForBufferRow(2)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.lineTextForBufferRow(3)).toBe('    if (items.length <= 1) return items;');\n            expect(editor.getCursorBufferPosition()).toEqual([3, 13]);\n          }));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "respects options that preserve the formatting of the pasted text",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "clipboard operations",
                ".pasteText()",
                "when a full line was copied",
                "when there is no selection"
            ],
            "updatePoint": {
                "line": 4077,
                "column": 76
            },
            "line": 4077,
            "code": "        it('respects options that preserve the formatting of the pasted text', () => {\n          editor.update({\n            autoIndentOnPaste: true\n          });\n          atom.clipboard.write('a(x);\\n  b(x);\\r\\nc(x);\\n', {\n            indentBasis: 0\n          });\n          editor.setCursorBufferPosition([5, 0]);\n          editor.insertText('  ');\n          editor.pasteText({\n            autoIndent: false,\n            preserveTrailingLineIndentation: true,\n            normalizeLineEndings: false\n          });\n          expect(editor.lineTextForBufferRow(5)).toBe('  a(x);');\n          expect(editor.lineTextForBufferRow(6)).toBe('  b(x);');\n          expect(editor.buffer.lineEndingForRow(6)).toBe(os.EOL);\n          expect(editor.lineTextForBufferRow(7)).toBe('c(x);');\n          expect(editor.lineTextForBufferRow(8)).toBe('      current = items.shift();');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents line and retains selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indentSelectedRows()",
                "when nothing is selected",
                "when softTabs is enabled"
            ],
            "updatePoint": {
                "line": 4102,
                "column": 48
            },
            "line": 4102,
            "code": "          it('indents line and retains selection', () => {\n            editor.setSelectedBufferRange([[0, 3], [0, 3]]);\n            editor.indentSelectedRows();\n            expect(buffer.lineForRow(0)).toBe('  var quicksort = function () {');\n            expect(editor.getSelectedBufferRange()).toEqual([[0, 3 + editor.getTabLength()], [0, 3 + editor.getTabLength()]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents line and retains selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indentSelectedRows()",
                "when nothing is selected",
                "when softTabs is disabled"
            ],
            "updatePoint": {
                "line": 4110,
                "column": 48
            },
            "line": 4110,
            "code": "          it('indents line and retains selection', () => {\n            convertToHardTabs(buffer);\n            editor.setSoftTabs(false);\n            editor.setSelectedBufferRange([[0, 3], [0, 3]]);\n            editor.indentSelectedRows();\n            expect(buffer.lineForRow(0)).toBe('\\tvar quicksort = function () {');\n            expect(editor.getSelectedBufferRange()).toEqual([[0, 3 + 1], [0, 3 + 1]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents line and retains selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indentSelectedRows()",
                "when one line is selected",
                "when softTabs is enabled"
            ],
            "updatePoint": {
                "line": 4122,
                "column": 48
            },
            "line": 4122,
            "code": "          it('indents line and retains selection', () => {\n            editor.setSelectedBufferRange([[0, 4], [0, 14]]);\n            editor.indentSelectedRows();\n            expect(buffer.lineForRow(0)).toBe(`${editor.getTabText()}var quicksort = function () {`);\n            expect(editor.getSelectedBufferRange()).toEqual([[0, 4 + editor.getTabLength()], [0, 14 + editor.getTabLength()]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents line and retains selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indentSelectedRows()",
                "when one line is selected",
                "when softTabs is disabled"
            ],
            "updatePoint": {
                "line": 4130,
                "column": 48
            },
            "line": 4130,
            "code": "          it('indents line and retains selection', () => {\n            convertToHardTabs(buffer);\n            editor.setSoftTabs(false);\n            editor.setSelectedBufferRange([[0, 4], [0, 14]]);\n            editor.indentSelectedRows();\n            expect(buffer.lineForRow(0)).toBe('\\tvar quicksort = function () {');\n            expect(editor.getSelectedBufferRange()).toEqual([[0, 4 + 1], [0, 14 + 1]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents selected lines (that are not empty) and retains selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indentSelectedRows()",
                "when multiple lines are selected",
                "when softTabs is enabled"
            ],
            "updatePoint": {
                "line": 4142,
                "column": 79
            },
            "line": 4142,
            "code": "          it('indents selected lines (that are not empty) and retains selection', () => {\n            editor.setSelectedBufferRange([[9, 1], [11, 15]]);\n            editor.indentSelectedRows();\n            expect(buffer.lineForRow(9)).toBe('    };');\n            expect(buffer.lineForRow(10)).toBe('');\n            expect(buffer.lineForRow(11)).toBe('    return sort(Array.apply(this, arguments));');\n            expect(editor.getSelectedBufferRange()).toEqual([[9, 1 + editor.getTabLength()], [11, 15 + editor.getTabLength()]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not indent the last row if the selection ends at column 0",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indentSelectedRows()",
                "when multiple lines are selected",
                "when softTabs is enabled"
            ],
            "updatePoint": {
                "line": 4150,
                "column": 76
            },
            "line": 4150,
            "code": "          it('does not indent the last row if the selection ends at column 0', () => {\n            editor.setSelectedBufferRange([[9, 1], [11, 0]]);\n            editor.indentSelectedRows();\n            expect(buffer.lineForRow(9)).toBe('    };');\n            expect(buffer.lineForRow(10)).toBe('');\n            expect(buffer.lineForRow(11)).toBe('  return sort(Array.apply(this, arguments));');\n            expect(editor.getSelectedBufferRange()).toEqual([[9, 1 + editor.getTabLength()], [11, 0]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents selected lines (that are not empty) and retains selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".indentSelectedRows()",
                "when multiple lines are selected",
                "when softTabs is disabled"
            ],
            "updatePoint": {
                "line": 4160,
                "column": 79
            },
            "line": 4160,
            "code": "          it('indents selected lines (that are not empty) and retains selection', () => {\n            convertToHardTabs(buffer);\n            editor.setSoftTabs(false);\n            editor.setSelectedBufferRange([[9, 1], [11, 15]]);\n            editor.indentSelectedRows();\n            expect(buffer.lineForRow(9)).toBe('\\t\\t};');\n            expect(buffer.lineForRow(10)).toBe('');\n            expect(buffer.lineForRow(11)).toBe('\\t\\treturn sort(Array.apply(this, arguments));');\n            expect(editor.getSelectedBufferRange()).toEqual([[9, 1 + 1], [11, 15 + 1]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "outdents line and retains selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".outdentSelectedRows()",
                "when nothing is selected"
            ],
            "updatePoint": {
                "line": 4175,
                "column": 47
            },
            "line": 4175,
            "code": "        it('outdents line and retains selection', () => {\n          editor.setSelectedBufferRange([[1, 3], [1, 3]]);\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(1)).toBe('var sort = function(items) {');\n          expect(editor.getSelectedBufferRange()).toEqual([[1, 3 - editor.getTabLength()], [1, 3 - editor.getTabLength()]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "outdents when indent is less than a tab length",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".outdentSelectedRows()",
                "when nothing is selected"
            ],
            "updatePoint": {
                "line": 4181,
                "column": 58
            },
            "line": 4181,
            "code": "        it('outdents when indent is less than a tab length', () => {\n          editor.insertText(' ');\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "outdents a single hard tab when indent is multiple hard tabs and and the session is using soft tabs",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".outdentSelectedRows()",
                "when nothing is selected"
            ],
            "updatePoint": {
                "line": 4186,
                "column": 111
            },
            "line": 4186,
            "code": "        it('outdents a single hard tab when indent is multiple hard tabs and and the session is using soft tabs', () => {\n          editor.insertText('\\t\\t');\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(0)).toBe('\\tvar quicksort = function () {');\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "outdents when a mix of hard tabs and soft tabs are used",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".outdentSelectedRows()",
                "when nothing is selected"
            ],
            "updatePoint": {
                "line": 4193,
                "column": 67
            },
            "line": 4193,
            "code": "        it('outdents when a mix of hard tabs and soft tabs are used', () => {\n          editor.insertText('\\t   ');\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(0)).toBe('   var quicksort = function () {');\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(0)).toBe(' var quicksort = function () {');\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "outdents only up to the first non-space non-tab character",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".outdentSelectedRows()",
                "when nothing is selected"
            ],
            "updatePoint": {
                "line": 4202,
                "column": 69
            },
            "line": 4202,
            "code": "        it('outdents only up to the first non-space non-tab character', () => {\n          editor.insertText(' \\tfoo\\t ');\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(0)).toBe('\\tfoo\\t var quicksort = function () {');\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(0)).toBe('foo\\t var quicksort = function () {');\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(0)).toBe('foo\\t var quicksort = function () {');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "outdents line and retains editor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".outdentSelectedRows()",
                "when one line is selected"
            ],
            "updatePoint": {
                "line": 4213,
                "column": 44
            },
            "line": 4213,
            "code": "        it('outdents line and retains editor', () => {\n          editor.setSelectedBufferRange([[1, 4], [1, 14]]);\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(1)).toBe('var sort = function(items) {');\n          expect(editor.getSelectedBufferRange()).toEqual([[1, 4 - editor.getTabLength()], [1, 14 - editor.getTabLength()]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "outdents selected lines and retains editor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".outdentSelectedRows()",
                "when multiple lines are selected"
            ],
            "updatePoint": {
                "line": 4221,
                "column": 54
            },
            "line": 4221,
            "code": "        it('outdents selected lines and retains editor', () => {\n          editor.setSelectedBufferRange([[0, 1], [3, 15]]);\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');\n          expect(buffer.lineForRow(1)).toBe('var sort = function(items) {');\n          expect(buffer.lineForRow(2)).toBe('  if (items.length <= 1) return items;');\n          expect(buffer.lineForRow(3)).toBe('  var pivot = items.shift(), current, left = [], right = [];');\n          expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [3, 15 - editor.getTabLength()]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not outdent the last line of the selection if it ends at column 0",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".outdentSelectedRows()",
                "when multiple lines are selected"
            ],
            "updatePoint": {
                "line": 4230,
                "column": 82
            },
            "line": 4230,
            "code": "        it('does not outdent the last line of the selection if it ends at column 0', () => {\n          editor.setSelectedBufferRange([[0, 1], [3, 0]]);\n          editor.outdentSelectedRows();\n          expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');\n          expect(buffer.lineForRow(1)).toBe('var sort = function(items) {');\n          expect(buffer.lineForRow(2)).toBe('  if (items.length <= 1) return items;');\n          expect(buffer.lineForRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n          expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [3, 0]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "auto-indents the selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".autoIndentSelectedRows"
            ],
            "updatePoint": {
                "line": 4242,
                "column": 36
            },
            "line": 4242,
            "code": "      it('auto-indents the selection', () => {\n        editor.setCursorBufferPosition([2, 0]);\n        editor.insertText('function() {\\ninside=true\\n}\\n  i=1\\n');\n        editor.getLastSelection().setBufferRange([[2, 0], [6, 0]]);\n        editor.autoIndentSelectedRows();\n        expect(editor.lineTextForBufferRow(2)).toBe('    function() {');\n        expect(editor.lineTextForBufferRow(3)).toBe('      inside=true');\n        expect(editor.lineTextForBufferRow(4)).toBe('    }');\n        expect(editor.lineTextForBufferRow(5)).toBe('    i=1');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "undoes/redoes the last change",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".undo() and .redo()"
            ],
            "updatePoint": {
                "line": 4254,
                "column": 39
            },
            "line": 4254,
            "code": "      it('undoes/redoes the last change', () => {\n        editor.insertText('foo');\n        editor.undo();\n        expect(buffer.lineForRow(0)).not.toContain('foo');\n        editor.redo();\n        expect(buffer.lineForRow(0)).toContain('foo');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "batches the undo / redo of changes caused by multiple cursors",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".undo() and .redo()"
            ],
            "updatePoint": {
                "line": 4261,
                "column": 71
            },
            "line": 4261,
            "code": "      it('batches the undo / redo of changes caused by multiple cursors', () => {\n        editor.setCursorScreenPosition([0, 0]);\n        editor.addCursorAtScreenPosition([1, 0]);\n        editor.insertText('foo');\n        editor.backspace();\n        expect(buffer.lineForRow(0)).toContain('fovar');\n        expect(buffer.lineForRow(1)).toContain('fo ');\n        editor.undo();\n        expect(buffer.lineForRow(0)).toContain('foo');\n        expect(buffer.lineForRow(1)).toContain('foo');\n        editor.redo();\n        expect(buffer.lineForRow(0)).not.toContain('foo');\n        expect(buffer.lineForRow(0)).toContain('fovar');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores cursors and selections to their states before and after undone and redone changes",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".undo() and .redo()"
            ],
            "updatePoint": {
                "line": 4275,
                "column": 100
            },
            "line": 4275,
            "code": "      it('restores cursors and selections to their states before and after undone and redone changes', () => {\n        editor.setSelectedBufferRanges([[[0, 0], [0, 0]], [[1, 0], [1, 3]]]);\n        editor.insertText('abc');\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 3], [0, 3]], [[1, 3], [1, 3]]]);\n        editor.setCursorBufferPosition([0, 0]);\n        editor.setSelectedBufferRanges([[[2, 0], [2, 0]], [[3, 0], [3, 0]], [[4, 0], [4, 3]]]);\n        editor.insertText('def');\n        expect(editor.getSelectedBufferRanges()).toEqual([[[2, 3], [2, 3]], [[3, 3], [3, 3]], [[4, 3], [4, 3]]]);\n        editor.setCursorBufferPosition([0, 0]);\n        editor.undo();\n        expect(editor.getSelectedBufferRanges()).toEqual([[[2, 0], [2, 0]], [[3, 0], [3, 0]], [[4, 0], [4, 3]]]);\n        editor.undo();\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [0, 0]], [[1, 0], [1, 3]]]);\n        editor.redo();\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 3], [0, 3]], [[1, 3], [1, 3]]]);\n        editor.redo();\n        expect(editor.getSelectedBufferRanges()).toEqual([[[2, 3], [2, 3]], [[3, 3], [3, 3]], [[4, 3], [4, 3]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the selected ranges after undo and redo",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".undo() and .redo()"
            ],
            "updatePoint": {
                "line": 4293,
                "column": 58
            },
            "line": 4293,
            "code": "      it('restores the selected ranges after undo and redo', () => {\n        editor.setSelectedBufferRanges([[[1, 6], [1, 10]], [[1, 22], [1, 27]]]);\n        editor.delete();\n        editor.delete();\n        expect(buffer.lineForRow(1)).toBe('  var = function( {');\n        expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 6]], [[1, 17], [1, 17]]]);\n        editor.undo();\n        expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 6]], [[1, 18], [1, 18]]]);\n        editor.undo();\n        expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 10]], [[1, 22], [1, 27]]]);\n        editor.redo();\n        expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 6]], [[1, 18], [1, 18]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores folds after undo and redo",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".undo() and .redo()"
            ],
            "updatePoint": {
                "line": 4306,
                "column": 45
            },
            "line": 4306,
            "code": "      xit('restores folds after undo and redo', () => {\n        editor.foldBufferRow(1);\n        editor.setSelectedBufferRange([[1, 0], [10, Infinity]], {\n          preserveFolds: true\n        });\n        expect(editor.isFoldedAtBufferRow(1)).toBeTruthy();\n        editor.insertText(dedent`\\\n          // testing\n          function foo() {\n            return 1 + 2;\n          }\\\n        `);\n        expect(editor.isFoldedAtBufferRow(1)).toBeFalsy();\n        editor.foldBufferRow(2);\n        editor.undo();\n        expect(editor.isFoldedAtBufferRow(1)).toBeTruthy();\n        expect(editor.isFoldedAtBufferRow(9)).toBeTruthy();\n        expect(editor.isFoldedAtBufferRow(10)).toBeFalsy();\n        editor.redo();\n        expect(editor.isFoldedAtBufferRow(1)).toBeFalsy();\n        expect(editor.isFoldedAtBufferRow(2)).toBeTruthy();\n      });",
            "skipped": true,
            "file": "text-editor-spec.js",
            "dir": "spec"
        },
        {
            "name": "restores the selection when the transaction is undone/redone",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "::transact"
            ],
            "updatePoint": {
                "line": 4330,
                "column": 70
            },
            "line": 4330,
            "code": "      it('restores the selection when the transaction is undone/redone', () => {\n        buffer.setText('1234');\n        editor.setSelectedBufferRange([[0, 1], [0, 3]]);\n        editor.transact(() => {\n          editor.delete();\n          editor.moveToEndOfLine();\n          editor.insertText('5');\n          expect(buffer.getText()).toBe('145');\n        });\n        editor.undo();\n        expect(buffer.getText()).toBe('1234');\n        expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 3]]);\n        editor.redo();\n        expect(buffer.getText()).toBe('145');\n        expect(editor.getSelectedBufferRange()).toEqual([[0, 3], [0, 3]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "[editor.transact] restore selection of change-initiated-editor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "undo/redo restore selections of editor which initiated original change"
            ],
            "updatePoint": {
                "line": 4362,
                "column": 72
            },
            "line": 4362,
            "code": "      it('[editor.transact] restore selection of change-initiated-editor', () => {\n        editor1.setCursorBufferPosition([0, 0]);\n        editor1.transact(() => editor1.insertText('1'));\n        editor2.setCursorBufferPosition([1, 0]);\n        editor2.transact(() => editor2.insertText('2'));\n        editor1.setCursorBufferPosition([2, 0]);\n        editor1.transact(() => editor1.insertText('3'));\n        editor2.setCursorBufferPosition([3, 0]);\n        editor2.transact(() => editor2.insertText('4'));\n        expect(editor1.getText()).toBe(dedent`\n          1aaaaaa\n          2bbbbbb\n          3cccccc\n          4dddddd\n          eeeeee\n        `);\n        editor2.setCursorBufferPosition([4, 0]);\n        editor1.undo();\n        expect(editor1.getCursorBufferPosition()).toEqual([3, 0]);\n        editor1.undo();\n        expect(editor1.getCursorBufferPosition()).toEqual([2, 0]);\n        editor1.undo();\n        expect(editor1.getCursorBufferPosition()).toEqual([1, 0]);\n        editor1.undo();\n        expect(editor1.getCursorBufferPosition()).toEqual([0, 0]);\n        expect(editor2.getCursorBufferPosition()).toEqual([4, 0]); // remain unchanged\n\n        editor1.redo();\n        expect(editor1.getCursorBufferPosition()).toEqual([0, 1]);\n        editor1.redo();\n        expect(editor1.getCursorBufferPosition()).toEqual([1, 1]);\n        editor1.redo();\n        expect(editor1.getCursorBufferPosition()).toEqual([2, 1]);\n        editor1.redo();\n        expect(editor1.getCursorBufferPosition()).toEqual([3, 1]);\n        expect(editor2.getCursorBufferPosition()).toEqual([4, 0]); // remain unchanged\n\n        editor1.setCursorBufferPosition([4, 0]);\n        editor2.undo();\n        expect(editor2.getCursorBufferPosition()).toEqual([3, 0]);\n        editor2.undo();\n        expect(editor2.getCursorBufferPosition()).toEqual([2, 0]);\n        editor2.undo();\n        expect(editor2.getCursorBufferPosition()).toEqual([1, 0]);\n        editor2.undo();\n        expect(editor2.getCursorBufferPosition()).toEqual([0, 0]);\n        expect(editor1.getCursorBufferPosition()).toEqual([4, 0]); // remain unchanged\n\n        editor2.redo();\n        expect(editor2.getCursorBufferPosition()).toEqual([0, 1]);\n        editor2.redo();\n        expect(editor2.getCursorBufferPosition()).toEqual([1, 1]);\n        editor2.redo();\n        expect(editor2.getCursorBufferPosition()).toEqual([2, 1]);\n        editor2.redo();\n        expect(editor2.getCursorBufferPosition()).toEqual([3, 1]);\n        expect(editor1.getCursorBufferPosition()).toEqual([4, 0]); // remain unchanged\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "[manually group checkpoint] restore selection of change-initiated-editor",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "undo/redo restore selections of editor which initiated original change"
            ],
            "updatePoint": {
                "line": 4420,
                "column": 82
            },
            "line": 4420,
            "code": "      it('[manually group checkpoint] restore selection of change-initiated-editor', () => {\n        const transact = (editor, fn) => {\n          const checkpoint = editor.createCheckpoint();\n          fn();\n          editor.groupChangesSinceCheckpoint(checkpoint);\n        };\n\n        editor1.setCursorBufferPosition([0, 0]);\n        transact(editor1, () => editor1.insertText('1'));\n        editor2.setCursorBufferPosition([1, 0]);\n        transact(editor2, () => editor2.insertText('2'));\n        editor1.setCursorBufferPosition([2, 0]);\n        transact(editor1, () => editor1.insertText('3'));\n        editor2.setCursorBufferPosition([3, 0]);\n        transact(editor2, () => editor2.insertText('4'));\n        expect(editor1.getText()).toBe(dedent`\n          1aaaaaa\n          2bbbbbb\n          3cccccc\n          4dddddd\n          eeeeee\n        `);\n        editor2.setCursorBufferPosition([4, 0]);\n        editor1.undo();\n        expect(editor1.getCursorBufferPosition()).toEqual([3, 0]);\n        editor1.undo();\n        expect(editor1.getCursorBufferPosition()).toEqual([2, 0]);\n        editor1.undo();\n        expect(editor1.getCursorBufferPosition()).toEqual([1, 0]);\n        editor1.undo();\n        expect(editor1.getCursorBufferPosition()).toEqual([0, 0]);\n        expect(editor2.getCursorBufferPosition()).toEqual([4, 0]); // remain unchanged\n\n        editor1.redo();\n        expect(editor1.getCursorBufferPosition()).toEqual([0, 1]);\n        editor1.redo();\n        expect(editor1.getCursorBufferPosition()).toEqual([1, 1]);\n        editor1.redo();\n        expect(editor1.getCursorBufferPosition()).toEqual([2, 1]);\n        editor1.redo();\n        expect(editor1.getCursorBufferPosition()).toEqual([3, 1]);\n        expect(editor2.getCursorBufferPosition()).toEqual([4, 0]); // remain unchanged\n\n        editor1.setCursorBufferPosition([4, 0]);\n        editor2.undo();\n        expect(editor2.getCursorBufferPosition()).toEqual([3, 0]);\n        editor2.undo();\n        expect(editor2.getCursorBufferPosition()).toEqual([2, 0]);\n        editor2.undo();\n        expect(editor2.getCursorBufferPosition()).toEqual([1, 0]);\n        editor2.undo();\n        expect(editor2.getCursorBufferPosition()).toEqual([0, 0]);\n        expect(editor1.getCursorBufferPosition()).toEqual([4, 0]); // remain unchanged\n\n        editor2.redo();\n        expect(editor2.getCursorBufferPosition()).toEqual([0, 1]);\n        editor2.redo();\n        expect(editor2.getCursorBufferPosition()).toEqual([1, 1]);\n        editor2.redo();\n        expect(editor2.getCursorBufferPosition()).toEqual([2, 1]);\n        editor2.redo();\n        expect(editor2.getCursorBufferPosition()).toEqual([3, 1]);\n        expect(editor1.getCursorBufferPosition()).toEqual([4, 0]); // remain unchanged\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor so it is in the same relative position of the buffer",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "when the buffer is changed (via its direct api, rather than via than edit session)"
            ],
            "updatePoint": {
                "line": 4486,
                "column": 79
            },
            "line": 4486,
            "code": "      it('moves the cursor so it is in the same relative position of the buffer', () => {\n        expect(editor.getCursorScreenPosition()).toEqual([0, 0]);\n        editor.addCursorAtScreenPosition([0, 5]);\n        editor.addCursorAtScreenPosition([1, 0]);\n        const [cursor1, cursor2, cursor3] = editor.getCursors();\n        buffer.insert([0, 1], 'abc');\n        expect(cursor1.getScreenPosition()).toEqual([0, 0]);\n        expect(cursor2.getScreenPosition()).toEqual([0, 8]);\n        expect(cursor3.getScreenPosition()).toEqual([1, 0]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not destroy cursors or selections when a change encompasses them",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "when the buffer is changed (via its direct api, rather than via than edit session)"
            ],
            "updatePoint": {
                "line": 4496,
                "column": 79
            },
            "line": 4496,
            "code": "      it('does not destroy cursors or selections when a change encompasses them', () => {\n        const cursor = editor.getLastCursor();\n        cursor.setBufferPosition([3, 3]);\n        editor.buffer.delete([[3, 1], [3, 5]]);\n        expect(cursor.getBufferPosition()).toEqual([3, 1]);\n        expect(editor.getCursors().indexOf(cursor)).not.toBe(-1);\n        const selection = editor.getLastSelection();\n        selection.setBufferRange([[3, 5], [3, 10]]);\n        editor.buffer.delete([[3, 3], [3, 8]]);\n        expect(selection.getBufferRange()).toEqual([[3, 3], [3, 5]]);\n        expect(editor.getSelections().indexOf(selection)).not.toBe(-1);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "merges cursors when the change causes them to overlap",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "when the buffer is changed (via its direct api, rather than via than edit session)"
            ],
            "updatePoint": {
                "line": 4508,
                "column": 63
            },
            "line": 4508,
            "code": "      it('merges cursors when the change causes them to overlap', () => {\n        editor.setCursorScreenPosition([0, 0]);\n        editor.addCursorAtScreenPosition([0, 2]);\n        editor.addCursorAtScreenPosition([1, 2]);\n        const [cursor1,, cursor3] = editor.getCursors();\n        expect(editor.getCursors().length).toBe(3);\n        buffer.delete([[0, 0], [0, 2]]);\n        expect(editor.getCursors().length).toBe(2);\n        expect(editor.getCursors()).toEqual([cursor1, cursor3]);\n        expect(cursor1.getBufferPosition()).toEqual([0, 0]);\n        expect(cursor3.getBufferPosition()).toEqual([1, 2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves one active selection on one line one column to the left",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveSelectionLeft()"
            ],
            "updatePoint": {
                "line": 4522,
                "column": 71
            },
            "line": 4522,
            "code": "      it('moves one active selection on one line one column to the left', () => {\n        editor.setSelectedBufferRange([[0, 4], [0, 13]]);\n        expect(editor.getSelectedText()).toBe('quicksort');\n        editor.moveSelectionLeft();\n        expect(editor.getSelectedText()).toBe('quicksort');\n        expect(editor.getSelectedBufferRange()).toEqual([[0, 3], [0, 12]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves multiple active selections on one line one column to the left",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveSelectionLeft()"
            ],
            "updatePoint": {
                "line": 4529,
                "column": 77
            },
            "line": 4529,
            "code": "      it('moves multiple active selections on one line one column to the left', () => {\n        editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[0, 16], [0, 24]]]);\n        const selections = editor.getSelections();\n        expect(selections[0].getText()).toBe('quicksort');\n        expect(selections[1].getText()).toBe('function');\n        editor.moveSelectionLeft();\n        expect(selections[0].getText()).toBe('quicksort');\n        expect(selections[1].getText()).toBe('function');\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 3], [0, 12]], [[0, 15], [0, 23]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves multiple active selections on multiple lines one column to the left",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveSelectionLeft()"
            ],
            "updatePoint": {
                "line": 4539,
                "column": 83
            },
            "line": 4539,
            "code": "      it('moves multiple active selections on multiple lines one column to the left', () => {\n        editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]]]);\n        const selections = editor.getSelections();\n        expect(selections[0].getText()).toBe('quicksort');\n        expect(selections[1].getText()).toBe('sort');\n        editor.moveSelectionLeft();\n        expect(selections[0].getText()).toBe('quicksort');\n        expect(selections[1].getText()).toBe('sort');\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 3], [0, 12]], [[1, 5], [1, 9]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not change the selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveSelectionLeft()",
                "when a selection is at the first column of a line"
            ],
            "updatePoint": {
                "line": 4550,
                "column": 41
            },
            "line": 4550,
            "code": "        it('does not change the selection', () => {\n          editor.setSelectedBufferRanges([[[0, 0], [0, 3]], [[1, 0], [1, 3]]]);\n          const selections = editor.getSelections();\n          expect(selections[0].getText()).toBe('var');\n          expect(selections[1].getText()).toBe('  v');\n          editor.moveSelectionLeft();\n          editor.moveSelectionLeft();\n          expect(selections[0].getText()).toBe('var');\n          expect(selections[1].getText()).toBe('  v');\n          expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [0, 3]], [[1, 0], [1, 3]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not change the selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveSelectionLeft()",
                "when a selection is at the first column of a line",
                "when multiple selections are active on one line"
            ],
            "updatePoint": {
                "line": 4562,
                "column": 43
            },
            "line": 4562,
            "code": "          it('does not change the selection', () => {\n            editor.setSelectedBufferRanges([[[0, 0], [0, 3]], [[0, 4], [0, 13]]]);\n            const selections = editor.getSelections();\n            expect(selections[0].getText()).toBe('var');\n            expect(selections[1].getText()).toBe('quicksort');\n            editor.moveSelectionLeft();\n            expect(selections[0].getText()).toBe('var');\n            expect(selections[1].getText()).toBe('quicksort');\n            expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [0, 3]], [[0, 4], [0, 13]]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves one active selection on one line one column to the right",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveSelectionRight()"
            ],
            "updatePoint": {
                "line": 4576,
                "column": 72
            },
            "line": 4576,
            "code": "      it('moves one active selection on one line one column to the right', () => {\n        editor.setSelectedBufferRange([[0, 4], [0, 13]]);\n        expect(editor.getSelectedText()).toBe('quicksort');\n        editor.moveSelectionRight();\n        expect(editor.getSelectedText()).toBe('quicksort');\n        expect(editor.getSelectedBufferRange()).toEqual([[0, 5], [0, 14]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves multiple active selections on one line one column to the right",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveSelectionRight()"
            ],
            "updatePoint": {
                "line": 4583,
                "column": 78
            },
            "line": 4583,
            "code": "      it('moves multiple active selections on one line one column to the right', () => {\n        editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[0, 16], [0, 24]]]);\n        const selections = editor.getSelections();\n        expect(selections[0].getText()).toBe('quicksort');\n        expect(selections[1].getText()).toBe('function');\n        editor.moveSelectionRight();\n        expect(selections[0].getText()).toBe('quicksort');\n        expect(selections[1].getText()).toBe('function');\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 5], [0, 14]], [[0, 17], [0, 25]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves multiple active selections on multiple lines one column to the right",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveSelectionRight()"
            ],
            "updatePoint": {
                "line": 4593,
                "column": 84
            },
            "line": 4593,
            "code": "      it('moves multiple active selections on multiple lines one column to the right', () => {\n        editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]]]);\n        const selections = editor.getSelections();\n        expect(selections[0].getText()).toBe('quicksort');\n        expect(selections[1].getText()).toBe('sort');\n        editor.moveSelectionRight();\n        expect(selections[0].getText()).toBe('quicksort');\n        expect(selections[1].getText()).toBe('sort');\n        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 5], [0, 14]], [[1, 7], [1, 11]]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not change the selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveSelectionRight()",
                "when a selection is at the last column of a line"
            ],
            "updatePoint": {
                "line": 4604,
                "column": 41
            },
            "line": 4604,
            "code": "        it('does not change the selection', () => {\n          editor.setSelectedBufferRanges([[[2, 34], [2, 40]], [[5, 22], [5, 30]]]);\n          const selections = editor.getSelections();\n          expect(selections[0].getText()).toBe('items;');\n          expect(selections[1].getText()).toBe('shift();');\n          editor.moveSelectionRight();\n          editor.moveSelectionRight();\n          expect(selections[0].getText()).toBe('items;');\n          expect(selections[1].getText()).toBe('shift();');\n          expect(editor.getSelectedBufferRanges()).toEqual([[[2, 34], [2, 40]], [[5, 22], [5, 30]]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not change the selection",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                ".moveSelectionRight()",
                "when a selection is at the last column of a line",
                "when multiple selections are active on one line"
            ],
            "updatePoint": {
                "line": 4616,
                "column": 43
            },
            "line": 4616,
            "code": "          it('does not change the selection', () => {\n            editor.setSelectedBufferRanges([[[2, 27], [2, 33]], [[2, 34], [2, 40]]]);\n            const selections = editor.getSelections();\n            expect(selections[0].getText()).toBe('return');\n            expect(selections[1].getText()).toBe('items;');\n            editor.moveSelectionRight();\n            expect(selections[0].getText()).toBe('return');\n            expect(selections[1].getText()).toBe('items;');\n            expect(editor.getSelectedBufferRanges()).toEqual([[[2, 27], [2, 33]], [[2, 34], [2, 40]]]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an error on ",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "when readonly",
                "without bypassReadOnly"
            ],
            "updatePoint": {
                "line": 4786,
                "column": 40
            },
            "line": 4786,
            "code": "          it(`throws an error on ${name}`, () => {\n            expect(op).toThrow();\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "permits ",
            "suites": [
                "TextEditor",
                "buffer manipulation",
                "when readonly",
                "with bypassReadOnly"
            ],
            "updatePoint": {
                "line": 4796,
                "column": 29
            },
            "line": 4796,
            "code": "          it(`permits ${name}`, () => {\n            op({\n              bypassReadOnly: true\n            });\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": ".lineTextForScreenRow(row)",
            "suites": [
                "TextEditor",
                "reading text"
            ],
            "updatePoint": {
                "line": 4806,
                "column": 34
            },
            "line": 4806,
            "code": "    it('.lineTextForScreenRow(row)', () => {\n      editor.foldBufferRow(4);\n      expect(editor.lineTextForScreenRow(5)).toEqual('    return sort(left).concat(pivot).concat(sort(right));');\n      expect(editor.lineTextForScreenRow(9)).toEqual('};');\n      expect(editor.lineTextForScreenRow(10)).toBeUndefined();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the first line when the cursor is there",
            "suites": [
                "TextEditor",
                ".deleteLine()"
            ],
            "updatePoint": {
                "line": 4814,
                "column": 55
            },
            "line": 4814,
            "code": "    it('deletes the first line when the cursor is there', () => {\n      editor.getLastCursor().moveToTop();\n      const line1 = buffer.lineForRow(1);\n      const count = buffer.getLineCount();\n      expect(buffer.lineForRow(0)).not.toBe(line1);\n      editor.deleteLine();\n      expect(buffer.lineForRow(0)).toBe(line1);\n      expect(buffer.getLineCount()).toBe(count - 1);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the last line when the cursor is there",
            "suites": [
                "TextEditor",
                ".deleteLine()"
            ],
            "updatePoint": {
                "line": 4823,
                "column": 54
            },
            "line": 4823,
            "code": "    it('deletes the last line when the cursor is there', () => {\n      const count = buffer.getLineCount();\n      const secondToLastLine = buffer.lineForRow(count - 2);\n      expect(buffer.lineForRow(count - 1)).not.toBe(secondToLastLine);\n      editor.getLastCursor().moveToBottom();\n      editor.deleteLine();\n      const newCount = buffer.getLineCount();\n      expect(buffer.lineForRow(newCount - 1)).toBe(secondToLastLine);\n      expect(newCount).toBe(count - 1);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes whole lines when partial lines are selected",
            "suites": [
                "TextEditor",
                ".deleteLine()"
            ],
            "updatePoint": {
                "line": 4833,
                "column": 59
            },
            "line": 4833,
            "code": "    it('deletes whole lines when partial lines are selected', () => {\n      editor.setSelectedBufferRange([[0, 2], [1, 2]]);\n      const line2 = buffer.lineForRow(2);\n      const count = buffer.getLineCount();\n      expect(buffer.lineForRow(0)).not.toBe(line2);\n      expect(buffer.lineForRow(1)).not.toBe(line2);\n      editor.deleteLine();\n      expect(buffer.lineForRow(0)).toBe(line2);\n      expect(buffer.getLineCount()).toBe(count - 2);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores cursor position for multiple cursors",
            "suites": [
                "TextEditor",
                ".deleteLine()"
            ],
            "updatePoint": {
                "line": 4843,
                "column": 53
            },
            "line": 4843,
            "code": "    it('restores cursor position for multiple cursors', () => {\n      const line = '0123456789'.repeat(8);\n      editor.setText((line + '\\n').repeat(5));\n      editor.setCursorScreenPosition([0, 5]);\n      editor.addCursorAtScreenPosition([2, 8]);\n      editor.deleteLine();\n      const cursors = editor.getCursors();\n      expect(cursors.length).toBe(2);\n      expect(cursors[0].getScreenPosition()).toEqual([0, 5]);\n      expect(cursors[1].getScreenPosition()).toEqual([1, 8]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores cursor position for multiple selections",
            "suites": [
                "TextEditor",
                ".deleteLine()"
            ],
            "updatePoint": {
                "line": 4854,
                "column": 56
            },
            "line": 4854,
            "code": "    it('restores cursor position for multiple selections', () => {\n      const line = '0123456789'.repeat(8);\n      editor.setText((line + '\\n').repeat(5));\n      editor.setSelectedBufferRanges([[[0, 5], [0, 8]], [[2, 4], [2, 15]]]);\n      editor.deleteLine();\n      const cursors = editor.getCursors();\n      expect(cursors.length).toBe(2);\n      expect(cursors[0].getScreenPosition()).toEqual([0, 5]);\n      expect(cursors[1].getScreenPosition()).toEqual([1, 4]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes a line only once when multiple selections are on the same line",
            "suites": [
                "TextEditor",
                ".deleteLine()"
            ],
            "updatePoint": {
                "line": 4864,
                "column": 78
            },
            "line": 4864,
            "code": "    it('deletes a line only once when multiple selections are on the same line', () => {\n      const line1 = buffer.lineForRow(1);\n      const count = buffer.getLineCount();\n      editor.setSelectedBufferRanges([[[0, 1], [0, 2]], [[0, 4], [0, 5]]]);\n      expect(buffer.lineForRow(0)).not.toBe(line1);\n      editor.deleteLine();\n      expect(buffer.lineForRow(0)).toBe(line1);\n      expect(buffer.getLineCount()).toBe(count - 1);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only deletes first line if only newline is selected on second line",
            "suites": [
                "TextEditor",
                ".deleteLine()"
            ],
            "updatePoint": {
                "line": 4873,
                "column": 74
            },
            "line": 4873,
            "code": "    it('only deletes first line if only newline is selected on second line', () => {\n      editor.setSelectedBufferRange([[0, 2], [1, 0]]);\n      const line1 = buffer.lineForRow(1);\n      const count = buffer.getLineCount();\n      expect(buffer.lineForRow(0)).not.toBe(line1);\n      editor.deleteLine();\n      expect(buffer.lineForRow(0)).toBe(line1);\n      expect(buffer.getLineCount()).toBe(count - 1);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the entire region when invoke on a folded region",
            "suites": [
                "TextEditor",
                ".deleteLine()"
            ],
            "updatePoint": {
                "line": 4882,
                "column": 64
            },
            "line": 4882,
            "code": "    it('deletes the entire region when invoke on a folded region', () => {\n      editor.foldBufferRow(1);\n      editor.getLastCursor().moveToTop();\n      editor.getLastCursor().moveDown();\n      expect(buffer.getLineCount()).toBe(13);\n      editor.deleteLine();\n      expect(buffer.getLineCount()).toBe(4);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the entire file from the bottom up",
            "suites": [
                "TextEditor",
                ".deleteLine()"
            ],
            "updatePoint": {
                "line": 4890,
                "column": 50
            },
            "line": 4890,
            "code": "    it('deletes the entire file from the bottom up', () => {\n      const count = buffer.getLineCount();\n      expect(count).toBeGreaterThan(0);\n\n      for (let i = 0; i < count; i++) {\n        editor.getLastCursor().moveToBottom();\n        editor.deleteLine();\n      }\n\n      expect(buffer.getLineCount()).toBe(1);\n      expect(buffer.getText()).toBe('');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the entire file from the top down",
            "suites": [
                "TextEditor",
                ".deleteLine()"
            ],
            "updatePoint": {
                "line": 4902,
                "column": 49
            },
            "line": 4902,
            "code": "    it('deletes the entire file from the top down', () => {\n      const count = buffer.getLineCount();\n      expect(count).toBeGreaterThan(0);\n\n      for (let i = 0; i < count; i++) {\n        editor.getLastCursor().moveToTop();\n        editor.deleteLine();\n      }\n\n      expect(buffer.getLineCount()).toBe(1);\n      expect(buffer.getText()).toBe('');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the entire line that the cursor is on",
            "suites": [
                "TextEditor",
                ".deleteLine()",
                "when soft wrap is enabled"
            ],
            "updatePoint": {
                "line": 4915,
                "column": 55
            },
            "line": 4915,
            "code": "      it('deletes the entire line that the cursor is on', () => {\n        editor.setSoftWrapped(true);\n        editor.setEditorWidthInChars(10);\n        editor.setCursorBufferPosition([6]);\n        const line7 = buffer.lineForRow(7);\n        const count = buffer.getLineCount();\n        expect(buffer.lineForRow(6)).not.toBe(line7);\n        editor.deleteLine();\n        expect(buffer.lineForRow(6)).toBe(line7);\n        expect(buffer.getLineCount()).toBe(count - 1);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "restores the line and preserves the fold",
            "suites": [
                "TextEditor",
                ".deleteLine()",
                "when the line being deleted precedes a fold, and the command is undone"
            ],
            "updatePoint": {
                "line": 4928,
                "column": 50
            },
            "line": 4928,
            "code": "      it('restores the line and preserves the fold', () => {\n        editor.setCursorBufferPosition([4]);\n        editor.foldCurrentRow();\n        expect(editor.isFoldedAtScreenRow(4)).toBeTruthy();\n        editor.setCursorBufferPosition([3]);\n        editor.deleteLine();\n        expect(editor.isFoldedAtScreenRow(3)).toBeTruthy();\n        expect(buffer.lineForRow(3)).toBe('    while(items.length > 0) {');\n        editor.undo();\n        expect(editor.isFoldedAtScreenRow(4)).toBeTruthy();\n        expect(buffer.lineForRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts the text returned from the function at the cursor position",
            "suites": [
                "TextEditor",
                ".replaceSelectedText(options, fn)",
                "when no text is selected"
            ],
            "updatePoint": {
                "line": 4944,
                "column": 76
            },
            "line": 4944,
            "code": "      it('inserts the text returned from the function at the cursor position', () => {\n        editor.replaceSelectedText({}, () => '123');\n        expect(buffer.lineForRow(0)).toBe('123var quicksort = function () {');\n        editor.setCursorBufferPosition([0]);\n        editor.replaceSelectedText({\n          selectWordIfEmpty: true\n        }, () => 'var');\n        expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');\n        editor.setCursorBufferPosition([10]);\n        editor.replaceSelectedText(null, () => '');\n        expect(buffer.lineForRow(10)).toBe('');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces the selected text with the text returned from the function",
            "suites": [
                "TextEditor",
                ".replaceSelectedText(options, fn)",
                "when text is selected"
            ],
            "updatePoint": {
                "line": 4958,
                "column": 77
            },
            "line": 4958,
            "code": "      it('replaces the selected text with the text returned from the function', () => {\n        editor.setSelectedBufferRange([[0, 1], [0, 3]]);\n        editor.replaceSelectedText({}, () => 'ia');\n        expect(buffer.lineForRow(0)).toBe('via quicksort = function () {');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces the selected text and selects the replacement text",
            "suites": [
                "TextEditor",
                ".replaceSelectedText(options, fn)",
                "when text is selected"
            ],
            "updatePoint": {
                "line": 4963,
                "column": 69
            },
            "line": 4963,
            "code": "      it('replaces the selected text and selects the replacement text', () => {\n        editor.setSelectedBufferRange([[0, 4], [0, 9]]);\n        editor.replaceSelectedText({}, () => 'whatnot');\n        expect(buffer.lineForRow(0)).toBe('var whatnotsort = function () {');\n        expect(editor.getSelectedBufferRange()).toEqual([[0, 4], [0, 11]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "swaps two characters",
            "suites": [
                "TextEditor",
                ".transpose()"
            ],
            "updatePoint": {
                "line": 4972,
                "column": 28
            },
            "line": 4972,
            "code": "    it('swaps two characters', () => {\n      editor.buffer.setText('abc');\n      editor.setCursorScreenPosition([0, 1]);\n      editor.transpose();\n      expect(editor.lineTextForBufferRow(0)).toBe('bac');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reverses a selection",
            "suites": [
                "TextEditor",
                ".transpose()"
            ],
            "updatePoint": {
                "line": 4978,
                "column": 28
            },
            "line": 4978,
            "code": "    it('reverses a selection', () => {\n      editor.buffer.setText('xabcz');\n      editor.setSelectedBufferRange([[0, 1], [0, 4]]);\n      editor.transpose();\n      expect(editor.lineTextForBufferRow(0)).toBe('xcbaz');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "upper cases the current word",
            "suites": [
                "TextEditor",
                ".upperCase()",
                "when there is no selection"
            ],
            "updatePoint": {
                "line": 4987,
                "column": 38
            },
            "line": 4987,
            "code": "      it('upper cases the current word', () => {\n        editor.buffer.setText('aBc');\n        editor.setCursorScreenPosition([0, 1]);\n        editor.upperCase();\n        expect(editor.lineTextForBufferRow(0)).toBe('ABC');\n        expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 3]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "upper cases the current selection",
            "suites": [
                "TextEditor",
                ".upperCase()",
                "when there is a selection"
            ],
            "updatePoint": {
                "line": 4996,
                "column": 43
            },
            "line": 4996,
            "code": "      it('upper cases the current selection', () => {\n        editor.buffer.setText('abc');\n        editor.setSelectedBufferRange([[0, 0], [0, 2]]);\n        editor.upperCase();\n        expect(editor.lineTextForBufferRow(0)).toBe('ABc');\n        expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 2]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "lower cases the current word",
            "suites": [
                "TextEditor",
                ".lowerCase()",
                "when there is no selection"
            ],
            "updatePoint": {
                "line": 5007,
                "column": 38
            },
            "line": 5007,
            "code": "      it('lower cases the current word', () => {\n        editor.buffer.setText('aBC');\n        editor.setCursorScreenPosition([0, 1]);\n        editor.lowerCase();\n        expect(editor.lineTextForBufferRow(0)).toBe('abc');\n        expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 3]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "lower cases the current selection",
            "suites": [
                "TextEditor",
                ".lowerCase()",
                "when there is a selection"
            ],
            "updatePoint": {
                "line": 5016,
                "column": 43
            },
            "line": 5016,
            "code": "      it('lower cases the current selection', () => {\n        editor.buffer.setText('ABC');\n        editor.setSelectedBufferRange([[0, 0], [0, 2]]);\n        editor.lowerCase();\n        expect(editor.lineTextForBufferRow(0)).toBe('abC');\n        expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 2]]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clips atomic soft tabs to the given tab length",
            "suites": [
                "TextEditor",
                ".setTabLength(tabLength)"
            ],
            "updatePoint": {
                "line": 5026,
                "column": 54
            },
            "line": 5026,
            "code": "    it('clips atomic soft tabs to the given tab length', () => {\n      expect(editor.getTabLength()).toBe(2);\n      expect(editor.clipScreenPosition([5, 1], {\n        clipDirection: 'forward'\n      })).toEqual([5, 2]);\n      editor.setTabLength(6);\n      expect(editor.getTabLength()).toBe(6);\n      expect(editor.clipScreenPosition([5, 1], {\n        clipDirection: 'forward'\n      })).toEqual([5, 6]);\n      const changeHandler = jasmine.createSpy('changeHandler');\n      editor.onDidChange(changeHandler);\n      editor.setTabLength(6);\n      expect(changeHandler).not.toHaveBeenCalled();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not change its tab length when the given tab length is null",
            "suites": [
                "TextEditor",
                ".setTabLength(tabLength)"
            ],
            "updatePoint": {
                "line": 5041,
                "column": 72
            },
            "line": 5041,
            "code": "    it('does not change its tab length when the given tab length is null', () => {\n      editor.setTabLength(4);\n      editor.setTabLength(null);\n      expect(editor.getTabLength()).toBe(4);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the indent level when the line has only leading whitespace",
            "suites": [
                "TextEditor",
                ".indentLevelForLine(line)"
            ],
            "updatePoint": {
                "line": 5048,
                "column": 74
            },
            "line": 5048,
            "code": "    it('returns the indent level when the line has only leading whitespace', () => {\n      expect(editor.indentLevelForLine('    hello')).toBe(2);\n      expect(editor.indentLevelForLine('   hello')).toBe(1.5);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the indent level when the line has only leading tabs",
            "suites": [
                "TextEditor",
                ".indentLevelForLine(line)"
            ],
            "updatePoint": {
                "line": 5052,
                "column": 68
            },
            "line": 5052,
            "code": "    it('returns the indent level when the line has only leading tabs', () => expect(editor.indentLevelForLine('\\t\\thello')).toBe(2));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the indent level based on the character starting the line when the leading whitespace contains both spaces and tabs",
            "suites": [
                "TextEditor",
                ".indentLevelForLine(line)"
            ],
            "updatePoint": {
                "line": 5053,
                "column": 131
            },
            "line": 5053,
            "code": "    it('returns the indent level based on the character starting the line when the leading whitespace contains both spaces and tabs', () => {\n      expect(editor.indentLevelForLine('\\t  hello')).toBe(2);\n      expect(editor.indentLevelForLine('  \\thello')).toBe(2);\n      expect(editor.indentLevelForLine('  \\t hello')).toBe(2.5);\n      expect(editor.indentLevelForLine('    \\t \\thello')).toBe(4);\n      expect(editor.indentLevelForLine('     \\t \\thello')).toBe(4);\n      expect(editor.indentLevelForLine('     \\t \\t hello')).toBe(4.5);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies onDidTokenize observers when retokenization is finished",
            "suites": [
                "TextEditor",
                "when the buffer's language mode changes"
            ],
            "updatePoint": {
                "line": 5066,
                "column": 72
            },
            "line": 5066,
            "code": "    it('notifies onDidTokenize observers when retokenization is finished', async () => {\n      // Exercise the full `tokenizeInBackground` code path, which bails out early if\n      // `.setVisible` has not been called with `true`.\n      jasmine.unspy(TextMateLanguageMode.prototype, 'tokenizeInBackground');\n      jasmine.attachToDOM(editor.getElement());\n      const events = [];\n      editor.onDidTokenize(event => events.push(event));\n      await atom.packages.activatePackage('language-c');\n      expect(atom.grammars.assignLanguageMode(editor.getBuffer(), 'source.c')).toBe(true);\n      advanceClock(1);\n      expect(events.length).toBe(1);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies onDidChangeGrammar observers",
            "suites": [
                "TextEditor",
                "when the buffer's language mode changes"
            ],
            "updatePoint": {
                "line": 5078,
                "column": 45
            },
            "line": 5078,
            "code": "    it('notifies onDidChangeGrammar observers', async () => {\n      const events = [];\n      editor.onDidChangeGrammar(grammar => events.push(grammar));\n      await atom.packages.activatePackage('language-c');\n      expect(atom.grammars.assignLanguageMode(editor.getBuffer(), 'source.c')).toBe(true);\n      expect(events.length).toBe(1);\n      expect(events[0].name).toBe('C');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not auto-indent the line",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is false (default)",
                "when `indent` is triggered"
            ],
            "updatePoint": {
                "line": 5090,
                "column": 41
            },
            "line": 5090,
            "code": "        it('does not auto-indent the line', () => {\n          editor.setCursorBufferPosition([1, 30]);\n          editor.insertText('\\n ');\n          expect(editor.lineTextForBufferRow(2)).toBe(' ');\n          editor.update({\n            autoIndent: false\n          });\n          editor.indent();\n          expect(editor.lineTextForBufferRow(2)).toBe('  ');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "auto-indents the line",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when `indent` is triggered"
            ],
            "updatePoint": {
                "line": 5107,
                "column": 33
            },
            "line": 5107,
            "code": "        it('auto-indents the line', () => {\n          editor.setCursorBufferPosition([1, 30]);\n          editor.insertText('\\n ');\n          expect(editor.lineTextForBufferRow(2)).toBe(' ');\n          editor.update({\n            autoIndent: true\n          });\n          editor.indent();\n          expect(editor.lineTextForBufferRow(2)).toBe('    ');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents the newline to one additional level of indentation beyond the preceding line",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when a newline is added",
                "when the line preceding the newline adds a new level of indentation"
            ],
            "updatePoint": {
                "line": 5120,
                "column": 98
            },
            "line": 5120,
            "code": "          it('indents the newline to one additional level of indentation beyond the preceding line', () => {\n            editor.setCursorBufferPosition([1, Infinity]);\n            editor.insertText('\\n');\n            expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents the new line to the same level as the preceding line",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when a newline is added",
                "when the line preceding the newline doesn't add a level of indentation"
            ],
            "updatePoint": {
                "line": 5127,
                "column": 74
            },
            "line": 5127,
            "code": "          it('indents the new line to the same level as the preceding line', () => {\n            editor.setCursorBufferPosition([5, 14]);\n            editor.insertText('\\n');\n            expect(editor.indentationForBufferRow(6)).toBe(editor.indentationForBufferRow(5));\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "maintains the indent of the commented line",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when a newline is added",
                "when the line preceding the newline is a comment"
            ],
            "updatePoint": {
                "line": 5134,
                "column": 56
            },
            "line": 5134,
            "code": "          it('maintains the indent of the commented line', () => {\n            editor.setCursorBufferPosition([0, 0]);\n            editor.insertText('    //');\n            editor.setCursorBufferPosition([0, Infinity]);\n            editor.insertText('\\n');\n            expect(editor.indentationForBufferRow(1)).toBe(2);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "bases the new line's indentation on only the preceding line",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when a newline is added",
                "when the line preceding the newline contains only whitespace"
            ],
            "updatePoint": {
                "line": 5143,
                "column": 73
            },
            "line": 5143,
            "code": "          it(\"bases the new line's indentation on only the preceding line\", () => {\n            editor.setCursorBufferPosition([6, Infinity]);\n            editor.insertText('\\n  ');\n            expect(editor.getCursorBufferPosition()).toEqual([7, 2]);\n            editor.insertNewline();\n            expect(editor.lineTextForBufferRow(8)).toBe('  ');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not indent the line preceding the newline",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when a newline is added",
                "when the line preceding the newline contains only whitespace"
            ],
            "updatePoint": {
                "line": 5151,
                "column": 58
            },
            "line": 5151,
            "code": "        it('does not indent the line preceding the newline', () => {\n          editor.setCursorBufferPosition([2, 0]);\n          editor.insertText('  var this-line-should-be-indented-more\\n');\n          expect(editor.indentationForBufferRow(1)).toBe(1);\n          editor.update({\n            autoIndent: true\n          });\n          editor.setCursorBufferPosition([2, Infinity]);\n          editor.insertText('\\n');\n          expect(editor.indentationForBufferRow(1)).toBe(1);\n          expect(editor.indentationForBufferRow(2)).toBe(1);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "retains the whitespace following the cursor on the new line",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when a newline is added",
                "when the cursor is before whitespace"
            ],
            "updatePoint": {
                "line": 5164,
                "column": 73
            },
            "line": 5164,
            "code": "          it('retains the whitespace following the cursor on the new line', () => {\n            editor.setText('  var sort = function() {}');\n            editor.setCursorScreenPosition([0, 12]);\n            editor.insertNewline();\n            expect(buffer.lineForRow(0)).toBe('  var sort =');\n            expect(buffer.lineForRow(1)).toBe('   function() {}');\n            expect(editor.getCursorScreenPosition()).toEqual([1, 2]);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "decreases the indentation to match that of the preceding line",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when inserted text matches a decrease indent pattern",
                "when the preceding line matches an increase indent pattern"
            ],
            "updatePoint": {
                "line": 5176,
                "column": 75
            },
            "line": 5176,
            "code": "          it('decreases the indentation to match that of the preceding line', () => {\n            editor.setCursorBufferPosition([1, Infinity]);\n            editor.insertText('\\n');\n            expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);\n            editor.insertText('}');\n            expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1));\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "decreases the indentation to be one level below that of the preceding line",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when inserted text matches a decrease indent pattern",
                "when the preceding line doesn't match an increase indent pattern"
            ],
            "updatePoint": {
                "line": 5185,
                "column": 88
            },
            "line": 5185,
            "code": "          it('decreases the indentation to be one level below that of the preceding line', () => {\n            editor.setCursorBufferPosition([3, Infinity]);\n            editor.insertText('\\n    ');\n            expect(editor.indentationForBufferRow(4)).toBe(editor.indentationForBufferRow(3));\n            editor.insertText('}');\n            expect(editor.indentationForBufferRow(4)).toBe(editor.indentationForBufferRow(3) - 1);\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't break when decreasing the indentation on a row that has no indentation",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when inserted text matches a decrease indent pattern",
                "when the preceding line doesn't match an increase indent pattern"
            ],
            "updatePoint": {
                "line": 5192,
                "column": 92
            },
            "line": 5192,
            "code": "          it(\"doesn't break when decreasing the indentation on a row that has no indentation\", () => {\n            editor.setCursorBufferPosition([12, Infinity]);\n            editor.insertText('\\n}; # too many closing brackets!');\n            expect(editor.lineTextForBufferRow(13)).toBe('}; # too many closing brackets!');\n          });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not decrease the indentation",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when inserted text does not match a decrease indent pattern"
            ],
            "updatePoint": {
                "line": 5200,
                "column": 45
            },
            "line": 5200,
            "code": "        it('does not decrease the indentation', () => {\n          editor.setCursorBufferPosition([12, 0]);\n          editor.insertText('  ');\n          expect(editor.lineTextForBufferRow(12)).toBe('  };');\n          editor.insertText('\\t\\t');\n          expect(editor.lineTextForBufferRow(12)).toBe('  \\t\\t};');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "leaves the line unchanged",
            "suites": [
                "TextEditor",
                "editor.autoIndent",
                "when editor.autoIndent is true",
                "when the current line does not match a decrease indent pattern"
            ],
            "updatePoint": {
                "line": 5209,
                "column": 37
            },
            "line": 5209,
            "code": "        it('leaves the line unchanged', () => {\n          editor.setCursorBufferPosition([2, 4]);\n          expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);\n          editor.insertText('foo');\n          expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "skips tab-length runs of leading whitespace when moving the cursor",
            "suites": [
                "TextEditor",
                "atomic soft tabs"
            ],
            "updatePoint": {
                "line": 5219,
                "column": 74
            },
            "line": 5219,
            "code": "    it('skips tab-length runs of leading whitespace when moving the cursor', () => {\n      editor.update({\n        tabLength: 4,\n        atomicSoftTabs: true\n      });\n      editor.setCursorScreenPosition([2, 3]);\n      expect(editor.getCursorScreenPosition()).toEqual([2, 4]);\n      editor.update({\n        atomicSoftTabs: false\n      });\n      editor.setCursorScreenPosition([2, 3]);\n      expect(editor.getCursorScreenPosition()).toEqual([2, 3]);\n      editor.update({\n        atomicSoftTabs: true\n      });\n      editor.setCursorScreenPosition([2, 3]);\n      expect(editor.getCursorScreenPosition()).toEqual([2, 4]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "destroys marker layers associated with the text editor",
            "suites": [
                "TextEditor",
                ".destroy()"
            ],
            "updatePoint": {
                "line": 5239,
                "column": 62
            },
            "line": 5239,
            "code": "    it('destroys marker layers associated with the text editor', () => {\n      buffer.retain();\n      const selectionsMarkerLayerId = editor.selectionsMarkerLayer.id;\n      const foldsMarkerLayerId = editor.displayLayer.foldsMarkerLayer.id;\n      editor.destroy();\n      expect(buffer.getMarkerLayer(selectionsMarkerLayerId)).toBeUndefined();\n      expect(buffer.getMarkerLayer(foldsMarkerLayerId)).toBeUndefined();\n      buffer.release();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies ::onDidDestroy observers when the editor is destroyed",
            "suites": [
                "TextEditor",
                ".destroy()"
            ],
            "updatePoint": {
                "line": 5248,
                "column": 70
            },
            "line": 5248,
            "code": "    it('notifies ::onDidDestroy observers when the editor is destroyed', () => {\n      let destroyObserverCalled = false;\n      editor.onDidDestroy(() => destroyObserverCalled = true);\n      editor.destroy();\n      expect(destroyObserverCalled).toBe(true);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not blow up when query methods are called afterward",
            "suites": [
                "TextEditor",
                ".destroy()"
            ],
            "updatePoint": {
                "line": 5254,
                "column": 64
            },
            "line": 5254,
            "code": "    it('does not blow up when query methods are called afterward', () => {\n      editor.destroy();\n      editor.getGrammar();\n      editor.getLastCursor();\n      editor.lineTextForBufferRow(0);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits the destroy event after destroying the editor's buffer",
            "suites": [
                "TextEditor",
                ".destroy()"
            ],
            "updatePoint": {
                "line": 5260,
                "column": 68
            },
            "line": 5260,
            "code": "    it(\"emits the destroy event after destroying the editor's buffer\", () => {\n      const events = [];\n      editor.getBuffer().onDidDestroy(() => {\n        expect(editor.isDestroyed()).toBe(true);\n        events.push('buffer-destroyed');\n      });\n      editor.onDidDestroy(() => {\n        expect(buffer.isDestroyed()).toBe(true);\n        events.push('editor-destroyed');\n      });\n      editor.destroy();\n      expect(events).toEqual(['buffer-destroyed', 'editor-destroyed']);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "joins the line below with the current line separated by a space and moves the cursor to the start of line that was moved up",
            "suites": [
                "TextEditor",
                ".joinLines()",
                "when no text is selected",
                "when the line below isn't empty"
            ],
            "updatePoint": {
                "line": 5277,
                "column": 135
            },
            "line": 5277,
            "code": "        it('joins the line below with the current line separated by a space and moves the cursor to the start of line that was moved up', () => {\n          editor.setCursorBufferPosition([0, Infinity]);\n          editor.insertText('  ');\n          editor.setCursorBufferPosition([0]);\n          editor.joinLines();\n          expect(editor.lineTextForBufferRow(0)).toBe('var quicksort = function () { var sort = function(items) {');\n          expect(editor.getCursorBufferPosition()).toEqual([0, 29]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deletes the line below and moves the cursor to the end of the line",
            "suites": [
                "TextEditor",
                ".joinLines()",
                "when no text is selected",
                "when the line below is empty"
            ],
            "updatePoint": {
                "line": 5287,
                "column": 78
            },
            "line": 5287,
            "code": "        it('deletes the line below and moves the cursor to the end of the line', () => {\n          editor.setCursorBufferPosition([9]);\n          editor.joinLines();\n          expect(editor.lineTextForBufferRow(9)).toBe('  };');\n          expect(editor.lineTextForBufferRow(10)).toBe('  return sort(Array.apply(this, arguments));');\n          expect(editor.getCursorBufferPosition()).toEqual([9, 4]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing",
            "suites": [
                "TextEditor",
                ".joinLines()",
                "when no text is selected",
                "when the cursor is on the last row"
            ],
            "updatePoint": {
                "line": 5296,
                "column": 24
            },
            "line": 5296,
            "code": "        it('does nothing', () => {\n          editor.setCursorBufferPosition([Infinity, Infinity]);\n          editor.joinLines();\n          expect(editor.lineTextForBufferRow(12)).toBe('};');\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "joins the line below with the current line with no added space",
            "suites": [
                "TextEditor",
                ".joinLines()",
                "when no text is selected",
                "when the line is empty"
            ],
            "updatePoint": {
                "line": 5303,
                "column": 74
            },
            "line": 5303,
            "code": "        it('joins the line below with the current line with no added space', () => {\n          editor.setCursorBufferPosition([10]);\n          editor.joinLines();\n          expect(editor.lineTextForBufferRow(10)).toBe('return sort(Array.apply(this, arguments));');\n          expect(editor.getCursorBufferPosition()).toEqual([10, 0]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "joins the line below with the current line separated by a space and retains the selected text",
            "suites": [
                "TextEditor",
                ".joinLines()",
                "when text is selected",
                "when the selection does not span multiple lines"
            ],
            "updatePoint": {
                "line": 5313,
                "column": 105
            },
            "line": 5313,
            "code": "        it('joins the line below with the current line separated by a space and retains the selected text', () => {\n          editor.setSelectedBufferRange([[0, 1], [0, 3]]);\n          editor.joinLines();\n          expect(editor.lineTextForBufferRow(0)).toBe('var quicksort = function () { var sort = function(items) {');\n          expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 3]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "joins all selected lines separated by a space and retains the selected text",
            "suites": [
                "TextEditor",
                ".joinLines()",
                "when text is selected",
                "when the selection spans multiple lines"
            ],
            "updatePoint": {
                "line": 5321,
                "column": 87
            },
            "line": 5321,
            "code": "        it('joins all selected lines separated by a space and retains the selected text', () => {\n          editor.setSelectedBufferRange([[9, 3], [12, 1]]);\n          editor.joinLines();\n          expect(editor.lineTextForBufferRow(9)).toBe('  }; return sort(Array.apply(this, arguments)); };');\n          expect(editor.getSelectedBufferRange()).toEqual([[9, 3], [9, 49]]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "for each selection, duplicates all buffer lines intersected by the selection",
            "suites": [
                "TextEditor",
                ".duplicateLines()"
            ],
            "updatePoint": {
                "line": 5331,
                "column": 84
            },
            "line": 5331,
            "code": "    it('for each selection, duplicates all buffer lines intersected by the selection', () => {\n      editor.foldBufferRow(4);\n      editor.setCursorBufferPosition([2, 5]);\n      editor.addSelectionForBufferRange([[3, 0], [8, 0]], {\n        preserveFolds: true\n      });\n      editor.duplicateLines();\n      expect(editor.getTextInBufferRange([[2, 0], [13, 5]])).toBe(dedent`\n        if (items.length <= 1) return items;\n        if (items.length <= 1) return items;\n        var pivot = items.shift(), current, left = [], right = [];\n        while(items.length > 0) {\n          current = items.shift();\n          current < pivot ? left.push(current) : right.push(current);\n        }\n        var pivot = items.shift(), current, left = [], right = [];\n        while(items.length > 0) {\n          current = items.shift();\n          current < pivot ? left.push(current) : right.push(current);\n        }\\\n      `.split('\\n').map(l => `    ${l}`).join('\\n'));\n      expect(editor.getSelectedBufferRanges()).toEqual([[[3, 5], [3, 5]], [[9, 0], [14, 0]]]); // folds are also duplicated\n\n      expect(editor.isFoldedAtScreenRow(5)).toBe(true);\n      expect(editor.isFoldedAtScreenRow(7)).toBe(true);\n      expect(editor.lineTextForScreenRow(7)).toBe(`    while(items.length > 0) {${editor.displayLayer.foldCharacter}}`);\n      expect(editor.lineTextForScreenRow(8)).toBe('    return sort(left).concat(pivot).concat(sort(right));');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "duplicates all folded lines for empty selections on lines containing folds",
            "suites": [
                "TextEditor",
                ".duplicateLines()"
            ],
            "updatePoint": {
                "line": 5359,
                "column": 82
            },
            "line": 5359,
            "code": "    it('duplicates all folded lines for empty selections on lines containing folds', () => {\n      editor.foldBufferRow(4);\n      editor.setCursorBufferPosition([4, 0]);\n      editor.duplicateLines();\n      expect(editor.getTextInBufferRange([[2, 0], [11, 5]])).toBe(dedent`\n        if (items.length <= 1) return items;\n        var pivot = items.shift(), current, left = [], right = [];\n        while(items.length > 0) {\n          current = items.shift();\n          current < pivot ? left.push(current) : right.push(current);\n        }\n        while(items.length > 0) {\n          current = items.shift();\n          current < pivot ? left.push(current) : right.push(current);\n        }\n      `.split('\\n').map(l => `    ${l}`).join('\\n'));\n      expect(editor.getSelectedBufferRange()).toEqual([[8, 0], [8, 0]]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can duplicate the last line of the buffer",
            "suites": [
                "TextEditor",
                ".duplicateLines()"
            ],
            "updatePoint": {
                "line": 5377,
                "column": 49
            },
            "line": 5377,
            "code": "    it('can duplicate the last line of the buffer', () => {\n      editor.setSelectedBufferRange([[11, 0], [12, 2]]);\n      editor.duplicateLines();\n      expect(editor.getTextInBufferRange([[11, 0], [14, 2]])).toBe('  ' + dedent`\n          return sort(Array.apply(this, arguments));\n        };\n          return sort(Array.apply(this, arguments));\n        };\n      `.trim());\n      expect(editor.getSelectedBufferRange()).toEqual([[13, 0], [14, 2]]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only duplicates lines containing multiple selections once",
            "suites": [
                "TextEditor",
                ".duplicateLines()"
            ],
            "updatePoint": {
                "line": 5388,
                "column": 65
            },
            "line": 5388,
            "code": "    it('only duplicates lines containing multiple selections once', () => {\n      editor.setText(dedent`\n        aaaaaa\n        bbbbbb\n        cccccc\n        dddddd\n      `);\n      editor.setSelectedBufferRanges([[[0, 1], [0, 2]], [[0, 3], [0, 4]], [[2, 1], [2, 2]], [[2, 3], [3, 1]], [[3, 3], [3, 4]]]);\n      editor.duplicateLines();\n      expect(editor.getText()).toBe(dedent`\n        aaaaaa\n        aaaaaa\n        bbbbbb\n        cccccc\n        dddddd\n        cccccc\n        dddddd\n      `);\n      expect(editor.getSelectedBufferRanges()).toEqual([[[1, 1], [1, 2]], [[1, 3], [1, 4]], [[5, 1], [5, 2]], [[5, 3], [6, 1]], [[6, 3], [6, 4]]]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly backspaces over them",
            "suites": [
                "TextEditor",
                "when the editor contains surrogate pair characters"
            ],
            "updatePoint": {
                "line": 5410,
                "column": 38
            },
            "line": 5410,
            "code": "    it('correctly backspaces over them', () => {\n      editor.setText('\\uD835\\uDF97\\uD835\\uDF97\\uD835\\uDF97');\n      editor.moveToBottom();\n      editor.backspace();\n      expect(editor.getText()).toBe('\\uD835\\uDF97\\uD835\\uDF97');\n      editor.backspace();\n      expect(editor.getText()).toBe('\\uD835\\uDF97');\n      editor.backspace();\n      expect(editor.getText()).toBe('');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly deletes over them",
            "suites": [
                "TextEditor",
                "when the editor contains surrogate pair characters"
            ],
            "updatePoint": {
                "line": 5420,
                "column": 35
            },
            "line": 5420,
            "code": "    it('correctly deletes over them', () => {\n      editor.setText('\\uD835\\uDF97\\uD835\\uDF97\\uD835\\uDF97');\n      editor.moveToTop();\n      editor.delete();\n      expect(editor.getText()).toBe('\\uD835\\uDF97\\uD835\\uDF97');\n      editor.delete();\n      expect(editor.getText()).toBe('\\uD835\\uDF97');\n      editor.delete();\n      expect(editor.getText()).toBe('');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly moves over them",
            "suites": [
                "TextEditor",
                "when the editor contains surrogate pair characters"
            ],
            "updatePoint": {
                "line": 5430,
                "column": 33
            },
            "line": 5430,
            "code": "    it('correctly moves over them', () => {\n      editor.setText('\\uD835\\uDF97\\uD835\\uDF97\\uD835\\uDF97\\n');\n      editor.moveToTop();\n      editor.moveRight();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 2]);\n      editor.moveRight();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n      editor.moveRight();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 6]);\n      editor.moveRight();\n      expect(editor.getCursorBufferPosition()).toEqual([1, 0]);\n      editor.moveLeft();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 6]);\n      editor.moveLeft();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n      editor.moveLeft();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 2]);\n      editor.moveLeft();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly backspaces over them",
            "suites": [
                "TextEditor",
                "when the editor contains variation sequence character pairs"
            ],
            "updatePoint": {
                "line": 5452,
                "column": 38
            },
            "line": 5452,
            "code": "    it('correctly backspaces over them', () => {\n      editor.setText('\\u2714\\uFE0E\\u2714\\uFE0E\\u2714\\uFE0E');\n      editor.moveToBottom();\n      editor.backspace();\n      expect(editor.getText()).toBe('\\u2714\\uFE0E\\u2714\\uFE0E');\n      editor.backspace();\n      expect(editor.getText()).toBe('\\u2714\\uFE0E');\n      editor.backspace();\n      expect(editor.getText()).toBe('');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly deletes over them",
            "suites": [
                "TextEditor",
                "when the editor contains variation sequence character pairs"
            ],
            "updatePoint": {
                "line": 5462,
                "column": 35
            },
            "line": 5462,
            "code": "    it('correctly deletes over them', () => {\n      editor.setText('\\u2714\\uFE0E\\u2714\\uFE0E\\u2714\\uFE0E');\n      editor.moveToTop();\n      editor.delete();\n      expect(editor.getText()).toBe('\\u2714\\uFE0E\\u2714\\uFE0E');\n      editor.delete();\n      expect(editor.getText()).toBe('\\u2714\\uFE0E');\n      editor.delete();\n      expect(editor.getText()).toBe('');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly moves over them",
            "suites": [
                "TextEditor",
                "when the editor contains variation sequence character pairs"
            ],
            "updatePoint": {
                "line": 5472,
                "column": 33
            },
            "line": 5472,
            "code": "    it('correctly moves over them', () => {\n      editor.setText('\\u2714\\uFE0E\\u2714\\uFE0E\\u2714\\uFE0E\\n');\n      editor.moveToTop();\n      editor.moveRight();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 2]);\n      editor.moveRight();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n      editor.moveRight();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 6]);\n      editor.moveRight();\n      expect(editor.getCursorBufferPosition()).toEqual([1, 0]);\n      editor.moveLeft();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 6]);\n      editor.moveLeft();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 4]);\n      editor.moveLeft();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 2]);\n      editor.moveLeft();\n      expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only replaces whitespace characters",
            "suites": [
                "TextEditor",
                ".setIndentationForBufferRow",
                "when the editor uses soft tabs but the row has hard tabs"
            ],
            "updatePoint": {
                "line": 5495,
                "column": 45
            },
            "line": 5495,
            "code": "      it('only replaces whitespace characters', () => {\n        editor.setSoftWrapped(true);\n        editor.setText('\\t1\\n\\t2');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.setIndentationForBufferRow(0, 2);\n        expect(editor.getText()).toBe('    1\\n\\t2');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw an exception",
            "suites": [
                "TextEditor",
                ".setIndentationForBufferRow",
                "when the indentation level is a non-integer"
            ],
            "updatePoint": {
                "line": 5504,
                "column": 37
            },
            "line": 5504,
            "code": "      it('does not throw an exception', () => {\n        editor.setSoftWrapped(true);\n        editor.setText('\\t1\\n\\t2');\n        editor.setCursorBufferPosition([0, 0]);\n        editor.setIndentationForBufferRow(0, 2.1);\n        expect(editor.getText()).toBe('    1\\n\\t2');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes the grammar's patterns when the selector matches the current scope in other grammars",
            "suites": [
                "TextEditor",
                "when the editor's grammar has an injection selector"
            ],
            "updatePoint": {
                "line": 5519,
                "column": 101
            },
            "line": 5519,
            "code": "    it(\"includes the grammar's patterns when the selector matches the current scope in other grammars\", async () => {\n      await atom.packages.activatePackage('language-hyperlink');\n      const grammar = atom.grammars.selectGrammar('text.js');\n      const {\n        line,\n        tags\n      } = grammar.tokenizeLine('var i; // http://github.com');\n      const tokens = atom.grammars.decodeTokens(line, tags);\n      expect(tokens[0].value).toBe('var');\n      expect(tokens[0].scopes).toEqual(['source.js', 'storage.type.var.js']);\n      expect(tokens[6].value).toBe('http://github.com');\n      expect(tokens[6].scopes).toEqual(['source.js', 'comment.line.double-slash.js', 'markup.underline.link.http.hyperlink']);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "retokenizes existing buffers that contain tokens that match the injection selector",
            "suites": [
                "TextEditor",
                "when the editor's grammar has an injection selector",
                "when the grammar is added"
            ],
            "updatePoint": {
                "line": 5533,
                "column": 92
            },
            "line": 5533,
            "code": "      it('retokenizes existing buffers that contain tokens that match the injection selector', async () => {\n        editor = await atom.workspace.open('sample.js');\n        editor.setText('// http://github.com');\n        let tokens = editor.tokensForScreenRow(0);\n        expect(tokens).toEqual([{\n          text: '//',\n          scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js', 'syntax--punctuation syntax--definition syntax--comment syntax--js']\n        }, {\n          text: ' http://github.com',\n          scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js']\n        }]);\n        await atom.packages.activatePackage('language-hyperlink');\n        tokens = editor.tokensForScreenRow(0);\n        expect(tokens).toEqual([{\n          text: '//',\n          scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js', 'syntax--punctuation syntax--definition syntax--comment syntax--js']\n        }, {\n          text: ' ',\n          scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js']\n        }, {\n          text: 'http://github.com',\n          scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js', 'syntax--markup syntax--underline syntax--link syntax--http syntax--hyperlink']\n        }]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "retokenizes existing buffers that contain tokens that match the injection selector",
            "suites": [
                "TextEditor",
                "when the editor's grammar has an injection selector",
                "when the grammar is added",
                "when the grammar is updated"
            ],
            "updatePoint": {
                "line": 5558,
                "column": 94
            },
            "line": 5558,
            "code": "        it('retokenizes existing buffers that contain tokens that match the injection selector', async () => {\n          editor = await atom.workspace.open('sample.js');\n          editor.setText('// SELECT * FROM OCTOCATS');\n          let tokens = editor.tokensForScreenRow(0);\n          expect(tokens).toEqual([{\n            text: '//',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js', 'syntax--punctuation syntax--definition syntax--comment syntax--js']\n          }, {\n            text: ' SELECT * FROM OCTOCATS',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js']\n          }]);\n          await atom.packages.activatePackage('package-with-injection-selector');\n          tokens = editor.tokensForScreenRow(0);\n          expect(tokens).toEqual([{\n            text: '//',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js', 'syntax--punctuation syntax--definition syntax--comment syntax--js']\n          }, {\n            text: ' SELECT * FROM OCTOCATS',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js']\n          }]);\n          await atom.packages.activatePackage('language-sql');\n          tokens = editor.tokensForScreenRow(0);\n          expect(tokens).toEqual([{\n            text: '//',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js', 'syntax--punctuation syntax--definition syntax--comment syntax--js']\n          }, {\n            text: ' ',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js']\n          }, {\n            text: 'SELECT',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js', 'syntax--keyword syntax--other syntax--DML syntax--sql']\n          }, {\n            text: ' ',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js']\n          }, {\n            text: '*',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js', 'syntax--keyword syntax--operator syntax--star syntax--sql']\n          }, {\n            text: ' ',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js']\n          }, {\n            text: 'FROM',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js', 'syntax--keyword syntax--other syntax--DML syntax--sql']\n          }, {\n            text: ' OCTOCATS',\n            scopes: ['syntax--source syntax--js', 'syntax--comment syntax--line syntax--double-slash syntax--js']\n          }]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "normalizes tabs depending on the editor's soft tab/tab length settings",
            "suites": [
                "TextEditor",
                ".normalizeTabsInBufferRange()"
            ],
            "updatePoint": {
                "line": 5610,
                "column": 78
            },
            "line": 5610,
            "code": "    it(\"normalizes tabs depending on the editor's soft tab/tab length settings\", () => {\n      editor.setTabLength(1);\n      editor.setSoftTabs(true);\n      editor.setText('\\t\\t\\t');\n      editor.normalizeTabsInBufferRange([[0, 0], [0, 1]]);\n      expect(editor.getText()).toBe(' \\t\\t');\n      editor.setTabLength(2);\n      editor.normalizeTabsInBufferRange([[0, 0], [Infinity, Infinity]]);\n      expect(editor.getText()).toBe('     ');\n      editor.setSoftTabs(false);\n      editor.normalizeTabsInBufferRange([[0, 0], [Infinity, Infinity]]);\n      expect(editor.getText()).toBe('     ');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor down one page length",
            "suites": [
                "TextEditor",
                ".pageUp/Down()"
            ],
            "updatePoint": {
                "line": 5625,
                "column": 45
            },
            "line": 5625,
            "code": "    it('moves the cursor down one page length', () => {\n      editor.update({\n        autoHeight: false\n      });\n      const element = editor.getElement();\n      jasmine.attachToDOM(element);\n      element.style.height = element.component.getLineHeight() * 5 + 'px';\n      element.measureDimensions();\n      expect(editor.getCursorBufferPosition().row).toBe(0);\n      editor.pageDown();\n      expect(editor.getCursorBufferPosition().row).toBe(5);\n      editor.pageDown();\n      expect(editor.getCursorBufferPosition().row).toBe(10);\n      editor.pageUp();\n      expect(editor.getCursorBufferPosition().row).toBe(5);\n      editor.pageUp();\n      expect(editor.getCursorBufferPosition().row).toBe(0);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "selects one screen height of text up or down",
            "suites": [
                "TextEditor",
                ".selectPageUp/Down()"
            ],
            "updatePoint": {
                "line": 5645,
                "column": 52
            },
            "line": 5645,
            "code": "    it('selects one screen height of text up or down', () => {\n      editor.update({\n        autoHeight: false\n      });\n      const element = editor.getElement();\n      jasmine.attachToDOM(element);\n      element.style.height = element.component.getLineHeight() * 5 + 'px';\n      element.measureDimensions();\n      expect(editor.getCursorBufferPosition().row).toBe(0);\n      editor.selectPageDown();\n      expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [5, 0]]]);\n      editor.selectPageDown();\n      expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [10, 0]]]);\n      editor.selectPageDown();\n      expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [12, 2]]]);\n      editor.moveToBottom();\n      editor.selectPageUp();\n      expect(editor.getSelectedBufferRanges()).toEqual([[[7, 0], [12, 2]]]);\n      editor.selectPageUp();\n      expect(editor.getSelectedBufferRanges()).toEqual([[[2, 0], [12, 2]]]);\n      editor.selectPageUp();\n      expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [12, 2]]]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "triggers ::onDidRequestAutoscroll with the logical coordinates along with the options",
            "suites": [
                "TextEditor",
                "::scrollToScreenPosition(position, [options])"
            ],
            "updatePoint": {
                "line": 5670,
                "column": 93
            },
            "line": 5670,
            "code": "    it('triggers ::onDidRequestAutoscroll with the logical coordinates along with the options', () => {\n      const scrollSpy = jasmine.createSpy('::onDidRequestAutoscroll');\n      editor.onDidRequestAutoscroll(scrollSpy);\n      editor.scrollToScreenPosition([8, 20]);\n      editor.scrollToScreenPosition([8, 20], {\n        center: true\n      });\n      editor.scrollToScreenPosition([8, 20], {\n        center: false,\n        reversed: true\n      });\n      expect(scrollSpy).toHaveBeenCalledWith({\n        screenRange: [[8, 20], [8, 20]],\n        options: {}\n      });\n      expect(scrollSpy).toHaveBeenCalledWith({\n        screenRange: [[8, 20], [8, 20]],\n        options: {\n          center: true\n        }\n      });\n      expect(scrollSpy).toHaveBeenCalledWith({\n        screenRange: [[8, 20], [8, 20]],\n        options: {\n          center: false,\n          reversed: true\n        }\n      });\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false by default but can be customized",
            "suites": [
                "TextEditor",
                "scroll past end"
            ],
            "updatePoint": {
                "line": 5701,
                "column": 54
            },
            "line": 5701,
            "code": "    it('returns false by default but can be customized', () => {\n      expect(editor.getScrollPastEnd()).toBe(false);\n      editor.update({\n        scrollPastEnd: true\n      });\n      expect(editor.getScrollPastEnd()).toBe(true);\n      editor.update({\n        scrollPastEnd: false\n      });\n      expect(editor.getScrollPastEnd()).toBe(false);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "always returns false when autoHeight is on",
            "suites": [
                "TextEditor",
                "scroll past end"
            ],
            "updatePoint": {
                "line": 5712,
                "column": 50
            },
            "line": 5712,
            "code": "    it('always returns false when autoHeight is on', () => {\n      editor.update({\n        autoHeight: true,\n        scrollPastEnd: true\n      });\n      expect(editor.getScrollPastEnd()).toBe(false);\n      editor.update({\n        autoHeight: false\n      });\n      expect(editor.getScrollPastEnd()).toBe(true);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true by default but can be customized",
            "suites": [
                "TextEditor",
                "auto height"
            ],
            "updatePoint": {
                "line": 5725,
                "column": 53
            },
            "line": 5725,
            "code": "    it('returns true by default but can be customized', () => {\n      editor = new TextEditor();\n      expect(editor.getAutoHeight()).toBe(true);\n      editor.update({\n        autoHeight: false\n      });\n      expect(editor.getAutoHeight()).toBe(false);\n      editor.update({\n        autoHeight: true\n      });\n      expect(editor.getAutoHeight()).toBe(true);\n      editor.destroy();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false by default but can be customized",
            "suites": [
                "TextEditor",
                "auto width"
            ],
            "updatePoint": {
                "line": 5740,
                "column": 54
            },
            "line": 5740,
            "code": "    it('returns false by default but can be customized', () => {\n      expect(editor.getAutoWidth()).toBe(false);\n      editor.update({\n        autoWidth: true\n      });\n      expect(editor.getAutoWidth()).toBe(true);\n      editor.update({\n        autoWidth: false\n      });\n      expect(editor.getAutoWidth()).toBe(false);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can be created with placeholderText",
            "suites": [
                "TextEditor",
                ".get/setPlaceholderText()"
            ],
            "updatePoint": {
                "line": 5753,
                "column": 43
            },
            "line": 5753,
            "code": "    it('can be created with placeholderText', () => {\n      const newEditor = new TextEditor({\n        mini: true,\n        placeholderText: 'yep'\n      });\n      expect(newEditor.getPlaceholderText()).toBe('yep');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "models placeholderText and emits an event when changed",
            "suites": [
                "TextEditor",
                ".get/setPlaceholderText()"
            ],
            "updatePoint": {
                "line": 5760,
                "column": 62
            },
            "line": 5760,
            "code": "    it('models placeholderText and emits an event when changed', () => {\n      let handler;\n      editor.onDidChangePlaceholderText(handler = jasmine.createSpy());\n      expect(editor.getPlaceholderText()).toBeUndefined();\n      editor.setPlaceholderText('OK');\n      expect(handler).toHaveBeenCalledWith('OK');\n      expect(editor.getPlaceholderText()).toBe('OK');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a line-number gutter",
            "suites": [
                "TextEditor",
                "gutters",
                "the TextEditor constructor"
            ],
            "updatePoint": {
                "line": 5771,
                "column": 38
            },
            "line": 5771,
            "code": "      it('creates a line-number gutter', () => {\n        expect(editor.getGutters().length).toBe(1);\n        const lineNumberGutter = editor.gutterWithName('line-number');\n        expect(lineNumberGutter.name).toBe('line-number');\n        expect(lineNumberGutter.priority).toBe(0);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can add a gutter",
            "suites": [
                "TextEditor",
                "gutters",
                "::addGutter"
            ],
            "updatePoint": {
                "line": 5779,
                "column": 26
            },
            "line": 5779,
            "code": "      it('can add a gutter', () => {\n        expect(editor.getGutters().length).toBe(1); // line-number gutter\n\n        const options = {\n          name: 'test-gutter',\n          priority: 1\n        };\n        const gutter = editor.addGutter(options);\n        expect(editor.getGutters().length).toBe(2);\n        expect(editor.getGutters()[1]).toBe(gutter);\n        expect(gutter.type).toBe('decorated');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can add a custom line-number gutter",
            "suites": [
                "TextEditor",
                "gutters",
                "::addGutter"
            ],
            "updatePoint": {
                "line": 5791,
                "column": 45
            },
            "line": 5791,
            "code": "      it('can add a custom line-number gutter', () => {\n        expect(editor.getGutters().length).toBe(1);\n        const options = {\n          name: 'another-gutter',\n          priority: 2,\n          type: 'line-number'\n        };\n        const gutter = editor.addGutter(options);\n        expect(editor.getGutters().length).toBe(2);\n        expect(editor.getGutters()[1]).toBe(gutter);\n        expect(gutter.type).toBe('line-number');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not allow a custom gutter with the 'line-number' name.",
            "suites": [
                "TextEditor",
                "gutters",
                "::addGutter"
            ],
            "updatePoint": {
                "line": 5803,
                "column": 69
            },
            "line": 5803,
            "code": "      it(\"does not allow a custom gutter with the 'line-number' name.\", () => expect(editor.addGutter.bind(editor, {\n        name: 'line-number'\n      })).toThrow());",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reflects an added decoration when one of its custom gutters is decorated.",
            "suites": [
                "TextEditor",
                "gutters",
                "::decorateMarker"
            ],
            "updatePoint": {
                "line": 5810,
                "column": 83
            },
            "line": 5810,
            "code": "      it('reflects an added decoration when one of its custom gutters is decorated.', () => {\n        const gutter = editor.addGutter({\n          name: 'custom-gutter'\n        });\n        const decoration = gutter.decorateMarker(marker, {\n          class: 'custom-class'\n        });\n        const gutterDecorations = editor.getDecorations({\n          type: 'gutter',\n          gutterName: 'custom-gutter',\n          class: 'custom-class'\n        });\n        expect(gutterDecorations.length).toBe(1);\n        expect(gutterDecorations[0]).toBe(decoration);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reflects an added decoration when its line-number gutter is decorated.",
            "suites": [
                "TextEditor",
                "gutters",
                "::decorateMarker"
            ],
            "updatePoint": {
                "line": 5825,
                "column": 80
            },
            "line": 5825,
            "code": "      it('reflects an added decoration when its line-number gutter is decorated.', () => {\n        const decoration = editor.gutterWithName('line-number').decorateMarker(marker, {\n          class: 'test-class'\n        });\n        const gutterDecorations = editor.getDecorations({\n          type: 'line-number',\n          gutterName: 'line-number',\n          class: 'test-class'\n        });\n        expect(gutterDecorations.length).toBe(1);\n        expect(gutterDecorations[0]).toBe(decoration);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the callback immediately with each existing gutter, and with each added gutter after that.",
            "suites": [
                "TextEditor",
                "gutters",
                "::observeGutters"
            ],
            "updatePoint": {
                "line": 5845,
                "column": 106
            },
            "line": 5845,
            "code": "      it('calls the callback immediately with each existing gutter, and with each added gutter after that.', () => {\n        const lineNumberGutter = editor.gutterWithName('line-number');\n        editor.observeGutters(callback);\n        expect(payloads).toEqual([lineNumberGutter]);\n        const gutter1 = editor.addGutter({\n          name: 'test-gutter-1'\n        });\n        expect(payloads).toEqual([lineNumberGutter, gutter1]);\n        const gutter2 = editor.addGutter({\n          name: 'test-gutter-2'\n        });\n        expect(payloads).toEqual([lineNumberGutter, gutter1, gutter2]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not call the callback when a gutter is removed.",
            "suites": [
                "TextEditor",
                "gutters",
                "::observeGutters"
            ],
            "updatePoint": {
                "line": 5858,
                "column": 62
            },
            "line": 5858,
            "code": "      it('does not call the callback when a gutter is removed.', () => {\n        const gutter = editor.addGutter({\n          name: 'test-gutter'\n        });\n        editor.observeGutters(callback);\n        payloads = [];\n        gutter.destroy();\n        expect(payloads).toEqual([]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not call the callback after the subscription has been disposed.",
            "suites": [
                "TextEditor",
                "gutters",
                "::observeGutters"
            ],
            "updatePoint": {
                "line": 5867,
                "column": 78
            },
            "line": 5867,
            "code": "      it('does not call the callback after the subscription has been disposed.', () => {\n        const subscription = editor.observeGutters(callback);\n        payloads = [];\n        subscription.dispose();\n        editor.addGutter({\n          name: 'test-gutter'\n        });\n        expect(payloads).toEqual([]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the callback with each newly-added gutter, but not with existing gutters.",
            "suites": [
                "TextEditor",
                "gutters",
                "::onDidAddGutter"
            ],
            "updatePoint": {
                "line": 5884,
                "column": 89
            },
            "line": 5884,
            "code": "      it('calls the callback with each newly-added gutter, but not with existing gutters.', () => {\n        editor.onDidAddGutter(callback);\n        expect(payloads).toEqual([]);\n        const gutter = editor.addGutter({\n          name: 'test-gutter'\n        });\n        expect(payloads).toEqual([gutter]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not call the callback after the subscription has been disposed.",
            "suites": [
                "TextEditor",
                "gutters",
                "::onDidAddGutter"
            ],
            "updatePoint": {
                "line": 5892,
                "column": 78
            },
            "line": 5892,
            "code": "      it('does not call the callback after the subscription has been disposed.', () => {\n        const subscription = editor.onDidAddGutter(callback);\n        payloads = [];\n        subscription.dispose();\n        editor.addGutter({\n          name: 'test-gutter'\n        });\n        expect(payloads).toEqual([]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the callback when a gutter is removed.",
            "suites": [
                "TextEditor",
                "gutters",
                "::onDidRemoveGutter"
            ],
            "updatePoint": {
                "line": 5909,
                "column": 54
            },
            "line": 5909,
            "code": "      it('calls the callback when a gutter is removed.', () => {\n        const gutter = editor.addGutter({\n          name: 'test-gutter'\n        });\n        editor.onDidRemoveGutter(callback);\n        expect(payloads).toEqual([]);\n        gutter.destroy();\n        expect(payloads).toEqual(['test-gutter']);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not call the callback after the subscription has been disposed.",
            "suites": [
                "TextEditor",
                "gutters",
                "::onDidRemoveGutter"
            ],
            "updatePoint": {
                "line": 5918,
                "column": 78
            },
            "line": 5918,
            "code": "      it('does not call the callback after the subscription has been disposed.', () => {\n        const gutter = editor.addGutter({\n          name: 'test-gutter'\n        });\n        const subscription = editor.onDidRemoveGutter(callback);\n        subscription.dispose();\n        gutter.destroy();\n        expect(payloads).toEqual([]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes the decoration in the object returned from ::decorationsStateForScreenRowRange",
            "suites": [
                "TextEditor",
                "decorations",
                "::decorateMarker"
            ],
            "updatePoint": {
                "line": 5931,
                "column": 97
            },
            "line": 5931,
            "code": "      it('includes the decoration in the object returned from ::decorationsStateForScreenRowRange', () => {\n        const marker = editor.markBufferRange([[2, 4], [6, 8]]);\n        const decoration = editor.decorateMarker(marker, {\n          type: 'highlight',\n          class: 'foo'\n        });\n        expect(editor.decorationsStateForScreenRowRange(0, 5)[decoration.id]).toEqual({\n          properties: {\n            id: decoration.id,\n            order: Infinity,\n            type: 'highlight',\n            class: 'foo'\n          },\n          screenRange: marker.getScreenRange(),\n          bufferRange: marker.getBufferRange(),\n          rangeIsReversed: false\n        });\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not throw errors after the marker's containing layer is destroyed",
            "suites": [
                "TextEditor",
                "decorations",
                "::decorateMarker"
            ],
            "updatePoint": {
                "line": 5949,
                "column": 80
            },
            "line": 5949,
            "code": "      it(\"does not throw errors after the marker's containing layer is destroyed\", () => {\n        const layer = editor.addMarkerLayer();\n        layer.markBufferRange([[2, 4], [6, 8]]);\n        layer.destroy();\n        editor.decorationsStateForScreenRowRange(0, 5);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "based on the markers in the layer, includes multiple decoration objects with the same properties and different ranges in the object returned from ::decorationsStateForScreenRowRange",
            "suites": [
                "TextEditor",
                "decorations",
                "::decorateMarkerLayer"
            ],
            "updatePoint": {
                "line": 5957,
                "column": 191
            },
            "line": 5957,
            "code": "      it('based on the markers in the layer, includes multiple decoration objects with the same properties and different ranges in the object returned from ::decorationsStateForScreenRowRange', () => {\n        const layer1 = editor.getBuffer().addMarkerLayer();\n        const marker1 = layer1.markRange([[2, 4], [6, 8]]);\n        const marker2 = layer1.markRange([[11, 0], [11, 12]]);\n        const layer2 = editor.getBuffer().addMarkerLayer();\n        const marker3 = layer2.markRange([[8, 0], [9, 0]]);\n        const layer1Decoration1 = editor.decorateMarkerLayer(layer1, {\n          type: 'highlight',\n          class: 'foo'\n        });\n        const layer1Decoration2 = editor.decorateMarkerLayer(layer1, {\n          type: 'highlight',\n          class: 'bar'\n        });\n        const layer2Decoration = editor.decorateMarkerLayer(layer2, {\n          type: 'highlight',\n          class: 'baz'\n        });\n        let decorationState = editor.decorationsStateForScreenRowRange(0, 13);\n        expect(decorationState[`${layer1Decoration1.id}-${marker1.id}`]).toEqual({\n          properties: {\n            type: 'highlight',\n            class: 'foo'\n          },\n          screenRange: marker1.getRange(),\n          bufferRange: marker1.getRange(),\n          rangeIsReversed: false\n        });\n        expect(decorationState[`${layer1Decoration1.id}-${marker2.id}`]).toEqual({\n          properties: {\n            type: 'highlight',\n            class: 'foo'\n          },\n          screenRange: marker2.getRange(),\n          bufferRange: marker2.getRange(),\n          rangeIsReversed: false\n        });\n        expect(decorationState[`${layer1Decoration2.id}-${marker1.id}`]).toEqual({\n          properties: {\n            type: 'highlight',\n            class: 'bar'\n          },\n          screenRange: marker1.getRange(),\n          bufferRange: marker1.getRange(),\n          rangeIsReversed: false\n        });\n        expect(decorationState[`${layer1Decoration2.id}-${marker2.id}`]).toEqual({\n          properties: {\n            type: 'highlight',\n            class: 'bar'\n          },\n          screenRange: marker2.getRange(),\n          bufferRange: marker2.getRange(),\n          rangeIsReversed: false\n        });\n        expect(decorationState[`${layer2Decoration.id}-${marker3.id}`]).toEqual({\n          properties: {\n            type: 'highlight',\n            class: 'baz'\n          },\n          screenRange: marker3.getRange(),\n          bufferRange: marker3.getRange(),\n          rangeIsReversed: false\n        });\n        layer1Decoration1.destroy();\n        decorationState = editor.decorationsStateForScreenRowRange(0, 12);\n        expect(decorationState[`${layer1Decoration1.id}-${marker1.id}`]).toBeUndefined();\n        expect(decorationState[`${layer1Decoration1.id}-${marker2.id}`]).toBeUndefined();\n        expect(decorationState[`${layer1Decoration2.id}-${marker1.id}`]).toEqual({\n          properties: {\n            type: 'highlight',\n            class: 'bar'\n          },\n          screenRange: marker1.getRange(),\n          bufferRange: marker1.getRange(),\n          rangeIsReversed: false\n        });\n        expect(decorationState[`${layer1Decoration2.id}-${marker2.id}`]).toEqual({\n          properties: {\n            type: 'highlight',\n            class: 'bar'\n          },\n          screenRange: marker2.getRange(),\n          bufferRange: marker2.getRange(),\n          rangeIsReversed: false\n        });\n        expect(decorationState[`${layer2Decoration.id}-${marker3.id}`]).toEqual({\n          properties: {\n            type: 'highlight',\n            class: 'baz'\n          },\n          screenRange: marker3.getRange(),\n          bufferRange: marker3.getRange(),\n          rangeIsReversed: false\n        });\n        layer1Decoration2.setPropertiesForMarker(marker1, {\n          type: 'highlight',\n          class: 'quux'\n        });\n        decorationState = editor.decorationsStateForScreenRowRange(0, 12);\n        expect(decorationState[`${layer1Decoration2.id}-${marker1.id}`]).toEqual({\n          properties: {\n            type: 'highlight',\n            class: 'quux'\n          },\n          screenRange: marker1.getRange(),\n          bufferRange: marker1.getRange(),\n          rangeIsReversed: false\n        });\n        layer1Decoration2.setPropertiesForMarker(marker1, null);\n        decorationState = editor.decorationsStateForScreenRowRange(0, 12);\n        expect(decorationState[`${layer1Decoration2.id}-${marker1.id}`]).toEqual({\n          properties: {\n            type: 'highlight',\n            class: 'bar'\n          },\n          screenRange: marker1.getRange(),\n          bufferRange: marker1.getRange(),\n          rangeIsReversed: false\n        });\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "substitutes invisible characters according to the given rules",
            "suites": [
                "TextEditor",
                "invisibles"
            ],
            "updatePoint": {
                "line": 6086,
                "column": 69
            },
            "line": 6086,
            "code": "    it('substitutes invisible characters according to the given rules', () => {\n      const previousLineText = editor.lineTextForScreenRow(0);\n      editor.update({\n        invisibles: {\n          eol: '?'\n        }\n      });\n      expect(editor.lineTextForScreenRow(0)).not.toBe(previousLineText);\n      expect(editor.lineTextForScreenRow(0).endsWith('?')).toBe(true);\n      expect(editor.getInvisibles()).toEqual({\n        eol: '?'\n      });\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not use invisibles if showInvisibles is set to false",
            "suites": [
                "TextEditor",
                "invisibles"
            ],
            "updatePoint": {
                "line": 6099,
                "column": 65
            },
            "line": 6099,
            "code": "    it('does not use invisibles if showInvisibles is set to false', () => {\n      editor.update({\n        invisibles: {\n          eol: '?'\n        }\n      });\n      expect(editor.lineTextForScreenRow(0).endsWith('?')).toBe(true);\n      editor.update({\n        showInvisibles: false\n      });\n      expect(editor.lineTextForScreenRow(0).endsWith('?')).toBe(false);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shows indent guides when `editor.showIndentGuide` is set to true and the editor is not mini",
            "suites": [
                "TextEditor",
                "indent guides"
            ],
            "updatePoint": {
                "line": 6113,
                "column": 99
            },
            "line": 6113,
            "code": "    it('shows indent guides when `editor.showIndentGuide` is set to true and the editor is not mini', () => {\n      editor.update({\n        showIndentGuide: false\n      });\n      expect(editor.tokensForScreenRow(1).slice(0, 3)).toEqual([{\n        text: '  ',\n        scopes: ['syntax--source syntax--js', 'leading-whitespace']\n      }, {\n        text: 'var',\n        scopes: ['syntax--source syntax--js', 'syntax--storage syntax--type']\n      }, {\n        text: ' sort ',\n        scopes: ['syntax--source syntax--js']\n      }]);\n      editor.update({\n        showIndentGuide: true\n      });\n      expect(editor.tokensForScreenRow(1).slice(0, 3)).toEqual([{\n        text: '  ',\n        scopes: ['syntax--source syntax--js', 'leading-whitespace indent-guide']\n      }, {\n        text: 'var',\n        scopes: ['syntax--source syntax--js', 'syntax--storage syntax--type']\n      }, {\n        text: ' sort ',\n        scopes: ['syntax--source syntax--js']\n      }]);\n      editor.setMini(true);\n      expect(editor.tokensForScreenRow(1).slice(0, 3)).toEqual([{\n        text: '  ',\n        scopes: ['syntax--source syntax--js', 'leading-whitespace']\n      }, {\n        text: 'var',\n        scopes: ['syntax--source syntax--js', 'syntax--storage syntax--type']\n      }, {\n        text: ' sort ',\n        scopes: ['syntax--source syntax--js']\n      }]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "soft wraps the editor at the preferred line length unless the editor is narrower or the editor is mini",
            "suites": [
                "TextEditor",
                "softWrapAtPreferredLineLength"
            ],
            "updatePoint": {
                "line": 6154,
                "column": 110
            },
            "line": 6154,
            "code": "    it('soft wraps the editor at the preferred line length unless the editor is narrower or the editor is mini', () => {\n      editor.update({\n        editorWidthInChars: 30,\n        softWrapped: true,\n        softWrapAtPreferredLineLength: true,\n        preferredLineLength: 20\n      });\n      expect(editor.lineTextForScreenRow(0)).toBe('var quicksort = ');\n      editor.update({\n        editorWidthInChars: 10\n      });\n      expect(editor.lineTextForScreenRow(0)).toBe('var ');\n      editor.update({\n        mini: true\n      });\n      expect(editor.lineTextForScreenRow(0)).toBe('var quicksort = function () {');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "controls how much extra indentation is applied to soft-wrapped lines",
            "suites": [
                "TextEditor",
                "softWrapHangingIndentLength"
            ],
            "updatePoint": {
                "line": 6173,
                "column": 76
            },
            "line": 6173,
            "code": "    it('controls how much extra indentation is applied to soft-wrapped lines', () => {\n      editor.setText('123456789');\n      editor.update({\n        editorWidthInChars: 8,\n        softWrapped: true,\n        softWrapHangingIndentLength: 2\n      });\n      expect(editor.lineTextForScreenRow(1)).toEqual('  9');\n      editor.update({\n        softWrapHangingIndentLength: 4\n      });\n      expect(editor.lineTextForScreenRow(1)).toEqual('    9');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns an element",
            "suites": [
                "TextEditor",
                "::getElement"
            ],
            "updatePoint": {
                "line": 6188,
                "column": 26
            },
            "line": 6188,
            "code": "    it('returns an element', () => expect(editor.getElement() instanceof HTMLElement).toBe(true));",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the maximum line length in the editor before soft wrapping is forced",
            "suites": [
                "TextEditor",
                "setMaxScreenLineLength"
            ],
            "updatePoint": {
                "line": 6191,
                "column": 81
            },
            "line": 6191,
            "code": "    it('sets the maximum line length in the editor before soft wrapping is forced', () => {\n      expect(editor.getSoftWrapColumn()).toBe(500);\n      editor.update({\n        maxScreenLineLength: 1500\n      });\n      expect(editor.getSoftWrapColumn()).toBe(1500);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a default scope descriptor when no language mode is assigned",
            "suites": [
                "TextEditor",
                ".scopeDescriptorForBufferPosition(position)"
            ],
            "updatePoint": {
                "line": 6206,
                "column": 76
            },
            "line": 6206,
            "code": "    it('returns a default scope descriptor when no language mode is assigned', () => {\n      editor = new TextEditor({\n        buffer: new TextBuffer()\n      });\n      const scopeDescriptor = editor.scopeDescriptorForBufferPosition([0, 0]);\n      expect(scopeDescriptor.getScopesArray()).toEqual(['text']);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the result of scopeDescriptorForBufferPosition() when textmate language mode is used",
            "suites": [
                "TextEditor",
                ".syntaxTreeScopeDescriptorForBufferPosition(position)"
            ],
            "updatePoint": {
                "line": 6215,
                "column": 100
            },
            "line": 6215,
            "code": "    it('returns the result of scopeDescriptorForBufferPosition() when textmate language mode is used', async () => {\n      atom.config.set('core.useTreeSitterParsers', false);\n      editor = await atom.workspace.open('sample.js', {\n        autoIndent: false\n      });\n      await atom.packages.activatePackage('language-javascript');\n      let buffer = editor.getBuffer();\n      let languageMode = new TextMateLanguageMode({\n        buffer,\n        grammar: atom.grammars.grammarForScopeName('source.js')\n      });\n      buffer.setLanguageMode(languageMode);\n      languageMode.startTokenizing();\n\n      while (languageMode.firstInvalidRow() != null) {\n        advanceClock();\n      }\n\n      const syntaxTreeeScopeDescriptor = editor.syntaxTreeScopeDescriptorForBufferPosition([4, 17]);\n      expect(syntaxTreeeScopeDescriptor.getScopesArray()).toEqual(['source.js', 'support.variable.property.js']);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the result of syntaxTreeScopeDescriptorForBufferPosition() when tree-sitter language mode is used",
            "suites": [
                "TextEditor",
                ".syntaxTreeScopeDescriptorForBufferPosition(position)"
            ],
            "updatePoint": {
                "line": 6236,
                "column": 113
            },
            "line": 6236,
            "code": "    it('returns the result of syntaxTreeScopeDescriptorForBufferPosition() when tree-sitter language mode is used', async () => {\n      editor = await atom.workspace.open('sample.js', {\n        autoIndent: false\n      });\n      await atom.packages.activatePackage('language-javascript');\n      let buffer = editor.getBuffer();\n      buffer.setLanguageMode(new TreeSitterLanguageMode({\n        buffer,\n        grammar: atom.grammars.grammarForScopeName('source.js')\n      }));\n      const syntaxTreeeScopeDescriptor = editor.syntaxTreeScopeDescriptorForBufferPosition([4, 17]);\n      expect(syntaxTreeeScopeDescriptor.getScopesArray()).toEqual(['source.js', 'program', 'variable_declaration', 'variable_declarator', 'function', 'statement_block', 'variable_declaration', 'variable_declarator', 'function', 'statement_block', 'while_statement', 'parenthesized_expression', 'binary_expression', 'member_expression', 'property_identifier']);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true when buffer has unsaved changes",
            "suites": [
                "TextEditor",
                ".shouldPromptToSave()"
            ],
            "updatePoint": {
                "line": 6256,
                "column": 52
            },
            "line": 6256,
            "code": "    it('returns true when buffer has unsaved changes', () => {\n      expect(editor.shouldPromptToSave()).toBeFalsy();\n      editor.setText('changed');\n      expect(editor.shouldPromptToSave()).toBeTruthy();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false when an editor's buffer is in use by more than one buffer",
            "suites": [
                "TextEditor",
                ".shouldPromptToSave()"
            ],
            "updatePoint": {
                "line": 6261,
                "column": 79
            },
            "line": 6261,
            "code": "    it(\"returns false when an editor's buffer is in use by more than one buffer\", async () => {\n      editor.setText('changed');\n      atom.workspace.getActivePane().splitRight();\n      const editor2 = await atom.workspace.open('sample.js', {\n        autoIndent: false\n      });\n      expect(editor.shouldPromptToSave()).toBeFalsy();\n      editor2.destroy();\n      expect(editor.shouldPromptToSave()).toBeTruthy();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true when the window is closing if the file has changed on disk",
            "suites": [
                "TextEditor",
                ".shouldPromptToSave()"
            ],
            "updatePoint": {
                "line": 6271,
                "column": 79
            },
            "line": 6271,
            "code": "    it('returns true when the window is closing if the file has changed on disk', async () => {\n      jasmine.useRealClock();\n      editor.setText('initial stuff');\n      await editor.saveAs(temp.openSync('test-file').path);\n      editor.setText('other stuff');\n      fs.writeFileSync(editor.getPath(), 'new stuff');\n      expect(editor.shouldPromptToSave({\n        windowCloseRequested: true,\n        projectHasPaths: true\n      })).toBeFalsy();\n      await new Promise(resolve => editor.onDidConflict(resolve));\n      expect(editor.shouldPromptToSave({\n        windowCloseRequested: true,\n        projectHasPaths: true\n      })).toBeTruthy();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false when the window is closing and the project has one or more directory paths",
            "suites": [
                "TextEditor",
                ".shouldPromptToSave()"
            ],
            "updatePoint": {
                "line": 6287,
                "column": 96
            },
            "line": 6287,
            "code": "    it('returns false when the window is closing and the project has one or more directory paths', () => {\n      editor.setText('changed');\n      expect(editor.shouldPromptToSave({\n        windowCloseRequested: true,\n        projectHasPaths: true\n      })).toBeFalsy();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false when the window is closing and the project has no directory paths",
            "suites": [
                "TextEditor",
                ".shouldPromptToSave()"
            ],
            "updatePoint": {
                "line": 6294,
                "column": 87
            },
            "line": 6294,
            "code": "    it('returns false when the window is closing and the project has no directory paths', () => {\n      editor.setText('changed');\n      expect(editor.shouldPromptToSave({\n        windowCloseRequested: true,\n        projectHasPaths: false\n      })).toBeTruthy();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "toggles comments on the selected lines",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsInSelection()"
            ],
            "updatePoint": {
                "line": 6307,
                "column": 46
            },
            "line": 6307,
            "code": "    it('toggles comments on the selected lines', () => {\n      editor.setSelectedBufferRange([[4, 5], [7, 5]]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(4)).toBe('    // while(items.length > 0) {');\n      expect(editor.lineTextForBufferRow(5)).toBe('    //   current = items.shift();');\n      expect(editor.lineTextForBufferRow(6)).toBe('    //   current < pivot ? left.push(current) : right.push(current);');\n      expect(editor.lineTextForBufferRow(7)).toBe('    // }');\n      expect(editor.getSelectedBufferRange()).toEqual([[4, 8], [7, 8]]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n      expect(editor.lineTextForBufferRow(5)).toBe('      current = items.shift();');\n      expect(editor.lineTextForBufferRow(6)).toBe('      current < pivot ? left.push(current) : right.push(current);');\n      expect(editor.lineTextForBufferRow(7)).toBe('    }');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not comment the last line of a non-empty selection if it ends at column 0",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsInSelection()"
            ],
            "updatePoint": {
                "line": 6321,
                "column": 86
            },
            "line": 6321,
            "code": "    it('does not comment the last line of a non-empty selection if it ends at column 0', () => {\n      editor.setSelectedBufferRange([[4, 5], [7, 0]]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(4)).toBe('    // while(items.length > 0) {');\n      expect(editor.lineTextForBufferRow(5)).toBe('    //   current = items.shift();');\n      expect(editor.lineTextForBufferRow(6)).toBe('    //   current < pivot ? left.push(current) : right.push(current);');\n      expect(editor.lineTextForBufferRow(7)).toBe('    }');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uncomments lines if all lines match the comment regex",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsInSelection()"
            ],
            "updatePoint": {
                "line": 6329,
                "column": 61
            },
            "line": 6329,
            "code": "    it('uncomments lines if all lines match the comment regex', () => {\n      editor.setSelectedBufferRange([[0, 0], [0, 1]]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(0)).toBe('// var quicksort = function () {');\n      editor.setSelectedBufferRange([[0, 0], [2, Infinity]]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(0)).toBe('// // var quicksort = function () {');\n      expect(editor.lineTextForBufferRow(1)).toBe('//   var sort = function(items) {');\n      expect(editor.lineTextForBufferRow(2)).toBe('//     if (items.length <= 1) return items;');\n      editor.setSelectedBufferRange([[0, 0], [2, Infinity]]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(0)).toBe('// var quicksort = function () {');\n      expect(editor.lineTextForBufferRow(1)).toBe('  var sort = function(items) {');\n      expect(editor.lineTextForBufferRow(2)).toBe('    if (items.length <= 1) return items;');\n      editor.setSelectedBufferRange([[0, 0], [0, Infinity]]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(0)).toBe('var quicksort = function () {');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uncomments commented lines separated by an empty line",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsInSelection()"
            ],
            "updatePoint": {
                "line": 6347,
                "column": 61
            },
            "line": 6347,
            "code": "    it('uncomments commented lines separated by an empty line', () => {\n      editor.setSelectedBufferRange([[0, 0], [1, Infinity]]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(0)).toBe('// var quicksort = function () {');\n      expect(editor.lineTextForBufferRow(1)).toBe('//   var sort = function(items) {');\n      editor.getBuffer().insert([0, Infinity], '\\n');\n      editor.setSelectedBufferRange([[0, 0], [2, Infinity]]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(0)).toBe('var quicksort = function () {');\n      expect(editor.lineTextForBufferRow(1)).toBe('');\n      expect(editor.lineTextForBufferRow(2)).toBe('  var sort = function(items) {');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "preserves selection emptiness",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsInSelection()"
            ],
            "updatePoint": {
                "line": 6359,
                "column": 37
            },
            "line": 6359,
            "code": "    it('preserves selection emptiness', () => {\n      editor.setCursorBufferPosition([4, 0]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.getLastSelection().isEmpty()).toBeTruthy();\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not explode if the current language mode has no comment regex",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsInSelection()"
            ],
            "updatePoint": {
                "line": 6364,
                "column": 74
            },
            "line": 6364,
            "code": "    it('does not explode if the current language mode has no comment regex', () => {\n      const editor = new TextEditor({\n        buffer: new TextBuffer({\n          text: 'hello'\n        })\n      });\n      editor.setSelectedBufferRange([[0, 0], [0, 5]]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(0)).toBe('hello');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing for empty lines and null grammar",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsInSelection()"
            ],
            "updatePoint": {
                "line": 6374,
                "column": 53
            },
            "line": 6374,
            "code": "    it('does nothing for empty lines and null grammar', () => {\n      atom.grammars.assignLanguageMode(editor, null);\n      editor.setCursorBufferPosition([10, 0]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(10)).toBe('');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uncomments when the line lacks the trailing whitespace in the comment regex",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsInSelection()"
            ],
            "updatePoint": {
                "line": 6380,
                "column": 83
            },
            "line": 6380,
            "code": "    it('uncomments when the line lacks the trailing whitespace in the comment regex', () => {\n      editor.setCursorBufferPosition([10, 0]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(10)).toBe('// ');\n      expect(editor.getSelectedBufferRange()).toEqual([[10, 3], [10, 3]]);\n      editor.backspace();\n      expect(editor.lineTextForBufferRow(10)).toBe('//');\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(10)).toBe('');\n      expect(editor.getSelectedBufferRange()).toEqual([[10, 0], [10, 0]]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uncomments when the line has leading whitespace",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsInSelection()"
            ],
            "updatePoint": {
                "line": 6391,
                "column": 55
            },
            "line": 6391,
            "code": "    it('uncomments when the line has leading whitespace', () => {\n      editor.setCursorBufferPosition([10, 0]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(10)).toBe('// ');\n      editor.moveToBeginningOfLine();\n      editor.insertText('  ');\n      editor.setSelectedBufferRange([[10, 0], [10, 0]]);\n      editor.toggleLineCommentsInSelection();\n      expect(editor.lineTextForBufferRow(10)).toBe('  ');\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the leading whitespace from the comment end pattern match when uncommenting lines",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsForBufferRows",
                "xml"
            ],
            "updatePoint": {
                "line": 6409,
                "column": 99
            },
            "line": 6409,
            "code": "      it('removes the leading whitespace from the comment end pattern match when uncommenting lines', () => {\n        editor.toggleLineCommentsForBufferRows(0, 0);\n        expect(editor.lineTextForBufferRow(0)).toBe('test');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not select the new delimiters",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsForBufferRows",
                "xml"
            ],
            "updatePoint": {
                "line": 6413,
                "column": 44
            },
            "line": 6413,
            "code": "      it('does not select the new delimiters', () => {\n        editor.setText('<!-- test -->');\n        let delimLength = '<!--'.length;\n        let selection = editor.addSelectionForBufferRange([[0, delimLength], [0, delimLength]]);\n        {\n          selection.toggleLineComments();\n          const range = selection.getBufferRange();\n          expect(range.isEmpty()).toBe(true);\n          expect(range.start.column).toBe(0);\n        }\n        {\n          selection.toggleLineComments();\n          const range = selection.getBufferRange();\n          expect(range.isEmpty()).toBe(true);\n          expect(range.start.column).toBe(delimLength + 1);\n        }\n        {\n          selection.setBufferRange([[0, delimLength], [0, delimLength + 1 + 'test'.length]]);\n          selection.toggleLineComments();\n          const range = selection.getBufferRange();\n          expect(range.start.column).toBe(0);\n          expect(range.end.column).toBe('test'.length);\n        }\n        {\n          selection.toggleLineComments();\n          const range = selection.getBufferRange();\n          expect(range.start.column).toBe(delimLength + 1);\n          expect(range.end.column).toBe(delimLength + 1 + 'test'.length);\n        }\n        {\n          editor.setText('    test');\n          selection.setBufferRange([[0, 4], [0, 4]]);\n          selection.toggleLineComments();\n          const range = selection.getBufferRange();\n          expect(range.isEmpty()).toBe(true);\n          expect(range.start.column).toBe(4 + delimLength + 1);\n        }\n        {\n          editor.setText('    test');\n          selection.setBufferRange([[0, 8], [0, 8]]);\n          selection.selectToBeginningOfWord();\n          selection.toggleLineComments();\n          const range = selection.getBufferRange();\n          expect(range.start.column).toBe(4 + delimLength + 1);\n          expect(range.end.column).toBe(4 + delimLength + 1 + 4);\n        }\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only uses the `commentEnd` pattern if it comes from the same grammar as the `commentStart` when commenting lines",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsForBufferRows",
                "less"
            ],
            "updatePoint": {
                "line": 6467,
                "column": 122
            },
            "line": 6467,
            "code": "      it('only uses the `commentEnd` pattern if it comes from the same grammar as the `commentStart` when commenting lines', () => {\n        editor.toggleLineCommentsForBufferRows(0, 0);\n        expect(editor.lineTextForBufferRow(0)).toBe('// @color: #4D926F;');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "comments/uncomments lines in the given range",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsForBufferRows",
                "css"
            ],
            "updatePoint": {
                "line": 6477,
                "column": 54
            },
            "line": 6477,
            "code": "      it('comments/uncomments lines in the given range', () => {\n        editor.toggleLineCommentsForBufferRows(0, 1);\n        expect(editor.lineTextForBufferRow(0)).toBe('/* body {');\n        expect(editor.lineTextForBufferRow(1)).toBe('  font-size: 1234px; */');\n        expect(editor.lineTextForBufferRow(2)).toBe('  width: 110%;');\n        expect(editor.lineTextForBufferRow(3)).toBe('  font-weight: bold !important;');\n        editor.toggleLineCommentsForBufferRows(2, 2);\n        expect(editor.lineTextForBufferRow(0)).toBe('/* body {');\n        expect(editor.lineTextForBufferRow(1)).toBe('  font-size: 1234px; */');\n        expect(editor.lineTextForBufferRow(2)).toBe('  /* width: 110%; */');\n        expect(editor.lineTextForBufferRow(3)).toBe('  font-weight: bold !important;');\n        editor.toggleLineCommentsForBufferRows(0, 1);\n        expect(editor.lineTextForBufferRow(0)).toBe('body {');\n        expect(editor.lineTextForBufferRow(1)).toBe('  font-size: 1234px;');\n        expect(editor.lineTextForBufferRow(2)).toBe('  /* width: 110%; */');\n        expect(editor.lineTextForBufferRow(3)).toBe('  font-weight: bold !important;');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uncomments lines with leading whitespace",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsForBufferRows",
                "css"
            ],
            "updatePoint": {
                "line": 6494,
                "column": 50
            },
            "line": 6494,
            "code": "      it('uncomments lines with leading whitespace', () => {\n        editor.setTextInBufferRange([[2, 0], [2, Infinity]], '  /* width: 110%; */');\n        editor.toggleLineCommentsForBufferRows(2, 2);\n        expect(editor.lineTextForBufferRow(2)).toBe('  width: 110%;');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uncomments lines with trailing whitespace",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsForBufferRows",
                "css"
            ],
            "updatePoint": {
                "line": 6499,
                "column": 51
            },
            "line": 6499,
            "code": "      it('uncomments lines with trailing whitespace', () => {\n        editor.setTextInBufferRange([[2, 0], [2, Infinity]], '/* width: 110%; */  ');\n        editor.toggleLineCommentsForBufferRows(2, 2);\n        expect(editor.lineTextForBufferRow(2)).toBe('width: 110%;  ');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uncomments lines with leading and trailing whitespace",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsForBufferRows",
                "css"
            ],
            "updatePoint": {
                "line": 6504,
                "column": 63
            },
            "line": 6504,
            "code": "      it('uncomments lines with leading and trailing whitespace', () => {\n        editor.setTextInBufferRange([[2, 0], [2, Infinity]], '   /* width: 110%; */ ');\n        editor.toggleLineCommentsForBufferRows(2, 2);\n        expect(editor.lineTextForBufferRow(2)).toBe('   width: 110%; ');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "comments/uncomments lines in the given range",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsForBufferRows",
                "coffeescript"
            ],
            "updatePoint": {
                "line": 6515,
                "column": 54
            },
            "line": 6515,
            "code": "      it('comments/uncomments lines in the given range', () => {\n        editor.toggleLineCommentsForBufferRows(4, 6);\n        expect(editor.lineTextForBufferRow(4)).toBe('    # pivot = items.shift()');\n        expect(editor.lineTextForBufferRow(5)).toBe('    # left = []');\n        expect(editor.lineTextForBufferRow(6)).toBe('    # right = []');\n        editor.toggleLineCommentsForBufferRows(4, 5);\n        expect(editor.lineTextForBufferRow(4)).toBe('    pivot = items.shift()');\n        expect(editor.lineTextForBufferRow(5)).toBe('    left = []');\n        expect(editor.lineTextForBufferRow(6)).toBe('    # right = []');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "comments/uncomments empty lines",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsForBufferRows",
                "coffeescript"
            ],
            "updatePoint": {
                "line": 6525,
                "column": 41
            },
            "line": 6525,
            "code": "      it('comments/uncomments empty lines', () => {\n        editor.toggleLineCommentsForBufferRows(4, 7);\n        expect(editor.lineTextForBufferRow(4)).toBe('    # pivot = items.shift()');\n        expect(editor.lineTextForBufferRow(5)).toBe('    # left = []');\n        expect(editor.lineTextForBufferRow(6)).toBe('    # right = []');\n        expect(editor.lineTextForBufferRow(7)).toBe('    # ');\n        editor.toggleLineCommentsForBufferRows(4, 5);\n        expect(editor.lineTextForBufferRow(4)).toBe('    pivot = items.shift()');\n        expect(editor.lineTextForBufferRow(5)).toBe('    left = []');\n        expect(editor.lineTextForBufferRow(6)).toBe('    # right = []');\n        expect(editor.lineTextForBufferRow(7)).toBe('    # ');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "comments/uncomments lines in the given range",
            "suites": [
                "TextEditor",
                ".toggleLineCommentsForBufferRows",
                "javascript"
            ],
            "updatePoint": {
                "line": 6543,
                "column": 54
            },
            "line": 6543,
            "code": "      it('comments/uncomments lines in the given range', () => {\n        editor.toggleLineCommentsForBufferRows(4, 7);\n        expect(editor.lineTextForBufferRow(4)).toBe('    // while(items.length > 0) {');\n        expect(editor.lineTextForBufferRow(5)).toBe('    //   current = items.shift();');\n        expect(editor.lineTextForBufferRow(6)).toBe('    //   current < pivot ? left.push(current) : right.push(current);');\n        expect(editor.lineTextForBufferRow(7)).toBe('    // }');\n        editor.toggleLineCommentsForBufferRows(4, 5);\n        expect(editor.lineTextForBufferRow(4)).toBe('    while(items.length > 0) {');\n        expect(editor.lineTextForBufferRow(5)).toBe('      current = items.shift();');\n        expect(editor.lineTextForBufferRow(6)).toBe('    //   current < pivot ? left.push(current) : right.push(current);');\n        expect(editor.lineTextForBufferRow(7)).toBe('    // }');\n        editor.setText('\\tvar i;');\n        editor.toggleLineCommentsForBufferRows(0, 0);\n        expect(editor.lineTextForBufferRow(0)).toBe('\\t// var i;');\n        editor.setText('var i;');\n        editor.toggleLineCommentsForBufferRows(0, 0);\n        expect(editor.lineTextForBufferRow(0)).toBe('// var i;');\n        editor.setText(' var i;');\n        editor.toggleLineCommentsForBufferRows(0, 0);\n        expect(editor.lineTextForBufferRow(0)).toBe(' // var i;');\n        editor.setText('  ');\n        editor.toggleLineCommentsForBufferRows(0, 0);\n        expect(editor.lineTextForBufferRow(0)).toBe('  // ');\n        editor.setText('    a\\n  \\n    b');\n        editor.toggleLineCommentsForBufferRows(0, 2);\n        expect(editor.lineTextForBufferRow(0)).toBe('    // a');\n        expect(editor.lineTextForBufferRow(1)).toBe('    // ');\n        expect(editor.lineTextForBufferRow(2)).toBe('    // b');\n        editor.setText('    \\n    // var i;');\n        editor.toggleLineCommentsForBufferRows(0, 1);\n        expect(editor.lineTextForBufferRow(0)).toBe('    ');\n        expect(editor.lineTextForBufferRow(1)).toBe('    var i;');\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "maintains cursor buffer position when a folding/unfolding",
            "suites": [
                "TextEditor",
                "folding"
            ],
            "updatePoint": {
                "line": 6582,
                "column": 65
            },
            "line": 6582,
            "code": "    it('maintains cursor buffer position when a folding/unfolding', async () => {\n      editor = await atom.workspace.open('sample.js', {\n        autoIndent: false\n      });\n      editor.setCursorBufferPosition([5, 5]);\n      editor.foldAll();\n      expect(editor.getCursorBufferPosition()).toEqual([5, 5]);\n    });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "unfolds every folded line",
            "suites": [
                "TextEditor",
                "folding",
                ".unfoldAll()"
            ],
            "updatePoint": {
                "line": 6591,
                "column": 35
            },
            "line": 6591,
            "code": "      it('unfolds every folded line', async () => {\n        editor = await atom.workspace.open('sample.js', {\n          autoIndent: false\n        });\n        const initialScreenLineCount = editor.getScreenLineCount();\n        editor.foldBufferRow(0);\n        editor.foldBufferRow(1);\n        expect(editor.getScreenLineCount()).toBeLessThan(initialScreenLineCount);\n        editor.unfoldAll();\n        expect(editor.getScreenLineCount()).toBe(initialScreenLineCount);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "unfolds every folded line with comments",
            "suites": [
                "TextEditor",
                "folding",
                ".unfoldAll()"
            ],
            "updatePoint": {
                "line": 6602,
                "column": 49
            },
            "line": 6602,
            "code": "      it('unfolds every folded line with comments', async () => {\n        editor = await atom.workspace.open('sample-with-comments.js', {\n          autoIndent: false\n        });\n        const initialScreenLineCount = editor.getScreenLineCount();\n        editor.foldBufferRow(0);\n        editor.foldBufferRow(5);\n        expect(editor.getScreenLineCount()).toBeLessThan(initialScreenLineCount);\n        editor.unfoldAll();\n        expect(editor.getScreenLineCount()).toBe(initialScreenLineCount);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "folds every foldable line",
            "suites": [
                "TextEditor",
                "folding",
                ".foldAll()"
            ],
            "updatePoint": {
                "line": 6615,
                "column": 35
            },
            "line": 6615,
            "code": "      it('folds every foldable line', async () => {\n        editor = await atom.workspace.open('sample.js', {\n          autoIndent: false\n        });\n        editor.foldAll();\n        const [fold1, fold2, fold3] = editor.unfoldAll();\n        expect([fold1.start.row, fold1.end.row]).toEqual([0, 12]);\n        expect([fold2.start.row, fold2.end.row]).toEqual([1, 9]);\n        expect([fold3.start.row, fold3.end.row]).toEqual([4, 7]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a fold based on the syntactic region starting at the given row",
            "suites": [
                "TextEditor",
                "folding",
                ".foldBufferRow(bufferRow)",
                "when bufferRow can be folded"
            ],
            "updatePoint": {
                "line": 6631,
                "column": 82
            },
            "line": 6631,
            "code": "        it('creates a fold based on the syntactic region starting at the given row', () => {\n          editor.foldBufferRow(1);\n          const [fold] = editor.unfoldAll();\n          expect([fold.start.row, fold.end.row]).toEqual([1, 9]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "searches upward for the first row that begins a syntactic region containing the given buffer row (and folds it)",
            "suites": [
                "TextEditor",
                "folding",
                ".foldBufferRow(bufferRow)",
                "when bufferRow can't be folded"
            ],
            "updatePoint": {
                "line": 6638,
                "column": 123
            },
            "line": 6638,
            "code": "        it('searches upward for the first row that begins a syntactic region containing the given buffer row (and folds it)', () => {\n          editor.foldBufferRow(8);\n          const [fold] = editor.unfoldAll();\n          expect([fold.start.row, fold.end.row]).toEqual([1, 9]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "searches upward for the first row that begins a syntactic region containing the folded row (and folds it)",
            "suites": [
                "TextEditor",
                "folding",
                ".foldBufferRow(bufferRow)",
                "when the bufferRow is already folded"
            ],
            "updatePoint": {
                "line": 6645,
                "column": 117
            },
            "line": 6645,
            "code": "        it('searches upward for the first row that begins a syntactic region containing the folded row (and folds it)', () => {\n          editor.foldBufferRow(2);\n          expect(editor.isFoldedAtBufferRow(0)).toBe(false);\n          expect(editor.isFoldedAtBufferRow(1)).toBe(true);\n          editor.foldBufferRow(1);\n          expect(editor.isFoldedAtBufferRow(0)).toBe(true);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "searches upward for the first row that begins a syntactic region containing the folded row (and folds it)",
            "suites": [
                "TextEditor",
                "folding",
                ".foldBufferRow(bufferRow)",
                "when the bufferRow is a single-line comment"
            ],
            "updatePoint": {
                "line": 6654,
                "column": 117
            },
            "line": 6654,
            "code": "        it('searches upward for the first row that begins a syntactic region containing the folded row (and folds it)', () => {\n          editor.buffer.insert([1, 0], '  //this is a single line comment\\n');\n          editor.foldBufferRow(1);\n          const [fold] = editor.unfoldAll();\n          expect([fold.start.row, fold.end.row]).toEqual([0, 13]);\n        });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a fold at the location of the last cursor",
            "suites": [
                "TextEditor",
                "folding",
                ".foldCurrentRow()"
            ],
            "updatePoint": {
                "line": 6663,
                "column": 59
            },
            "line": 6663,
            "code": "      it('creates a fold at the location of the last cursor', async () => {\n        editor = await atom.workspace.open();\n        editor.setText('\\nif (x) {\\n  y()\\n}');\n        editor.setCursorBufferPosition([1, 0]);\n        expect(editor.getScreenLineCount()).toBe(4);\n        editor.foldCurrentRow();\n        expect(editor.getScreenLineCount()).toBe(3);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing when the current row cannot be folded",
            "suites": [
                "TextEditor",
                "folding",
                ".foldCurrentRow()"
            ],
            "updatePoint": {
                "line": 6671,
                "column": 60
            },
            "line": 6671,
            "code": "      it('does nothing when the current row cannot be folded', async () => {\n        editor = await atom.workspace.open();\n        editor.setText('var x;\\nx++\\nx++');\n        editor.setCursorBufferPosition([0, 0]);\n        expect(editor.getScreenLineCount()).toBe(3);\n        editor.foldCurrentRow();\n        expect(editor.getScreenLineCount()).toBe(3);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "folds blocks of text at the given indentation level",
            "suites": [
                "TextEditor",
                "folding",
                ".foldAllAtIndentLevel(indentLevel)"
            ],
            "updatePoint": {
                "line": 6681,
                "column": 61
            },
            "line": 6681,
            "code": "      it('folds blocks of text at the given indentation level', async () => {\n        editor = await atom.workspace.open('sample.js', {\n          autoIndent: false\n        });\n        editor.foldAllAtIndentLevel(0);\n        expect(editor.lineTextForScreenRow(0)).toBe(`var quicksort = function () {${editor.displayLayer.foldCharacter}};`);\n        expect(editor.getLastScreenRow()).toBe(0);\n        editor.foldAllAtIndentLevel(1);\n        expect(editor.lineTextForScreenRow(0)).toBe('var quicksort = function () {');\n        expect(editor.lineTextForScreenRow(1)).toBe(`  var sort = function(items) {${editor.displayLayer.foldCharacter}};`);\n        expect(editor.getLastScreenRow()).toBe(4);\n        editor.foldAllAtIndentLevel(2);\n        expect(editor.lineTextForScreenRow(0)).toBe('var quicksort = function () {');\n        expect(editor.lineTextForScreenRow(1)).toBe('  var sort = function(items) {');\n        expect(editor.lineTextForScreenRow(2)).toBe('    if (items.length <= 1) return items;');\n        expect(editor.getLastScreenRow()).toBe(9);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not fold anything but the indentLevel",
            "suites": [
                "TextEditor",
                "folding",
                ".foldAllAtIndentLevel(indentLevel)"
            ],
            "updatePoint": {
                "line": 6698,
                "column": 52
            },
            "line": 6698,
            "code": "      it('does not fold anything but the indentLevel', async () => {\n        editor = await atom.workspace.open('sample-with-comments.js', {\n          autoIndent: false\n        });\n        editor.foldAllAtIndentLevel(0);\n        const folds = editor.unfoldAll();\n        expect(folds.length).toBe(1);\n        expect([folds[0].start.row, folds[0].end.row]).toEqual([0, 30]);\n      });",
            "file": "text-editor-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads the editor but doesn't tokenize",
            "suites": [
                "TextMateLanguageMode",
                "when the editor is constructed with the largeFileMode option set to true"
            ],
            "updatePoint": {
                "line": 31,
                "column": 45
            },
            "line": 31,
            "code": "    it(\"loads the editor but doesn't tokenize\", async () => {\n      const line = 'a b c d\\n';\n      buffer = new TextBuffer(line.repeat(256 * 1024));\n      expect(buffer.getText().length).toBe(2 * 1024 * 1024);\n      languageMode = new TextMateLanguageMode({\n        buffer,\n        grammar: atom.grammars.grammarForScopeName('source.js'),\n        tabLength: 2\n      });\n      buffer.setLanguageMode(languageMode);\n      expect(languageMode.isRowCommented(0)).toBeFalsy(); // It treats the entire line as one big token\n\n      let iterator = languageMode.buildHighlightIterator();\n      iterator.seek({\n        row: 0,\n        column: 0\n      });\n      iterator.moveToSuccessor();\n      expect(iterator.getPosition()).toEqual({\n        row: 0,\n        column: 7\n      });\n      buffer.insert([0, 0], 'hey\"');\n      iterator = languageMode.buildHighlightIterator();\n      iterator.seek({\n        row: 0,\n        column: 0\n      });\n      iterator.moveToSuccessor();\n      expect(iterator.getPosition()).toEqual({\n        row: 0,\n        column: 11\n      });\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stops tokenization",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer is destroyed"
            ],
            "updatePoint": {
                "line": 77,
                "column": 28
            },
            "line": 77,
            "code": "      it('stops tokenization', () => {\n        languageMode.destroy();\n        spyOn(languageMode, 'tokenizeNextChunk');\n        advanceClock();\n        expect(languageMode.tokenizeNextChunk).not.toHaveBeenCalled();\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "tokenizes lines chunk at a time in the background",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "on construction"
            ],
            "updatePoint": {
                "line": 99,
                "column": 93
            },
            "line": 99,
            "code": "      describe('on construction', () => it('tokenizes lines chunk at a time in the background', () => {\n        const line0 = languageMode.tokenizedLines[0];\n        expect(line0).toBeUndefined();\n        const line11 = languageMode.tokenizedLines[11];\n        expect(line11).toBeUndefined(); // tokenize chunk 1\n\n        advanceClock();\n        expect(languageMode.tokenizedLines[0].ruleStack != null).toBeTruthy();\n        expect(languageMode.tokenizedLines[4].ruleStack != null).toBeTruthy();\n        expect(languageMode.tokenizedLines[5]).toBeUndefined(); // tokenize chunk 2\n\n        advanceClock();\n        expect(languageMode.tokenizedLines[5].ruleStack != null).toBeTruthy();\n        expect(languageMode.tokenizedLines[9].ruleStack != null).toBeTruthy();\n        expect(languageMode.tokenizedLines[10]).toBeUndefined(); // tokenize last chunk\n\n        advanceClock();\n        expect(languageMode.tokenizedLines[10].ruleStack != null).toBeTruthy();\n        expect(languageMode.tokenizedLines[12].ruleStack != null).toBeTruthy();\n      }));",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "pushes the invalid rows down",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is partially tokenized",
                "when there is a buffer change inside the tokenized region",
                "when lines are added"
            ],
            "updatePoint": {
                "line": 126,
                "column": 44
            },
            "line": 126,
            "code": "            it('pushes the invalid rows down', () => {\n              expect(languageMode.firstInvalidRow()).toBe(5);\n              buffer.insert([1, 0], '\\n\\n');\n              expect(languageMode.firstInvalidRow()).toBe(7);\n            });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "pulls the invalid rows up",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is partially tokenized",
                "when there is a buffer change inside the tokenized region",
                "when lines are removed"
            ],
            "updatePoint": {
                "line": 133,
                "column": 41
            },
            "line": 133,
            "code": "            it('pulls the invalid rows up', () => {\n              expect(languageMode.firstInvalidRow()).toBe(5);\n              buffer.delete([[1, 0], [3, 0]]);\n              expect(languageMode.firstInvalidRow()).toBe(2);\n            });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "retokenizes the invalidated lines and continues into the valid region",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is partially tokenized",
                "when there is a buffer change inside the tokenized region",
                "when the change invalidates all the lines before the current invalid region"
            ],
            "updatePoint": {
                "line": 140,
                "column": 85
            },
            "line": 140,
            "code": "            it('retokenizes the invalidated lines and continues into the valid region', () => {\n              expect(languageMode.firstInvalidRow()).toBe(5);\n              buffer.insert([2, 0], '/*');\n              expect(languageMode.firstInvalidRow()).toBe(3);\n              advanceClock();\n              expect(languageMode.firstInvalidRow()).toBe(8);\n            });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "pushes the invalid row to the end of the change",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is partially tokenized",
                "when there is a buffer change surrounding an invalid row"
            ],
            "updatePoint": {
                "line": 150,
                "column": 61
            },
            "line": 150,
            "code": "          it('pushes the invalid row to the end of the change', () => {\n            buffer.setTextInRange([[4, 0], [6, 0]], '\\n\\n\\n');\n            expect(languageMode.firstInvalidRow()).toBe(8);\n          });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not attempt to tokenize the lines in the change, and preserves the existing invalid row",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is partially tokenized",
                "when there is a buffer change inside an invalid region"
            ],
            "updatePoint": {
                "line": 156,
                "column": 106
            },
            "line": 156,
            "code": "          it('does not attempt to tokenize the lines in the change, and preserves the existing invalid row', () => {\n            expect(languageMode.firstInvalidRow()).toBe(5);\n            buffer.setTextInRange([[6, 0], [7, 0]], '\\n\\n\\n');\n            expect(languageMode.tokenizedLines[6]).toBeUndefined();\n            expect(languageMode.tokenizedLines[7]).toBeUndefined();\n            expect(languageMode.firstInvalidRow()).toBe(5);\n          });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates tokens to reflect the change",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is fully tokenized",
                "when there is a buffer change that is smaller than the chunk size",
                "when lines are updated, but none are added or removed"
            ],
            "updatePoint": {
                "line": 169,
                "column": 52
            },
            "line": 169,
            "code": "            it('updates tokens to reflect the change', () => {\n              buffer.setTextInRange([[0, 0], [2, 0]], 'foo()\\n7\\n');\n              expect(languageMode.tokenizedLines[0].tokens[1]).toEqual({\n                value: '(',\n                scopes: ['source.js', 'meta.function-call.js', 'meta.arguments.js', 'punctuation.definition.arguments.begin.bracket.round.js']\n              });\n              expect(languageMode.tokenizedLines[1].tokens[0]).toEqual({\n                value: '7',\n                scopes: ['source.js', 'constant.numeric.decimal.js']\n              }); // line 2 is unchanged\n\n              expect(languageMode.tokenizedLines[2].tokens[1]).toEqual({\n                value: 'if',\n                scopes: ['source.js', 'keyword.control.js']\n              });\n            });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "schedules the invalidated lines to be tokenized in the background",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is fully tokenized",
                "when there is a buffer change that is smaller than the chunk size",
                "when lines are updated, but none are added or removed",
                "when the change invalidates the tokenization of subsequent lines"
            ],
            "updatePoint": {
                "line": 186,
                "column": 83
            },
            "line": 186,
            "code": "              it('schedules the invalidated lines to be tokenized in the background', () => {\n                buffer.insert([5, 30], '/* */');\n                buffer.insert([2, 0], '/*');\n                expect(languageMode.tokenizedLines[3].tokens[0].scopes).toEqual(['source.js']);\n                advanceClock();\n                expect(languageMode.tokenizedLines[3].tokens[0].scopes).toEqual(['source.js', 'comment.block.js']);\n                expect(languageMode.tokenizedLines[4].tokens[0].scopes).toEqual(['source.js', 'comment.block.js']);\n                expect(languageMode.tokenizedLines[5].tokens[0].scopes).toEqual(['source.js', 'comment.block.js']);\n              });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resumes highlighting with the state of the previous line",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is fully tokenized",
                "when there is a buffer change that is smaller than the chunk size",
                "when lines are updated, but none are added or removed",
                "when the change invalidates the tokenization of subsequent lines"
            ],
            "updatePoint": {
                "line": 196,
                "column": 72
            },
            "line": 196,
            "code": "            it('resumes highlighting with the state of the previous line', () => {\n              buffer.insert([0, 0], '/*');\n              buffer.insert([5, 0], '*/');\n              buffer.insert([1, 0], 'var ');\n              expect(languageMode.tokenizedLines[1].tokens[0].scopes).toEqual(['source.js', 'comment.block.js']);\n            });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates tokens to reflect the change",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is fully tokenized",
                "when there is a buffer change that is smaller than the chunk size",
                "when lines are both updated and removed"
            ],
            "updatePoint": {
                "line": 204,
                "column": 52
            },
            "line": 204,
            "code": "            it('updates tokens to reflect the change', () => {\n              buffer.setTextInRange([[1, 0], [3, 0]], 'foo()'); // previous line 0 remains\n\n              expect(languageMode.tokenizedLines[0].tokens[0]).toEqual({\n                value: 'var',\n                scopes: ['source.js', 'storage.type.var.js']\n              }); // previous line 3 should be combined with input to form line 1\n\n              expect(languageMode.tokenizedLines[1].tokens[0]).toEqual({\n                value: 'foo',\n                scopes: ['source.js', 'meta.function-call.js', 'entity.name.function.js']\n              });\n              expect(languageMode.tokenizedLines[1].tokens[6]).toEqual({\n                value: '=',\n                scopes: ['source.js', 'keyword.operator.assignment.js']\n              }); // lines below deleted regions should be shifted upward\n\n              expect(languageMode.tokenizedLines[2].tokens[1]).toEqual({\n                value: 'while',\n                scopes: ['source.js', 'keyword.control.js']\n              });\n              expect(languageMode.tokenizedLines[3].tokens[1]).toEqual({\n                value: '=',\n                scopes: ['source.js', 'keyword.operator.assignment.js']\n              });\n              expect(languageMode.tokenizedLines[4].tokens[1]).toEqual({\n                value: '<',\n                scopes: ['source.js', 'keyword.operator.comparison.js']\n              });\n            });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "schedules the invalidated lines to be tokenized in the background",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is fully tokenized",
                "when there is a buffer change that is smaller than the chunk size",
                "when the change invalidates the tokenization of subsequent lines"
            ],
            "updatePoint": {
                "line": 236,
                "column": 81
            },
            "line": 236,
            "code": "            it('schedules the invalidated lines to be tokenized in the background', () => {\n              buffer.insert([5, 30], '/* */');\n              buffer.setTextInRange([[2, 0], [3, 0]], '/*');\n              expect(languageMode.tokenizedLines[2].tokens[0].scopes).toEqual(['source.js', 'comment.block.js', 'punctuation.definition.comment.begin.js']);\n              expect(languageMode.tokenizedLines[3].tokens[0].scopes).toEqual(['source.js']);\n              advanceClock();\n              expect(languageMode.tokenizedLines[3].tokens[0].scopes).toEqual(['source.js', 'comment.block.js']);\n              expect(languageMode.tokenizedLines[4].tokens[0].scopes).toEqual(['source.js', 'comment.block.js']);\n            });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates tokens to reflect the change",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is fully tokenized",
                "when there is a buffer change that is smaller than the chunk size",
                "when lines are both updated and inserted"
            ],
            "updatePoint": {
                "line": 247,
                "column": 52
            },
            "line": 247,
            "code": "            it('updates tokens to reflect the change', () => {\n              buffer.setTextInRange([[1, 0], [2, 0]], 'foo()\\nbar()\\nbaz()\\nquux()'); // previous line 0 remains\n\n              expect(languageMode.tokenizedLines[0].tokens[0]).toEqual({\n                value: 'var',\n                scopes: ['source.js', 'storage.type.var.js']\n              }); // 3 new lines inserted\n\n              expect(languageMode.tokenizedLines[1].tokens[0]).toEqual({\n                value: 'foo',\n                scopes: ['source.js', 'meta.function-call.js', 'entity.name.function.js']\n              });\n              expect(languageMode.tokenizedLines[2].tokens[0]).toEqual({\n                value: 'bar',\n                scopes: ['source.js', 'meta.function-call.js', 'entity.name.function.js']\n              });\n              expect(languageMode.tokenizedLines[3].tokens[0]).toEqual({\n                value: 'baz',\n                scopes: ['source.js', 'meta.function-call.js', 'entity.name.function.js']\n              }); // previous line 2 is joined with quux() on line 4\n\n              expect(languageMode.tokenizedLines[4].tokens[0]).toEqual({\n                value: 'quux',\n                scopes: ['source.js', 'meta.function-call.js', 'entity.name.function.js']\n              });\n              expect(languageMode.tokenizedLines[4].tokens[4]).toEqual({\n                value: 'if',\n                scopes: ['source.js', 'keyword.control.js']\n              }); // previous line 3 is pushed down to become line 5\n\n              expect(languageMode.tokenizedLines[5].tokens[3]).toEqual({\n                value: '=',\n                scopes: ['source.js', 'keyword.operator.assignment.js']\n              });\n            });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "schedules the invalidated lines to be tokenized in the background",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is fully tokenized",
                "when there is a buffer change that is smaller than the chunk size",
                "when the change invalidates the tokenization of subsequent lines"
            ],
            "updatePoint": {
                "line": 284,
                "column": 81
            },
            "line": 284,
            "code": "            it('schedules the invalidated lines to be tokenized in the background', () => {\n              buffer.insert([5, 30], '/* */');\n              buffer.insert([2, 0], '/*\\nabcde\\nabcder');\n              expect(languageMode.tokenizedLines[2].tokens[0].scopes).toEqual(['source.js', 'comment.block.js', 'punctuation.definition.comment.begin.js']);\n              expect(languageMode.tokenizedLines[3].tokens[0].scopes).toEqual(['source.js', 'comment.block.js']);\n              expect(languageMode.tokenizedLines[4].tokens[0].scopes).toEqual(['source.js', 'comment.block.js']);\n              expect(languageMode.tokenizedLines[5].tokens[0].scopes).toEqual(['source.js']);\n              advanceClock(); // tokenize invalidated lines in background\n\n              expect(languageMode.tokenizedLines[5].tokens[0].scopes).toEqual(['source.js', 'comment.block.js']);\n              expect(languageMode.tokenizedLines[6].tokens[0].scopes).toEqual(['source.js', 'comment.block.js']);\n              expect(languageMode.tokenizedLines[7].tokens[0].scopes).toEqual(['source.js', 'comment.block.js']);\n              expect(languageMode.tokenizedLines[8].tokens[0].scopes).not.toBe(['source.js', 'comment.block.js']);\n            });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "tokenizes the initial chunk synchronously, then tokenizes the remaining lines in the background",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer contains soft-tabs",
                "when the buffer is fully tokenized",
                "when there is an insertion that is larger than the chunk size"
            ],
            "updatePoint": {
                "line": 301,
                "column": 109
            },
            "line": 301,
            "code": "          it('tokenizes the initial chunk synchronously, then tokenizes the remaining lines in the background', () => {\n            const commentBlock = _.multiplyString('// a comment\\n', languageMode.chunkSize + 2);\n\n            buffer.insert([0, 0], commentBlock);\n            expect(languageMode.tokenizedLines[0].ruleStack != null).toBeTruthy();\n            expect(languageMode.tokenizedLines[4].ruleStack != null).toBeTruthy();\n            expect(languageMode.tokenizedLines[5]).toBeUndefined();\n            advanceClock();\n            expect(languageMode.tokenizedLines[5].ruleStack != null).toBeTruthy();\n            expect(languageMode.tokenizedLines[6].ruleStack != null).toBeTruthy();\n          });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits the `tokenized` event",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when tokenization completes"
            ],
            "updatePoint": {
                "line": 335,
                "column": 37
            },
            "line": 335,
            "code": "      it('emits the `tokenized` event', async () => {\n        const editor = await atom.workspace.open('sample.js');\n        const tokenizedHandler = jasmine.createSpy('tokenized handler');\n        editor.languageMode.onDidTokenize(tokenizedHandler);\n        fullyTokenize(editor.getBuffer().getLanguageMode());\n        expect(tokenizedHandler.callCount).toBe(1);\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't re-emit the `tokenized` event when it is re-tokenized",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when tokenization completes"
            ],
            "updatePoint": {
                "line": 342,
                "column": 71
            },
            "line": 342,
            "code": "      it(\"doesn't re-emit the `tokenized` event when it is re-tokenized\", async () => {\n        const editor = await atom.workspace.open('sample.js');\n        fullyTokenize(editor.languageMode);\n        const tokenizedHandler = jasmine.createSpy('tokenized handler');\n        editor.languageMode.onDidTokenize(tokenizedHandler);\n        editor.getBuffer().insert([0, 0], \"'\");\n        fullyTokenize(editor.languageMode);\n        expect(tokenizedHandler).not.toHaveBeenCalled();\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "re-emits the `tokenized` event",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the grammar is updated because a grammar it includes is activated"
            ],
            "updatePoint": {
                "line": 353,
                "column": 40
            },
            "line": 353,
            "code": "      it('re-emits the `tokenized` event', async () => {\n        let tokenizationCount = 0;\n        const editor = await atom.workspace.open('coffee.coffee');\n        editor.onDidTokenize(() => {\n          tokenizationCount++;\n        });\n        fullyTokenize(editor.getBuffer().getLanguageMode());\n        tokenizationCount = 0;\n        await atom.packages.activatePackage('language-coffee-script');\n        fullyTokenize(editor.getBuffer().getLanguageMode());\n        expect(tokenizationCount).toBe(1);\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "retokenizes the buffer",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the grammar is updated because a grammar it includes is activated"
            ],
            "updatePoint": {
                "line": 365,
                "column": 32
            },
            "line": 365,
            "code": "      it('retokenizes the buffer', async () => {\n        await atom.packages.activatePackage('language-ruby-on-rails');\n        await atom.packages.activatePackage('language-ruby');\n        buffer = atom.project.bufferForPathSync();\n        buffer.setText(\"<div class='name'><%= User.find(2).full_name %></div>\");\n        languageMode = new TextMateLanguageMode({\n          buffer,\n          config,\n          grammar: atom.grammars.selectGrammar('test.erb')\n        });\n        fullyTokenize(languageMode);\n        expect(languageMode.tokenizedLines[0].tokens[0]).toEqual({\n          value: \"<div class='name'>\",\n          scopes: ['text.html.ruby']\n        });\n        await atom.packages.activatePackage('language-html');\n        fullyTokenize(languageMode);\n        expect(languageMode.tokenizedLines[0].tokens[0]).toEqual({\n          value: '<',\n          scopes: ['text.html.ruby', 'meta.tag.block.div.html', 'punctuation.definition.tag.begin.html']\n        });\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not actually tokenize using the grammar",
            "suites": [
                "TextMateLanguageMode",
                "tokenizing",
                "when the buffer is configured with the null grammar"
            ],
            "updatePoint": {
                "line": 389,
                "column": 54
            },
            "line": 389,
            "code": "      it('does not actually tokenize using the grammar', () => {\n        spyOn(NullGrammar, 'tokenizeLine').andCallThrough();\n        buffer = atom.project.bufferForPathSync('sample.will-use-the-null-grammar');\n        buffer.setText('a\\nb\\nc');\n        languageMode = new TextMateLanguageMode({\n          buffer,\n          config\n        });\n        const tokenizeCallback = jasmine.createSpy('onDidTokenize');\n        languageMode.onDidTokenize(tokenizeCallback);\n        expect(languageMode.tokenizedLines[0]).toBeUndefined();\n        expect(languageMode.tokenizedLines[1]).toBeUndefined();\n        expect(languageMode.tokenizedLines[2]).toBeUndefined();\n        expect(tokenizeCallback.callCount).toBe(0);\n        expect(NullGrammar.tokenizeLine).not.toHaveBeenCalled();\n        fullyTokenize(languageMode);\n        expect(languageMode.tokenizedLines[0]).toBeUndefined();\n        expect(languageMode.tokenizedLines[1]).toBeUndefined();\n        expect(languageMode.tokenizedLines[2]).toBeUndefined();\n        expect(tokenizeCallback.callCount).toBe(0);\n        expect(NullGrammar.tokenizeLine).not.toHaveBeenCalled();\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the correct token (regression)",
            "suites": [
                "TextMateLanguageMode",
                ".tokenForPosition(position)"
            ],
            "updatePoint": {
                "line": 418,
                "column": 46
            },
            "line": 418,
            "code": "    it('returns the correct token (regression)', () => {\n      buffer = atom.project.bufferForPathSync('sample.js');\n      languageMode = new TextMateLanguageMode({\n        buffer,\n        config,\n        grammar: atom.grammars.grammarForScopeName('source.js')\n      });\n      fullyTokenize(languageMode);\n      expect(languageMode.tokenForPosition([1, 0]).scopes).toEqual(['source.js']);\n      expect(languageMode.tokenForPosition([1, 1]).scopes).toEqual(['source.js']);\n      expect(languageMode.tokenForPosition([1, 2]).scopes).toEqual(['source.js', 'storage.type.var.js']);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a falsy value",
            "suites": [
                "TextMateLanguageMode",
                ".bufferRangeForScopeAtPosition(selector, position)",
                "when the selector does not match the token at the position"
            ],
            "updatePoint": {
                "line": 441,
                "column": 106
            },
            "line": 441,
            "code": "    describe('when the selector does not match the token at the position', () => it('returns a falsy value', () => expect(languageMode.bufferRangeForScopeAtPosition('.bogus', [0, 1])).toBeUndefined()));",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the range covered by the token",
            "suites": [
                "TextMateLanguageMode",
                ".bufferRangeForScopeAtPosition(selector, position)",
                "when the selector matches a single token at the position"
            ],
            "updatePoint": {
                "line": 443,
                "column": 48
            },
            "line": 443,
            "code": "      it('returns the range covered by the token', () => {\n        expect(languageMode.bufferRangeForScopeAtPosition('.storage.type.var.js', [0, 1])).toEqual([[0, 0], [0, 3]]);\n        expect(languageMode.bufferRangeForScopeAtPosition('.storage.type.var.js', [0, 3])).toEqual([[0, 0], [0, 3]]);\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the range covered by all contiguous tokens (within a single line)",
            "suites": [
                "TextMateLanguageMode",
                ".bufferRangeForScopeAtPosition(selector, position)",
                "when the selector matches a run of multiple tokens at the position"
            ],
            "updatePoint": {
                "line": 449,
                "column": 83
            },
            "line": 449,
            "code": "      it('returns the range covered by all contiguous tokens (within a single line)', () => {\n        expect(languageMode.bufferRangeForScopeAtPosition('.function', [1, 18])).toEqual([[1, 6], [1, 28]]);\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the tokenized line for a row, or a placeholder line if it hasn't been tokenized yet",
            "suites": [
                "TextMateLanguageMode",
                ".tokenizedLineForRow(row)"
            ],
            "updatePoint": {
                "line": 455,
                "column": 99
            },
            "line": 455,
            "code": "    it(\"returns the tokenized line for a row, or a placeholder line if it hasn't been tokenized yet\", () => {\n      buffer = atom.project.bufferForPathSync('sample.js');\n      const grammar = atom.grammars.grammarForScopeName('source.js');\n      languageMode = new TextMateLanguageMode({\n        buffer,\n        config,\n        grammar\n      });\n      const line0 = buffer.lineForRow(0);\n      const jsScopeStartId = grammar.startIdForScope(grammar.scopeName);\n      const jsScopeEndId = grammar.endIdForScope(grammar.scopeName);\n      languageMode.startTokenizing();\n      expect(languageMode.tokenizedLines[0]).toBeUndefined();\n      expect(languageMode.tokenizedLineForRow(0).text).toBe(line0);\n      expect(languageMode.tokenizedLineForRow(0).tags).toEqual([jsScopeStartId, line0.length, jsScopeEndId]);\n      advanceClock(1);\n      expect(languageMode.tokenizedLines[0]).not.toBeUndefined();\n      expect(languageMode.tokenizedLineForRow(0).text).toBe(line0);\n      expect(languageMode.tokenizedLineForRow(0).tags).not.toEqual([jsScopeStartId, line0.length, jsScopeEndId]);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns undefined if the requested row is outside the buffer range",
            "suites": [
                "TextMateLanguageMode",
                ".tokenizedLineForRow(row)"
            ],
            "updatePoint": {
                "line": 475,
                "column": 74
            },
            "line": 475,
            "code": "    it('returns undefined if the requested row is outside the buffer range', () => {\n      buffer = atom.project.bufferForPathSync('sample.js');\n      const grammar = atom.grammars.grammarForScopeName('source.js');\n      languageMode = new TextMateLanguageMode({\n        buffer,\n        config,\n        grammar\n      });\n      fullyTokenize(languageMode);\n      expect(languageMode.tokenizedLineForRow(999)).toBeUndefined();\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "iterates over the syntactic scope boundaries",
            "suites": [
                "TextMateLanguageMode",
                ".buildHighlightIterator"
            ],
            "updatePoint": {
                "line": 491,
                "column": 52
            },
            "line": 491,
            "code": "    it('iterates over the syntactic scope boundaries', () => {\n      buffer = new TextBuffer({\n        text: 'var foo = 1 /*\\nhello*/var bar = 2\\n'\n      });\n      languageMode = new TextMateLanguageMode({\n        buffer,\n        config,\n        grammar: atom.grammars.grammarForScopeName('source.js')\n      });\n      fullyTokenize(languageMode);\n      const iterator = languageMode.buildHighlightIterator();\n      iterator.seek(Point(0, 0));\n      const expectedBoundaries = [{\n        position: Point(0, 0),\n        closeTags: [],\n        openTags: ['syntax--source syntax--js', 'syntax--storage syntax--type syntax--var syntax--js']\n      }, {\n        position: Point(0, 3),\n        closeTags: ['syntax--storage syntax--type syntax--var syntax--js'],\n        openTags: []\n      }, {\n        position: Point(0, 8),\n        closeTags: [],\n        openTags: ['syntax--keyword syntax--operator syntax--assignment syntax--js']\n      }, {\n        position: Point(0, 9),\n        closeTags: ['syntax--keyword syntax--operator syntax--assignment syntax--js'],\n        openTags: []\n      }, {\n        position: Point(0, 10),\n        closeTags: [],\n        openTags: ['syntax--constant syntax--numeric syntax--decimal syntax--js']\n      }, {\n        position: Point(0, 11),\n        closeTags: ['syntax--constant syntax--numeric syntax--decimal syntax--js'],\n        openTags: []\n      }, {\n        position: Point(0, 12),\n        closeTags: [],\n        openTags: ['syntax--comment syntax--block syntax--js', 'syntax--punctuation syntax--definition syntax--comment syntax--begin syntax--js']\n      }, {\n        position: Point(0, 14),\n        closeTags: ['syntax--punctuation syntax--definition syntax--comment syntax--begin syntax--js'],\n        openTags: []\n      }, {\n        position: Point(1, 5),\n        closeTags: [],\n        openTags: ['syntax--punctuation syntax--definition syntax--comment syntax--end syntax--js']\n      }, {\n        position: Point(1, 7),\n        closeTags: ['syntax--punctuation syntax--definition syntax--comment syntax--end syntax--js', 'syntax--comment syntax--block syntax--js'],\n        openTags: ['syntax--storage syntax--type syntax--var syntax--js']\n      }, {\n        position: Point(1, 10),\n        closeTags: ['syntax--storage syntax--type syntax--var syntax--js'],\n        openTags: []\n      }, {\n        position: Point(1, 15),\n        closeTags: [],\n        openTags: ['syntax--keyword syntax--operator syntax--assignment syntax--js']\n      }, {\n        position: Point(1, 16),\n        closeTags: ['syntax--keyword syntax--operator syntax--assignment syntax--js'],\n        openTags: []\n      }, {\n        position: Point(1, 17),\n        closeTags: [],\n        openTags: ['syntax--constant syntax--numeric syntax--decimal syntax--js']\n      }, {\n        position: Point(1, 18),\n        closeTags: ['syntax--constant syntax--numeric syntax--decimal syntax--js'],\n        openTags: []\n      }];\n\n      while (true) {\n        const boundary = {\n          position: iterator.getPosition(),\n          closeTags: iterator.getCloseScopeIds().map(scopeId => languageMode.classNameForScopeId(scopeId)),\n          openTags: iterator.getOpenScopeIds().map(scopeId => languageMode.classNameForScopeId(scopeId))\n        };\n        expect(boundary).toEqual(expectedBoundaries.shift());\n\n        if (!iterator.moveToSuccessor()) {\n          break;\n        }\n      }\n\n      expect(iterator.seek(Point(0, 1)).map(scopeId => languageMode.classNameForScopeId(scopeId))).toEqual(['syntax--source syntax--js', 'syntax--storage syntax--type syntax--var syntax--js']);\n      expect(iterator.getPosition()).toEqual(Point(0, 3));\n      expect(iterator.seek(Point(0, 8)).map(scopeId => languageMode.classNameForScopeId(scopeId))).toEqual(['syntax--source syntax--js']);\n      expect(iterator.getPosition()).toEqual(Point(0, 8));\n      expect(iterator.seek(Point(1, 0)).map(scopeId => languageMode.classNameForScopeId(scopeId))).toEqual(['syntax--source syntax--js', 'syntax--comment syntax--block syntax--js']);\n      expect(iterator.getPosition()).toEqual(Point(1, 0));\n      expect(iterator.seek(Point(1, 18)).map(scopeId => languageMode.classNameForScopeId(scopeId))).toEqual(['syntax--source syntax--js', 'syntax--constant syntax--numeric syntax--decimal syntax--js']);\n      expect(iterator.getPosition()).toEqual(Point(1, 18));\n      expect(iterator.seek(Point(2, 0)).map(scopeId => languageMode.classNameForScopeId(scopeId))).toEqual(['syntax--source syntax--js']);\n      iterator.moveToSuccessor();\n    }); // ensure we don't infinitely loop (regression test)",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not report columns beyond the length of the line",
            "suites": [
                "TextMateLanguageMode",
                ".buildHighlightIterator"
            ],
            "updatePoint": {
                "line": 590,
                "column": 61
            },
            "line": 590,
            "code": "    it('does not report columns beyond the length of the line', async () => {\n      await atom.packages.activatePackage('language-coffee-script');\n      buffer = new TextBuffer({\n        text: '# hello\\n# world'\n      });\n      languageMode = new TextMateLanguageMode({\n        buffer,\n        config,\n        grammar: atom.grammars.grammarForScopeName('source.coffee')\n      });\n      fullyTokenize(languageMode);\n      const iterator = languageMode.buildHighlightIterator();\n      iterator.seek(Point(0, 0));\n      iterator.moveToSuccessor();\n      iterator.moveToSuccessor();\n      expect(iterator.getPosition().column).toBe(7);\n      iterator.moveToSuccessor();\n      expect(iterator.getPosition().column).toBe(0);\n      iterator.seek(Point(0, 7));\n      expect(iterator.getPosition().column).toBe(7);\n      iterator.seek(Point(0, 8));\n      expect(iterator.getPosition().column).toBe(7);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly terminates scopes at the beginning of the line (regression)",
            "suites": [
                "TextMateLanguageMode",
                ".buildHighlightIterator"
            ],
            "updatePoint": {
                "line": 613,
                "column": 77
            },
            "line": 613,
            "code": "    it('correctly terminates scopes at the beginning of the line (regression)', () => {\n      const grammar = atom.grammars.createGrammar('test', {\n        scopeName: 'text.broken',\n        name: 'Broken grammar',\n        patterns: [{\n          begin: 'start',\n          end: '(?=end)',\n          name: 'blue.broken'\n        }, {\n          match: '.',\n          name: 'yellow.broken'\n        }]\n      });\n      buffer = new TextBuffer({\n        text: 'start x\\nend x\\nx'\n      });\n      languageMode = new TextMateLanguageMode({\n        buffer,\n        config,\n        grammar\n      });\n      fullyTokenize(languageMode);\n      const iterator = languageMode.buildHighlightIterator();\n      iterator.seek(Point(1, 0));\n      expect(iterator.getPosition()).toEqual([1, 0]);\n      expect(iterator.getCloseScopeIds().map(scopeId => languageMode.classNameForScopeId(scopeId))).toEqual(['syntax--blue syntax--broken']);\n      expect(iterator.getOpenScopeIds().map(scopeId => languageMode.classNameForScopeId(scopeId))).toEqual(['syntax--yellow syntax--broken']);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "seeks to the leftmost tag boundary greater than or equal to the given position and returns the containing tags",
            "suites": [
                "TextMateLanguageMode",
                ".buildHighlightIterator",
                "TextMateHighlightIterator.seek(position)"
            ],
            "updatePoint": {
                "line": 642,
                "column": 120
            },
            "line": 642,
            "code": "      it('seeks to the leftmost tag boundary greater than or equal to the given position and returns the containing tags', function () {\n        const languageMode = {\n          tokenizedLineForRow(row) {\n            if (row === 0) {\n              return {\n                tags: [-1, -2, -3, -4, -5, 3, -3, -4, -6, -5, 4, -6, -3, -4],\n                text: 'foo bar',\n                openScopes: []\n              };\n            } else {\n              return null;\n            }\n          }\n\n        };\n        const iterator = new TextMateHighlightIterator(languageMode);\n        expect(iterator.seek(Point(0, 0))).toEqual([]);\n        expect(iterator.getPosition()).toEqual(Point(0, 0));\n        expect(iterator.getCloseScopeIds()).toEqual([]);\n        expect(iterator.getOpenScopeIds()).toEqual([257]);\n        iterator.moveToSuccessor();\n        expect(iterator.getCloseScopeIds()).toEqual([257]);\n        expect(iterator.getOpenScopeIds()).toEqual([259]);\n        expect(iterator.seek(Point(0, 1))).toEqual([261]);\n        expect(iterator.getPosition()).toEqual(Point(0, 3));\n        expect(iterator.getCloseScopeIds()).toEqual([]);\n        expect(iterator.getOpenScopeIds()).toEqual([259]);\n        iterator.moveToSuccessor();\n        expect(iterator.getPosition()).toEqual(Point(0, 3));\n        expect(iterator.getCloseScopeIds()).toEqual([259, 261]);\n        expect(iterator.getOpenScopeIds()).toEqual([261]);\n        expect(iterator.seek(Point(0, 3))).toEqual([261]);\n        expect(iterator.getPosition()).toEqual(Point(0, 3));\n        expect(iterator.getCloseScopeIds()).toEqual([]);\n        expect(iterator.getOpenScopeIds()).toEqual([259]);\n        iterator.moveToSuccessor();\n        expect(iterator.getPosition()).toEqual(Point(0, 3));\n        expect(iterator.getCloseScopeIds()).toEqual([259, 261]);\n        expect(iterator.getOpenScopeIds()).toEqual([261]);\n        iterator.moveToSuccessor();\n        expect(iterator.getPosition()).toEqual(Point(0, 7));\n        expect(iterator.getCloseScopeIds()).toEqual([261]);\n        expect(iterator.getOpenScopeIds()).toEqual([259]);\n        iterator.moveToSuccessor();\n        expect(iterator.getPosition()).toEqual(Point(0, 7));\n        expect(iterator.getCloseScopeIds()).toEqual([259]);\n        expect(iterator.getOpenScopeIds()).toEqual([]);\n        iterator.moveToSuccessor();\n        expect(iterator.getPosition()).toEqual(Point(1, 0));\n        expect(iterator.getCloseScopeIds()).toEqual([]);\n        expect(iterator.getOpenScopeIds()).toEqual([]);\n        expect(iterator.seek(Point(0, 5))).toEqual([261]);\n        expect(iterator.getPosition()).toEqual(Point(0, 7));\n        expect(iterator.getCloseScopeIds()).toEqual([261]);\n        expect(iterator.getOpenScopeIds()).toEqual([259]);\n        iterator.moveToSuccessor();\n        expect(iterator.getPosition()).toEqual(Point(0, 7));\n        expect(iterator.getCloseScopeIds()).toEqual([259]);\n        expect(iterator.getOpenScopeIds()).toEqual([]);\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reports two boundaries at the same position when tags close, open, then close again without a non-negative integer separating them (regression)",
            "suites": [
                "TextMateLanguageMode",
                ".buildHighlightIterator",
                "TextMateHighlightIterator.moveToSuccessor()"
            ],
            "updatePoint": {
                "line": 704,
                "column": 153
            },
            "line": 704,
            "code": "      it('reports two boundaries at the same position when tags close, open, then close again without a non-negative integer separating them (regression)', () => {\n        const languageMode = {\n          tokenizedLineForRow() {\n            return {\n              tags: [-1, -2, -1, -2],\n              text: '',\n              openScopes: []\n            };\n          }\n\n        };\n        const iterator = new TextMateHighlightIterator(languageMode);\n        iterator.seek(Point(0, 0));\n        expect(iterator.getPosition()).toEqual(Point(0, 0));\n        expect(iterator.getCloseScopeIds()).toEqual([]);\n        expect(iterator.getOpenScopeIds()).toEqual([257]);\n        iterator.moveToSuccessor();\n        expect(iterator.getPosition()).toEqual(Point(0, 0));\n        expect(iterator.getCloseScopeIds()).toEqual([257]);\n        expect(iterator.getOpenScopeIds()).toEqual([257]);\n        iterator.moveToSuccessor();\n        expect(iterator.getCloseScopeIds()).toEqual([257]);\n        expect(iterator.getOpenScopeIds()).toEqual([]);\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "bases indentation off of the previous non-blank line",
            "suites": [
                "TextMateLanguageMode",
                ".suggestedIndentForBufferRow",
                "javascript"
            ],
            "updatePoint": {
                "line": 739,
                "column": 62
            },
            "line": 739,
            "code": "      it('bases indentation off of the previous non-blank line', () => {\n        expect(editor.suggestedIndentForBufferRow(0)).toBe(0);\n        expect(editor.suggestedIndentForBufferRow(1)).toBe(1);\n        expect(editor.suggestedIndentForBufferRow(2)).toBe(2);\n        expect(editor.suggestedIndentForBufferRow(5)).toBe(3);\n        expect(editor.suggestedIndentForBufferRow(7)).toBe(2);\n        expect(editor.suggestedIndentForBufferRow(9)).toBe(1);\n        expect(editor.suggestedIndentForBufferRow(11)).toBe(1);\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not take invisibles into account",
            "suites": [
                "TextMateLanguageMode",
                ".suggestedIndentForBufferRow",
                "javascript"
            ],
            "updatePoint": {
                "line": 748,
                "column": 47
            },
            "line": 748,
            "code": "      it('does not take invisibles into account', () => {\n        editor.update({\n          showInvisibles: true\n        });\n        expect(editor.suggestedIndentForBufferRow(0)).toBe(0);\n        expect(editor.suggestedIndentForBufferRow(1)).toBe(1);\n        expect(editor.suggestedIndentForBufferRow(2)).toBe(2);\n        expect(editor.suggestedIndentForBufferRow(5)).toBe(3);\n        expect(editor.suggestedIndentForBufferRow(7)).toBe(2);\n        expect(editor.suggestedIndentForBufferRow(9)).toBe(1);\n        expect(editor.suggestedIndentForBufferRow(11)).toBe(1);\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not return negative values (regression)",
            "suites": [
                "TextMateLanguageMode",
                ".suggestedIndentForBufferRow",
                "css"
            ],
            "updatePoint": {
                "line": 769,
                "column": 54
            },
            "line": 769,
            "code": "      it('does not return negative values (regression)', () => {\n        editor.setText('.test {\\npadding: 0;\\n}');\n        expect(editor.suggestedIndentForBufferRow(2)).toBe(0);\n      });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes the first line of multi-line comments",
            "suites": [
                "TextMateLanguageMode",
                ".isFoldableAtRow(row)"
            ],
            "updatePoint": {
                "line": 789,
                "column": 54
            },
            "line": 789,
            "code": "    it('includes the first line of multi-line comments', () => {\n      expect(languageMode.isFoldableAtRow(0)).toBe(true);\n      expect(languageMode.isFoldableAtRow(1)).toBe(false);\n      expect(languageMode.isFoldableAtRow(2)).toBe(false);\n      expect(languageMode.isFoldableAtRow(3)).toBe(true); // because of indent\n\n      expect(languageMode.isFoldableAtRow(13)).toBe(true);\n      expect(languageMode.isFoldableAtRow(14)).toBe(false);\n      expect(languageMode.isFoldableAtRow(15)).toBe(false);\n      expect(languageMode.isFoldableAtRow(16)).toBe(false);\n      buffer.insert([0, Infinity], '\\n');\n      expect(languageMode.isFoldableAtRow(0)).toBe(false);\n      expect(languageMode.isFoldableAtRow(1)).toBe(false);\n      expect(languageMode.isFoldableAtRow(2)).toBe(true);\n      expect(languageMode.isFoldableAtRow(3)).toBe(false);\n      buffer.undo();\n      expect(languageMode.isFoldableAtRow(0)).toBe(true);\n      expect(languageMode.isFoldableAtRow(1)).toBe(false);\n      expect(languageMode.isFoldableAtRow(2)).toBe(false);\n      expect(languageMode.isFoldableAtRow(3)).toBe(true);\n    }); // because of indent",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes non-comment lines that precede an increase in indentation",
            "suites": [
                "TextMateLanguageMode",
                ".isFoldableAtRow(row)"
            ],
            "updatePoint": {
                "line": 811,
                "column": 74
            },
            "line": 811,
            "code": "    it('includes non-comment lines that precede an increase in indentation', () => {\n      buffer.insert([2, 0], '  '); // commented lines preceding an indent aren't foldable\n\n      expect(languageMode.isFoldableAtRow(1)).toBe(false);\n      expect(languageMode.isFoldableAtRow(2)).toBe(false);\n      expect(languageMode.isFoldableAtRow(3)).toBe(true);\n      expect(languageMode.isFoldableAtRow(4)).toBe(true);\n      expect(languageMode.isFoldableAtRow(5)).toBe(false);\n      expect(languageMode.isFoldableAtRow(6)).toBe(false);\n      expect(languageMode.isFoldableAtRow(7)).toBe(true);\n      expect(languageMode.isFoldableAtRow(8)).toBe(false);\n      buffer.insert([7, 0], '  ');\n      expect(languageMode.isFoldableAtRow(6)).toBe(true);\n      expect(languageMode.isFoldableAtRow(7)).toBe(false);\n      expect(languageMode.isFoldableAtRow(8)).toBe(false);\n      buffer.undo();\n      expect(languageMode.isFoldableAtRow(6)).toBe(false);\n      expect(languageMode.isFoldableAtRow(7)).toBe(true);\n      expect(languageMode.isFoldableAtRow(8)).toBe(false);\n      buffer.insert([7, 0], '    \\n      x\\n');\n      expect(languageMode.isFoldableAtRow(6)).toBe(true);\n      expect(languageMode.isFoldableAtRow(7)).toBe(false);\n      expect(languageMode.isFoldableAtRow(8)).toBe(false);\n      buffer.insert([9, 0], '  ');\n      expect(languageMode.isFoldableAtRow(6)).toBe(true);\n      expect(languageMode.isFoldableAtRow(7)).toBe(false);\n      expect(languageMode.isFoldableAtRow(8)).toBe(false);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true if the line starts a multi-line comment",
            "suites": [
                "TextMateLanguageMode",
                ".isFoldableAtRow(row)"
            ],
            "updatePoint": {
                "line": 839,
                "column": 60
            },
            "line": 839,
            "code": "    it('returns true if the line starts a multi-line comment', async () => {\n      editor = await atom.workspace.open('sample-with-comments.js');\n      fullyTokenize(editor.getBuffer().getLanguageMode());\n      expect(editor.isFoldableAtBufferRow(1)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(6)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(8)).toBe(false);\n      expect(editor.isFoldableAtBufferRow(11)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(15)).toBe(false);\n      expect(editor.isFoldableAtBufferRow(17)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(21)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(24)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(28)).toBe(false);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true for lines that end with a comment and are followed by an indented line",
            "suites": [
                "TextMateLanguageMode",
                ".isFoldableAtRow(row)"
            ],
            "updatePoint": {
                "line": 852,
                "column": 91
            },
            "line": 852,
            "code": "    it('returns true for lines that end with a comment and are followed by an indented line', async () => {\n      editor = await atom.workspace.open('sample-with-comments.js');\n      expect(editor.isFoldableAtBufferRow(5)).toBe(true);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not return true for a line in the middle of a comment that's followed by an indented line",
            "suites": [
                "TextMateLanguageMode",
                ".isFoldableAtRow(row)"
            ],
            "updatePoint": {
                "line": 856,
                "column": 102
            },
            "line": 856,
            "code": "    it(\"does not return true for a line in the middle of a comment that's followed by an indented line\", async () => {\n      editor = await atom.workspace.open('sample-with-comments.js');\n      fullyTokenize(editor.getBuffer().getLanguageMode());\n      expect(editor.isFoldableAtBufferRow(7)).toBe(false);\n      editor.buffer.insert([8, 0], '  ');\n      expect(editor.isFoldableAtBufferRow(7)).toBe(false);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the ranges that can be folded at the given indent level",
            "suites": [
                "TextMateLanguageMode",
                ".getFoldableRangesAtIndentLevel"
            ],
            "updatePoint": {
                "line": 866,
                "column": 71
            },
            "line": 866,
            "code": "    it('returns the ranges that can be folded at the given indent level', () => {\n      buffer = new TextBuffer(dedent`\n        if (a) {\n          b();\n          if (c) {\n            d()\n            if (e) {\n              f()\n            }\n            g()\n          }\n          h()\n        }\n        i()\n        if (j) {\n          k()\n        }\n      `);\n      languageMode = new TextMateLanguageMode({\n        buffer,\n        config\n      });\n      expect(simulateFold(languageMode.getFoldableRangesAtIndentLevel(0, 2))).toBe(dedent`\n        if (a) {⋯\n        }\n        i()\n        if (j) {⋯\n        }\n      `);\n      expect(simulateFold(languageMode.getFoldableRangesAtIndentLevel(1, 2))).toBe(dedent`\n        if (a) {\n          b();\n          if (c) {⋯\n          }\n          h()\n        }\n        i()\n        if (j) {\n          k()\n        }\n      `);\n      expect(simulateFold(languageMode.getFoldableRangesAtIndentLevel(2, 2))).toBe(dedent`\n        if (a) {\n          b();\n          if (c) {\n            d()\n            if (e) {⋯\n            }\n            g()\n          }\n          h()\n        }\n        i()\n        if (j) {\n          k()\n        }\n      `);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "folds every foldable range at a given indentLevel",
            "suites": [
                "TextMateLanguageMode",
                ".getFoldableRangesAtIndentLevel"
            ],
            "updatePoint": {
                "line": 924,
                "column": 57
            },
            "line": 924,
            "code": "    it('folds every foldable range at a given indentLevel', async () => {\n      editor = await atom.workspace.open('sample-with-comments.js');\n      fullyTokenize(editor.getBuffer().getLanguageMode());\n      editor.foldAllAtIndentLevel(2);\n      const folds = editor.unfoldAll();\n      expect(folds.length).toBe(5);\n      expect([folds[0].start.row, folds[0].end.row]).toEqual([6, 8]);\n      expect([folds[1].start.row, folds[1].end.row]).toEqual([11, 16]);\n      expect([folds[2].start.row, folds[2].end.row]).toEqual([17, 20]);\n      expect([folds[3].start.row, folds[3].end.row]).toEqual([21, 22]);\n      expect([folds[4].start.row, folds[4].end.row]).toEqual([24, 25]);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the ranges that can be folded",
            "suites": [
                "TextMateLanguageMode",
                ".getFoldableRanges"
            ],
            "updatePoint": {
                "line": 938,
                "column": 45
            },
            "line": 938,
            "code": "    it('returns the ranges that can be folded', () => {\n      buffer = new TextBuffer(dedent`\n        if (a) {\n          b();\n          if (c) {\n            d()\n            if (e) {\n              f()\n            }\n            g()\n          }\n          h()\n        }\n        i()\n        if (j) {\n          k()\n        }\n      `);\n      languageMode = new TextMateLanguageMode({\n        buffer,\n        config\n      });\n      expect(languageMode.getFoldableRanges(2).map(r => r.toString())).toEqual([...languageMode.getFoldableRangesAtIndentLevel(0, 2), ...languageMode.getFoldableRangesAtIndentLevel(1, 2), ...languageMode.getFoldableRangesAtIndentLevel(2, 2)].sort((a, b) => a.start.row - b.start.row || a.end.row - b.end.row).map(r => r.toString()));\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works with multi-line comments",
            "suites": [
                "TextMateLanguageMode",
                ".getFoldableRanges"
            ],
            "updatePoint": {
                "line": 962,
                "column": 38
            },
            "line": 962,
            "code": "    it('works with multi-line comments', async () => {\n      await atom.packages.activatePackage('language-javascript');\n      const editor = await atom.workspace.open('sample-with-comments.js', {\n        autoIndent: false\n      });\n      fullyTokenize(editor.getBuffer().getLanguageMode());\n      editor.foldAll();\n      const folds = editor.unfoldAll();\n      expect(folds.length).toBe(8);\n      expect([folds[0].start.row, folds[0].end.row]).toEqual([0, 30]);\n      expect([folds[1].start.row, folds[1].end.row]).toEqual([1, 4]);\n      expect([folds[2].start.row, folds[2].end.row]).toEqual([5, 27]);\n      expect([folds[3].start.row, folds[3].end.row]).toEqual([6, 8]);\n      expect([folds[4].start.row, folds[4].end.row]).toEqual([11, 16]);\n      expect([folds[5].start.row, folds[5].end.row]).toEqual([17, 20]);\n      expect([folds[6].start.row, folds[6].end.row]).toEqual([21, 22]);\n      expect([folds[7].start.row, folds[7].end.row]).toEqual([24, 25]);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the range for the smallest fold that contains the given range",
            "suites": [
                "TextMateLanguageMode",
                ".getFoldableRangeContainingPoint"
            ],
            "updatePoint": {
                "line": 982,
                "column": 77
            },
            "line": 982,
            "code": "    it('returns the range for the smallest fold that contains the given range', () => {\n      buffer = new TextBuffer(dedent`\n        if (a) {\n          b();\n          if (c) {\n            d()\n            if (e) {\n              f()\n            }\n            g()\n          }\n          h()\n        }\n        i()\n        if (j) {\n          k()\n        }\n      `);\n      languageMode = new TextMateLanguageMode({\n        buffer,\n        config\n      });\n      expect(languageMode.getFoldableRangeContainingPoint(Point(0, 5), 2)).toBeNull();\n      let range = languageMode.getFoldableRangeContainingPoint(Point(0, 10), 2);\n      expect(simulateFold([range])).toBe(dedent`\n        if (a) {⋯\n        }\n        i()\n        if (j) {\n          k()\n        }\n      `);\n      range = languageMode.getFoldableRangeContainingPoint(Point(7, 0), 2);\n      expect(simulateFold([range])).toBe(dedent`\n        if (a) {\n          b();\n          if (c) {⋯\n          }\n          h()\n        }\n        i()\n        if (j) {\n          k()\n        }\n      `);\n      range = languageMode.getFoldableRangeContainingPoint(Point(1, Infinity), 2);\n      expect(simulateFold([range])).toBe(dedent`\n        if (a) {⋯\n        }\n        i()\n        if (j) {\n          k()\n        }\n      `);\n      range = languageMode.getFoldableRangeContainingPoint(Point(2, 20), 2);\n      expect(simulateFold([range])).toBe(dedent`\n        if (a) {\n          b();\n          if (c) {⋯\n          }\n          h()\n        }\n        i()\n        if (j) {\n          k()\n        }\n      `);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works for coffee-script",
            "suites": [
                "TextMateLanguageMode",
                ".getFoldableRangeContainingPoint"
            ],
            "updatePoint": {
                "line": 1050,
                "column": 31
            },
            "line": 1050,
            "code": "    it('works for coffee-script', async () => {\n      const editor = await atom.workspace.open('coffee.coffee');\n      await atom.packages.activatePackage('language-coffee-script');\n      buffer = editor.buffer;\n      languageMode = editor.languageMode;\n      expect(languageMode.getFoldableRangeContainingPoint(Point(0, Infinity), 2)).toEqual([[0, Infinity], [20, Infinity]]);\n      expect(languageMode.getFoldableRangeContainingPoint(Point(1, Infinity), 2)).toEqual([[1, Infinity], [17, Infinity]]);\n      expect(languageMode.getFoldableRangeContainingPoint(Point(2, Infinity), 2)).toEqual([[1, Infinity], [17, Infinity]]);\n      expect(languageMode.getFoldableRangeContainingPoint(Point(19, Infinity), 2)).toEqual([[19, Infinity], [20, Infinity]]);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works for javascript",
            "suites": [
                "TextMateLanguageMode",
                ".getFoldableRangeContainingPoint"
            ],
            "updatePoint": {
                "line": 1060,
                "column": 28
            },
            "line": 1060,
            "code": "    it('works for javascript', async () => {\n      const editor = await atom.workspace.open('sample.js');\n      await atom.packages.activatePackage('language-javascript');\n      buffer = editor.buffer;\n      languageMode = editor.languageMode;\n      expect(editor.languageMode.getFoldableRangeContainingPoint(Point(0, Infinity), 2)).toEqual([[0, Infinity], [12, Infinity]]);\n      expect(editor.languageMode.getFoldableRangeContainingPoint(Point(1, Infinity), 2)).toEqual([[1, Infinity], [9, Infinity]]);\n      expect(editor.languageMode.getFoldableRangeContainingPoint(Point(2, Infinity), 2)).toEqual([[1, Infinity], [9, Infinity]]);\n      expect(editor.languageMode.getFoldableRangeContainingPoint(Point(4, Infinity), 2)).toEqual([[4, Infinity], [7, Infinity]]);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "searches upward and downward for surrounding comment lines and folds them as a single fold",
            "suites": [
                "TextMateLanguageMode",
                ".getFoldableRangeContainingPoint"
            ],
            "updatePoint": {
                "line": 1070,
                "column": 98
            },
            "line": 1070,
            "code": "    it('searches upward and downward for surrounding comment lines and folds them as a single fold', async () => {\n      await atom.packages.activatePackage('language-javascript');\n      const editor = await atom.workspace.open('sample-with-comments.js');\n      editor.buffer.insert([1, 0], '  //this is a comment\\n  // and\\n  //more docs\\n\\n//second comment');\n      fullyTokenize(editor.getBuffer().getLanguageMode());\n      editor.foldBufferRow(1);\n      const [fold] = editor.unfoldAll();\n      expect([fold.start.row, fold.end.row]).toEqual([1, 3]);\n    });",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly terminates scopes at the beginning of the line (regression)",
            "suites": [
                "TextMateLanguageMode",
                "TokenIterator"
            ],
            "updatePoint": {
                "line": 1080,
                "column": 107
            },
            "line": 1080,
            "code": "  describe('TokenIterator', () => it('correctly terminates scopes at the beginning of the line (regression)', () => {\n    const grammar = atom.grammars.createGrammar('test', {\n      scopeName: 'text.broken',\n      name: 'Broken grammar',\n      patterns: [{\n        begin: 'start',\n        end: '(?=end)',\n        name: 'blue.broken'\n      }, {\n        match: '.',\n        name: 'yellow.broken'\n      }]\n    });\n    const buffer = new TextBuffer({\n      text: dedent`\n        start x\n        end x\n        x\n      `\n    });\n    const languageMode = new TextMateLanguageMode({\n      buffer,\n      grammar,\n      config: atom.config,\n      grammarRegistry: atom.grammars,\n      packageManager: atom.packages,\n      assert: atom.assert\n    });\n    fullyTokenize(languageMode);\n    const tokenIterator = languageMode.tokenizedLineForRow(1).getTokenIterator();\n    tokenIterator.next();\n    expect(tokenIterator.getBufferStart()).toBe(0);\n    expect(tokenIterator.getScopeEnds()).toEqual([]);\n    expect(tokenIterator.getScopeStarts()).toEqual(['text.broken', 'yellow.broken']);\n  }));",
            "file": "text-mate-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true when the string contains a surrogate pair, variation sequence, or combined character",
            "suites": [
                "text utilities",
                ".hasPairedCharacter(string)"
            ],
            "updatePoint": {
                "line": 4,
                "column": 149
            },
            "line": 4,
            "code": "  describe('.hasPairedCharacter(string)', () => it('returns true when the string contains a surrogate pair, variation sequence, or combined character', () => {\n    expect(textUtils.hasPairedCharacter('abc')).toBe(false);\n    expect(textUtils.hasPairedCharacter('a\\uD835\\uDF97b\\uD835\\uDF97c')).toBe(true);\n    expect(textUtils.hasPairedCharacter('\\uD835\\uDF97')).toBe(true);\n    expect(textUtils.hasPairedCharacter('\\u2714\\uFE0E')).toBe(true);\n    expect(textUtils.hasPairedCharacter('e\\u0301')).toBe(true);\n    expect(textUtils.hasPairedCharacter('\\uD835')).toBe(false);\n    expect(textUtils.hasPairedCharacter('\\uDF97')).toBe(false);\n    expect(textUtils.hasPairedCharacter('\\uFE0E')).toBe(false);\n    expect(textUtils.hasPairedCharacter('\\u0301')).toBe(false);\n    expect(textUtils.hasPairedCharacter('\\uFE0E\\uFE0E')).toBe(false);\n    expect(textUtils.hasPairedCharacter('\\u0301\\u0301')).toBe(false);\n  }));",
            "file": "text-utils-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true when the index is the start of a high/low surrogate pair, variation sequence, or combined character",
            "suites": [
                "text utilities",
                ".isPairedCharacter(string, index)"
            ],
            "updatePoint": {
                "line": 17,
                "column": 170
            },
            "line": 17,
            "code": "  describe('.isPairedCharacter(string, index)', () => it('returns true when the index is the start of a high/low surrogate pair, variation sequence, or combined character', () => {\n    expect(textUtils.isPairedCharacter('a\\uD835\\uDF97b\\uD835\\uDF97c', 0)).toBe(false);\n    expect(textUtils.isPairedCharacter('a\\uD835\\uDF97b\\uD835\\uDF97c', 1)).toBe(true);\n    expect(textUtils.isPairedCharacter('a\\uD835\\uDF97b\\uD835\\uDF97c', 2)).toBe(false);\n    expect(textUtils.isPairedCharacter('a\\uD835\\uDF97b\\uD835\\uDF97c', 3)).toBe(false);\n    expect(textUtils.isPairedCharacter('a\\uD835\\uDF97b\\uD835\\uDF97c', 4)).toBe(true);\n    expect(textUtils.isPairedCharacter('a\\uD835\\uDF97b\\uD835\\uDF97c', 5)).toBe(false);\n    expect(textUtils.isPairedCharacter('a\\uD835\\uDF97b\\uD835\\uDF97c', 6)).toBe(false);\n    expect(textUtils.isPairedCharacter('a\\u2714\\uFE0E', 0)).toBe(false);\n    expect(textUtils.isPairedCharacter('a\\u2714\\uFE0E', 1)).toBe(true);\n    expect(textUtils.isPairedCharacter('a\\u2714\\uFE0E', 2)).toBe(false);\n    expect(textUtils.isPairedCharacter('a\\u2714\\uFE0E', 3)).toBe(false);\n    expect(textUtils.isPairedCharacter('\\uD835')).toBe(false);\n    expect(textUtils.isPairedCharacter('\\uDF97')).toBe(false);\n    expect(textUtils.isPairedCharacter('\\uFE0E')).toBe(false);\n    expect(textUtils.isPairedCharacter('\\uFE0E')).toBe(false);\n    expect(textUtils.isPairedCharacter('\\uFE0E\\uFE0E')).toBe(false);\n    expect(textUtils.isPairedCharacter('ae\\u0301c', 0)).toBe(false);\n    expect(textUtils.isPairedCharacter('ae\\u0301c', 1)).toBe(true);\n    expect(textUtils.isPairedCharacter('ae\\u0301c', 2)).toBe(false);\n    expect(textUtils.isPairedCharacter('ae\\u0301c', 3)).toBe(false);\n    expect(textUtils.isPairedCharacter('ae\\u0301c', 4)).toBe(false);\n  }));",
            "file": "text-utils-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true when the character is either japanese, chinese or a full width form",
            "suites": [
                "text utilities",
                ".isDoubleWidthCharacter(character)"
            ],
            "updatePoint": {
                "line": 40,
                "column": 139
            },
            "line": 40,
            "code": "  describe('.isDoubleWidthCharacter(character)', () => it('returns true when the character is either japanese, chinese or a full width form', () => {\n    expect(textUtils.isDoubleWidthCharacter('我')).toBe(true);\n    expect(textUtils.isDoubleWidthCharacter('私')).toBe(true);\n    expect(textUtils.isDoubleWidthCharacter('Ｂ')).toBe(true);\n    expect(textUtils.isDoubleWidthCharacter('，')).toBe(true);\n    expect(textUtils.isDoubleWidthCharacter('￠')).toBe(true);\n    expect(textUtils.isDoubleWidthCharacter('a')).toBe(false);\n  }));",
            "file": "text-utils-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true when the character is an half width form",
            "suites": [
                "text utilities",
                ".isHalfWidthCharacter(character)"
            ],
            "updatePoint": {
                "line": 48,
                "column": 110
            },
            "line": 48,
            "code": "  describe('.isHalfWidthCharacter(character)', () => it('returns true when the character is an half width form', () => {\n    expect(textUtils.isHalfWidthCharacter('ﾊ')).toBe(true);\n    expect(textUtils.isHalfWidthCharacter('ﾋ')).toBe(true);\n    expect(textUtils.isHalfWidthCharacter('ﾬ')).toBe(true);\n    expect(textUtils.isHalfWidthCharacter('￭')).toBe(true);\n    expect(textUtils.isHalfWidthCharacter('B')).toBe(false);\n  }));",
            "file": "text-utils-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true when the character is a korean character",
            "suites": [
                "text utilities",
                ".isKoreanCharacter(character)"
            ],
            "updatePoint": {
                "line": 55,
                "column": 107
            },
            "line": 55,
            "code": "  describe('.isKoreanCharacter(character)', () => it('returns true when the character is a korean character', () => {\n    expect(textUtils.isKoreanCharacter('우')).toBe(true);\n    expect(textUtils.isKoreanCharacter('가')).toBe(true);\n    expect(textUtils.isKoreanCharacter('ㅢ')).toBe(true);\n    expect(textUtils.isKoreanCharacter('ㄼ')).toBe(true);\n    expect(textUtils.isKoreanCharacter('O')).toBe(false);\n  }));",
            "file": "text-utils-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true when the character is CJK or when the previous character is a space/tab",
            "suites": [
                "text utilities",
                ".isWrapBoundary(previousCharacter, character)"
            ],
            "updatePoint": {
                "line": 62,
                "column": 154
            },
            "line": 62,
            "code": "  describe('.isWrapBoundary(previousCharacter, character)', () => it('returns true when the character is CJK or when the previous character is a space/tab', () => {\n    const anyCharacter = 'x';\n    expect(textUtils.isWrapBoundary(anyCharacter, '我')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, '私')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, 'Ｂ')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, '，')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, '￠')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, 'ﾊ')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, 'ﾋ')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, 'ﾬ')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, '￭')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, '우')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, '가')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, 'ㅢ')).toBe(true);\n    expect(textUtils.isWrapBoundary(anyCharacter, 'ㄼ')).toBe(true);\n    expect(textUtils.isWrapBoundary(' ', 'h')).toBe(true);\n    expect(textUtils.isWrapBoundary('\\t', 'h')).toBe(true);\n    expect(textUtils.isWrapBoundary('a', 'h')).toBe(false);\n  }));",
            "file": "text-utils-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gets all the loaded themes",
            "suites": [
                "atom.themes",
                "theme getters and setters",
                "getLoadedThemes"
            ],
            "updatePoint": {
                "line": 26,
                "column": 68
            },
            "line": 26,
            "code": "    describe('getLoadedThemes', () => it('gets all the loaded themes', function () {\n      const themes = atom.themes.getLoadedThemes();\n      expect(themes.length).toBeGreaterThan(2);\n    }));",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "gets all the active themes",
            "suites": [
                "atom.themes",
                "theme getters and setters",
                "getActiveThemes"
            ],
            "updatePoint": {
                "line": 30,
                "column": 68
            },
            "line": 30,
            "code": "    describe('getActiveThemes', () => it('gets all the active themes', function () {\n      waitsForPromise(() => atom.themes.activateThemes());\n      runs(function () {\n        const names = atom.config.get('core.themes');\n        expect(names.length).toBeGreaterThan(0);\n        const themes = atom.themes.getActiveThemes();\n        expect(themes).toHaveLength(names.length);\n      });\n    }));",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores theme",
            "suites": [
                "atom.themes",
                "when the core.themes config value contains invalid entry"
            ],
            "updatePoint": {
                "line": 40,
                "column": 94
            },
            "line": 40,
            "code": "  describe('when the core.themes config value contains invalid entry', () => it('ignores theme', function () {\n    atom.config.set('core.themes', ['atom-light-ui', null, undefined, '', false, 4, {}, [], 'atom-dark-ui']);\n    expect(atom.themes.getEnabledThemeNames()).toEqual(['atom-dark-ui', 'atom-light-ui']);\n  }));",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the theme directories before the themes are loaded",
            "suites": [
                "atom.themes",
                "::getImportPaths()"
            ],
            "updatePoint": {
                "line": 45,
                "column": 66
            },
            "line": 45,
            "code": "    it('returns the theme directories before the themes are loaded', function () {\n      atom.config.set('core.themes', ['theme-with-index-less', 'atom-dark-ui', 'atom-light-ui']);\n      const paths = atom.themes.getImportPaths(); // syntax theme is not a dir at this time, so only two.\n\n      expect(paths.length).toBe(2);\n      expect(paths[0]).toContain('atom-light-ui');\n      expect(paths[1]).toContain('atom-dark-ui');\n    });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores themes that cannot be resolved to a directory",
            "suites": [
                "atom.themes",
                "::getImportPaths()"
            ],
            "updatePoint": {
                "line": 53,
                "column": 61
            },
            "line": 53,
            "code": "    it('ignores themes that cannot be resolved to a directory', function () {\n      atom.config.set('core.themes', ['definitely-not-a-theme']);\n      expect(() => atom.themes.getImportPaths()).not.toThrow();\n    });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "add/removes stylesheets to reflect the new config value",
            "suites": [
                "atom.themes",
                "when the core.themes config value changes"
            ],
            "updatePoint": {
                "line": 59,
                "column": 63
            },
            "line": 59,
            "code": "    it('add/removes stylesheets to reflect the new config value', function () {\n      let didChangeActiveThemesHandler;\n      atom.themes.onDidChangeActiveThemes(didChangeActiveThemesHandler = jasmine.createSpy());\n      spyOn(atom.styles, 'getUserStyleSheetPath').andCallFake(() => null);\n      waitsForPromise(() => atom.themes.activateThemes());\n      runs(function () {\n        didChangeActiveThemesHandler.reset();\n        atom.config.set('core.themes', []);\n      });\n      waitsFor('a', () => didChangeActiveThemesHandler.callCount === 1);\n      runs(function () {\n        didChangeActiveThemesHandler.reset();\n        expect(document.querySelectorAll('style.theme')).toHaveLength(0);\n        atom.config.set('core.themes', ['atom-dark-ui']);\n      });\n      waitsFor('b', () => didChangeActiveThemesHandler.callCount === 1);\n      runs(function () {\n        didChangeActiveThemesHandler.reset();\n        expect(document.querySelectorAll('style[priority=\"1\"]')).toHaveLength(2);\n        expect(document.querySelector('style[priority=\"1\"]').getAttribute('source-path')).toMatch(/atom-dark-ui/);\n        atom.config.set('core.themes', ['atom-light-ui', 'atom-dark-ui']);\n      });\n      waitsFor('c', () => didChangeActiveThemesHandler.callCount === 1);\n      runs(function () {\n        didChangeActiveThemesHandler.reset();\n        expect(document.querySelectorAll('style[priority=\"1\"]')).toHaveLength(2);\n        expect(document.querySelectorAll('style[priority=\"1\"]')[0].getAttribute('source-path')).toMatch(/atom-dark-ui/);\n        expect(document.querySelectorAll('style[priority=\"1\"]')[1].getAttribute('source-path')).toMatch(/atom-light-ui/);\n        atom.config.set('core.themes', []);\n      });\n      waitsFor(() => didChangeActiveThemesHandler.callCount === 1);\n      runs(function () {\n        didChangeActiveThemesHandler.reset();\n        expect(document.querySelectorAll('style[priority=\"1\"]')).toHaveLength(2); // atom-dark-ui has a directory path, the syntax one doesn't\n\n        atom.config.set('core.themes', ['theme-with-index-less', 'atom-dark-ui']);\n      });\n      waitsFor(() => didChangeActiveThemesHandler.callCount === 1);\n      runs(function () {\n        expect(document.querySelectorAll('style[priority=\"1\"]')).toHaveLength(2);\n        const importPaths = atom.themes.getImportPaths();\n        expect(importPaths.length).toBe(1);\n        expect(importPaths[0]).toContain('atom-dark-ui');\n      });\n    });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds theme-* classes to the workspace for each active theme",
            "suites": [
                "atom.themes",
                "when the core.themes config value changes"
            ],
            "updatePoint": {
                "line": 104,
                "column": 67
            },
            "line": 104,
            "code": "    it('adds theme-* classes to the workspace for each active theme', function () {\n      atom.config.set('core.themes', ['atom-dark-ui', 'atom-dark-syntax']);\n      let didChangeActiveThemesHandler;\n      atom.themes.onDidChangeActiveThemes(didChangeActiveThemesHandler = jasmine.createSpy());\n      waitsForPromise(() => atom.themes.activateThemes());\n      const workspaceElement = atom.workspace.getElement();\n      runs(function () {\n        expect(workspaceElement).toHaveClass('theme-atom-dark-ui');\n        atom.themes.onDidChangeActiveThemes(didChangeActiveThemesHandler = jasmine.createSpy());\n        atom.config.set('core.themes', ['theme-with-ui-variables', 'theme-with-syntax-variables']);\n      });\n      waitsFor(() => didChangeActiveThemesHandler.callCount > 0);\n      runs(function () {\n        // `theme-` twice as it prefixes the name with `theme-`\n        expect(workspaceElement).toHaveClass('theme-theme-with-ui-variables');\n        expect(workspaceElement).toHaveClass('theme-theme-with-syntax-variables');\n        expect(workspaceElement).not.toHaveClass('theme-atom-dark-ui');\n        expect(workspaceElement).not.toHaveClass('theme-atom-dark-syntax');\n      });\n    });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "logs a warning",
            "suites": [
                "atom.themes",
                "when a theme fails to load"
            ],
            "updatePoint": {
                "line": 125,
                "column": 65
            },
            "line": 125,
            "code": "  describe('when a theme fails to load', () => it('logs a warning', function () {\n    console.warn.reset();\n    atom.packages.activatePackage('a-theme-that-will-not-be-found').then(function () {}, function () {});\n    expect(console.warn.callCount).toBe(1);\n    expect(console.warn.argsForCall[0][0]).toContain(\"Could not resolve 'a-theme-that-will-not-be-found'\");\n  }));",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "synchronously loads css at the given path and installs a style tag for it in the head",
            "suites": [
                "atom.themes",
                "::requireStylesheet(path)"
            ],
            "updatePoint": {
                "line": 134,
                "column": 93
            },
            "line": 134,
            "code": "    it('synchronously loads css at the given path and installs a style tag for it in the head', function () {\n      let styleElementAddedHandler;\n      atom.styles.onDidAddStyleElement(styleElementAddedHandler = jasmine.createSpy('styleElementAddedHandler'));\n      const cssPath = getAbsolutePath(atom.project.getDirectories()[0], 'css.css');\n      const lengthBefore = document.querySelectorAll('head style').length;\n      atom.themes.requireStylesheet(cssPath);\n      expect(document.querySelectorAll('head style').length).toBe(lengthBefore + 1);\n      expect(styleElementAddedHandler).toHaveBeenCalled();\n      const element = document.querySelector('head style[source-path*=\"css.css\"]');\n      expect(element.getAttribute('source-path')).toEqualPath(cssPath);\n      expect(element.textContent).toBe(fs.readFileSync(cssPath, 'utf8')); // doesn't append twice\n\n      styleElementAddedHandler.reset();\n      atom.themes.requireStylesheet(cssPath);\n      expect(document.querySelectorAll('head style').length).toBe(lengthBefore + 1);\n      expect(styleElementAddedHandler).not.toHaveBeenCalled();\n      document.querySelectorAll('head style[id*=\"css.css\"]').forEach(styleElement => {\n        styleElement.remove();\n      });\n    });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "synchronously loads and parses less files at the given path and installs a style tag for it in the head",
            "suites": [
                "atom.themes",
                "::requireStylesheet(path)"
            ],
            "updatePoint": {
                "line": 154,
                "column": 111
            },
            "line": 154,
            "code": "    it('synchronously loads and parses less files at the given path and installs a style tag for it in the head', function () {\n      const lessPath = getAbsolutePath(atom.project.getDirectories()[0], 'sample.less');\n      const lengthBefore = document.querySelectorAll('head style').length;\n      atom.themes.requireStylesheet(lessPath);\n      expect(document.querySelectorAll('head style').length).toBe(lengthBefore + 1);\n      const element = document.querySelector('head style[source-path*=\"sample.less\"]');\n      expect(element.getAttribute('source-path')).toEqualPath(lessPath);\n      expect(element.textContent.toLowerCase()).toBe(`\\\n#header {\n  color: #4d926f;\n}\nh2 {\n  color: #4d926f;\n}\n\\\n`); // doesn't append twice\n\n      atom.themes.requireStylesheet(lessPath);\n      expect(document.querySelectorAll('head style').length).toBe(lengthBefore + 1);\n      document.querySelectorAll('head style[id*=\"sample.less\"]').forEach(styleElement => {\n        styleElement.remove();\n      });\n    });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "supports requiring css and less stylesheets without an explicit extension",
            "suites": [
                "atom.themes",
                "::requireStylesheet(path)"
            ],
            "updatePoint": {
                "line": 177,
                "column": 81
            },
            "line": 177,
            "code": "    it('supports requiring css and less stylesheets without an explicit extension', function () {\n      atom.themes.requireStylesheet(path.join(__dirname, 'fixtures', 'css'));\n      expect(document.querySelector('head style[source-path*=\"css.css\"]').getAttribute('source-path')).toEqualPath(getAbsolutePath(atom.project.getDirectories()[0], 'css.css'));\n      atom.themes.requireStylesheet(path.join(__dirname, 'fixtures', 'sample'));\n      expect(document.querySelector('head style[source-path*=\"sample.less\"]').getAttribute('source-path')).toEqualPath(getAbsolutePath(atom.project.getDirectories()[0], 'sample.less'));\n      document.querySelector('head style[source-path*=\"css.css\"]').remove();\n      document.querySelector('head style[source-path*=\"sample.less\"]').remove();\n    });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a disposable allowing styles applied by the given path to be removed",
            "suites": [
                "atom.themes",
                "::requireStylesheet(path)"
            ],
            "updatePoint": {
                "line": 185,
                "column": 84
            },
            "line": 185,
            "code": "    it('returns a disposable allowing styles applied by the given path to be removed', function () {\n      const cssPath = require.resolve('./fixtures/css.css');\n\n      expect(getComputedStyle(document.body).fontWeight).not.toBe('700');\n      const disposable = atom.themes.requireStylesheet(cssPath);\n      expect(getComputedStyle(document.body).fontWeight).toBe('700');\n      let styleElementRemovedHandler;\n      atom.styles.onDidRemoveStyleElement(styleElementRemovedHandler = jasmine.createSpy('styleElementRemovedHandler'));\n      disposable.dispose();\n      expect(getComputedStyle(document.body).fontWeight).not.toBe('bold');\n      expect(styleElementRemovedHandler).toHaveBeenCalled();\n    });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads the correct values from the theme's ui-variables file",
            "suites": [
                "atom.themes",
                "base style sheet loading"
            ],
            "updatePoint": {
                "line": 205,
                "column": 67
            },
            "line": 205,
            "code": "    it(\"loads the correct values from the theme's ui-variables file\", function () {\n      let didChangeActiveThemesHandler;\n      atom.themes.onDidChangeActiveThemes(didChangeActiveThemesHandler = jasmine.createSpy());\n      atom.config.set('core.themes', ['theme-with-ui-variables', 'theme-with-syntax-variables']);\n      waitsFor(() => didChangeActiveThemesHandler.callCount > 0);\n      runs(function () {\n        // an override loaded in the base css\n        expect(getComputedStyle(atom.workspace.getElement())['background-color']).toBe('rgb(0, 0, 255)'); // from within the theme itself\n\n        expect(getComputedStyle(document.querySelector('atom-text-editor')).paddingTop).toBe('150px');\n        expect(getComputedStyle(document.querySelector('atom-text-editor')).paddingRight).toBe('150px');\n        expect(getComputedStyle(document.querySelector('atom-text-editor')).paddingBottom).toBe('150px');\n      });\n    });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "loads the correct values from the fallback ui-variables",
            "suites": [
                "atom.themes",
                "base style sheet loading",
                "when there is a theme with incomplete variables"
            ],
            "updatePoint": {
                "line": 219,
                "column": 129
            },
            "line": 219,
            "code": "    describe('when there is a theme with incomplete variables', () => it('loads the correct values from the fallback ui-variables', function () {\n      let didChangeActiveThemesHandler;\n      atom.themes.onDidChangeActiveThemes(didChangeActiveThemesHandler = jasmine.createSpy());\n      atom.config.set('core.themes', ['theme-with-incomplete-ui-variables', 'theme-with-syntax-variables']);\n      waitsFor(() => didChangeActiveThemesHandler.callCount > 0);\n      runs(function () {\n        // an override loaded in the base css\n        expect(getComputedStyle(atom.workspace.getElement())['background-color']).toBe('rgb(0, 0, 255)'); // from within the theme itself\n\n        expect(getComputedStyle(document.querySelector('atom-text-editor')).backgroundColor).toBe('rgb(0, 152, 255)');\n      });\n    }));",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reloads it",
            "suites": [
                "atom.themes",
                "user stylesheet",
                "when the user stylesheet changes"
            ],
            "updatePoint": {
                "line": 242,
                "column": 20
            },
            "line": 242,
            "code": "      it('reloads it', function () {\n        let styleElementAddedHandler, styleElementRemovedHandler;\n        waitsForPromise(() => atom.themes.activateThemes());\n        runs(function () {\n          atom.styles.onDidRemoveStyleElement(styleElementRemovedHandler = jasmine.createSpy('styleElementRemovedHandler'));\n          atom.styles.onDidAddStyleElement(styleElementAddedHandler = jasmine.createSpy('styleElementAddedHandler'));\n          spyOn(atom.themes, 'loadUserStylesheet').andCallThrough();\n          expect(getComputedStyle(document.body).borderStyle).toBe('dotted');\n          fs.writeFileSync(userStylesheetPath, 'body {border-style: dashed}');\n        });\n        waitsFor(() => atom.themes.loadUserStylesheet.callCount === 1);\n        runs(function () {\n          expect(getComputedStyle(document.body).borderStyle).toBe('dashed');\n          expect(styleElementRemovedHandler).toHaveBeenCalled();\n          expect(styleElementRemovedHandler.argsForCall[0][0].textContent).toContain('dotted');\n          expect(styleElementAddedHandler).toHaveBeenCalled();\n          expect(styleElementAddedHandler.argsForCall[0][0].textContent).toContain('dashed');\n          styleElementRemovedHandler.reset();\n          fs.removeSync(userStylesheetPath);\n        });\n        waitsFor(() => atom.themes.loadUserStylesheet.callCount === 2);\n        runs(function () {\n          expect(styleElementRemovedHandler).toHaveBeenCalled();\n          expect(styleElementRemovedHandler.argsForCall[0][0].textContent).toContain('dashed');\n          expect(getComputedStyle(document.body).borderStyle).toBe('none');\n        });\n      });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates an error notification and does not add the stylesheet",
            "suites": [
                "atom.themes",
                "user stylesheet",
                "when there is an error reading the stylesheet"
            ],
            "updatePoint": {
                "line": 279,
                "column": 71
            },
            "line": 279,
            "code": "      it('creates an error notification and does not add the stylesheet', function () {\n        atom.themes.loadUserStylesheet();\n        expect(addErrorHandler).toHaveBeenCalled();\n        const note = addErrorHandler.mostRecentCall.args[0];\n        expect(note.getType()).toBe('error');\n        expect(note.getMessage()).toContain('Error loading');\n        expect(atom.styles.styleElementsBySourcePath[atom.styles.getUserStyleSheetPath()]).toBeUndefined();\n      });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates an error notification",
            "suites": [
                "atom.themes",
                "user stylesheet",
                "when there is an error watching the user stylesheet"
            ],
            "updatePoint": {
                "line": 303,
                "column": 39
            },
            "line": 303,
            "code": "      it('creates an error notification', function () {\n        atom.themes.loadUserStylesheet();\n        expect(addErrorHandler).toHaveBeenCalled();\n        const note = addErrorHandler.mostRecentCall.args[0];\n        expect(note.getType()).toBe('error');\n        expect(note.getMessage()).toContain('Unable to watch path');\n      });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a notification when a theme's stylesheet is invalid",
            "suites": [
                "atom.themes",
                "user stylesheet",
                "when there is an error watching the user stylesheet"
            ],
            "updatePoint": {
                "line": 311,
                "column": 64
            },
            "line": 311,
            "code": "    it(\"adds a notification when a theme's stylesheet is invalid\", function () {\n      const addErrorHandler = jasmine.createSpy();\n      atom.notifications.onDidAddNotification(addErrorHandler);\n      expect(() => atom.packages.activatePackage('theme-with-invalid-styles').then(function () {}, function () {})).not.toThrow();\n      expect(addErrorHandler.callCount).toBe(2);\n      expect(addErrorHandler.argsForCall[1][0].message).toContain('Failed to activate the theme-with-invalid-styles theme');\n    });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the default one-dark UI and syntax themes and logs a warning",
            "suites": [
                "atom.themes",
                "when a non-existent theme is present in the config"
            ],
            "updatePoint": {
                "line": 325,
                "column": 73
            },
            "line": 325,
            "code": "    it('uses the default one-dark UI and syntax themes and logs a warning', function () {\n      const activeThemeNames = atom.themes.getActiveThemeNames();\n      expect(console.warn.callCount).toBe(2);\n      expect(activeThemeNames.length).toBe(2);\n      expect(activeThemeNames).toContain('one-dark-ui');\n      expect(activeThemeNames).toContain('one-dark-syntax');\n    });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the enabled themes",
            "suites": [
                "atom.themes",
                "when in safe mode",
                "when the enabled UI and syntax themes are bundled with Atom"
            ],
            "updatePoint": {
                "line": 339,
                "column": 33
            },
            "line": 339,
            "code": "      it('uses the enabled themes', function () {\n        const activeThemeNames = atom.themes.getActiveThemeNames();\n        expect(activeThemeNames.length).toBe(2);\n        expect(activeThemeNames).toContain('atom-light-ui');\n        expect(activeThemeNames).toContain('atom-dark-syntax');\n      });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the default dark UI and syntax themes",
            "suites": [
                "atom.themes",
                "when in safe mode",
                "when the enabled UI and syntax themes are not bundled with Atom"
            ],
            "updatePoint": {
                "line": 351,
                "column": 52
            },
            "line": 351,
            "code": "      it('uses the default dark UI and syntax themes', function () {\n        const activeThemeNames = atom.themes.getActiveThemeNames();\n        expect(activeThemeNames.length).toBe(2);\n        expect(activeThemeNames).toContain('one-dark-ui');\n        expect(activeThemeNames).toContain('one-dark-syntax');\n      });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the default one-dark UI theme",
            "suites": [
                "atom.themes",
                "when in safe mode",
                "when the enabled UI theme is not bundled with Atom"
            ],
            "updatePoint": {
                "line": 363,
                "column": 44
            },
            "line": 363,
            "code": "      it('uses the default one-dark UI theme', function () {\n        const activeThemeNames = atom.themes.getActiveThemeNames();\n        expect(activeThemeNames.length).toBe(2);\n        expect(activeThemeNames).toContain('one-dark-ui');\n        expect(activeThemeNames).toContain('atom-light-syntax');\n      });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the default one-dark syntax theme",
            "suites": [
                "atom.themes",
                "when in safe mode",
                "when the enabled syntax theme is not bundled with Atom"
            ],
            "updatePoint": {
                "line": 375,
                "column": 48
            },
            "line": 375,
            "code": "      it('uses the default one-dark syntax theme', function () {\n        const activeThemeNames = atom.themes.getActiveThemeNames();\n        expect(activeThemeNames.length).toBe(2);\n        expect(activeThemeNames).toContain('atom-light-ui');\n        expect(activeThemeNames).toContain('one-dark-syntax');\n      });",
            "file": "theme-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates its title when document.title changes",
            "suites": [
                "TitleBar"
            ],
            "updatePoint": {
                "line": 6,
                "column": 51
            },
            "line": 6,
            "code": "  it('updates its title when document.title changes', () => {\n    const titleBar = new TitleBar({\n      workspace: atom.workspace,\n      themes: atom.themes,\n      applicationDelegate: atom.applicationDelegate\n    });\n    expect(titleBar.element.querySelector('.title').textContent).toBe(document.title);\n    const paneItem = new FakePaneItem('Title 1');\n    atom.workspace.getActivePane().activateItem(paneItem);\n    expect(document.title).toMatch('Title 1');\n    expect(titleBar.element.querySelector('.title').textContent).toBe(document.title);\n    paneItem.setTitle('Title 2');\n    expect(document.title).toMatch('Title 2');\n    expect(titleBar.element.querySelector('.title').textContent).toBe(document.title);\n    atom.project.setPaths([temp.mkdirSync('project-1')]);\n    expect(document.title).toMatch('project-1');\n    expect(titleBar.element.querySelector('.title').textContent).toBe(document.title);\n  });",
            "file": "title-bar-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can update the sheet offset for the current window based on its height",
            "suites": [
                "TitleBar"
            ],
            "updatePoint": {
                "line": 24,
                "column": 76
            },
            "line": 24,
            "code": "  it('can update the sheet offset for the current window based on its height', () => {\n    const titleBar = new TitleBar({\n      workspace: atom.workspace,\n      themes: atom.themes,\n      applicationDelegate: atom.applicationDelegate\n    });\n    expect(() => titleBar.updateWindowSheetOffset()).not.toThrow();\n  });",
            "file": "title-bar-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a tooltip when hovering over the target element",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when the trigger is 'hover' (the default)"
            ],
            "updatePoint": {
                "line": 35,
                "column": 65
            },
            "line": 35,
            "code": "      it('creates a tooltip when hovering over the target element', () => {\n        manager.add(element, {\n          title: 'Title'\n        });\n        hover(element, () => expect(document.body.querySelector('.tooltip')).toHaveText('Title'));\n      });",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "displays tooltips immediately when hovering over new elements once a tooltip has been displayed once",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when the trigger is 'hover' (the default)"
            ],
            "updatePoint": {
                "line": 41,
                "column": 110
            },
            "line": 41,
            "code": "      it('displays tooltips immediately when hovering over new elements once a tooltip has been displayed once', () => {\n        const disposables = new CompositeDisposable();\n        const element1 = createElement('foo');\n        disposables.add(manager.add(element1, {\n          title: 'Title'\n        }));\n        const element2 = createElement('bar');\n        disposables.add(manager.add(element2, {\n          title: 'Title'\n        }));\n        const element3 = createElement('baz');\n        disposables.add(manager.add(element3, {\n          title: 'Title'\n        }));\n        hover(element1, () => {});\n        expect(document.body.querySelector('.tooltip')).toBeNull();\n        mouseEnter(element2);\n        expect(document.body.querySelector('.tooltip')).not.toBeNull();\n        mouseLeave(element2);\n        advanceClock(manager.hoverDefaults.delay.hide);\n        expect(document.body.querySelector('.tooltip')).toBeNull();\n        advanceClock(Tooltip.FOLLOW_THROUGH_DURATION);\n        mouseEnter(element3);\n        expect(document.body.querySelector('.tooltip')).toBeNull();\n        advanceClock(manager.hoverDefaults.delay.show);\n        expect(document.body.querySelector('.tooltip')).not.toBeNull();\n        disposables.dispose();\n      });",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "hides the tooltip on keydown events",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when the trigger is 'hover' (the default)"
            ],
            "updatePoint": {
                "line": 69,
                "column": 45
            },
            "line": 69,
            "code": "      it('hides the tooltip on keydown events', () => {\n        const disposable = manager.add(element, {\n          title: 'Title',\n          trigger: 'hover'\n        });\n        hover(element, function () {\n          expect(document.body.querySelector('.tooltip')).not.toBeNull();\n          window.dispatchEvent(new CustomEvent('keydown', {\n            bubbles: true\n          }));\n          expect(document.body.querySelector('.tooltip')).toBeNull();\n          disposable.dispose();\n        });\n      });",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a tooltip immediately and only hides it on dispose",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when the trigger is 'manual'"
            ],
            "updatePoint": {
                "line": 84,
                "column": 113
            },
            "line": 84,
            "code": "    describe(\"when the trigger is 'manual'\", () => it('creates a tooltip immediately and only hides it on dispose', () => {\n      const disposable = manager.add(element, {\n        title: 'Title',\n        trigger: 'manual'\n      });\n      expect(document.body.querySelector('.tooltip')).toHaveText('Title');\n      disposable.dispose();\n      expect(document.body.querySelector('.tooltip')).toBeNull();\n    }));",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shows and hides the tooltip when the target element is clicked",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when the trigger is 'click'"
            ],
            "updatePoint": {
                "line": 93,
                "column": 116
            },
            "line": 93,
            "code": "    describe(\"when the trigger is 'click'\", () => it('shows and hides the tooltip when the target element is clicked', () => {\n      manager.add(element, {\n        title: 'Title',\n        trigger: 'click'\n      });\n      expect(document.body.querySelector('.tooltip')).toBeNull();\n      element.click();\n      expect(document.body.querySelector('.tooltip')).not.toBeNull();\n      element.click();\n      expect(document.body.querySelector('.tooltip')).toBeNull(); // Hide the tooltip when clicking anywhere but inside the tooltip element\n\n      element.click();\n      expect(document.body.querySelector('.tooltip')).not.toBeNull();\n      document.body.querySelector('.tooltip').click();\n      expect(document.body.querySelector('.tooltip')).not.toBeNull();\n      document.body.querySelector('.tooltip').firstChild.click();\n      expect(document.body.querySelector('.tooltip')).not.toBeNull();\n      document.body.click();\n      expect(document.body.querySelector('.tooltip')).toBeNull(); // Tooltip can show again after hiding due to clicking outside of the tooltip\n\n      element.click();\n      expect(document.body.querySelector('.tooltip')).not.toBeNull();\n      element.click();\n      expect(document.body.querySelector('.tooltip')).toBeNull();\n    }));",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not hide the tooltip on keyboard input",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when the trigger is 'click'"
            ],
            "updatePoint": {
                "line": 118,
                "column": 51
            },
            "line": 118,
            "code": "    it('does not hide the tooltip on keyboard input', () => {\n      manager.add(element, {\n        title: 'Title',\n        trigger: 'click'\n      });\n      element.click();\n      expect(document.body.querySelector('.tooltip')).not.toBeNull();\n      window.dispatchEvent(new CustomEvent('keydown', {\n        bubbles: true\n      }));\n      expect(document.body.querySelector('.tooltip')).not.toBeNull(); // click again to hide the tooltip because otherwise state leaks\n      // into other tests.\n\n      element.click();\n    });",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows a custom item to be specified for the content of the tooltip",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when the trigger is 'click'"
            ],
            "updatePoint": {
                "line": 133,
                "column": 75
            },
            "line": 133,
            "code": "    it('allows a custom item to be specified for the content of the tooltip', () => {\n      const tooltipElement = document.createElement('div');\n      manager.add(element, {\n        item: {\n          element: tooltipElement\n        }\n      });\n      hover(element, () => expect(tooltipElement.closest('.tooltip')).not.toBeNull());\n    });",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows a custom class to be specified for the tooltip",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when the trigger is 'click'"
            ],
            "updatePoint": {
                "line": 142,
                "column": 61
            },
            "line": 142,
            "code": "    it('allows a custom class to be specified for the tooltip', () => {\n      manager.add(element, {\n        title: 'Title',\n        class: 'custom-tooltip-class'\n      });\n      hover(element, () => expect(document.body.querySelector('.tooltip').classList.contains('custom-tooltip-class')).toBe(true));\n    });",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows jQuery elements to be passed as the target",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when the trigger is 'click'"
            ],
            "updatePoint": {
                "line": 149,
                "column": 57
            },
            "line": 149,
            "code": "    it('allows jQuery elements to be passed as the target', () => {\n      const element2 = document.createElement('div');\n      jasmine.attachToDOM(element2);\n      const fakeJqueryWrapper = {\n        0: element,\n        1: element2,\n        length: 2,\n        jquery: 'any-version'\n      };\n      const disposable = manager.add(fakeJqueryWrapper, {\n        title: 'Title'\n      });\n      hover(element, () => expect(document.body.querySelector('.tooltip')).toHaveText('Title'));\n      expect(document.body.querySelector('.tooltip')).toBeNull();\n      hover(element2, () => expect(document.body.querySelector('.tooltip')).toHaveText('Title'));\n      expect(document.body.querySelector('.tooltip')).toBeNull();\n      disposable.dispose();\n      hover(element, () => expect(document.body.querySelector('.tooltip')).toBeNull());\n      hover(element2, () => expect(document.body.querySelector('.tooltip')).toBeNull());\n    });",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "appends the key binding corresponding to the command to the title",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when a keyBindingCommand is specified",
                "when a title is specified"
            ],
            "updatePoint": {
                "line": 170,
                "column": 119
            },
            "line": 170,
            "code": "      describe('when a title is specified', () => it('appends the key binding corresponding to the command to the title', () => {\n        atom.keymaps.add('test', {\n          '.foo': {\n            'ctrl-x ctrl-y': 'test-command'\n          },\n          '.bar': {\n            'ctrl-x ctrl-z': 'test-command'\n          }\n        });\n        manager.add(element, {\n          title: 'Title',\n          keyBindingCommand: 'test-command'\n        });\n        hover(element, function () {\n          const tooltipElement = document.body.querySelector('.tooltip');\n          expect(tooltipElement).toHaveText(`Title ${ctrlX} ${ctrlY}`);\n        });\n      }));",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shows the key binding corresponding to the command alone",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when a keyBindingCommand is specified",
                "when no title is specified"
            ],
            "updatePoint": {
                "line": 188,
                "column": 111
            },
            "line": 188,
            "code": "      describe('when no title is specified', () => it('shows the key binding corresponding to the command alone', () => {\n        atom.keymaps.add('test', {\n          '.foo': {\n            'ctrl-x ctrl-y': 'test-command'\n          }\n        });\n        manager.add(element, {\n          keyBindingCommand: 'test-command'\n        });\n        hover(element, function () {\n          const tooltipElement = document.body.querySelector('.tooltip');\n          expect(tooltipElement).toHaveText(`${ctrlX} ${ctrlY}`);\n        });\n      }));",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "looks up the key binding relative to the target",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when a keyBindingCommand is specified",
                "when a keyBindingTarget is specified"
            ],
            "updatePoint": {
                "line": 203,
                "column": 59
            },
            "line": 203,
            "code": "        it('looks up the key binding relative to the target', () => {\n          atom.keymaps.add('test', {\n            '.bar': {\n              'ctrl-x ctrl-z': 'test-command'\n            },\n            '.foo': {\n              'ctrl-x ctrl-y': 'test-command'\n            }\n          });\n          manager.add(element, {\n            keyBindingCommand: 'test-command',\n            keyBindingTarget: element\n          });\n          hover(element, function () {\n            const tooltipElement = document.body.querySelector('.tooltip');\n            expect(tooltipElement).toHaveText(`${ctrlX} ${ctrlY}`);\n          });\n        });",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not display the keybinding if there is nothing mapped to the specified keyBindingCommand",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when a keyBindingCommand is specified",
                "when a keyBindingTarget is specified"
            ],
            "updatePoint": {
                "line": 221,
                "column": 105
            },
            "line": 221,
            "code": "        it('does not display the keybinding if there is nothing mapped to the specified keyBindingCommand', () => {\n          manager.add(element, {\n            title: 'A Title',\n            keyBindingCommand: 'test-command',\n            keyBindingTarget: element\n          });\n          hover(element, function () {\n            const tooltipElement = document.body.querySelector('.tooltip');\n            expect(tooltipElement.textContent).toBe('A Title');\n          });\n        });",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "no longer displays the tooltip on hover",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when .dispose() is called on the returned disposable"
            ],
            "updatePoint": {
                "line": 234,
                "column": 118
            },
            "line": 234,
            "code": "    describe('when .dispose() is called on the returned disposable', () => it('no longer displays the tooltip on hover', () => {\n      const disposable = manager.add(element, {\n        title: 'Title'\n      });\n      hover(element, () => expect(document.body.querySelector('.tooltip')).toHaveText('Title'));\n      disposable.dispose();\n      hover(element, () => expect(document.body.querySelector('.tooltip')).toBeNull());\n    }));",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "hides the tooltips",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "when the window is resized"
            ],
            "updatePoint": {
                "line": 242,
                "column": 71
            },
            "line": 242,
            "code": "    describe('when the window is resized', () => it('hides the tooltips', () => {\n      const disposable = manager.add(element, {\n        title: 'Title'\n      });\n      hover(element, function () {\n        expect(document.body.querySelector('.tooltip')).not.toBeNull();\n        window.dispatchEvent(new CustomEvent('resize'));\n        expect(document.body.querySelector('.tooltip')).toBeNull();\n        disposable.dispose();\n      });\n    }));",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds and remove tooltips correctly",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "findTooltips"
            ],
            "updatePoint": {
                "line": 254,
                "column": 44
            },
            "line": 254,
            "code": "      it('adds and remove tooltips correctly', () => {\n        expect(manager.findTooltips(element).length).toBe(0);\n        const disposable1 = manager.add(element, {\n          title: 'elem1'\n        });\n        expect(manager.findTooltips(element).length).toBe(1);\n        const disposable2 = manager.add(element, {\n          title: 'elem2'\n        });\n        expect(manager.findTooltips(element).length).toBe(2);\n        disposable1.dispose();\n        expect(manager.findTooltips(element).length).toBe(1);\n        disposable2.dispose();\n        expect(manager.findTooltips(element).length).toBe(0);\n      });",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "lets us hide tooltips programmatically",
            "suites": [
                "TooltipManager",
                "::add(target, options)",
                "findTooltips"
            ],
            "updatePoint": {
                "line": 269,
                "column": 48
            },
            "line": 269,
            "code": "      it('lets us hide tooltips programmatically', () => {\n        const disposable = manager.add(element, {\n          title: 'Title'\n        });\n        hover(element, function () {\n          expect(document.body.querySelector('.tooltip')).not.toBeNull();\n          manager.findTooltips(element)[0].hide();\n          expect(document.body.querySelector('.tooltip')).toBeNull();\n          disposable.dispose();\n        });\n      });",
            "file": "tooltip-manager-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indents wrongly indented lines",
            "suites": [
                "TreeIndenter",
                "indentation"
            ],
            "updatePoint": {
                "line": 89,
                "column": 38
            },
            "line": 89,
            "code": "    it('indents wrongly indented lines', () => {\n      buffer.setText(`if (true) {\n        a = {a: [\n        1,\n        'something'\n        ],\n        b: 2}\n        }`);\n      const correct = [0, 1, 3, 3, 2, 2, 0];\n      languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      treeIndenter = new TreeIndenter(languageMode, jsScopes);\n\n      for (let row = 0; row < buffer.getLineCount(); row++) {\n        // get suggested indentation\n        const indent = treeIndenter.suggestedIndentForBufferRow(row, TAB_LENGTH, {}); // verify\n\n        if (indent !== correct[row]) {\n          const line = buffer.lineForRow(row).trim();\n          throw Error(`failure in row ${row}: suggested ${indent} but ${correct[row]} is correct (${line})`);\n        } else {\n          expect(indent).toEqual(correct[row]);\n        }\n      }\n    });",
            "file": "tree-indenter-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "suggests correct indentations for ",
            "suites": [
                "TreeIndenter",
                "indentation"
            ],
            "updatePoint": {
                "line": 118,
                "column": 55
            },
            "line": 118,
            "code": "      it(`suggests correct indentations for ${filename}`, () => {\n        compareFile(path.join(__dirname, 'fixtures', 'indentation', filename));\n      });",
            "file": "tree-indenter-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "applies the most specific scope mapping to each node in the syntax tree",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 53,
                "column": 79
            },
            "line": 53,
            "code": "    it('applies the most specific scope mapping to each node in the syntax tree', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          program: 'source',\n          'call_expression > identifier': 'function',\n          property_identifier: 'property',\n          'call_expression > member_expression > property_identifier': 'method'\n        }\n      });\n      buffer.setText('aa.bbb = cc(d.eee());');\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expectTokensToEqual(editor, [[{\n        text: 'aa.',\n        scopes: ['source']\n      }, {\n        text: 'bbb',\n        scopes: ['source', 'property']\n      }, {\n        text: ' = ',\n        scopes: ['source']\n      }, {\n        text: 'cc',\n        scopes: ['source', 'function']\n      }, {\n        text: '(d.',\n        scopes: ['source']\n      }, {\n        text: 'eee',\n        scopes: ['source', 'method']\n      }, {\n        text: '());',\n        scopes: ['source']\n      }]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "provides the grammar with the text of leaf nodes only",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 92,
                "column": 61
            },
            "line": 92,
            "code": "    it('provides the grammar with the text of leaf nodes only', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          program: 'source',\n          'call_expression > identifier': 'function',\n          property_identifier: 'property',\n          'call_expression > member_expression > property_identifier': 'method'\n        }\n      });\n      const original = grammar.idForScope.bind(grammar);\n      let tokens = [];\n\n      grammar.idForScope = function (scope, text) {\n        if (text && tokens[tokens.length - 1] !== text) {\n          tokens.push(text);\n        }\n\n        return original(scope, text);\n      };\n\n      buffer.setText('aa.bbb = cc(d.eee());');\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expectTokensToEqual(editor, [[{\n        text: 'aa.',\n        scopes: ['source']\n      }, {\n        text: 'bbb',\n        scopes: ['source', 'property']\n      }, {\n        text: ' = ',\n        scopes: ['source']\n      }, {\n        text: 'cc',\n        scopes: ['source', 'function']\n      }, {\n        text: '(d.',\n        scopes: ['source']\n      }, {\n        text: 'eee',\n        scopes: ['source', 'method']\n      }, {\n        text: '());',\n        scopes: ['source']\n      }]]);\n      expect(tokens).toEqual(['aa', '.', 'bbb', '=', 'cc', '(', 'd', '.', 'eee', '(', ')', ';']);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can start or end multiple scopes at the same position",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 143,
                "column": 61
            },
            "line": 143,
            "code": "    it('can start or end multiple scopes at the same position', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          program: 'source',\n          call_expression: 'call',\n          member_expression: 'member',\n          identifier: 'variable',\n          '\"(\"': 'open-paren',\n          '\")\"': 'close-paren'\n        }\n      });\n      buffer.setText('a = bb.ccc();');\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expectTokensToEqual(editor, [[{\n        text: 'a',\n        scopes: ['source', 'variable']\n      }, {\n        text: ' = ',\n        scopes: ['source']\n      }, {\n        text: 'bb',\n        scopes: ['source', 'call', 'member', 'variable']\n      }, {\n        text: '.ccc',\n        scopes: ['source', 'call', 'member']\n      }, {\n        text: '(',\n        scopes: ['source', 'call', 'open-paren']\n      }, {\n        text: ')',\n        scopes: ['source', 'call', 'close-paren']\n      }, {\n        text: ';',\n        scopes: ['source']\n      }]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can resume highlighting on a line that starts with whitespace",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 184,
                "column": 69
            },
            "line": 184,
            "code": "    it('can resume highlighting on a line that starts with whitespace', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          'call_expression > member_expression > property_identifier': 'function',\n          property_identifier: 'member',\n          identifier: 'variable'\n        }\n      });\n      buffer.setText('a\\n  .b();');\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expectTokensToEqual(editor, [[{\n        text: 'a',\n        scopes: ['variable']\n      }], [{\n        text: '  ',\n        scopes: ['leading-whitespace']\n      }, {\n        text: '.',\n        scopes: []\n      }, {\n        text: 'b',\n        scopes: ['function']\n      }, {\n        text: '();',\n        scopes: []\n      }]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly skips over tokens with zero size",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 216,
                "column": 50
            },
            "line": 216,
            "code": "    it('correctly skips over tokens with zero size', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, cGrammarPath, {\n        parser: 'tree-sitter-c',\n        scopes: {\n          primitive_type: 'type',\n          identifier: 'variable'\n        }\n      });\n      buffer.setText('int main() {\\n  int a\\n  int b;\\n}');\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expect(languageMode.tree.rootNode.descendantForPosition(Point(1, 2), Point(1, 6)).toString()).toBe('(declaration type: (primitive_type)' + ' declarator: (identifier) (MISSING \";\"))');\n      expectTokensToEqual(editor, [[{\n        text: 'int',\n        scopes: ['type']\n      }, {\n        text: ' ',\n        scopes: []\n      }, {\n        text: 'main',\n        scopes: ['variable']\n      }, {\n        text: '() {',\n        scopes: []\n      }], [{\n        text: '  ',\n        scopes: ['leading-whitespace']\n      }, {\n        text: 'int',\n        scopes: ['type']\n      }, {\n        text: ' ',\n        scopes: []\n      }, {\n        text: 'a',\n        scopes: ['variable']\n      }], [{\n        text: '  ',\n        scopes: ['leading-whitespace']\n      }, {\n        text: 'int',\n        scopes: ['type']\n      }, {\n        text: ' ',\n        scopes: []\n      }, {\n        text: 'b',\n        scopes: ['variable']\n      }, {\n        text: ';',\n        scopes: []\n      }], [{\n        text: '}',\n        scopes: []\n      }]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates lines' highlighting when they are affected by distant changes",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 275,
                "column": 77
            },
            "line": 275,
            "code": "    it(\"updates lines' highlighting when they are affected by distant changes\", async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          'call_expression > identifier': 'function',\n          property_identifier: 'member'\n        }\n      });\n      buffer.setText('a(\\nb,\\nc\\n');\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode); // missing closing paren\n\n      expectTokensToEqual(editor, [[{\n        text: 'a(',\n        scopes: []\n      }], [{\n        text: 'b,',\n        scopes: []\n      }], [{\n        text: 'c',\n        scopes: []\n      }], [{\n        text: '',\n        scopes: []\n      }]]);\n      buffer.append(')');\n      expectTokensToEqual(editor, [[{\n        text: 'a',\n        scopes: ['function']\n      }, {\n        text: '(',\n        scopes: []\n      }], [{\n        text: 'b,',\n        scopes: []\n      }], [{\n        text: 'c',\n        scopes: []\n      }], [{\n        text: ')',\n        scopes: []\n      }]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows comma-separated selectors as scope mapping keys",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 321,
                "column": 62
            },
            "line": 321,
            "code": "    it('allows comma-separated selectors as scope mapping keys', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          'identifier, call_expression > identifier': [{\n            match: '^[A-Z]',\n            scopes: 'constructor'\n          }],\n          'call_expression > identifier': 'function'\n        }\n      });\n      buffer.setText(`a(B(new C))`);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expectTokensToEqual(editor, [[{\n        text: 'a',\n        scopes: ['function']\n      }, {\n        text: '(',\n        scopes: []\n      }, {\n        text: 'B',\n        scopes: ['constructor']\n      }, {\n        text: '(new ',\n        scopes: []\n      }, {\n        text: 'C',\n        scopes: ['constructor']\n      }, {\n        text: '))',\n        scopes: []\n      }]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "handles edits after tokens that end between CR and LF characters (regression)",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 358,
                "column": 85
            },
            "line": 358,
            "code": "    it('handles edits after tokens that end between CR and LF characters (regression)', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          comment: 'comment',\n          string: 'string',\n          property_identifier: 'property'\n        }\n      });\n      buffer.setText(['// abc', '', 'a(\"b\").c'].join('\\r\\n'));\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expectTokensToEqual(editor, [[{\n        text: '// abc',\n        scopes: ['comment']\n      }], [{\n        text: '',\n        scopes: []\n      }], [{\n        text: 'a(',\n        scopes: []\n      }, {\n        text: '\"b\"',\n        scopes: ['string']\n      }, {\n        text: ').',\n        scopes: []\n      }, {\n        text: 'c',\n        scopes: ['property']\n      }]]);\n      buffer.insert([2, 0], '  ');\n      expectTokensToEqual(editor, [[{\n        text: '// abc',\n        scopes: ['comment']\n      }], [{\n        text: '',\n        scopes: []\n      }], [{\n        text: '  ',\n        scopes: ['leading-whitespace']\n      }, {\n        text: 'a(',\n        scopes: []\n      }, {\n        text: '\"b\"',\n        scopes: ['string']\n      }, {\n        text: ').',\n        scopes: []\n      }, {\n        text: 'c',\n        scopes: ['property']\n      }]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "handles multi-line nodes with children on different lines (regression)",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 416,
                "column": 78
            },
            "line": 416,
            "code": "    it('handles multi-line nodes with children on different lines (regression)', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          template_string: 'string',\n          '\"${\"': 'interpolation',\n          '\"}\"': 'interpolation'\n        }\n      });\n      buffer.setText('`\\na${1}\\nb${2}\\n`;');\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expectTokensToEqual(editor, [[{\n        text: '`',\n        scopes: ['string']\n      }], [{\n        text: 'a',\n        scopes: ['string']\n      }, {\n        text: '${',\n        scopes: ['string', 'interpolation']\n      }, {\n        text: '1',\n        scopes: ['string']\n      }, {\n        text: '}',\n        scopes: ['string', 'interpolation']\n      }], [{\n        text: 'b',\n        scopes: ['string']\n      }, {\n        text: '${',\n        scopes: ['string', 'interpolation']\n      }, {\n        text: '2',\n        scopes: ['string']\n      }, {\n        text: '}',\n        scopes: ['string', 'interpolation']\n      }], [{\n        text: '`',\n        scopes: ['string']\n      }, {\n        text: ';',\n        scopes: []\n      }]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "handles folds inside of highlighted tokens",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 466,
                "column": 50
            },
            "line": 466,
            "code": "    it('handles folds inside of highlighted tokens', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          comment: 'comment',\n          'call_expression > identifier': 'function'\n        }\n      });\n      buffer.setText(dedent`\n        /*\n         * Hello\n         */\n\n        hello();\n      `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      editor.foldBufferRange([[0, 2], [2, 0]]);\n      expectTokensToEqual(editor, [[{\n        text: '/*',\n        scopes: ['comment']\n      }, {\n        text: '…',\n        scopes: ['fold-marker']\n      }, {\n        text: ' */',\n        scopes: ['comment']\n      }], [{\n        text: '',\n        scopes: []\n      }], [{\n        text: 'hello',\n        scopes: ['function']\n      }, {\n        text: '();',\n        scopes: []\n      }]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "applies regex match rules when specified",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 507,
                "column": 48
            },
            "line": 507,
            "code": "    it('applies regex match rules when specified', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          identifier: [{\n            match: '^(exports|document|window|global)$',\n            scopes: 'global'\n          }, {\n            match: '^[A-Z_]+$',\n            scopes: 'constant'\n          }, {\n            match: '^[A-Z]',\n            scopes: 'constructor'\n          }, 'variable']\n        }\n      });\n      buffer.setText(`exports.object = Class(SOME_CONSTANT, x)`);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expectTokensToEqual(editor, [[{\n        text: 'exports',\n        scopes: ['global']\n      }, {\n        text: '.object = ',\n        scopes: []\n      }, {\n        text: 'Class',\n        scopes: ['constructor']\n      }, {\n        text: '(',\n        scopes: []\n      }, {\n        text: 'SOME_CONSTANT',\n        scopes: ['constant']\n      }, {\n        text: ', ',\n        scopes: []\n      }, {\n        text: 'x',\n        scopes: ['variable']\n      }, {\n        text: ')',\n        scopes: []\n      }]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "handles nodes that start before their first child and end after their last child",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting"
            ],
            "updatePoint": {
                "line": 555,
                "column": 88
            },
            "line": 555,
            "code": "    it('handles nodes that start before their first child and end after their last child', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, rubyGrammarPath, {\n        parser: 'tree-sitter-ruby',\n        scopes: {\n          bare_string: 'string',\n          interpolation: 'embedded',\n          '\"#{\"': 'punctuation',\n          '\"}\"': 'punctuation'\n        }\n      }); // The bare string node `bc#{d}ef` has one child: the interpolation, and that child\n      // starts later and ends earlier than the bare string.\n\n      buffer.setText('a = %W( bc#{d}ef )');\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expectTokensToEqual(editor, [[{\n        text: 'a = %W( ',\n        scopes: []\n      }, {\n        text: 'bc',\n        scopes: ['string']\n      }, {\n        text: '#{',\n        scopes: ['string', 'embedded', 'punctuation']\n      }, {\n        text: 'd',\n        scopes: ['string', 'embedded']\n      }, {\n        text: '}',\n        scopes: ['string', 'embedded', 'punctuation']\n      }, {\n        text: 'ef',\n        scopes: ['string']\n      }, {\n        text: ' )',\n        scopes: []\n      }]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "immediately parses again when the current parse completes",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "when the buffer changes during a parse"
            ],
            "updatePoint": {
                "line": 597,
                "column": 67
            },
            "line": 597,
            "code": "      it('immediately parses again when the current parse completes', async () => {\n        const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n          parser: 'tree-sitter-javascript',\n          scopes: {\n            identifier: 'variable',\n            'call_expression > identifier': 'function',\n            'new_expression > identifier': 'constructor'\n          }\n        });\n        buffer.setText('abc;');\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar,\n          syncTimeoutMicros: 0\n        });\n        buffer.setLanguageMode(languageMode);\n        await nextHighlightingUpdate(languageMode);\n        await new Promise(process.nextTick);\n        expectTokensToEqual(editor, [[{\n          text: 'abc',\n          scopes: ['variable']\n        }, {\n          text: ';',\n          scopes: []\n        }]]);\n        buffer.setTextInRange([[0, 3], [0, 3]], '()');\n        expectTokensToEqual(editor, [[{\n          text: 'abc()',\n          scopes: ['variable']\n        }, {\n          text: ';',\n          scopes: []\n        }]]);\n        buffer.setTextInRange([[0, 0], [0, 0]], 'new ');\n        expectTokensToEqual(editor, [[{\n          text: 'new ',\n          scopes: []\n        }, {\n          text: 'abc()',\n          scopes: ['variable']\n        }, {\n          text: ';',\n          scopes: []\n        }]]);\n        await nextHighlightingUpdate(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: 'new ',\n          scopes: []\n        }, {\n          text: 'abc',\n          scopes: ['function']\n        }, {\n          text: '();',\n          scopes: []\n        }]]);\n        await nextHighlightingUpdate(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: 'new ',\n          scopes: []\n        }, {\n          text: 'abc',\n          scopes: ['constructor']\n        }, {\n          text: '();',\n          scopes: []\n        }]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can incorporate multiple consecutive synchronous updates",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "when changes are small enough to be re-parsed synchronously"
            ],
            "updatePoint": {
                "line": 666,
                "column": 66
            },
            "line": 666,
            "code": "      it('can incorporate multiple consecutive synchronous updates', () => {\n        const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n          parser: 'tree-sitter-javascript',\n          scopes: {\n            property_identifier: 'property',\n            'call_expression > identifier': 'function',\n            'call_expression > member_expression > property_identifier': 'method'\n          }\n        });\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar\n        });\n        buffer.setLanguageMode(languageMode);\n        buffer.setText('a');\n        expectTokensToEqual(editor, [[{\n          text: 'a',\n          scopes: []\n        }]]);\n        buffer.append('.');\n        expectTokensToEqual(editor, [[{\n          text: 'a.',\n          scopes: []\n        }]]);\n        buffer.append('b');\n        expectTokensToEqual(editor, [[{\n          text: 'a.',\n          scopes: []\n        }, {\n          text: 'b',\n          scopes: ['property']\n        }]]);\n        buffer.append('()');\n        expectTokensToEqual(editor, [[{\n          text: 'a.',\n          scopes: []\n        }, {\n          text: 'b',\n          scopes: ['method']\n        }, {\n          text: '()',\n          scopes: []\n        }]]);\n        buffer.delete([[0, 1], [0, 2]]);\n        expectTokensToEqual(editor, [[{\n          text: 'ab',\n          scopes: ['function']\n        }, {\n          text: '()',\n          scopes: []\n        }]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "highlights code inside of injection points",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "injectionPoints and injectionPatterns"
            ],
            "updatePoint": {
                "line": 748,
                "column": 52
            },
            "line": 748,
            "code": "      it('highlights code inside of injection points', async () => {\n        atom.grammars.addGrammar(jsGrammar);\n        atom.grammars.addGrammar(htmlGrammar);\n        buffer.setText('node.innerHTML = html `\\na ${b}<img src=\"d\">\\n`;');\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar: jsGrammar,\n          grammars: atom.grammars\n        });\n        buffer.setLanguageMode(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: 'node.',\n          scopes: []\n        }, {\n          text: 'innerHTML',\n          scopes: ['property']\n        }, {\n          text: ' = ',\n          scopes: []\n        }, {\n          text: 'html',\n          scopes: ['function']\n        }, {\n          text: ' ',\n          scopes: []\n        }, {\n          text: '`',\n          scopes: ['string']\n        }, {\n          text: '',\n          scopes: ['string', 'html']\n        }], [{\n          text: 'a ',\n          scopes: ['string', 'html']\n        }, {\n          text: '${',\n          scopes: ['string', 'html', 'interpolation']\n        }, {\n          text: 'b',\n          scopes: ['string', 'html']\n        }, {\n          text: '}',\n          scopes: ['string', 'html', 'interpolation']\n        }, {\n          text: '<',\n          scopes: ['string', 'html']\n        }, {\n          text: 'img',\n          scopes: ['string', 'html', 'tag']\n        }, {\n          text: ' ',\n          scopes: ['string', 'html']\n        }, {\n          text: 'src',\n          scopes: ['string', 'html', 'attr']\n        }, {\n          text: '=\"d\">',\n          scopes: ['string', 'html']\n        }], [{\n          text: '`',\n          scopes: ['string']\n        }, {\n          text: ';',\n          scopes: []\n        }]]);\n        const range = buffer.findSync('html');\n        buffer.setTextInRange(range, 'xml');\n        await nextHighlightingUpdate(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: 'node.',\n          scopes: []\n        }, {\n          text: 'innerHTML',\n          scopes: ['property']\n        }, {\n          text: ' = ',\n          scopes: []\n        }, {\n          text: 'xml',\n          scopes: ['function']\n        }, {\n          text: ' ',\n          scopes: []\n        }, {\n          text: '`',\n          scopes: ['string']\n        }], [{\n          text: 'a ',\n          scopes: ['string']\n        }, {\n          text: '${',\n          scopes: ['string', 'interpolation']\n        }, {\n          text: 'b',\n          scopes: ['string']\n        }, {\n          text: '}',\n          scopes: ['string', 'interpolation']\n        }, {\n          text: '<img src=\"d\">',\n          scopes: ['string']\n        }], [{\n          text: '`',\n          scopes: ['string']\n        }, {\n          text: ';',\n          scopes: []\n        }]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "highlights the content after injections",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "injectionPoints and injectionPatterns"
            ],
            "updatePoint": {
                "line": 857,
                "column": 49
            },
            "line": 857,
            "code": "      it('highlights the content after injections', async () => {\n        atom.grammars.addGrammar(jsGrammar);\n        atom.grammars.addGrammar(htmlGrammar);\n        buffer.setText('<script>\\nhello();\\n</script>\\n<div>\\n</div>');\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar: htmlGrammar,\n          grammars: atom.grammars\n        });\n        buffer.setLanguageMode(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: '<',\n          scopes: ['html']\n        }, {\n          text: 'script',\n          scopes: ['html', 'tag']\n        }, {\n          text: '>',\n          scopes: ['html']\n        }], [{\n          text: 'hello',\n          scopes: ['html', 'function']\n        }, {\n          text: '();',\n          scopes: ['html']\n        }], [{\n          text: '</',\n          scopes: ['html']\n        }, {\n          text: 'script',\n          scopes: ['html', 'tag']\n        }, {\n          text: '>',\n          scopes: ['html']\n        }], [{\n          text: '<',\n          scopes: ['html']\n        }, {\n          text: 'div',\n          scopes: ['html', 'tag']\n        }, {\n          text: '>',\n          scopes: ['html']\n        }], [{\n          text: '</',\n          scopes: ['html']\n        }, {\n          text: 'div',\n          scopes: ['html', 'tag']\n        }, {\n          text: '>',\n          scopes: ['html']\n        }]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates buffers highlighting when a grammar with injectionRegExp is added",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "injectionPoints and injectionPatterns"
            ],
            "updatePoint": {
                "line": 911,
                "column": 83
            },
            "line": 911,
            "code": "      it('updates buffers highlighting when a grammar with injectionRegExp is added', async () => {\n        atom.grammars.addGrammar(jsGrammar);\n        buffer.setText('node.innerHTML = html `\\na ${b}<img src=\"d\">\\n`;');\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar: jsGrammar,\n          grammars: atom.grammars\n        });\n        buffer.setLanguageMode(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: 'node.',\n          scopes: []\n        }, {\n          text: 'innerHTML',\n          scopes: ['property']\n        }, {\n          text: ' = ',\n          scopes: []\n        }, {\n          text: 'html',\n          scopes: ['function']\n        }, {\n          text: ' ',\n          scopes: []\n        }, {\n          text: '`',\n          scopes: ['string']\n        }], [{\n          text: 'a ',\n          scopes: ['string']\n        }, {\n          text: '${',\n          scopes: ['string', 'interpolation']\n        }, {\n          text: 'b',\n          scopes: ['string']\n        }, {\n          text: '}',\n          scopes: ['string', 'interpolation']\n        }, {\n          text: '<img src=\"d\">',\n          scopes: ['string']\n        }], [{\n          text: '`',\n          scopes: ['string']\n        }, {\n          text: ';',\n          scopes: []\n        }]]);\n        atom.grammars.addGrammar(htmlGrammar);\n        await nextHighlightingUpdate(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: 'node.',\n          scopes: []\n        }, {\n          text: 'innerHTML',\n          scopes: ['property']\n        }, {\n          text: ' = ',\n          scopes: []\n        }, {\n          text: 'html',\n          scopes: ['function']\n        }, {\n          text: ' ',\n          scopes: []\n        }, {\n          text: '`',\n          scopes: ['string']\n        }, {\n          text: '',\n          scopes: ['string', 'html']\n        }], [{\n          text: 'a ',\n          scopes: ['string', 'html']\n        }, {\n          text: '${',\n          scopes: ['string', 'html', 'interpolation']\n        }, {\n          text: 'b',\n          scopes: ['string', 'html']\n        }, {\n          text: '}',\n          scopes: ['string', 'html', 'interpolation']\n        }, {\n          text: '<',\n          scopes: ['string', 'html']\n        }, {\n          text: 'img',\n          scopes: ['string', 'html', 'tag']\n        }, {\n          text: ' ',\n          scopes: ['string', 'html']\n        }, {\n          text: 'src',\n          scopes: ['string', 'html', 'attr']\n        }, {\n          text: '=\"d\">',\n          scopes: ['string', 'html']\n        }], [{\n          text: '`',\n          scopes: ['string']\n        }, {\n          text: ';',\n          scopes: []\n        }]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "handles injections that intersect",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "injectionPoints and injectionPatterns"
            ],
            "updatePoint": {
                "line": 1018,
                "column": 43
            },
            "line": 1018,
            "code": "      it('handles injections that intersect', async () => {\n        const ejsGrammar = new TreeSitterGrammar(atom.grammars, ejsGrammarPath, {\n          id: 'ejs',\n          parser: 'tree-sitter-embedded-template',\n          scopes: {\n            '\"<%=\"': 'directive',\n            '\"%>\"': 'directive'\n          },\n          injectionPoints: [{\n            type: 'template',\n\n            language(node) {\n              return 'javascript';\n            },\n\n            content(node) {\n              return node.descendantsOfType('code');\n            }\n\n          }, {\n            type: 'template',\n\n            language(node) {\n              return 'html';\n            },\n\n            content(node) {\n              return node.descendantsOfType('content');\n            }\n\n          }]\n        });\n        atom.grammars.addGrammar(jsGrammar);\n        atom.grammars.addGrammar(htmlGrammar);\n        buffer.setText('<body>\\n<script>\\nb(<%= c.d %>)\\n</script>\\n</body>');\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar: ejsGrammar,\n          grammars: atom.grammars\n        });\n        buffer.setLanguageMode(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: '<',\n          scopes: ['html']\n        }, {\n          text: 'body',\n          scopes: ['html', 'tag']\n        }, {\n          text: '>',\n          scopes: ['html']\n        }], [{\n          text: '<',\n          scopes: ['html']\n        }, {\n          text: 'script',\n          scopes: ['html', 'tag']\n        }, {\n          text: '>',\n          scopes: ['html']\n        }], [{\n          text: 'b',\n          scopes: ['html', 'function']\n        }, {\n          text: '(',\n          scopes: ['html']\n        }, {\n          text: '<%=',\n          scopes: ['html', 'directive']\n        }, {\n          text: ' c.',\n          scopes: ['html']\n        }, {\n          text: 'd',\n          scopes: ['html', 'property']\n        }, {\n          text: ' ',\n          scopes: ['html']\n        }, {\n          text: '%>',\n          scopes: ['html', 'directive']\n        }, {\n          text: ')',\n          scopes: ['html']\n        }], [{\n          text: '</',\n          scopes: ['html']\n        }, {\n          text: 'script',\n          scopes: ['html', 'tag']\n        }, {\n          text: '>',\n          scopes: ['html']\n        }], [{\n          text: '</',\n          scopes: ['html']\n        }, {\n          text: 'body',\n          scopes: ['html', 'tag']\n        }, {\n          text: '>',\n          scopes: ['html']\n        }]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "handles injections that are empty",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "injectionPoints and injectionPatterns"
            ],
            "updatePoint": {
                "line": 1121,
                "column": 43
            },
            "line": 1121,
            "code": "      it('handles injections that are empty', async () => {\n        atom.grammars.addGrammar(jsGrammar);\n        atom.grammars.addGrammar(htmlGrammar);\n        buffer.setText('text = html');\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar: jsGrammar,\n          grammars: atom.grammars\n        });\n        buffer.setLanguageMode(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: 'text = html',\n          scopes: []\n        }]]);\n        buffer.append(' ``;');\n        expectTokensToEqual(editor, [[{\n          text: 'text = ',\n          scopes: []\n        }, {\n          text: 'html',\n          scopes: ['function']\n        }, {\n          text: ' ',\n          scopes: []\n        }, {\n          text: '``',\n          scopes: ['string']\n        }, {\n          text: ';',\n          scopes: []\n        }]]);\n        buffer.insert({\n          row: 0,\n          column: buffer.getText().lastIndexOf('`')\n        }, '<div>');\n        await nextHighlightingUpdate(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: 'text = ',\n          scopes: []\n        }, {\n          text: 'html',\n          scopes: ['function']\n        }, {\n          text: ' ',\n          scopes: []\n        }, {\n          text: '`',\n          scopes: ['string']\n        }, {\n          text: '<',\n          scopes: ['string', 'html']\n        }, {\n          text: 'div',\n          scopes: ['string', 'html', 'tag']\n        }, {\n          text: '>',\n          scopes: ['string', 'html']\n        }, {\n          text: '`',\n          scopes: ['string']\n        }, {\n          text: ';',\n          scopes: []\n        }]]);\n        buffer.undo();\n        await nextHighlightingUpdate(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: 'text = ',\n          scopes: []\n        }, {\n          text: 'html',\n          scopes: ['function']\n        }, {\n          text: ' ',\n          scopes: []\n        }, {\n          text: '``',\n          scopes: ['string']\n        }, {\n          text: ';',\n          scopes: []\n        }]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "terminates comment token at the end of an injection, so that the next injection is NOT a continuation of the comment",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "injectionPoints and injectionPatterns"
            ],
            "updatePoint": {
                "line": 1204,
                "column": 126
            },
            "line": 1204,
            "code": "      it('terminates comment token at the end of an injection, so that the next injection is NOT a continuation of the comment', async () => {\n        const ejsGrammar = new TreeSitterGrammar(atom.grammars, ejsGrammarPath, {\n          id: 'ejs',\n          parser: 'tree-sitter-embedded-template',\n          scopes: {\n            '\"<%\"': 'directive',\n            '\"%>\"': 'directive'\n          },\n          injectionPoints: [{\n            type: 'template',\n\n            language(node) {\n              return 'javascript';\n            },\n\n            content(node) {\n              return node.descendantsOfType('code');\n            },\n\n            newlinesBetween: true\n          }, {\n            type: 'template',\n\n            language(node) {\n              return 'html';\n            },\n\n            content(node) {\n              return node.descendantsOfType('content');\n            }\n\n          }]\n        });\n        atom.grammars.addGrammar(jsGrammar);\n        atom.grammars.addGrammar(htmlGrammar);\n        buffer.setText('<% // js comment %>\\n<% b() %>');\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar: ejsGrammar,\n          grammars: atom.grammars\n        });\n        buffer.setLanguageMode(languageMode);\n        expectTokensToEqual(editor, [[{\n          text: '<%',\n          scopes: ['directive']\n        }, {\n          text: ' ',\n          scopes: []\n        }, {\n          text: '// js comment ',\n          scopes: ['comment']\n        }, {\n          text: '%>',\n          scopes: ['directive']\n        }, {\n          text: '',\n          scopes: ['html']\n        }], [{\n          text: '<%',\n          scopes: ['directive']\n        }, {\n          text: ' ',\n          scopes: []\n        }, {\n          text: 'b',\n          scopes: ['function']\n        }, {\n          text: '() ',\n          scopes: []\n        }, {\n          text: '%>',\n          scopes: ['directive']\n        }]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "only covers scope boundaries in parent layers if a nested layer has a boundary at the same position",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "injectionPoints and injectionPatterns"
            ],
            "updatePoint": {
                "line": 1278,
                "column": 109
            },
            "line": 1278,
            "code": "      it('only covers scope boundaries in parent layers if a nested layer has a boundary at the same position', async () => {\n        const jsdocGrammar = new TreeSitterGrammar(atom.grammars, jsdocGrammarPath, {\n          scopeName: 'jsdoc',\n          parser: 'tree-sitter-jsdoc',\n          scopes: {},\n          injectionRegExp: 'jsdoc',\n          injectionPoints: []\n        });\n        atom.grammars.addGrammar(jsGrammar);\n        atom.grammars.addGrammar(jsdocGrammar);\n        editor.setGrammar(jsGrammar);\n        editor.setText('/**\\n*/\\n{\\n}');\n        expectTokensToEqual(editor, [[{\n          text: '/**',\n          scopes: ['comment']\n        }], [{\n          text: '*/',\n          scopes: ['comment']\n        }], [{\n          text: '{',\n          scopes: []\n        }], [{\n          text: '}',\n          scopes: []\n        }]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reports scopes from shallower layers when they are at the start or end of an injection",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "injectionPoints and injectionPatterns"
            ],
            "updatePoint": {
                "line": 1304,
                "column": 96
            },
            "line": 1304,
            "code": "      it('reports scopes from shallower layers when they are at the start or end of an injection', async () => {\n        await atom.packages.activatePackage('language-javascript');\n        editor.setGrammar(atom.grammars.grammarForScopeName('source.js'));\n        editor.setText('/** @babel */\\n{\\n}');\n        expectTokensToEqual(editor, [[{\n          text: '/** ',\n          scopes: ['source js', 'comment block']\n        }, {\n          text: '@babel',\n          scopes: ['source js', 'comment block', 'keyword control']\n        }, {\n          text: ' *',\n          scopes: ['source js', 'comment block']\n        }, {\n          text: '/',\n          scopes: ['source js', 'comment block', 'meta delimiter slash']\n        }], [{\n          text: '{',\n          scopes: ['source js', 'punctuation definition function body begin bracket curly']\n        }], [{\n          text: '}',\n          scopes: ['source js', 'punctuation definition function body end bracket curly']\n        }]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "respects the `includeChildren` property of injection points",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "injectionPoints and injectionPatterns"
            ],
            "updatePoint": {
                "line": 1328,
                "column": 69
            },
            "line": 1328,
            "code": "      it('respects the `includeChildren` property of injection points', async () => {\n        const rustGrammar = new TreeSitterGrammar(atom.grammars, rustGrammarPath, {\n          scopeName: 'rust',\n          parser: 'tree-sitter-rust',\n          scopes: {\n            identifier: 'variable',\n            field_identifier: 'property',\n            'call_expression > field_expression > field_identifier': 'function',\n            'macro_invocation > identifier': 'macro'\n          },\n          injectionRegExp: 'rust',\n          injectionPoints: [{\n            type: 'macro_invocation',\n\n            language() {\n              return 'rust';\n            },\n\n            content(node) {\n              return node.lastChild;\n            },\n\n            // The tokens within a `token_tree` are all parsed as separate\n            // children of the `token_tree`. By default, when adding a language\n            // injection for a node, the node's children's ranges would be\n            // excluded from the injection. But for this injection point\n            // (parsing token trees as rust code), we want to reparse all of the\n            // content of the token tree.\n            includeChildren: true\n          }]\n        });\n        atom.grammars.addGrammar(rustGrammar); // Macro call within another macro call.\n\n        buffer.setText('assert_eq!(a.b.c(), vec![d.e()]); f.g();');\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar: rustGrammar,\n          grammars: atom.grammars\n        });\n        buffer.setLanguageMode(languageMode); // There should not be duplicate scopes due to the root layer\n        // and for the injected rust layer.\n\n        expectTokensToEqual(editor, [[{\n          text: 'assert_eq',\n          scopes: ['macro']\n        }, {\n          text: '!(',\n          scopes: []\n        }, {\n          text: 'a',\n          scopes: ['variable']\n        }, {\n          text: '.',\n          scopes: []\n        }, {\n          text: 'b',\n          scopes: ['property']\n        }, {\n          text: '.',\n          scopes: []\n        }, {\n          text: 'c',\n          scopes: ['function']\n        }, {\n          text: '(), ',\n          scopes: []\n        }, {\n          text: 'vec',\n          scopes: ['macro']\n        }, {\n          text: '![',\n          scopes: []\n        }, {\n          text: 'd',\n          scopes: ['variable']\n        }, {\n          text: '.',\n          scopes: []\n        }, {\n          text: 'e',\n          scopes: ['function']\n        }, {\n          text: '()]); ',\n          scopes: []\n        }, {\n          text: 'f',\n          scopes: ['variable']\n        }, {\n          text: '.',\n          scopes: []\n        }, {\n          text: 'g',\n          scopes: ['function']\n        }, {\n          text: '();',\n          scopes: []\n        }]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies onDidTokenize listeners the first time all syntax highlighting is done",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting",
                "injectionPoints and injectionPatterns"
            ],
            "updatePoint": {
                "line": 1426,
                "column": 89
            },
            "line": 1426,
            "code": "      it('notifies onDidTokenize listeners the first time all syntax highlighting is done', async () => {\n        const promise = new Promise(resolve => {\n          editor.onDidTokenize(event => {\n            expectTokensToEqual(editor, [[{\n              text: '<',\n              scopes: ['html']\n            }, {\n              text: 'script',\n              scopes: ['html', 'tag']\n            }, {\n              text: '>',\n              scopes: ['html']\n            }], [{\n              text: 'hello',\n              scopes: ['html', 'function']\n            }, {\n              text: '();',\n              scopes: ['html']\n            }], [{\n              text: '</',\n              scopes: ['html']\n            }, {\n              text: 'script',\n              scopes: ['html', 'tag']\n            }, {\n              text: '>',\n              scopes: ['html']\n            }]]);\n            resolve();\n          });\n        });\n        atom.grammars.addGrammar(jsGrammar);\n        atom.grammars.addGrammar(htmlGrammar);\n        buffer.setText('<script>\\nhello();\\n</script>');\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar: htmlGrammar,\n          grammars: atom.grammars,\n          syncTimeoutMicros: 0\n        });\n        buffer.setLanguageMode(languageMode);\n        await promise;\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "matches the highlighting of a freshly-opened editor",
            "suites": [
                "TreeSitterLanguageMode",
                "highlighting after random changes"
            ],
            "updatePoint": {
                "line": 1480,
                "column": 59
            },
            "line": 1480,
            "code": "    it('matches the highlighting of a freshly-opened editor', async () => {\n      jasmine.useRealClock();\n      const text = fs.readFileSync(path.join(__dirname, 'fixtures', 'sample.js'), 'utf8');\n      atom.grammars.loadGrammarSync(jsGrammarPath);\n      atom.grammars.assignLanguageMode(buffer, 'source.js');\n      buffer.getLanguageMode().syncTimeoutMicros = 0;\n      const initialSeed = Date.now();\n\n      for (let i = 0, trialCount = 10; i < trialCount; i++) {\n        let seed = initialSeed + i; // seed = 1541201470759\n\n        const random = Random(seed); // Parse the initial content and render all of the screen lines.\n\n        buffer.setText(text);\n        buffer.clearUndoStack();\n        await buffer.getLanguageMode().parseCompletePromise();\n        editor.displayLayer.getScreenLines(); // Make several random edits.\n\n        for (let j = 0, editCount = 1 + random(4); j < editCount; j++) {\n          const editRoll = random(10);\n          const range = getRandomBufferRange(random, buffer);\n\n          if (editRoll < 2) {\n            const linesToInsert = buildRandomLines(random, range.getExtent().row + 1); // console.log('replace', range.toString(), JSON.stringify(linesToInsert))\n\n            buffer.setTextInRange(range, linesToInsert);\n          } else if (editRoll < 5) {\n            // console.log('delete', range.toString())\n            buffer.delete(range);\n          } else {\n            const linesToInsert = buildRandomLines(random, 3); // console.log('insert', range.start.toString(), JSON.stringify(linesToInsert))\n\n            buffer.insert(range.start, linesToInsert);\n          } // console.log(buffer.getText())\n          // Sometimes, let the parse complete before re-rendering.\n          // Sometimes re-render and move on before the parse completes.\n\n\n          if (random(2)) await buffer.getLanguageMode().parseCompletePromise();\n          editor.displayLayer.getScreenLines();\n        } // Revert the edits, because Tree-sitter's error recovery is somewhat path-dependent,\n        // and we want a state where the tree parse result is guaranteed.\n\n\n        while (buffer.undo()) {} // Create a fresh buffer and editor with the same text.\n\n\n        const buffer2 = new TextBuffer(buffer.getText());\n        const editor2 = new TextEditor({\n          buffer: buffer2\n        });\n        atom.grammars.assignLanguageMode(buffer2, 'source.js'); // Verify that the the two buffers have the same syntax highlighting.\n\n        await buffer.getLanguageMode().parseCompletePromise();\n        await buffer2.getLanguageMode().parseCompletePromise();\n        expect(buffer.getLanguageMode().tree.rootNode.toString()).toEqual(buffer2.getLanguageMode().tree.rootNode.toString(), `Seed: ${seed}`);\n\n        for (let j = 0, n = editor.getScreenLineCount(); j < n; j++) {\n          const tokens1 = editor.tokensForScreenRow(j);\n          const tokens2 = editor2.tokensForScreenRow(j);\n          expect(tokens1).toEqual(tokens2, `Seed: ${seed}, screen line: ${j}`);\n\n          if (jasmine.getEnv().currentSpec.results().failedCount > 0) {\n            console.log(tokens1);\n            console.log(tokens2);\n            debugger; // eslint-disable-line no-debugger\n\n            break;\n          }\n        }\n\n        if (jasmine.getEnv().currentSpec.results().failedCount > 0) break;\n      }\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can fold nodes that start and end with specified tokens",
            "suites": [
                "TreeSitterLanguageMode",
                "folding"
            ],
            "updatePoint": {
                "line": 1556,
                "column": 63
            },
            "line": 1556,
            "code": "    it('can fold nodes that start and end with specified tokens', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        folds: [{\n          start: {\n            type: '{',\n            index: 0\n          },\n          end: {\n            type: '}',\n            index: -1\n          }\n        }, {\n          start: {\n            type: '(',\n            index: 0\n          },\n          end: {\n            type: ')',\n            index: -1\n          }\n        }]\n      });\n      buffer.setText(dedent`\n        module.exports =\n        class A {\n          getB (c,\n                d,\n                e) {\n            return this.f(g)\n          }\n        }\n      `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expect(editor.isFoldableAtBufferRow(0)).toBe(false);\n      expect(editor.isFoldableAtBufferRow(1)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(2)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(3)).toBe(false);\n      expect(editor.isFoldableAtBufferRow(4)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(5)).toBe(false);\n      editor.foldBufferRow(2);\n      expect(getDisplayText(editor)).toBe(dedent`\n        module.exports =\n        class A {\n          getB (c,…) {\n            return this.f(g)\n          }\n        }\n      `);\n      editor.foldBufferRow(4);\n      expect(getDisplayText(editor)).toBe(dedent`\n        module.exports =\n        class A {\n          getB (c,…) {…}\n        }\n      `);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "folds entire buffer rows when necessary to keep words on separate lines",
            "suites": [
                "TreeSitterLanguageMode",
                "folding"
            ],
            "updatePoint": {
                "line": 1617,
                "column": 79
            },
            "line": 1617,
            "code": "    it('folds entire buffer rows when necessary to keep words on separate lines', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        folds: [{\n          start: {\n            type: '{',\n            index: 0\n          },\n          end: {\n            type: '}',\n            index: -1\n          }\n        }, {\n          start: {\n            type: '(',\n            index: 0\n          },\n          end: {\n            type: ')',\n            index: -1\n          }\n        }]\n      });\n      buffer.setText(dedent`\n        if (a) {\n          b\n        } else if (c) {\n          d\n        } else {\n          e\n        }\n      `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode); // Avoid bringing the `else if...` up onto the same screen line as the preceding `if`.\n\n      editor.foldBufferRow(1);\n      editor.foldBufferRow(3);\n      expect(getDisplayText(editor)).toBe(dedent`\n        if (a) {…\n        } else if (c) {…\n        } else {\n          e\n        }\n      `); // It's ok to bring the final `}` onto the same screen line as the preceding `else`.\n\n      editor.foldBufferRow(5);\n      expect(getDisplayText(editor)).toBe(dedent`\n        if (a) {…\n        } else if (c) {…\n        } else {…}\n      `);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can fold nodes of specified types",
            "suites": [
                "TreeSitterLanguageMode",
                "folding"
            ],
            "updatePoint": {
                "line": 1672,
                "column": 41
            },
            "line": 1672,
            "code": "    it('can fold nodes of specified types', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        folds: [// Start the fold after the first child (the opening tag) and end it at the last child\n        // (the closing tag).\n        {\n          type: 'jsx_element',\n          start: {\n            index: 0\n          },\n          end: {\n            index: -1\n          }\n        }, // End the fold at the *second* to last child of the self-closing tag: the `/`.\n        {\n          type: 'jsx_self_closing_element',\n          start: {\n            index: 1\n          },\n          end: {\n            index: -2\n          }\n        }]\n      });\n      buffer.setText(dedent`\n        const element1 = <Element\n          className='submit'\n          id='something' />\n\n        const element2 = <Element>\n          <span>hello</span>\n          <span>world</span>\n        </Element>\n      `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expect(editor.isFoldableAtBufferRow(0)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(1)).toBe(false);\n      expect(editor.isFoldableAtBufferRow(2)).toBe(false);\n      expect(editor.isFoldableAtBufferRow(3)).toBe(false);\n      expect(editor.isFoldableAtBufferRow(4)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(5)).toBe(false);\n      editor.foldBufferRow(0);\n      expect(getDisplayText(editor)).toBe(dedent`\n        const element1 = <Element…/>\n\n        const element2 = <Element>\n          <span>hello</span>\n          <span>world</span>\n        </Element>\n      `);\n      editor.foldBufferRow(4);\n      expect(getDisplayText(editor)).toBe(dedent`\n        const element1 = <Element…/>\n\n        const element2 = <Element>…\n        </Element>\n      `);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can fold entire nodes when no start or end parameters are specified",
            "suites": [
                "TreeSitterLanguageMode",
                "folding"
            ],
            "updatePoint": {
                "line": 1734,
                "column": 75
            },
            "line": 1734,
            "code": "    it('can fold entire nodes when no start or end parameters are specified', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        folds: [// By default, for a node with no children, folds are started at the *end* of the first\n        // line of a node, and ended at the *beginning* of the last line.\n        {\n          type: 'comment'\n        }]\n      });\n      buffer.setText(dedent`\n        /**\n         * Important\n         */\n        const x = 1 /*\n          Also important\n        */\n      `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expect(editor.isFoldableAtBufferRow(0)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(1)).toBe(false);\n      expect(editor.isFoldableAtBufferRow(2)).toBe(false);\n      expect(editor.isFoldableAtBufferRow(3)).toBe(true);\n      expect(editor.isFoldableAtBufferRow(4)).toBe(false);\n      editor.foldBufferRow(0);\n      expect(getDisplayText(editor)).toBe(dedent`\n        /**… */\n        const x = 1 /*\n          Also important\n        */\n      `);\n      editor.foldBufferRow(3);\n      expect(getDisplayText(editor)).toBe(dedent`\n        /**… */\n        const x = 1 /*…*/\n      `);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "tries each folding strategy for a given node in the order specified",
            "suites": [
                "TreeSitterLanguageMode",
                "folding"
            ],
            "updatePoint": {
                "line": 1774,
                "column": 75
            },
            "line": 1774,
            "code": "    it('tries each folding strategy for a given node in the order specified', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, cGrammarPath, {\n        parser: 'tree-sitter-c',\n        folds: [// If the #ifdef has an `#else` clause, then end the fold there.\n        {\n          type: ['preproc_ifdef', 'preproc_elif'],\n          start: {\n            index: 1\n          },\n          end: {\n            type: ['preproc_else', 'preproc_elif']\n          }\n        }, // Otherwise, end the fold at the last child - the `#endif`.\n        {\n          type: 'preproc_ifdef',\n          start: {\n            index: 1\n          },\n          end: {\n            index: -1\n          }\n        }, // When folding an `#else` clause, the fold extends to the end of the clause.\n        {\n          type: 'preproc_else',\n          start: {\n            index: 0\n          }\n        }]\n      });\n      buffer.setText(dedent`\n        #ifndef FOO_H_\n        #define FOO_H_\n\n        #ifdef _WIN32\n\n        #include <windows.h>\n        const char *path_separator = \"\\\\\";\n\n        #elif defined MACOS\n\n        #include <carbon.h>\n        const char *path_separator = \"/\";\n\n        #else\n\n        #include <dirent.h>\n        const char *path_separator = \"/\";\n\n        #endif\n\n        #endif\n      `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      editor.foldBufferRow(3);\n      expect(getDisplayText(editor)).toBe(dedent`\n        #ifndef FOO_H_\n        #define FOO_H_\n\n        #ifdef _WIN32…\n        #elif defined MACOS\n\n        #include <carbon.h>\n        const char *path_separator = \"/\";\n\n        #else\n\n        #include <dirent.h>\n        const char *path_separator = \"/\";\n\n        #endif\n\n        #endif\n      `);\n      editor.foldBufferRow(8);\n      expect(getDisplayText(editor)).toBe(dedent`\n        #ifndef FOO_H_\n        #define FOO_H_\n\n        #ifdef _WIN32…\n        #elif defined MACOS…\n        #else\n\n        #include <dirent.h>\n        const char *path_separator = \"/\";\n\n        #endif\n\n        #endif\n      `);\n      editor.foldBufferRow(0);\n      expect(getDisplayText(editor)).toBe(dedent`\n        #ifndef FOO_H_…\n        #endif\n      `);\n      editor.foldAllAtIndentLevel(1);\n      expect(getDisplayText(editor)).toBe(dedent`\n        #ifndef FOO_H_\n        #define FOO_H_\n\n        #ifdef _WIN32…\n        #elif defined MACOS…\n        #else…\n\n        #endif\n\n        #endif\n      `);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not fold when the start and end parameters match the same child",
            "suites": [
                "TreeSitterLanguageMode",
                "folding"
            ],
            "updatePoint": {
                "line": 1886,
                "column": 76
            },
            "line": 1886,
            "code": "    it('does not fold when the start and end parameters match the same child', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, htmlGrammarPath, {\n        parser: 'tree-sitter-html',\n        folds: [{\n          type: 'element',\n          start: {\n            index: 0\n          },\n          end: {\n            index: -1\n          }\n        }]\n      });\n      buffer.setText(dedent`\n        <head>\n        <meta name='key-1', content='value-1'>\n        <meta name='key-2', content='value-2'>\n        </head>\n      `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode); // Void elements have only one child\n\n      expect(editor.isFoldableAtBufferRow(1)).toBe(false);\n      expect(editor.isFoldableAtBufferRow(2)).toBe(false);\n      editor.foldBufferRow(0);\n      expect(getDisplayText(editor)).toBe(dedent`\n        <head>…\n        </head>\n      `);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can target named vs anonymous nodes as fold boundaries",
            "suites": [
                "TreeSitterLanguageMode",
                "folding"
            ],
            "updatePoint": {
                "line": 1919,
                "column": 62
            },
            "line": 1919,
            "code": "    it('can target named vs anonymous nodes as fold boundaries', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, rubyGrammarPath, {\n        parser: 'tree-sitter-ruby',\n        folds: [// Note that this isn't how folds actually work in language-ruby. It's\n        // just to demonstrate the targeting of named vs anonymous nodes.\n        {\n          type: 'elsif',\n          start: {\n            index: 1\n          },\n          // There are no double quotes around the `elsif` type. This indicates\n          // that we're targeting a *named* node in the syntax tree. The fold\n          // should end at the nested `elsif` node, not at the token that represents\n          // the literal string \"elsif\".\n          end: {\n            type: ['else', 'elsif']\n          }\n        }, {\n          type: 'else',\n          // There are double quotes around the `else` type. This indicates that\n          // we're targeting an *anonymous* node in the syntax tree. The fold\n          // should start at the token representing the literal string \"else\",\n          // not at an `else` node.\n          start: {\n            type: '\"else\"'\n          }\n        }]\n      });\n      buffer.setText(dedent`\n        if a\n          b\n        elsif c\n          d\n        else\n          e\n        end\n      `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expect(languageMode.tree.rootNode.toString()).toBe('(program (if condition: (identifier) consequence: (then ' + '(identifier)) ' + 'alternative: (elsif condition: (identifier) consequence: (then ' + '(identifier)) ' + 'alternative: (else ' + '(identifier)))))');\n      editor.foldBufferRow(2);\n      expect(getDisplayText(editor)).toBe(dedent`\n        if a\n          b\n        elsif c…\n        else\n          e\n        end\n      `);\n      editor.foldBufferRow(4);\n      expect(getDisplayText(editor)).toBe(dedent`\n        if a\n          b\n        elsif c…\n        else…\n        end\n      `);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates fold locations when the buffer changes",
            "suites": [
                "TreeSitterLanguageMode",
                "folding"
            ],
            "updatePoint": {
                "line": 1980,
                "column": 54
            },
            "line": 1980,
            "code": "    it('updates fold locations when the buffer changes', () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        folds: [{\n          start: {\n            type: '{',\n            index: 0\n          },\n          end: {\n            type: '}',\n            index: -1\n          }\n        }]\n      });\n      buffer.setText(dedent`\n        class A {\n          // a\n          constructor (b) {\n            this.b = b\n          }\n        }\n      `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expect(languageMode.isFoldableAtRow(0)).toBe(true);\n      expect(languageMode.isFoldableAtRow(1)).toBe(false);\n      expect(languageMode.isFoldableAtRow(2)).toBe(true);\n      expect(languageMode.isFoldableAtRow(3)).toBe(false);\n      expect(languageMode.isFoldableAtRow(4)).toBe(false);\n      buffer.insert([0, 0], '\\n');\n      expect(languageMode.isFoldableAtRow(0)).toBe(false);\n      expect(languageMode.isFoldableAtRow(1)).toBe(true);\n      expect(languageMode.isFoldableAtRow(2)).toBe(false);\n      expect(languageMode.isFoldableAtRow(3)).toBe(true);\n      expect(languageMode.isFoldableAtRow(4)).toBe(false);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ends the fold at the end of the previous line",
            "suites": [
                "TreeSitterLanguageMode",
                "folding",
                "when folding a node that ends with a line break"
            ],
            "updatePoint": {
                "line": 2020,
                "column": 55
            },
            "line": 2020,
            "code": "      it('ends the fold at the end of the previous line', async () => {\n        const grammar = new TreeSitterGrammar(atom.grammars, pythonGrammarPath, {\n          parser: 'tree-sitter-python',\n          folds: [{\n            type: 'function_definition',\n            start: {\n              type: ':'\n            }\n          }]\n        });\n        buffer.setText(dedent`\n          def ab():\n            print 'a'\n            print 'b'\n\n          def cd():\n            print 'c'\n            print 'd'\n        `);\n        buffer.setLanguageMode(new TreeSitterLanguageMode({\n          buffer,\n          grammar\n        }));\n        editor.foldBufferRow(0);\n        expect(getDisplayText(editor)).toBe(dedent`\n          def ab():…\n\n          def cd():\n            print 'c'\n            print 'd'\n        `);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "folds code in injected languages",
            "suites": [
                "TreeSitterLanguageMode",
                "folding",
                "when folding a node that ends with a line break"
            ],
            "updatePoint": {
                "line": 2053,
                "column": 40
            },
            "line": 2053,
            "code": "    it('folds code in injected languages', async () => {\n      const htmlGrammar = new TreeSitterGrammar(atom.grammars, htmlGrammarPath, {\n        scopeName: 'html',\n        parser: 'tree-sitter-html',\n        scopes: {},\n        folds: [{\n          type: ['element', 'script_element'],\n          start: {\n            index: 0\n          },\n          end: {\n            index: -1\n          }\n        }],\n        injectionRegExp: 'html'\n      });\n      const jsGrammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        scopeName: 'javascript',\n        parser: 'tree-sitter-javascript',\n        scopes: {},\n        folds: [{\n          type: ['template_string'],\n          start: {\n            index: 0\n          },\n          end: {\n            index: -1\n          }\n        }, {\n          start: {\n            index: 0,\n            type: '('\n          },\n          end: {\n            index: -1,\n            type: ')'\n          }\n        }],\n        injectionRegExp: 'javascript',\n        injectionPoints: [HTML_TEMPLATE_LITERAL_INJECTION_POINT]\n      });\n      atom.grammars.addGrammar(htmlGrammar);\n      buffer.setText(`a = html \\`\n            <div>\n              c\\${def(\n                1,\n                2,\n                3,\n              )}e\\${f}g\n            </div>\n          \\`\n        `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar: jsGrammar,\n        grammars: atom.grammars\n      });\n      buffer.setLanguageMode(languageMode);\n      editor.foldBufferRow(2);\n      expect(getDisplayText(editor)).toBe(`a = html \\`\n            <div>\n              c\\${def(…\n              )}e\\${f}g\n            </div>\n          \\`\n        `);\n      editor.foldBufferRow(1);\n      expect(getDisplayText(editor)).toBe(`a = html \\`\n            <div>…\n            </div>\n          \\`\n        `);\n      editor.foldBufferRow(0);\n      expect(getDisplayText(editor)).toBe(`a = html \\`…\\`\n        `);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a scope descriptor representing the given position in the syntax tree",
            "suites": [
                "TreeSitterLanguageMode",
                ".scopeDescriptorForPosition"
            ],
            "updatePoint": {
                "line": 2131,
                "column": 85
            },
            "line": 2131,
            "code": "    it('returns a scope descriptor representing the given position in the syntax tree', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        scopeName: 'source.js',\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          program: 'source.js',\n          property_identifier: 'property.name',\n          comment: 'comment.block'\n        }\n      });\n      buffer.setText('foo({bar: baz});');\n      buffer.setLanguageMode(new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      }));\n      expect(editor.scopeDescriptorForBufferPosition([0, 'foo({b'.length]).getScopesArray()).toEqual(['source.js', 'property.name']);\n      expect(editor.scopeDescriptorForBufferPosition([0, 'foo({'.length]).getScopesArray()).toEqual(['source.js', 'property.name']); // Drive-by test for .tokenForPosition()\n\n      const token = editor.tokenForBufferPosition([0, 'foo({b'.length]);\n      expect(token.value).toBe('bar');\n      expect(token.scopes).toEqual(['source.js', 'property.name']);\n      buffer.setText('// baz\\n'); // Adjust position when at end of line\n\n      buffer.setLanguageMode(new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      }));\n      expect(editor.scopeDescriptorForBufferPosition([0, '// baz'.length]).getScopesArray()).toEqual(['source.js', 'comment.block']);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes nodes in injected syntax trees",
            "suites": [
                "TreeSitterLanguageMode",
                ".scopeDescriptorForPosition"
            ],
            "updatePoint": {
                "line": 2160,
                "column": 47
            },
            "line": 2160,
            "code": "    it('includes nodes in injected syntax trees', async () => {\n      const jsGrammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        scopeName: 'source.js',\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          program: 'source.js',\n          template_string: 'string.quoted',\n          interpolation: 'meta.embedded',\n          property_identifier: 'property.name'\n        },\n        injectionRegExp: 'javascript',\n        injectionPoints: [HTML_TEMPLATE_LITERAL_INJECTION_POINT]\n      });\n      const htmlGrammar = new TreeSitterGrammar(atom.grammars, htmlGrammarPath, {\n        scopeName: 'text.html',\n        parser: 'tree-sitter-html',\n        scopes: {\n          fragment: 'text.html',\n          script_element: 'script.tag'\n        },\n        injectionRegExp: 'html',\n        injectionPoints: [SCRIPT_TAG_INJECTION_POINT]\n      });\n      atom.grammars.addGrammar(jsGrammar);\n      atom.grammars.addGrammar(htmlGrammar);\n      buffer.setText(`\n        <div>\n          <script>\n            html \\`\n              <span>\\${person.name}</span>\n            \\`\n          </script>\n        </div>\n      `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar: htmlGrammar,\n        grammars: atom.grammars\n      });\n      buffer.setLanguageMode(languageMode);\n      const position = buffer.findSync('name').start;\n      expect(languageMode.scopeDescriptorForPosition(position).getScopesArray()).toEqual(['text.html', 'script.tag', 'source.js', 'string.quoted', 'text.html', 'property.name']);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes the root scope name even when the given position is in trailing whitespace at EOF",
            "suites": [
                "TreeSitterLanguageMode",
                ".scopeDescriptorForPosition"
            ],
            "updatePoint": {
                "line": 2203,
                "column": 98
            },
            "line": 2203,
            "code": "    it('includes the root scope name even when the given position is in trailing whitespace at EOF', () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        scopeName: 'source.js',\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          program: 'source.js',\n          property_identifier: 'property.name'\n        }\n      });\n      buffer.setText('a; ');\n      buffer.setLanguageMode(new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      }));\n      expect(editor.scopeDescriptorForBufferPosition([0, 3]).getScopesArray()).toEqual(['source.js']);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works when the given position is between tokens",
            "suites": [
                "TreeSitterLanguageMode",
                ".scopeDescriptorForPosition"
            ],
            "updatePoint": {
                "line": 2219,
                "column": 55
            },
            "line": 2219,
            "code": "    it('works when the given position is between tokens', () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        scopeName: 'source.js',\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          program: 'source.js',\n          comment: 'comment.block'\n        }\n      });\n      buffer.setText('a  // b');\n      buffer.setLanguageMode(new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      }));\n      expect(editor.scopeDescriptorForBufferPosition([0, 2]).getScopesArray()).toEqual(['source.js']);\n      expect(editor.scopeDescriptorForBufferPosition([0, 3]).getScopesArray()).toEqual(['source.js', 'comment.block']);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a scope descriptor representing the given position in the syntax tree",
            "suites": [
                "TreeSitterLanguageMode",
                ".syntaxTreeScopeDescriptorForPosition"
            ],
            "updatePoint": {
                "line": 2238,
                "column": 85
            },
            "line": 2238,
            "code": "    it('returns a scope descriptor representing the given position in the syntax tree', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        scopeName: 'source.js',\n        parser: 'tree-sitter-javascript'\n      });\n      buffer.setText('foo({bar: baz});');\n      buffer.setLanguageMode(new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      }));\n      expect(editor.syntaxTreeScopeDescriptorForBufferPosition([0, 6]).getScopesArray()).toEqual(['source.js', 'program', 'expression_statement', 'call_expression', 'arguments', 'object', 'pair', 'property_identifier']);\n      buffer.setText('//bar\\n');\n      buffer.setLanguageMode(new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      }));\n      expect(editor.syntaxTreeScopeDescriptorForBufferPosition([0, 5]).getScopesArray()).toEqual(['source.js', 'program', 'comment']);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes nodes in injected syntax trees",
            "suites": [
                "TreeSitterLanguageMode",
                ".syntaxTreeScopeDescriptorForPosition"
            ],
            "updatePoint": {
                "line": 2256,
                "column": 47
            },
            "line": 2256,
            "code": "    it('includes nodes in injected syntax trees', async () => {\n      const jsGrammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        scopeName: 'source.js',\n        parser: 'tree-sitter-javascript',\n        scopes: {},\n        injectionRegExp: 'javascript',\n        injectionPoints: [HTML_TEMPLATE_LITERAL_INJECTION_POINT]\n      });\n      const htmlGrammar = new TreeSitterGrammar(atom.grammars, htmlGrammarPath, {\n        scopeName: 'text.html',\n        parser: 'tree-sitter-html',\n        scopes: {},\n        injectionRegExp: 'html',\n        injectionPoints: [SCRIPT_TAG_INJECTION_POINT]\n      });\n      atom.grammars.addGrammar(jsGrammar);\n      atom.grammars.addGrammar(htmlGrammar);\n      buffer.setText(`\n        <div>\n          <script>\n            html \\`\n              <span>\\${person.name}</span>\n            \\`\n          </script>\n        </div>\n      `);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar: htmlGrammar,\n        grammars: atom.grammars\n      });\n      buffer.setLanguageMode(languageMode);\n      const position = buffer.findSync('name').start;\n      expect(editor.syntaxTreeScopeDescriptorForBufferPosition(position).getScopesArray()).toEqual(['text.html', 'fragment', 'element', 'script_element', 'program', 'raw_text', 'expression_statement', 'call_expression', 'template_string', 'fragment', 'element', 'template_substitution', 'member_expression', 'property_identifier']);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the range of the smallest node at position",
            "suites": [
                "TreeSitterLanguageMode",
                ".bufferRangeForScopeAtPosition(selector?, position)",
                "when selector = null"
            ],
            "updatePoint": {
                "line": 2294,
                "column": 60
            },
            "line": 2294,
            "code": "      it('returns the range of the smallest node at position', async () => {\n        const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n          scopeName: 'javascript',\n          parser: 'tree-sitter-javascript'\n        });\n        buffer.setText('foo({bar: baz});');\n        buffer.setLanguageMode(new TreeSitterLanguageMode({\n          buffer,\n          grammar\n        }));\n        expect(editor.bufferRangeForScopeAtPosition(null, [0, 6])).toEqual([[0, 5], [0, 8]]);\n        expect(editor.bufferRangeForScopeAtPosition(null, [0, 8])).toEqual([[0, 8], [0, 9]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes nodes in injected syntax trees",
            "suites": [
                "TreeSitterLanguageMode",
                ".bufferRangeForScopeAtPosition(selector?, position)",
                "when selector = null"
            ],
            "updatePoint": {
                "line": 2307,
                "column": 49
            },
            "line": 2307,
            "code": "      it('includes nodes in injected syntax trees', async () => {\n        const jsGrammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n          scopeName: 'javascript',\n          parser: 'tree-sitter-javascript',\n          scopes: {},\n          injectionRegExp: 'javascript',\n          injectionPoints: [HTML_TEMPLATE_LITERAL_INJECTION_POINT]\n        });\n        const htmlGrammar = new TreeSitterGrammar(atom.grammars, htmlGrammarPath, {\n          scopeName: 'html',\n          parser: 'tree-sitter-html',\n          scopes: {},\n          injectionRegExp: 'html',\n          injectionPoints: [SCRIPT_TAG_INJECTION_POINT]\n        });\n        atom.grammars.addGrammar(jsGrammar);\n        atom.grammars.addGrammar(htmlGrammar);\n        buffer.setText(`\n          <div>\n            <script>\n              html \\`\n                <span>\\${person.name}</span>\n              \\`\n            </script>\n          </div>\n        `);\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar: htmlGrammar,\n          grammars: atom.grammars\n        });\n        buffer.setLanguageMode(languageMode);\n        const nameProperty = buffer.findSync('name');\n        const {\n          start\n        } = nameProperty;\n        const position = Object.assign({}, start, {\n          column: start.column + 2\n        });\n        expect(languageMode.bufferRangeForScopeAtPosition(null, position)).toEqual(nameProperty);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the range of the smallest matching node at position",
            "suites": [
                "TreeSitterLanguageMode",
                ".bufferRangeForScopeAtPosition(selector?, position)",
                "with a selector"
            ],
            "updatePoint": {
                "line": 2350,
                "column": 69
            },
            "line": 2350,
            "code": "      it('returns the range of the smallest matching node at position', async () => {\n        const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n          scopeName: 'javascript',\n          parser: 'tree-sitter-javascript',\n          scopes: {\n            property_identifier: 'variable.other.object.property',\n            template_string: 'string.quoted.template'\n          }\n        });\n        buffer.setText('a(`${b({ccc: ddd})} eee`);');\n        buffer.setLanguageMode(new TreeSitterLanguageMode({\n          buffer,\n          grammar\n        }));\n        expect(editor.bufferRangeForScopeAtPosition('.variable.property', [0, 9])).toEqual([[0, 8], [0, 11]]);\n        expect(editor.bufferRangeForScopeAtPosition('.string.quoted', [0, 6])).toEqual([[0, 2], [0, 24]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes nodes in injected syntax trees",
            "suites": [
                "TreeSitterLanguageMode",
                ".bufferRangeForScopeAtPosition(selector?, position)",
                "with a selector"
            ],
            "updatePoint": {
                "line": 2367,
                "column": 49
            },
            "line": 2367,
            "code": "      it('includes nodes in injected syntax trees', async () => {\n        const jsGrammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n          scopeName: 'javascript',\n          parser: 'tree-sitter-javascript',\n          scopes: {\n            property_identifier: 'variable.other.object.property'\n          },\n          injectionRegExp: 'javascript',\n          injectionPoints: [HTML_TEMPLATE_LITERAL_INJECTION_POINT]\n        });\n        const htmlGrammar = new TreeSitterGrammar(atom.grammars, htmlGrammarPath, {\n          scopeName: 'html',\n          parser: 'tree-sitter-html',\n          scopes: {\n            element: 'meta.element.html'\n          },\n          injectionRegExp: 'html',\n          injectionPoints: [SCRIPT_TAG_INJECTION_POINT]\n        });\n        atom.grammars.addGrammar(jsGrammar);\n        atom.grammars.addGrammar(htmlGrammar);\n        buffer.setText(`\n          <div>\n            <script>\n              html \\`\n                <span>\\${person.name}</span>\n              \\`\n            </script>\n          </div>\n        `);\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar: htmlGrammar,\n          grammars: atom.grammars\n        });\n        buffer.setLanguageMode(languageMode);\n        const nameProperty = buffer.findSync('name');\n        const {\n          start\n        } = nameProperty;\n        const position = Object.assign({}, start, {\n          column: start.column + 2\n        });\n        expect(languageMode.bufferRangeForScopeAtPosition('.object.property', position)).toEqual(nameProperty);\n        expect(languageMode.bufferRangeForScopeAtPosition('.meta.element.html', position)).toEqual(buffer.findSync('<span>\\\\${person\\\\.name}</span>'));\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "accepts node-matching functions as selectors",
            "suites": [
                "TreeSitterLanguageMode",
                ".bufferRangeForScopeAtPosition(selector?, position)",
                "with a selector"
            ],
            "updatePoint": {
                "line": 2413,
                "column": 54
            },
            "line": 2413,
            "code": "      it('accepts node-matching functions as selectors', async () => {\n        const jsGrammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n          scopeName: 'javascript',\n          parser: 'tree-sitter-javascript',\n          scopes: {},\n          injectionRegExp: 'javascript',\n          injectionPoints: [HTML_TEMPLATE_LITERAL_INJECTION_POINT]\n        });\n        const htmlGrammar = new TreeSitterGrammar(atom.grammars, htmlGrammarPath, {\n          scopeName: 'html',\n          parser: 'tree-sitter-html',\n          scopes: {},\n          injectionRegExp: 'html',\n          injectionPoints: [SCRIPT_TAG_INJECTION_POINT]\n        });\n        atom.grammars.addGrammar(jsGrammar);\n        atom.grammars.addGrammar(htmlGrammar);\n        buffer.setText(`\n          <div>\n            <script>\n              html \\`\n                <span>\\${person.name}</span>\n              \\`\n            </script>\n          </div>\n        `);\n        const languageMode = new TreeSitterLanguageMode({\n          buffer,\n          grammar: htmlGrammar,\n          grammars: atom.grammars\n        });\n        buffer.setLanguageMode(languageMode);\n        const nameProperty = buffer.findSync('name');\n        const {\n          start\n        } = nameProperty;\n        const position = Object.assign({}, start, {\n          column: start.column + 2\n        });\n\n        const templateStringInCallExpression = node => node.type === 'template_string' && node.parent.type === 'call_expression';\n\n        expect(languageMode.bufferRangeForScopeAtPosition(templateStringInCallExpression, position)).toEqual([[3, 19], [5, 15]]);\n      });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the range of the smallest matching node at position",
            "suites": [
                "TreeSitterLanguageMode",
                ".getSyntaxNodeAtPosition(position, where?)"
            ],
            "updatePoint": {
                "line": 2460,
                "column": 67
            },
            "line": 2460,
            "code": "    it('returns the range of the smallest matching node at position', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        scopeName: 'javascript',\n        parser: 'tree-sitter-javascript'\n      });\n      buffer.setText('foo(bar({x: 2}));');\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expect(languageMode.getSyntaxNodeAtPosition([0, 6]).range).toEqual(buffer.findSync('bar'));\n\n      const findFoo = node => node.type === 'call_expression' && node.firstChild.text === 'foo';\n\n      expect(languageMode.getSyntaxNodeAtPosition([0, 6], findFoo).range).toEqual([[0, 0], [0, buffer.getText().length - 1]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the correct comment strings for nested languages",
            "suites": [
                "TreeSitterLanguageMode",
                ".commentStringsForPosition(position)"
            ],
            "updatePoint": {
                "line": 2479,
                "column": 64
            },
            "line": 2479,
            "code": "    it('returns the correct comment strings for nested languages', () => {\n      const jsGrammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        scopeName: 'javascript',\n        parser: 'tree-sitter-javascript',\n        comments: {\n          start: '//'\n        },\n        injectionRegExp: 'javascript',\n        injectionPoints: [HTML_TEMPLATE_LITERAL_INJECTION_POINT]\n      });\n      const htmlGrammar = new TreeSitterGrammar(atom.grammars, htmlGrammarPath, {\n        scopeName: 'html',\n        parser: 'tree-sitter-html',\n        scopes: {},\n        comments: {\n          start: '<!--',\n          end: '-->'\n        },\n        injectionRegExp: 'html',\n        injectionPoints: [SCRIPT_TAG_INJECTION_POINT]\n      });\n      atom.grammars.addGrammar(jsGrammar);\n      atom.grammars.addGrammar(htmlGrammar);\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar: htmlGrammar,\n        grammars: atom.grammars\n      });\n      buffer.setLanguageMode(languageMode);\n      buffer.setText(`\n        <div>hi</div>\n        <script>\n          const node = document.getElementById('some-id');\n          node.innerHTML = html \\`\n            <span>bye</span>\n          \\`\n        </script>\n      `.trim());\n      const htmlCommentStrings = {\n        commentStartString: '<!--',\n        commentEndString: '-->'\n      };\n      const jsCommentStrings = {\n        commentStartString: '//',\n        commentEndString: undefined\n      };\n      expect(languageMode.commentStringsForPosition(new Point(0, 0))).toEqual(htmlCommentStrings);\n      expect(languageMode.commentStringsForPosition(new Point(1, 0))).toEqual(htmlCommentStrings);\n      expect(languageMode.commentStringsForPosition(new Point(2, 0))).toEqual(jsCommentStrings);\n      expect(languageMode.commentStringsForPosition(new Point(3, 0))).toEqual(jsCommentStrings);\n      expect(languageMode.commentStringsForPosition(new Point(4, 0))).toEqual(htmlCommentStrings);\n      expect(languageMode.commentStringsForPosition(new Point(5, 0))).toEqual(jsCommentStrings);\n      expect(languageMode.commentStringsForPosition(new Point(6, 0))).toEqual(htmlCommentStrings);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "expands and contracts the selection based on the syntax tree",
            "suites": [
                "TreeSitterLanguageMode",
                "TextEditor.selectLargerSyntaxNode and .selectSmallerSyntaxNode"
            ],
            "updatePoint": {
                "line": 2535,
                "column": 68
            },
            "line": 2535,
            "code": "    it('expands and contracts the selection based on the syntax tree', async () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          program: 'source'\n        }\n      });\n      buffer.setText(dedent`\n        function a (b, c, d) {\n          eee.f()\n          g()\n        }\n      `);\n      buffer.setLanguageMode(new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      }));\n      editor.setCursorBufferPosition([1, 3]);\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('eee');\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('eee.f');\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('eee.f()');\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('{\\n  eee.f()\\n  g()\\n}');\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('function a (b, c, d) {\\n  eee.f()\\n  g()\\n}');\n      editor.selectSmallerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('{\\n  eee.f()\\n  g()\\n}');\n      editor.selectSmallerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('eee.f()');\n      editor.selectSmallerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('eee.f');\n      editor.selectSmallerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('eee');\n      editor.selectSmallerSyntaxNode();\n      expect(editor.getSelectedBufferRange()).toEqual([[1, 3], [1, 3]]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "handles injected languages",
            "suites": [
                "TreeSitterLanguageMode",
                "TextEditor.selectLargerSyntaxNode and .selectSmallerSyntaxNode"
            ],
            "updatePoint": {
                "line": 2574,
                "column": 34
            },
            "line": 2574,
            "code": "    it('handles injected languages', async () => {\n      const jsGrammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        scopeName: 'javascript',\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          property_identifier: 'property',\n          'call_expression > identifier': 'function',\n          template_string: 'string',\n          'template_substitution > \"${\"': 'interpolation',\n          'template_substitution > \"}\"': 'interpolation'\n        },\n        injectionRegExp: 'javascript',\n        injectionPoints: [HTML_TEMPLATE_LITERAL_INJECTION_POINT]\n      });\n      const htmlGrammar = new TreeSitterGrammar(atom.grammars, htmlGrammarPath, {\n        scopeName: 'html',\n        parser: 'tree-sitter-html',\n        scopes: {\n          fragment: 'html',\n          tag_name: 'tag',\n          attribute_name: 'attr'\n        },\n        injectionRegExp: 'html'\n      });\n      atom.grammars.addGrammar(htmlGrammar);\n      buffer.setText('a = html ` <b>c${def()}e${f}g</b> `');\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar: jsGrammar,\n        grammars: atom.grammars\n      });\n      buffer.setLanguageMode(languageMode);\n      editor.setCursorBufferPosition({\n        row: 0,\n        column: buffer.getText().indexOf('ef()')\n      });\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('def');\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('def()');\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('${def()}');\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('c${def()}e${f}g');\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('<b>c${def()}e${f}g</b>');\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe(' <b>c${def()}e${f}g</b> ');\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('` <b>c${def()}e${f}g</b> `');\n      editor.selectLargerSyntaxNode();\n      expect(editor.getSelectedText()).toBe('html ` <b>c${def()}e${f}g</b> `');\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a shimmed TokenizedLine with tokens",
            "suites": [
                "TreeSitterLanguageMode",
                ".tokenizedLineForRow(row)"
            ],
            "updatePoint": {
                "line": 2629,
                "column": 51
            },
            "line": 2629,
            "code": "    it('returns a shimmed TokenizedLine with tokens', () => {\n      const grammar = new TreeSitterGrammar(atom.grammars, jsGrammarPath, {\n        parser: 'tree-sitter-javascript',\n        scopes: {\n          program: 'source',\n          'call_expression > identifier': 'function',\n          property_identifier: 'property',\n          'call_expression > member_expression > property_identifier': 'method',\n          identifier: 'variable'\n        }\n      });\n      buffer.setText('aa.bbb = cc(d.eee());\\n\\n    \\n  b');\n      const languageMode = new TreeSitterLanguageMode({\n        buffer,\n        grammar\n      });\n      buffer.setLanguageMode(languageMode);\n      expect(languageMode.tokenizedLineForRow(0).tokens).toEqual([{\n        value: 'aa',\n        scopes: ['source', 'variable']\n      }, {\n        value: '.',\n        scopes: ['source']\n      }, {\n        value: 'bbb',\n        scopes: ['source', 'property']\n      }, {\n        value: ' = ',\n        scopes: ['source']\n      }, {\n        value: 'cc',\n        scopes: ['source', 'function']\n      }, {\n        value: '(',\n        scopes: ['source']\n      }, {\n        value: 'd',\n        scopes: ['source', 'variable']\n      }, {\n        value: '.',\n        scopes: ['source']\n      }, {\n        value: 'eee',\n        scopes: ['source', 'method']\n      }, {\n        value: '());',\n        scopes: ['source']\n      }]);\n      expect(languageMode.tokenizedLineForRow(1).tokens).toEqual([]);\n      expect(languageMode.tokenizedLineForRow(2).tokens).toEqual([{\n        value: '    ',\n        scopes: ['source']\n      }]);\n      expect(languageMode.tokenizedLineForRow(3).tokens).toEqual([{\n        value: '  ',\n        scopes: ['source']\n      }, {\n        value: 'b',\n        scopes: ['source', 'variable']\n      }]);\n    });",
            "file": "tree-sitter-language-mode-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "transpiles it using typescript",
            "suites": [
                "TypeScript transpiler support",
                "when there is a .ts file"
            ],
            "updatePoint": {
                "line": 2,
                "column": 79
            },
            "line": 2,
            "code": "  describe('when there is a .ts file', () => it('transpiles it using typescript', function () {\n    const transpiled = require('./fixtures/typescript/valid.ts');\n\n    expect(transpiled(3)).toBe(4);\n  }));",
            "file": "typescript-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not transpile",
            "suites": [
                "TypeScript transpiler support",
                "when the .ts file is invalid"
            ],
            "updatePoint": {
                "line": 7,
                "column": 71
            },
            "line": 7,
            "code": "  describe('when the .ts file is invalid', () => it('does not transpile', () => expect(() => require('./fixtures/typescript/invalid.ts')).toThrow()));",
            "file": "typescript-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates process.env to match the launch environment because PWD is set",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment appears to come from a shell"
            ],
            "updatePoint": {
                "line": 33,
                "column": 78
            },
            "line": 33,
            "code": "    it('updates process.env to match the launch environment because PWD is set', async function () {\n      process.env = {\n        WILL_BE_DELETED: 'hi',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      };\n      const initialProcessEnv = process.env;\n      await updateProcessEnv({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PWD: '/the/dir',\n        TERM: 'xterm-something',\n        KEY1: 'value1',\n        KEY2: 'value2'\n      });\n      expect(process.env).toEqual({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PWD: '/the/dir',\n        TERM: 'xterm-something',\n        KEY1: 'value1',\n        KEY2: 'value2',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      }); // See #11302. On Windows, `process.env` is a magic object that offers\n      // case-insensitive environment variable matching, so we cannot replace it\n      // with another object.\n\n      expect(process.env).toBe(initialProcessEnv);\n    });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates process.env to match the launch environment because PROMPT is set",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment appears to come from a shell"
            ],
            "updatePoint": {
                "line": 63,
                "column": 81
            },
            "line": 63,
            "code": "    it('updates process.env to match the launch environment because PROMPT is set', async function () {\n      process.env = {\n        WILL_BE_DELETED: 'hi',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      };\n      const initialProcessEnv = process.env;\n      await updateProcessEnv({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PROMPT: '$P$G',\n        KEY1: 'value1',\n        KEY2: 'value2'\n      });\n      expect(process.env).toEqual({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PROMPT: '$P$G',\n        KEY1: 'value1',\n        KEY2: 'value2',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      }); // See #11302. On Windows, `process.env` is a magic object that offers\n      // case-insensitive environment variable matching, so we cannot replace it\n      // with another object.\n\n      expect(process.env).toBe(initialProcessEnv);\n    });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates process.env to match the launch environment because PSModulePath is set",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment appears to come from a shell"
            ],
            "updatePoint": {
                "line": 91,
                "column": 87
            },
            "line": 91,
            "code": "    it('updates process.env to match the launch environment because PSModulePath is set', async function () {\n      process.env = {\n        WILL_BE_DELETED: 'hi',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      };\n      const initialProcessEnv = process.env;\n      await updateProcessEnv({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PSModulePath: 'C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\WINDOWS\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules\\\\',\n        KEY1: 'value1',\n        KEY2: 'value2'\n      });\n      expect(process.env).toEqual({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PSModulePath: 'C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\WINDOWS\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules\\\\',\n        KEY1: 'value1',\n        KEY2: 'value2',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      }); // See #11302. On Windows, `process.env` is a magic object that offers\n      // case-insensitive environment variable matching, so we cannot replace it\n      // with another object.\n\n      expect(process.env).toBe(initialProcessEnv);\n    });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows ATOM_HOME to be overwritten only if the new value is a valid path",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment appears to come from a shell"
            ],
            "updatePoint": {
                "line": 119,
                "column": 80
            },
            "line": 119,
            "code": "    it('allows ATOM_HOME to be overwritten only if the new value is a valid path', async function () {\n      let newAtomHomePath = temp.mkdirSync('atom-home');\n      process.env = {\n        WILL_BE_DELETED: 'hi',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      };\n      await updateProcessEnv({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PWD: '/the/dir'\n      });\n      expect(process.env).toEqual({\n        PWD: '/the/dir',\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      });\n      await updateProcessEnv({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PWD: '/the/dir',\n        ATOM_HOME: path.join(newAtomHomePath, 'non-existent')\n      });\n      expect(process.env).toEqual({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PWD: '/the/dir',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      });\n      await updateProcessEnv({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PWD: '/the/dir',\n        ATOM_HOME: newAtomHomePath\n      });\n      expect(process.env).toEqual({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PWD: '/the/dir',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: newAtomHomePath\n      });\n    });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT to be preserved if set",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment appears to come from a shell"
            ],
            "updatePoint": {
                "line": 163,
                "column": 79
            },
            "line": 163,
            "code": "    it('allows ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT to be preserved if set', async function () {\n      process.env = {\n        WILL_BE_DELETED: 'hi',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      };\n      await updateProcessEnv({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PWD: '/the/dir',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      });\n      expect(process.env).toEqual({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PWD: '/the/dir',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      });\n      await updateProcessEnv({\n        PWD: '/the/dir',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      });\n      expect(process.env).toEqual({\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        PWD: '/the/dir',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      });\n    });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "allows an existing env variable to be updated",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment appears to come from a shell"
            ],
            "updatePoint": {
                "line": 198,
                "column": 53
            },
            "line": 198,
            "code": "    it('allows an existing env variable to be updated', async function () {\n      process.env = {\n        WILL_BE_UPDATED: 'old-value',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home'\n      };\n      await updateProcessEnv(process.env);\n      expect(process.env).toEqual(process.env);\n      let updatedEnv = {\n        ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n        WILL_BE_UPDATED: 'new-value',\n        NODE_ENV: 'the-node-env',\n        NODE_PATH: '/the/node/path',\n        ATOM_HOME: '/the/atom/home',\n        PWD: '/the/dir'\n      };\n      await updateProcessEnv(updatedEnv);\n      expect(process.env).toEqual(updatedEnv);\n    });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates process.env to match the environment in the user's login shell",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment does not come from a shell",
                "on macOS"
            ],
            "updatePoint": {
                "line": 221,
                "column": 80
            },
            "line": 221,
            "code": "      it(\"updates process.env to match the environment in the user's login shell\", async function () {\n        if (process.platform === 'win32') return; // TestsThatFailOnWin32\n\n        process.platform = 'darwin';\n        process.env.SHELL = '/my/custom/bash';\n        spawn.setDefault(spawn.simple(0, 'FOO=BAR=BAZ=QUUX\\0MULTILINE\\nNAME=multiline\\nvalue\\0TERM=xterm-something\\0PATH=/usr/bin:/bin:/usr/sbin:/sbin:/crazy/path'));\n        await updateProcessEnv(process.env);\n        expect(spawn.calls.length).toBe(1);\n        expect(spawn.calls[0].command).toBe('/my/custom/bash');\n        expect(spawn.calls[0].args).toEqual(['-ilc', 'command awk \\'BEGIN{for(v in ENVIRON) printf(\"%s=%s%c\", v, ENVIRON[v], 0)}\\'']);\n        expect(process.env).toEqual({\n          FOO: 'BAR=BAZ=QUUX',\n          'MULTILINE\\nNAME': 'multiline\\nvalue',\n          TERM: 'xterm-something',\n          PATH: '/usr/bin:/bin:/usr/sbin:/sbin:/crazy/path'\n        }); // Doesn't error\n\n        await updateProcessEnv(null);\n      });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates process.env to match the environment in the user's login shell",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment does not come from a shell",
                "on linux"
            ],
            "updatePoint": {
                "line": 242,
                "column": 80
            },
            "line": 242,
            "code": "      it(\"updates process.env to match the environment in the user's login shell\", async function () {\n        if (process.platform === 'win32') return; // TestsThatFailOnWin32\n\n        process.platform = 'linux';\n        process.env.SHELL = '/my/custom/bash';\n        spawn.setDefault(spawn.simple(0, 'FOO=BAR=BAZ=QUUX\\0MULTILINE\\nNAME=multiline\\nvalue\\0TERM=xterm-something\\0PATH=/usr/bin:/bin:/usr/sbin:/sbin:/crazy/path'));\n        await updateProcessEnv(process.env);\n        expect(spawn.calls.length).toBe(1);\n        expect(spawn.calls[0].command).toBe('/my/custom/bash');\n        expect(spawn.calls[0].args).toEqual(['-ilc', 'command awk \\'BEGIN{for(v in ENVIRON) printf(\"%s=%s%c\", v, ENVIRON[v], 0)}\\'']);\n        expect(process.env).toEqual({\n          FOO: 'BAR=BAZ=QUUX',\n          'MULTILINE\\nNAME': 'multiline\\nvalue',\n          TERM: 'xterm-something',\n          PATH: '/usr/bin:/bin:/usr/sbin:/sbin:/crazy/path'\n        }); // Doesn't error\n\n        await updateProcessEnv(null);\n      });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not update process.env",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment does not come from a shell",
                "on windows"
            ],
            "updatePoint": {
                "line": 263,
                "column": 37
            },
            "line": 263,
            "code": "      it('does not update process.env', async function () {\n        process.platform = 'win32';\n        spyOn(childProcess, 'spawn');\n        process.env = {\n          FOO: 'bar'\n        };\n        await updateProcessEnv(process.env);\n        expect(childProcess.spawn).not.toHaveBeenCalled();\n        expect(process.env).toEqual({\n          FOO: 'bar'\n        });\n      });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "indicates when the environment should be fetched from the shell",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment does not come from a shell",
                "shouldGetEnvFromShell()"
            ],
            "updatePoint": {
                "line": 277,
                "column": 73
            },
            "line": 277,
            "code": "      it('indicates when the environment should be fetched from the shell', function () {\n        if (process.platform === 'win32') return; // TestsThatFailOnWin32\n\n        process.platform = 'darwin';\n        expect(shouldGetEnvFromShell({\n          SHELL: '/bin/sh'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/usr/local/bin/sh'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/bin/bash'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/usr/local/bin/bash'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/bin/zsh'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/usr/local/bin/zsh'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/bin/fish'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/usr/local/bin/fish'\n        })).toBe(true);\n        process.platform = 'linux';\n        expect(shouldGetEnvFromShell({\n          SHELL: '/bin/sh'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/usr/local/bin/sh'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/bin/bash'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/usr/local/bin/bash'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/bin/zsh'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/usr/local/bin/zsh'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/bin/fish'\n        })).toBe(true);\n        expect(shouldGetEnvFromShell({\n          SHELL: '/usr/local/bin/fish'\n        })).toBe(true);\n      });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false when the environment indicates that Atom was launched from a shell",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment does not come from a shell",
                "shouldGetEnvFromShell()"
            ],
            "updatePoint": {
                "line": 331,
                "column": 90
            },
            "line": 331,
            "code": "      it('returns false when the environment indicates that Atom was launched from a shell', function () {\n        process.platform = 'darwin';\n        expect(shouldGetEnvFromShell({\n          ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n          SHELL: '/bin/sh'\n        })).toBe(false);\n        process.platform = 'linux';\n        expect(shouldGetEnvFromShell({\n          ATOM_DISABLE_SHELLING_OUT_FOR_ENVIRONMENT: 'true',\n          SHELL: '/bin/sh'\n        })).toBe(false);\n      });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns false when the shell is undefined or empty",
            "suites": [
                "updateProcessEnv(launchEnv)",
                "when the launch environment does not come from a shell",
                "shouldGetEnvFromShell()"
            ],
            "updatePoint": {
                "line": 343,
                "column": 60
            },
            "line": 343,
            "code": "      it('returns false when the shell is undefined or empty', function () {\n        process.platform = 'darwin';\n        expect(shouldGetEnvFromShell(undefined)).toBe(false);\n        expect(shouldGetEnvFromShell({})).toBe(false);\n        process.platform = 'linux';\n        expect(shouldGetEnvFromShell(undefined)).toBe(false);\n        expect(shouldGetEnvFromShell({})).toBe(false);\n      });",
            "file": "update-process-env-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "handles URIs on a per-host basis",
            "suites": [
                "URIHandlerRegistry"
            ],
            "updatePoint": {
                "line": 9,
                "column": 38
            },
            "line": 9,
            "code": "  it('handles URIs on a per-host basis', async () => {\n    const testPackageSpy = jasmine.createSpy();\n    const otherPackageSpy = jasmine.createSpy();\n    registry.registerHostHandler('test-package', testPackageSpy);\n    registry.registerHostHandler('other-package', otherPackageSpy);\n    await registry.handleURI('atom://yet-another-package/path');\n    expect(testPackageSpy).not.toHaveBeenCalled();\n    expect(otherPackageSpy).not.toHaveBeenCalled();\n    await registry.handleURI('atom://test-package/path');\n    expect(testPackageSpy).toHaveBeenCalledWith(url.parse('atom://test-package/path', true), 'atom://test-package/path');\n    expect(otherPackageSpy).not.toHaveBeenCalled();\n    await registry.handleURI('atom://other-package/path');\n    expect(otherPackageSpy).toHaveBeenCalledWith(url.parse('atom://other-package/path', true), 'atom://other-package/path');\n  });",
            "file": "uri-handler-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps track of the most recent URIs",
            "suites": [
                "URIHandlerRegistry"
            ],
            "updatePoint": {
                "line": 23,
                "column": 41
            },
            "line": 23,
            "code": "  it('keeps track of the most recent URIs', async () => {\n    const spy1 = jasmine.createSpy();\n    const spy2 = jasmine.createSpy();\n    const changeSpy = jasmine.createSpy();\n    registry.registerHostHandler('one', spy1);\n    registry.registerHostHandler('two', spy2);\n    registry.onHistoryChange(changeSpy);\n    const uris = ['atom://one/something?asdf=1', 'atom://fake/nothing', 'atom://two/other/stuff', 'atom://one/more/thing', 'atom://two/more/stuff'];\n\n    for (const u of uris) {\n      await registry.handleURI(u);\n    }\n\n    expect(changeSpy.callCount).toBe(5);\n    expect(registry.getRecentlyHandledURIs()).toEqual(uris.map((u, idx) => {\n      return {\n        id: idx + 1,\n        uri: u,\n        handled: !u.match(/fake/),\n        host: url.parse(u).host\n      };\n    }).reverse());\n    await registry.handleURI('atom://another/url');\n    expect(changeSpy.callCount).toBe(6);\n    const history = registry.getRecentlyHandledURIs();\n    expect(history.length).toBe(5);\n    expect(history[0].uri).toBe('atom://another/url');\n    expect(history[4].uri).toBe(uris[1]);\n  });",
            "file": "uri-handler-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "refuses to handle bad URLs",
            "suites": [
                "URIHandlerRegistry"
            ],
            "updatePoint": {
                "line": 52,
                "column": 32
            },
            "line": 52,
            "code": "  it('refuses to handle bad URLs', async () => {\n    const invalidUris = ['atom:package/path', 'atom:8080://package/path', 'user:pass@atom://package/path', 'smth://package/path'];\n    let numErrors = 0;\n\n    for (const uri of invalidUris) {\n      try {\n        await registry.handleURI(uri);\n        expect(uri).toBe('throwing an error');\n      } catch (ex) {\n        numErrors++;\n      }\n    }\n\n    expect(numErrors).toBe(invalidUris.length);\n  });",
            "file": "uri-handler-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the given DOM node",
            "suites": [
                "ViewRegistry",
                "::getView(object)",
                "when passed a DOM node"
            ],
            "updatePoint": {
                "line": 18,
                "column": 75
            },
            "line": 18,
            "code": "    describe('when passed a DOM node', () => it('returns the given DOM node', () => {\n      const node = document.createElement('div');\n      expect(registry.getView(node)).toBe(node);\n    }));",
            "file": "view-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the element property if it's an instance of HTMLElement",
            "suites": [
                "ViewRegistry",
                "::getView(object)",
                "when passed an object with an element property"
            ],
            "updatePoint": {
                "line": 22,
                "column": 136
            },
            "line": 22,
            "code": "    describe('when passed an object with an element property', () => it(\"returns the element property if it's an instance of HTMLElement\", () => {\n      class TestComponent {\n        constructor() {\n          this.element = document.createElement('div');\n        }\n\n      }\n\n      const component = new TestComponent();\n      expect(registry.getView(component)).toBe(component.element);\n    }));",
            "file": "view-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the return value of getElement if it's an instance of HTMLElement",
            "suites": [
                "ViewRegistry",
                "::getView(object)",
                "when passed an object with a getElement function"
            ],
            "updatePoint": {
                "line": 33,
                "column": 148
            },
            "line": 33,
            "code": "    describe('when passed an object with a getElement function', () => it(\"returns the return value of getElement if it's an instance of HTMLElement\", () => {\n      class TestComponent {\n        getElement() {\n          if (this.myElement == null) {\n            this.myElement = document.createElement('div');\n          }\n\n          return this.myElement;\n        }\n\n      }\n\n      const component = new TestComponent();\n      expect(registry.getView(component)).toBe(component.myElement);\n    }));",
            "file": "view-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "constructs a view element and assigns the model on it",
            "suites": [
                "ViewRegistry",
                "::getView(object)",
                "when passed a model object",
                "when a view provider is registered matching the object's constructor"
            ],
            "updatePoint": {
                "line": 49,
                "column": 150
            },
            "line": 49,
            "code": "      describe(\"when a view provider is registered matching the object's constructor\", () => it('constructs a view element and assigns the model on it', () => {\n        class TestModel {}\n\n        class TestModelSubclass extends TestModel {}\n\n        class TestView {\n          initialize(model) {\n            this.model = model;\n            return this;\n          }\n\n        }\n\n        const model = new TestModel();\n        registry.addViewProvider(TestModel, model => new TestView().initialize(model));\n        const view = registry.getView(model);\n        expect(view instanceof TestView).toBe(true);\n        expect(view.model).toBe(model);\n        const subclassModel = new TestModelSubclass();\n        const view2 = registry.getView(subclassModel);\n        expect(view2 instanceof TestView).toBe(true);\n        expect(view2.model).toBe(subclassModel);\n      }));",
            "file": "view-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "constructs a view element and assigns the model on it",
            "suites": [
                "ViewRegistry",
                "::getView(object)",
                "when passed a model object",
                "when a view provider is registered generically, and works with the object"
            ],
            "updatePoint": {
                "line": 72,
                "column": 155
            },
            "line": 72,
            "code": "      describe('when a view provider is registered generically, and works with the object', () => it('constructs a view element and assigns the model on it', () => {\n        registry.addViewProvider(model => {\n          if (model.a === 'b') {\n            const element = document.createElement('div');\n            element.className = 'test-element';\n            return element;\n          }\n        });\n        const view = registry.getView({\n          a: 'b'\n        });\n        expect(view.className).toBe('test-element');\n        expect(() => registry.getView({\n          a: 'c'\n        })).toThrow();\n      }));",
            "file": "view-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "throws an exception",
            "suites": [
                "ViewRegistry",
                "::getView(object)",
                "when passed a model object",
                "when no view provider is registered for the object's constructor"
            ],
            "updatePoint": {
                "line": 88,
                "column": 112
            },
            "line": 88,
            "code": "      describe(\"when no view provider is registered for the object's constructor\", () => it('throws an exception', () => {\n        expect(() => registry.getView({})).toThrow();\n      }));",
            "file": "view-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a disposable that can be used to remove the provider",
            "suites": [
                "ViewRegistry",
                "::addViewProvider(providerSpec)"
            ],
            "updatePoint": {
                "line": 93,
                "column": 116
            },
            "line": 93,
            "code": "  describe('::addViewProvider(providerSpec)', () => it('returns a disposable that can be used to remove the provider', () => {\n    class TestModel {}\n\n    class TestView {\n      initialize(model) {\n        this.model = model;\n        return this;\n      }\n\n    }\n\n    const disposable = registry.addViewProvider(TestModel, model => new TestView().initialize(model));\n    expect(registry.getView(new TestModel()) instanceof TestView).toBe(true);\n    disposable.dispose();\n    expect(() => registry.getView(new TestModel())).toThrow();\n  }));",
            "file": "view-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "performs all pending writes before all pending reads on the next animation frame",
            "suites": [
                "ViewRegistry",
                "::updateDocument(fn) and ::readDocument(fn)"
            ],
            "updatePoint": {
                "line": 115,
                "column": 88
            },
            "line": 115,
            "code": "    it('performs all pending writes before all pending reads on the next animation frame', () => {\n      let events = [];\n      registry.updateDocument(() => events.push('write 1'));\n      registry.readDocument(() => events.push('read 1'));\n      registry.readDocument(() => events.push('read 2'));\n      registry.updateDocument(() => events.push('write 2'));\n      expect(events).toEqual([]);\n      expect(frameRequests.length).toBe(1);\n      frameRequests[0]();\n      expect(events).toEqual(['write 1', 'write 2', 'read 1', 'read 2']);\n      frameRequests = [];\n      events = [];\n      const disposable = registry.updateDocument(() => events.push('write 3'));\n      registry.updateDocument(() => events.push('write 4'));\n      registry.readDocument(() => events.push('read 3'));\n      disposable.dispose();\n      expect(frameRequests.length).toBe(1);\n      frameRequests[0]();\n      expect(events).toEqual(['write 4', 'read 3']);\n    });",
            "file": "view-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "performs writes requested from read callbacks in the same animation frame",
            "suites": [
                "ViewRegistry",
                "::updateDocument(fn) and ::readDocument(fn)"
            ],
            "updatePoint": {
                "line": 135,
                "column": 81
            },
            "line": 135,
            "code": "    it('performs writes requested from read callbacks in the same animation frame', () => {\n      spyOn(window, 'setInterval').andCallFake(fakeSetInterval);\n      spyOn(window, 'clearInterval').andCallFake(fakeClearInterval);\n      const events = [];\n      registry.updateDocument(() => events.push('write 1'));\n      registry.readDocument(() => {\n        registry.updateDocument(() => events.push('write from read 1'));\n        events.push('read 1');\n      });\n      registry.readDocument(() => {\n        registry.updateDocument(() => events.push('write from read 2'));\n        events.push('read 2');\n      });\n      registry.updateDocument(() => events.push('write 2'));\n      expect(frameRequests.length).toBe(1);\n      frameRequests[0]();\n      expect(frameRequests.length).toBe(1);\n      expect(events).toEqual(['write 1', 'write 2', 'read 1', 'read 2', 'write from read 1', 'write from read 2']);\n    });",
            "file": "view-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns a promise that resolves at the end of the next update cycle",
            "suites": [
                "ViewRegistry",
                "::getNextUpdatePromise()"
            ],
            "updatePoint": {
                "line": 155,
                "column": 116
            },
            "line": 155,
            "code": "  describe('::getNextUpdatePromise()', () => it('returns a promise that resolves at the end of the next update cycle', () => {\n    let updateCalled = false;\n    let readCalled = false;\n    waitsFor('getNextUpdatePromise to resolve', done => {\n      registry.getNextUpdatePromise().then(() => {\n        expect(updateCalled).toBe(true);\n        expect(readCalled).toBe(true);\n        done();\n      });\n      registry.updateDocument(() => {\n        updateCalled = true;\n      });\n      registry.readDocument(() => {\n        readCalled = true;\n      });\n    });\n  }));",
            "file": "view-registry-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't have .is-blurred on the body tag",
            "suites": [
                "WindowEventHandler",
                "when the window is loaded"
            ],
            "updatePoint": {
                "line": 31,
                "column": 90
            },
            "line": 31,
            "code": "  describe('when the window is loaded', () => it(\"doesn't have .is-blurred on the body tag\", () => {\n    if (process.platform === 'win32') {\n      return;\n    } // Win32TestFailures - can not steal focus\n\n\n    expect(document.body.className).not.toMatch('is-blurred');\n  }));",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the .is-blurred class on the body",
            "suites": [
                "WindowEventHandler",
                "when the window is blurred"
            ],
            "updatePoint": {
                "line": 42,
                "column": 46
            },
            "line": 42,
            "code": "    it('adds the .is-blurred class on the body', () => expect(document.body.className).toMatch('is-blurred'));",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the .is-blurred class from the body",
            "suites": [
                "WindowEventHandler",
                "when the window is blurred",
                "when the window is focused again"
            ],
            "updatePoint": {
                "line": 43,
                "column": 102
            },
            "line": 43,
            "code": "    describe('when the window is focused again', () => it('removes the .is-blurred class from the body', () => {\n      window.dispatchEvent(new CustomEvent('focus'));\n      expect(document.body.className).not.toMatch('is-blurred');\n    }));",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls storeWindowDimensions",
            "suites": [
                "WindowEventHandler",
                "resize event"
            ],
            "updatePoint": {
                "line": 48,
                "column": 64
            },
            "line": 48,
            "code": "  describe('resize event', () => it('calls storeWindowDimensions', async () => {\n    jasmine.useRealClock();\n    spyOn(atom, 'storeWindowDimensions');\n    window.dispatchEvent(new CustomEvent('resize'));\n    await conditionPromise(() => atom.storeWindowDimensions.callCount > 0);\n  }));",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "closes the window",
            "suites": [
                "WindowEventHandler",
                "window:close event"
            ],
            "updatePoint": {
                "line": 54,
                "column": 60
            },
            "line": 54,
            "code": "  describe('window:close event', () => it('closes the window', () => {\n    spyOn(atom, 'close');\n    window.dispatchEvent(new CustomEvent('window:close'));\n    expect(atom.close).toHaveBeenCalled();\n  }));",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the http/https links in an external application",
            "suites": [
                "WindowEventHandler",
                "when a link is clicked"
            ],
            "updatePoint": {
                "line": 60,
                "column": 61
            },
            "line": 60,
            "code": "    it('opens the http/https links in an external application', () => {\n      const {\n        shell\n      } = require('electron');\n\n      spyOn(shell, 'openExternal');\n      const link = document.createElement('a');\n      const linkChild = document.createElement('span');\n      link.appendChild(linkChild);\n      link.href = 'http://github.com';\n      jasmine.attachToDOM(link);\n      const fakeEvent = {\n        target: linkChild,\n        currentTarget: link,\n        preventDefault: () => {}\n      };\n      windowEventHandler.handleLinkClick(fakeEvent);\n      expect(shell.openExternal).toHaveBeenCalled();\n      expect(shell.openExternal.argsForCall[0][0]).toBe('http://github.com');\n      shell.openExternal.reset();\n      link.href = 'https://github.com';\n      windowEventHandler.handleLinkClick(fakeEvent);\n      expect(shell.openExternal).toHaveBeenCalled();\n      expect(shell.openExternal.argsForCall[0][0]).toBe('https://github.com');\n      shell.openExternal.reset();\n      link.href = '';\n      windowEventHandler.handleLinkClick(fakeEvent);\n      expect(shell.openExternal).not.toHaveBeenCalled();\n      shell.openExternal.reset();\n      link.href = '#scroll-me';\n      windowEventHandler.handleLinkClick(fakeEvent);\n      expect(shell.openExternal).not.toHaveBeenCalled();\n    });",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the \"atom://\" links with URL handler",
            "suites": [
                "WindowEventHandler",
                "when a link is clicked"
            ],
            "updatePoint": {
                "line": 93,
                "column": 50
            },
            "line": 93,
            "code": "    it('opens the \"atom://\" links with URL handler', () => {\n      const uriHandler = windowEventHandler.atomEnvironment.uriHandlerRegistry;\n      expect(uriHandler).toBeDefined();\n      spyOn(uriHandler, 'handleURI');\n      const link = document.createElement('a');\n      const linkChild = document.createElement('span');\n      link.appendChild(linkChild);\n      link.href = 'atom://github.com';\n      jasmine.attachToDOM(link);\n      const fakeEvent = {\n        target: linkChild,\n        currentTarget: link,\n        preventDefault: () => {}\n      };\n      windowEventHandler.handleLinkClick(fakeEvent);\n      expect(uriHandler.handleURI).toHaveBeenCalled();\n      expect(uriHandler.handleURI.argsForCall[0][0]).toBe('atom://github.com');\n    });",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prevents the default so that the window's URL isn't changed",
            "suites": [
                "WindowEventHandler",
                "when a form is submitted"
            ],
            "updatePoint": {
                "line": 112,
                "column": 108
            },
            "line": 112,
            "code": "  describe('when a form is submitted', () => it(\"prevents the default so that the window's URL isn't changed\", () => {\n    const form = document.createElement('form');\n    jasmine.attachToDOM(form);\n    let defaultPrevented = false;\n    const event = new CustomEvent('submit', {\n      bubbles: true\n    });\n\n    event.preventDefault = () => {\n      defaultPrevented = true;\n    };\n\n    form.dispatchEvent(event);\n    expect(defaultPrevented).toBe(true);\n  }));",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses the element with the lowest/highest tabindex",
            "suites": [
                "WindowEventHandler",
                "core:focus-next and core:focus-previous",
                "when there is no currently focused element"
            ],
            "updatePoint": {
                "line": 128,
                "column": 121
            },
            "line": 128,
            "code": "    describe('when there is no currently focused element', () => it('focuses the element with the lowest/highest tabindex', () => {\n      const wrapperDiv = document.createElement('div');\n      wrapperDiv.innerHTML = `\n          <div>\n            <button tabindex=\"2\"></button>\n            <input tabindex=\"1\">\n          </div>\n        `.trim();\n      const elements = wrapperDiv.firstChild;\n      jasmine.attachToDOM(elements);\n      elements.dispatchEvent(new CustomEvent('core:focus-next', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(1);\n      document.body.focus();\n      elements.dispatchEvent(new CustomEvent('core:focus-previous', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(2);\n    }));",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses the element with the next highest/lowest tabindex, skipping disabled elements",
            "suites": [
                "WindowEventHandler",
                "core:focus-next and core:focus-previous",
                "when a tabindex is set on the currently focused element"
            ],
            "updatePoint": {
                "line": 148,
                "column": 167
            },
            "line": 148,
            "code": "    describe('when a tabindex is set on the currently focused element', () => it('focuses the element with the next highest/lowest tabindex, skipping disabled elements', () => {\n      const wrapperDiv = document.createElement('div');\n      wrapperDiv.innerHTML = `\n          <div>\n            <input tabindex=\"1\">\n            <button tabindex=\"2\"></button>\n            <button tabindex=\"5\"></button>\n            <input tabindex=\"-1\">\n            <input tabindex=\"3\">\n            <button tabindex=\"7\"></button>\n            <input tabindex=\"9\" disabled>\n          </div>\n        `.trim();\n      const elements = wrapperDiv.firstChild;\n      jasmine.attachToDOM(elements);\n      elements.querySelector('[tabindex=\"1\"]').focus();\n      elements.dispatchEvent(new CustomEvent('core:focus-next', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(2);\n      elements.dispatchEvent(new CustomEvent('core:focus-next', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(3);\n      elements.dispatchEvent(new CustomEvent('core:focus-next', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(5);\n      elements.dispatchEvent(new CustomEvent('core:focus-next', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(7);\n      elements.dispatchEvent(new CustomEvent('core:focus-next', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(1);\n      elements.dispatchEvent(new CustomEvent('core:focus-previous', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(7);\n      elements.dispatchEvent(new CustomEvent('core:focus-previous', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(5);\n      elements.dispatchEvent(new CustomEvent('core:focus-previous', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(3);\n      elements.dispatchEvent(new CustomEvent('core:focus-previous', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(2);\n      elements.dispatchEvent(new CustomEvent('core:focus-previous', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(1);\n      elements.dispatchEvent(new CustomEvent('core:focus-previous', {\n        bubbles: true\n      }));\n      expect(document.activeElement.tabIndex).toBe(7);\n    }));",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "dispatches the event via the KeymapManager and CommandRegistry",
            "suites": [
                "WindowEventHandler",
                "when keydown events occur on the document"
            ],
            "updatePoint": {
                "line": 210,
                "column": 128
            },
            "line": 210,
            "code": "  describe('when keydown events occur on the document', () => it('dispatches the event via the KeymapManager and CommandRegistry', () => {\n    const dispatchedCommands = [];\n    atom.commands.onWillDispatch(command => dispatchedCommands.push(command));\n    atom.commands.add('*', {\n      'foo-command': () => {}\n    });\n    atom.keymaps.add('source-name', {\n      '*': {\n        x: 'foo-command'\n      }\n    });\n    const event = KeymapManager.buildKeydownEvent('x', {\n      target: document.createElement('div')\n    });\n    document.dispatchEvent(event);\n    expect(dispatchedCommands.length).toBe(1);\n    expect(dispatchedCommands[0].type).toBe('foo-command');\n  }));",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "correctly dispatches them to active elements with the '.native-key-bindings' class",
            "suites": [
                "WindowEventHandler",
                "native key bindings"
            ],
            "updatePoint": {
                "line": 228,
                "column": 126
            },
            "line": 228,
            "code": "  describe('native key bindings', () => it(\"correctly dispatches them to active elements with the '.native-key-bindings' class\", () => {\n    const webContentsSpy = jasmine.createSpyObj('webContents', ['copy', 'paste']);\n    spyOn(atom.applicationDelegate, 'getCurrentWindow').andReturn({\n      webContents: webContentsSpy,\n      on: () => {}\n    });\n    const nativeKeyBindingsInput = document.createElement('input');\n    nativeKeyBindingsInput.classList.add('native-key-bindings');\n    jasmine.attachToDOM(nativeKeyBindingsInput);\n    nativeKeyBindingsInput.focus();\n    atom.dispatchApplicationMenuCommand('core:copy');\n    atom.dispatchApplicationMenuCommand('core:paste');\n    expect(webContentsSpy.copy).toHaveBeenCalled();\n    expect(webContentsSpy.paste).toHaveBeenCalled();\n    webContentsSpy.copy.reset();\n    webContentsSpy.paste.reset();\n    const normalInput = document.createElement('input');\n    jasmine.attachToDOM(normalInput);\n    normalInput.focus();\n    atom.dispatchApplicationMenuCommand('core:copy');\n    atom.dispatchApplicationMenuCommand('core:paste');\n    expect(webContentsSpy.copy).not.toHaveBeenCalled();\n    expect(webContentsSpy.paste).not.toHaveBeenCalled();\n  }));",
            "file": "window-event-handler-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the observer with current and future text editors",
            "suites": [
                "WorkspaceCenter",
                ".observeTextEditors()"
            ],
            "updatePoint": {
                "line": 6,
                "column": 65
            },
            "line": 6,
            "code": "    it('invokes the observer with current and future text editors', () => {\n      const workspaceCenter = atom.workspace.getCenter();\n      const pane = workspaceCenter.getActivePane();\n      const observed = [];\n      const editorAddedBeforeRegisteringObserver = new TextEditor();\n      const nonEditorItemAddedBeforeRegisteringObserver = document.createElement('div');\n      pane.activateItem(editorAddedBeforeRegisteringObserver);\n      pane.activateItem(nonEditorItemAddedBeforeRegisteringObserver);\n      workspaceCenter.observeTextEditors(editor => observed.push(editor));\n      const editorAddedAfterRegisteringObserver = new TextEditor();\n      const nonEditorItemAddedAfterRegisteringObserver = document.createElement('div');\n      pane.activateItem(editorAddedAfterRegisteringObserver);\n      pane.activateItem(nonEditorItemAddedAfterRegisteringObserver);\n      expect(observed).toEqual([editorAddedBeforeRegisteringObserver, editorAddedAfterRegisteringObserver]);\n    });",
            "file": "workspace-center-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "transfers focus to the active pane",
            "suites": [
                "WorkspaceElement",
                "when the workspace element is focused"
            ],
            "updatePoint": {
                "line": 26,
                "column": 42
            },
            "line": 26,
            "code": "    it('transfers focus to the active pane', () => {\n      const workspaceElement = atom.workspace.getElement();\n      jasmine.attachToDOM(workspaceElement);\n      const activePaneElement = atom.workspace.getActivePane().getElement();\n      document.body.focus();\n      expect(document.activeElement).not.toBe(activePaneElement);\n      workspaceElement.focus();\n      expect(document.activeElement).toBe(activePaneElement);\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "changes the active pane container",
            "suites": [
                "WorkspaceElement",
                "when the active pane of an inactive pane container is focused"
            ],
            "updatePoint": {
                "line": 37,
                "column": 41
            },
            "line": 37,
            "code": "    it('changes the active pane container', () => {\n      const dock = atom.workspace.getLeftDock();\n      dock.show();\n      jasmine.attachToDOM(atom.workspace.getElement());\n      expect(atom.workspace.getActivePaneContainer()).toBe(atom.workspace.getCenter());\n      dock.getActivePane().getElement().focus();\n      expect(atom.workspace.getActivePaneContainer()).toBe(dock);\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the adjacent row above",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane above",
                "when there are multiple rows above the pane"
            ],
            "updatePoint": {
                "line": 93,
                "column": 54
            },
            "line": 93,
            "code": "        it('returns the pane in the adjacent row above', () => {\n          nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('above', pane8);\n          expect(nearestPaneElement).toBe(pane5.getElement());\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane above",
                "when there are no rows above the pane"
            ],
            "updatePoint": {
                "line": 99,
                "column": 24
            },
            "line": 99,
            "code": "        it('returns null', () => {\n          nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('above', pane2);\n          expect(nearestPaneElement).toBeUndefined(); // TODO Expect toBeNull()\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the adjacent row above",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane above",
                "when the bottom dock contains the pane"
            ],
            "updatePoint": {
                "line": 105,
                "column": 54
            },
            "line": 105,
            "code": "        it('returns the pane in the adjacent row above', () => {\n          workspace.getBottomDock().show();\n          nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('above', bottomDockPane);\n          expect(nearestPaneElement).toBe(pane7.getElement());\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the adjacent row below",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane below",
                "when there are multiple rows below the pane"
            ],
            "updatePoint": {
                "line": 114,
                "column": 54
            },
            "line": 114,
            "code": "        it('returns the pane in the adjacent row below', () => {\n          nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('below', pane2);\n          expect(nearestPaneElement).toBe(pane5.getElement());\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane below",
                "when there are no rows below the pane"
            ],
            "updatePoint": {
                "line": 120,
                "column": 24
            },
            "line": 120,
            "code": "        it('returns null', () => {\n          nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('below', pane8);\n          expect(nearestPaneElement).toBeUndefined(); // TODO Expect toBeNull()\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the bottom dock's adjacent row below",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane below",
                "when the bottom dock is visible",
                "when the workspace center's bottommost row contains the pane"
            ],
            "updatePoint": {
                "line": 127,
                "column": 70
            },
            "line": 127,
            "code": "          it(\"returns the pane in the bottom dock's adjacent row below\", () => {\n            workspace.getBottomDock().show();\n            nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('below', pane8);\n            expect(nearestPaneElement).toBe(bottomDockPane.getElement());\n          });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the adjacent column to the left",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane to the left",
                "when there are multiple columns to the left of the pane"
            ],
            "updatePoint": {
                "line": 137,
                "column": 63
            },
            "line": 137,
            "code": "        it('returns the pane in the adjacent column to the left', () => {\n          nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('left', pane6);\n          expect(nearestPaneElement).toBe(pane5.getElement());\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane to the left",
                "when there are no columns to the left of the pane"
            ],
            "updatePoint": {
                "line": 143,
                "column": 24
            },
            "line": 143,
            "code": "        it('returns null', () => {\n          nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('left', pane4);\n          expect(nearestPaneElement).toBeUndefined(); // TODO Expect toBeNull()\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the adjacent column to the left",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane to the left",
                "when the right dock contains the pane"
            ],
            "updatePoint": {
                "line": 149,
                "column": 63
            },
            "line": 149,
            "code": "        it('returns the pane in the adjacent column to the left', () => {\n          workspace.getRightDock().show();\n          nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('left', rightDockPane);\n          expect(nearestPaneElement).toBe(pane3.getElement());\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the left dock's adjacent column to the left",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane to the left",
                "when the left dock is visible",
                "when the workspace center's leftmost column contains the pane"
            ],
            "updatePoint": {
                "line": 157,
                "column": 77
            },
            "line": 157,
            "code": "          it(\"returns the pane in the left dock's adjacent column to the left\", () => {\n            workspace.getLeftDock().show();\n            nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('left', pane4);\n            expect(nearestPaneElement).toBe(leftDockPane.getElement());\n          });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the left dock's adjacent column to the left",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane to the left",
                "when the left dock is visible",
                "when the bottom dock contains the pane"
            ],
            "updatePoint": {
                "line": 164,
                "column": 77
            },
            "line": 164,
            "code": "          it(\"returns the pane in the left dock's adjacent column to the left\", () => {\n            workspace.getLeftDock().show();\n            workspace.getBottomDock().show();\n            nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('left', bottomDockPane);\n            expect(nearestPaneElement).toBe(leftDockPane.getElement());\n          });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the adjacent column to the right",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane to the right",
                "when there are multiple columns to the right of the pane"
            ],
            "updatePoint": {
                "line": 175,
                "column": 64
            },
            "line": 175,
            "code": "        it('returns the pane in the adjacent column to the right', () => {\n          nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('right', pane4);\n          expect(nearestPaneElement).toBe(pane5.getElement());\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns null",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane to the right",
                "when there are no columns to the right of the pane"
            ],
            "updatePoint": {
                "line": 181,
                "column": 24
            },
            "line": 181,
            "code": "        it('returns null', () => {\n          nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('right', pane6);\n          expect(nearestPaneElement).toBeUndefined(); // TODO Expect toBeNull()\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the adjacent column to the right",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane to the right",
                "when the left dock contains the pane"
            ],
            "updatePoint": {
                "line": 187,
                "column": 64
            },
            "line": 187,
            "code": "        it('returns the pane in the adjacent column to the right', () => {\n          workspace.getLeftDock().show();\n          nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('right', leftDockPane);\n          expect(nearestPaneElement).toBe(pane1.getElement());\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the right dock's adjacent column to the right",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane to the right",
                "when the right dock is visible",
                "when the workspace center's rightmost column contains the pane"
            ],
            "updatePoint": {
                "line": 195,
                "column": 79
            },
            "line": 195,
            "code": "          it(\"returns the pane in the right dock's adjacent column to the right\", () => {\n            workspace.getRightDock().show();\n            nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('right', pane6);\n            expect(nearestPaneElement).toBe(rightDockPane.getElement());\n          });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the pane in the right dock's adjacent column to the right",
            "suites": [
                "WorkspaceElement",
                "finding the nearest visible pane in a specific direction",
                "finding the nearest pane to the right",
                "when the right dock is visible",
                "when the bottom dock contains the pane"
            ],
            "updatePoint": {
                "line": 202,
                "column": 79
            },
            "line": 202,
            "code": "          it(\"returns the pane in the right dock's adjacent column to the right\", () => {\n            workspace.getRightDock().show();\n            workspace.getBottomDock().show();\n            nearestPaneElement = workspaceElement.nearestVisiblePaneInDirection('right', bottomDockPane);\n            expect(nearestPaneElement).toBe(rightDockPane.getElement());\n          });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses up to the adjacent row",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::focusPaneViewAbove()",
                "when there is a row above the focused pane"
            ],
            "updatePoint": {
                "line": 230,
                "column": 101
            },
            "line": 230,
            "code": "      describe('when there is a row above the focused pane', () => it('focuses up to the adjacent row', function () {\n        const paneAbove = startingPane.splitUp();\n        startingPane.activate();\n        workspaceElement.focusPaneViewAbove();\n        expect(document.activeElement).toBe(paneAbove.getElement());\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the current pane focused",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::focusPaneViewAbove()",
                "when there are no rows above the focused pane"
            ],
            "updatePoint": {
                "line": 236,
                "column": 104
            },
            "line": 236,
            "code": "      describe('when there are no rows above the focused pane', () => it('keeps the current pane focused', function () {\n        startingPane.activate();\n        workspaceElement.focusPaneViewAbove();\n        expect(document.activeElement).toBe(startingPane.getElement());\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses down to the adjacent row",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::focusPaneViewBelow()",
                "when there is a row below the focused pane"
            ],
            "updatePoint": {
                "line": 243,
                "column": 103
            },
            "line": 243,
            "code": "      describe('when there is a row below the focused pane', () => it('focuses down to the adjacent row', function () {\n        const paneBelow = startingPane.splitDown();\n        startingPane.activate();\n        workspaceElement.focusPaneViewBelow();\n        expect(document.activeElement).toBe(paneBelow.getElement());\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the current pane focused",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::focusPaneViewBelow()",
                "when there are no rows below the focused pane"
            ],
            "updatePoint": {
                "line": 249,
                "column": 104
            },
            "line": 249,
            "code": "      describe('when there are no rows below the focused pane', () => it('keeps the current pane focused', function () {\n        startingPane.activate();\n        workspaceElement.focusPaneViewBelow();\n        expect(document.activeElement).toBe(startingPane.getElement());\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses left to the adjacent column",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::focusPaneViewOnLeft()",
                "when there is a column to the left of the focused pane"
            ],
            "updatePoint": {
                "line": 256,
                "column": 118
            },
            "line": 256,
            "code": "      describe('when there is a column to the left of the focused pane', () => it('focuses left to the adjacent column', function () {\n        const paneOnLeft = startingPane.splitLeft();\n        startingPane.activate();\n        workspaceElement.focusPaneViewOnLeft();\n        expect(document.activeElement).toBe(paneOnLeft.getElement());\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the current pane focused",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::focusPaneViewOnLeft()",
                "when there are no columns to the left of the focused pane"
            ],
            "updatePoint": {
                "line": 262,
                "column": 116
            },
            "line": 262,
            "code": "      describe('when there are no columns to the left of the focused pane', () => it('keeps the current pane focused', function () {\n        startingPane.activate();\n        workspaceElement.focusPaneViewOnLeft();\n        expect(document.activeElement).toBe(startingPane.getElement());\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "focuses right to the adjacent column",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::focusPaneViewOnRight()",
                "when there is a column to the right of the focused pane"
            ],
            "updatePoint": {
                "line": 269,
                "column": 120
            },
            "line": 269,
            "code": "      describe('when there is a column to the right of the focused pane', () => it('focuses right to the adjacent column', function () {\n        const paneOnRight = startingPane.splitRight();\n        startingPane.activate();\n        workspaceElement.focusPaneViewOnRight();\n        expect(document.activeElement).toBe(paneOnRight.getElement());\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the current pane focused",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::focusPaneViewOnRight()",
                "when there are no columns to the right of the focused pane"
            ],
            "updatePoint": {
                "line": 275,
                "column": 117
            },
            "line": 275,
            "code": "      describe('when there are no columns to the right of the focused pane', () => it('keeps the current pane focused', function () {\n        startingPane.activate();\n        workspaceElement.focusPaneViewOnRight();\n        expect(document.activeElement).toBe(startingPane.getElement());\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the active item up to the adjacent row",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneAbove(keepOriginal)",
                "when there is a row above the focused pane"
            ],
            "updatePoint": {
                "line": 282,
                "column": 115
            },
            "line": 282,
            "code": "      describe('when there is a row above the focused pane', () => it('moves the active item up to the adjacent row', function () {\n        const item = document.createElement('div');\n        const paneAbove = startingPane.splitUp();\n        startingPane.activate();\n        startingPane.activateItem(item);\n        workspaceElement.moveActiveItemToPaneAbove();\n        expect(workspace.paneForItem(item)).toBe(paneAbove);\n        expect(paneAbove.getActiveItem()).toBe(item);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the active pane focused",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneAbove(keepOriginal)",
                "when there are no rows above the focused pane"
            ],
            "updatePoint": {
                "line": 291,
                "column": 103
            },
            "line": 291,
            "code": "      describe('when there are no rows above the focused pane', () => it('keeps the active pane focused', function () {\n        const item = document.createElement('div');\n        startingPane.activate();\n        startingPane.activateItem(item);\n        workspaceElement.moveActiveItemToPaneAbove();\n        expect(workspace.paneForItem(item)).toBe(startingPane);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the item and adds a copy of it to the adjacent pane",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneAbove(keepOriginal)",
                "when `keepOriginal: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 298,
                "column": 135
            },
            "line": 298,
            "code": "      describe('when `keepOriginal: true` is passed in the params', () => it('keeps the item and adds a copy of it to the adjacent pane', function () {\n        const itemA = document.createElement('div');\n        const itemB = document.createElement('div');\n\n        itemA.copy = () => itemB;\n\n        const paneAbove = startingPane.splitUp();\n        startingPane.activate();\n        startingPane.activateItem(itemA);\n        workspaceElement.moveActiveItemToPaneAbove({\n          keepOriginal: true\n        });\n        expect(workspace.paneForItem(itemA)).toBe(startingPane);\n        expect(paneAbove.getActiveItem()).toBe(itemB);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the active item down to the adjacent row",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneBelow(keepOriginal)",
                "when there is a row below the focused pane"
            ],
            "updatePoint": {
                "line": 315,
                "column": 117
            },
            "line": 315,
            "code": "      describe('when there is a row below the focused pane', () => it('moves the active item down to the adjacent row', function () {\n        const item = document.createElement('div');\n        const paneBelow = startingPane.splitDown();\n        startingPane.activate();\n        startingPane.activateItem(item);\n        workspaceElement.moveActiveItemToPaneBelow();\n        expect(workspace.paneForItem(item)).toBe(paneBelow);\n        expect(paneBelow.getActiveItem()).toBe(item);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the active item in the focused pane",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneBelow(keepOriginal)",
                "when there are no rows below the focused pane"
            ],
            "updatePoint": {
                "line": 324,
                "column": 115
            },
            "line": 324,
            "code": "      describe('when there are no rows below the focused pane', () => it('keeps the active item in the focused pane', function () {\n        const item = document.createElement('div');\n        startingPane.activate();\n        startingPane.activateItem(item);\n        workspaceElement.moveActiveItemToPaneBelow();\n        expect(workspace.paneForItem(item)).toBe(startingPane);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the item and adds a copy of it to the adjacent pane",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneBelow(keepOriginal)",
                "when `keepOriginal: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 331,
                "column": 135
            },
            "line": 331,
            "code": "      describe('when `keepOriginal: true` is passed in the params', () => it('keeps the item and adds a copy of it to the adjacent pane', function () {\n        const itemA = document.createElement('div');\n        const itemB = document.createElement('div');\n\n        itemA.copy = () => itemB;\n\n        const paneBelow = startingPane.splitDown();\n        startingPane.activate();\n        startingPane.activateItem(itemA);\n        workspaceElement.moveActiveItemToPaneBelow({\n          keepOriginal: true\n        });\n        expect(workspace.paneForItem(itemA)).toBe(startingPane);\n        expect(paneBelow.getActiveItem()).toBe(itemB);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the active item left to the adjacent column",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneOnLeft(keepOriginal)",
                "when there is a column to the left of the focused pane"
            ],
            "updatePoint": {
                "line": 348,
                "column": 132
            },
            "line": 348,
            "code": "      describe('when there is a column to the left of the focused pane', () => it('moves the active item left to the adjacent column', function () {\n        const item = document.createElement('div');\n        const paneOnLeft = startingPane.splitLeft();\n        startingPane.activate();\n        startingPane.activateItem(item);\n        workspaceElement.moveActiveItemToPaneOnLeft();\n        expect(workspace.paneForItem(item)).toBe(paneOnLeft);\n        expect(paneOnLeft.getActiveItem()).toBe(item);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the active item in the focused pane",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneOnLeft(keepOriginal)",
                "when there are no columns to the left of the focused pane"
            ],
            "updatePoint": {
                "line": 357,
                "column": 127
            },
            "line": 357,
            "code": "      describe('when there are no columns to the left of the focused pane', () => it('keeps the active item in the focused pane', function () {\n        const item = document.createElement('div');\n        startingPane.activate();\n        startingPane.activateItem(item);\n        workspaceElement.moveActiveItemToPaneOnLeft();\n        expect(workspace.paneForItem(item)).toBe(startingPane);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the item and adds a copy of it to the adjacent pane",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneOnLeft(keepOriginal)",
                "when `keepOriginal: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 364,
                "column": 135
            },
            "line": 364,
            "code": "      describe('when `keepOriginal: true` is passed in the params', () => it('keeps the item and adds a copy of it to the adjacent pane', function () {\n        const itemA = document.createElement('div');\n        const itemB = document.createElement('div');\n\n        itemA.copy = () => itemB;\n\n        const paneOnLeft = startingPane.splitLeft();\n        startingPane.activate();\n        startingPane.activateItem(itemA);\n        workspaceElement.moveActiveItemToPaneOnLeft({\n          keepOriginal: true\n        });\n        expect(workspace.paneForItem(itemA)).toBe(startingPane);\n        expect(paneOnLeft.getActiveItem()).toBe(itemB);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the active item right to the adjacent column",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneOnRight(keepOriginal)",
                "when there is a column to the right of the focused pane"
            ],
            "updatePoint": {
                "line": 381,
                "column": 134
            },
            "line": 381,
            "code": "      describe('when there is a column to the right of the focused pane', () => it('moves the active item right to the adjacent column', function () {\n        const item = document.createElement('div');\n        const paneOnRight = startingPane.splitRight();\n        startingPane.activate();\n        startingPane.activateItem(item);\n        workspaceElement.moveActiveItemToPaneOnRight();\n        expect(workspace.paneForItem(item)).toBe(paneOnRight);\n        expect(paneOnRight.getActiveItem()).toBe(item);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the active item in the focused pane",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneOnRight(keepOriginal)",
                "when there are no columns to the right of the focused pane"
            ],
            "updatePoint": {
                "line": 390,
                "column": 128
            },
            "line": 390,
            "code": "      describe('when there are no columns to the right of the focused pane', () => it('keeps the active item in the focused pane', function () {\n        const item = document.createElement('div');\n        startingPane.activate();\n        startingPane.activateItem(item);\n        workspaceElement.moveActiveItemToPaneOnRight();\n        expect(workspace.paneForItem(item)).toBe(startingPane);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the item and adds a copy of it to the adjacent pane",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToPaneOnRight(keepOriginal)",
                "when `keepOriginal: true` is passed in the params"
            ],
            "updatePoint": {
                "line": 397,
                "column": 135
            },
            "line": 397,
            "code": "      describe('when `keepOriginal: true` is passed in the params', () => it('keeps the item and adds a copy of it to the adjacent pane', function () {\n        const itemA = document.createElement('div');\n        const itemB = document.createElement('div');\n\n        itemA.copy = () => itemB;\n\n        const paneOnRight = startingPane.splitRight();\n        startingPane.activate();\n        startingPane.activateItem(itemA);\n        workspaceElement.moveActiveItemToPaneOnRight({\n          keepOriginal: true\n        });\n        expect(workspace.paneForItem(itemA)).toBe(startingPane);\n        expect(paneOnRight.getActiveItem()).toBe(itemB);\n      }));",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not move or copy the active item",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToNearestPaneInDirection(direction, params)",
                "when the item is not allowed in nearest pane in the given direction"
            ],
            "updatePoint": {
                "line": 415,
                "column": 49
            },
            "line": 415,
            "code": "        it('does not move or copy the active item', function () {\n          const item = {\n            element: document.createElement('div'),\n            getAllowedLocations: () => ['left', 'right']\n          };\n          workspace.getBottomDock().show();\n          startingPane.activate();\n          startingPane.activateItem(item);\n          workspaceElement.moveActiveItemToNearestPaneInDirection('below', {\n            keepOriginal: false\n          });\n          expect(workspace.paneForItem(item)).toBe(startingPane);\n          workspaceElement.moveActiveItemToNearestPaneInDirection('below', {\n            keepOriginal: true\n          });\n          expect(workspace.paneForItem(item)).toBe(startingPane);\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not copy the active item",
            "suites": [
                "WorkspaceElement",
                "changing focus, copying, and moving items directionally between panes",
                "::moveActiveItemToNearestPaneInDirection(direction, params)",
                "when the item doesn't implement a `copy` function"
            ],
            "updatePoint": {
                "line": 434,
                "column": 41
            },
            "line": 434,
            "code": "        it('does not copy the active item', function () {\n          const item = document.createElement('div');\n          const paneBelow = startingPane.splitDown();\n          expect(paneBelow.getItems().length).toEqual(0);\n          startingPane.activate();\n          startingPane.activateItem(item);\n          workspaceElement.focusPaneViewAbove();\n          workspaceElement.moveActiveItemToNearestPaneInDirection('below', {\n            keepOriginal: true\n          });\n          expect(workspace.paneForItem(item)).toBe(startingPane);\n          expect(paneBelow.getItems().length).toEqual(0);\n        });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shows the toggle button when the dock is open",
            "suites": [
                "WorkspaceElement",
                "mousing over docks"
            ],
            "updatePoint": {
                "line": 469,
                "column": 53
            },
            "line": 469,
            "code": "    it('shows the toggle button when the dock is open', async () => {\n      await Promise.all([atom.workspace.open({\n        element: document.createElement('div'),\n\n        getDefaultLocation() {\n          return 'left';\n        },\n\n        getPreferredWidth() {\n          return 150;\n        }\n\n      }), atom.workspace.open({\n        element: document.createElement('div'),\n\n        getDefaultLocation() {\n          return 'right';\n        },\n\n        getPreferredWidth() {\n          return 150;\n        }\n\n      }), atom.workspace.open({\n        element: document.createElement('div'),\n\n        getDefaultLocation() {\n          return 'bottom';\n        },\n\n        getPreferredHeight() {\n          return 100;\n        }\n\n      })]);\n      const leftDock = atom.workspace.getLeftDock();\n      const rightDock = atom.workspace.getRightDock();\n      const bottomDock = atom.workspace.getBottomDock();\n      expect(leftDock.isVisible()).toBe(true);\n      expect(rightDock.isVisible()).toBe(true);\n      expect(bottomDock.isVisible()).toBe(true);\n      expectToggleButtonHidden(leftDock);\n      expectToggleButtonHidden(rightDock);\n      expectToggleButtonHidden(bottomDock); // --- Right Dock ---\n      // Mouse over where the toggle button would be if the dock were hovered\n\n      moveMouse({\n        clientX: 440,\n        clientY: 150\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonHidden(leftDock);\n      expectToggleButtonHidden(rightDock);\n      expectToggleButtonHidden(bottomDock); // Mouse over the dock\n\n      moveMouse({\n        clientX: 460,\n        clientY: 150\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonHidden(leftDock);\n      expectToggleButtonVisible(rightDock, 'icon-chevron-right');\n      expectToggleButtonHidden(bottomDock); // Mouse over the toggle button\n\n      moveMouse({\n        clientX: 440,\n        clientY: 150\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonHidden(leftDock);\n      expectToggleButtonVisible(rightDock, 'icon-chevron-right');\n      expectToggleButtonHidden(bottomDock); // Click the toggle button\n\n      rightDock.refs.toggleButton.refs.innerElement.click();\n      await getNextUpdatePromise();\n      expect(rightDock.isVisible()).toBe(false);\n      expectToggleButtonHidden(rightDock); // Mouse to edge of the window\n\n      moveMouse({\n        clientX: 575,\n        clientY: 150\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonHidden(rightDock);\n      moveMouse({\n        clientX: 598,\n        clientY: 150\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonVisible(rightDock, 'icon-chevron-left'); // Click the toggle button again\n\n      rightDock.refs.toggleButton.refs.innerElement.click();\n      await getNextUpdatePromise();\n      expect(rightDock.isVisible()).toBe(true);\n      expectToggleButtonVisible(rightDock, 'icon-chevron-right'); // --- Left Dock ---\n      // Mouse over where the toggle button would be if the dock were hovered\n\n      moveMouse({\n        clientX: 160,\n        clientY: 150\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonHidden(leftDock);\n      expectToggleButtonHidden(rightDock);\n      expectToggleButtonHidden(bottomDock); // Mouse over the dock\n\n      moveMouse({\n        clientX: 140,\n        clientY: 150\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonVisible(leftDock, 'icon-chevron-left');\n      expectToggleButtonHidden(rightDock);\n      expectToggleButtonHidden(bottomDock); // Mouse over the toggle button\n\n      moveMouse({\n        clientX: 160,\n        clientY: 150\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonVisible(leftDock, 'icon-chevron-left');\n      expectToggleButtonHidden(rightDock);\n      expectToggleButtonHidden(bottomDock); // Click the toggle button\n\n      leftDock.refs.toggleButton.refs.innerElement.click();\n      await getNextUpdatePromise();\n      expect(leftDock.isVisible()).toBe(false);\n      expectToggleButtonHidden(leftDock); // Mouse to edge of the window\n\n      moveMouse({\n        clientX: 25,\n        clientY: 150\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonHidden(leftDock);\n      moveMouse({\n        clientX: 2,\n        clientY: 150\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonVisible(leftDock, 'icon-chevron-right'); // Click the toggle button again\n\n      leftDock.refs.toggleButton.refs.innerElement.click();\n      await getNextUpdatePromise();\n      expect(leftDock.isVisible()).toBe(true);\n      expectToggleButtonVisible(leftDock, 'icon-chevron-left'); // --- Bottom Dock ---\n      // Mouse over where the toggle button would be if the dock were hovered\n\n      moveMouse({\n        clientX: 300,\n        clientY: 190\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonHidden(leftDock);\n      expectToggleButtonHidden(rightDock);\n      expectToggleButtonHidden(bottomDock); // Mouse over the dock\n\n      moveMouse({\n        clientX: 300,\n        clientY: 210\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonHidden(leftDock);\n      expectToggleButtonHidden(rightDock);\n      expectToggleButtonVisible(bottomDock, 'icon-chevron-down'); // Mouse over the toggle button\n\n      moveMouse({\n        clientX: 300,\n        clientY: 195\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonHidden(leftDock);\n      expectToggleButtonHidden(rightDock);\n      expectToggleButtonVisible(bottomDock, 'icon-chevron-down'); // Click the toggle button\n\n      bottomDock.refs.toggleButton.refs.innerElement.click();\n      await getNextUpdatePromise();\n      expect(bottomDock.isVisible()).toBe(false);\n      expectToggleButtonHidden(bottomDock); // Mouse to edge of the window\n\n      moveMouse({\n        clientX: 300,\n        clientY: 290\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonHidden(leftDock);\n      moveMouse({\n        clientX: 300,\n        clientY: 299\n      });\n      await getNextUpdatePromise();\n      expectToggleButtonVisible(bottomDock, 'icon-chevron-up'); // Click the toggle button again\n\n      bottomDock.refs.toggleButton.refs.innerElement.click();\n      await getNextUpdatePromise();\n      expect(bottomDock.isVisible()).toBe(true);\n      expectToggleButtonVisible(bottomDock, 'icon-chevron-down');\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "has a class based on the style of the scrollbar",
            "suites": [
                "WorkspaceElement",
                "the scrollbar visibility class"
            ],
            "updatePoint": {
                "line": 687,
                "column": 55
            },
            "line": 687,
            "code": "    it('has a class based on the style of the scrollbar', () => {\n      let observeCallback;\n\n      const scrollbarStyle = require('scrollbar-style');\n\n      spyOn(scrollbarStyle, 'observePreferredScrollbarStyle').andCallFake(cb => {\n        observeCallback = cb;\n        return new Disposable(() => {});\n      });\n      const workspaceElement = atom.workspace.getElement();\n      observeCallback('legacy');\n      expect(workspaceElement.className).toMatch('scrollbars-visible-always');\n      observeCallback('overlay');\n      expect(workspaceElement).toHaveClass('scrollbars-visible-when-scrolling');\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the font-size based on the 'editor.fontSize' config value",
            "suites": [
                "WorkspaceElement",
                "editor font styling"
            ],
            "updatePoint": {
                "line": 712,
                "column": 73
            },
            "line": 712,
            "code": "    it(\"updates the font-size based on the 'editor.fontSize' config value\", async () => {\n      const initialCharWidth = editor.getDefaultCharWidth();\n      expect(getComputedStyle(editorElement).fontSize).toBe(atom.config.get('editor.fontSize') + 'px');\n      atom.config.set('editor.fontSize', atom.config.get('editor.fontSize') + 5);\n      await editorElement.component.getNextUpdatePromise();\n      expect(getComputedStyle(editorElement).fontSize).toBe(atom.config.get('editor.fontSize') + 'px');\n      expect(editor.getDefaultCharWidth()).toBeGreaterThan(initialCharWidth);\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the font-family based on the 'editor.fontFamily' config value",
            "suites": [
                "WorkspaceElement",
                "editor font styling"
            ],
            "updatePoint": {
                "line": 720,
                "column": 77
            },
            "line": 720,
            "code": "    it(\"updates the font-family based on the 'editor.fontFamily' config value\", async () => {\n      const initialCharWidth = editor.getDefaultCharWidth();\n      let fontFamily = atom.config.get('editor.fontFamily');\n      expect(getComputedStyle(editorElement).fontFamily).toBe(fontFamily);\n      atom.config.set('editor.fontFamily', 'sans-serif');\n      fontFamily = atom.config.get('editor.fontFamily');\n      await editorElement.component.getNextUpdatePromise();\n      expect(getComputedStyle(editorElement).fontFamily).toBe(fontFamily);\n      expect(editor.getDefaultCharWidth()).not.toBe(initialCharWidth);\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the line-height based on the 'editor.lineHeight' config value",
            "suites": [
                "WorkspaceElement",
                "editor font styling"
            ],
            "updatePoint": {
                "line": 730,
                "column": 77
            },
            "line": 730,
            "code": "    it(\"updates the line-height based on the 'editor.lineHeight' config value\", async () => {\n      const initialLineHeight = editor.getLineHeightInPixels();\n      atom.config.set('editor.lineHeight', '30px');\n      await editorElement.component.getNextUpdatePromise();\n      expect(getComputedStyle(editorElement).lineHeight).toBe(atom.config.get('editor.lineHeight'));\n      expect(editor.getLineHeightInPixels()).not.toBe(initialLineHeight);\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "increases or decreases the font size when a ctrl-mousewheel event occurs",
            "suites": [
                "WorkspaceElement",
                "editor font styling"
            ],
            "updatePoint": {
                "line": 737,
                "column": 80
            },
            "line": 737,
            "code": "    it('increases or decreases the font size when a ctrl-mousewheel event occurs', () => {\n      atom.config.set('editor.zoomFontWhenCtrlScrolling', true);\n      atom.config.set('editor.fontSize', 12); // Zoom out\n\n      editorElement.querySelector('span').dispatchEvent(new WheelEvent('mousewheel', {\n        wheelDeltaY: -10,\n        ctrlKey: true\n      }));\n      expect(atom.config.get('editor.fontSize')).toBe(11); // Zoom in\n\n      editorElement.querySelector('span').dispatchEvent(new WheelEvent('mousewheel', {\n        wheelDeltaY: 10,\n        ctrlKey: true\n      }));\n      expect(atom.config.get('editor.fontSize')).toBe(12); // Not on an atom-text-editor\n\n      workspaceElement.dispatchEvent(new WheelEvent('mousewheel', {\n        wheelDeltaY: 10,\n        ctrlKey: true\n      }));\n      expect(atom.config.get('editor.fontSize')).toBe(12); // No ctrl key\n\n      editorElement.querySelector('span').dispatchEvent(new WheelEvent('mousewheel', {\n        wheelDeltaY: 10\n      }));\n      expect(atom.config.get('editor.fontSize')).toBe(12);\n      atom.config.set('editor.zoomFontWhenCtrlScrolling', false);\n      editorElement.querySelector('span').dispatchEvent(new WheelEvent('mousewheel', {\n        wheelDeltaY: 10,\n        ctrlKey: true\n      }));\n      expect(atom.config.get('editor.fontSize')).toBe(12);\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "inserts panel container elements in the correct places in the DOM",
            "suites": [
                "WorkspaceElement",
                "panel containers"
            ],
            "updatePoint": {
                "line": 772,
                "column": 73
            },
            "line": 772,
            "code": "    it('inserts panel container elements in the correct places in the DOM', () => {\n      const workspaceElement = atom.workspace.getElement();\n      const leftContainer = workspaceElement.querySelector('atom-panel-container.left');\n      const rightContainer = workspaceElement.querySelector('atom-panel-container.right');\n      expect(leftContainer.nextSibling).toBe(workspaceElement.verticalAxis);\n      expect(rightContainer.previousSibling).toBe(workspaceElement.verticalAxis);\n      const topContainer = workspaceElement.querySelector('atom-panel-container.top');\n      const bottomContainer = workspaceElement.querySelector('atom-panel-container.bottom');\n      expect(topContainer.nextSibling).toBe(workspaceElement.paneContainer);\n      expect(bottomContainer.previousSibling).toBe(workspaceElement.paneContainer);\n      const headerContainer = workspaceElement.querySelector('atom-panel-container.header');\n      const footerContainer = workspaceElement.querySelector('atom-panel-container.footer');\n      expect(headerContainer.nextSibling).toBe(workspaceElement.horizontalAxis);\n      expect(footerContainer.previousSibling).toBe(workspaceElement.horizontalAxis);\n      const modalContainer = workspaceElement.querySelector('atom-panel-container.modal');\n      expect(modalContainer.parentNode).toBe(workspaceElement);\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stretches header/footer panels to the workspace width",
            "suites": [
                "WorkspaceElement",
                "panel containers"
            ],
            "updatePoint": {
                "line": 789,
                "column": 61
            },
            "line": 789,
            "code": "    it('stretches header/footer panels to the workspace width', () => {\n      const workspaceElement = atom.workspace.getElement();\n      jasmine.attachToDOM(workspaceElement);\n      expect(workspaceElement.offsetWidth).toBeGreaterThan(0);\n      const headerItem = document.createElement('div');\n      atom.workspace.addHeaderPanel({\n        item: headerItem\n      });\n      expect(headerItem.offsetWidth).toEqual(workspaceElement.offsetWidth);\n      const footerItem = document.createElement('div');\n      atom.workspace.addFooterPanel({\n        item: footerItem\n      });\n      expect(footerItem.offsetWidth).toEqual(workspaceElement.offsetWidth);\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shrinks horizontal axis according to header/footer panels height",
            "suites": [
                "WorkspaceElement",
                "panel containers"
            ],
            "updatePoint": {
                "line": 804,
                "column": 72
            },
            "line": 804,
            "code": "    it('shrinks horizontal axis according to header/footer panels height', () => {\n      const workspaceElement = atom.workspace.getElement();\n      workspaceElement.style.height = '100px';\n      const horizontalAxisElement = workspaceElement.querySelector('atom-workspace-axis.horizontal');\n      jasmine.attachToDOM(workspaceElement);\n      const originalHorizontalAxisHeight = horizontalAxisElement.offsetHeight;\n      expect(workspaceElement.offsetHeight).toBeGreaterThan(0);\n      expect(originalHorizontalAxisHeight).toBeGreaterThan(0);\n      const headerItem = document.createElement('div');\n      headerItem.style.height = '10px';\n      atom.workspace.addHeaderPanel({\n        item: headerItem\n      });\n      expect(headerItem.offsetHeight).toBeGreaterThan(0);\n      const footerItem = document.createElement('div');\n      footerItem.style.height = '15px';\n      atom.workspace.addFooterPanel({\n        item: footerItem\n      });\n      expect(footerItem.offsetHeight).toBeGreaterThan(0);\n      expect(horizontalAxisElement.offsetHeight).toEqual(originalHorizontalAxisHeight - headerItem.offsetHeight - footerItem.offsetHeight);\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "shows/hides invisibles in all open and future editors",
            "suites": [
                "WorkspaceElement",
                "the 'window:toggle-invisibles' command"
            ],
            "updatePoint": {
                "line": 828,
                "column": 61
            },
            "line": 828,
            "code": "    it('shows/hides invisibles in all open and future editors', () => {\n      const workspaceElement = atom.workspace.getElement();\n      expect(atom.config.get('editor.showInvisibles')).toBe(false);\n      atom.commands.dispatch(workspaceElement, 'window:toggle-invisibles');\n      expect(atom.config.get('editor.showInvisibles')).toBe(true);\n      atom.commands.dispatch(workspaceElement, 'window:toggle-invisibles');\n      expect(atom.config.get('editor.showInvisibles')).toBe(false);\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "runs the package specs for the active item's project path, or the first project path",
            "suites": [
                "WorkspaceElement",
                "the 'window:run-package-specs' command"
            ],
            "updatePoint": {
                "line": 838,
                "column": 92
            },
            "line": 838,
            "code": "    it(\"runs the package specs for the active item's project path, or the first project path\", () => {\n      const workspaceElement = atom.workspace.getElement();\n      spyOn(ipcRenderer, 'send'); // No project paths. Don't try to run specs.\n\n      atom.commands.dispatch(workspaceElement, 'window:run-package-specs');\n      expect(ipcRenderer.send).not.toHaveBeenCalledWith('run-package-specs');\n      const projectPaths = [temp.mkdirSync('dir1-'), temp.mkdirSync('dir2-')];\n      atom.project.setPaths(projectPaths); // No active item. Use first project directory.\n\n      atom.commands.dispatch(workspaceElement, 'window:run-package-specs');\n      expect(ipcRenderer.send).toHaveBeenCalledWith('run-package-specs', path.join(projectPaths[0], 'spec'), {});\n      ipcRenderer.send.reset(); // Active item doesn't implement ::getPath(). Use first project directory.\n\n      const item = document.createElement('div');\n      atom.workspace.getActivePane().activateItem(item);\n      atom.commands.dispatch(workspaceElement, 'window:run-package-specs');\n      expect(ipcRenderer.send).toHaveBeenCalledWith('run-package-specs', path.join(projectPaths[0], 'spec'), {});\n      ipcRenderer.send.reset(); // Active item has no path. Use first project directory.\n\n      item.getPath = () => null;\n\n      atom.commands.dispatch(workspaceElement, 'window:run-package-specs');\n      expect(ipcRenderer.send).toHaveBeenCalledWith('run-package-specs', path.join(projectPaths[0], 'spec'), {});\n      ipcRenderer.send.reset(); // Active item has path. Use project path for item path.\n\n      item.getPath = () => path.join(projectPaths[1], 'a-file.txt');\n\n      atom.commands.dispatch(workspaceElement, 'window:run-package-specs');\n      expect(ipcRenderer.send).toHaveBeenCalledWith('run-package-specs', path.join(projectPaths[1], 'spec'), {});\n      ipcRenderer.send.reset();\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "passes additional options to the spec window",
            "suites": [
                "WorkspaceElement",
                "the 'window:run-package-specs' command"
            ],
            "updatePoint": {
                "line": 869,
                "column": 52
            },
            "line": 869,
            "code": "    it('passes additional options to the spec window', () => {\n      const workspaceElement = atom.workspace.getElement();\n      spyOn(ipcRenderer, 'send');\n      const projectPath = temp.mkdirSync('dir1-');\n      atom.project.setPaths([projectPath]);\n      workspaceElement.runPackageSpecs({\n        env: {\n          ATOM_GITHUB_BABEL_ENV: 'coverage'\n        }\n      });\n      expect(ipcRenderer.send).toHaveBeenCalledWith('run-package-specs', path.join(projectPath, 'spec'), {\n        env: {\n          ATOM_GITHUB_BABEL_ENV: 'coverage'\n        }\n      });\n    });",
            "file": "workspace-element-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "constructs the view with the same panes",
            "suites": [
                "Workspace",
                "serialization",
                "when the workspace contains text editors"
            ],
            "updatePoint": {
                "line": 84,
                "column": 49
            },
            "line": 84,
            "code": "      it('constructs the view with the same panes', () => {\n        const pane1 = atom.workspace.getActivePane();\n        const pane2 = pane1.splitRight({\n          copyActiveItem: true\n        });\n        const pane3 = pane2.splitRight({\n          copyActiveItem: true\n        });\n        let pane4 = null;\n        waitsForPromise(() => atom.workspace.open(null).then(editor => editor.setText('An untitled editor.')));\n        waitsForPromise(() => atom.workspace.open('b').then(editor => pane2.activateItem(editor.copy())));\n        waitsForPromise(() => atom.workspace.open('../sample.js').then(editor => pane3.activateItem(editor)));\n        runs(() => {\n          pane3.activeItem.setCursorScreenPosition([2, 4]);\n          pane4 = pane2.splitDown();\n        });\n        waitsForPromise(() => atom.workspace.open('../sample.txt').then(editor => pane4.activateItem(editor)));\n        runs(() => {\n          pane4.getActiveItem().setCursorScreenPosition([0, 2]);\n          pane2.activate();\n        });\n        simulateReload();\n        runs(() => {\n          expect(atom.workspace.getTextEditors().length).toBe(5);\n          const [editor1, editor2, untitledEditor, editor3, editor4] = atom.workspace.getTextEditors();\n          const firstDirectory = atom.project.getDirectories()[0];\n          expect(firstDirectory).toBeDefined();\n          expect(editor1.getPath()).toBe(firstDirectory.resolve('b'));\n          expect(editor2.getPath()).toBe(firstDirectory.resolve('../sample.txt'));\n          expect(editor2.getCursorScreenPosition()).toEqual([0, 2]);\n          expect(editor3.getPath()).toBe(firstDirectory.resolve('b'));\n          expect(editor4.getPath()).toBe(firstDirectory.resolve('../sample.js'));\n          expect(editor4.getCursorScreenPosition()).toEqual([2, 4]);\n          expect(untitledEditor.getPath()).toBeUndefined();\n          expect(untitledEditor.getText()).toBe('An untitled editor.');\n          expect(atom.workspace.getActiveTextEditor().getPath()).toBe(editor3.getPath());\n          const pathEscaped = fs.tildify(escapeStringRegex(atom.project.getPaths()[0]));\n          expect(document.title).toMatch(new RegExp(`^${path.basename(editor3.getLongTitle())} \\\\u2014 ${pathEscaped}`));\n        });\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "constructs the view with no open editors",
            "suites": [
                "Workspace",
                "serialization",
                "where there are no open panes or editors"
            ],
            "updatePoint": {
                "line": 126,
                "column": 50
            },
            "line": 126,
            "code": "      it('constructs the view with no open editors', () => {\n        atom.workspace.getActivePane().destroy();\n        expect(atom.workspace.getTextEditors().length).toBe(0);\n        simulateReload();\n        runs(() => {\n          expect(atom.workspace.getTextEditors().length).toBe(0);\n        });\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds and activates an empty editor on the active pane",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is false (default)",
                "when called without a uri or item"
            ],
            "updatePoint": {
                "line": 145,
                "column": 65
            },
            "line": 145,
            "code": "        it('adds and activates an empty editor on the active pane', () => {\n          let editor1;\n          let editor2;\n          waitsForPromise(() => workspace.open().then(editor => {\n            editor1 = editor;\n          }));\n          runs(() => {\n            expect(editor1.getPath()).toBeUndefined();\n            expect(workspace.getActivePane().items).toEqual([editor1]);\n            expect(workspace.getActivePaneItem()).toBe(editor1);\n            expect(workspace.getActivePane().activate).toHaveBeenCalled();\n            expect(openEvents).toEqual([{\n              uri: undefined,\n              pane: workspace.getActivePane(),\n              item: editor1,\n              index: 0\n            }]);\n            openEvents = [];\n          });\n          waitsForPromise(() => workspace.open().then(editor => {\n            editor2 = editor;\n          }));\n          runs(() => {\n            expect(editor2.getPath()).toBeUndefined();\n            expect(workspace.getActivePane().items).toEqual([editor1, editor2]);\n            expect(workspace.getActivePaneItem()).toBe(editor2);\n            expect(workspace.getActivePane().activate).toHaveBeenCalled();\n            expect(openEvents).toEqual([{\n              uri: undefined,\n              pane: workspace.getActivePane(),\n              item: editor2,\n              index: 1\n            }]);\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the existing editor on the active pane",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is false (default)",
                "when called with a uri",
                "when the active pane already has an editor for the given uri"
            ],
            "updatePoint": {
                "line": 183,
                "column": 62
            },
            "line": 183,
            "code": "          it('activates the existing editor on the active pane', () => {\n            let editor = null;\n            let editor1 = null;\n            let editor2 = null;\n            waitsForPromise(() => workspace.open('a').then(o => {\n              editor1 = o;\n              return workspace.open('b').then(o => {\n                editor2 = o;\n                return workspace.open('a').then(o => {\n                  editor = o;\n                });\n              });\n            }));\n            runs(() => {\n              expect(editor).toBe(editor1);\n              expect(workspace.getActivePaneItem()).toBe(editor);\n              expect(workspace.getActivePane().activate).toHaveBeenCalled();\n              const firstDirectory = atom.project.getDirectories()[0];\n              expect(firstDirectory).toBeDefined();\n              expect(openEvents).toEqual([{\n                uri: firstDirectory.resolve('a'),\n                item: editor1,\n                pane: atom.workspace.getActivePane(),\n                index: 0\n              }, {\n                uri: firstDirectory.resolve('b'),\n                item: editor2,\n                pane: atom.workspace.getActivePane(),\n                index: 1\n              }, {\n                uri: firstDirectory.resolve('a'),\n                item: editor1,\n                pane: atom.workspace.getActivePane(),\n                index: 0\n              }]);\n            });\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "finds items in docks",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is false (default)",
                "when called with a uri",
                "when the active pane already has an editor for the given uri"
            ],
            "updatePoint": {
                "line": 220,
                "column": 34
            },
            "line": 220,
            "code": "          it('finds items in docks', () => {\n            const dock = atom.workspace.getRightDock();\n            const ITEM_URI = 'atom://test';\n            const item = {\n              getURI: () => ITEM_URI,\n              getDefaultLocation: () => 'left',\n              getElement: () => document.createElement('div')\n            };\n            dock.getActivePane().addItem(item);\n            expect(dock.getPaneItems()).toHaveLength(1);\n            waitsForPromise(() => atom.workspace.open(ITEM_URI, {\n              searchAllPanes: true\n            }));\n            runs(() => {\n              expect(atom.workspace.getPaneItems()).toHaveLength(1);\n              expect(dock.getPaneItems()).toHaveLength(1);\n              expect(dock.getPaneItems()[0]).toBe(item);\n            });\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the item to the workspace",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is false (default)",
                "when called with a uri",
                "when the 'activateItem' option is false"
            ],
            "updatePoint": {
                "line": 241,
                "column": 44
            },
            "line": 241,
            "code": "          it('adds the item to the workspace', () => {\n            let editor;\n            waitsForPromise(() => workspace.open('a'));\n            waitsForPromise(() => workspace.open('b', {\n              activateItem: false\n            }).then(o => {\n              editor = o;\n            }));\n            runs(() => {\n              expect(workspace.getPaneItems()).toContain(editor);\n              expect(workspace.getActivePaneItem()).not.toBe(editor);\n            });\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds and activates a new editor for the given path on the active pane",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is false (default)",
                "when called with a uri",
                "when the active pane does not have an editor for the given uri"
            ],
            "updatePoint": {
                "line": 263,
                "column": 83
            },
            "line": 263,
            "code": "          it('adds and activates a new editor for the given path on the active pane', () => {\n            let editor = null;\n            waitsForPromise(() => workspace.open('a').then(o => {\n              editor = o;\n            }));\n            runs(() => {\n              const firstDirectory = atom.project.getDirectories()[0];\n              expect(firstDirectory).toBeDefined();\n              expect(editor.getURI()).toBe(firstDirectory.resolve('a'));\n              expect(workspace.getActivePaneItem()).toBe(editor);\n              expect(workspace.getActivePane().items).toEqual([editor]);\n              expect(workspace.getActivePane().activate).toHaveBeenCalled();\n            });\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "discovers existing editors that are still opening",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is false (default)",
                "when called with a uri",
                "when the active pane does not have an editor for the given uri"
            ],
            "updatePoint": {
                "line": 277,
                "column": 63
            },
            "line": 277,
            "code": "          it('discovers existing editors that are still opening', () => {\n            let editor0 = null;\n            let editor1 = null;\n            waitsForPromise(() => Promise.all([workspace.open('spartacus.txt').then(o0 => {\n              editor0 = o0;\n            }), workspace.open('spartacus.txt').then(o1 => {\n              editor1 = o1;\n            })]));\n            runs(() => {\n              expect(editor0).toEqual(editor1);\n              expect(workspace.getActivePane().items).toEqual([editor0]);\n            });\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "uses the location specified by the model's `getDefaultLocation()` method",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is false (default)",
                "when called with a uri",
                "when the active pane does not have an editor for the given uri"
            ],
            "updatePoint": {
                "line": 290,
                "column": 86
            },
            "line": 290,
            "code": "          it(\"uses the location specified by the model's `getDefaultLocation()` method\", () => {\n            const item = {\n              getDefaultLocation: jasmine.createSpy().andReturn('right'),\n              getElement: () => document.createElement('div')\n            };\n            const opener = jasmine.createSpy().andReturn(item);\n            const dock = atom.workspace.getRightDock();\n            spyOn(atom.workspace.itemLocationStore, 'load').andReturn(Promise.resolve());\n            spyOn(atom.workspace, 'getOpeners').andReturn([opener]);\n            expect(dock.getPaneItems()).toHaveLength(0);\n            waitsForPromise(() => atom.workspace.open('a'));\n            runs(() => {\n              expect(dock.getPaneItems()).toHaveLength(1);\n              expect(opener).toHaveBeenCalled();\n              expect(item.getDefaultLocation).toHaveBeenCalled();\n            });\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prefers the last location the user used for that item",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is false (default)",
                "when called with a uri",
                "when the active pane does not have an editor for the given uri"
            ],
            "updatePoint": {
                "line": 307,
                "column": 67
            },
            "line": 307,
            "code": "          it('prefers the last location the user used for that item', () => {\n            const ITEM_URI = 'atom://test';\n            const item = {\n              getURI: () => ITEM_URI,\n              getDefaultLocation: () => 'left',\n              getElement: () => document.createElement('div')\n            };\n\n            const opener = uri => uri === ITEM_URI ? item : null;\n\n            const dock = atom.workspace.getRightDock();\n            spyOn(atom.workspace.itemLocationStore, 'load').andCallFake(uri => uri === 'atom://test' ? Promise.resolve('right') : Promise.resolve());\n            spyOn(atom.workspace, 'getOpeners').andReturn([opener]);\n            expect(dock.getPaneItems()).toHaveLength(0);\n            waitsForPromise(() => atom.workspace.open(ITEM_URI));\n            runs(() => {\n              expect(dock.getPaneItems()).toHaveLength(1);\n              expect(dock.getPaneItems()[0]).toBe(item);\n            });\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates that item if it is in that container's active pane",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is false (default)",
                "when an item with the given uri exists in an inactive pane container"
            ],
            "updatePoint": {
                "line": 330,
                "column": 72
            },
            "line": 330,
            "code": "        it(\"activates that item if it is in that container's active pane\", async () => {\n          const item = await atom.workspace.open('a');\n          atom.workspace.getLeftDock().activate();\n          expect(await atom.workspace.open('a', {\n            searchAllPanes: false\n          })).toBe(item);\n          expect(atom.workspace.getActivePaneContainer().getLocation()).toBe('center');\n          expect(atom.workspace.getPaneItems()).toEqual([item]);\n          atom.workspace.getActivePane().splitRight();\n          atom.workspace.getLeftDock().activate();\n          const item2 = await atom.workspace.open('a', {\n            searchAllPanes: false\n          });\n          expect(item2).not.toBe(item);\n          expect(atom.workspace.getActivePaneContainer().getLocation()).toBe('center');\n          expect(atom.workspace.getPaneItems()).toEqual([item, item2]);\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the existing editor on the inactive pane, then activates that pane",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is true",
                "when an editor for the given uri is already open on an inactive pane"
            ],
            "updatePoint": {
                "line": 351,
                "column": 88
            },
            "line": 351,
            "code": "        it('activates the existing editor on the inactive pane, then activates that pane', () => {\n          let editor1 = null;\n          let editor2 = null;\n          const pane1 = workspace.getActivePane();\n          const pane2 = workspace.getActivePane().splitRight();\n          waitsForPromise(() => {\n            pane1.activate();\n            return workspace.open('a').then(o => {\n              editor1 = o;\n            });\n          });\n          waitsForPromise(() => {\n            pane2.activate();\n            return workspace.open('b').then(o => {\n              editor2 = o;\n            });\n          });\n          runs(() => expect(workspace.getActivePaneItem()).toBe(editor2));\n          waitsForPromise(() => workspace.open('a', {\n            searchAllPanes: true\n          }));\n          runs(() => {\n            expect(workspace.getActivePane()).toBe(pane1);\n            expect(workspace.getActivePaneItem()).toBe(editor1);\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "discovers existing editors that are still opening in an inactive pane",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is true",
                "when an editor for the given uri is already open on an inactive pane"
            ],
            "updatePoint": {
                "line": 377,
                "column": 81
            },
            "line": 377,
            "code": "        it('discovers existing editors that are still opening in an inactive pane', () => {\n          let editor0 = null;\n          let editor1 = null;\n          const pane0 = workspace.getActivePane();\n          const pane1 = workspace.getActivePane().splitRight();\n          pane0.activate();\n          const promise0 = workspace.open('spartacus.txt', {\n            searchAllPanes: true\n          }).then(o0 => {\n            editor0 = o0;\n          });\n          pane1.activate();\n          const promise1 = workspace.open('spartacus.txt', {\n            searchAllPanes: true\n          }).then(o1 => {\n            editor1 = o1;\n          });\n          waitsForPromise(() => Promise.all([promise0, promise1]));\n          runs(() => {\n            expect(editor0).toBeDefined();\n            expect(editor1).toBeDefined();\n            expect(editor0).toEqual(editor1);\n            expect(workspace.getActivePane().items).toEqual([editor0]);\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the pane in the dock with the matching item",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is true",
                "when an editor for the given uri is already open on an inactive pane"
            ],
            "updatePoint": {
                "line": 402,
                "column": 65
            },
            "line": 402,
            "code": "        it('activates the pane in the dock with the matching item', () => {\n          const dock = atom.workspace.getRightDock();\n          const ITEM_URI = 'atom://test';\n          const item = {\n            getURI: () => ITEM_URI,\n            getDefaultLocation: jasmine.createSpy().andReturn('left'),\n            getElement: () => document.createElement('div')\n          };\n          dock.getActivePane().addItem(item);\n          spyOn(dock.paneForItem(item), 'activate');\n          waitsForPromise(() => atom.workspace.open(ITEM_URI, {\n            searchAllPanes: true\n          }));\n          runs(() => expect(dock.paneForItem(item).activate).toHaveBeenCalled());\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens an editor for the given uri in the active pane",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'searchAllPanes' option is true",
                "when no editor for the given uri is open in any pane"
            ],
            "updatePoint": {
                "line": 419,
                "column": 64
            },
            "line": 419,
            "code": "        it('opens an editor for the given uri in the active pane', () => {\n          let editor = null;\n          waitsForPromise(() => workspace.open('a', {\n            searchAllPanes: true\n          }).then(o => {\n            editor = o;\n          }));\n          runs(() => expect(workspace.getActivePaneItem()).toBe(editor));\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the editor in the workspace center",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when attempting to open an editor in a dock"
            ],
            "updatePoint": {
                "line": 431,
                "column": 50
            },
            "line": 431,
            "code": "      it('opens the editor in the workspace center', async () => {\n        await atom.workspace.open('sample.txt', {\n          location: 'right'\n        });\n        expect(atom.workspace.getCenter().getActivePaneItem().getFileName()).toEqual('sample.txt');\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the item itself to the workspace",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when called with an item rather than a URI"
            ],
            "updatePoint": {
                "line": 439,
                "column": 47
            },
            "line": 439,
            "code": "      it('adds the item itself to the workspace', async () => {\n        const item = document.createElement('div');\n        await atom.workspace.open(item);\n        expect(atom.workspace.getActivePaneItem()).toBe(item);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the item",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when called with an item rather than a URI",
                "when the active pane already contains the item"
            ],
            "updatePoint": {
                "line": 445,
                "column": 30
            },
            "line": 445,
            "code": "        it('activates the item', async () => {\n          const item = document.createElement('div');\n          await atom.workspace.open(item);\n          await atom.workspace.open();\n          expect(atom.workspace.getActivePaneItem()).not.toBe(item);\n          expect(atom.workspace.getActivePane().getItems().length).toBe(2);\n          await atom.workspace.open(item);\n          expect(atom.workspace.getActivePaneItem()).toBe(item);\n          expect(atom.workspace.getActivePane().getItems().length).toBe(2);\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "rejects the promise",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when called with an item rather than a URI",
                "when the item already exists in another pane"
            ],
            "updatePoint": {
                "line": 457,
                "column": 31
            },
            "line": 457,
            "code": "        it('rejects the promise', async () => {\n          const item = document.createElement('div');\n          await atom.workspace.open(item);\n          await atom.workspace.open(null, {\n            split: 'right'\n          });\n          expect(atom.workspace.getActivePaneItem()).not.toBe(item);\n          expect(atom.workspace.getActivePane().getItems().length).toBe(1);\n          let rejection;\n\n          try {\n            await atom.workspace.open(item);\n          } catch (error) {\n            rejection = error;\n          }\n\n          expect(rejection.message).toMatch(/The workspace can only contain one instance of item/);\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the editor in the leftmost pane of the current pane axis",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'split' option is set",
                "when the 'split' option is 'left'"
            ],
            "updatePoint": {
                "line": 479,
                "column": 74
            },
            "line": 479,
            "code": "        it('opens the editor in the leftmost pane of the current pane axis', () => {\n          const pane1 = workspace.getActivePane();\n          const pane2 = pane1.splitRight();\n          expect(workspace.getActivePane()).toBe(pane2);\n          let editor = null;\n          waitsForPromise(() => workspace.open('a', {\n            split: 'left'\n          }).then(o => {\n            editor = o;\n          }));\n          runs(() => {\n            expect(workspace.getActivePane()).toBe(pane1);\n            expect(pane1.items).toEqual([editor]);\n            expect(pane2.items).toEqual([]);\n          }); // Focus right pane and reopen the file on the left\n\n          waitsForPromise(() => {\n            pane2.focus();\n            return workspace.open('a', {\n              split: 'left'\n            }).then(o => {\n              editor = o;\n            });\n          });\n          runs(() => {\n            expect(workspace.getActivePane()).toBe(pane1);\n            expect(pane1.items).toEqual([editor]);\n            expect(pane2.items).toEqual([]);\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the new item in the current pane",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'split' option is set",
                "when a pane axis is the leftmost sibling of the current pane"
            ],
            "updatePoint": {
                "line": 511,
                "column": 50
            },
            "line": 511,
            "code": "        it('opens the new item in the current pane', () => {\n          let editor = null;\n          const pane1 = workspace.getActivePane();\n          const pane2 = pane1.splitLeft();\n          pane2.splitDown();\n          pane1.activate();\n          expect(workspace.getActivePane()).toBe(pane1);\n          waitsForPromise(() => workspace.open('a', {\n            split: 'left'\n          }).then(o => {\n            editor = o;\n          }));\n          runs(() => {\n            expect(workspace.getActivePane()).toBe(pane1);\n            expect(pane1.items).toEqual([editor]);\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the editor in the rightmost pane of the current pane axis",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'split' option is set",
                "when the 'split' option is 'right'"
            ],
            "updatePoint": {
                "line": 530,
                "column": 75
            },
            "line": 530,
            "code": "        it('opens the editor in the rightmost pane of the current pane axis', () => {\n          let editor = null;\n          const pane1 = workspace.getActivePane();\n          let pane2 = null;\n          waitsForPromise(() => workspace.open('a', {\n            split: 'right'\n          }).then(o => {\n            editor = o;\n          }));\n          runs(() => {\n            pane2 = workspace.getPanes().filter(p => p !== pane1)[0];\n            expect(workspace.getActivePane()).toBe(pane2);\n            expect(pane1.items).toEqual([]);\n            expect(pane2.items).toEqual([editor]);\n          }); // Focus right pane and reopen the file on the right\n\n          waitsForPromise(() => {\n            pane1.focus();\n            return workspace.open('a', {\n              split: 'right'\n            }).then(o => {\n              editor = o;\n            });\n          });\n          runs(() => {\n            expect(workspace.getActivePane()).toBe(pane2);\n            expect(pane1.items).toEqual([]);\n            expect(pane2.items).toEqual([editor]);\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the new item in a new pane split to the right of the current pane",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'split' option is set",
                "when the 'split' option is 'right'",
                "when a pane axis is the rightmost sibling of the current pane"
            ],
            "updatePoint": {
                "line": 561,
                "column": 85
            },
            "line": 561,
            "code": "          it('opens the new item in a new pane split to the right of the current pane', () => {\n            let editor = null;\n            const pane1 = workspace.getActivePane();\n            const pane2 = pane1.splitRight();\n            pane2.splitDown();\n            pane1.activate();\n            expect(workspace.getActivePane()).toBe(pane1);\n            let pane4 = null;\n            waitsForPromise(() => workspace.open('a', {\n              split: 'right'\n            }).then(o => {\n              editor = o;\n            }));\n            runs(() => {\n              pane4 = workspace.getPanes().filter(p => p !== pane1)[0];\n              expect(workspace.getActivePane()).toBe(pane4);\n              expect(pane4.items).toEqual([editor]);\n              expect(workspace.getCenter().paneContainer.root.children[0]).toBe(pane1);\n              expect(workspace.getCenter().paneContainer.root.children[1]).toBe(pane4);\n            });\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the editor in the topmost pane of the current pane axis",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'split' option is set",
                "when the 'split' option is 'up'"
            ],
            "updatePoint": {
                "line": 585,
                "column": 73
            },
            "line": 585,
            "code": "        it('opens the editor in the topmost pane of the current pane axis', () => {\n          const pane1 = workspace.getActivePane();\n          const pane2 = pane1.splitDown();\n          expect(workspace.getActivePane()).toBe(pane2);\n          let editor = null;\n          waitsForPromise(() => workspace.open('a', {\n            split: 'up'\n          }).then(o => {\n            editor = o;\n          }));\n          runs(() => {\n            expect(workspace.getActivePane()).toBe(pane1);\n            expect(pane1.items).toEqual([editor]);\n            expect(pane2.items).toEqual([]);\n          }); // Focus bottom pane and reopen the file on the top\n\n          waitsForPromise(() => {\n            pane2.focus();\n            return workspace.open('a', {\n              split: 'up'\n            }).then(o => {\n              editor = o;\n            });\n          });\n          runs(() => {\n            expect(workspace.getActivePane()).toBe(pane1);\n            expect(pane1.items).toEqual([editor]);\n            expect(pane2.items).toEqual([]);\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the new item in the current pane",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'split' option is set",
                "when a pane axis is the topmost sibling of the current pane"
            ],
            "updatePoint": {
                "line": 617,
                "column": 50
            },
            "line": 617,
            "code": "        it('opens the new item in the current pane', () => {\n          let editor = null;\n          const pane1 = workspace.getActivePane();\n          const pane2 = pane1.splitUp();\n          pane2.splitRight();\n          pane1.activate();\n          expect(workspace.getActivePane()).toBe(pane1);\n          waitsForPromise(() => workspace.open('a', {\n            split: 'up'\n          }).then(o => {\n            editor = o;\n          }));\n          runs(() => {\n            expect(workspace.getActivePane()).toBe(pane1);\n            expect(pane1.items).toEqual([editor]);\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the editor in the bottommost pane of the current pane axis",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'split' option is set",
                "when the 'split' option is 'down'"
            ],
            "updatePoint": {
                "line": 636,
                "column": 76
            },
            "line": 636,
            "code": "        it('opens the editor in the bottommost pane of the current pane axis', () => {\n          let editor = null;\n          const pane1 = workspace.getActivePane();\n          let pane2 = null;\n          waitsForPromise(() => workspace.open('a', {\n            split: 'down'\n          }).then(o => {\n            editor = o;\n          }));\n          runs(() => {\n            pane2 = workspace.getPanes().filter(p => p !== pane1)[0];\n            expect(workspace.getActivePane()).toBe(pane2);\n            expect(pane1.items).toEqual([]);\n            expect(pane2.items).toEqual([editor]);\n          }); // Focus bottom pane and reopen the file on the right\n\n          waitsForPromise(() => {\n            pane1.focus();\n            return workspace.open('a', {\n              split: 'down'\n            }).then(o => {\n              editor = o;\n            });\n          });\n          runs(() => {\n            expect(workspace.getActivePane()).toBe(pane2);\n            expect(pane1.items).toEqual([]);\n            expect(pane2.items).toEqual([editor]);\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the new item in a new pane split to the bottom of the current pane",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the 'split' option is set",
                "when the 'split' option is 'down'",
                "when a pane axis is the bottommost sibling of the current pane"
            ],
            "updatePoint": {
                "line": 667,
                "column": 86
            },
            "line": 667,
            "code": "          it('opens the new item in a new pane split to the bottom of the current pane', () => {\n            let editor = null;\n            const pane1 = workspace.getActivePane();\n            const pane2 = pane1.splitDown();\n            pane1.activate();\n            expect(workspace.getActivePane()).toBe(pane1);\n            let pane4 = null;\n            waitsForPromise(() => workspace.open('a', {\n              split: 'down'\n            }).then(o => {\n              editor = o;\n            }));\n            runs(() => {\n              pane4 = workspace.getPanes().filter(p => p !== pane1)[0];\n              expect(workspace.getActivePane()).toBe(pane4);\n              expect(pane4.items).toEqual([editor]);\n              expect(workspace.getCenter().paneContainer.root.children[0]).toBe(pane1);\n              expect(workspace.getCenter().paneContainer.root.children[1]).toBe(pane2);\n            });\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "moves the cursor to the indicated location",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when an initialLine and initialColumn are specified"
            ],
            "updatePoint": {
                "line": 691,
                "column": 52
            },
            "line": 691,
            "code": "      it('moves the cursor to the indicated location', () => {\n        waitsForPromise(() => workspace.open('a', {\n          initialLine: 1,\n          initialColumn: 5\n        }));\n        runs(() => expect(workspace.getActiveTextEditor().getCursorBufferPosition()).toEqual([1, 5]));\n        waitsForPromise(() => workspace.open('a', {\n          initialLine: 2,\n          initialColumn: 4\n        }));\n        runs(() => expect(workspace.getActiveTextEditor().getCursorBufferPosition()).toEqual([2, 4]));\n        waitsForPromise(() => workspace.open('a', {\n          initialLine: 0,\n          initialColumn: 0\n        }));\n        runs(() => expect(workspace.getActiveTextEditor().getCursorBufferPosition()).toEqual([0, 0]));\n        waitsForPromise(() => workspace.open('a', {\n          initialLine: NaN,\n          initialColumn: 4\n        }));\n        runs(() => expect(workspace.getActiveTextEditor().getCursorBufferPosition()).toEqual([0, 4]));\n        waitsForPromise(() => workspace.open('a', {\n          initialLine: 2,\n          initialColumn: NaN\n        }));\n        runs(() => expect(workspace.getActiveTextEditor().getCursorBufferPosition()).toEqual([2, 0]));\n        waitsForPromise(() => workspace.open('a', {\n          initialLine: Infinity,\n          initialColumn: Infinity\n        }));\n        runs(() => expect(workspace.getActiveTextEditor().getCursorBufferPosition()).toEqual([2, 11]));\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "unfolds the fold containing the line",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when an initialLine and initialColumn are specified"
            ],
            "updatePoint": {
                "line": 723,
                "column": 46
            },
            "line": 723,
            "code": "      it('unfolds the fold containing the line', async () => {\n        let editor;\n        await workspace.open('../sample-with-many-folds.js');\n        editor = workspace.getActiveTextEditor();\n        editor.foldBufferRow(2);\n        expect(editor.isFoldedAtBufferRow(2)).toBe(true);\n        expect(editor.isFoldedAtBufferRow(3)).toBe(true);\n        await workspace.open('../sample-with-many-folds.js', {\n          initialLine: 2\n        });\n        expect(editor.isFoldedAtBufferRow(2)).toBe(false);\n        expect(editor.isFoldedAtBufferRow(3)).toBe(false);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prompts before opening the file",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the file size is over the limit defined in `core.warnOnLargeFileLimit`"
            ],
            "updatePoint": {
                "line": 758,
                "column": 41
            },
            "line": 758,
            "code": "      it('prompts before opening the file', async () => {\n        atom.config.set('core.warnOnLargeFileLimit', 20);\n        await shouldPromptForFileOfSize(20, true);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't prompt on files below the limit",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the file size is over the limit defined in `core.warnOnLargeFileLimit`"
            ],
            "updatePoint": {
                "line": 762,
                "column": 49
            },
            "line": 762,
            "code": "      it(\"doesn't prompt on files below the limit\", async () => {\n        atom.config.set('core.warnOnLargeFileLimit', 30);\n        await shouldPromptForFileOfSize(20, false);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "prompts for smaller files with a lower limit",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the file size is over the limit defined in `core.warnOnLargeFileLimit`"
            ],
            "updatePoint": {
                "line": 766,
                "column": 54
            },
            "line": 766,
            "code": "      it('prompts for smaller files with a lower limit', async () => {\n        atom.config.set('core.warnOnLargeFileLimit', 5);\n        await shouldPromptForFileOfSize(10, true);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the resource returned by the custom opener",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when passed a path that matches a custom opener"
            ],
            "updatePoint": {
                "line": 772,
                "column": 60
            },
            "line": 772,
            "code": "      it('returns the resource returned by the custom opener', () => {\n        const fooOpener = (pathToOpen, options) => {\n          if (pathToOpen != null ? pathToOpen.match(/\\.foo/) : undefined) {\n            return {\n              foo: pathToOpen,\n              options\n            };\n          }\n        };\n\n        const barOpener = pathToOpen => {\n          if (pathToOpen != null ? pathToOpen.match(/^bar:\\/\\//) : undefined) {\n            return {\n              bar: pathToOpen\n            };\n          }\n        };\n\n        workspace.addOpener(fooOpener);\n        workspace.addOpener(barOpener);\n        waitsForPromise(() => {\n          const pathToOpen = atom.project.getDirectories()[0].resolve('a.foo');\n          return workspace.open(pathToOpen, {\n            hey: 'there'\n          }).then(item => expect(item).toEqual({\n            foo: pathToOpen,\n            options: {\n              hey: 'there'\n            }\n          }));\n        });\n        waitsForPromise(() => workspace.open('bar://baz').then(item => expect(item).toEqual({\n          bar: 'bar://baz'\n        })));\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the file to the application's recent documents list",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when passed a path that matches a custom opener"
            ],
            "updatePoint": {
                "line": 808,
                "column": 64
            },
            "line": 808,
            "code": "    it(\"adds the file to the application's recent documents list\", () => {\n      if (process.platform !== 'darwin') {\n        return;\n      } // Feature only supported on macOS\n\n\n      spyOn(atom.applicationDelegate, 'addRecentDocument');\n      waitsForPromise(() => workspace.open());\n      runs(() => expect(atom.applicationDelegate.addRecentDocument).not.toHaveBeenCalled());\n      waitsForPromise(() => workspace.open('something://a/url'));\n      runs(() => expect(atom.applicationDelegate.addRecentDocument).not.toHaveBeenCalled());\n      waitsForPromise(() => workspace.open(__filename));\n      runs(() => expect(atom.applicationDelegate.addRecentDocument).toHaveBeenCalledWith(__filename));\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies ::onDidAddTextEditor observers",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when passed a path that matches a custom opener"
            ],
            "updatePoint": {
                "line": 822,
                "column": 47
            },
            "line": 822,
            "code": "    it('notifies ::onDidAddTextEditor observers', () => {\n      const absolutePath = require.resolve('./fixtures/dir/a');\n\n      const newEditorHandler = jasmine.createSpy('newEditorHandler');\n      workspace.onDidAddTextEditor(newEditorHandler);\n      let editor = null;\n      waitsForPromise(() => workspace.open(absolutePath).then(e => {\n        editor = e;\n      }));\n      runs(() => expect(newEditorHandler.argsForCall[0][0].textEditor).toBe(editor));\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates an empty buffer for the specified path",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when there is an error opening the file",
                "when a file does not exist"
            ],
            "updatePoint": {
                "line": 837,
                "column": 58
            },
            "line": 837,
            "code": "        it('creates an empty buffer for the specified path', () => {\n          waitsForPromise(() => workspace.open('not-a-file.md'));\n          runs(() => {\n            const editor = workspace.getActiveTextEditor();\n            expect(notificationSpy).not.toHaveBeenCalled();\n            expect(editor.getPath()).toContain('not-a-file.md');\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a notification",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when there is an error opening the file",
                "when the user does not have access to the file"
            ],
            "updatePoint": {
                "line": 853,
                "column": 34
            },
            "line": 853,
            "code": "        it('creates a notification', () => {\n          waitsForPromise(() => workspace.open('file1'));\n          runs(() => {\n            expect(notificationSpy).toHaveBeenCalled();\n            const notification = notificationSpy.mostRecentCall.args[0];\n            expect(notification.getType()).toBe('warning');\n            expect(notification.getMessage()).toContain('Permission denied');\n            expect(notification.getMessage()).toContain('file1');\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a notification",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when there is an error opening the file",
                "when the the operation is not permitted"
            ],
            "updatePoint": {
                "line": 871,
                "column": 34
            },
            "line": 871,
            "code": "        it('creates a notification', () => {\n          waitsForPromise(() => workspace.open('file1'));\n          runs(() => {\n            expect(notificationSpy).toHaveBeenCalled();\n            const notification = notificationSpy.mostRecentCall.args[0];\n            expect(notification.getType()).toBe('warning');\n            expect(notification.getMessage()).toContain('Unable to open');\n            expect(notification.getMessage()).toContain('file1');\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "creates a notification",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when there is an error opening the file",
                "when the the file is already open in windows"
            ],
            "updatePoint": {
                "line": 889,
                "column": 34
            },
            "line": 889,
            "code": "        it('creates a notification', () => {\n          waitsForPromise(() => workspace.open('file1'));\n          runs(() => {\n            expect(notificationSpy).toHaveBeenCalled();\n            const notification = notificationSpy.mostRecentCall.args[0];\n            expect(notification.getType()).toBe('warning');\n            expect(notification.getMessage()).toContain('Unable to open');\n            expect(notification.getMessage()).toContain('file1');\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "rejects the promise",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when there is an error opening the file",
                "when there is an unhandled error"
            ],
            "updatePoint": {
                "line": 904,
                "column": 31
            },
            "line": 904,
            "code": "        it('rejects the promise', () => {\n          waitsFor(done => {\n            workspace.open('file1').catch(error => {\n              expect(error.message).toBe('I dont even know what is happening right now!!');\n              done();\n            });\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "should terminate the pending state",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when the file is already open in pending state"
            ],
            "updatePoint": {
                "line": 915,
                "column": 44
            },
            "line": 915,
            "code": "      it('should terminate the pending state', () => {\n        let editor = null;\n        let pane = null;\n        waitsForPromise(() => atom.workspace.open('sample.js', {\n          pending: true\n        }).then(o => {\n          editor = o;\n          pane = atom.workspace.getActivePane();\n        }));\n        runs(() => expect(pane.getPendingItem()).toEqual(editor));\n        waitsForPromise(() => atom.workspace.open('sample.js'));\n        runs(() => expect(pane.getPendingItem()).toBeNull());\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "keeps the pending tab open",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when opening will switch from a pending tab to a permanent tab"
            ],
            "updatePoint": {
                "line": 930,
                "column": 36
            },
            "line": 930,
            "code": "      it('keeps the pending tab open', () => {\n        let editor1 = null;\n        let editor2 = null;\n        waitsForPromise(() => atom.workspace.open('sample.txt').then(o => {\n          editor1 = o;\n        }));\n        waitsForPromise(() => atom.workspace.open('sample2.txt', {\n          pending: true\n        }).then(o => {\n          editor2 = o;\n        }));\n        runs(() => {\n          const pane = atom.workspace.getActivePane();\n          pane.activateItem(editor1);\n          expect(pane.getItems().length).toBe(2);\n          expect(pane.getItems()).toEqual([editor1, editor2]);\n        });\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not destroy the pane even if core.destroyEmptyPanes is on",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when replacing a pending item which is the last item in a second pane"
            ],
            "updatePoint": {
                "line": 950,
                "column": 72
            },
            "line": 950,
            "code": "      it('does not destroy the pane even if core.destroyEmptyPanes is on', () => {\n        atom.config.set('core.destroyEmptyPanes', true);\n        let editor1 = null;\n        let editor2 = null;\n        const leftPane = atom.workspace.getActivePane();\n        let rightPane = null;\n        waitsForPromise(() => atom.workspace.open('sample.js', {\n          pending: true,\n          split: 'right'\n        }).then(o => {\n          editor1 = o;\n          rightPane = atom.workspace.getActivePane();\n          spyOn(rightPane, 'destroy').andCallThrough();\n        }));\n        runs(() => {\n          expect(leftPane).not.toBe(rightPane);\n          expect(atom.workspace.getActivePane()).toBe(rightPane);\n          expect(atom.workspace.getActivePane().getItems().length).toBe(1);\n          expect(rightPane.getPendingItem()).toBe(editor1);\n        });\n        waitsForPromise(() => atom.workspace.open('sample.txt', {\n          pending: true\n        }).then(o => {\n          editor2 = o;\n        }));\n        runs(() => {\n          expect(rightPane.getPendingItem()).toBe(editor2);\n          expect(rightPane.destroy.callCount).toBe(0);\n        });\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds the buffer to the project",
            "suites": [
                "Workspace",
                "::open(itemOrURI, options)",
                "when opening an editor with a buffer that isn't part of the project"
            ],
            "updatePoint": {
                "line": 982,
                "column": 40
            },
            "line": 982,
            "code": "      it('adds the buffer to the project', async () => {\n        const buffer = new TextBuffer();\n        const editor = new TextEditor({\n          buffer\n        });\n        await atom.workspace.open(editor);\n        expect(atom.project.getBuffers().map(buffer => buffer.id)).toContain(buffer.id);\n        expect(buffer.getLanguageMode().getLanguageId()).toBe('text.plain.null-grammar');\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can identify the pane and pane container for a given item or URI",
            "suites": [
                "Workspace",
                "finding items in the workspace"
            ],
            "updatePoint": {
                "line": 994,
                "column": 72
            },
            "line": 994,
            "code": "    it('can identify the pane and pane container for a given item or URI', () => {\n      const uri = 'atom://test-pane-for-item';\n      const item = {\n        element: document.createElement('div'),\n\n        getURI() {\n          return uri;\n        }\n\n      };\n      atom.workspace.getActivePane().activateItem(item);\n      expect(atom.workspace.paneForItem(item)).toBe(atom.workspace.getCenter().getActivePane());\n      expect(atom.workspace.paneContainerForItem(item)).toBe(atom.workspace.getCenter());\n      expect(atom.workspace.paneForURI(uri)).toBe(atom.workspace.getCenter().getActivePane());\n      expect(atom.workspace.paneContainerForURI(uri)).toBe(atom.workspace.getCenter());\n      atom.workspace.getActivePane().destroyActiveItem();\n      atom.workspace.getLeftDock().getActivePane().activateItem(item);\n      expect(atom.workspace.paneForItem(item)).toBe(atom.workspace.getLeftDock().getActivePane());\n      expect(atom.workspace.paneContainerForItem(item)).toBe(atom.workspace.getLeftDock());\n      expect(atom.workspace.paneForURI(uri)).toBe(atom.workspace.getLeftDock().getActivePane());\n      expect(atom.workspace.paneContainerForURI(uri)).toBe(atom.workspace.getLeftDock());\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "if the item for the given URI is in the center, removes it",
            "suites": [
                "Workspace",
                "::hide(uri)",
                "when called with a URI"
            ],
            "updatePoint": {
                "line": 1029,
                "column": 68
            },
            "line": 1029,
            "code": "      it('if the item for the given URI is in the center, removes it', () => {\n        const pane = atom.workspace.getActivePane();\n        pane.addItem(item);\n        atom.workspace.hide(URI);\n        expect(pane.getItems().length).toBe(0);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "if the item for the given URI is in a dock, hides the dock",
            "suites": [
                "Workspace",
                "::hide(uri)",
                "when called with a URI"
            ],
            "updatePoint": {
                "line": 1035,
                "column": 68
            },
            "line": 1035,
            "code": "      it('if the item for the given URI is in a dock, hides the dock', () => {\n        const dock = atom.workspace.getLeftDock();\n        const pane = dock.getActivePane();\n        pane.addItem(item);\n        dock.activate();\n        expect(dock.isVisible()).toBe(true);\n        const itemFound = atom.workspace.hide(URI);\n        expect(itemFound).toBe(true);\n        expect(dock.isVisible()).toBe(false);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "if the item is in the center, removes it",
            "suites": [
                "Workspace",
                "::hide(uri)",
                "when called with an item"
            ],
            "updatePoint": {
                "line": 1047,
                "column": 50
            },
            "line": 1047,
            "code": "      it('if the item is in the center, removes it', () => {\n        const pane = atom.workspace.getActivePane();\n        pane.addItem(item);\n        atom.workspace.hide(item);\n        expect(pane.getItems().length).toBe(0);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "if the item is in a dock, hides the dock",
            "suites": [
                "Workspace",
                "::hide(uri)",
                "when called with an item"
            ],
            "updatePoint": {
                "line": 1053,
                "column": 50
            },
            "line": 1053,
            "code": "      it('if the item is in a dock, hides the dock', () => {\n        const dock = atom.workspace.getLeftDock();\n        const pane = dock.getActivePane();\n        pane.addItem(item);\n        dock.activate();\n        expect(dock.isVisible()).toBe(true);\n        const itemFound = atom.workspace.hide(item);\n        expect(itemFound).toBe(true);\n        expect(dock.isVisible()).toBe(false);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds or shows the item and its dock if it is not currently visible, and otherwise hides the containing dock",
            "suites": [
                "Workspace",
                "::toggle(itemOrUri)",
                "when the location resolves to a dock"
            ],
            "updatePoint": {
                "line": 1067,
                "column": 117
            },
            "line": 1067,
            "code": "      it('adds or shows the item and its dock if it is not currently visible, and otherwise hides the containing dock', async () => {\n        const item1 = {\n          getDefaultLocation() {\n            return 'left';\n          },\n\n          getElement() {\n            return this.element = document.createElement('div');\n          }\n\n        };\n        const item2 = {\n          getDefaultLocation() {\n            return 'left';\n          },\n\n          getElement() {\n            return this.element = document.createElement('div');\n          }\n\n        };\n        const dock = workspace.getLeftDock();\n        expect(dock.isVisible()).toBe(false);\n        await workspace.toggle(item1);\n        expect(dock.isVisible()).toBe(true);\n        expect(dock.getActivePaneItem()).toBe(item1);\n        await workspace.toggle(item2);\n        expect(dock.isVisible()).toBe(true);\n        expect(dock.getActivePaneItem()).toBe(item2);\n        await workspace.toggle(item1);\n        expect(dock.isVisible()).toBe(true);\n        expect(dock.getActivePaneItem()).toBe(item1);\n        await workspace.toggle(item1);\n        expect(dock.isVisible()).toBe(false);\n        expect(dock.getActivePaneItem()).toBe(item1);\n        await workspace.toggle(item2);\n        expect(dock.isVisible()).toBe(true);\n        expect(dock.getActivePaneItem()).toBe(item2);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds or shows the item if it is not currently the active pane item, and otherwise removes the item",
            "suites": [
                "Workspace",
                "::toggle(itemOrUri)",
                "when the location resolves to the center"
            ],
            "updatePoint": {
                "line": 1108,
                "column": 108
            },
            "line": 1108,
            "code": "      it('adds or shows the item if it is not currently the active pane item, and otherwise removes the item', async () => {\n        const item1 = {\n          getDefaultLocation() {\n            return 'center';\n          },\n\n          getElement() {\n            return this.element = document.createElement('div');\n          }\n\n        };\n        const item2 = {\n          getDefaultLocation() {\n            return 'center';\n          },\n\n          getElement() {\n            return this.element = document.createElement('div');\n          }\n\n        };\n        expect(workspace.getActivePaneItem()).toBeUndefined();\n        await workspace.toggle(item1);\n        expect(workspace.getActivePaneItem()).toBe(item1);\n        await workspace.toggle(item2);\n        expect(workspace.getActivePaneItem()).toBe(item2);\n        await workspace.toggle(item1);\n        expect(workspace.getActivePaneItem()).toBe(item1);\n        await workspace.toggle(item1);\n        expect(workspace.paneForItem(item1)).toBeUndefined();\n        expect(workspace.getActivePaneItem()).toBe(item2);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "maintains the active pane and item globally across active pane containers",
            "suites": [
                "Workspace",
                "active pane containers"
            ],
            "updatePoint": {
                "line": 1143,
                "column": 81
            },
            "line": 1143,
            "code": "    it('maintains the active pane and item globally across active pane containers', () => {\n      const leftDock = workspace.getLeftDock();\n      const leftItem1 = {\n        element: document.createElement('div')\n      };\n      const leftItem2 = {\n        element: document.createElement('div')\n      };\n      const leftItem3 = {\n        element: document.createElement('div')\n      };\n      const leftPane1 = leftDock.getActivePane();\n      leftPane1.addItems([leftItem1, leftItem2]);\n      const leftPane2 = leftPane1.splitDown({\n        items: [leftItem3]\n      });\n      const rightDock = workspace.getRightDock();\n      const rightItem1 = {\n        element: document.createElement('div')\n      };\n      const rightItem2 = {\n        element: document.createElement('div')\n      };\n      const rightItem3 = {\n        element: document.createElement('div')\n      };\n      const rightPane1 = rightDock.getActivePane();\n      rightPane1.addItems([rightItem1, rightItem2]);\n      const rightPane2 = rightPane1.splitDown({\n        items: [rightItem3]\n      });\n      const bottomDock = workspace.getBottomDock();\n      const bottomItem1 = {\n        element: document.createElement('div')\n      };\n      const bottomItem2 = {\n        element: document.createElement('div')\n      };\n      const bottomItem3 = {\n        element: document.createElement('div')\n      };\n      const bottomPane1 = bottomDock.getActivePane();\n      bottomPane1.addItems([bottomItem1, bottomItem2]);\n      const bottomPane2 = bottomPane1.splitDown({\n        items: [bottomItem3]\n      });\n      const center = workspace.getCenter();\n      const centerItem1 = {\n        element: document.createElement('div')\n      };\n      const centerItem2 = {\n        element: document.createElement('div')\n      };\n      const centerItem3 = {\n        element: document.createElement('div')\n      };\n      const centerPane1 = center.getActivePane();\n      centerPane1.addItems([centerItem1, centerItem2]);\n      const centerPane2 = centerPane1.splitDown({\n        items: [centerItem3]\n      });\n      const activePaneContainers = [];\n      const activePanes = [];\n      const activeItems = [];\n      workspace.onDidChangeActivePaneContainer(container => activePaneContainers.push(container));\n      workspace.onDidChangeActivePane(pane => activePanes.push(pane));\n      workspace.onDidChangeActivePaneItem(item => activeItems.push(item));\n\n      function clearEvents() {\n        activePaneContainers.length = 0;\n        activePanes.length = 0;\n        activeItems.length = 0;\n      }\n\n      expect(workspace.getActivePaneContainer()).toBe(center);\n      expect(workspace.getActivePane()).toBe(centerPane2);\n      expect(workspace.getActivePaneItem()).toBe(centerItem3);\n      leftDock.activate();\n      expect(workspace.getActivePaneContainer()).toBe(leftDock);\n      expect(workspace.getActivePane()).toBe(leftPane2);\n      expect(workspace.getActivePaneItem()).toBe(leftItem3);\n      expect(activePaneContainers).toEqual([leftDock]);\n      expect(activePanes).toEqual([leftPane2]);\n      expect(activeItems).toEqual([leftItem3]);\n      clearEvents();\n      leftPane1.activate();\n      leftPane1.activate();\n      expect(workspace.getActivePaneContainer()).toBe(leftDock);\n      expect(workspace.getActivePane()).toBe(leftPane1);\n      expect(workspace.getActivePaneItem()).toBe(leftItem1);\n      expect(activePaneContainers).toEqual([]);\n      expect(activePanes).toEqual([leftPane1]);\n      expect(activeItems).toEqual([leftItem1]);\n      clearEvents();\n      leftPane1.activateItem(leftItem2);\n      leftPane1.activateItem(leftItem2);\n      expect(workspace.getActivePaneContainer()).toBe(leftDock);\n      expect(workspace.getActivePane()).toBe(leftPane1);\n      expect(workspace.getActivePaneItem()).toBe(leftItem2);\n      expect(activePaneContainers).toEqual([]);\n      expect(activePanes).toEqual([]);\n      expect(activeItems).toEqual([leftItem2]);\n      clearEvents();\n      expect(rightDock.getActivePane()).toBe(rightPane2);\n      rightPane1.activate();\n      rightPane1.activate();\n      expect(workspace.getActivePaneContainer()).toBe(rightDock);\n      expect(workspace.getActivePane()).toBe(rightPane1);\n      expect(workspace.getActivePaneItem()).toBe(rightItem1);\n      expect(activePaneContainers).toEqual([rightDock]);\n      expect(activePanes).toEqual([rightPane1]);\n      expect(activeItems).toEqual([rightItem1]);\n      clearEvents();\n      rightPane1.activateItem(rightItem2);\n      expect(workspace.getActivePaneContainer()).toBe(rightDock);\n      expect(workspace.getActivePane()).toBe(rightPane1);\n      expect(workspace.getActivePaneItem()).toBe(rightItem2);\n      expect(activePaneContainers).toEqual([]);\n      expect(activePanes).toEqual([]);\n      expect(activeItems).toEqual([rightItem2]);\n      clearEvents();\n      expect(bottomDock.getActivePane()).toBe(bottomPane2);\n      bottomPane2.activate();\n      bottomPane2.activate();\n      expect(workspace.getActivePaneContainer()).toBe(bottomDock);\n      expect(workspace.getActivePane()).toBe(bottomPane2);\n      expect(workspace.getActivePaneItem()).toBe(bottomItem3);\n      expect(activePaneContainers).toEqual([bottomDock]);\n      expect(activePanes).toEqual([bottomPane2]);\n      expect(activeItems).toEqual([bottomItem3]);\n      clearEvents();\n      center.activate();\n      center.activate();\n      expect(workspace.getActivePaneContainer()).toBe(center);\n      expect(workspace.getActivePane()).toBe(centerPane2);\n      expect(workspace.getActivePaneItem()).toBe(centerItem3);\n      expect(activePaneContainers).toEqual([center]);\n      expect(activePanes).toEqual([centerPane2]);\n      expect(activeItems).toEqual([centerItem3]);\n      clearEvents();\n      centerPane1.activate();\n      centerPane1.activate();\n      expect(workspace.getActivePaneContainer()).toBe(center);\n      expect(workspace.getActivePane()).toBe(centerPane1);\n      expect(workspace.getActivePaneItem()).toBe(centerItem1);\n      expect(activePaneContainers).toEqual([]);\n      expect(activePanes).toEqual([centerPane1]);\n      expect(activeItems).toEqual([centerItem1]);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes observers when the active item of the active pane stops changing",
            "suites": [
                "Workspace",
                "::onDidStopChangingActivePaneItem()"
            ],
            "updatePoint": {
                "line": 1294,
                "column": 80
            },
            "line": 1294,
            "code": "    it('invokes observers when the active item of the active pane stops changing', () => {\n      const pane1 = atom.workspace.getCenter().getActivePane();\n      const pane2 = pane1.splitRight({\n        items: [document.createElement('div'), document.createElement('div')]\n      });\n      atom.workspace.getLeftDock().getActivePane().addItem(document.createElement('div'));\n      const emittedItems = [];\n      atom.workspace.onDidStopChangingActivePaneItem(item => emittedItems.push(item));\n      pane2.activateNextItem();\n      pane2.activateNextItem();\n      pane1.activate();\n      atom.workspace.getLeftDock().activate();\n      advanceClock(100);\n      expect(emittedItems).toEqual([atom.workspace.getLeftDock().getActivePaneItem()]);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires when opening a file or changing the grammar of an open file",
            "suites": [
                "Workspace",
                "the grammar-used hook"
            ],
            "updatePoint": {
                "line": 1311,
                "column": 73
            },
            "line": 1311,
            "code": "    it('fires when opening a file or changing the grammar of an open file', async () => {\n      await atom.packages.activatePackage('language-javascript');\n      await atom.packages.activatePackage('language-coffee-script');\n      const observeTextEditorsSpy = jasmine.createSpy('observeTextEditors');\n      const javascriptGrammarUsed = jasmine.createSpy('javascript');\n      const coffeeScriptGrammarUsed = jasmine.createSpy('coffeescript');\n      atom.packages.triggerDeferredActivationHooks();\n      atom.packages.onDidTriggerActivationHook('language-javascript:grammar-used', () => {\n        atom.workspace.observeTextEditors(observeTextEditorsSpy);\n        javascriptGrammarUsed();\n      });\n      atom.packages.onDidTriggerActivationHook('language-coffee-script:grammar-used', coffeeScriptGrammarUsed);\n      expect(javascriptGrammarUsed).not.toHaveBeenCalled();\n      expect(observeTextEditorsSpy).not.toHaveBeenCalled();\n      const editor = await atom.workspace.open('sample.js', {\n        autoIndent: false\n      });\n      expect(javascriptGrammarUsed).toHaveBeenCalled();\n      expect(observeTextEditorsSpy.callCount).toBe(1);\n      expect(coffeeScriptGrammarUsed).not.toHaveBeenCalled();\n      atom.grammars.assignLanguageMode(editor, 'source.coffee');\n      expect(coffeeScriptGrammarUsed).toHaveBeenCalled();\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "fires when opening a file or changing the grammar of an open file",
            "suites": [
                "Workspace",
                "the root-scope-used hook"
            ],
            "updatePoint": {
                "line": 1336,
                "column": 73
            },
            "line": 1336,
            "code": "    it('fires when opening a file or changing the grammar of an open file', async () => {\n      await atom.packages.activatePackage('language-javascript');\n      await atom.packages.activatePackage('language-coffee-script');\n      const observeTextEditorsSpy = jasmine.createSpy('observeTextEditors');\n      const javascriptGrammarUsed = jasmine.createSpy('javascript');\n      const coffeeScriptGrammarUsed = jasmine.createSpy('coffeescript');\n      atom.packages.triggerDeferredActivationHooks();\n      atom.packages.onDidTriggerActivationHook('source.js:root-scope-used', () => {\n        atom.workspace.observeTextEditors(observeTextEditorsSpy);\n        javascriptGrammarUsed();\n      });\n      atom.packages.onDidTriggerActivationHook('source.coffee:root-scope-used', coffeeScriptGrammarUsed);\n      expect(javascriptGrammarUsed).not.toHaveBeenCalled();\n      expect(observeTextEditorsSpy).not.toHaveBeenCalled();\n      const editor = await atom.workspace.open('sample.js', {\n        autoIndent: false\n      });\n      expect(javascriptGrammarUsed).toHaveBeenCalled();\n      expect(observeTextEditorsSpy.callCount).toBe(1);\n      expect(coffeeScriptGrammarUsed).not.toHaveBeenCalled();\n      atom.grammars.assignLanguageMode(editor, 'source.coffee');\n      expect(coffeeScriptGrammarUsed).toHaveBeenCalled();\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the uri associated with the last closed pane that isn't currently open",
            "suites": [
                "Workspace",
                "::reopenItem()"
            ],
            "updatePoint": {
                "line": 1361,
                "column": 84
            },
            "line": 1361,
            "code": "    it(\"opens the uri associated with the last closed pane that isn't currently open\", () => {\n      const pane = workspace.getActivePane();\n      waitsForPromise(() => workspace.open('a').then(() => workspace.open('b').then(() => workspace.open('file1').then(() => workspace.open()))));\n      runs(() => {\n        // does not reopen items with no uri\n        expect(workspace.getActivePaneItem().getURI()).toBeUndefined();\n        pane.destroyActiveItem();\n      });\n      waitsForPromise(() => workspace.reopenItem());\n      const firstDirectory = atom.project.getDirectories()[0];\n      expect(firstDirectory).toBeDefined();\n      runs(() => {\n        expect(workspace.getActivePaneItem().getURI()).not.toBeUndefined(); // destroy all items\n\n        expect(workspace.getActivePaneItem().getURI()).toBe(firstDirectory.resolve('file1'));\n        pane.destroyActiveItem();\n        expect(workspace.getActivePaneItem().getURI()).toBe(firstDirectory.resolve('b'));\n        pane.destroyActiveItem();\n        expect(workspace.getActivePaneItem().getURI()).toBe(firstDirectory.resolve('a'));\n        pane.destroyActiveItem(); // reopens items with uris\n\n        expect(workspace.getActivePaneItem()).toBeUndefined();\n      });\n      waitsForPromise(() => workspace.reopenItem());\n      runs(() => expect(workspace.getActivePaneItem().getURI()).toBe(firstDirectory.resolve('a'))); // does not reopen items that are already open\n\n      waitsForPromise(() => workspace.open('b'));\n      runs(() => expect(workspace.getActivePaneItem().getURI()).toBe(firstDirectory.resolve('b')));\n      waitsForPromise(() => workspace.reopenItem());\n      runs(() => expect(workspace.getActivePaneItem().getURI()).toBe(firstDirectory.resolve('file1')));\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "increases/decreases the font size without going below 1",
            "suites": [
                "Workspace",
                "::increase/decreaseFontSize()"
            ],
            "updatePoint": {
                "line": 1394,
                "column": 63
            },
            "line": 1394,
            "code": "    it('increases/decreases the font size without going below 1', () => {\n      atom.config.set('editor.fontSize', 1);\n      workspace.increaseFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(2);\n      workspace.increaseFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(3);\n      workspace.decreaseFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(2);\n      workspace.decreaseFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(1);\n      workspace.decreaseFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(1);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resets the font size to the window's default font size",
            "suites": [
                "Workspace",
                "::resetFontSize()"
            ],
            "updatePoint": {
                "line": 1409,
                "column": 62
            },
            "line": 1409,
            "code": "    it(\"resets the font size to the window's default font size\", () => {\n      const defaultFontSize = atom.config.get('editor.defaultFontSize');\n      workspace.increaseFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(defaultFontSize + 1);\n      workspace.resetFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(defaultFontSize);\n      workspace.decreaseFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(defaultFontSize - 1);\n      workspace.resetFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(defaultFontSize);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resets the font size the default font size when it is changed",
            "suites": [
                "Workspace",
                "::resetFontSize()"
            ],
            "updatePoint": {
                "line": 1420,
                "column": 69
            },
            "line": 1420,
            "code": "    it('resets the font size the default font size when it is changed', () => {\n      const defaultFontSize = atom.config.get('editor.defaultFontSize');\n      workspace.increaseFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(defaultFontSize + 1);\n      atom.config.set('editor.defaultFontSize', 14);\n      workspace.resetFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(14);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does nothing if the font size has not been changed",
            "suites": [
                "Workspace",
                "::resetFontSize()"
            ],
            "updatePoint": {
                "line": 1428,
                "column": 58
            },
            "line": 1428,
            "code": "    it('does nothing if the font size has not been changed', () => {\n      const originalFontSize = atom.config.get('editor.fontSize');\n      workspace.resetFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(originalFontSize);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "resets the font size when the editor's font size changes",
            "suites": [
                "Workspace",
                "::resetFontSize()"
            ],
            "updatePoint": {
                "line": 1433,
                "column": 64
            },
            "line": 1433,
            "code": "    it(\"resets the font size when the editor's font size changes\", () => {\n      const originalFontSize = atom.config.get('editor.fontSize');\n      atom.config.set('editor.fontSize', originalFontSize + 1);\n      workspace.resetFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(originalFontSize);\n      atom.config.set('editor.fontSize', originalFontSize - 1);\n      workspace.resetFontSize();\n      expect(atom.config.get('editor.fontSize')).toBe(originalFontSize);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "opens the license as plain-text in a buffer",
            "suites": [
                "Workspace",
                "::openLicense()"
            ],
            "updatePoint": {
                "line": 1444,
                "column": 51
            },
            "line": 1444,
            "code": "    it('opens the license as plain-text in a buffer', () => {\n      waitsForPromise(() => workspace.openLicense());\n      runs(() => expect(workspace.getActivePaneItem().getText()).toMatch(/Copyright/));\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns true when the passed object is an instance of `TextEditor`",
            "suites": [
                "Workspace",
                "::isTextEditor(obj)"
            ],
            "updatePoint": {
                "line": 1450,
                "column": 74
            },
            "line": 1450,
            "code": "    it('returns true when the passed object is an instance of `TextEditor`', () => {\n      expect(workspace.isTextEditor(new TextEditor())).toBe(true);\n      expect(workspace.isTextEditor({\n        getText: () => null\n      })).toBe(false);\n      expect(workspace.isTextEditor(null)).toBe(false);\n      expect(workspace.isTextEditor(undefined)).toBe(false);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the text editor",
            "suites": [
                "Workspace",
                "::getActiveTextEditor()",
                "when the workspace center's active pane item is a text editor",
                "when the workspace center has focus"
            ],
            "updatePoint": {
                "line": 1462,
                "column": 35
            },
            "line": 1462,
            "code": "        it('returns the text editor', () => {\n          const workspaceCenter = workspace.getCenter();\n          const editor = new TextEditor();\n          workspaceCenter.getActivePane().activateItem(editor);\n          workspaceCenter.activate();\n          expect(workspace.getActiveTextEditor()).toBe(editor);\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the text editor",
            "suites": [
                "Workspace",
                "::getActiveTextEditor()",
                "when the workspace center's active pane item is a text editor",
                "when a dock has focus"
            ],
            "updatePoint": {
                "line": 1471,
                "column": 35
            },
            "line": 1471,
            "code": "        it('returns the text editor', () => {\n          const workspaceCenter = workspace.getCenter();\n          const editor = new TextEditor();\n          workspaceCenter.getActivePane().activateItem(editor);\n          workspace.getLeftDock().activate();\n          expect(workspace.getActiveTextEditor()).toBe(editor);\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns undefined",
            "suites": [
                "Workspace",
                "::getActiveTextEditor()",
                "when the workspace center's active pane item is not a text editor"
            ],
            "updatePoint": {
                "line": 1481,
                "column": 27
            },
            "line": 1481,
            "code": "      it('returns undefined', () => {\n        const workspaceCenter = workspace.getCenter();\n        const nonEditorItem = document.createElement('div');\n        workspaceCenter.getActivePane().activateItem(nonEditorItem);\n        expect(workspace.getActiveTextEditor()).toBeUndefined();\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the observer with current and future text editors",
            "suites": [
                "Workspace",
                "::observeTextEditors()"
            ],
            "updatePoint": {
                "line": 1490,
                "column": 65
            },
            "line": 1490,
            "code": "    it('invokes the observer with current and future text editors', () => {\n      const observed = [];\n      waitsForPromise(() => workspace.open());\n      waitsForPromise(() => workspace.open());\n      waitsForPromise(() => workspace.openLicense());\n      runs(() => workspace.observeTextEditors(editor => observed.push(editor)));\n      waitsForPromise(() => workspace.open());\n      expect(observed).toEqual(workspace.getTextEditors());\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the observer with current active text editor and each time a different text editor becomes active",
            "suites": [
                "Workspace",
                "::observeActiveTextEditor()"
            ],
            "updatePoint": {
                "line": 1501,
                "column": 113
            },
            "line": 1501,
            "code": "    it('invokes the observer with current active text editor and each time a different text editor becomes active', () => {\n      const pane = workspace.getCenter().getActivePane();\n      const observed = [];\n      const inactiveEditorBeforeRegisteringObserver = new TextEditor();\n      const activeEditorBeforeRegisteringObserver = new TextEditor();\n      pane.activateItem(inactiveEditorBeforeRegisteringObserver);\n      pane.activateItem(activeEditorBeforeRegisteringObserver);\n      workspace.observeActiveTextEditor(editor => observed.push(editor));\n      const editorAddedAfterRegisteringObserver = new TextEditor();\n      pane.activateItem(editorAddedAfterRegisteringObserver);\n      expect(observed).toEqual([activeEditorBeforeRegisteringObserver, editorAddedAfterRegisteringObserver]);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the observer when a text editor becomes the workspace center's active pane item while a dock has focus",
            "suites": [
                "Workspace",
                "::onDidChangeActiveTextEditor()"
            ],
            "updatePoint": {
                "line": 1521,
                "column": 118
            },
            "line": 1521,
            "code": "    it(\"invokes the observer when a text editor becomes the workspace center's active pane item while a dock has focus\", () => {\n      workspace.onDidChangeActiveTextEditor(editor => observed.push(editor));\n      const dock = workspace.getLeftDock();\n      dock.activate();\n      expect(atom.workspace.getActivePaneContainer()).toBe(dock);\n      const editor = new TextEditor();\n      center.getActivePane().activateItem(editor);\n      expect(atom.workspace.getActivePaneContainer()).toBe(dock);\n      expect(observed).toEqual([editor]);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the observer when the last text editor is closed",
            "suites": [
                "Workspace",
                "::onDidChangeActiveTextEditor()"
            ],
            "updatePoint": {
                "line": 1531,
                "column": 64
            },
            "line": 1531,
            "code": "    it('invokes the observer when the last text editor is closed', () => {\n      const editor = new TextEditor();\n      pane.activateItem(editor);\n      workspace.onDidChangeActiveTextEditor(editor => observed.push(editor));\n      pane.destroyItem(editor);\n      expect(observed).toEqual([undefined]);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the observer when the workspace center's active pane item changes from an editor item to a non-editor item",
            "suites": [
                "Workspace",
                "::onDidChangeActiveTextEditor()"
            ],
            "updatePoint": {
                "line": 1538,
                "column": 122
            },
            "line": 1538,
            "code": "    it(\"invokes the observer when the workspace center's active pane item changes from an editor item to a non-editor item\", () => {\n      const editor = new TextEditor();\n      const nonEditorItem = document.createElement('div');\n      pane.activateItem(editor);\n      workspace.onDidChangeActiveTextEditor(editor => observed.push(editor));\n      pane.activateItem(nonEditorItem);\n      expect(observed).toEqual([undefined]);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not invoke the observer when the workspace center's active pane item changes from a non-editor item to another non-editor item",
            "suites": [
                "Workspace",
                "::onDidChangeActiveTextEditor()"
            ],
            "updatePoint": {
                "line": 1546,
                "column": 139
            },
            "line": 1546,
            "code": "    it(\"does not invoke the observer when the workspace center's active pane item changes from a non-editor item to another non-editor item\", () => {\n      workspace.onDidChangeActiveTextEditor(editor => observed.push(editor));\n      const nonEditorItem1 = document.createElement('div');\n      const nonEditorItem2 = document.createElement('div');\n      pane.activateItem(nonEditorItem1);\n      pane.activateItem(nonEditorItem2);\n      expect(observed).toEqual([]);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "invokes the observer when closing the one and only text editor after deserialization",
            "suites": [
                "Workspace",
                "::onDidChangeActiveTextEditor()"
            ],
            "updatePoint": {
                "line": 1554,
                "column": 92
            },
            "line": 1554,
            "code": "    it('invokes the observer when closing the one and only text editor after deserialization', async () => {\n      pane.activateItem(new TextEditor());\n      simulateReload();\n      runs(() => {\n        workspace.onDidChangeActiveTextEditor(editor => observed.push(editor));\n        workspace.closeActivePaneItemOrEmptyPaneOrWindow();\n        expect(observed).toEqual([undefined]);\n      });\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "removes the editor",
            "suites": [
                "Workspace",
                "when an editor is destroyed"
            ],
            "updatePoint": {
                "line": 1565,
                "column": 26
            },
            "line": 1565,
            "code": "    it('removes the editor', async () => {\n      const editor = await workspace.open('a');\n      expect(workspace.getTextEditors()).toHaveLength(1);\n      editor.destroy();\n      expect(workspace.getTextEditors()).toHaveLength(0);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets up the new editor to be configured by the text editor registry",
            "suites": [
                "Workspace",
                "when an editor is copied because its pane is split"
            ],
            "updatePoint": {
                "line": 1573,
                "column": 75
            },
            "line": 1573,
            "code": "    it('sets up the new editor to be configured by the text editor registry', async () => {\n      await atom.packages.activatePackage('language-javascript');\n      const editor = await workspace.open('a');\n      atom.grammars.assignLanguageMode(editor, 'source.js');\n      expect(editor.getGrammar().name).toBe('JavaScript');\n      workspace.getActivePane().splitRight({\n        copyActiveItem: true\n      });\n      const newEditor = workspace.getActiveTextEditor();\n      expect(newEditor).not.toBe(editor);\n      expect(newEditor.getGrammar().name).toBe('JavaScript');\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stores the active grammars used by all the open editors",
            "suites": [
                "Workspace",
                "when an editor is copied because its pane is split"
            ],
            "updatePoint": {
                "line": 1586,
                "column": 61
            },
            "line": 1586,
            "code": "  it('stores the active grammars used by all the open editors', () => {\n    waitsForPromise(() => atom.packages.activatePackage('language-javascript'));\n    waitsForPromise(() => atom.packages.activatePackage('language-coffee-script'));\n    waitsForPromise(() => atom.packages.activatePackage('language-todo'));\n    waitsForPromise(() => atom.workspace.open('sample.coffee'));\n    runs(() => {\n      atom.workspace.getActiveTextEditor().setText(dedent`\n        i = /test/; #FIXME\\\n      `);\n      const atom2 = new AtomEnvironment({\n        applicationDelegate: atom.applicationDelegate\n      });\n      atom2.initialize({\n        window: document.createElement('div'),\n        document: Object.assign(document.createElement('div'), {\n          body: document.createElement('div'),\n          head: document.createElement('div')\n        })\n      });\n      atom2.packages.loadPackage('language-javascript');\n      atom2.packages.loadPackage('language-coffee-script');\n      atom2.packages.loadPackage('language-todo');\n      atom2.project.deserialize(atom.project.serialize());\n      atom2.workspace.deserialize(atom.workspace.serialize(), atom2.deserializers);\n      expect(atom2.grammars.getGrammars({\n        includeTreeSitter: true\n      }).map(grammar => grammar.scopeName).sort()).toEqual(['source.coffee', 'source.js', // Tree-sitter grammars also load\n      'source.js', 'source.js.regexp', 'source.js.regexp', 'source.js.regexp.replacement', 'source.jsdoc', 'source.jsdoc', 'source.litcoffee', 'text.plain.null-grammar', 'text.todo']);\n      atom2.destroy();\n    });\n  });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the title to the project path",
            "suites": [
                "Workspace",
                "document.title",
                "when there is no item open"
            ],
            "updatePoint": {
                "line": 1619,
                "column": 44
            },
            "line": 1619,
            "code": "      it('sets the title to the project path', () => expect(document.title).toMatch(escapeStringRegex(fs.tildify(atom.project.getPaths()[0]))));",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the title to 'untitled' if there is no project path",
            "suites": [
                "Workspace",
                "document.title",
                "when there is no item open"
            ],
            "updatePoint": {
                "line": 1620,
                "column": 66
            },
            "line": 1620,
            "code": "      it(\"sets the title to 'untitled' if there is no project path\", () => {\n        atom.project.setPaths([]);\n        expect(document.title).toMatch(/^untitled/);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the title to the pane item's title plus the item's path",
            "suites": [
                "Workspace",
                "document.title",
                "when the active pane item's path is not inside a project path"
            ],
            "updatePoint": {
                "line": 1627,
                "column": 70
            },
            "line": 1627,
            "code": "      it(\"sets the title to the pane item's title plus the item's path\", () => {\n        const item = atom.workspace.getActivePaneItem();\n        const pathEscaped = fs.tildify(escapeStringRegex(path.dirname(item.getPath())));\n        expect(document.title).toMatch(new RegExp(`^${item.getTitle()} \\\\u2014 ${pathEscaped}`));\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the window title based on the item's new title",
            "suites": [
                "Workspace",
                "document.title",
                "when the active pane item's path is not inside a project path",
                "when the title of the active pane item changes"
            ],
            "updatePoint": {
                "line": 1633,
                "column": 66
            },
            "line": 1633,
            "code": "        it(\"updates the window title based on the item's new title\", () => {\n          const editor = atom.workspace.getActivePaneItem();\n          editor.buffer.setPath(path.join(temp.dir, 'hi'));\n          const pathEscaped = fs.tildify(escapeStringRegex(path.dirname(editor.getPath())));\n          expect(document.title).toMatch(new RegExp(`^${editor.getTitle()} \\\\u2014 ${pathEscaped}`));\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the title to the new item's title plus the project path",
            "suites": [
                "Workspace",
                "document.title",
                "when the active pane item's path is not inside a project path",
                "when the active pane's item changes"
            ],
            "updatePoint": {
                "line": 1641,
                "column": 75
            },
            "line": 1641,
            "code": "        it(\"updates the title to the new item's title plus the project path\", () => {\n          atom.workspace.getActivePane().activateNextItem();\n          const item = atom.workspace.getActivePaneItem();\n          const pathEscaped = fs.tildify(escapeStringRegex(path.dirname(item.getPath())));\n          expect(document.title).toMatch(new RegExp(`^${item.getTitle()} \\\\u2014 ${pathEscaped}`));\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not update the title",
            "suites": [
                "Workspace",
                "document.title",
                "when the active pane item's path is not inside a project path",
                "when an inactive pane's item changes"
            ],
            "updatePoint": {
                "line": 1649,
                "column": 37
            },
            "line": 1649,
            "code": "        it('does not update the title', () => {\n          const pane = atom.workspace.getActivePane();\n          pane.splitRight();\n          const initialTitle = document.title;\n          pane.activateNextItem();\n          expect(document.title).toBe(initialTitle);\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "sets the title to the pane item's title plus the project path",
            "suites": [
                "Workspace",
                "document.title",
                "when the active pane item is inside a project path",
                "when there is an active pane item"
            ],
            "updatePoint": {
                "line": 1661,
                "column": 73
            },
            "line": 1661,
            "code": "        it(\"sets the title to the pane item's title plus the project path\", () => {\n          const item = atom.workspace.getActivePaneItem();\n          const pathEscaped = fs.tildify(escapeStringRegex(atom.project.getPaths()[0]));\n          expect(document.title).toMatch(new RegExp(`^${item.getTitle()} \\\\u2014 ${pathEscaped}`));\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the window title based on the item's new title",
            "suites": [
                "Workspace",
                "document.title",
                "when the active pane item is inside a project path",
                "when the title of the active pane item changes"
            ],
            "updatePoint": {
                "line": 1668,
                "column": 66
            },
            "line": 1668,
            "code": "        it(\"updates the window title based on the item's new title\", () => {\n          const editor = atom.workspace.getActivePaneItem();\n          editor.buffer.setPath(path.join(atom.project.getPaths()[0], 'hi'));\n          const pathEscaped = fs.tildify(escapeStringRegex(atom.project.getPaths()[0]));\n          expect(document.title).toMatch(new RegExp(`^${editor.getTitle()} \\\\u2014 ${pathEscaped}`));\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the title to the new item's title plus the project path",
            "suites": [
                "Workspace",
                "document.title",
                "when the active pane item is inside a project path",
                "when the active pane's item changes"
            ],
            "updatePoint": {
                "line": 1676,
                "column": 75
            },
            "line": 1676,
            "code": "        it(\"updates the title to the new item's title plus the project path\", () => {\n          atom.workspace.getActivePane().activateNextItem();\n          const item = atom.workspace.getActivePaneItem();\n          const pathEscaped = fs.tildify(escapeStringRegex(atom.project.getPaths()[0]));\n          expect(document.title).toMatch(new RegExp(`^${item.getTitle()} \\\\u2014 ${pathEscaped}`));\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the title to the project's first path",
            "suites": [
                "Workspace",
                "document.title",
                "when the active pane item is inside a project path",
                "when the last pane item is removed"
            ],
            "updatePoint": {
                "line": 1684,
                "column": 57
            },
            "line": 1684,
            "code": "        it(\"updates the title to the project's first path\", () => {\n          atom.workspace.getActivePane().destroy();\n          expect(atom.workspace.getActivePaneItem()).toBeUndefined();\n          expect(document.title).toMatch(escapeStringRegex(fs.tildify(atom.project.getPaths()[0])));\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not update the title",
            "suites": [
                "Workspace",
                "document.title",
                "when the active pane item is inside a project path",
                "when an inactive pane's item changes"
            ],
            "updatePoint": {
                "line": 1691,
                "column": 37
            },
            "line": 1691,
            "code": "        it('does not update the title', () => {\n          const pane = atom.workspace.getActivePane();\n          pane.splitRight();\n          const initialTitle = document.title;\n          pane.activateNextItem();\n          expect(document.title).toBe(initialTitle);\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "updates the title to contain the project's path",
            "suites": [
                "Workspace",
                "document.title",
                "when the workspace is deserialized"
            ],
            "updatePoint": {
                "line": 1702,
                "column": 57
            },
            "line": 1702,
            "code": "      it(\"updates the title to contain the project's path\", () => {\n        document.title = null;\n        const atom2 = new AtomEnvironment({\n          applicationDelegate: atom.applicationDelegate\n        });\n        atom2.initialize({\n          window: document.createElement('div'),\n          document: Object.assign(document.createElement('div'), {\n            body: document.createElement('div'),\n            head: document.createElement('div')\n          })\n        });\n        waitsForPromise(() => atom2.project.deserialize(atom.project.serialize()));\n        runs(() => {\n          atom2.workspace.deserialize(atom.workspace.serialize(), atom2.deserializers);\n          const item = atom2.workspace.getActivePaneItem();\n          const pathEscaped = fs.tildify(escapeStringRegex(atom.project.getPaths()[0]));\n          expect(document.title).toMatch(new RegExp(`^${item.getLongTitle()} \\\\u2014 ${pathEscaped}`));\n          atom2.destroy();\n        });\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls setDocumentEdited when the active item changes",
            "suites": [
                "Workspace",
                "document edited status"
            ],
            "updatePoint": {
                "line": 1735,
                "column": 60
            },
            "line": 1735,
            "code": "    it('calls setDocumentEdited when the active item changes', () => {\n      expect(atom.workspace.getActivePaneItem()).toBe(item2);\n      item1.insertText('a');\n      expect(item1.isModified()).toBe(true);\n      atom.workspace.getActivePane().activateNextItem();\n      expect(setDocumentEdited).toHaveBeenCalledWith(true);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls atom.setDocumentEdited when the active item's modified status changes",
            "suites": [
                "Workspace",
                "document edited status"
            ],
            "updatePoint": {
                "line": 1742,
                "column": 83
            },
            "line": 1742,
            "code": "    it(\"calls atom.setDocumentEdited when the active item's modified status changes\", () => {\n      expect(atom.workspace.getActivePaneItem()).toBe(item2);\n      item2.insertText('a');\n      advanceClock(item2.getBuffer().getStoppedChangingDelay());\n      expect(item2.isModified()).toBe(true);\n      expect(setDocumentEdited).toHaveBeenCalledWith(true);\n      item2.undo();\n      advanceClock(item2.getBuffer().getStoppedChangingDelay());\n      expect(item2.isModified()).toBe(false);\n      expect(setDocumentEdited).toHaveBeenCalledWith(false);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a panel to the correct panel container",
            "suites": [
                "Workspace",
                "adding panels",
                "::addLeftPanel(model)"
            ],
            "updatePoint": {
                "line": 1782,
                "column": 53
            },
            "line": 1782,
            "code": "      it('adds a panel to the correct panel container', () => {\n        let addPanelSpy;\n        expect(atom.workspace.getLeftPanels().length).toBe(0);\n        atom.workspace.panelContainers.left.onDidAddPanel(addPanelSpy = jasmine.createSpy());\n        const model = new TestItem();\n        const panel = atom.workspace.addLeftPanel({\n          item: model\n        });\n        expect(panel).toBeDefined();\n        expect(addPanelSpy).toHaveBeenCalledWith({\n          panel,\n          index: 0\n        });\n        const itemView = atom.views.getView(atom.workspace.getLeftPanels()[0].getItem());\n        expect(itemView instanceof TestItemElement).toBe(true);\n        expect(itemView.getModel()).toBe(model);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a panel to the correct panel container",
            "suites": [
                "Workspace",
                "adding panels",
                "::addRightPanel(model)"
            ],
            "updatePoint": {
                "line": 1801,
                "column": 53
            },
            "line": 1801,
            "code": "      it('adds a panel to the correct panel container', () => {\n        let addPanelSpy;\n        expect(atom.workspace.getRightPanels().length).toBe(0);\n        atom.workspace.panelContainers.right.onDidAddPanel(addPanelSpy = jasmine.createSpy());\n        const model = new TestItem();\n        const panel = atom.workspace.addRightPanel({\n          item: model\n        });\n        expect(panel).toBeDefined();\n        expect(addPanelSpy).toHaveBeenCalledWith({\n          panel,\n          index: 0\n        });\n        const itemView = atom.views.getView(atom.workspace.getRightPanels()[0].getItem());\n        expect(itemView instanceof TestItemElement).toBe(true);\n        expect(itemView.getModel()).toBe(model);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a panel to the correct panel container",
            "suites": [
                "Workspace",
                "adding panels",
                "::addTopPanel(model)"
            ],
            "updatePoint": {
                "line": 1820,
                "column": 53
            },
            "line": 1820,
            "code": "      it('adds a panel to the correct panel container', () => {\n        let addPanelSpy;\n        expect(atom.workspace.getTopPanels().length).toBe(0);\n        atom.workspace.panelContainers.top.onDidAddPanel(addPanelSpy = jasmine.createSpy());\n        const model = new TestItem();\n        const panel = atom.workspace.addTopPanel({\n          item: model\n        });\n        expect(panel).toBeDefined();\n        expect(addPanelSpy).toHaveBeenCalledWith({\n          panel,\n          index: 0\n        });\n        const itemView = atom.views.getView(atom.workspace.getTopPanels()[0].getItem());\n        expect(itemView instanceof TestItemElement).toBe(true);\n        expect(itemView.getModel()).toBe(model);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a panel to the correct panel container",
            "suites": [
                "Workspace",
                "adding panels",
                "::addBottomPanel(model)"
            ],
            "updatePoint": {
                "line": 1839,
                "column": 53
            },
            "line": 1839,
            "code": "      it('adds a panel to the correct panel container', () => {\n        let addPanelSpy;\n        expect(atom.workspace.getBottomPanels().length).toBe(0);\n        atom.workspace.panelContainers.bottom.onDidAddPanel(addPanelSpy = jasmine.createSpy());\n        const model = new TestItem();\n        const panel = atom.workspace.addBottomPanel({\n          item: model\n        });\n        expect(panel).toBeDefined();\n        expect(addPanelSpy).toHaveBeenCalledWith({\n          panel,\n          index: 0\n        });\n        const itemView = atom.views.getView(atom.workspace.getBottomPanels()[0].getItem());\n        expect(itemView instanceof TestItemElement).toBe(true);\n        expect(itemView.getModel()).toBe(model);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a panel to the correct panel container",
            "suites": [
                "Workspace",
                "adding panels",
                "::addHeaderPanel(model)"
            ],
            "updatePoint": {
                "line": 1858,
                "column": 53
            },
            "line": 1858,
            "code": "      it('adds a panel to the correct panel container', () => {\n        let addPanelSpy;\n        expect(atom.workspace.getHeaderPanels().length).toBe(0);\n        atom.workspace.panelContainers.header.onDidAddPanel(addPanelSpy = jasmine.createSpy());\n        const model = new TestItem();\n        const panel = atom.workspace.addHeaderPanel({\n          item: model\n        });\n        expect(panel).toBeDefined();\n        expect(addPanelSpy).toHaveBeenCalledWith({\n          panel,\n          index: 0\n        });\n        const itemView = atom.views.getView(atom.workspace.getHeaderPanels()[0].getItem());\n        expect(itemView instanceof TestItemElement).toBe(true);\n        expect(itemView.getModel()).toBe(model);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a panel to the correct panel container",
            "suites": [
                "Workspace",
                "adding panels",
                "::addFooterPanel(model)"
            ],
            "updatePoint": {
                "line": 1877,
                "column": 53
            },
            "line": 1877,
            "code": "      it('adds a panel to the correct panel container', () => {\n        let addPanelSpy;\n        expect(atom.workspace.getFooterPanels().length).toBe(0);\n        atom.workspace.panelContainers.footer.onDidAddPanel(addPanelSpy = jasmine.createSpy());\n        const model = new TestItem();\n        const panel = atom.workspace.addFooterPanel({\n          item: model\n        });\n        expect(panel).toBeDefined();\n        expect(addPanelSpy).toHaveBeenCalledWith({\n          panel,\n          index: 0\n        });\n        const itemView = atom.views.getView(atom.workspace.getFooterPanels()[0].getItem());\n        expect(itemView instanceof TestItemElement).toBe(true);\n        expect(itemView.getModel()).toBe(model);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "adds a panel to the correct panel container",
            "suites": [
                "Workspace",
                "adding panels",
                "::addModalPanel(model)"
            ],
            "updatePoint": {
                "line": 1896,
                "column": 53
            },
            "line": 1896,
            "code": "      it('adds a panel to the correct panel container', () => {\n        let addPanelSpy;\n        expect(atom.workspace.getModalPanels().length).toBe(0);\n        atom.workspace.panelContainers.modal.onDidAddPanel(addPanelSpy = jasmine.createSpy());\n        const model = new TestItem();\n        const panel = atom.workspace.addModalPanel({\n          item: model\n        });\n        expect(panel).toBeDefined();\n        expect(addPanelSpy).toHaveBeenCalledWith({\n          panel,\n          index: 0\n        });\n        const itemView = atom.views.getView(atom.workspace.getModalPanels()[0].getItem());\n        expect(itemView instanceof TestItemElement).toBe(true);\n        expect(itemView.getModel()).toBe(model);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns the panel associated with the item",
            "suites": [
                "Workspace",
                "adding panels",
                "::panelForItem(item)"
            ],
            "updatePoint": {
                "line": 1915,
                "column": 52
            },
            "line": 1915,
            "code": "      it('returns the panel associated with the item', () => {\n        const item = new TestItem();\n        const panel = atom.workspace.addLeftPanel({\n          item\n        });\n        const itemWithNoPanel = new TestItem();\n        expect(atom.workspace.panelForItem(item)).toBe(panel);\n        expect(atom.workspace.panelForItem(itemWithNoPanel)).toBe(null);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls the callback with all regex results in all files in the project",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex"
            ],
            "updatePoint": {
                "line": 1936,
                "column": 81
            },
            "line": 1936,
            "code": "        it('calls the callback with all regex results in all files in the project', async () => {\n          const results = [];\n          await scan(/(a)+/, {\n            leadingContextLineCount: 1,\n            trailingContextLineCount: 1\n          }, result => results.push(result));\n          results.sort((a, b) => a.filePath.localeCompare(b.filePath));\n          expect(results.length).toBeGreaterThan(0);\n          expect(results[0].filePath).toBe(atom.project.getDirectories()[0].resolve('a'));\n          expect(results[0].matches).toHaveLength(3);\n          expect(results[0].matches[0]).toEqual({\n            matchText: 'aaa',\n            lineText: 'aaa bbb',\n            lineTextOffset: 0,\n            range: [[0, 0], [0, 3]],\n            leadingContextLines: [],\n            trailingContextLines: ['cc aa cc']\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works with with escaped literals (like $ and ^)",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex"
            ],
            "updatePoint": {
                "line": 1955,
                "column": 59
            },
            "line": 1955,
            "code": "        it('works with with escaped literals (like $ and ^)', async () => {\n          const results = [];\n          await scan(/\\$\\w+/, {\n            leadingContextLineCount: 1,\n            trailingContextLineCount: 1\n          }, result => results.push(result));\n          expect(results.length).toBe(1);\n          const {\n            filePath,\n            matches\n          } = results[0];\n          expect(filePath).toBe(atom.project.getDirectories()[0].resolve('a'));\n          expect(matches).toHaveLength(1);\n          expect(matches[0]).toEqual({\n            matchText: '$bill',\n            lineText: 'dollar$bill',\n            lineTextOffset: 0,\n            range: [[2, 6], [2, 11]],\n            leadingContextLines: ['cc aa cc'],\n            trailingContextLines: []\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works on evil filenames",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex"
            ],
            "updatePoint": {
                "line": 1977,
                "column": 35
            },
            "line": 1977,
            "code": "        it('works on evil filenames', async () => {\n          atom.config.set('core.excludeVcsIgnoredPaths', false);\n          platform.generateEvilFiles();\n          atom.project.setPaths([path.join(__dirname, 'fixtures', 'evil-files')]);\n          const paths = [];\n          let matches = [];\n          await scan(/evil/, {}, result => {\n            paths.push(result.filePath);\n            matches = matches.concat(result.matches);\n          }); // Sort the paths to make the test deterministic.\n\n          paths.sort();\n\n          _.each(matches, m => expect(m.matchText).toEqual('evil'));\n\n          if (platform.isWindows()) {\n            expect(paths.length).toBe(3);\n            expect(paths[0]).toMatch(/a_file_with_utf8.txt$/);\n            expect(paths[1]).toMatch(/file with spaces.txt$/);\n            expect(path.basename(paths[2])).toBe('utfa\\u0306.md');\n          } else {\n            expect(paths.length).toBe(5);\n            expect(paths[0]).toMatch(/a_file_with_utf8.txt$/);\n            expect(paths[1]).toMatch(/file with spaces.txt$/);\n            expect(paths[2]).toMatch(/goddam\\nnewlines$/m);\n            expect(paths[3]).toMatch(/quote\".txt$/m);\n            expect(path.basename(paths[4])).toBe('utfa\\u0306.md');\n          }\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores case if the regex includes the `i` flag",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex"
            ],
            "updatePoint": {
                "line": 2006,
                "column": 59
            },
            "line": 2006,
            "code": "        it('ignores case if the regex includes the `i` flag', async () => {\n          const results = [];\n          await scan(/DOLLAR/i, {}, result => results.push(result));\n          expect(results).toHaveLength(1);\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns empty text matches",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex"
            ],
            "updatePoint": {
                "line": 2013,
                "column": 40
            },
            "line": 2013,
            "code": "          it('returns empty text matches', async () => {\n            const results = [];\n            await scan(/^\\s{0}/, {\n              paths: [`oh-git`]\n            }, result => results.push(result));\n            expect(results.length).toBe(1);\n            const {\n              filePath,\n              matches\n            } = results[0];\n            expect(filePath).toBe(atom.project.getDirectories()[0].resolve(path.join('a-dir', 'oh-git')));\n            expect(matches).toHaveLength(1);\n            expect(matches[0]).toEqual({\n              matchText: '',\n              lineText: 'bbb aaaa',\n              lineTextOffset: 0,\n              range: [[0, 0], [0, 0]],\n              leadingContextLines: [],\n              trailingContextLines: []\n            });\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns multiline results from regexps",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "newlines on regexps"
            ],
            "updatePoint": {
                "line": 2035,
                "column": 54
            },
            "line": 2035,
            "code": "            it('returns multiline results from regexps', async () => {\n              const results = [];\n              await scan(/first\\nsecond/, {}, result => results.push(result));\n              expect(results.length).toBe(1);\n              const {\n                filePath,\n                matches\n              } = results[0];\n              expect(filePath).toBe(atom.project.getDirectories()[0].resolve('file-with-newline-literal'));\n              expect(matches).toHaveLength(1);\n              expect(matches[0]).toEqual({\n                matchText: 'first\\nsecond',\n                lineText: 'first\\nsecond\\\\nthird',\n                lineTextOffset: 0,\n                range: [[3, 0], [4, 6]],\n                leadingContextLines: [],\n                trailingContextLines: []\n              });\n            });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns correctly the context lines",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "newlines on regexps"
            ],
            "updatePoint": {
                "line": 2054,
                "column": 51
            },
            "line": 2054,
            "code": "            it('returns correctly the context lines', async () => {\n              const results = [];\n              await scan(/first\\nsecond/, {\n                leadingContextLineCount: 2,\n                trailingContextLineCount: 2\n              }, result => results.push(result));\n              expect(results.length).toBe(1);\n              const {\n                filePath,\n                matches\n              } = results[0];\n              expect(filePath).toBe(atom.project.getDirectories()[0].resolve('file-with-newline-literal'));\n              expect(matches).toHaveLength(1);\n              expect(matches[0]).toEqual({\n                matchText: 'first\\nsecond',\n                lineText: 'first\\nsecond\\\\nthird',\n                lineTextOffset: 0,\n                range: [[3, 0], [4, 6]],\n                leadingContextLines: ['newline2', 'newline3'],\n                trailingContextLines: ['newline4', 'newline5']\n              });\n            });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns multiple results from the same line",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "newlines on regexps"
            ],
            "updatePoint": {
                "line": 2076,
                "column": 59
            },
            "line": 2076,
            "code": "            it('returns multiple results from the same line', async () => {\n              const results = [];\n              await scan(/line\\d\\nne/, {}, result => results.push(result));\n              results.sort((a, b) => a.filePath.localeCompare(b.filePath));\n              expect(results.length).toBe(1);\n              const {\n                filePath,\n                matches\n              } = results[0];\n              expect(filePath).toBe(atom.project.getDirectories()[0].resolve('file-with-newline-literal'));\n              expect(matches).toHaveLength(3);\n              expect(matches[0]).toEqual({\n                matchText: 'line1\\nne',\n                lineText: 'newline1\\nnewline2',\n                lineTextOffset: 0,\n                range: [[0, 3], [1, 2]],\n                leadingContextLines: [],\n                trailingContextLines: []\n              });\n              expect(matches[1]).toEqual({\n                matchText: 'line2\\nne',\n                lineText: 'newline2\\nnewline3',\n                lineTextOffset: 0,\n                range: [[1, 3], [2, 2]],\n                leadingContextLines: [],\n                trailingContextLines: []\n              });\n              expect(matches[2]).toEqual({\n                matchText: 'line4\\nne',\n                lineText: 'newline4\\nnewline5',\n                lineTextOffset: 0,\n                range: [[5, 3], [6, 2]],\n                leadingContextLines: [],\n                trailingContextLines: []\n              });\n            });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "works with escaped newlines",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "newlines on regexps"
            ],
            "updatePoint": {
                "line": 2112,
                "column": 43
            },
            "line": 2112,
            "code": "            it('works with escaped newlines', async () => {\n              const results = [];\n              await scan(/second\\\\nthird/, {}, result => results.push(result));\n              expect(results.length).toBe(1);\n              const {\n                filePath,\n                matches\n              } = results[0];\n              expect(filePath).toBe(atom.project.getDirectories()[0].resolve('file-with-newline-literal'));\n              expect(matches).toHaveLength(1);\n              expect(matches[0]).toEqual({\n                matchText: 'second\\\\nthird',\n                lineText: 'second\\\\nthird',\n                lineTextOffset: 0,\n                range: [[4, 0], [4, 13]],\n                leadingContextLines: [],\n                trailingContextLines: []\n              });\n            });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "matches a regexp ending with a newline",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "newlines on regexps"
            ],
            "updatePoint": {
                "line": 2131,
                "column": 54
            },
            "line": 2131,
            "code": "            it('matches a regexp ending with a newline', async () => {\n              const results = [];\n              await scan(/newline3\\n/, {}, result => results.push(result));\n              expect(results.length).toBe(1);\n              const {\n                filePath,\n                matches\n              } = results[0];\n              expect(filePath).toBe(atom.project.getDirectories()[0].resolve('file-with-newline-literal'));\n              expect(matches).toHaveLength(1);\n              expect(matches[0]).toEqual({\n                matchText: 'newline3\\n',\n                lineText: 'newline3',\n                lineTextOffset: 0,\n                range: [[2, 0], [3, 0]],\n                leadingContextLines: [],\n                trailingContextLines: []\n              });\n            });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "supports lookbehind searches",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "pcre2 enabled"
            ],
            "updatePoint": {
                "line": 2152,
                "column": 44
            },
            "line": 2152,
            "code": "            it('supports lookbehind searches', async () => {\n              const results = [];\n              await scan(/(?<!a)aa\\b/, {\n                PCRE2: true\n              }, result => results.push(result));\n              expect(results.length).toBe(1);\n              const {\n                filePath,\n                matches\n              } = results[0];\n              expect(filePath).toBe(atom.project.getDirectories()[0].resolve('a'));\n              expect(matches).toHaveLength(1);\n              expect(matches[0]).toEqual({\n                matchText: 'aa',\n                lineText: 'cc aa cc',\n                lineTextOffset: 0,\n                range: [[1, 3], [1, 5]],\n                leadingContextLines: [],\n                trailingContextLines: []\n              });\n            });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns results on lines with unicode strings",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "pcre2 enabled"
            ],
            "updatePoint": {
                "line": 2176,
                "column": 57
            },
            "line": 2176,
            "code": "        it('returns results on lines with unicode strings', async () => {\n          const results = [];\n          await scan(/line with unico/, {}, result => results.push(result));\n          expect(results.length).toBe(1);\n          const {\n            filePath,\n            matches\n          } = results[0];\n          expect(filePath).toBe(atom.project.getDirectories()[0].resolve('file-with-unicode'));\n          expect(matches).toHaveLength(1);\n          expect(matches[0]).toEqual({\n            matchText: 'line with unico',\n            lineText: 'ДДДДДДДДДДДДДДДДДД line with unicode',\n            lineTextOffset: 0,\n            range: [[0, 19], [0, 34]],\n            leadingContextLines: [],\n            trailingContextLines: []\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns results on files detected as binary",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "pcre2 enabled"
            ],
            "updatePoint": {
                "line": 2195,
                "column": 55
            },
            "line": 2195,
            "code": "        it('returns results on files detected as binary', async () => {\n          const results = [];\n          await scan(/asciiProperty=Foo/, {\n            trailingContextLineCount: 2\n          }, result => results.push(result));\n          expect(results.length).toBe(1);\n          const {\n            filePath,\n            matches\n          } = results[0];\n          expect(filePath).toBe(atom.project.getDirectories()[0].resolve('file-detected-as-binary'));\n          expect(matches).toHaveLength(1);\n          expect(matches[0]).toEqual({\n            matchText: 'asciiProperty=Foo',\n            lineText: 'asciiProperty=Foo',\n            lineTextOffset: 0,\n            range: [[0, 0], [0, 17]],\n            leadingContextLines: [],\n            trailingContextLines: ['utf8Property=Fòò', 'latin1Property=F��']\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "excludes ignored files when core.excludeVcsIgnoredPaths is true",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when the core.excludeVcsIgnoredPaths config is used"
            ],
            "updatePoint": {
                "line": 2237,
                "column": 77
            },
            "line": 2237,
            "code": "          it('excludes ignored files when core.excludeVcsIgnoredPaths is true', async () => {\n            atom.project.setPaths([projectPath]);\n            atom.config.set('core.excludeVcsIgnoredPaths', true);\n            const resultHandler = jasmine.createSpy('result found');\n            await scan(/match/, {}, ({\n              filePath\n            }) => resultHandler(filePath));\n            expect(resultHandler).not.toHaveBeenCalled();\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not exclude ignored files when core.excludeVcsIgnoredPaths is false",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when the core.excludeVcsIgnoredPaths config is used"
            ],
            "updatePoint": {
                "line": 2246,
                "column": 86
            },
            "line": 2246,
            "code": "          it('does not exclude ignored files when core.excludeVcsIgnoredPaths is false', async () => {\n            atom.project.setPaths([projectPath]);\n            atom.config.set('core.excludeVcsIgnoredPaths', false);\n            const resultHandler = jasmine.createSpy('result found');\n            await scan(/match/, {}, ({\n              filePath\n            }) => resultHandler(filePath));\n            expect(resultHandler).toHaveBeenCalledWith(path.join(projectPath, 'ignored.txt'));\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not exclude files when searching on an ignored folder even when core.excludeVcsIgnoredPaths is true",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when the core.excludeVcsIgnoredPaths config is used"
            ],
            "updatePoint": {
                "line": 2255,
                "column": 118
            },
            "line": 2255,
            "code": "          it('does not exclude files when searching on an ignored folder even when core.excludeVcsIgnoredPaths is true', async () => {\n            fs.mkdirSync(path.join(projectPath, 'poop'));\n            ignoredPath = path.join(path.join(projectPath, 'poop', 'whatever.txt'));\n            fs.writeFileSync(ignoredPath, 'this match should be included');\n            atom.project.setPaths([projectPath]);\n            atom.config.set('core.excludeVcsIgnoredPaths', true);\n            const resultHandler = jasmine.createSpy('result found');\n            await scan(/match/, {\n              paths: ['poop']\n            }, ({\n              filePath\n            }) => resultHandler(filePath));\n            expect(resultHandler).toHaveBeenCalledWith(ignoredPath);\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "follows symlinks when core.followSymlinks is true",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when the core.followSymlinks config is used"
            ],
            "updatePoint": {
                "line": 2288,
                "column": 63
            },
            "line": 2288,
            "code": "          it('follows symlinks when core.followSymlinks is true', async () => {\n            atom.project.setPaths([projectPath]);\n            atom.config.set('core.followSymlinks', true);\n            const resultHandler = jasmine.createSpy('result found');\n            await scan(/ccc/, {}, ({\n              filePath\n            }) => resultHandler(filePath));\n            expect(resultHandler).toHaveBeenCalledWith(path.join(projectPath, 'symlink'));\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not follow symlinks when core.followSymlinks is false",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when the core.followSymlinks config is used"
            ],
            "updatePoint": {
                "line": 2297,
                "column": 72
            },
            "line": 2297,
            "code": "          it('does not follow symlinks when core.followSymlinks is false', async () => {\n            atom.project.setPaths([projectPath]);\n            atom.config.set('core.followSymlinks', false);\n            const resultHandler = jasmine.createSpy('result found');\n            await scan(/ccc/, {}, ({\n              filePath\n            }) => resultHandler(filePath));\n            expect(resultHandler).not.toHaveBeenCalled();\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "searches on hidden files",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when there are hidden files"
            ],
            "updatePoint": {
                "line": 2328,
                "column": 38
            },
            "line": 2328,
            "code": "          it('searches on hidden files', async () => {\n            atom.project.setPaths([projectPath]);\n            const resultHandler = jasmine.createSpy('result found');\n            await scan(/ccc/, {}, ({\n              filePath\n            }) => resultHandler(filePath));\n            expect(resultHandler).toHaveBeenCalledWith(path.join(projectPath, '.hidden'));\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes only files when a directory filter is specified",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when there are hidden files"
            ],
            "updatePoint": {
                "line": 2337,
                "column": 68
            },
            "line": 2337,
            "code": "        it('includes only files when a directory filter is specified', async () => {\n          const projectPath = path.join(path.join(__dirname, 'fixtures', 'dir'));\n          atom.project.setPaths([projectPath]);\n          const filePath = path.join(projectPath, 'a-dir', 'oh-git');\n          const paths = [];\n          let matches = [];\n          await scan(/aaa/, {\n            paths: [`a-dir${path.sep}`]\n          }, result => {\n            paths.push(result.filePath);\n            matches = matches.concat(result.matches);\n          });\n          expect(paths.length).toBe(1);\n          expect(paths[0]).toBe(filePath);\n          expect(matches.length).toBe(1);\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "includes files and folders that begin with a '.'",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when there are hidden files"
            ],
            "updatePoint": {
                "line": 2353,
                "column": 60
            },
            "line": 2353,
            "code": "        it(\"includes files and folders that begin with a '.'\", async () => {\n          const projectPath = temp.mkdirSync('atom-spec-workspace');\n          const filePath = path.join(projectPath, '.text');\n          fs.writeFileSync(filePath, 'match this');\n          atom.project.setPaths([projectPath]);\n          const paths = [];\n          let matches = [];\n          await scan(/match this/, {}, result => {\n            paths.push(result.filePath);\n            matches = matches.concat(result.matches);\n          });\n          expect(paths.length).toBe(1);\n          expect(paths[0]).toBe(filePath);\n          expect(matches.length).toBe(1);\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "excludes values in core.ignoredNames",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when there are hidden files"
            ],
            "updatePoint": {
                "line": 2368,
                "column": 48
            },
            "line": 2368,
            "code": "        it('excludes values in core.ignoredNames', async () => {\n          const ignoredNames = atom.config.get('core.ignoredNames');\n          ignoredNames.push('a');\n          atom.config.set('core.ignoredNames', ignoredNames);\n          const resultHandler = jasmine.createSpy('result found');\n          await scan(/dollar/, {}, () => resultHandler());\n          expect(resultHandler).not.toHaveBeenCalled();\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "scans buffer contents if the buffer is modified",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when there are hidden files"
            ],
            "updatePoint": {
                "line": 2376,
                "column": 59
            },
            "line": 2376,
            "code": "        it('scans buffer contents if the buffer is modified', async () => {\n          const results = [];\n          const editor = await atom.workspace.open('a');\n          editor.setText('Elephant');\n          await scan(/a|Elephant/, {}, result => results.push(result));\n          expect(results.length).toBeGreaterThan(0);\n\n          const resultForA = _.find(results, ({\n            filePath\n          }) => path.basename(filePath) === 'a');\n\n          expect(resultForA.matches).toHaveLength(1);\n          expect(resultForA.matches[0].matchText).toBe('Elephant');\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "ignores buffers outside the project",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when there are hidden files"
            ],
            "updatePoint": {
                "line": 2390,
                "column": 47
            },
            "line": 2390,
            "code": "        it('ignores buffers outside the project', async () => {\n          const results = [];\n          const editor = await atom.workspace.open(temp.openSync().path);\n          editor.setText('Elephant');\n          await scan(/Elephant/, {}, result => results.push(result));\n          expect(results).toHaveLength(0);\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "searches matching files in all of the project's root directories",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when the project has multiple root directories"
            ],
            "updatePoint": {
                "line": 2412,
                "column": 78
            },
            "line": 2412,
            "code": "          it(\"searches matching files in all of the project's root directories\", async () => {\n            const resultPaths = [];\n            await scan(/aaaa/, {}, ({\n              filePath\n            }) => resultPaths.push(filePath));\n            expect(resultPaths.sort()).toEqual([file1, file2].sort());\n          });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "interprets the inclusion path as starting from that directory",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when the project has multiple root directories",
                "when an inclusion path starts with the basename of a root directory"
            ],
            "updatePoint": {
                "line": 2420,
                "column": 77
            },
            "line": 2420,
            "code": "            it('interprets the inclusion path as starting from that directory', async () => {\n              let resultPaths = [];\n              await scan(/aaaa/, {\n                paths: ['dir']\n              }, ({\n                filePath\n              }) => {\n                if (!resultPaths.includes(filePath)) {\n                  resultPaths.push(filePath);\n                }\n              });\n              expect(resultPaths).toEqual([file1]);\n              resultPaths = [];\n              await scan(/aaaa/, {\n                paths: [path.join('dir', 'a-dir')]\n              }, ({\n                filePath\n              }) => {\n                if (!resultPaths.includes(filePath)) {\n                  resultPaths.push(filePath);\n                }\n              });\n              expect(resultPaths).toEqual([file1]);\n              resultPaths = [];\n              await scan(/aaaa/, {\n                paths: [path.basename(dir2)]\n              }, ({\n                filePath\n              }) => {\n                if (!resultPaths.includes(filePath)) {\n                  resultPaths.push(filePath);\n                }\n              });\n              expect(resultPaths).toEqual([file2]);\n              resultPaths = [];\n              await scan(/aaaa/, {\n                paths: [path.join(path.basename(dir2), 'a-dir')]\n              }, ({\n                filePath\n              }) => {\n                if (!resultPaths.includes(filePath)) {\n                  resultPaths.push(filePath);\n                }\n              });\n              expect(resultPaths).toEqual([file2]);\n            });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can override the DefaultDirectorySearcher on a per-directory basis",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when the project has multiple root directories",
                "when a custom directory searcher is registered"
            ],
            "updatePoint": {
                "line": 2515,
                "column": 82
            },
            "line": 2515,
            "code": "            it('can override the DefaultDirectorySearcher on a per-directory basis', async () => {\n              const foreignFilePath = 'ssh://foreign-directory:8080/hello.txt';\n              const numPathsSearchedInDir2 = 1;\n              const numPathsToPretendToSearchInCustomDirectorySearcher = 10;\n              const searchResult = {\n                filePath: foreignFilePath,\n                matches: [{\n                  lineText: 'Hello world',\n                  lineTextOffset: 0,\n                  matchText: 'Hello',\n                  range: [[0, 0], [0, 5]]\n                }]\n              };\n\n              onFakeSearchCreated = fakeSearch => {\n                fakeSearch.options.didMatch(searchResult);\n                fakeSearch.options.didSearchPaths(numPathsToPretendToSearchInCustomDirectorySearcher);\n                fakeSearch.hoistedResolve();\n              };\n\n              const resultPaths = [];\n              const onPathsSearched = jasmine.createSpy('onPathsSearched');\n              await scan(/aaaa/, {\n                onPathsSearched\n              }, ({\n                filePath\n              }) => resultPaths.push(filePath));\n              expect(resultPaths.sort()).toEqual([foreignFilePath, file2].sort()); // onPathsSearched should be called once by each DirectorySearcher. The order is not\n              // guaranteed, so we can only verify the total number of paths searched is correct\n              // after the second call.\n\n              expect(onPathsSearched.callCount).toBe(2);\n              expect(onPathsSearched.mostRecentCall.args[0]).toBe(numPathsToPretendToSearchInCustomDirectorySearcher + numPathsSearchedInDir2);\n            });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "can be cancelled when the object returned by scan() has its cancel() method invoked",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when the project has multiple root directories",
                "when a custom directory searcher is registered"
            ],
            "updatePoint": {
                "line": 2549,
                "column": 99
            },
            "line": 2549,
            "code": "            it('can be cancelled when the object returned by scan() has its cancel() method invoked', async () => {\n              const thenable = scan(/aaaa/, {}, () => {});\n              let resultOfPromiseSearch = null;\n              waitsFor('fakeSearch to be defined', () => fakeSearch != null);\n              runs(() => {\n                expect(fakeSearch.cancelled).toBe(undefined);\n                thenable.cancel();\n                expect(fakeSearch.cancelled).toBe(true);\n              });\n              waitsForPromise(() => thenable.then(promiseResult => {\n                resultOfPromiseSearch = promiseResult;\n              }));\n              runs(() => expect(resultOfPromiseSearch).toBe('cancelled'));\n            });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "will have the side-effect of failing the overall search if it fails",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "when called with a regex",
                "when the project has multiple root directories",
                "when a custom directory searcher is registered"
            ],
            "updatePoint": {
                "line": 2563,
                "column": 83
            },
            "line": 2563,
            "code": "            it('will have the side-effect of failing the overall search if it fails', () => {\n              // This provider's search should be cancelled when the first provider fails\n              let cancelableSearch;\n              let fakeSearch2 = null;\n              atom.packages.serviceHub.provide('atom.directory-searcher', '0.1.0', {\n                canSearchDirectory(directory) {\n                  return directory.getPath() === dir2;\n                },\n\n                search(directory, regex, options) {\n                  fakeSearch2 = new FakeSearch(options);\n                  return fakeSearch2;\n                }\n\n              });\n              let didReject = false;\n              const promise = cancelableSearch = scan(/aaaa/, () => {});\n              waitsFor('fakeSearch to be defined', () => fakeSearch != null);\n              runs(() => fakeSearch.hoistedReject());\n              waitsForPromise(() => cancelableSearch.catch(() => {\n                didReject = true;\n              }));\n              waitsFor(done => promise.then(null, done));\n              runs(() => {\n                expect(didReject).toBe(true);\n                expect(fakeSearch2.cancelled).toBe(true);\n              });\n            });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns valid contexts no matter how many lines are requested",
            "suites": [
                "Workspace",
                "::scan(regex, options, callback) { ripgrep:  }",
                "leadingContextLineCount and trailingContextLineCount options"
            ],
            "updatePoint": {
                "line": 2612,
                "column": 73
            },
            "line": 2612,
            "code": "        it('returns valid contexts no matter how many lines are requested', async () => {\n          expect(await search({})).toEqual({\n            leadingContext: [[], [], [], []],\n            trailingContext: [[], [], [], []]\n          });\n          expect(await search({\n            leadingContextLineCount: 1,\n            trailingContextLineCount: 1\n          })).toEqual({\n            leadingContext: expectedLeadingContext.map(result => result.slice(-1)),\n            trailingContext: expectedTrailingContext.map(result => result.slice(0, 1))\n          });\n          expect(await search({\n            leadingContextLineCount: 2,\n            trailingContextLineCount: 2\n          })).toEqual({\n            leadingContext: expectedLeadingContext.map(result => result.slice(-2)),\n            trailingContext: expectedTrailingContext.map(result => result.slice(0, 2))\n          });\n          expect(await search({\n            leadingContextLineCount: 5,\n            trailingContextLineCount: 5\n          })).toEqual({\n            leadingContext: expectedLeadingContext.map(result => result.slice(-5)),\n            trailingContext: expectedTrailingContext.map(result => result.slice(0, 5))\n          });\n          expect(await search({\n            leadingContextLineCount: 2,\n            trailingContextLineCount: 3\n          })).toEqual({\n            leadingContext: expectedLeadingContext.map(result => result.slice(-2)),\n            trailingContext: expectedTrailingContext.map(result => result.slice(0, 3))\n          });\n        });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "calls back with an error",
            "suites": [
                "Workspace",
                "::replace(regex, replacementText, paths, iterator)",
                "when a file doesn't exist"
            ],
            "updatePoint": {
                "line": 2658,
                "column": 34
            },
            "line": 2658,
            "code": "      it('calls back with an error', () => {\n        const errors = [];\n        const missingPath = path.resolve('/not-a-file.js');\n        expect(fs.existsSync(missingPath)).toBeFalsy();\n        waitsForPromise(() => atom.workspace.replace(/items/gi, 'items', [missingPath], (result, error) => errors.push(error)));\n        runs(() => {\n          expect(errors).toHaveLength(1);\n          expect(errors[0].path).toBe(missingPath);\n        });\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces properly",
            "suites": [
                "Workspace",
                "::replace(regex, replacementText, paths, iterator)",
                "when called with unopened files"
            ],
            "updatePoint": {
                "line": 2670,
                "column": 27
            },
            "line": 2670,
            "code": "      it('replaces properly', () => {\n        const filePath = path.join(projectDir, 'sample.js');\n        fs.copyFileSync(path.join(fixturesDir, 'sample.js'), filePath);\n        const results = [];\n        waitsForPromise(() => atom.workspace.replace(/items/gi, 'items', [filePath], result => results.push(result)));\n        runs(() => {\n          expect(results).toHaveLength(1);\n          expect(results[0].filePath).toBe(filePath);\n          expect(results[0].replacements).toBe(6);\n        });\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not discard the multiline flag",
            "suites": [
                "Workspace",
                "::replace(regex, replacementText, paths, iterator)",
                "when called with unopened files"
            ],
            "updatePoint": {
                "line": 2681,
                "column": 45
            },
            "line": 2681,
            "code": "      it('does not discard the multiline flag', () => {\n        const filePath = path.join(projectDir, 'sample.js');\n        fs.copyFileSync(path.join(fixturesDir, 'sample.js'), filePath);\n        const results = [];\n        waitsForPromise(() => atom.workspace.replace(/;$/gim, 'items', [filePath], result => results.push(result)));\n        runs(() => {\n          expect(results).toHaveLength(1);\n          expect(results[0].filePath).toBe(filePath);\n          expect(results[0].replacements).toBe(8);\n        });\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "replaces properly and saves when not modified",
            "suites": [
                "Workspace",
                "::replace(regex, replacementText, paths, iterator)",
                "when a buffer is already open"
            ],
            "updatePoint": {
                "line": 2694,
                "column": 55
            },
            "line": 2694,
            "code": "      it('replaces properly and saves when not modified', () => {\n        const filePath = path.join(projectDir, 'sample.js');\n        fs.copyFileSync(path.join(fixturesDir, 'sample.js'), path.join(projectDir, 'sample.js'));\n        let editor = null;\n        const results = [];\n        waitsForPromise(() => atom.workspace.open('sample.js').then(o => {\n          editor = o;\n        }));\n        runs(() => expect(editor.isModified()).toBeFalsy());\n        waitsForPromise(() => atom.workspace.replace(/items/gi, 'items', [filePath], result => results.push(result)));\n        runs(() => {\n          expect(results).toHaveLength(1);\n          expect(results[0].filePath).toBe(filePath);\n          expect(results[0].replacements).toBe(6);\n          expect(editor.isModified()).toBeFalsy();\n        });\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not replace when the path is not specified",
            "suites": [
                "Workspace",
                "::replace(regex, replacementText, paths, iterator)",
                "when a buffer is already open"
            ],
            "updatePoint": {
                "line": 2711,
                "column": 57
            },
            "line": 2711,
            "code": "      it('does not replace when the path is not specified', () => {\n        const filePath = path.join(projectDir, 'sample.js');\n        const commentFilePath = path.join(projectDir, 'sample-with-comments.js');\n        fs.copyFileSync(path.join(fixturesDir, 'sample.js'), filePath);\n        fs.copyFileSync(path.join(fixturesDir, 'sample-with-comments.js'), path.join(projectDir, 'sample-with-comments.js'));\n        const results = [];\n        waitsForPromise(() => atom.workspace.open('sample-with-comments.js'));\n        waitsForPromise(() => atom.workspace.replace(/items/gi, 'items', [commentFilePath], result => results.push(result)));\n        runs(() => {\n          expect(results).toHaveLength(1);\n          expect(results[0].filePath).toBe(commentFilePath);\n        });\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does NOT save when modified",
            "suites": [
                "Workspace",
                "::replace(regex, replacementText, paths, iterator)",
                "when a buffer is already open"
            ],
            "updatePoint": {
                "line": 2724,
                "column": 37
            },
            "line": 2724,
            "code": "      it('does NOT save when modified', () => {\n        const filePath = path.join(projectDir, 'sample.js');\n        fs.copyFileSync(path.join(fixturesDir, 'sample.js'), filePath);\n        let editor = null;\n        const results = [];\n        waitsForPromise(() => atom.workspace.open('sample.js').then(o => {\n          editor = o;\n        }));\n        runs(() => {\n          editor.buffer.setTextInRange([[0, 0], [0, 0]], 'omg');\n          expect(editor.isModified()).toBeTruthy();\n        });\n        waitsForPromise(() => atom.workspace.replace(/items/gi, 'okthen', [filePath], result => results.push(result)));\n        runs(() => {\n          expect(results).toHaveLength(1);\n          expect(results[0].filePath).toBe(filePath);\n          expect(results[0].replacements).toBe(6);\n          expect(editor.isModified()).toBeTruthy();\n        });\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a warning notification when the file cannot be saved",
            "suites": [
                "Workspace",
                "::saveActivePaneItem()",
                "when there is an error"
            ],
            "updatePoint": {
                "line": 2756,
                "column": 68
            },
            "line": 2756,
            "code": "      it('emits a warning notification when the file cannot be saved', () => {\n        spyOn(editor, 'save').andCallFake(() => {\n          throw new Error(\"'/some/file' is a directory\");\n        });\n        waitsForPromise(() => atom.workspace.saveActivePaneItem().then(() => {\n          expect(notificationSpy).toHaveBeenCalled();\n          expect(notificationSpy.mostRecentCall.args[0].getType()).toBe('warning');\n          expect(notificationSpy.mostRecentCall.args[0].getMessage()).toContain('Unable to save');\n        }));\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a warning notification when the directory cannot be written to",
            "suites": [
                "Workspace",
                "::saveActivePaneItem()",
                "when there is an error"
            ],
            "updatePoint": {
                "line": 2766,
                "column": 78
            },
            "line": 2766,
            "code": "      it('emits a warning notification when the directory cannot be written to', () => {\n        spyOn(editor, 'save').andCallFake(() => {\n          throw new Error(\"ENOTDIR, not a directory '/Some/dir/and-a-file.js'\");\n        });\n        waitsForPromise(() => atom.workspace.saveActivePaneItem().then(() => {\n          expect(notificationSpy).toHaveBeenCalled();\n          expect(notificationSpy.mostRecentCall.args[0].getType()).toBe('warning');\n          expect(notificationSpy.mostRecentCall.args[0].getMessage()).toContain('Unable to save');\n        }));\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a warning notification when the user does not have permission",
            "suites": [
                "Workspace",
                "::saveActivePaneItem()",
                "when there is an error"
            ],
            "updatePoint": {
                "line": 2776,
                "column": 77
            },
            "line": 2776,
            "code": "      it('emits a warning notification when the user does not have permission', () => {\n        spyOn(editor, 'save').andCallFake(() => {\n          const error = new Error(\"EACCES, permission denied '/Some/dir/and-a-file.js'\");\n          error.code = 'EACCES';\n          error.path = '/Some/dir/and-a-file.js';\n          throw error;\n        });\n        waitsForPromise(() => atom.workspace.saveActivePaneItem().then(() => {\n          expect(notificationSpy).toHaveBeenCalled();\n          expect(notificationSpy.mostRecentCall.args[0].getType()).toBe('warning');\n          expect(notificationSpy.mostRecentCall.args[0].getMessage()).toContain('Unable to save');\n        }));\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a warning notification when the operation is not permitted",
            "suites": [
                "Workspace",
                "::saveActivePaneItem()",
                "when there is an error"
            ],
            "updatePoint": {
                "line": 2789,
                "column": 74
            },
            "line": 2789,
            "code": "      it('emits a warning notification when the operation is not permitted', () => {\n        spyOn(editor, 'save').andCallFake(() => {\n          const error = new Error(\"EPERM, operation not permitted '/Some/dir/and-a-file.js'\");\n          error.code = 'EPERM';\n          error.path = '/Some/dir/and-a-file.js';\n          throw error;\n        });\n        waitsForPromise(() => atom.workspace.saveActivePaneItem().then(() => {\n          expect(notificationSpy).toHaveBeenCalled();\n          expect(notificationSpy.mostRecentCall.args[0].getType()).toBe('warning');\n          expect(notificationSpy.mostRecentCall.args[0].getMessage()).toContain('Unable to save');\n        }));\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a warning notification when the file is already open by another app",
            "suites": [
                "Workspace",
                "::saveActivePaneItem()",
                "when there is an error"
            ],
            "updatePoint": {
                "line": 2802,
                "column": 83
            },
            "line": 2802,
            "code": "      it('emits a warning notification when the file is already open by another app', () => {\n        spyOn(editor, 'save').andCallFake(() => {\n          const error = new Error(\"EBUSY, resource busy or locked '/Some/dir/and-a-file.js'\");\n          error.code = 'EBUSY';\n          error.path = '/Some/dir/and-a-file.js';\n          throw error;\n        });\n        waitsForPromise(() => atom.workspace.saveActivePaneItem().then(() => {\n          expect(notificationSpy).toHaveBeenCalled();\n          expect(notificationSpy.mostRecentCall.args[0].getType()).toBe('warning');\n          expect(notificationSpy.mostRecentCall.args[0].getMessage()).toContain('Unable to save');\n        }));\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a warning notification when the file system is read-only",
            "suites": [
                "Workspace",
                "::saveActivePaneItem()",
                "when there is an error"
            ],
            "updatePoint": {
                "line": 2815,
                "column": 72
            },
            "line": 2815,
            "code": "      it('emits a warning notification when the file system is read-only', () => {\n        spyOn(editor, 'save').andCallFake(() => {\n          const error = new Error(\"EROFS, read-only file system '/Some/dir/and-a-file.js'\");\n          error.code = 'EROFS';\n          error.path = '/Some/dir/and-a-file.js';\n          throw error;\n        });\n        waitsForPromise(() => atom.workspace.saveActivePaneItem().then(() => {\n          expect(notificationSpy).toHaveBeenCalled();\n          expect(notificationSpy.mostRecentCall.args[0].getType()).toBe('warning');\n          expect(notificationSpy.mostRecentCall.args[0].getMessage()).toContain('Unable to save');\n        }));\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "emits a warning notification when the file cannot be saved",
            "suites": [
                "Workspace",
                "::saveActivePaneItem()",
                "when there is an error"
            ],
            "updatePoint": {
                "line": 2828,
                "column": 68
            },
            "line": 2828,
            "code": "      it('emits a warning notification when the file cannot be saved', () => {\n        spyOn(editor, 'save').andCallFake(() => {\n          throw new Error('no one knows');\n        });\n        waitsForPromise({\n          shouldReject: true\n        }, () => atom.workspace.saveActivePaneItem());\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "closes the active center pane item, or the active center pane if it is empty, or the current window if there is only the empty root pane in the center",
            "suites": [
                "Workspace",
                "::closeActivePaneItemOrEmptyPaneOrWindow"
            ],
            "updatePoint": {
                "line": 2843,
                "column": 158
            },
            "line": 2843,
            "code": "    it('closes the active center pane item, or the active center pane if it is empty, or the current window if there is only the empty root pane in the center', async () => {\n      atom.config.set('core.destroyEmptyPanes', false);\n      const pane1 = atom.workspace.getActivePane();\n      const pane2 = pane1.splitRight({\n        copyActiveItem: true\n      });\n      expect(atom.workspace.getCenter().getPanes().length).toBe(2);\n      expect(pane2.getItems().length).toBe(1);\n      atom.workspace.closeActivePaneItemOrEmptyPaneOrWindow();\n      expect(atom.workspace.getCenter().getPanes().length).toBe(2);\n      expect(pane2.getItems().length).toBe(0);\n      atom.workspace.closeActivePaneItemOrEmptyPaneOrWindow();\n      expect(atom.workspace.getCenter().getPanes().length).toBe(1);\n      expect(pane1.getItems().length).toBe(1);\n      atom.workspace.closeActivePaneItemOrEmptyPaneOrWindow();\n      expect(atom.workspace.getCenter().getPanes().length).toBe(1);\n      expect(pane1.getItems().length).toBe(0);\n      expect(atom.workspace.getCenter().getPanes().length).toBe(1); // The dock items should not be closed\n\n      await atom.workspace.open({\n        getTitle: () => 'Permanent Dock Item',\n        element: document.createElement('div'),\n        getDefaultLocation: () => 'left',\n        isPermanentDockItem: () => true\n      });\n      await atom.workspace.open({\n        getTitle: () => 'Impermanent Dock Item',\n        element: document.createElement('div'),\n        getDefaultLocation: () => 'left'\n      });\n      expect(atom.workspace.getLeftDock().getPaneItems().length).toBe(2);\n      atom.workspace.closeActivePaneItemOrEmptyPaneOrWindow();\n      expect(atom.close).toHaveBeenCalled();\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the next pane in the dock",
            "suites": [
                "Workspace",
                "::activateNextPane",
                "when the active workspace pane is inside a dock"
            ],
            "updatePoint": {
                "line": 2880,
                "column": 45
            },
            "line": 2880,
            "code": "      it('activates the next pane in the dock', () => {\n        const dock = atom.workspace.getLeftDock();\n        const dockPane1 = dock.getPanes()[0];\n        const dockPane2 = dockPane1.splitRight();\n        dockPane2.focus();\n        expect(atom.workspace.getActivePane()).toBe(dockPane2);\n        atom.workspace.activateNextPane();\n        expect(atom.workspace.getActivePane()).toBe(dockPane1);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the next pane in the workspace center",
            "suites": [
                "Workspace",
                "::activateNextPane",
                "when the active workspace pane is inside the workspace center"
            ],
            "updatePoint": {
                "line": 2891,
                "column": 57
            },
            "line": 2891,
            "code": "      it('activates the next pane in the workspace center', () => {\n        const center = atom.workspace.getCenter();\n        const centerPane1 = center.getPanes()[0];\n        const centerPane2 = centerPane1.splitRight();\n        centerPane2.focus();\n        expect(atom.workspace.getActivePane()).toBe(centerPane2);\n        atom.workspace.activateNextPane();\n        expect(atom.workspace.getActivePane()).toBe(centerPane1);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the previous pane in the dock",
            "suites": [
                "Workspace",
                "::activatePreviousPane",
                "when the active workspace pane is inside a dock"
            ],
            "updatePoint": {
                "line": 2904,
                "column": 49
            },
            "line": 2904,
            "code": "      it('activates the previous pane in the dock', () => {\n        const dock = atom.workspace.getLeftDock();\n        const dockPane1 = dock.getPanes()[0];\n        const dockPane2 = dockPane1.splitRight();\n        dockPane1.focus();\n        expect(atom.workspace.getActivePane()).toBe(dockPane1);\n        atom.workspace.activatePreviousPane();\n        expect(atom.workspace.getActivePane()).toBe(dockPane2);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "activates the previous pane in the workspace center",
            "suites": [
                "Workspace",
                "::activatePreviousPane",
                "when the active workspace pane is inside the workspace center"
            ],
            "updatePoint": {
                "line": 2915,
                "column": 61
            },
            "line": 2915,
            "code": "      it('activates the previous pane in the workspace center', () => {\n        const center = atom.workspace.getCenter();\n        const centerPane1 = center.getPanes()[0];\n        const centerPane2 = centerPane1.splitRight();\n        centerPane1.focus();\n        expect(atom.workspace.getActivePane()).toBe(centerPane1);\n        atom.workspace.activatePreviousPane();\n        expect(atom.workspace.getActivePane()).toBe(centerPane2);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns all panes in visible pane containers",
            "suites": [
                "Workspace",
                "::getVisiblePanes"
            ],
            "updatePoint": {
                "line": 2927,
                "column": 52
            },
            "line": 2927,
            "code": "    it('returns all panes in visible pane containers', () => {\n      const center = workspace.getCenter();\n      const leftDock = workspace.getLeftDock();\n      const rightDock = workspace.getRightDock();\n      const bottomDock = workspace.getBottomDock();\n      const centerPane = center.getPanes()[0];\n      const leftDockPane = leftDock.getPanes()[0];\n      const rightDockPane = rightDock.getPanes()[0];\n      const bottomDockPane = bottomDock.getPanes()[0];\n      leftDock.hide();\n      rightDock.hide();\n      bottomDock.hide();\n      expect(workspace.getVisiblePanes()).toContain(centerPane);\n      expect(workspace.getVisiblePanes()).not.toContain(leftDockPane);\n      expect(workspace.getVisiblePanes()).not.toContain(rightDockPane);\n      expect(workspace.getVisiblePanes()).not.toContain(bottomDockPane);\n      leftDock.show();\n      expect(workspace.getVisiblePanes()).toContain(centerPane);\n      expect(workspace.getVisiblePanes()).toContain(leftDockPane);\n      expect(workspace.getVisiblePanes()).not.toContain(rightDockPane);\n      expect(workspace.getVisiblePanes()).not.toContain(bottomDockPane);\n      rightDock.show();\n      expect(workspace.getVisiblePanes()).toContain(centerPane);\n      expect(workspace.getVisiblePanes()).toContain(leftDockPane);\n      expect(workspace.getVisiblePanes()).toContain(rightDockPane);\n      expect(workspace.getVisiblePanes()).not.toContain(bottomDockPane);\n      bottomDock.show();\n      expect(workspace.getVisiblePanes()).toContain(centerPane);\n      expect(workspace.getVisiblePanes()).toContain(leftDockPane);\n      expect(workspace.getVisiblePanes()).toContain(rightDockPane);\n      expect(workspace.getVisiblePanes()).toContain(bottomDockPane);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "returns all visible pane containers",
            "suites": [
                "Workspace",
                "::getVisiblePaneContainers"
            ],
            "updatePoint": {
                "line": 2961,
                "column": 43
            },
            "line": 2961,
            "code": "    it('returns all visible pane containers', () => {\n      const center = workspace.getCenter();\n      const leftDock = workspace.getLeftDock();\n      const rightDock = workspace.getRightDock();\n      const bottomDock = workspace.getBottomDock();\n      leftDock.hide();\n      rightDock.hide();\n      bottomDock.hide();\n      expect(workspace.getVisiblePaneContainers()).toEqual([center]);\n      leftDock.show();\n      expect(workspace.getVisiblePaneContainers().sort()).toEqual([center, leftDock]);\n      rightDock.show();\n      expect(workspace.getVisiblePaneContainers().sort()).toEqual([center, leftDock, rightDock]);\n      bottomDock.show();\n      expect(workspace.getVisiblePaneContainers().sort()).toEqual([center, leftDock, rightDock, bottomDock]);\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "does not open item with `pending: true` option as pending",
            "suites": [
                "Workspace",
                "when the core.allowPendingPaneItems option is falsy"
            ],
            "updatePoint": {
                "line": 2979,
                "column": 65
            },
            "line": 2979,
            "code": "    it('does not open item with `pending: true` option as pending', () => {\n      let pane = null;\n      atom.config.set('core.allowPendingPaneItems', false);\n      waitsForPromise(() => atom.workspace.open('sample.js', {\n        pending: true\n      }).then(() => {\n        pane = atom.workspace.getActivePane();\n      }));\n      runs(() => expect(pane.getPendingItem()).toBeFalsy());\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "notifies the workspace of which grammar is used",
            "suites": [
                "Workspace",
                "grammar activation"
            ],
            "updatePoint": {
                "line": 2991,
                "column": 55
            },
            "line": 2991,
            "code": "    it('notifies the workspace of which grammar is used', async () => {\n      atom.packages.triggerDeferredActivationHooks();\n      const javascriptGrammarUsed = jasmine.createSpy('js grammar used');\n      const rubyGrammarUsed = jasmine.createSpy('ruby grammar used');\n      const cGrammarUsed = jasmine.createSpy('c grammar used');\n      atom.packages.onDidTriggerActivationHook('language-javascript:grammar-used', javascriptGrammarUsed);\n      atom.packages.onDidTriggerActivationHook('language-ruby:grammar-used', rubyGrammarUsed);\n      atom.packages.onDidTriggerActivationHook('language-c:grammar-used', cGrammarUsed);\n      await atom.packages.activatePackage('language-ruby');\n      await atom.packages.activatePackage('language-javascript');\n      await atom.packages.activatePackage('language-c');\n      await atom.workspace.open('sample-with-comments.js'); // Hooks are triggered when opening new editors\n\n      expect(javascriptGrammarUsed).toHaveBeenCalled(); // Hooks are triggered when changing existing editors grammars\n\n      atom.grammars.assignLanguageMode(atom.workspace.getActiveTextEditor(), 'source.c');\n      expect(cGrammarUsed).toHaveBeenCalled(); // Hooks are triggered when editors are added in other ways.\n\n      atom.workspace.getActivePane().splitRight({\n        copyActiveItem: true\n      });\n      atom.grammars.assignLanguageMode(atom.workspace.getActiveTextEditor(), 'source.ruby');\n      expect(rubyGrammarUsed).toHaveBeenCalled();\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "reverts to the version of its file checked into the project repository",
            "suites": [
                "Workspace",
                ".checkoutHeadRevision()"
            ],
            "updatePoint": {
                "line": 3023,
                "column": 78
            },
            "line": 3023,
            "code": "    it('reverts to the version of its file checked into the project repository', async () => {\n      editor.setCursorBufferPosition([0, 0]);\n      editor.insertText('---\\n');\n      expect(editor.lineTextForBufferRow(0)).toBe('---');\n      atom.workspace.checkoutHeadRevision(editor);\n      await conditionPromise(() => editor.lineTextForBufferRow(0) === '');\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "doesn't do anything",
            "suites": [
                "Workspace",
                ".checkoutHeadRevision()",
                "when there's no repository for the editor's file"
            ],
            "updatePoint": {
                "line": 3031,
                "column": 29
            },
            "line": 3031,
            "code": "      it(\"doesn't do anything\", async () => {\n        editor = new TextEditor();\n        editor.setText('stuff');\n        atom.workspace.checkoutHeadRevision(editor);\n        atom.workspace.checkoutHeadRevision(editor);\n      });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "stores the new location if it's not the default",
            "suites": [
                "Workspace",
                "when an item is moved"
            ],
            "updatePoint": {
                "line": 3047,
                "column": 55
            },
            "line": 3047,
            "code": "    it(\"stores the new location if it's not the default\", () => {\n      const ITEM_URI = 'atom://test';\n      const item = {\n        getURI: () => ITEM_URI,\n        getDefaultLocation: () => 'left',\n        getElement: () => document.createElement('div')\n      };\n      const centerPane = workspace.getActivePane();\n      centerPane.addItem(item);\n      const dockPane = atom.workspace.getRightDock().getActivePane();\n      spyOn(workspace.itemLocationStore, 'save');\n      centerPane.moveItemToPane(item, dockPane);\n      expect(workspace.itemLocationStore.save).toHaveBeenCalledWith(ITEM_URI, 'right');\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "clears the location if it's the default",
            "suites": [
                "Workspace",
                "when an item is moved"
            ],
            "updatePoint": {
                "line": 3061,
                "column": 47
            },
            "line": 3061,
            "code": "    it(\"clears the location if it's the default\", () => {\n      const ITEM_URI = 'atom://test';\n      const item = {\n        getURI: () => ITEM_URI,\n        getDefaultLocation: () => 'right',\n        getElement: () => document.createElement('div')\n      };\n      const centerPane = workspace.getActivePane();\n      centerPane.addItem(item);\n      const dockPane = atom.workspace.getRightDock().getActivePane();\n      spyOn(workspace.itemLocationStore, 'save');\n      spyOn(workspace.itemLocationStore, 'delete');\n      centerPane.moveItemToPane(item, dockPane);\n      expect(workspace.itemLocationStore.delete).toHaveBeenCalledWith(ITEM_URI);\n      expect(workspace.itemLocationStore.save).not.toHaveBeenCalled();\n    });",
            "file": "workspace-spec.js",
            "skipped": false,
            "dir": "spec"
        },
        {
            "name": "deserializes correctly",
            "suites": [
                "About"
            ],
            "updatePoint": {
                "line": 14,
                "column": 28
            },
            "line": 14,
            "code": "  it('deserializes correctly', () => {\n    let deserializedAboutView = atom.deserializers.deserialize({\n      deserializer: 'AboutView',\n      uri: 'atom://about'\n    });\n    expect(deserializedAboutView).toBeTruthy();\n  });",
            "file": "about-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "shows the About Atom view",
            "suites": [
                "About",
                "when the about:about-atom command is triggered"
            ],
            "updatePoint": {
                "line": 22,
                "column": 33
            },
            "line": 22,
            "code": "    it('shows the About Atom view', async () => {\n      // Attaching the workspaceElement to the DOM is required to allow the\n      // `toBeVisible()` matchers to work. Anything testing visibility or focus\n      // requires that the workspaceElement is on the DOM. Tests that attach the\n      // workspaceElement to the DOM are generally slower than those off DOM.\n      jasmine.attachToDOM(workspaceElement);\n      expect(workspaceElement.querySelector('.about')).not.toExist();\n      await atom.workspace.open('atom://about');\n      let aboutElement = workspaceElement.querySelector('.about');\n      expect(aboutElement).toBeVisible();\n    });",
            "file": "about-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "copies the version number to the clipboard",
            "suites": [
                "About",
                "when the Atom version number is clicked"
            ],
            "updatePoint": {
                "line": 35,
                "column": 50
            },
            "line": 35,
            "code": "    it('copies the version number to the clipboard', async () => {\n      await atom.workspace.open('atom://about');\n      jasmine.attachToDOM(workspaceElement);\n      let aboutElement = workspaceElement.querySelector('.about');\n      let versionContainer = aboutElement.querySelector('.atom');\n      versionContainer.click();\n      expect(atom.clipboard.read()).toBe(atom.getVersion());\n    });",
            "file": "about-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "expands to show additional version numbers",
            "suites": [
                "About",
                "when the show more link is clicked"
            ],
            "updatePoint": {
                "line": 45,
                "column": 50
            },
            "line": 45,
            "code": "    it('expands to show additional version numbers', async () => {\n      await atom.workspace.open('atom://about');\n      jasmine.attachToDOM(workspaceElement);\n      let aboutElement = workspaceElement.querySelector('.about');\n      let showMoreElement = aboutElement.querySelector('.show-more-expand');\n      let moreInfoElement = workspaceElement.querySelector('.show-more');\n      showMoreElement.click();\n      expect(moreInfoElement).toBeVisible();\n    });",
            "file": "about-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "copies the version number to the clipboard",
            "suites": [
                "About",
                "when the Electron version number is clicked"
            ],
            "updatePoint": {
                "line": 56,
                "column": 50
            },
            "line": 56,
            "code": "    it('copies the version number to the clipboard', async () => {\n      await atom.workspace.open('atom://about');\n      jasmine.attachToDOM(workspaceElement);\n      let aboutElement = workspaceElement.querySelector('.about');\n      let versionContainer = aboutElement.querySelector('.electron');\n      versionContainer.click();\n      expect(atom.clipboard.read()).toBe(process.versions.electron);\n    });",
            "file": "about-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "copies the version number to the clipboard",
            "suites": [
                "About",
                "when the Chrome version number is clicked"
            ],
            "updatePoint": {
                "line": 66,
                "column": 50
            },
            "line": 66,
            "code": "    it('copies the version number to the clipboard', async () => {\n      await atom.workspace.open('atom://about');\n      jasmine.attachToDOM(workspaceElement);\n      let aboutElement = workspaceElement.querySelector('.about');\n      let versionContainer = aboutElement.querySelector('.chrome');\n      versionContainer.click();\n      expect(atom.clipboard.read()).toBe(process.versions.chrome);\n    });",
            "file": "about-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "copies the version number to the clipboard",
            "suites": [
                "About",
                "when the Node version number is clicked"
            ],
            "updatePoint": {
                "line": 76,
                "column": 50
            },
            "line": 76,
            "code": "    it('copies the version number to the clipboard', async () => {\n      await atom.workspace.open('atom://about');\n      jasmine.attachToDOM(workspaceElement);\n      let aboutElement = workspaceElement.querySelector('.about');\n      let versionContainer = aboutElement.querySelector('.node');\n      versionContainer.click();\n      expect(atom.clipboard.read()).toBe(process.version);\n    });",
            "file": "about-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "does not show the view",
            "suites": [
                "the status bar",
                "on a stable version",
                "with no update"
            ],
            "updatePoint": {
                "line": 36,
                "column": 32
            },
            "line": 36,
            "code": "      it('does not show the view', () => {\n        expect(workspaceElement).not.toContain('.about-release-notes');\n      });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "shows the view when the update finishes downloading",
            "suites": [
                "the status bar",
                "on a stable version",
                "with an update"
            ],
            "updatePoint": {
                "line": 41,
                "column": 61
            },
            "line": 41,
            "code": "      it('shows the view when the update finishes downloading', () => {\n        MockUpdater.finishDownloadingUpdate('42.0.0');\n        expect(workspaceElement).toContain('.about-release-notes');\n      });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "opens the about page",
            "suites": [
                "the status bar",
                "on a stable version",
                "with an update",
                "clicking on the status"
            ],
            "updatePoint": {
                "line": 46,
                "column": 32
            },
            "line": 46,
            "code": "        it('opens the about page', async () => {\n          MockUpdater.finishDownloadingUpdate('42.0.0');\n          workspaceElement.querySelector('.about-release-notes').click();\n          await conditionPromise(() => workspaceElement.querySelector('.about'));\n          expect(workspaceElement.querySelector('.about')).toExist();\n        });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "continues to show the squirrel until Atom is updated to the new version",
            "suites": [
                "the status bar",
                "on a stable version",
                "with an update",
                "clicking on the status"
            ],
            "updatePoint": {
                "line": 53,
                "column": 81
            },
            "line": 53,
            "code": "      it('continues to show the squirrel until Atom is updated to the new version', async () => {\n        MockUpdater.finishDownloadingUpdate('42.0.0');\n        expect(workspaceElement).toContain('.about-release-notes');\n        await atom.packages.deactivatePackage('about');\n        expect(workspaceElement).not.toContain('.about-release-notes');\n        await atom.packages.activatePackage('about');\n        await Promise.resolve(); // Service consumption hooks are deferred until the next tick\n\n        expect(workspaceElement).toContain('.about-release-notes');\n        await atom.packages.deactivatePackage('about');\n        expect(workspaceElement).not.toContain('.about-release-notes');\n        atomVersion = '42.0.0';\n        await atom.packages.activatePackage('about');\n        await Promise.resolve(); // Service consumption hooks are deferred until the next tick\n\n        expect(workspaceElement).not.toContain('.about-release-notes');\n      });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "does not show the view if Atom is updated to a newer version than notified",
            "suites": [
                "the status bar",
                "on a stable version",
                "with an update",
                "clicking on the status"
            ],
            "updatePoint": {
                "line": 70,
                "column": 84
            },
            "line": 70,
            "code": "      it('does not show the view if Atom is updated to a newer version than notified', async () => {\n        MockUpdater.finishDownloadingUpdate('42.0.0');\n        await atom.packages.deactivatePackage('about');\n        atomVersion = '43.0.0';\n        await atom.packages.activatePackage('about');\n        await Promise.resolve(); // Service consumption hooks are deferred until the next tick\n\n        expect(workspaceElement).not.toContain('.about-release-notes');\n      });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "does not show the view",
            "suites": [
                "the status bar",
                "on a beta version",
                "with no update"
            ],
            "updatePoint": {
                "line": 87,
                "column": 32
            },
            "line": 87,
            "code": "      it('does not show the view', () => {\n        expect(workspaceElement).not.toContain('.about-release-notes');\n      });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "shows the view when the update finishes downloading",
            "suites": [
                "the status bar",
                "on a beta version",
                "with an update"
            ],
            "updatePoint": {
                "line": 92,
                "column": 61
            },
            "line": 92,
            "code": "      it('shows the view when the update finishes downloading', () => {\n        MockUpdater.finishDownloadingUpdate('42.0.0');\n        expect(workspaceElement).toContain('.about-release-notes');\n      });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "opens the about page",
            "suites": [
                "the status bar",
                "on a beta version",
                "with an update",
                "clicking on the status"
            ],
            "updatePoint": {
                "line": 97,
                "column": 32
            },
            "line": 97,
            "code": "        it('opens the about page', async () => {\n          MockUpdater.finishDownloadingUpdate('42.0.0');\n          workspaceElement.querySelector('.about-release-notes').click();\n          await conditionPromise(() => workspaceElement.querySelector('.about'));\n          expect(workspaceElement.querySelector('.about')).toExist();\n        });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "continues to show the squirrel until Atom is updated to the new version",
            "suites": [
                "the status bar",
                "on a beta version",
                "with an update",
                "clicking on the status"
            ],
            "updatePoint": {
                "line": 104,
                "column": 81
            },
            "line": 104,
            "code": "      it('continues to show the squirrel until Atom is updated to the new version', async () => {\n        MockUpdater.finishDownloadingUpdate('42.0.0');\n        expect(workspaceElement).toContain('.about-release-notes');\n        await atom.packages.deactivatePackage('about');\n        expect(workspaceElement).not.toContain('.about-release-notes');\n        await atom.packages.activatePackage('about');\n        await Promise.resolve(); // Service consumption hooks are deferred until the next tick\n\n        expect(workspaceElement).toContain('.about-release-notes');\n        await atom.packages.deactivatePackage('about');\n        expect(workspaceElement).not.toContain('.about-release-notes');\n        atomVersion = '42.0.0';\n        await atom.packages.activatePackage('about');\n        await Promise.resolve(); // Service consumption hooks are deferred until the next tick\n\n        expect(workspaceElement).not.toContain('.about-release-notes');\n      });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "does not show the view if Atom is updated to a newer version than notified",
            "suites": [
                "the status bar",
                "on a beta version",
                "with an update",
                "clicking on the status"
            ],
            "updatePoint": {
                "line": 121,
                "column": 84
            },
            "line": 121,
            "code": "      it('does not show the view if Atom is updated to a newer version than notified', async () => {\n        MockUpdater.finishDownloadingUpdate('42.0.0');\n        await atom.packages.deactivatePackage('about');\n        atomVersion = '43.0.0';\n        await atom.packages.activatePackage('about');\n        await Promise.resolve(); // Service consumption hooks are deferred until the next tick\n\n        expect(workspaceElement).not.toContain('.about-release-notes');\n      });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "does not show the view",
            "suites": [
                "the status bar",
                "on a development version",
                "with no update"
            ],
            "updatePoint": {
                "line": 138,
                "column": 32
            },
            "line": 138,
            "code": "      it('does not show the view', () => {\n        expect(workspaceElement).not.toContain('.about-release-notes');\n      });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "does not show the view",
            "suites": [
                "the status bar",
                "on a development version",
                "with a previously downloaded update"
            ],
            "updatePoint": {
                "line": 143,
                "column": 32
            },
            "line": 143,
            "code": "      it('does not show the view', () => {\n        window.localStorage.setItem('about:version-available', '42.0.0');\n        expect(workspaceElement).not.toContain('.about-release-notes');\n      });",
            "file": "about-status-bar-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "returns atom.io releases when dev version",
            "suites": [
                "UpdateManager",
                "::getReleaseNotesURLForVersion"
            ],
            "updatePoint": {
                "line": 9,
                "column": 49
            },
            "line": 9,
            "code": "    it('returns atom.io releases when dev version', () => {\n      expect(updateManager.getReleaseNotesURLForVersion('1.7.0-dev-e44b57d')).toContain('atom.io/releases');\n    });",
            "file": "update-manager-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "returns the page for the release when not a dev version",
            "suites": [
                "UpdateManager",
                "::getReleaseNotesURLForVersion"
            ],
            "updatePoint": {
                "line": 12,
                "column": 63
            },
            "line": 12,
            "code": "    it('returns the page for the release when not a dev version', () => {\n      expect(updateManager.getReleaseNotesURLForVersion('1.7.0')).toContain('atom/atom/releases/tag/v1.7.0');\n      expect(updateManager.getReleaseNotesURLForVersion('v1.7.0')).toContain('atom/atom/releases/tag/v1.7.0');\n      expect(updateManager.getReleaseNotesURLForVersion('1.7.0-beta10')).toContain('atom/atom/releases/tag/v1.7.0-beta10');\n      expect(updateManager.getReleaseNotesURLForVersion('1.7.0-nightly10')).toContain('atom/atom-nightly-releases/releases/tag/v1.7.0-nightly10');\n    });",
            "file": "update-manager-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "hides the auto update UI and shows the update instructions link",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when the updates are not supported by the platform"
            ],
            "updatePoint": {
                "line": 46,
                "column": 73
            },
            "line": 46,
            "code": "      it('hides the auto update UI and shows the update instructions link', async () => {\n        expect(aboutElement.querySelector('.about-update-action-button')).not.toBeVisible();\n        expect(aboutElement.querySelector('.about-auto-updates')).not.toBeVisible();\n      });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "opens the update instructions page when the instructions link is clicked",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when the updates are not supported by the platform"
            ],
            "updatePoint": {
                "line": 50,
                "column": 82
            },
            "line": 50,
            "code": "      it('opens the update instructions page when the instructions link is clicked', async () => {\n        spyOn(shell, 'openExternal');\n        let link = aboutElement.querySelector('.app-unsupported .about-updates-instructions');\n        link.click();\n        let args = shell.openExternal.mostRecentCall.args;\n        expect(shell.openExternal).toHaveBeenCalled();\n        expect(args[0]).toContain('installing-atom');\n      });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "shows the auto update UI",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform"
            ],
            "updatePoint": {
                "line": 65,
                "column": 34
            },
            "line": 65,
            "code": "      it('shows the auto update UI', () => {\n        expect(aboutElement.querySelector('.about-updates')).toBeVisible();\n      });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "shows the correct panels when the app checks for updates and there is no update available",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform"
            ],
            "updatePoint": {
                "line": 68,
                "column": 99
            },
            "line": 68,
            "code": "      it('shows the correct panels when the app checks for updates and there is no update available', async () => {\n        expect(aboutElement.querySelector('.about-default-update-message')).toBeVisible();\n        MockUpdater.checkForUpdate();\n        await scheduler.getNextUpdatePromise();\n        expect(aboutElement.querySelector('.app-up-to-date')).not.toBeVisible();\n        expect(aboutElement.querySelector('.app-checking-for-updates')).toBeVisible();\n        MockUpdater.updateNotAvailable();\n        await scheduler.getNextUpdatePromise();\n        expect(aboutElement.querySelector('.app-up-to-date')).toBeVisible();\n        expect(aboutElement.querySelector('.app-checking-for-updates')).not.toBeVisible();\n      });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "shows the correct panels when the app checks for updates and encounters an error",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform"
            ],
            "updatePoint": {
                "line": 79,
                "column": 90
            },
            "line": 79,
            "code": "      it('shows the correct panels when the app checks for updates and encounters an error', async () => {\n        expect(aboutElement.querySelector('.about-default-update-message')).toBeVisible();\n        MockUpdater.checkForUpdate();\n        await scheduler.getNextUpdatePromise();\n        expect(aboutElement.querySelector('.app-up-to-date')).not.toBeVisible();\n        expect(aboutElement.querySelector('.app-checking-for-updates')).toBeVisible();\n        spyOn(atom.autoUpdater, 'getErrorMessage').andReturn('an error message');\n        MockUpdater.updateError();\n        await scheduler.getNextUpdatePromise();\n        expect(aboutElement.querySelector('.app-update-error')).toBeVisible();\n        expect(aboutElement.querySelector('.app-error-message').textContent).toBe('an error message');\n        expect(aboutElement.querySelector('.app-checking-for-updates')).not.toBeVisible();\n        expect(aboutElement.querySelector('.about-update-action-button').disabled).toBe(false);\n        expect(aboutElement.querySelector('.about-update-action-button').textContent).toBe('Check now');\n      });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "shows the correct panels and button states when the app checks for updates and an update is downloaded",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform"
            ],
            "updatePoint": {
                "line": 94,
                "column": 112
            },
            "line": 94,
            "code": "      it('shows the correct panels and button states when the app checks for updates and an update is downloaded', async () => {\n        expect(aboutElement.querySelector('.about-default-update-message')).toBeVisible();\n        expect(aboutElement.querySelector('.about-update-action-button').disabled).toBe(false);\n        expect(aboutElement.querySelector('.about-update-action-button').textContent).toBe('Check now');\n        MockUpdater.checkForUpdate();\n        await scheduler.getNextUpdatePromise();\n        expect(aboutElement.querySelector('.app-up-to-date')).not.toBeVisible();\n        expect(aboutElement.querySelector('.app-checking-for-updates')).toBeVisible();\n        expect(aboutElement.querySelector('.about-update-action-button').disabled).toBe(true);\n        expect(aboutElement.querySelector('.about-update-action-button').textContent).toBe('Check now');\n        MockUpdater.downloadUpdate();\n        await scheduler.getNextUpdatePromise();\n        expect(aboutElement.querySelector('.app-checking-for-updates')).not.toBeVisible();\n        expect(aboutElement.querySelector('.app-downloading-update')).toBeVisible(); // TODO: at some point it would be nice to be able to cancel an update download, and then this would be a cancel button\n\n        expect(aboutElement.querySelector('.about-update-action-button').disabled).toBe(true);\n        expect(aboutElement.querySelector('.about-update-action-button').textContent).toBe('Check now');\n        MockUpdater.finishDownloadingUpdate('42.0.0');\n        await scheduler.getNextUpdatePromise();\n        expect(aboutElement.querySelector('.app-downloading-update')).not.toBeVisible();\n        expect(aboutElement.querySelector('.app-update-available-to-install')).toBeVisible();\n        expect(aboutElement.querySelector('.app-update-available-to-install .about-updates-version').textContent).toBe('42.0.0');\n        expect(aboutElement.querySelector('.about-update-action-button').disabled).toBe(false);\n        expect(aboutElement.querySelector('.about-update-action-button').textContent).toBe('Restart and install');\n      });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "opens the release notes for the downloaded release when the release notes link are clicked",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform"
            ],
            "updatePoint": {
                "line": 119,
                "column": 100
            },
            "line": 119,
            "code": "      it('opens the release notes for the downloaded release when the release notes link are clicked', async () => {\n        MockUpdater.finishDownloadingUpdate('1.2.3');\n        await scheduler.getNextUpdatePromise();\n        spyOn(shell, 'openExternal');\n        let link = aboutElement.querySelector('.app-update-available-to-install .about-updates-release-notes');\n        link.click();\n        let args = shell.openExternal.mostRecentCall.args;\n        expect(shell.openExternal).toHaveBeenCalled();\n        expect(args[0]).toContain('/v1.2.3');\n      });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "executes checkForUpdate() when the check for update button is clicked",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform"
            ],
            "updatePoint": {
                "line": 129,
                "column": 79
            },
            "line": 129,
            "code": "      it('executes checkForUpdate() when the check for update button is clicked', () => {\n        let button = aboutElement.querySelector('.about-update-action-button');\n        button.click();\n        expect(atom.autoUpdater.checkForUpdate).toHaveBeenCalled();\n      });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "executes restartAndInstallUpdate() when the restart and install button is clicked",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform"
            ],
            "updatePoint": {
                "line": 134,
                "column": 91
            },
            "line": 134,
            "code": "      it('executes restartAndInstallUpdate() when the restart and install button is clicked', async () => {\n        spyOn(atom.autoUpdater, 'restartAndInstallUpdate');\n        MockUpdater.finishDownloadingUpdate('42.0.0');\n        await scheduler.getNextUpdatePromise();\n        let button = aboutElement.querySelector('.about-update-action-button');\n        button.click();\n        expect(atom.autoUpdater.restartAndInstallUpdate).toHaveBeenCalled();\n      });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "starts in the same state as atom's AutoUpdateManager",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform"
            ],
            "updatePoint": {
                "line": 142,
                "column": 62
            },
            "line": 142,
            "code": "      it(\"starts in the same state as atom's AutoUpdateManager\", async () => {\n        atom.autoUpdater.getState.andReturn('downloading');\n        updateManager.resetState();\n        await scheduler.getNextUpdatePromise();\n        expect(aboutElement.querySelector('.app-checking-for-updates')).not.toBeVisible();\n        expect(aboutElement.querySelector('.app-downloading-update')).toBeVisible();\n        expect(aboutElement.querySelector('.about-update-action-button').disabled).toBe(true);\n        expect(aboutElement.querySelector('.about-update-action-button').textContent).toBe('Check now');\n      });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "shows the auto update UI",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform",
                "when core.automaticallyUpdate is toggled"
            ],
            "updatePoint": {
                "line": 156,
                "column": 36
            },
            "line": 156,
            "code": "        it('shows the auto update UI', async () => {\n          expect(aboutElement.querySelector('.about-auto-updates input').checked).toBe(true);\n          expect(aboutElement.querySelector('.about-default-update-message')).toBeVisible();\n          expect(aboutElement.querySelector('.about-default-update-message').textContent).toBe('Atom will check for updates automatically');\n          atom.config.set('core.automaticallyUpdate', false);\n          await scheduler.getNextUpdatePromise();\n          expect(aboutElement.querySelector('.about-auto-updates input').checked).toBe(false);\n          expect(aboutElement.querySelector('.about-default-update-message')).toBeVisible();\n          expect(aboutElement.querySelector('.about-default-update-message').textContent).toBe('Automatic updates are disabled please check manually');\n        });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "updates config and the UI when the checkbox is used to toggle",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform",
                "when core.automaticallyUpdate is toggled"
            ],
            "updatePoint": {
                "line": 166,
                "column": 73
            },
            "line": 166,
            "code": "        it('updates config and the UI when the checkbox is used to toggle', async () => {\n          expect(aboutElement.querySelector('.about-auto-updates input').checked).toBe(true);\n          aboutElement.querySelector('.about-auto-updates input').click();\n          await scheduler.getNextUpdatePromise();\n          expect(atom.config.get('core.automaticallyUpdate')).toBe(false);\n          expect(aboutElement.querySelector('.about-auto-updates input').checked).toBe(false);\n          expect(aboutElement.querySelector('.about-default-update-message')).toBeVisible();\n          expect(aboutElement.querySelector('.about-default-update-message').textContent).toBe('Automatic updates are disabled please check manually');\n          aboutElement.querySelector('.about-auto-updates input').click();\n          await scheduler.getNextUpdatePromise();\n          expect(atom.config.get('core.automaticallyUpdate')).toBe(true);\n          expect(aboutElement.querySelector('.about-auto-updates input').checked).toBe(true);\n          expect(aboutElement.querySelector('.about-default-update-message')).toBeVisible();\n          expect(aboutElement.querySelector('.about-default-update-message').textContent).toBe('Atom will check for updates automatically');\n        });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "checks for update when the about page is shown",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform",
                "when core.automaticallyUpdate is toggled",
                "checking for updates"
            ],
            "updatePoint": {
                "line": 185,
                "column": 60
            },
            "line": 185,
            "code": "          it('checks for update when the about page is shown', () => {\n            expect(atom.autoUpdater.checkForUpdate).not.toHaveBeenCalled();\n            this.updateView = new UpdateView({\n              updateManager: updateManager,\n              availableVersion: '9999.0.0',\n              viewUpdateReleaseNotes: () => {}\n            });\n            expect(atom.autoUpdater.checkForUpdate).toHaveBeenCalled();\n          });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "does not check for update when the about page is shown and the update manager is not in the idle state",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform",
                "when core.automaticallyUpdate is toggled",
                "checking for updates"
            ],
            "updatePoint": {
                "line": 194,
                "column": 116
            },
            "line": 194,
            "code": "          it('does not check for update when the about page is shown and the update manager is not in the idle state', () => {\n            atom.autoUpdater.getState.andReturn('downloading');\n            updateManager.resetState();\n            expect(atom.autoUpdater.checkForUpdate).not.toHaveBeenCalled();\n            this.updateView = new UpdateView({\n              updateManager: updateManager,\n              availableVersion: '9999.0.0',\n              viewUpdateReleaseNotes: () => {}\n            });\n            expect(atom.autoUpdater.checkForUpdate).not.toHaveBeenCalled();\n          });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "does not check for update when the about page is shown and auto updates are turned off",
            "suites": [
                "UpdateView",
                "when the About page is open",
                "when updates are supported by the platform",
                "when core.automaticallyUpdate is toggled",
                "checking for updates"
            ],
            "updatePoint": {
                "line": 205,
                "column": 100
            },
            "line": 205,
            "code": "          it('does not check for update when the about page is shown and auto updates are turned off', () => {\n            atom.config.set('core.automaticallyUpdate', false);\n            expect(atom.autoUpdater.checkForUpdate).not.toHaveBeenCalled();\n            this.updateView = new UpdateView({\n              updateManager: updateManager,\n              availableVersion: '9999.0.0',\n              viewUpdateReleaseNotes: () => {}\n            });\n            expect(atom.autoUpdater.checkForUpdate).not.toHaveBeenCalled();\n          });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "should display the new version when it is opened",
            "suites": [
                "UpdateView",
                "when the About page is not open and an update is downloaded"
            ],
            "updatePoint": {
                "line": 220,
                "column": 56
            },
            "line": 220,
            "code": "    it('should display the new version when it is opened', async () => {\n      MockUpdater.finishDownloadingUpdate('42.0.0');\n      jasmine.attachToDOM(workspaceElement);\n      await atom.workspace.open('atom://about');\n      aboutElement = workspaceElement.querySelector('.about');\n      updateManager = main.model.state.updateManager;\n      scheduler = AboutView.getScheduler();\n      expect(aboutElement.querySelector('.app-update-available-to-install')).toBeVisible();\n      expect(aboutElement.querySelector('.app-update-available-to-install .about-updates-version').textContent).toBe('42.0.0');\n      expect(aboutElement.querySelector('.about-update-action-button').disabled).toBe(false);\n      expect(aboutElement.querySelector('.about-update-action-button').textContent).toBe('Restart and install');\n    });",
            "file": "update-view-spec.js",
            "skipped": false,
            "dir": "packages/about/spec"
        },
        {
            "name": "returns a list of duplicate names",
            "suites": [
                "dalek",
                "enumerate"
            ],
            "updatePoint": {
                "line": 44,
                "column": 41
            },
            "line": 44,
            "code": "    it('returns a list of duplicate names', async function () {\n      assert.deepEqual(await dalek.enumerate(), ['duplicated-package']);\n    });",
            "file": "dalek.test.js",
            "skipped": false,
            "dir": "packages/dalek/test"
        },
        {
            "name": "always returns an empty list",
            "suites": [
                "dalek",
                "enumerate",
                "when in dev mode"
            ],
            "updatePoint": {
                "line": 51,
                "column": 38
            },
            "line": 51,
            "code": "      it('always returns an empty list', async function () {\n        assert.deepEqual(await dalek.enumerate(), []);\n      });",
            "file": "dalek.test.js",
            "skipped": false,
            "dir": "packages/dalek/test"
        },
        {
            "name": "is not included in the list of duplicate names",
            "suites": [
                "dalek",
                "enumerate",
                "when a package is symlinked into the package directory"
            ],
            "updatePoint": {
                "line": 61,
                "column": 56
            },
            "line": 61,
            "code": "      it('is not included in the list of duplicate names', async function () {\n        assert.deepEqual(await dalek.enumerate(), []);\n      });",
            "file": "dalek.test.js",
            "skipped": false,
            "dir": "packages/dalek/test"
        },
        {
            "name": "does not watch files",
            "suites": [
                "Dev Live Reload",
                "package activation",
                "when the window is not in dev mode"
            ],
            "updatePoint": {
                "line": 12,
                "column": 30
            },
            "line": 12,
            "code": "      it('does not watch files', async () => {\n        spyOn(atom.packages, 'hasActivatedInitialPackages').andReturn(true);\n        await atom.packages.activatePackage('dev-live-reload');\n        expect(mainModule.startWatching).not.toHaveBeenCalled();\n      });",
            "file": "dev-live-reload-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "does not watch files",
            "suites": [
                "Dev Live Reload",
                "package activation",
                "when the window is in spec mode"
            ],
            "updatePoint": {
                "line": 20,
                "column": 30
            },
            "line": 20,
            "code": "      it('does not watch files', async () => {\n        spyOn(atom.packages, 'hasActivatedInitialPackages').andReturn(true);\n        await atom.packages.activatePackage('dev-live-reload');\n        expect(mainModule.startWatching).not.toHaveBeenCalled();\n      });",
            "file": "dev-live-reload-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "watches files",
            "suites": [
                "Dev Live Reload",
                "package activation",
                "when the window is in dev mode"
            ],
            "updatePoint": {
                "line": 31,
                "column": 23
            },
            "line": 31,
            "code": "      it('watches files', async () => {\n        spyOn(atom.packages, 'hasActivatedInitialPackages').andReturn(true);\n        await atom.packages.activatePackage('dev-live-reload');\n        expect(mainModule.startWatching).toHaveBeenCalled();\n      });",
            "file": "dev-live-reload-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "does not watch files",
            "suites": [
                "Dev Live Reload",
                "package activation",
                "when the window is in both dev mode and spec mode"
            ],
            "updatePoint": {
                "line": 42,
                "column": 30
            },
            "line": 42,
            "code": "      it('does not watch files', async () => {\n        spyOn(atom.packages, 'hasActivatedInitialPackages').andReturn(true);\n        await atom.packages.activatePackage('dev-live-reload');\n        expect(mainModule.startWatching).not.toHaveBeenCalled();\n      });",
            "file": "dev-live-reload-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "waits until all initial packages have been activated before watching files",
            "suites": [
                "Dev Live Reload",
                "package activation",
                "when the package is activated before initial packages have been activated"
            ],
            "updatePoint": {
                "line": 53,
                "column": 84
            },
            "line": 53,
            "code": "      it('waits until all initial packages have been activated before watching files', async () => {\n        await atom.packages.activatePackage('dev-live-reload');\n        expect(mainModule.startWatching).not.toHaveBeenCalled();\n        atom.packages.emitter.emit('did-activate-initial-packages');\n        expect(mainModule.startWatching).toHaveBeenCalled();\n      });",
            "file": "dev-live-reload-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "stops watching all files",
            "suites": [
                "Dev Live Reload",
                "package deactivation"
            ],
            "updatePoint": {
                "line": 66,
                "column": 32
            },
            "line": 66,
            "code": "    it('stops watching all files', async () => {\n      spyOn(atom.packages, 'hasActivatedInitialPackages').andReturn(true);\n      const {\n        mainModule\n      } = await atom.packages.activatePackage('dev-live-reload');\n      expect(mainModule.uiWatcher).not.toBeNull();\n      spyOn(mainModule.uiWatcher, 'destroy');\n      await atom.packages.deactivatePackage('dev-live-reload');\n      expect(mainModule.uiWatcher.destroy).toHaveBeenCalled();\n    });",
            "file": "dev-live-reload-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "unsubscribes from the onDidActivateInitialPackages subscription if it is disabled before all initial packages are activated",
            "suites": [
                "Dev Live Reload",
                "package deactivation"
            ],
            "updatePoint": {
                "line": 76,
                "column": 131
            },
            "line": 76,
            "code": "    it('unsubscribes from the onDidActivateInitialPackages subscription if it is disabled before all initial packages are activated', async () => {\n      const {\n        mainModule\n      } = await atom.packages.activatePackage('dev-live-reload');\n      expect(mainModule.activatedDisposable.disposed).toBe(false);\n      await atom.packages.deactivatePackage('dev-live-reload');\n      expect(mainModule.activatedDisposable.disposed).toBe(true);\n      spyOn(mainModule, 'startWatching');\n      atom.packages.emitter.emit('did-activate-initial-packages');\n      expect(mainModule.startWatching).not.toHaveBeenCalled();\n    });",
            "file": "dev-live-reload-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "removes its commands",
            "suites": [
                "Dev Live Reload",
                "package deactivation"
            ],
            "updatePoint": {
                "line": 87,
                "column": 28
            },
            "line": 87,
            "code": "    it('removes its commands', async () => {\n      spyOn(atom.packages, 'hasActivatedInitialPackages').andReturn(true);\n      await atom.packages.activatePackage('dev-live-reload');\n      expect(atom.commands.findCommands({\n        target: atom.views.getView(atom.workspace)\n      }).filter(command => command.name.startsWith('dev-live-reload')).length).toBeGreaterThan(0);\n      await atom.packages.deactivatePackage('dev-live-reload');\n      expect(atom.commands.findCommands({\n        target: atom.views.getView(atom.workspace)\n      }).filter(command => command.name.startsWith('dev-live-reload')).length).toBe(0);\n    });",
            "file": "dev-live-reload-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "reloads all the base styles",
            "suites": [
                "UIWatcher",
                "when a base theme's file changes"
            ],
            "updatePoint": {
                "line": 18,
                "column": 35
            },
            "line": 18,
            "code": "    it('reloads all the base styles', () => {\n      spyOn(atom.themes, 'reloadBaseStylesheets');\n      expect(uiWatcher.baseTheme.entities[0].getPath()).toContain(`${path.sep}static${path.sep}`);\n      uiWatcher.baseTheme.entities[0].emitter.emit('did-change');\n      expect(atom.themes.reloadBaseStylesheets).toHaveBeenCalled();\n    });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "watches all the style sheets in the theme's styles folder",
            "suites": [
                "UIWatcher",
                "when a base theme's file changes"
            ],
            "updatePoint": {
                "line": 25,
                "column": 63
            },
            "line": 25,
            "code": "  it(\"watches all the style sheets in the theme's styles folder\", async () => {\n    const packagePath = path.join(__dirname, 'fixtures', 'package-with-styles-folder');\n    await atom.packages.activatePackage(packagePath);\n    uiWatcher = new UIWatcher();\n    const lastWatcher = uiWatcher.watchers[uiWatcher.watchers.length - 1];\n    expect(lastWatcher.entities.length).toBe(4);\n    expect(lastWatcher.entities[0].getPath()).toBe(path.join(packagePath, 'styles'));\n    expect(lastWatcher.entities[1].getPath()).toBe(path.join(packagePath, 'styles', '3.css'));\n    expect(lastWatcher.entities[2].getPath()).toBe(path.join(packagePath, 'styles', 'sub', '1.css'));\n    expect(lastWatcher.entities[3].getPath()).toBe(path.join(packagePath, 'styles', 'sub', '2.less'));\n  });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "reloads all package styles",
            "suites": [
                "UIWatcher",
                "when a package stylesheet file changes"
            ],
            "updatePoint": {
                "line": 41,
                "column": 34
            },
            "line": 41,
            "code": "    it('reloads all package styles', () => {\n      const pack = atom.packages.getActivePackages()[0];\n      spyOn(pack, 'reloadStylesheets');\n      uiWatcher.watchers[uiWatcher.watchers.length - 1].entities[1].emitter.emit('did-change');\n      expect(pack.reloadStylesheets).toHaveBeenCalled();\n    });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "does not create a PackageWatcher",
            "suites": [
                "UIWatcher",
                "when a package does not have a stylesheet"
            ],
            "updatePoint": {
                "line": 53,
                "column": 40
            },
            "line": 53,
            "code": "    it('does not create a PackageWatcher', () => {\n      expect(uiWatcher.watchedPackages['package-with-index']).toBeUndefined();\n    });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "reloads every package when the variables file changes",
            "suites": [
                "UIWatcher",
                "when a package global file changes"
            ],
            "updatePoint": {
                "line": 64,
                "column": 61
            },
            "line": 64,
            "code": "    it('reloads every package when the variables file changes', () => {\n      let varEntity;\n\n      for (const theme of atom.themes.getActiveThemes()) {\n        spyOn(theme, 'reloadStylesheets');\n      }\n\n      for (const entity of uiWatcher.watchedThemes.get('theme-with-multiple-imported-files').entities) {\n        if (entity.getPath().indexOf('variables') > -1) varEntity = entity;\n      }\n\n      varEntity.emitter.emit('did-change');\n\n      for (const theme of atom.themes.getActiveThemes()) {\n        expect(theme.reloadStylesheets).toHaveBeenCalled();\n      }\n    });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "starts watching a package if it is activated after initial startup",
            "suites": [
                "UIWatcher",
                "watcher lifecycle"
            ],
            "updatePoint": {
                "line": 83,
                "column": 74
            },
            "line": 83,
            "code": "    it('starts watching a package if it is activated after initial startup', async () => {\n      uiWatcher = new UIWatcher();\n      expect(uiWatcher.watchedPackages.size).toBe(0);\n      await atom.packages.activatePackage(path.join(__dirname, 'fixtures', 'package-with-styles-folder'));\n      expect(uiWatcher.watchedPackages.get('package-with-styles-folder')).not.toBeUndefined();\n    });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "unwatches a package after it is deactivated",
            "suites": [
                "UIWatcher",
                "watcher lifecycle"
            ],
            "updatePoint": {
                "line": 89,
                "column": 51
            },
            "line": 89,
            "code": "    it('unwatches a package after it is deactivated', async () => {\n      await atom.packages.activatePackage(path.join(__dirname, 'fixtures', 'package-with-styles-folder'));\n      uiWatcher = new UIWatcher();\n      const watcher = uiWatcher.watchedPackages.get('package-with-styles-folder');\n      expect(watcher).not.toBeUndefined();\n      const watcherDestructionSpy = jasmine.createSpy('watcher-on-did-destroy');\n      watcher.onDidDestroy(watcherDestructionSpy);\n      await atom.packages.deactivatePackage('package-with-styles-folder');\n      expect(uiWatcher.watchedPackages.get('package-with-styles-folder')).toBeUndefined();\n      expect(uiWatcher.watchedPackages.size).toBe(0);\n      expect(watcherDestructionSpy).toHaveBeenCalled();\n    });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "does not watch activated packages after the UI watcher has been destroyed",
            "suites": [
                "UIWatcher",
                "watcher lifecycle"
            ],
            "updatePoint": {
                "line": 101,
                "column": 81
            },
            "line": 101,
            "code": "    it('does not watch activated packages after the UI watcher has been destroyed', async () => {\n      uiWatcher = new UIWatcher();\n      uiWatcher.destroy();\n      await atom.packages.activatePackage(path.join(__dirname, 'fixtures', 'package-with-styles-folder'));\n      expect(uiWatcher.watchedPackages.size).toBe(0);\n    });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "watches themes without a styles directory",
            "suites": [
                "UIWatcher",
                "minimal theme packages"
            ],
            "updatePoint": {
                "line": 117,
                "column": 49
            },
            "line": 117,
            "code": "    it('watches themes without a styles directory', () => {\n      spyOn(pack, 'reloadStylesheets');\n      spyOn(atom.themes, 'reloadBaseStylesheets');\n      const watcher = uiWatcher.watchedThemes.get('theme-with-index-less');\n      expect(watcher.entities.length).toBe(1);\n      watcher.entities[0].emitter.emit('did-change');\n      expect(pack.reloadStylesheets).toHaveBeenCalled();\n      expect(atom.themes.reloadBaseStylesheets).not.toHaveBeenCalled();\n    });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "reloads the theme when anything within the theme changes",
            "suites": [
                "UIWatcher",
                "theme packages"
            ],
            "updatePoint": {
                "line": 136,
                "column": 64
            },
            "line": 136,
            "code": "    it('reloads the theme when anything within the theme changes', () => {\n      spyOn(pack, 'reloadStylesheets');\n      spyOn(atom.themes, 'reloadBaseStylesheets');\n      const watcher = uiWatcher.watchedThemes.get('theme-with-multiple-imported-files');\n      expect(watcher.entities.length).toBe(6);\n      watcher.entities[2].emitter.emit('did-change');\n      expect(pack.reloadStylesheets).toHaveBeenCalled();\n      expect(atom.themes.reloadBaseStylesheets).not.toHaveBeenCalled();\n      watcher.entities[watcher.entities.length - 1].emitter.emit('did-change');\n      expect(atom.themes.reloadBaseStylesheets).toHaveBeenCalled();\n    });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "unwatches when a theme is deactivated",
            "suites": [
                "UIWatcher",
                "theme packages"
            ],
            "updatePoint": {
                "line": 147,
                "column": 45
            },
            "line": 147,
            "code": "    it('unwatches when a theme is deactivated', async () => {\n      jasmine.useRealClock();\n      atom.config.set('core.themes', []);\n      await conditionPromise(() => !uiWatcher.watchedThemes['theme-with-multiple-imported-files']);\n    });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "watches a new theme when it is deactivated",
            "suites": [
                "UIWatcher",
                "theme packages"
            ],
            "updatePoint": {
                "line": 152,
                "column": 50
            },
            "line": 152,
            "code": "    it('watches a new theme when it is deactivated', async () => {\n      jasmine.useRealClock();\n      atom.config.set('core.themes', ['theme-with-syntax-variables', 'theme-with-package-file']);\n      await conditionPromise(() => uiWatcher.watchedThemes.get('theme-with-package-file'));\n      pack = atom.themes.getActiveThemes()[0];\n      spyOn(pack, 'reloadStylesheets');\n      expect(pack.name).toBe('theme-with-package-file');\n      const watcher = uiWatcher.watchedThemes.get('theme-with-package-file');\n      watcher.entities[2].emitter.emit('did-change');\n      expect(pack.reloadStylesheets).toHaveBeenCalled();\n    });",
            "file": "ui-watcher-spec.js",
            "skipped": false,
            "dir": "packages/dev-live-reload/spec"
        },
        {
            "name": "posts errors originated inside Atom Core to BugSnag",
            "suites": [
                "Reporter",
                ".reportUncaughtException(error)"
            ],
            "updatePoint": {
                "line": 39,
                "column": 59
            },
            "line": 39,
            "code": "    it('posts errors originated inside Atom Core to BugSnag', () => {\n      const repositoryRootPath = path.join(__dirname, '..');\n      reporter = new Reporter({\n        request: (url, options) => requests.push(Object.assign({\n          url\n        }, options)),\n        alwaysReport: true,\n        reportPreviousErrors: false,\n        resourcePath: repositoryRootPath\n      });\n      let error = new Error();\n      Error.captureStackTrace(error);\n      reporter.reportUncaughtException(error);\n      let [lineNumber, columnNumber] = error.stack.match(/.js:(\\d+):(\\d+)/).slice(1).map(s => parseInt(s));\n      expect(requests.length).toBe(1);\n      let [request] = requests;\n      expect(request.method).toBe('POST');\n      expect(request.url).toBe('https://notify.bugsnag.com');\n      expect(request.headers.get('Content-Type')).toBe('application/json');\n      let body = JSON.parse(request.body); // Delete `inProject` field because tests may fail when run as part of Atom core\n      // (i.e. when this test file will be located under `node_modules/exception-reporting/spec`)\n\n      delete body.events[0].exceptions[0].stacktrace[0].inProject;\n      expect(body).toEqual({\n        apiKey: Reporter.API_KEY,\n        notifier: {\n          name: 'Atom',\n          version: Reporter.LIB_VERSION,\n          url: 'https://www.atom.io'\n        },\n        events: [{\n          payloadVersion: '2',\n          exceptions: [{\n            errorClass: 'Error',\n            message: '',\n            stacktrace: [{\n              method: semver.gt(process.versions.electron, '1.6.0') ? 'Spec.<anonymous>' : '<anonymous>',\n              file: 'spec/reporter-spec.js',\n              lineNumber: lineNumber,\n              columnNumber: columnNumber\n            }]\n          }],\n          severity: 'error',\n          user: {},\n          app: {\n            version: atom.getVersion(),\n            releaseStage: getReleaseChannel(atom.getVersion())\n          },\n          device: {\n            osVersion: osVersion\n          }\n        }]\n      });\n    });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "posts errors originated outside Atom Core to BugSnag",
            "suites": [
                "Reporter",
                ".reportUncaughtException(error)"
            ],
            "updatePoint": {
                "line": 93,
                "column": 60
            },
            "line": 93,
            "code": "    it('posts errors originated outside Atom Core to BugSnag', () => {\n      fs.getHomeDirectory = () => path.join(__dirname, '..', '..');\n\n      let error = new Error();\n      Error.captureStackTrace(error);\n      reporter.reportUncaughtException(error);\n      let [lineNumber, columnNumber] = error.stack.match(/.js:(\\d+):(\\d+)/).slice(1).map(s => parseInt(s));\n      expect(requests.length).toBe(1);\n      let [request] = requests;\n      expect(request.method).toBe('POST');\n      expect(request.url).toBe('https://notify.bugsnag.com');\n      expect(request.headers.get('Content-Type')).toBe('application/json');\n      let body = JSON.parse(request.body); // Delete `inProject` field because tests may fail when run as part of Atom core\n      // (i.e. when this test file will be located under `node_modules/exception-reporting/spec`)\n\n      delete body.events[0].exceptions[0].stacktrace[0].inProject;\n      expect(body).toEqual({\n        apiKey: Reporter.API_KEY,\n        notifier: {\n          name: 'Atom',\n          version: Reporter.LIB_VERSION,\n          url: 'https://www.atom.io'\n        },\n        events: [{\n          payloadVersion: '2',\n          exceptions: [{\n            errorClass: 'Error',\n            message: '',\n            stacktrace: [{\n              method: semver.gt(process.versions.electron, '1.6.0') ? 'Spec.<anonymous>' : '<anonymous>',\n              file: '~/exception-reporting/spec/reporter-spec.js',\n              lineNumber: lineNumber,\n              columnNumber: columnNumber\n            }]\n          }],\n          severity: 'error',\n          user: {},\n          app: {\n            version: atom.getVersion(),\n            releaseStage: getReleaseChannel(atom.getVersion())\n          },\n          device: {\n            osVersion: osVersion\n          }\n        }]\n      });\n    });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "posts a notification asking for consent",
            "suites": [
                "Reporter",
                ".reportUncaughtException(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 155,
                "column": 49
            },
            "line": 155,
            "code": "      it('posts a notification asking for consent', () => {\n        reporter.reportUncaughtException(error);\n        expect(atom.notifications.addInfo).toHaveBeenCalled();\n      });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "submits the error with the private metadata if the user consents",
            "suites": [
                "Reporter",
                ".reportUncaughtException(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 159,
                "column": 74
            },
            "line": 159,
            "code": "      it('submits the error with the private metadata if the user consents', () => {\n        spyOn(reporter, 'reportUncaughtException').andCallThrough();\n        reporter.reportUncaughtException(error);\n        reporter.reportUncaughtException.reset();\n        notification = atom.notifications.getNotifications()[0];\n        let notificationOptions = atom.notifications.addInfo.argsForCall[0][1];\n        expect(notificationOptions.buttons[1].text).toMatch(/Yes/);\n        notificationOptions.buttons[1].onDidClick();\n        expect(reporter.reportUncaughtException).toHaveBeenCalledWith(error);\n        expect(reporter.reportUncaughtException.callCount).toBe(1);\n        expect(error.privateMetadata).toBeUndefined();\n        expect(error.privateMetadataDescription).toBeUndefined();\n        expect(error.metadata).toEqual({\n          foo: 'bar',\n          baz: 'quux'\n        });\n        expect(notification.isDismissed()).toBe(true);\n      });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "submits the error without the private metadata if the user does not consent",
            "suites": [
                "Reporter",
                ".reportUncaughtException(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 177,
                "column": 85
            },
            "line": 177,
            "code": "      it('submits the error without the private metadata if the user does not consent', () => {\n        spyOn(reporter, 'reportUncaughtException').andCallThrough();\n        reporter.reportUncaughtException(error);\n        reporter.reportUncaughtException.reset();\n        notification = atom.notifications.getNotifications()[0];\n        let notificationOptions = atom.notifications.addInfo.argsForCall[0][1];\n        expect(notificationOptions.buttons[0].text).toMatch(/No/);\n        notificationOptions.buttons[0].onDidClick();\n        expect(reporter.reportUncaughtException).toHaveBeenCalledWith(error);\n        expect(reporter.reportUncaughtException.callCount).toBe(1);\n        expect(error.privateMetadata).toBeUndefined();\n        expect(error.privateMetadataDescription).toBeUndefined();\n        expect(error.metadata).toEqual({\n          foo: 'bar'\n        });\n        expect(notification.isDismissed()).toBe(true);\n      });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "submits the error without the private metadata if the user dismisses the notification",
            "suites": [
                "Reporter",
                ".reportUncaughtException(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 194,
                "column": 95
            },
            "line": 194,
            "code": "      it('submits the error without the private metadata if the user dismisses the notification', () => {\n        spyOn(reporter, 'reportUncaughtException').andCallThrough();\n        reporter.reportUncaughtException(error);\n        reporter.reportUncaughtException.reset();\n        notification = atom.notifications.getNotifications()[0];\n        notification.dismiss();\n        expect(reporter.reportUncaughtException).toHaveBeenCalledWith(error);\n        expect(reporter.reportUncaughtException.callCount).toBe(1);\n        expect(error.privateMetadata).toBeUndefined();\n        expect(error.privateMetadataDescription).toBeUndefined();\n        expect(error.metadata).toEqual({\n          foo: 'bar'\n        });\n      });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "treats packages located in atom.packages.getPackageDirPaths as user packages",
            "suites": [
                "Reporter",
                ".reportUncaughtException(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 209,
                "column": 84
            },
            "line": 209,
            "code": "    it('treats packages located in atom.packages.getPackageDirPaths as user packages', () => {\n      mockActivePackages = [{\n        name: 'user-1',\n        path: '/Users/user/.atom/packages/user-1',\n        metadata: {\n          version: '1.0.0'\n        }\n      }, {\n        name: 'user-2',\n        path: '/Users/user/.atom/packages/user-2',\n        metadata: {\n          version: '1.2.0'\n        }\n      }, {\n        name: 'bundled-1',\n        path: '/Applications/Atom.app/Contents/Resources/app.asar/node_modules/bundled-1',\n        metadata: {\n          version: '1.0.0'\n        }\n      }, {\n        name: 'bundled-2',\n        path: '/Applications/Atom.app/Contents/Resources/app.asar/node_modules/bundled-2',\n        metadata: {\n          version: '1.2.0'\n        }\n      }];\n      const packageDirPaths = ['/Users/user/.atom/packages'];\n      spyOn(atom.packages, 'getPackageDirPaths').andReturn(packageDirPaths);\n      let error = new Error();\n      Error.captureStackTrace(error);\n      reporter.reportUncaughtException(error);\n      expect(error.metadata.userPackages).toEqual({\n        'user-1': '1.0.0',\n        'user-2': '1.2.0'\n      });\n      expect(error.metadata.bundledPackages).toEqual({\n        'bundled-1': '1.0.0',\n        'bundled-2': '1.2.0'\n      });\n    });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "adds previous error messages and assertion failures to the reported metadata",
            "suites": [
                "Reporter",
                ".reportUncaughtException(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 249,
                "column": 84
            },
            "line": 249,
            "code": "    it('adds previous error messages and assertion failures to the reported metadata', () => {\n      reporter.reportPreviousErrors = true;\n      reporter.reportUncaughtException(new Error('A'));\n      reporter.reportUncaughtException(new Error('B'));\n      reporter.reportFailedAssertion(new Error('X'));\n      reporter.reportFailedAssertion(new Error('Y'));\n      reporter.reportUncaughtException(new Error('C'));\n      expect(requests.length).toBe(5);\n      const lastRequest = requests[requests.length - 1];\n      const body = JSON.parse(lastRequest.body);\n      console.log(body);\n      expect(body.events[0].metaData.previousErrors).toEqual(['A', 'B']);\n      expect(body.events[0].metaData.previousAssertionFailures).toEqual(['X', 'Y']);\n    });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "posts warnings to bugsnag",
            "suites": [
                "Reporter",
                ".reportFailedAssertion(error)"
            ],
            "updatePoint": {
                "line": 265,
                "column": 33
            },
            "line": 265,
            "code": "    it('posts warnings to bugsnag', () => {\n      fs.getHomeDirectory = () => path.join(__dirname, '..', '..');\n\n      let error = new Error();\n      Error.captureStackTrace(error);\n      reporter.reportFailedAssertion(error);\n      let [lineNumber, columnNumber] = error.stack.match(/.js:(\\d+):(\\d+)/).slice(1).map(s => parseInt(s));\n      expect(requests.length).toBe(1);\n      let [request] = requests;\n      expect(request.method).toBe('POST');\n      expect(request.url).toBe('https://notify.bugsnag.com');\n      expect(request.headers.get('Content-Type')).toBe('application/json');\n      let body = JSON.parse(request.body); // Delete `inProject` field because tests may fail when run as part of Atom core\n      // (i.e. when this test file will be located under `node_modules/exception-reporting/spec`)\n\n      delete body.events[0].exceptions[0].stacktrace[0].inProject;\n      expect(body).toEqual({\n        apiKey: Reporter.API_KEY,\n        notifier: {\n          name: 'Atom',\n          version: Reporter.LIB_VERSION,\n          url: 'https://www.atom.io'\n        },\n        events: [{\n          payloadVersion: '2',\n          exceptions: [{\n            errorClass: 'Error',\n            message: '',\n            stacktrace: [{\n              method: semver.gt(process.versions.electron, '1.6.0') ? 'Spec.<anonymous>' : '<anonymous>',\n              file: '~/exception-reporting/spec/reporter-spec.js',\n              lineNumber: lineNumber,\n              columnNumber: columnNumber\n            }]\n          }],\n          severity: 'warning',\n          user: {},\n          app: {\n            version: atom.getVersion(),\n            releaseStage: getReleaseChannel(atom.getVersion())\n          },\n          device: {\n            osVersion: osVersion\n          }\n        }]\n      });\n    });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "posts a notification asking for consent",
            "suites": [
                "Reporter",
                ".reportFailedAssertion(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 327,
                "column": 49
            },
            "line": 327,
            "code": "      it('posts a notification asking for consent', () => {\n        reporter.reportFailedAssertion(error);\n        expect(atom.notifications.addInfo).toHaveBeenCalled();\n      });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "submits the error with the private metadata if the user consents",
            "suites": [
                "Reporter",
                ".reportFailedAssertion(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 331,
                "column": 74
            },
            "line": 331,
            "code": "      it('submits the error with the private metadata if the user consents', () => {\n        spyOn(reporter, 'reportFailedAssertion').andCallThrough();\n        reporter.reportFailedAssertion(error);\n        reporter.reportFailedAssertion.reset();\n        notification = atom.notifications.getNotifications()[0];\n        let notificationOptions = atom.notifications.addInfo.argsForCall[0][1];\n        expect(notificationOptions.buttons[1].text).toMatch(/Yes/);\n        notificationOptions.buttons[1].onDidClick();\n        expect(reporter.reportFailedAssertion).toHaveBeenCalledWith(error);\n        expect(reporter.reportFailedAssertion.callCount).toBe(1);\n        expect(error.privateMetadata).toBeUndefined();\n        expect(error.privateMetadataDescription).toBeUndefined();\n        expect(error.metadata).toEqual({\n          foo: 'bar',\n          baz: 'quux'\n        });\n        expect(notification.isDismissed()).toBe(true);\n      });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "submits the error without the private metadata if the user does not consent",
            "suites": [
                "Reporter",
                ".reportFailedAssertion(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 349,
                "column": 85
            },
            "line": 349,
            "code": "      it('submits the error without the private metadata if the user does not consent', () => {\n        spyOn(reporter, 'reportFailedAssertion').andCallThrough();\n        reporter.reportFailedAssertion(error);\n        reporter.reportFailedAssertion.reset();\n        notification = atom.notifications.getNotifications()[0];\n        let notificationOptions = atom.notifications.addInfo.argsForCall[0][1];\n        expect(notificationOptions.buttons[0].text).toMatch(/No/);\n        notificationOptions.buttons[0].onDidClick();\n        expect(reporter.reportFailedAssertion).toHaveBeenCalledWith(error);\n        expect(reporter.reportFailedAssertion.callCount).toBe(1);\n        expect(error.privateMetadata).toBeUndefined();\n        expect(error.privateMetadataDescription).toBeUndefined();\n        expect(error.metadata).toEqual({\n          foo: 'bar'\n        });\n        expect(notification.isDismissed()).toBe(true);\n      });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "submits the error without the private metadata if the user dismisses the notification",
            "suites": [
                "Reporter",
                ".reportFailedAssertion(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 366,
                "column": 95
            },
            "line": 366,
            "code": "      it('submits the error without the private metadata if the user dismisses the notification', () => {\n        spyOn(reporter, 'reportFailedAssertion').andCallThrough();\n        reporter.reportFailedAssertion(error);\n        reporter.reportFailedAssertion.reset();\n        notification = atom.notifications.getNotifications()[0];\n        notification.dismiss();\n        expect(reporter.reportFailedAssertion).toHaveBeenCalledWith(error);\n        expect(reporter.reportFailedAssertion.callCount).toBe(1);\n        expect(error.privateMetadata).toBeUndefined();\n        expect(error.privateMetadataDescription).toBeUndefined();\n        expect(error.metadata).toEqual({\n          foo: 'bar'\n        });\n      });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "only notifies the user once for a given 'privateMetadataRequestName'",
            "suites": [
                "Reporter",
                ".reportFailedAssertion(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 380,
                "column": 78
            },
            "line": 380,
            "code": "      it(\"only notifies the user once for a given 'privateMetadataRequestName'\", () => {\n        let fakeStorage = {};\n        spyOn(global.localStorage, 'setItem').andCallFake((key, value) => fakeStorage[key] = value);\n        spyOn(global.localStorage, 'getItem').andCallFake(key => fakeStorage[key]);\n        error.privateMetadataRequestName = 'foo';\n        reporter.reportFailedAssertion(error);\n        expect(atom.notifications.addInfo).toHaveBeenCalled();\n        atom.notifications.addInfo.reset();\n        reporter.reportFailedAssertion(error);\n        expect(atom.notifications.addInfo).not.toHaveBeenCalled();\n        let error2 = new Error();\n        Error.captureStackTrace(error2);\n        error2.privateMetadataDescription = 'Something about you';\n        error2.privateMetadata = {\n          baz: 'quux'\n        };\n        error2.privateMetadataRequestName = 'bar';\n        reporter.reportFailedAssertion(error2);\n        expect(atom.notifications.addInfo).toHaveBeenCalled();\n      });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "treats packages located in atom.packages.getPackageDirPaths as user packages",
            "suites": [
                "Reporter",
                ".reportFailedAssertion(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 401,
                "column": 84
            },
            "line": 401,
            "code": "    it('treats packages located in atom.packages.getPackageDirPaths as user packages', () => {\n      mockActivePackages = [{\n        name: 'user-1',\n        path: '/Users/user/.atom/packages/user-1',\n        metadata: {\n          version: '1.0.0'\n        }\n      }, {\n        name: 'user-2',\n        path: '/Users/user/.atom/packages/user-2',\n        metadata: {\n          version: '1.2.0'\n        }\n      }, {\n        name: 'bundled-1',\n        path: '/Applications/Atom.app/Contents/Resources/app.asar/node_modules/bundled-1',\n        metadata: {\n          version: '1.0.0'\n        }\n      }, {\n        name: 'bundled-2',\n        path: '/Applications/Atom.app/Contents/Resources/app.asar/node_modules/bundled-2',\n        metadata: {\n          version: '1.2.0'\n        }\n      }];\n      const packageDirPaths = ['/Users/user/.atom/packages'];\n      spyOn(atom.packages, 'getPackageDirPaths').andReturn(packageDirPaths);\n      let error = new Error();\n      Error.captureStackTrace(error);\n      reporter.reportFailedAssertion(error);\n      expect(error.metadata.userPackages).toEqual({\n        'user-1': '1.0.0',\n        'user-2': '1.2.0'\n      });\n      expect(error.metadata.bundledPackages).toEqual({\n        'bundled-1': '1.0.0',\n        'bundled-2': '1.2.0'\n      });\n    });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "adds previous error messages and assertion failures to the reported metadata",
            "suites": [
                "Reporter",
                ".reportFailedAssertion(error)",
                "when the error object has `privateMetadata` and `privateMetadataDescription` fields"
            ],
            "updatePoint": {
                "line": 441,
                "column": 84
            },
            "line": 441,
            "code": "    it('adds previous error messages and assertion failures to the reported metadata', () => {\n      reporter.reportPreviousErrors = true;\n      reporter.reportUncaughtException(new Error('A'));\n      reporter.reportUncaughtException(new Error('B'));\n      reporter.reportFailedAssertion(new Error('X'));\n      reporter.reportFailedAssertion(new Error('Y'));\n      reporter.reportFailedAssertion(new Error('C'));\n      expect(requests.length).toBe(5);\n      const lastRequest = requests[requests.length - 1];\n      const body = JSON.parse(lastRequest.body);\n      expect(body.events[0].metaData.previousErrors).toEqual(['A', 'B']);\n      expect(body.events[0].metaData.previousAssertionFailures).toEqual(['X', 'Y']);\n    });",
            "file": "reporter-spec.js",
            "skipped": false,
            "dir": "packages/exception-reporting/spec"
        },
        {
            "name": "shows a list of all diff hunks",
            "suites": [
                "git-diff:toggle-diff-list"
            ],
            "updatePoint": {
                "line": 28,
                "column": 36
            },
            "line": 28,
            "code": "  it('shows a list of all diff hunks', () => {\n    diffListView = document.querySelector('.diff-list-view ol');\n    expect(diffListView.textContent).toBe('while (items.length > 0) {a-9,1 +9,1');\n  });",
            "file": "diff-list-view-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "moves the cursor to the selected hunk",
            "suites": [
                "git-diff:toggle-diff-list"
            ],
            "updatePoint": {
                "line": 32,
                "column": 43
            },
            "line": 32,
            "code": "  it('moves the cursor to the selected hunk', () => {\n    editor.setCursorBufferPosition([0, 0]);\n    atom.commands.dispatch(document.querySelector('.diff-list-view'), 'core:confirm');\n    expect(editor.getCursorBufferPosition()).toEqual([8, 4]);\n  });",
            "file": "diff-list-view-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "doesn't mark the editor",
            "suites": [
                "GitDiff package",
                "when the editor has no changes"
            ],
            "updatePoint": {
                "line": 35,
                "column": 31
            },
            "line": 35,
            "code": "    it(\"doesn't mark the editor\", () => {\n      waitsFor(() => screenUpdates > 0);\n      runs(() => expect(editor.getMarkers().length).toBe(0));\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "highlights the modified lines",
            "suites": [
                "GitDiff package",
                "when the editor has modified lines"
            ],
            "updatePoint": {
                "line": 41,
                "column": 37
            },
            "line": 41,
            "code": "    it('highlights the modified lines', () => {\n      expect(editorElement.querySelectorAll('.git-line-modified').length).toBe(0);\n      editor.insertText('a');\n      advanceClock(editor.getBuffer().stoppedChangingDelay);\n      waitsFor(() => editor.getMarkers().length > 0);\n      runs(() => {\n        expect(editorElement.querySelectorAll('.git-line-modified').length).toBe(1);\n        expect(editorElement.querySelector('.git-line-modified')).toHaveData('buffer-row', 0);\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "highlights the added lines",
            "suites": [
                "GitDiff package",
                "when the editor has added lines"
            ],
            "updatePoint": {
                "line": 53,
                "column": 34
            },
            "line": 53,
            "code": "    it('highlights the added lines', () => {\n      expect(editorElement.querySelectorAll('.git-line-added').length).toBe(0);\n      editor.moveToEndOfLine();\n      editor.insertNewline();\n      editor.insertText('a');\n      advanceClock(editor.getBuffer().stoppedChangingDelay);\n      waitsFor(() => editor.getMarkers().length > 0);\n      runs(() => {\n        expect(editorElement.querySelectorAll('.git-line-added').length).toBe(1);\n        expect(editorElement.querySelector('.git-line-added')).toHaveData('buffer-row', 1);\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "highlights the line preceeding the deleted lines",
            "suites": [
                "GitDiff package",
                "when the editor has removed lines"
            ],
            "updatePoint": {
                "line": 67,
                "column": 56
            },
            "line": 67,
            "code": "    it('highlights the line preceeding the deleted lines', () => {\n      expect(editorElement.querySelectorAll('.git-line-added').length).toBe(0);\n      editor.setCursorBufferPosition([5]);\n      editor.deleteLine();\n      advanceClock(editor.getBuffer().stoppedChangingDelay);\n      waitsFor(() => editor.getMarkers().length > 0);\n      runs(() => {\n        expect(editorElement.querySelectorAll('.git-line-removed').length).toBe(1);\n        expect(editorElement.querySelector('.git-line-removed')).toHaveData('buffer-row', 4);\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "highlights the line preceeding the deleted lines",
            "suites": [
                "GitDiff package",
                "when the editor has removed the first line"
            ],
            "updatePoint": {
                "line": 80,
                "column": 56
            },
            "line": 80,
            "code": "    it('highlights the line preceeding the deleted lines', () => {\n      expect(editorElement.querySelectorAll('.git-line-added').length).toBe(0);\n      editor.setCursorBufferPosition([0, 0]);\n      editor.deleteLine();\n      advanceClock(editor.getBuffer().stoppedChangingDelay);\n      waitsFor(() => editor.getMarkers().length > 0);\n      runs(() => {\n        expect(editorElement.querySelectorAll('.git-previous-line-removed').length).toBe(1);\n        expect(editorElement.querySelector('.git-previous-line-removed')).toHaveData('buffer-row', 0);\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "removes the diff highlight",
            "suites": [
                "GitDiff package",
                "when a modified line is restored to the HEAD version contents"
            ],
            "updatePoint": {
                "line": 93,
                "column": 34
            },
            "line": 93,
            "code": "    it('removes the diff highlight', () => {\n      expect(editorElement.querySelectorAll('.git-line-modified').length).toBe(0);\n      editor.insertText('a');\n      advanceClock(editor.getBuffer().stoppedChangingDelay);\n      waitsFor(() => editorElement.querySelectorAll('.git-line-modified').length > 0);\n      runs(() => {\n        expect(editorElement.querySelectorAll('.git-line-modified').length).toBe(1);\n        editor.backspace();\n        advanceClock(editor.getBuffer().stoppedChangingDelay);\n      });\n      waitsFor(() => editorElement.querySelectorAll('.git-line-modified').length < 1);\n      runs(() => {\n        expect(editorElement.querySelectorAll('.git-line-modified').length).toBe(0);\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "highlights the changed lines",
            "suites": [
                "GitDiff package",
                "when a modified file is opened"
            ],
            "updatePoint": {
                "line": 110,
                "column": 36
            },
            "line": 110,
            "code": "    it('highlights the changed lines', () => {\n      fs.writeFileSync(path.join(projectPath, 'sample.txt'), 'Some different text.');\n      waitsForPromise(() => atom.workspace.open(path.join(projectPath, 'sample.txt')));\n      runs(() => {\n        editor = atom.workspace.getActiveTextEditor();\n        editorElement = editor.getElement();\n      });\n      waitsFor(() => editor.getMarkers().length > 0);\n      runs(() => {\n        expect(editorElement.querySelectorAll('.git-line-modified').length).toBe(1);\n        expect(editorElement.querySelector('.git-line-modified')).toHaveData('buffer-row', 0);\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "doesn't try to use the destroyed git repository",
            "suites": [
                "GitDiff package",
                "when the project paths change"
            ],
            "updatePoint": {
                "line": 125,
                "column": 55
            },
            "line": 125,
            "code": "    it(\"doesn't try to use the destroyed git repository\", () => {\n      editor.deleteLine();\n      atom.project.setPaths([temp.mkdirSync('no-repository')]);\n      advanceClock(editor.getBuffer().stoppedChangingDelay);\n      waitsFor(() => editor.getMarkers().length === 0);\n      runs(() => {\n        expect(editor.getMarkers().length).toBe(0);\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "moves the cursor to first character of the next/previous diff line",
            "suites": [
                "GitDiff package",
                "move-to-next-diff/move-to-previous-diff events"
            ],
            "updatePoint": {
                "line": 136,
                "column": 74
            },
            "line": 136,
            "code": "    it('moves the cursor to first character of the next/previous diff line', () => {\n      editor.insertText('a');\n      waitsFor(() => editor.getMarkers().length > 0);\n      runs(() => {\n        editor.setCursorBufferPosition([5]);\n        editor.deleteLine();\n        advanceClock(editor.getBuffer().stoppedChangingDelay);\n        editor.setCursorBufferPosition([0]);\n        atom.commands.dispatch(editorElement, 'git-diff:move-to-next-diff');\n        expect(editor.getCursorBufferPosition()).toEqual([4, 4]);\n        atom.commands.dispatch(editorElement, 'git-diff:move-to-previous-diff');\n        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "wraps around to the first/last diff in the file",
            "suites": [
                "GitDiff package",
                "move-to-next-diff/move-to-previous-diff events"
            ],
            "updatePoint": {
                "line": 150,
                "column": 55
            },
            "line": 150,
            "code": "    it('wraps around to the first/last diff in the file', () => {\n      editor.insertText('a');\n      waitsFor(() => editor.getMarkers().length > 0);\n      runs(() => {\n        editor.setCursorBufferPosition([5]);\n        editor.deleteLine();\n        advanceClock(editor.getBuffer().stoppedChangingDelay);\n        editor.setCursorBufferPosition([0]);\n        atom.commands.dispatch(editorElement, 'git-diff:move-to-next-diff');\n        expect(editor.getCursorBufferPosition().toArray()).toEqual([4, 4]);\n        atom.commands.dispatch(editorElement, 'git-diff:move-to-next-diff');\n        expect(editor.getCursorBufferPosition().toArray()).toEqual([0, 0]);\n        atom.commands.dispatch(editorElement, 'git-diff:move-to-previous-diff');\n        expect(editor.getCursorBufferPosition().toArray()).toEqual([4, 4]);\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "does not wraps around to the first/last diff in the file",
            "suites": [
                "GitDiff package",
                "move-to-next-diff/move-to-previous-diff events",
                "when the wrapAroundOnMoveToDiff config option is false"
            ],
            "updatePoint": {
                "line": 168,
                "column": 66
            },
            "line": 168,
            "code": "      it('does not wraps around to the first/last diff in the file', () => {\n        editor.insertText('a');\n        editor.setCursorBufferPosition([5]);\n        editor.deleteLine();\n        advanceClock(editor.getBuffer().stoppedChangingDelay);\n        waitsFor(() => editor.getMarkers().length > 0);\n        runs(() => {\n          editor.setCursorBufferPosition([0]);\n          atom.commands.dispatch(editorElement, 'git-diff:move-to-next-diff');\n          expect(editor.getCursorBufferPosition()).toEqual([4, 4]);\n          atom.commands.dispatch(editorElement, 'git-diff:move-to-next-diff');\n          expect(editor.getCursorBufferPosition()).toEqual([4, 4]);\n          atom.commands.dispatch(editorElement, 'git-diff:move-to-previous-diff');\n          expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n          atom.commands.dispatch(editorElement, 'git-diff:move-to-previous-diff');\n          expect(editor.getCursorBufferPosition()).toEqual([0, 0]);\n        });\n      });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "the gutter has a git-diff-icon class",
            "suites": [
                "GitDiff package",
                "when the showIconsInEditorGutter config option is true"
            ],
            "updatePoint": {
                "line": 192,
                "column": 44
            },
            "line": 192,
            "code": "    it('the gutter has a git-diff-icon class', () => {\n      waitsFor(() => screenUpdates > 0);\n      runs(() => {\n        expect(editorElement.querySelector('.gutter')).toHaveClass('git-diff-icon');\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "keeps the git-diff-icon class when editor.showLineNumbers is toggled",
            "suites": [
                "GitDiff package",
                "when the showIconsInEditorGutter config option is true"
            ],
            "updatePoint": {
                "line": 198,
                "column": 76
            },
            "line": 198,
            "code": "    it('keeps the git-diff-icon class when editor.showLineNumbers is toggled', () => {\n      waitsFor(() => screenUpdates > 0);\n      runs(() => {\n        atom.config.set('editor.showLineNumbers', false);\n        expect(editorElement.querySelector('.gutter')).not.toHaveClass('git-diff-icon');\n        atom.config.set('editor.showLineNumbers', true);\n        expect(editorElement.querySelector('.gutter')).toHaveClass('git-diff-icon');\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "removes the git-diff-icon class when the showIconsInEditorGutter config option set to false",
            "suites": [
                "GitDiff package",
                "when the showIconsInEditorGutter config option is true"
            ],
            "updatePoint": {
                "line": 207,
                "column": 99
            },
            "line": 207,
            "code": "    it('removes the git-diff-icon class when the showIconsInEditorGutter config option set to false', () => {\n      waitsFor(() => screenUpdates > 0);\n      runs(() => {\n        atom.config.set('git-diff.showIconsInEditorGutter', false);\n        expect(editorElement.querySelector('.gutter')).not.toHaveClass('git-diff-icon');\n      });\n    });",
            "file": "git-diff-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "removes all registered command hooks after deactivation.",
            "suites": [
                "git-diff",
                "When the module is deactivated"
            ],
            "updatePoint": {
                "line": 23,
                "column": 64
            },
            "line": 23,
            "code": "    it('removes all registered command hooks after deactivation.', () => {\n      waitsForPromise(() => atom.packages.activatePackage('git-diff'));\n      waitsForPromise(() => atom.packages.deactivatePackage('git-diff'));\n      runs(() => {\n        // NOTE: don't use enable and disable from the Public API.\n        expect(atom.packages.isPackageActive('git-diff')).toBe(false);\n        atom.commands.findCommands({\n          target: element\n        }).filter(({\n          name\n        }) => commands.includes(name)).forEach(command => expect(commands).not.toContain(command.name));\n      });\n    });",
            "file": "init-spec.js",
            "skipped": false,
            "dir": "packages/git-diff/spec"
        },
        {
            "name": "adds a modal panel",
            "suites": [
                "GoToLine",
                "when go-to-line:toggle is triggered"
            ],
            "updatePoint": {
                "line": 25,
                "column": 26
            },
            "line": 25,
            "code": "    it('adds a modal panel', () => {\n      expect(goToLine.panel.isVisible()).toBeFalsy();\n      atom.commands.dispatch(editorView, 'go-to-line:toggle');\n      expect(goToLine.panel.isVisible()).toBeTruthy();\n    });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "only allows 0-9 and the colon character to be entered in the mini editor",
            "suites": [
                "GoToLine",
                "when entering a line number"
            ],
            "updatePoint": {
                "line": 32,
                "column": 80
            },
            "line": 32,
            "code": "    it('only allows 0-9 and the colon character to be entered in the mini editor', () => {\n      expect(goToLine.miniEditor.getText()).toBe('');\n      goToLine.miniEditor.insertText('a');\n      expect(goToLine.miniEditor.getText()).toBe('');\n      goToLine.miniEditor.insertText('path/file.txt:56');\n      expect(goToLine.miniEditor.getText()).toBe('');\n      goToLine.miniEditor.insertText(':');\n      expect(goToLine.miniEditor.getText()).toBe(':');\n      goToLine.miniEditor.setText('');\n      goToLine.miniEditor.insertText('4');\n      expect(goToLine.miniEditor.getText()).toBe('4');\n    });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "automatically scrolls to the desired line",
            "suites": [
                "GoToLine",
                "when typing line numbers (auto-navigation)"
            ],
            "updatePoint": {
                "line": 46,
                "column": 49
            },
            "line": 46,
            "code": "    it('automatically scrolls to the desired line', () => {\n      goToLine.miniEditor.insertText('19');\n      expect(editor.getCursorBufferPosition()).toEqual([18, 0]);\n    });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "automatically scrolls to the desired line and column",
            "suites": [
                "GoToLine",
                "when typing line and column numbers (auto-navigation)"
            ],
            "updatePoint": {
                "line": 52,
                "column": 60
            },
            "line": 52,
            "code": "    it('automatically scrolls to the desired line and column', () => {\n      goToLine.miniEditor.insertText('3:8');\n      expect(editor.getCursorBufferPosition()).toEqual([2, 7]);\n    });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "moves the cursor to the column number of the line specified",
            "suites": [
                "GoToLine",
                "when entering a line number and column number"
            ],
            "updatePoint": {
                "line": 58,
                "column": 67
            },
            "line": 58,
            "code": "    it('moves the cursor to the column number of the line specified', () => {\n      expect(goToLine.miniEditor.getText()).toBe('');\n      goToLine.miniEditor.insertText('3:14');\n      atom.commands.dispatch(goToLine.miniEditor.element, 'core:confirm');\n      expect(editor.getCursorBufferPosition()).toEqual([2, 13]);\n    });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "centers the selected line",
            "suites": [
                "GoToLine",
                "when entering a line number and column number"
            ],
            "updatePoint": {
                "line": 64,
                "column": 33
            },
            "line": 64,
            "code": "    it('centers the selected line', () => {\n      goToLine.miniEditor.insertText('45:4');\n      atom.commands.dispatch(goToLine.miniEditor.element, 'core:confirm');\n      const rowsPerPage = editor.getRowsPerPage();\n      const currentRow = editor.getCursorBufferPosition().row;\n      expect(editor.getFirstVisibleScreenRow()).toBe(Math.ceil(currentRow - rowsPerPage / 2));\n      expect(editor.getLastVisibleScreenRow()).toBe(currentRow + Math.floor(rowsPerPage / 2));\n    });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "moves the cursor position to the first character of the last line",
            "suites": [
                "GoToLine",
                "when entering a line number greater than the number of rows in the buffer"
            ],
            "updatePoint": {
                "line": 74,
                "column": 73
            },
            "line": 74,
            "code": "    it('moves the cursor position to the first character of the last line', () => {\n      atom.commands.dispatch(editorView, 'go-to-line:toggle');\n      expect(goToLine.panel.isVisible()).toBeTruthy();\n      expect(goToLine.miniEditor.getText()).toBe('');\n      goToLine.miniEditor.insertText('78');\n      atom.commands.dispatch(goToLine.miniEditor.element, 'core:confirm');\n      expect(goToLine.panel.isVisible()).toBeFalsy();\n      expect(editor.getCursorBufferPosition()).toEqual([77, 0]);\n    });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "moves the cursor position to the last character of the specified line",
            "suites": [
                "GoToLine",
                "when entering a column number greater than the number in the specified line"
            ],
            "updatePoint": {
                "line": 85,
                "column": 77
            },
            "line": 85,
            "code": "    it('moves the cursor position to the last character of the specified line', () => {\n      atom.commands.dispatch(editorView, 'go-to-line:toggle');\n      expect(goToLine.panel.isVisible()).toBeTruthy();\n      expect(goToLine.miniEditor.getText()).toBe('');\n      goToLine.miniEditor.insertText('3:43');\n      atom.commands.dispatch(goToLine.miniEditor.element, 'core:confirm');\n      expect(goToLine.panel.isVisible()).toBeFalsy();\n      expect(editor.getCursorBufferPosition()).toEqual([2, 39]);\n    });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "moves the cursor to the first character of the line",
            "suites": [
                "GoToLine",
                "when core:confirm is triggered",
                "when a line number has been entered"
            ],
            "updatePoint": {
                "line": 97,
                "column": 61
            },
            "line": 97,
            "code": "      it('moves the cursor to the first character of the line', () => {\n        goToLine.miniEditor.insertText('3');\n        atom.commands.dispatch(goToLine.miniEditor.element, 'core:confirm');\n        expect(editor.getCursorBufferPosition()).toEqual([2, 4]);\n      });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "unfolds all folds containing the given row",
            "suites": [
                "GoToLine",
                "when core:confirm is triggered",
                "when the line number entered is nested within foldes"
            ],
            "updatePoint": {
                "line": 104,
                "column": 52
            },
            "line": 104,
            "code": "      it('unfolds all folds containing the given row', () => {\n        expect(editor.indentationForBufferRow(9)).toEqual(3);\n        editor.foldAll();\n        expect(editor.screenRowForBufferRow(9)).toEqual(0);\n        goToLine.miniEditor.insertText('10');\n        atom.commands.dispatch(goToLine.miniEditor.element, 'core:confirm');\n        expect(editor.getCursorBufferPosition()).toEqual([9, 6]);\n      });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "closes the view and does not update the cursor position",
            "suites": [
                "GoToLine",
                "when no line number has been entered"
            ],
            "updatePoint": {
                "line": 115,
                "column": 63
            },
            "line": 115,
            "code": "    it('closes the view and does not update the cursor position', () => {\n      atom.commands.dispatch(editorView, 'go-to-line:toggle');\n      expect(goToLine.panel.isVisible()).toBeTruthy();\n      atom.commands.dispatch(goToLine.miniEditor.element, 'core:confirm');\n      expect(goToLine.panel.isVisible()).toBeFalsy();\n      expect(editor.getCursorBufferPosition()).toEqual([1, 0]);\n    });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "navigates to the column of the current line",
            "suites": [
                "GoToLine",
                "when no line number has been entered, but a column number has been entered"
            ],
            "updatePoint": {
                "line": 124,
                "column": 51
            },
            "line": 124,
            "code": "    it('navigates to the column of the current line', () => {\n      atom.commands.dispatch(editorView, 'go-to-line:toggle');\n      expect(goToLine.panel.isVisible()).toBeTruthy();\n      goToLine.miniEditor.insertText('4:1');\n      atom.commands.dispatch(goToLine.miniEditor.element, 'core:confirm');\n      expect(goToLine.panel.isVisible()).toBeFalsy();\n      expect(editor.getCursorBufferPosition()).toEqual([3, 0]);\n      atom.commands.dispatch(editorView, 'go-to-line:toggle');\n      expect(goToLine.panel.isVisible()).toBeTruthy();\n      goToLine.miniEditor.insertText(':19');\n      atom.commands.dispatch(goToLine.miniEditor.element, 'core:confirm');\n      expect(goToLine.panel.isVisible()).toBeFalsy();\n      expect(editor.getCursorBufferPosition()).toEqual([3, 18]);\n    });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "closes the view and does not update the cursor position",
            "suites": [
                "GoToLine",
                "when core:cancel is triggered"
            ],
            "updatePoint": {
                "line": 140,
                "column": 63
            },
            "line": 140,
            "code": "    it('closes the view and does not update the cursor position', () => {\n      atom.commands.dispatch(editorView, 'go-to-line:toggle');\n      expect(goToLine.panel.isVisible()).toBeTruthy();\n      atom.commands.dispatch(goToLine.miniEditor.element, 'core:cancel');\n      expect(goToLine.panel.isVisible()).toBeFalsy();\n      expect(editor.getCursorBufferPosition()).toEqual([1, 0]);\n    });",
            "file": "go-to-line-spec.js",
            "skipped": false,
            "dir": "packages/go-to-line/spec"
        },
        {
            "name": "displays a list of all the available grammars",
            "suites": [
                "GrammarSelector",
                "when grammar-selector:show is triggered"
            ],
            "updatePoint": {
                "line": 23,
                "column": 109
            },
            "line": 23,
            "code": "  describe('when grammar-selector:show is triggered', () => it('displays a list of all the available grammars', async () => {\n    const grammarView = (await getGrammarView(editor)).element; // -1 for removing nullGrammar, +1 for adding \"Auto Detect\"\n    // Tree-sitter names the regex and JSDoc grammars\n\n    expect(grammarView.querySelectorAll('li').length).toBe(atom.grammars.getGrammars({\n      includeTreeSitter: true\n    }).filter(g => g.name).length);\n    expect(grammarView.querySelectorAll('li')[0].textContent).toBe('Auto Detect');\n    expect(grammarView.textContent.includes('source.a')).toBe(false);\n    grammarView.querySelectorAll('li').forEach(li => expect(li.textContent).not.toBe(atom.grammars.nullGrammar.name));\n    expect(grammarView.textContent.includes('Tree-sitter')).toBe(true); // check we are showing and labelling Tree-sitter grammars\n  }));",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "sets the new grammar on the editor",
            "suites": [
                "GrammarSelector",
                "when a grammar is selected"
            ],
            "updatePoint": {
                "line": 35,
                "column": 85
            },
            "line": 35,
            "code": "  describe('when a grammar is selected', () => it('sets the new grammar on the editor', async () => {\n    const grammarView = await getGrammarView(editor);\n    grammarView.props.didConfirmSelection(textGrammar);\n    expect(editor.getGrammar()).toBe(textGrammar);\n  }));",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "restores the auto-detected grammar on the editor",
            "suites": [
                "GrammarSelector",
                "when auto-detect is selected"
            ],
            "updatePoint": {
                "line": 40,
                "column": 101
            },
            "line": 40,
            "code": "  describe('when auto-detect is selected', () => it('restores the auto-detected grammar on the editor', async () => {\n    let grammarView = await getGrammarView(editor);\n    grammarView.props.didConfirmSelection(textGrammar);\n    expect(editor.getGrammar()).toBe(textGrammar);\n    grammarView = await getGrammarView(editor);\n    grammarView.props.didConfirmSelection(grammarView.items[0]);\n    expect(editor.getGrammar()).toBe(jsGrammar);\n  }));",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "displays Auto Detect as the selected grammar",
            "suites": [
                "GrammarSelector",
                "when the editor's current grammar is the null grammar"
            ],
            "updatePoint": {
                "line": 48,
                "column": 122
            },
            "line": 48,
            "code": "  describe(\"when the editor's current grammar is the null grammar\", () => it('displays Auto Detect as the selected grammar', async () => {\n    editor.setGrammar(atom.grammars.nullGrammar);\n    const grammarView = (await getGrammarView(editor)).element;\n    expect(grammarView.querySelector('li.active').textContent).toBe('Auto Detect');\n  }));",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "sets the new grammar on the editor",
            "suites": [
                "GrammarSelector",
                "when editor is untitled"
            ],
            "updatePoint": {
                "line": 53,
                "column": 82
            },
            "line": 53,
            "code": "  describe('when editor is untitled', () => it('sets the new grammar on the editor', async () => {\n    editor = await atom.workspace.open();\n    expect(editor.getGrammar()).not.toBe(jsGrammar);\n    const grammarView = await getGrammarView(editor);\n    grammarView.props.didConfirmSelection(jsGrammar);\n    expect(editor.getGrammar()).toBe(jsGrammar);\n  }));",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "displays the name of the current grammar",
            "suites": [
                "GrammarSelector",
                "Status bar grammar label"
            ],
            "updatePoint": {
                "line": 72,
                "column": 48
            },
            "line": 72,
            "code": "    it('displays the name of the current grammar', () => {\n      expect(grammarStatus.querySelector('a').textContent).toBe('JavaScript');\n      expect(getTooltipText(grammarStatus)).toBe('File uses the JavaScript grammar');\n    });",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "displays Plain Text when the current grammar is the null grammar",
            "suites": [
                "GrammarSelector",
                "Status bar grammar label"
            ],
            "updatePoint": {
                "line": 76,
                "column": 72
            },
            "line": 76,
            "code": "    it('displays Plain Text when the current grammar is the null grammar', async () => {\n      editor.setGrammar(atom.grammars.nullGrammar);\n      await atom.views.getNextUpdatePromise();\n      expect(grammarStatus.querySelector('a').textContent).toBe('Plain Text');\n      expect(grammarStatus).toBeVisible();\n      expect(getTooltipText(grammarStatus)).toBe('File uses the Plain Text grammar');\n      editor.setGrammar(atom.grammars.grammarForScopeName('source.js'));\n      await atom.views.getNextUpdatePromise();\n      expect(grammarStatus.querySelector('a').textContent).toBe('JavaScript');\n      expect(grammarStatus).toBeVisible();\n    });",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "hides the label when the current grammar is null",
            "suites": [
                "GrammarSelector",
                "Status bar grammar label"
            ],
            "updatePoint": {
                "line": 87,
                "column": 56
            },
            "line": 87,
            "code": "    it('hides the label when the current grammar is null', async () => {\n      jasmine.attachToDOM(editor.getElement());\n      spyOn(editor, 'getGrammar').andReturn(null);\n      editor.setGrammar(atom.grammars.nullGrammar);\n      await atom.views.getNextUpdatePromise();\n      expect(grammarStatus.offsetHeight).toBe(0);\n    });",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "moves the item to the preferred side of the status bar",
            "suites": [
                "GrammarSelector",
                "Status bar grammar label",
                "when the grammar-selector.showOnRightSideOfStatusBar setting changes"
            ],
            "updatePoint": {
                "line": 94,
                "column": 149
            },
            "line": 94,
            "code": "    describe('when the grammar-selector.showOnRightSideOfStatusBar setting changes', () => it('moves the item to the preferred side of the status bar', () => {\n      expect(statusBar.getLeftTiles().map(tile => tile.getItem())).toContain(grammarStatus);\n      expect(statusBar.getRightTiles().map(tile => tile.getItem())).not.toContain(grammarStatus);\n      atom.config.set('grammar-selector.showOnRightSideOfStatusBar', true);\n      expect(statusBar.getLeftTiles().map(tile => tile.getItem())).not.toContain(grammarStatus);\n      expect(statusBar.getRightTiles().map(tile => tile.getItem())).toContain(grammarStatus);\n      atom.config.set('grammar-selector.showOnRightSideOfStatusBar', false);\n      expect(statusBar.getLeftTiles().map(tile => tile.getItem())).toContain(grammarStatus);\n      expect(statusBar.getRightTiles().map(tile => tile.getItem())).not.toContain(grammarStatus);\n    }));",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "displays the new grammar of the editor",
            "suites": [
                "GrammarSelector",
                "Status bar grammar label",
                "when the editor's grammar changes"
            ],
            "updatePoint": {
                "line": 104,
                "column": 98
            },
            "line": 104,
            "code": "    describe(\"when the editor's grammar changes\", () => it('displays the new grammar of the editor', async () => {\n      editor.setGrammar(atom.grammars.grammarForScopeName('text.plain'));\n      await atom.views.getNextUpdatePromise();\n      expect(grammarStatus.querySelector('a').textContent).toBe('Plain Text');\n      expect(getTooltipText(grammarStatus)).toBe('File uses the Plain Text grammar');\n      editor.setGrammar(atom.grammars.grammarForScopeName('source.a'));\n      await atom.views.getNextUpdatePromise();\n      expect(grammarStatus.querySelector('a').textContent).toBe('source.a');\n      expect(getTooltipText(grammarStatus)).toBe('File uses the source.a grammar');\n    }));",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "shows only the Tree-sitter if true and both exist",
            "suites": [
                "GrammarSelector",
                "Status bar grammar label",
                "when toggling hideDuplicateTextMateGrammars"
            ],
            "updatePoint": {
                "line": 115,
                "column": 59
            },
            "line": 115,
            "code": "      it('shows only the Tree-sitter if true and both exist', async () => {\n        // the main JS grammar has both a TextMate and Tree-sitter implementation\n        atom.config.set('grammar-selector.hideDuplicateTextMateGrammars', true);\n        const grammarView = await getGrammarView(editor);\n        const observedNames = new Set();\n        grammarView.element.querySelectorAll('li').forEach(li => {\n          const name = li.getAttribute('data-grammar');\n          expect(observedNames.has(name)).toBe(false);\n          observedNames.add(name);\n        }); // check the seen JS is actually the Tree-sitter one\n\n        const list = atom.workspace.getModalPanels()[0].item;\n\n        for (const item of list.items) {\n          if (item.name === 'JavaScript') {\n            expect(item.constructor.name === 'TreeSitterGrammar');\n          }\n        }\n      });",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "shows both if false",
            "suites": [
                "GrammarSelector",
                "Status bar grammar label",
                "when toggling hideDuplicateTextMateGrammars"
            ],
            "updatePoint": {
                "line": 134,
                "column": 29
            },
            "line": 134,
            "code": "      it('shows both if false', async () => {\n        await atom.packages.activatePackage('language-c'); // punctuation making it sort wrong\n\n        atom.config.set('grammar-selector.hideDuplicateTextMateGrammars', false);\n        await getGrammarView(editor);\n        let cppCount = 0;\n        const listItems = atom.workspace.getModalPanels()[0].item.items;\n\n        for (let i = 0; i < listItems.length; i++) {\n          const grammar = listItems[i];\n          const name = grammar.name;\n\n          if (cppCount === 0 && name === 'C++') {\n            expect(grammar.constructor.name).toBe('TreeSitterGrammar'); // first C++ entry should be Tree-sitter\n\n            cppCount++;\n          } else if (cppCount === 1) {\n            expect(name).toBe('C++');\n            expect(grammar.constructor.name).toBe('Grammar'); // immediate next grammar should be the TextMate version\n\n            cppCount++;\n          } else {\n            expect(name).not.toBe('C++'); // there should not be any other C++ grammars\n          }\n        }\n\n        expect(cppCount).toBe(2); // ensure we actually saw both grammars\n      });",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "adds a label to identify it as Tree-sitter",
            "suites": [
                "GrammarSelector",
                "Status bar grammar label",
                "for every Tree-sitter grammar"
            ],
            "updatePoint": {
                "line": 164,
                "column": 52
            },
            "line": 164,
            "code": "      it('adds a label to identify it as Tree-sitter', async () => {\n        const grammarView = await getGrammarView(editor);\n        const elements = grammarView.element.querySelectorAll('li');\n        const listItems = atom.workspace.getModalPanels()[0].item.items;\n\n        for (let i = 0; i < listItems.length; i++) {\n          if (listItems[i].constructor.name === 'TreeSitterGrammar') {\n            expect(elements[i].childNodes[1].childNodes[0].className.startsWith('grammar-selector-parser')).toBe(true);\n          }\n        }\n      });",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "shows the grammar selector modal",
            "suites": [
                "GrammarSelector",
                "Status bar grammar label",
                "when clicked"
            ],
            "updatePoint": {
                "line": 176,
                "column": 71
            },
            "line": 176,
            "code": "    describe('when clicked', () => it('shows the grammar selector modal', () => {\n      const eventHandler = jasmine.createSpy('eventHandler');\n      atom.commands.add(editor.getElement(), 'grammar-selector:show', eventHandler);\n      grammarStatus.click();\n      expect(eventHandler).toHaveBeenCalled();\n    }));",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "removes the view",
            "suites": [
                "GrammarSelector",
                "Status bar grammar label",
                "when the package is deactivated"
            ],
            "updatePoint": {
                "line": 182,
                "column": 74
            },
            "line": 182,
            "code": "    describe('when the package is deactivated', () => it('removes the view', () => {\n      spyOn(grammarTile, 'destroy');\n      atom.packages.deactivatePackage('grammar-selector');\n      expect(grammarTile.destroy).toHaveBeenCalled();\n    }));",
            "file": "grammar-selector-spec.js",
            "skipped": false,
            "dir": "packages/grammar-selector/spec"
        },
        {
            "name": "delays rendering incompatible packages until the end of the tick",
            "suites": [
                "IncompatiblePackagesComponent",
                "when packages have not finished loading"
            ],
            "updatePoint": {
                "line": 86,
                "column": 72
            },
            "line": 86,
            "code": "    it('delays rendering incompatible packages until the end of the tick', () => {\n      waitsForPromise(async () => {\n        let component = new IncompatiblePackagesComponent({\n          getActivePackages: () => [],\n          getLoadedPackages: () => packages\n        });\n        let {\n          element\n        } = component;\n        expect(element.querySelectorAll('.incompatible-package').length).toEqual(0);\n        await etchScheduler.getNextUpdatePromise();\n        expect(element.querySelectorAll('.incompatible-package').length).toBeGreaterThan(0);\n      });\n    });",
            "file": "incompatible-packages-component-spec.js",
            "skipped": false,
            "dir": "packages/incompatible-packages/spec"
        },
        {
            "name": "does not render incompatible packages or the rebuild button",
            "suites": [
                "IncompatiblePackagesComponent",
                "when there are no incompatible packages"
            ],
            "updatePoint": {
                "line": 102,
                "column": 67
            },
            "line": 102,
            "code": "    it('does not render incompatible packages or the rebuild button', () => {\n      waitsForPromise(async () => {\n        expect(packages[2].isCompatible()).toBe(true);\n        let compatiblePackages = [packages[2]];\n        let component = new IncompatiblePackagesComponent({\n          getActivePackages: () => compatiblePackages,\n          getLoadedPackages: () => compatiblePackages\n        });\n        let {\n          element\n        } = component;\n        await etchScheduler.getNextUpdatePromise();\n        expect(element.querySelectorAll('.incompatible-package').length).toBe(0);\n        expect(element.querySelector('button')).toBeNull();\n      });\n    });",
            "file": "incompatible-packages-component-spec.js",
            "skipped": false,
            "dir": "packages/incompatible-packages/spec"
        },
        {
            "name": "renders them with failed build status and error output",
            "suites": [
                "IncompatiblePackagesComponent",
                "when some packages previously failed to rebuild"
            ],
            "updatePoint": {
                "line": 120,
                "column": 62
            },
            "line": 120,
            "code": "    it('renders them with failed build status and error output', () => {\n      waitsForPromise(async () => {\n        packages[1].getBuildFailureOutput = function () {\n          return 'The build failed';\n        };\n\n        let component = new IncompatiblePackagesComponent({\n          getActivePackages: () => packages,\n          getLoadedPackages: () => packages\n        });\n        let {\n          element\n        } = component;\n        await etchScheduler.getNextUpdatePromise();\n        let packageElement = element.querySelector('.incompatible-package:nth-child(2)');\n        expect(packageElement.querySelector('.badge').textContent).toBe('Rebuild Failed');\n        expect(packageElement.querySelector('pre').textContent).toBe('The build failed');\n      });\n    });",
            "file": "incompatible-packages-component-spec.js",
            "skipped": false,
            "dir": "packages/incompatible-packages/spec"
        },
        {
            "name": "renders incompatible packages and the rebuild button",
            "suites": [
                "IncompatiblePackagesComponent",
                "when there are incompatible packages"
            ],
            "updatePoint": {
                "line": 141,
                "column": 60
            },
            "line": 141,
            "code": "    it('renders incompatible packages and the rebuild button', () => {\n      waitsForPromise(async () => {\n        let component = new IncompatiblePackagesComponent({\n          getActivePackages: () => packages,\n          getLoadedPackages: () => packages\n        });\n        let {\n          element\n        } = component;\n        await etchScheduler.getNextUpdatePromise();\n        expect(element.querySelectorAll('.incompatible-package').length).toEqual(2);\n        expect(element.querySelector('button')).not.toBeNull();\n      });\n    });",
            "file": "incompatible-packages-component-spec.js",
            "skipped": false,
            "dir": "packages/incompatible-packages/spec"
        },
        {
            "name": "rebuilds every incompatible package, updating each package's view with status",
            "suites": [
                "IncompatiblePackagesComponent",
                "when there are incompatible packages",
                "when the \"Rebuild All\" button is clicked"
            ],
            "updatePoint": {
                "line": 156,
                "column": 87
            },
            "line": 156,
            "code": "      it(\"rebuilds every incompatible package, updating each package's view with status\", () => {\n        waitsForPromise(async () => {\n          let component = new IncompatiblePackagesComponent({\n            getActivePackages: () => packages,\n            getLoadedPackages: () => packages\n          });\n          let {\n            element\n          } = component;\n          jasmine.attachToDOM(element);\n          await etchScheduler.getNextUpdatePromise();\n          component.refs.rebuildButton.dispatchEvent(new CustomEvent('click', {\n            bubbles: true\n          }));\n          await etchScheduler.getNextUpdatePromise(); // view update\n\n          expect(component.refs.rebuildButton.disabled).toBe(true);\n          expect(packages[0].resolveRebuild).toBeDefined();\n          expect(element.querySelector('.incompatible-package:nth-child(1) .badge').textContent).toBe('Rebuilding');\n          expect(element.querySelector('.incompatible-package:nth-child(2) .badge')).toBeNull();\n          packages[0].resolveRebuild({\n            code: 0\n          }); // simulate rebuild success\n\n          await etchScheduler.getNextUpdatePromise(); // view update\n\n          expect(packages[1].resolveRebuild).toBeDefined();\n          expect(element.querySelector('.incompatible-package:nth-child(1) .badge').textContent).toBe('Rebuild Succeeded');\n          expect(element.querySelector('.incompatible-package:nth-child(2) .badge').textContent).toBe('Rebuilding');\n          packages[1].resolveRebuild({\n            code: 12,\n            stderr: 'This is an error from the test!'\n          }); // simulate rebuild failure\n\n          await etchScheduler.getNextUpdatePromise(); // view update\n\n          expect(element.querySelector('.incompatible-package:nth-child(1) .badge').textContent).toBe('Rebuild Succeeded');\n          expect(element.querySelector('.incompatible-package:nth-child(2) .badge').textContent).toBe('Rebuild Failed');\n          expect(element.querySelector('.incompatible-package:nth-child(2) pre').textContent).toBe('This is an error from the test!');\n        });\n      });",
            "file": "incompatible-packages-component-spec.js",
            "skipped": false,
            "dir": "packages/incompatible-packages/spec"
        },
        {
            "name": "displays a prompt to reload Atom when the packages finish rebuilding",
            "suites": [
                "IncompatiblePackagesComponent",
                "when there are incompatible packages",
                "when the \"Rebuild All\" button is clicked"
            ],
            "updatePoint": {
                "line": 197,
                "column": 78
            },
            "line": 197,
            "code": "      it('displays a prompt to reload Atom when the packages finish rebuilding', () => {\n        waitsForPromise(async () => {\n          let component = new IncompatiblePackagesComponent({\n            getActivePackages: () => packages,\n            getLoadedPackages: () => packages\n          });\n          let {\n            element\n          } = component;\n          jasmine.attachToDOM(element);\n          await etchScheduler.getNextUpdatePromise(); // view update\n\n          component.refs.rebuildButton.dispatchEvent(new CustomEvent('click', {\n            bubbles: true\n          }));\n          expect(packages[0].resolveRebuild({\n            code: 0\n          }));\n          await new Promise(global.setImmediate);\n          expect(packages[1].resolveRebuild({\n            code: 0\n          }));\n          await etchScheduler.getNextUpdatePromise(); // view update\n\n          expect(component.refs.reloadButton).toBeDefined();\n          expect(element.querySelector('.alert').textContent).toMatch(/2 of 2/);\n          spyOn(atom, 'reload');\n          component.refs.reloadButton.dispatchEvent(new CustomEvent('click', {\n            bubbles: true\n          }));\n          expect(atom.reload).toHaveBeenCalled();\n        });\n      });",
            "file": "incompatible-packages-component-spec.js",
            "skipped": false,
            "dir": "packages/incompatible-packages/spec"
        },
        {
            "name": "opens the settings panel for the package",
            "suites": [
                "IncompatiblePackagesComponent",
                "when there are incompatible packages",
                "when the \"Package Settings\" button is clicked"
            ],
            "updatePoint": {
                "line": 232,
                "column": 50
            },
            "line": 232,
            "code": "      it('opens the settings panel for the package', () => {\n        waitsForPromise(async () => {\n          let component = new IncompatiblePackagesComponent({\n            getActivePackages: () => packages,\n            getLoadedPackages: () => packages\n          });\n          let {\n            element\n          } = component;\n          jasmine.attachToDOM(element);\n          await etchScheduler.getNextUpdatePromise();\n          spyOn(atom.workspace, 'open');\n          element.querySelector('.incompatible-package:nth-child(2) button').dispatchEvent(new CustomEvent('click', {\n            bubbles: true\n          }));\n          expect(atom.workspace.open).toHaveBeenCalledWith('atom://config/packages/incompatible-2');\n        });\n      });",
            "file": "incompatible-packages-component-spec.js",
            "skipped": false,
            "dir": "packages/incompatible-packages/spec"
        },
        {
            "name": "adds an icon to the status bar",
            "suites": [
                "Incompatible packages",
                "when there are packages with incompatible native modules"
            ],
            "updatePoint": {
                "line": 35,
                "column": 38
            },
            "line": 35,
            "code": "    it('adds an icon to the status bar', () => {\n      let statusBarIcon = statusBar.getRightTiles()[0].getItem();\n      expect(statusBarIcon.constructor).toBe(StatusIconComponent);\n    });",
            "file": "incompatible-packages-spec.js",
            "skipped": false,
            "dir": "packages/incompatible-packages/spec"
        },
        {
            "name": "displays the incompatible packages view in a pane",
            "suites": [
                "Incompatible packages",
                "when there are packages with incompatible native modules",
                "clicking the icon"
            ],
            "updatePoint": {
                "line": 40,
                "column": 59
            },
            "line": 40,
            "code": "      it('displays the incompatible packages view in a pane', () => {\n        let statusBarIcon = statusBar.getRightTiles()[0].getItem();\n        statusBarIcon.element.dispatchEvent(new MouseEvent('click'));\n        let activePaneItem;\n        waitsFor(() => activePaneItem = atom.workspace.getActivePaneItem());\n        runs(() => {\n          expect(activePaneItem.constructor).toBe(IncompatiblePackagesComponent);\n        });\n      });",
            "file": "incompatible-packages-spec.js",
            "skipped": false,
            "dir": "packages/incompatible-packages/spec"
        },
        {
            "name": "does not add an icon to the status bar",
            "suites": [
                "Incompatible packages",
                "when there are no packages with incompatible native modules"
            ],
            "updatePoint": {
                "line": 55,
                "column": 46
            },
            "line": 55,
            "code": "    it('does not add an icon to the status bar', () => {\n      let statusBarItemClasses = statusBar.getRightTiles().map(tile => tile.getItem().className);\n      expect(statusBarItemClasses).not.toContain('incompatible-packages');\n    });",
            "file": "incompatible-packages-spec.js",
            "skipped": false,
            "dir": "packages/incompatible-packages/spec"
        },
        {
            "name": "converts the file to LF line endings",
            "suites": [
                "line ending selector",
                "Commands",
                "When \"line-ending-selector:convert-to-LF\" is run"
            ],
            "updatePoint": {
                "line": 37,
                "column": 46
            },
            "line": 37,
            "code": "      it('converts the file to LF line endings', () => {\n        editorElement.focus();\n        atom.commands.dispatch(document.activeElement, 'line-ending-selector:convert-to-LF');\n        expect(editor.getText()).toBe('Hello\\nGoodbye\\nMixed\\n');\n      });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "converts the file to CRLF line endings",
            "suites": [
                "line ending selector",
                "Commands",
                "When \"line-ending-selector:convert-to-LF\" is run"
            ],
            "updatePoint": {
                "line": 44,
                "column": 48
            },
            "line": 44,
            "code": "      it('converts the file to CRLF line endings', () => {\n        editorElement.focus();\n        atom.commands.dispatch(document.activeElement, 'line-ending-selector:convert-to-CRLF');\n        expect(editor.getText()).toBe('Hello\\r\\nGoodbye\\r\\nMixed\\r\\n');\n      });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "uses the default line endings for the platform",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "when an empty file is opened"
            ],
            "updatePoint": {
                "line": 53,
                "column": 56
            },
            "line": 53,
            "code": "      it('uses the default line endings for the platform', () => {\n        waitsFor(done => {\n          spyOn(helpers, 'getProcessPlatform').andReturn('win32');\n          atom.workspace.open('').then(editor => {\n            const subscription = lineEndingTile.onDidChange(() => {\n              subscription.dispose();\n              expect(lineEndingTile.element.textContent).toBe('CRLF');\n              expect(editor.getBuffer().getPreferredLineEnding()).toBe('\\r\\n');\n              expect(getTooltipText(lineEndingTile.element)).toBe('File uses CRLF (Windows) line endings');\n              done();\n            });\n          });\n        });\n        waitsFor(done => {\n          helpers.getProcessPlatform.andReturn('darwin');\n          atom.workspace.open('').then(editor => {\n            const subscription = lineEndingTile.onDidChange(() => {\n              subscription.dispose();\n              expect(lineEndingTile.element.textContent).toBe('LF');\n              expect(editor.getBuffer().getPreferredLineEnding()).toBe('\\n');\n              expect(getTooltipText(lineEndingTile.element)).toBe('File uses LF (Unix) line endings');\n              done();\n            });\n          });\n        });\n      });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "uses LF line endings, regardless of the platform",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "when an empty file is opened",
                "when the \"defaultLineEnding\" setting is set to \"LF\""
            ],
            "updatePoint": {
                "line": 83,
                "column": 60
            },
            "line": 83,
            "code": "        it('uses LF line endings, regardless of the platform', () => {\n          waitsFor(done => {\n            spyOn(helpers, 'getProcessPlatform').andReturn('win32');\n            atom.workspace.open('').then(editor => {\n              lineEndingTile.onDidChange(() => {\n                expect(lineEndingTile.element.textContent).toBe('LF');\n                expect(editor.getBuffer().getPreferredLineEnding()).toBe('\\n');\n                done();\n              });\n            });\n          });\n        });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "uses CRLF line endings, regardless of the platform",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "when an empty file is opened",
                "when the \"defaultLineEnding\" setting is set to \"CRLF\""
            ],
            "updatePoint": {
                "line": 100,
                "column": 62
            },
            "line": 100,
            "code": "        it('uses CRLF line endings, regardless of the platform', () => {\n          waitsFor(done => {\n            atom.workspace.open('').then(editor => {\n              lineEndingTile.onDidChange(() => {\n                expect(lineEndingTile.element.textContent).toBe('CRLF');\n                expect(editor.getBuffer().getPreferredLineEnding()).toBe('\\r\\n');\n                done();\n              });\n            });\n          });\n        });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "displays \"CRLF\" as the line ending",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "when a file is opened that contains only CRLF line endings"
            ],
            "updatePoint": {
                "line": 114,
                "column": 44
            },
            "line": 114,
            "code": "      it('displays \"CRLF\" as the line ending', () => {\n        waitsFor(done => {\n          atom.workspace.open('windows-endings.md').then(() => {\n            lineEndingTile.onDidChange(() => {\n              expect(lineEndingTile.element.textContent).toBe('CRLF');\n              done();\n            });\n          });\n        });\n      });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "displays \"LF\" as the line ending",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "when a file is opened that contains only LF line endings"
            ],
            "updatePoint": {
                "line": 126,
                "column": 42
            },
            "line": 126,
            "code": "      it('displays \"LF\" as the line ending', () => {\n        waitsFor(done => {\n          atom.workspace.open('unix-endings.md').then(editor => {\n            lineEndingTile.onDidChange(() => {\n              expect(lineEndingTile.element.textContent).toBe('LF');\n              expect(editor.getBuffer().getPreferredLineEnding()).toBe(null);\n              done();\n            });\n          });\n        });\n      });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "displays \"Mixed\" as the line ending",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "when a file is opened that contains mixed line endings"
            ],
            "updatePoint": {
                "line": 139,
                "column": 45
            },
            "line": 139,
            "code": "      it('displays \"Mixed\" as the line ending', () => {\n        waitsFor(done => {\n          atom.workspace.open('mixed-endings.md').then(() => {\n            lineEndingTile.onDidChange(() => {\n              expect(lineEndingTile.element.textContent).toBe('Mixed');\n              done();\n            });\n          });\n        });\n      });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "opens the line ending selector modal for the text editor",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "clicking the tile",
                "when the text editor has focus"
            ],
            "updatePoint": {
                "line": 157,
                "column": 68
            },
            "line": 157,
            "code": "        it('opens the line ending selector modal for the text editor', () => {\n          atom.workspace.getCenter().activate();\n          const item = atom.workspace.getActivePaneItem();\n          expect(item.getFileName && item.getFileName()).toBe('unix-endings.md');\n          lineEndingTile.element.dispatchEvent(new MouseEvent('click', {}));\n          lineEndingModal = atom.workspace.getModalPanels()[0];\n          lineEndingSelector = lineEndingModal.getItem();\n          expect(lineEndingModal.isVisible()).toBe(true);\n          expect(lineEndingSelector.element.contains(document.activeElement)).toBe(true);\n          let listItems = lineEndingSelector.element.querySelectorAll('li');\n          expect(listItems[0].textContent).toBe('LF');\n          expect(listItems[1].textContent).toBe('CRLF');\n        });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "opens the line ending selector modal for the active text editor",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "clicking the tile",
                "when the text editor does not have focus"
            ],
            "updatePoint": {
                "line": 172,
                "column": 75
            },
            "line": 172,
            "code": "        it('opens the line ending selector modal for the active text editor', () => {\n          atom.workspace.getLeftDock().activate();\n          const item = atom.workspace.getActivePaneItem();\n          expect(item instanceof TextEditor).toBe(false);\n          lineEndingTile.element.dispatchEvent(new MouseEvent('click', {}));\n          lineEndingModal = atom.workspace.getModalPanels()[0];\n          lineEndingSelector = lineEndingModal.getItem();\n          expect(lineEndingModal.isVisible()).toBe(true);\n          expect(lineEndingSelector.element.contains(document.activeElement)).toBe(true);\n          let listItems = lineEndingSelector.element.querySelectorAll('li');\n          expect(listItems[0].textContent).toBe('LF');\n          expect(listItems[1].textContent).toBe('CRLF');\n        });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "changes the line endings in the buffer",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "clicking the tile",
                "when selecting a different line ending for the file"
            ],
            "updatePoint": {
                "line": 187,
                "column": 50
            },
            "line": 187,
            "code": "        it('changes the line endings in the buffer', () => {\n          lineEndingTile.element.dispatchEvent(new MouseEvent('click', {}));\n          lineEndingModal = atom.workspace.getModalPanels()[0];\n          lineEndingSelector = lineEndingModal.getItem();\n          const lineEndingChangedPromise = new Promise(resolve => {\n            lineEndingTile.onDidChange(() => {\n              expect(lineEndingTile.element.textContent).toBe('CRLF');\n              const editor = atom.workspace.getActiveTextEditor();\n              expect(editor.getText()).toBe('Hello\\r\\nGoodbye\\r\\nUnix\\r\\n');\n              expect(editor.getBuffer().getPreferredLineEnding()).toBe('\\r\\n');\n              resolve();\n            });\n          });\n          lineEndingSelector.refs.queryEditor.setText('CR');\n          lineEndingSelector.confirmSelection();\n          expect(lineEndingModal.isVisible()).toBe(false);\n          waitsForPromise(() => lineEndingChangedPromise);\n        });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "leaves the tile selection as-is",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "clicking the tile",
                "when modal is exited"
            ],
            "updatePoint": {
                "line": 207,
                "column": 43
            },
            "line": 207,
            "code": "        it('leaves the tile selection as-is', () => {\n          lineEndingTile.element.dispatchEvent(new MouseEvent('click', {}));\n          lineEndingModal = atom.workspace.getModalPanels()[0];\n          lineEndingSelector = lineEndingModal.getItem();\n          lineEndingSelector.cancelSelection();\n          expect(lineEndingTile.element.textContent).toBe('LF');\n        });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "displays no line ending in the status bar",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "closing the last text editor"
            ],
            "updatePoint": {
                "line": 217,
                "column": 51
            },
            "line": 217,
            "code": "      it('displays no line ending in the status bar', () => {\n        waitsForPromise(() => {\n          return atom.workspace.open('unix-endings.md').then(() => {\n            atom.workspace.getActivePane().destroy();\n            expect(lineEndingTile.element.textContent).toBe('');\n          });\n        });\n      });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "updates the line ending text in the tile",
            "suites": [
                "line ending selector",
                "Status bar tile",
                "when the buffer's line endings change"
            ],
            "updatePoint": {
                "line": 236,
                "column": 50
            },
            "line": 236,
            "code": "      it('updates the line ending text in the tile', () => {\n        let tileText = lineEndingTile.element.textContent;\n        let tileUpdateCount = 0;\n        Object.defineProperty(lineEndingTile.element, 'textContent', {\n          get() {\n            return tileText;\n          },\n\n          set(text) {\n            tileUpdateCount++;\n            tileText = text;\n          }\n\n        });\n        expect(lineEndingTile.element.textContent).toBe('LF');\n        expect(getTooltipText(lineEndingTile.element)).toBe('File uses LF (Unix) line endings');\n        waitsFor(done => {\n          editor.setTextInBufferRange([[0, 0], [0, 0]], '... ');\n          editor.setTextInBufferRange([[0, Infinity], [1, 0]], '\\r\\n', {\n            normalizeLineEndings: false\n          });\n          lineEndingTile.onDidChange(done);\n        });\n        runs(() => {\n          expect(tileUpdateCount).toBe(1);\n          expect(lineEndingTile.element.textContent).toBe('Mixed');\n          expect(getTooltipText(lineEndingTile.element)).toBe('File uses mixed line endings');\n        });\n        waitsFor(done => {\n          atom.commands.dispatch(editor.getElement(), 'line-ending-selector:convert-to-CRLF');\n          lineEndingTile.onDidChange(done);\n        });\n        runs(() => {\n          expect(tileUpdateCount).toBe(2);\n          expect(lineEndingTile.element.textContent).toBe('CRLF');\n          expect(getTooltipText(lineEndingTile.element)).toBe('File uses CRLF (Windows) line endings');\n        });\n        waitsFor(done => {\n          atom.commands.dispatch(editor.getElement(), 'line-ending-selector:convert-to-LF');\n          lineEndingTile.onDidChange(done);\n        });\n        runs(() => {\n          expect(tileUpdateCount).toBe(3);\n          expect(lineEndingTile.element.textContent).toBe('LF');\n        });\n        runs(() => {\n          editor.setTextInBufferRange([[0, 0], [0, 0]], '\\n');\n        });\n        waits(100);\n        runs(() => {\n          expect(tileUpdateCount).toBe(3);\n        });\n      });",
            "file": "line-ending-selector-spec.js",
            "skipped": false,
            "dir": "packages/line-ending-selector/spec"
        },
        {
            "name": "opens the link using the 'open' command",
            "suites": [
                "link package",
                "when the cursor is on a link"
            ],
            "updatePoint": {
                "line": 14,
                "column": 47
            },
            "line": 14,
            "code": "    it(\"opens the link using the 'open' command\", async () => {\n      await atom.workspace.open('sample.md');\n      const editor = atom.workspace.getActiveTextEditor();\n      editor.setText('// \"http://github.com\"');\n      spyOn(shell, 'openExternal');\n      atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n      expect(shell.openExternal).not.toHaveBeenCalled();\n      editor.setCursorBufferPosition([0, 4]);\n      atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n      expect(shell.openExternal).toHaveBeenCalled();\n      expect(shell.openExternal.argsForCall[0][0]).toBe('http://github.com');\n      shell.openExternal.reset();\n      editor.setCursorBufferPosition([0, 8]);\n      atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n      expect(shell.openExternal).toHaveBeenCalled();\n      expect(shell.openExternal.argsForCall[0][0]).toBe('http://github.com');\n      shell.openExternal.reset();\n      editor.setCursorBufferPosition([0, 21]);\n      atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n      expect(shell.openExternal).toHaveBeenCalled();\n      expect(shell.openExternal.argsForCall[0][0]).toBe('http://github.com');\n    }); // only works in Atom >= 1.33.0",
            "file": "link-spec.js",
            "skipped": false,
            "dir": "packages/link/spec"
        },
        {
            "name": "opens an 'atom:' link",
            "suites": [
                "link package",
                "when the cursor is on a link"
            ],
            "updatePoint": {
                "line": 42,
                "column": 31
            },
            "line": 42,
            "code": "      it(\"opens an 'atom:' link\", async () => {\n        await atom.workspace.open('sample.md');\n        const editor = atom.workspace.getActiveTextEditor();\n        editor.setText('// \"atom://core/open/file?filename=sample.js&line=1&column=2\"');\n        spyOn(shell, 'openExternal');\n        atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n        expect(shell.openExternal).not.toHaveBeenCalled();\n        editor.setCursorBufferPosition([0, 4]);\n        atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n        expect(shell.openExternal).toHaveBeenCalled();\n        expect(shell.openExternal.argsForCall[0][0]).toBe('atom://core/open/file?filename=sample.js&line=1&column=2');\n        shell.openExternal.reset();\n        editor.setCursorBufferPosition([0, 8]);\n        atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n        expect(shell.openExternal).toHaveBeenCalled();\n        expect(shell.openExternal.argsForCall[0][0]).toBe('atom://core/open/file?filename=sample.js&line=1&column=2');\n        shell.openExternal.reset();\n        editor.setCursorBufferPosition([0, 60]);\n        atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n        expect(shell.openExternal).toHaveBeenCalled();\n        expect(shell.openExternal.argsForCall[0][0]).toBe('atom://core/open/file?filename=sample.js&line=1&column=2');\n      });",
            "file": "link-spec.js",
            "skipped": false,
            "dir": "packages/link/spec"
        },
        {
            "name": "opens the named url",
            "suites": [
                "link package",
                "when the cursor is on a link",
                "when the cursor is on a [name][url-name] style markdown link"
            ],
            "updatePoint": {
                "line": 66,
                "column": 106
            },
            "line": 66,
            "code": "    describe('when the cursor is on a [name][url-name] style markdown link', () => it('opens the named url', async () => {\n      await atom.workspace.open('README.md');\n      const editor = atom.workspace.getActiveTextEditor();\n      editor.setText(`\\\nyou should [click][here]\nyou should not [click][her]\n\n[here]: http://github.com\\\n`);\n      spyOn(shell, 'openExternal');\n      editor.setCursorBufferPosition([0, 0]);\n      atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n      expect(shell.openExternal).not.toHaveBeenCalled();\n      editor.setCursorBufferPosition([0, 20]);\n      atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n      expect(shell.openExternal).toHaveBeenCalled();\n      expect(shell.openExternal.argsForCall[0][0]).toBe('http://github.com');\n      shell.openExternal.reset();\n      editor.setCursorBufferPosition([1, 24]);\n      atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n      expect(shell.openExternal).not.toHaveBeenCalled();\n    }));",
            "file": "link-spec.js",
            "skipped": false,
            "dir": "packages/link/spec"
        },
        {
            "name": "does not open non http/https/atom links",
            "suites": [
                "link package",
                "when the cursor is on a link",
                "when the cursor is on a [name][url-name] style markdown link"
            ],
            "updatePoint": {
                "line": 88,
                "column": 47
            },
            "line": 88,
            "code": "    it('does not open non http/https/atom links', async () => {\n      await atom.workspace.open('sample.md');\n      const editor = atom.workspace.getActiveTextEditor();\n      editor.setText('// ftp://github.com\\n');\n      spyOn(shell, 'openExternal');\n      atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n      expect(shell.openExternal).not.toHaveBeenCalled();\n      editor.setCursorBufferPosition([0, 5]);\n      atom.commands.dispatch(atom.views.getView(editor), 'link:open');\n      expect(shell.openExternal).not.toHaveBeenCalled();\n    });",
            "file": "link-spec.js",
            "skipped": false,
            "dir": "packages/link/spec"
        },
        {
            "name": "allows the font size to be set via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 6,
                "column": 47
            },
            "line": 6,
            "code": "  it('allows the font size to be set via config', () => {\n    expect(document.documentElement.style.fontSize).toBe('12px');\n    atom.config.set(`${themeName}.fontSize`, '10');\n    expect(document.documentElement.style.fontSize).toBe('10px');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-dark-ui/spec"
        },
        {
            "name": "allows the tab sizing to be set via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 11,
                "column": 48
            },
            "line": 11,
            "code": "  it('allows the tab sizing to be set via config', () => {\n    atom.config.set(`${themeName}.tabSizing`, 'Maximum');\n    expect(document.documentElement.getAttribute(`theme-${themeName}-tabsizing`)).toBe('maximum');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-dark-ui/spec"
        },
        {
            "name": "allows the tab sizing to be set via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 15,
                "column": 48
            },
            "line": 15,
            "code": "  it('allows the tab sizing to be set via config', () => {\n    atom.config.set(`${themeName}.tabSizing`, 'Minimum');\n    expect(document.documentElement.getAttribute(`theme-${themeName}-tabsizing`)).toBe('minimum');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-dark-ui/spec"
        },
        {
            "name": "allows the tab close button to be shown on the left via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 19,
                "column": 68
            },
            "line": 19,
            "code": "  it('allows the tab close button to be shown on the left via config', () => {\n    atom.config.set(`${themeName}.tabCloseButton`, 'Left');\n    expect(document.documentElement.getAttribute(`theme-${themeName}-tab-close-button`)).toBe('left');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-dark-ui/spec"
        },
        {
            "name": "allows the dock toggle buttons to be hidden via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 23,
                "column": 60
            },
            "line": 23,
            "code": "  it('allows the dock toggle buttons to be hidden via config', () => {\n    atom.config.set(`${themeName}.hideDockButtons`, true);\n    expect(document.documentElement.getAttribute(`theme-${themeName}-dock-buttons`)).toBe('hidden');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-dark-ui/spec"
        },
        {
            "name": "allows the tree-view headers to be sticky via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 27,
                "column": 58
            },
            "line": 27,
            "code": "  it('allows the tree-view headers to be sticky via config', () => {\n    atom.config.set(`${themeName}.stickyHeaders`, true);\n    expect(document.documentElement.getAttribute(`theme-${themeName}-sticky-headers`)).toBe('sticky');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-dark-ui/spec"
        },
        {
            "name": "allows the tree-view headers to not be sticky via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 31,
                "column": 62
            },
            "line": 31,
            "code": "  it('allows the tree-view headers to not be sticky via config', () => {\n    atom.config.set(`${themeName}.stickyHeaders`, false);\n    expect(document.documentElement.getAttribute(`theme-${themeName}-sticky-headers`)).toBe(null);\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-dark-ui/spec"
        },
        {
            "name": "allows the font size to be set via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 6,
                "column": 47
            },
            "line": 6,
            "code": "  it('allows the font size to be set via config', () => {\n    expect(document.documentElement.style.fontSize).toBe('12px');\n    atom.config.set(`${themeName}.fontSize`, '10');\n    expect(document.documentElement.style.fontSize).toBe('10px');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-light-ui/spec"
        },
        {
            "name": "allows the tab sizing to be set via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 11,
                "column": 48
            },
            "line": 11,
            "code": "  it('allows the tab sizing to be set via config', () => {\n    atom.config.set(`${themeName}.tabSizing`, 'Maximum');\n    expect(document.documentElement.getAttribute(`theme-${themeName}-tabsizing`)).toBe('maximum');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-light-ui/spec"
        },
        {
            "name": "allows the tab sizing to be set via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 15,
                "column": 48
            },
            "line": 15,
            "code": "  it('allows the tab sizing to be set via config', () => {\n    atom.config.set(`${themeName}.tabSizing`, 'Minimum');\n    expect(document.documentElement.getAttribute(`theme-${themeName}-tabsizing`)).toBe('minimum');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-light-ui/spec"
        },
        {
            "name": "allows the tab close button to be shown on the left via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 19,
                "column": 68
            },
            "line": 19,
            "code": "  it('allows the tab close button to be shown on the left via config', () => {\n    atom.config.set(`${themeName}.tabCloseButton`, 'Left');\n    expect(document.documentElement.getAttribute(`theme-${themeName}-tab-close-button`)).toBe('left');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-light-ui/spec"
        },
        {
            "name": "allows the dock toggle buttons to be hidden via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 23,
                "column": 60
            },
            "line": 23,
            "code": "  it('allows the dock toggle buttons to be hidden via config', () => {\n    atom.config.set(`${themeName}.hideDockButtons`, true);\n    expect(document.documentElement.getAttribute(`theme-${themeName}-dock-buttons`)).toBe('hidden');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-light-ui/spec"
        },
        {
            "name": "allows the tree-view headers to be sticky via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 27,
                "column": 58
            },
            "line": 27,
            "code": "  it('allows the tree-view headers to be sticky via config', () => {\n    atom.config.set(`${themeName}.stickyHeaders`, true);\n    expect(document.documentElement.getAttribute(`theme-${themeName}-sticky-headers`)).toBe('sticky');\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-light-ui/spec"
        },
        {
            "name": "allows the tree-view headers to not be sticky via config",
            "suites": [
                " theme"
            ],
            "updatePoint": {
                "line": 31,
                "column": 62
            },
            "line": 31,
            "code": "  it('allows the tree-view headers to not be sticky via config', () => {\n    atom.config.set(`${themeName}.stickyHeaders`, false);\n    expect(document.documentElement.getAttribute(`theme-${themeName}-sticky-headers`)).toBe(null);\n  });",
            "file": "theme-spec.js",
            "skipped": false,
            "dir": "packages/one-light-ui/spec"
        },
        {
            "name": "runs the `apm install` command",
            "suites": [
                "Update Package Dependencies",
                "updating package dependencies"
            ],
            "updatePoint": {
                "line": 36,
                "column": 38
            },
            "line": 36,
            "code": "    it('runs the `apm install` command', () => {\n      updatePackageDependencies.update();\n      expect(updatePackageDependencies.runBufferedProcess).toHaveBeenCalled();\n\n      if (process.platform !== 'win32') {\n        expect(command.endsWith('/apm')).toBe(true);\n      } else {\n        expect(command.endsWith('\\\\apm.cmd')).toBe(true);\n      }\n\n      expect(args).toEqual(['install', '--no-color']);\n      expect(options.cwd).toEqual(projectPath);\n    });",
            "file": "update-package-dependencies-spec.js",
            "skipped": false,
            "dir": "packages/update-package-dependencies/spec"
        },
        {
            "name": "only allows one apm process to be spawned at a time",
            "suites": [
                "Update Package Dependencies",
                "updating package dependencies"
            ],
            "updatePoint": {
                "line": 49,
                "column": 59
            },
            "line": 49,
            "code": "    it('only allows one apm process to be spawned at a time', () => {\n      updatePackageDependencies.update();\n      expect(updatePackageDependencies.runBufferedProcess.callCount).toBe(1);\n      updatePackageDependencies.update();\n      updatePackageDependencies.update();\n      expect(updatePackageDependencies.runBufferedProcess.callCount).toBe(1);\n      exit(0);\n      updatePackageDependencies.update();\n      expect(updatePackageDependencies.runBufferedProcess.callCount).toBe(2);\n    });",
            "file": "update-package-dependencies-spec.js",
            "skipped": false,
            "dir": "packages/update-package-dependencies/spec"
        },
        {
            "name": "sets NODE_ENV to development in order to install devDependencies",
            "suites": [
                "Update Package Dependencies",
                "updating package dependencies"
            ],
            "updatePoint": {
                "line": 59,
                "column": 72
            },
            "line": 59,
            "code": "    it('sets NODE_ENV to development in order to install devDependencies', () => {\n      updatePackageDependencies.update();\n      expect(options.env.NODE_ENV).toEqual('development');\n    });",
            "file": "update-package-dependencies-spec.js",
            "skipped": false,
            "dir": "packages/update-package-dependencies/spec"
        },
        {
            "name": "adds a status bar tile",
            "suites": [
                "Update Package Dependencies",
                "updating package dependencies"
            ],
            "updatePoint": {
                "line": 63,
                "column": 30
            },
            "line": 63,
            "code": "    it('adds a status bar tile', async () => {\n      const statusBar = await atom.packages.activatePackage('status-bar');\n      const activationPromise = atom.packages.activatePackage('update-package-dependencies');\n      atom.commands.dispatch(atom.views.getView(atom.workspace), 'update-package-dependencies:update');\n      const {\n        mainModule\n      } = await activationPromise;\n      mainModule.update();\n      let tile = statusBar.mainModule.statusBar.getRightTiles().find(tile => tile.item.matches('update-package-dependencies-status'));\n      expect(tile.item.classList.contains('update-package-dependencies-status')).toBe(true);\n      expect(tile.item.firstChild.classList.contains('loading')).toBe(true);\n      exit(0);\n      tile = statusBar.mainModule.statusBar.getRightTiles().find(tile => tile.item.matches('update-package-dependencies-status'));\n      expect(tile).toBeUndefined();\n    });",
            "file": "update-package-dependencies-spec.js",
            "skipped": false,
            "dir": "packages/update-package-dependencies/spec"
        },
        {
            "name": "uses the currently active one",
            "suites": [
                "Update Package Dependencies",
                "updating package dependencies",
                "when there are multiple project paths"
            ],
            "updatePoint": {
                "line": 80,
                "column": 39
            },
            "line": 80,
            "code": "      it('uses the currently active one', async () => {\n        await atom.workspace.open(path.join(projectPath, 'package.json'));\n        updatePackageDependencies.update();\n        expect(options.cwd).toEqual(projectPath);\n      });",
            "file": "update-package-dependencies-spec.js",
            "skipped": false,
            "dir": "packages/update-package-dependencies/spec"
        },
        {
            "name": "shows a success notification message",
            "suites": [
                "Update Package Dependencies",
                "updating package dependencies",
                "when the update succeeds"
            ],
            "updatePoint": {
                "line": 91,
                "column": 46
            },
            "line": 91,
            "code": "      it('shows a success notification message', () => {\n        const notification = atom.notifications.getNotifications()[0];\n        expect(notification.getType()).toEqual('success');\n        expect(notification.getMessage()).toEqual('Package dependencies updated');\n      });",
            "file": "update-package-dependencies-spec.js",
            "skipped": false,
            "dir": "packages/update-package-dependencies/spec"
        },
        {
            "name": "shows a failure notification",
            "suites": [
                "Update Package Dependencies",
                "updating package dependencies",
                "when the update fails"
            ],
            "updatePoint": {
                "line": 103,
                "column": 38
            },
            "line": 103,
            "code": "      it('shows a failure notification', () => {\n        const notification = atom.notifications.getNotifications()[0];\n        expect(notification.getType()).toEqual('error');\n        expect(notification.getMessage()).toEqual('Failed to update package dependencies');\n        expect(notification.getDetail()).toEqual('oh bother');\n        expect(notification.isDismissable()).toBe(true);\n      });",
            "file": "update-package-dependencies-spec.js",
            "skipped": false,
            "dir": "packages/update-package-dependencies/spec"
        },
        {
            "name": "activates the package and updates package dependencies",
            "suites": [
                "Update Package Dependencies",
                "the `update-package-dependencies:update` command"
            ],
            "updatePoint": {
                "line": 114,
                "column": 62
            },
            "line": 114,
            "code": "    it('activates the package and updates package dependencies', async () => {\n      const activationPromise = atom.packages.activatePackage('update-package-dependencies');\n      atom.commands.dispatch(atom.views.getView(atom.workspace), 'update-package-dependencies:update');\n      const {\n        mainModule\n      } = await activationPromise;\n      expect(mainModule.update).toHaveBeenCalled();\n    });",
            "file": "update-package-dependencies-spec.js",
            "skipped": false,
            "dir": "packages/update-package-dependencies/spec"
        },
        {
            "name": "opens the telemetry consent pane and the welcome panes",
            "suites": [
                "Welcome",
                "when `core.telemetryConsent` is 'undecided'"
            ],
            "updatePoint": {
                "line": 21,
                "column": 62
            },
            "line": 21,
            "code": "    it('opens the telemetry consent pane and the welcome panes', () => {\n      const panes = atom.workspace.getCenter().getPanes();\n      assert.equal(panes.length, 2);\n      assert.equal(panes[0].getItems()[0].getTitle(), 'Telemetry Consent');\n      assert.equal(panes[0].getItems()[1].getTitle(), 'Welcome');\n      assert.equal(panes[1].getItems()[0].getTitle(), 'Welcome Guide');\n    });",
            "file": "welcome.test.js",
            "skipped": false,
            "dir": "packages/welcome/test"
        },
        {
            "name": "shows the welcome panes",
            "suites": [
                "Welcome",
                "when `core.telemetryConsent` is not `undecided`",
                "when activated for the first time"
            ],
            "updatePoint": {
                "line": 34,
                "column": 83
            },
            "line": 34,
            "code": "    describe('when activated for the first time', () => it('shows the welcome panes', () => {\n      const panes = atom.workspace.getCenter().getPanes();\n      assert.equal(panes.length, 2);\n      assert.equal(panes[0].getItems()[0].getTitle(), 'Welcome');\n      assert.equal(panes[1].getItems()[0].getTitle(), 'Welcome Guide');\n    }));",
            "file": "welcome.test.js",
            "skipped": false,
            "dir": "packages/welcome/test"
        },
        {
            "name": "shows the welcome buffer",
            "suites": [
                "Welcome",
                "when `core.telemetryConsent` is not `undecided`",
                "the welcome:show command"
            ],
            "updatePoint": {
                "line": 41,
                "column": 34
            },
            "line": 41,
            "code": "      it('shows the welcome buffer', async () => {\n        atom.workspace.getCenter().getPanes().map(pane => pane.destroy());\n        assert(!atom.workspace.getActivePaneItem());\n        const workspaceElement = atom.views.getView(atom.workspace);\n        atom.commands.dispatch(workspaceElement, 'welcome:show');\n        await conditionPromise(() => atom.workspace.getActivePaneItem());\n        const panes = atom.workspace.getCenter().getPanes();\n        assert.equal(panes.length, 2);\n        assert.equal(panes[0].getItems()[0].getTitle(), 'Welcome');\n      });",
            "file": "welcome.test.js",
            "skipped": false,
            "dir": "packages/welcome/test"
        },
        {
            "name": "remembers open sections",
            "suites": [
                "Welcome",
                "when `core.telemetryConsent` is not `undecided`",
                "deserializing the pane items",
                "when GuideView is deserialized"
            ],
            "updatePoint": {
                "line": 54,
                "column": 35
            },
            "line": 54,
            "code": "        it('remembers open sections', () => {\n          const panes = atom.workspace.getCenter().getPanes();\n          const guideView = panes[1].getItems()[0];\n          guideView.element.querySelector('details[data-section=\"snippets\"]').setAttribute('open', 'open');\n          guideView.element.querySelector('details[data-section=\"init-script\"]').setAttribute('open', 'open');\n          const state = guideView.serialize();\n          assert.deepEqual(state.openSections, ['init-script', 'snippets']);\n          const newGuideView = welcomePackage.createGuideView(state);\n          assert(!newGuideView.element.querySelector('details[data-section=\"packages\"]').hasAttribute('open'));\n          assert(newGuideView.element.querySelector('details[data-section=\"snippets\"]').hasAttribute('open'));\n          assert(newGuideView.element.querySelector('details[data-section=\"init-script\"]').hasAttribute('open'));\n        });",
            "file": "welcome.test.js",
            "skipped": false,
            "dir": "packages/welcome/test"
        },
        {
            "name": "captures expand and collapse events",
            "suites": [
                "Welcome",
                "when `core.telemetryConsent` is not `undecided`",
                "reporting events",
                "GuideView events"
            ],
            "updatePoint": {
                "line": 80,
                "column": 47
            },
            "line": 80,
            "code": "        it('captures expand and collapse events', () => {\n          guideView.element.querySelector('details[data-section=\"packages\"] summary').click();\n          assert.deepEqual(reportedEvents, [['expand-packages-section']]);\n          guideView.element.querySelector('details[data-section=\"packages\"]').setAttribute('open', 'open');\n          guideView.element.querySelector('details[data-section=\"packages\"] summary').click();\n          assert.deepEqual(reportedEvents, [['expand-packages-section'], ['collapse-packages-section']]);\n        });",
            "file": "welcome.test.js",
            "skipped": false,
            "dir": "packages/welcome/test"
        },
        {
            "name": "captures button events",
            "suites": [
                "Welcome",
                "when `core.telemetryConsent` is not `undecided`",
                "reporting events",
                "GuideView events"
            ],
            "updatePoint": {
                "line": 87,
                "column": 34
            },
            "line": 87,
            "code": "        it('captures button events', () => {\n          for (const detailElement of Array.from(guideView.element.querySelector('details'))) {\n            reportedEvents.length = 0;\n            const sectionName = detailElement.dataset.section;\n            const eventName = `clicked-${sectionName}-cta`;\n            const primaryButton = detailElement.querySelector('.btn-primary');\n\n            if (primaryButton) {\n              primaryButton.click();\n              assert.deepEqual(reportedEvents, [[eventName]]);\n            }\n          }\n        });",
            "file": "welcome.test.js",
            "skipped": false,
            "dir": "packages/welcome/test"
        },
        {
            "name": "sends all queued events",
            "suites": [
                "Welcome",
                "when `core.telemetryConsent` is not `undecided`",
                "when the reporter changes"
            ],
            "updatePoint": {
                "line": 102,
                "column": 75
            },
            "line": 102,
            "code": "    describe('when the reporter changes', () => it('sends all queued events', () => {\n      welcomePackage.reporterProxy.queue.length = 0;\n      const reporter1 = {\n        addCustomEvent(category, event) {\n          this.reportedEvents.push({\n            category,\n            ...event\n          });\n        },\n\n        reportedEvents: []\n      };\n      const reporter2 = {\n        addCustomEvent(category, event) {\n          this.reportedEvents.push({\n            category,\n            ...event\n          });\n        },\n\n        reportedEvents: []\n      };\n      welcomePackage.reporterProxy.sendEvent('foo', 'bar', 10);\n      welcomePackage.reporterProxy.sendEvent('foo2', 'bar2', 60);\n      welcomePackage.reporterProxy.setReporter(reporter1);\n      assert.deepEqual(reporter1.reportedEvents, [{\n        category: 'welcome-v1',\n        ea: 'foo',\n        el: 'bar',\n        ev: 10\n      }, {\n        category: 'welcome-v1',\n        ea: 'foo2',\n        el: 'bar2',\n        ev: 60\n      }]);\n      welcomePackage.consumeReporter(reporter2);\n      assert.deepEqual(reporter2.reportedEvents, []);\n    }));",
            "file": "welcome.test.js",
            "skipped": false,
            "dir": "packages/welcome/test"
        },
        {
            "name": "1.0 Query by selector",
            "suites": [
                "query selector",
                "basic"
            ],
            "updatePoint": {
                "line": 25,
                "column": 29
            },
            "line": 25,
            "code": "    it('1.0 Query by selector', () => {\n      const $els = $('li.item[data-role=\"red\"]');\n      const els = document.querySelectorAll('li.item[data-role=\"red\"]');\n      expect($els.length).to.equal(2);\n      [].forEach.call($els, function ($el, i) {\n        expect($el).to.equal(els[i]);\n      });\n    });",
            "file": "query.spec.js",
            "skipped": false,
            "dir": "spec/fixtures/git/repo-with-submodules/You-Dont-Need-jQuery/test"
        },
        {
            "name": "1.1 Query by class",
            "suites": [
                "query selector",
                "basic"
            ],
            "updatePoint": {
                "line": 33,
                "column": 26
            },
            "line": 33,
            "code": "    it('1.1 Query by class', () => {\n      const $els = $('.item');\n      const els = document.getElementsByClassName('item');\n      [].forEach.call($els, function ($el, i) {\n        expect($el).to.equal(els[i]);\n      });\n    });",
            "file": "query.spec.js",
            "skipped": false,
            "dir": "spec/fixtures/git/repo-with-submodules/You-Dont-Need-jQuery/test"
        },
        {
            "name": "1.2 Query by id",
            "suites": [
                "query selector",
                "basic"
            ],
            "updatePoint": {
                "line": 40,
                "column": 23
            },
            "line": 40,
            "code": "    it('1.2 Query by id', () => {\n      expect($('#nested-ul')[0]).to.equal(document.getElementById('nested-ul'));\n    });",
            "file": "query.spec.js",
            "skipped": false,
            "dir": "spec/fixtures/git/repo-with-submodules/You-Dont-Need-jQuery/test"
        },
        {
            "name": "1.3 Query by attribute",
            "suites": [
                "query selector",
                "basic"
            ],
            "updatePoint": {
                "line": 43,
                "column": 30
            },
            "line": 43,
            "code": "    it('1.3 Query by attribute', () => {\n      const $els = $('[data-role=\"blue\"]');\n      const els = document.querySelectorAll('[data-role=\"blue\"]');\n      expect($els.length).to.equal(2);\n      [].forEach.call($els, function ($el, i) {\n        expect($el).to.equal(els[i]);\n      });\n    });",
            "file": "query.spec.js",
            "skipped": false,
            "dir": "spec/fixtures/git/repo-with-submodules/You-Dont-Need-jQuery/test"
        },
        {
            "name": "1.4 Query in descendents",
            "suites": [
                "query selector",
                "basic"
            ],
            "updatePoint": {
                "line": 51,
                "column": 32
            },
            "line": 51,
            "code": "    it('1.4 Query in descendents', () => {\n      const $els = $('#query-selector-test1').find('.item');\n      const els = document.getElementById('query-selector-test1').querySelectorAll('.item');\n      expect($els.length).to.equal(4);\n      [].forEach.call($els, function ($el, i) {\n        expect($el).to.equal(els[i]);\n      });\n    });",
            "file": "query.spec.js",
            "skipped": false,
            "dir": "spec/fixtures/git/repo-with-submodules/You-Dont-Need-jQuery/test"
        }
    ],
    "badge": "atom__atom.svg"
}