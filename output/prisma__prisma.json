{"repo":"prisma/prisma","url":"https://github.com/prisma/prisma","branch":"main","configs":[{"package":"prisma","lang":"ts","dir":"packages/cli/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/client","lang":"ts","dir":"packages/client/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/debug","lang":"ts","dir":"packages/debug/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/engine-core","lang":"ts","dir":"packages/engine-core/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/generator-helper","lang":"ts","dir":"packages/generator-helper/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/integration-tests","lang":"js","dir":"packages/integration-tests/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/migrate","lang":"ts","dir":"packages/migrate/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@prisma/sdk","lang":"ts","dir":"packages/sdk/src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"introspection-engine","suites":["artificial-panic introspection"],"updatePoint":{"line":24,"column":26},"line":24,"code":"  it('introspection-engine', async () => {\n    ctx.fixture('artificial-panic')\n    expect.assertions(5)\n    process.env.FORCE_PANIC_INTROSPECTION_ENGINE = '1'\n\n    const command = new DbPull()\n    try {\n      await command.parse(['--print'])\n    } catch (e) {\n      expect(e).toMatchInlineSnapshot(`[/some/rust/path:0:0] This is the debugPanic artificial panic`)\n      expect(isRustPanic(e)).toBe(true)\n      expect(e.rustStack).toBeTruthy()\n      expect(e.schema).toMatchInlineSnapshot(`\n        // This is your Prisma schema file,\n        // learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n        generator client {\n          provider = \"prisma-client-js\"\n        }\n\n        datasource db {\n          provider = \"postgresql\"\n          url      = env(\"DATABASE_URL\")\n        }\n\n      `),\n        expect(e).toMatchObject({\n          area: 'INTROSPECTION_CLI',\n          schemaPath: undefined,\n        })\n    }\n  })","file":"artificial-panic.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"formatter","suites":["artificial-panic formatter"],"updatePoint":{"line":65,"column":15},"line":65,"code":"  it('formatter', async () => {\n    ctx.fixture('artificial-panic')\n    expect.assertions(5)\n    process.env.FORCE_PANIC_PRISMA_FMT = '1'\n\n    const command = new Format()\n    try {\n      await command.parse([])\n    } catch (e) {\n      expect(e).toMatchInlineSnapshot(`unreachable`)\n      expect(isRustPanic(e)).toBe(true)\n      expect(e.rustStack).toBeTruthy()\n      expect(e.schemaPath.replace(/\\\\/g, '/')) // replace due to Windows CI\n        .toContain('prisma/schema.prisma')\n      expect(e).toMatchObject({\n        schema: undefined,\n      })\n    }\n  })","file":"artificial-panic.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"get-config","suites":["artificial-panic get-config"],"updatePoint":{"line":93,"column":16},"line":93,"code":"  it('get-config', async () => {\n    ctx.fixture('artificial-panic')\n    expect.assertions(5)\n    process.env.FORCE_PANIC_QUERY_ENGINE_GET_CONFIG = '1'\n\n    const command = new Validate()\n    try {\n      await command.parse([])\n    } catch (e) {\n      expect(e).toMatchInlineSnapshot(`unreachable`)\n      expect(isRustPanic(e)).toBe(true)\n      expect(e.rustStack).toBeTruthy()\n      expect(e.schema).toMatchInlineSnapshot(`\n        // This is your Prisma schema file,\n        // learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n        generator client {\n          provider = \"prisma-client-js\"\n        }\n\n        datasource db {\n          provider = \"postgresql\"\n          url      = env(\"DATABASE_URL\")\n        }\n\n      `)\n      expect(e).toMatchObject({\n        schemaPath: undefined,\n      })\n    }\n  })","file":"artificial-panic.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"query-engine get-dmmf library","suites":["artificial-panic get-config"],"updatePoint":{"line":133,"column":35},"line":133,"code":"  it('query-engine get-dmmf library', async () => {\n    ctx.fixture('artificial-panic')\n    expect.assertions(5)\n    process.env.FORCE_PANIC_QUERY_ENGINE_GET_DMMF = '1'\n\n    const command = new Validate()\n    try {\n      await command.parse([])\n    } catch (e) {\n      expect(e).toMatchInlineSnapshot(`FORCE_PANIC_QUERY_ENGINE_GET_DMMF`)\n      expect(isRustPanic(e)).toBe(true)\n      expect(e.rustStack).toBeTruthy()\n      expect(e.schema).toMatchInlineSnapshot(`\n        // This is your Prisma schema file,\n        // learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n        generator client {\n          provider = \"prisma-client-js\"\n        }\n\n        datasource db {\n          provider = \"postgresql\"\n          url      = env(\"DATABASE_URL\")\n        }\n\n      `)\n      expect(e).toMatchObject({\n        schemaPath: undefined,\n      })\n    }\n  })","file":"artificial-panic.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"query-engine get-dmmf binary","suites":["artificial-panic get-config"],"updatePoint":{"line":173,"column":34},"line":173,"code":"  it('query-engine get-dmmf binary', async () => {\n    ctx.fixture('artificial-panic')\n    expect.assertions(5)\n    process.env.FORCE_PANIC_QUERY_ENGINE_GET_DMMF = '1'\n\n    const command = new Validate()\n    try {\n      await command.parse([])\n    } catch (e) {\n      expect(e).toMatchInlineSnapshot(\n        `Command failed with exit code 101: prisma-engines-path FORCE_PANIC_QUERY_ENGINE_GET_DMMF`,\n      )\n      expect(isRustPanic(e)).toBe(true)\n      expect(e.rustStack).toBeTruthy()\n      expect(e.schemaPath).toBeTruthy()\n      expect(e).toMatchObject({\n        schema: undefined,\n      })\n    }\n  })","file":"artificial-panic.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact --option [value]","suites":[],"updatePoint":{"line":7,"column":34},"line":7,"code":"it('should redact --option [value]', () => {\n  for (const option of SENSITIVE_CLI_OPTIONS) {\n    expect(redactCommandArray(['cmd', option, 'secret'])).toEqual(['cmd', option, '[redacted]'])\n  }\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact --option=[value]","suites":[],"updatePoint":{"line":13,"column":34},"line":13,"code":"it('should redact --option=[value]', () => {\n  for (const option of SENSITIVE_CLI_OPTIONS) {\n    expect(redactCommandArray(['cmd', `${option}=secret`])).toEqual(['cmd', `${option}=[redacted]`])\n  }\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a PostgreSQL connection string","suites":[],"updatePoint":{"line":19,"column":48},"line":19,"code":"it('should redact a PostgreSQL connection string', () => {\n  expect(redactCommandArray(['init', '--url', '\"postgresql://janedoe:mypassword@localhost:5432/mydb?schema=sample\"']))\n    .toMatchInlineSnapshot(`\n    Array [\n      init,\n      --url,\n      [redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a MySQL connection string","suites":[],"updatePoint":{"line":30,"column":43},"line":30,"code":"it('should redact a MySQL connection string', () => {\n  expect(\n    redactCommandArray([\n      'init',\n      `--url \"mysql://janedoe:mypassword@localhost:3306/mydb?connection_limit=5&socket_timeout\"`,\n    ]),\n  ).toMatchInlineSnapshot(`\n    Array [\n      init,\n      --url=[redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a MongoDB connection string","suites":[],"updatePoint":{"line":44,"column":45},"line":44,"code":"it('should redact a MongoDB connection string', () => {\n  expect(\n    redactCommandArray([\n      'init',\n      `--url \"mongodb+srv://root:<password>@cluster0.ab1cd.mongodb.net/myDatabase?retryWrites=true&w=majority\"`,\n    ]),\n  ).toMatchInlineSnapshot(`\n    Array [\n      init,\n      --url=[redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a SQLite connection string","suites":[],"updatePoint":{"line":58,"column":44},"line":58,"code":"it('should redact a SQLite connection string', () => {\n  expect(redactCommandArray(['init', '--url', '\"file:./dev.db\"'])).toMatchInlineSnapshot(`\n    Array [\n      init,\n      --url,\n      [redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a SQL Server connection string","suites":[],"updatePoint":{"line":68,"column":48},"line":68,"code":"it('should redact a SQL Server connection string', () => {\n  expect(\n    redactCommandArray([\n      'init',\n      `--url=\"sqlserver://localhost:1433;initial catalog=sample;user=sa;password=mypassword;\"`,\n    ]),\n  ).toMatchInlineSnapshot(`\n    Array [\n      init,\n      --url=[redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a path with for example --schema","suites":[],"updatePoint":{"line":82,"column":50},"line":82,"code":"it('should redact a path with for example --schema', () => {\n  expect(redactCommandArray(['cmd', '--schema', '../../../../directory/my_schema.prisma'])).toMatchInlineSnapshot(`\n    Array [\n      cmd,\n      --schema,\n      [redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should redact a name with for example --name","suites":[],"updatePoint":{"line":92,"column":48},"line":92,"code":"it('should redact a name with for example --name', () => {\n  expect(redactCommandArray(['cmd', '--name', '1234_my_name'])).toMatchInlineSnapshot(`\n    Array [\n      cmd,\n      --name,\n      [redacted],\n    ]\n  `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should read data from Prisma schema","suites":[],"updatePoint":{"line":102,"column":39},"line":102,"code":"it('should read data from Prisma schema', async () => {\n  ctx.fixture('checkpoint-read-schema')\n\n  await expect(tryToReadDataFromSchema('./schema.prisma')).resolves.toMatchInlineSnapshot(`\n          Object {\n            schemaGeneratorsProviders: Array [\n              prisma-client-js,\n              something,\n            ],\n            schemaPreviewFeatures: Array [\n              extendedIndexes,\n            ],\n            schemaProvider: sqlite,\n          }\n        `)\n})","file":"checkpoint.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"no params should return help","suites":[],"updatePoint":{"line":65,"column":32},"line":65,"code":"it('no params should return help', async () => {\n  const spy = jest.spyOn(cliInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await cliInstance.parse([])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"commands/CLI.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"wrong flag","suites":[],"updatePoint":{"line":73,"column":14},"line":73,"code":"it('wrong flag', async () => {\n  const spy = jest.spyOn(cliInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await cliInstance.parse(['--something'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"commands/CLI.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"help flag","suites":[],"updatePoint":{"line":81,"column":13},"line":81,"code":"it('help flag', async () => {\n  const spy = jest.spyOn(cliInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await cliInstance.parse(['--help'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"commands/CLI.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"unknown command","suites":[],"updatePoint":{"line":89,"column":19},"line":89,"code":"it('unknown command', async () => {\n  await expect(cliInstance.parse(['doesnotexist'])).resolves.toThrowError()\n})","file":"commands/CLI.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"introspect should include deprecation warning","suites":[],"updatePoint":{"line":93,"column":49},"line":93,"code":"it('introspect should include deprecation warning', async () => {\n  const result = cliInstance.parse(['introspect'])\n\n  await expect(result).rejects.toMatchInlineSnapshot(`\n          Could not find a schema.prisma file that is required for this command.\n          You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n        `)\n  expect(ctx.mocked['console.log'].mock.calls).toHaveLength(0)\n  expect(ctx.mocked['console.info'].mock.calls).toHaveLength(0)\n  expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n    prisma:warn \n    prisma:warn The prisma introspect command is deprecated. Please use prisma db pull instead.\n    prisma:warn \n  `)\n  expect(ctx.mocked['console.error'].mock.calls).toHaveLength(0)\n})","file":"commands/CLI.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"doctor should succeed when schema and db do match","suites":[],"line":7,"code":"it.skip('doctor should succeed when schema and db do match', async () => {","file":"commands/Doctor.test.ts","skipped":true,"dir":"packages/cli/src/__tests__"},{"name":"should fail when db is missing","suites":[],"updatePoint":{"line":16,"column":34},"line":16,"code":"it('should fail when db is missing', async () => {\n  ctx.fixture('schema-db-out-of-sync')\n  ctx.fs.remove('dev.db')\n  const result = Doctor.new().parse([])\n  await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`P1003: Database dev.db does not exist at dev.db`)\n})","file":"commands/Doctor.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should fail when Prisma schema is missing","suites":[],"updatePoint":{"line":23,"column":45},"line":23,"code":"it('should fail when Prisma schema is missing', async () => {\n  const result = Doctor.new().parse([])\n  await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n          Could not find a schema.prisma file that is required for this command.\n          You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n        `)\n})","file":"commands/Doctor.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should fail when db is empty","suites":[],"updatePoint":{"line":31,"column":32},"line":31,"code":"it('should fail when db is empty', async () => {\n  ctx.fixture('schema-db-out-of-sync')\n  ctx.fs.write('dev.db', '')\n  const result = Doctor.new().parse([])\n  await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n          P4001\n\n          The introspected database was empty.\n\n        `)\n})","file":"commands/Doctor.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should fail when schema and db do not match","suites":[],"updatePoint":{"line":43,"column":47},"line":43,"code":"it('should fail when schema and db do not match', async () => {\n  ctx.fixture('schema-db-out-of-sync')\n  const result = Doctor.new().parse([])\n  await expect(result).rejects.toThrowErrorMatchingSnapshot(`\n\n\n                    NewPost\n                    ↪ Model is missing in database\n\n\n                    User\n                    ↪ Field newName is missing in database\n                    ↪ Field newPosts is missing in database\n\n                `)\n})","file":"commands/Doctor.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format should add a trailing EOL","suites":[],"updatePoint":{"line":8,"column":36},"line":8,"code":"it('format should add a trailing EOL', async () => {\n  ctx.fixture('example-project/prisma')\n  await Format.new().parse([])\n  expect(fs.read('schema.prisma')).toMatchSnapshot()\n})","file":"commands/Format.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format should add missing backrelation","suites":[],"updatePoint":{"line":14,"column":42},"line":14,"code":"it('format should add missing backrelation', async () => {\n  ctx.fixture('example-project/prisma')\n  await Format.new().parse(['--schema=missing-backrelation.prisma'])\n  expect(fs.read('missing-backrelation.prisma')).toMatchSnapshot()\n})","file":"commands/Format.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format should throw if schema is broken","suites":[],"updatePoint":{"line":20,"column":43},"line":20,"code":"it('format should throw if schema is broken', async () => {\n  ctx.fixture('example-project/prisma')\n  await expect(Format.new().parse(['--schema=broken.prisma'])).rejects.toThrowError()\n})","file":"commands/Format.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should work with a custom output dir","suites":["using cli"],"updatePoint":{"line":11,"column":42},"line":11,"code":"  it('should work with a custom output dir', async () => {\n    ctx.fixture('example-project')\n    const data = await ctx.cli('generate')\n\n    if (typeof data.signal === 'number' && data.signal !== 0) {\n      throw new Error(data.stderr + data.stdout)\n    }\n\n    const { main } = await import(ctx.fs.path('main.ts'))\n    expect(replaceEngineType(data.stdout)).toMatchSnapshot()\n    await expect(main()).resolves.toMatchSnapshot()\n  }, 60_000) // timeout","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should error with exit code 1 with incorrect schema","suites":["using cli"],"updatePoint":{"line":24,"column":57},"line":24,"code":"  it('should error with exit code 1 with incorrect schema', async () => {\n    ctx.fixture('broken-example-project')\n    await expect(ctx.cli('generate').catch((e) => e.exitCode)).resolves.toEqual(1)\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should work with a custom generator","suites":["using cli"],"updatePoint":{"line":29,"column":41},"line":29,"code":"  it('should work with a custom generator', async () => {\n    ctx.fixture('custom-generator')\n    const data = await ctx.cli('generate')\n\n    if (typeof data.signal === 'number' && data.signal !== 0) {\n      throw new Error(data.stderr + data.stdout)\n    }\n\n    expect(data.stdout).toContain(`I am a minimal generator`)\n  }, 75_000) // timeout","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema relative path: should work","suites":["--schema from project directory"],"updatePoint":{"line":42,"column":41},"line":42,"code":"  it('--schema relative path: should work', async () => {\n    expect.assertions(2)\n    ctx.fixture('generate-from-project-dir')\n    const result = await Generate.new().parse(['--schema=./schema.prisma'])\n    const output = stripAnsi(replaceEngineType(result))\n    expect(output).toMatchInlineSnapshot(`\n\n      ✔ Generated Prisma Client (0.0.0 | TEST_ENGINE_TYPE) to ./@prisma/client in XXXms\n      You can now start using Prisma Client in your code. Reference: https://pris.ly/d/client\n      \\`\\`\\`\n      import { PrismaClient } from './@prisma/client'\n      const prisma = new PrismaClient()\n      \\`\\`\\`\n    `)\n    // Check that the client path in the import statement actually contains\n    // forward slashes regardless of the platform (a snapshot test wouldn't\n    // detect the difference because backward slashes are replaced with forward\n    // slashes by the snapshot serializer).\n    expect(output).toContain(\"import { PrismaClient } from './@prisma/client'\")\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema relative path: should fail - invalid path","suites":["--schema from project directory"],"updatePoint":{"line":63,"column":56},"line":63,"code":"  it('--schema relative path: should fail - invalid path', async () => {\n    ctx.fixture('generate-from-project-dir')\n    const result = Generate.new().parse(['--schema=./doesnotexists.prisma'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(\n      `Provided --schema at ./doesnotexists.prisma doesn't exist.`,\n    )\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema absolute path: should work","suites":["--schema from project directory"],"updatePoint":{"line":71,"column":41},"line":71,"code":"  it('--schema absolute path: should work', async () => {\n    ctx.fixture('generate-from-project-dir')\n    const absoluteSchemaPath = path.resolve('./schema.prisma')\n    const result = await Generate.new().parse([`--schema=${absoluteSchemaPath}`])\n    expect(replaceEngineType(result)).toMatchInlineSnapshot(`\n\n      ✔ Generated Prisma Client (0.0.0 | TEST_ENGINE_TYPE) to ./@prisma/client in XXXms\n      You can now start using Prisma Client in your code. Reference: https://pris.ly/d/client\n      \\`\\`\\`\n      import { PrismaClient } from './@prisma/client'\n      const prisma = new PrismaClient()\n      \\`\\`\\`\n    `)\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema absolute path: should fail - invalid path","suites":["--schema from project directory"],"updatePoint":{"line":86,"column":56},"line":86,"code":"  it('--schema absolute path: should fail - invalid path', async () => {\n    ctx.fixture('generate-from-project-dir')\n    const absoluteSchemaPath = path.resolve('./doesnotexists.prisma')\n    const result = Generate.new().parse([`--schema=${absoluteSchemaPath}`])\n    await expect(result).rejects.toThrowError(`Provided --schema at ${absoluteSchemaPath} doesn't exist.`)\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema relative path: should work","suites":["--schema from parent directory"],"updatePoint":{"line":95,"column":41},"line":95,"code":"  it('--schema relative path: should work', async () => {\n    expect.assertions(2)\n    ctx.fixture('generate-from-parent-dir')\n    const result = await Generate.new().parse(['--schema=./subdirectory/schema.prisma'])\n    const output = stripAnsi(replaceEngineType(result))\n    expect(output).toMatchInlineSnapshot(`\n\n      ✔ Generated Prisma Client (0.0.0 | TEST_ENGINE_TYPE) to ./subdirectory/@prisma/client in XXXms\n      You can now start using Prisma Client in your code. Reference: https://pris.ly/d/client\n      \\`\\`\\`\n      import { PrismaClient } from './subdirectory/@prisma/client'\n      const prisma = new PrismaClient()\n      \\`\\`\\`\n    `)\n    // Check that the client path in the import statement actually contains\n    // forward slashes regardless of the platform (a snapshot test wouldn't\n    // detect the difference because backward slashes are replaced with forward\n    // slashes by the snapshot serializer).\n    expect(output).toContain(\"import { PrismaClient } from './subdirectory/@prisma/client'\")\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema relative path: should fail - invalid path","suites":["--schema from parent directory"],"updatePoint":{"line":116,"column":56},"line":116,"code":"  it('--schema relative path: should fail - invalid path', async () => {\n    ctx.fixture('generate-from-parent-dir')\n\n    const result = Generate.new().parse(['--schema=./subdirectory/doesnotexists.prisma'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(\n      `Provided --schema at ./subdirectory/doesnotexists.prisma doesn't exist.`,\n    )\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema absolute path: should work","suites":["--schema from parent directory"],"updatePoint":{"line":125,"column":41},"line":125,"code":"  it('--schema absolute path: should work', async () => {\n    expect.assertions(2)\n    ctx.fixture('generate-from-parent-dir')\n    const absoluteSchemaPath = path.resolve('./subdirectory/schema.prisma')\n    const result = await Generate.new().parse([`--schema=${absoluteSchemaPath}`])\n    const output = stripAnsi(replaceEngineType(result))\n    expect(output).toMatchInlineSnapshot(`\n\n      ✔ Generated Prisma Client (0.0.0 | TEST_ENGINE_TYPE) to ./subdirectory/@prisma/client in XXXms\n      You can now start using Prisma Client in your code. Reference: https://pris.ly/d/client\n      \\`\\`\\`\n      import { PrismaClient } from './subdirectory/@prisma/client'\n      const prisma = new PrismaClient()\n      \\`\\`\\`\n    `)\n    // Check that the client path in the import statement actually contains\n    // forward slashes regardless of the platform (a snapshot test wouldn't\n    // detect the difference because backward slashes are replaced with forward\n    // slashes by the snapshot serializer).\n    expect(output).toContain(\"import { PrismaClient } from './subdirectory/@prisma/client'\")\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"--schema absolute path: should fail - invalid path","suites":["--schema from parent directory"],"updatePoint":{"line":147,"column":56},"line":147,"code":"  it('--schema absolute path: should fail - invalid path', async () => {\n    ctx.fixture('generate-from-parent-dir')\n\n    const absoluteSchemaPath = path.resolve('./subdirectory/doesnotexists.prisma')\n    const result = Generate.new().parse([`--schema=${absoluteSchemaPath}`])\n    await expect(result).rejects.toThrowError(`Provided --schema at ${absoluteSchemaPath} doesn't exist.`)\n  })","file":"commands/Generate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"is schema and env written on disk replace","suites":[],"updatePoint":{"line":10,"column":47},"line":10,"code":"test('is schema and env written on disk replace', async () => {\n  const result = await ctx.cli('init')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema())\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatch(defaultEnv())\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with url param","suites":[],"updatePoint":{"line":22,"column":26},"line":22,"code":"test('works with url param', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--url', 'file:dev.db')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('sqlite'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"file:dev.db\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - postgresql","suites":[],"updatePoint":{"line":43,"column":44},"line":43,"code":"test('works with provider param - postgresql', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'postgresql')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('postgresql'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - cockroachdb","suites":[],"updatePoint":{"line":64,"column":45},"line":64,"code":"test('works with provider param - cockroachdb', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'cockroachdb')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('cockroachdb'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"postgresql://johndoe:randompassword@localhost:26257/mydb?schema=public\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider and url params - cockroachdb","suites":[],"updatePoint":{"line":85,"column":54},"line":85,"code":"test('works with provider and url params - cockroachdb', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli(\n    'init',\n    '--datasource-provider',\n    'cockroachdb',\n    '--url',\n    'postgres://prisma@localhost:26257/defaultdb',\n  )\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('cockroachdb'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"postgresql://johndoe:randompassword@localhost:26257/mydb?schema=public\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - mysql","suites":[],"updatePoint":{"line":112,"column":39},"line":112,"code":"test('works with provider param - mysql', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'mysql')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('mysql'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"mysql://johndoe:randompassword@localhost:3306/mydb\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - SQLITE","suites":[],"updatePoint":{"line":133,"column":40},"line":133,"code":"test('works with provider param - SQLITE', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'SQLITE')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('sqlite'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"file:./dev.db\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - SqlServer","suites":[],"updatePoint":{"line":154,"column":43},"line":154,"code":"test('works with provider param - SqlServer', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'SqlServer')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('sqlserver'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"sqlserver://localhost:1433;database=mydb;user=SA;password=randompassword;\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"works with provider param - MongoDB","suites":[],"updatePoint":{"line":175,"column":41},"line":175,"code":"test('works with provider param - MongoDB', async () => {\n  ctx.fixture('init')\n  const result = await ctx.cli('init', '--datasource-provider', 'MongoDB')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema('mongodb'))\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchInlineSnapshot(`\n    # Environment variables declared in this file are automatically made available to Prisma.\n    # See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema\n\n    # Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.\n    # See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\n    DATABASE_URL=\"mongodb+srv://root:randompassword@cluster0.ab1cd.mongodb.net/mydb?retryWrites=true&w=majority\"\n  `)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"errors with invalid provider param","suites":[],"updatePoint":{"line":196,"column":40},"line":196,"code":"test('errors with invalid provider param', async () => {\n  ctx.fixture('init')\n  const result = ctx.cli('init', '--datasource-provider', 'INVALID')\n  await expect(result).rejects.toThrowError()\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"warns when DATABASE_URL present in .env ","suites":[],"updatePoint":{"line":202,"column":46},"line":202,"code":"test('warns when DATABASE_URL present in .env ', async () => {\n  fs.writeFileSync(join(ctx.tmpDir, '.env'), `DATABASE_URL=\"postgres://dont:overwrite@me:5432/tests\"`)\n  const result = await ctx.cli('init')\n  expect(stripAnsi(result.all!)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema())\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatch(`DATABASE_URL=\"postgres://dont:overwrite@me:5432/tests\"`)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"appends when .env present","suites":[],"updatePoint":{"line":215,"column":31},"line":215,"code":"test('appends when .env present', async () => {\n  fs.writeFileSync(join(ctx.tmpDir, '.env'), `SOMETHING=\"is here\"`)\n  const result = await ctx.cli('init')\n  expect(stripAnsi(result.stdout)).toMatchSnapshot()\n\n  const schema = fs.readFileSync(join(ctx.tmpDir, 'prisma', 'schema.prisma'), 'utf-8')\n  expect(schema).toMatch(defaultSchema())\n  expect(schema).toMatchSnapshot()\n\n  const env = fs.readFileSync(join(ctx.tmpDir, '.env'), 'utf-8')\n  expect(env).toMatchSnapshot()\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"writes a minimal .gitignore file","suites":[],"updatePoint":{"line":228,"column":38},"line":228,"code":"test('writes a minimal .gitignore file', async () => {\n  ctx.fixture('init')\n  await ctx.cli('init')\n  const gitignore = fs.readFileSync(join(ctx.tmpDir, '.gitignore'), 'utf-8')\n  expect(gitignore).toMatch(defaultGitIgnore())\n\n  expect(gitignore).toMatchSnapshot()\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"ignore .gitignore file if already present (do not override)","suites":[],"updatePoint":{"line":237,"column":65},"line":237,"code":"test('ignore .gitignore file if already present (do not override)', async () => {\n  ctx.fixture('init')\n  const gitignorePath = join(ctx.tmpDir, '.gitignore')\n  fs.writeFileSync(gitignorePath, `# This should not be overridden`)\n  const gitignoreBefore = fs.readFileSync(gitignorePath, 'utf-8')\n  await ctx.cli('init')\n  const gitignoreAfter = fs.readFileSync(gitignorePath, 'utf-8')\n  expect(gitignoreAfter).toEqual(gitignoreBefore)\n})","file":"commands/Init.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can start up correctly","suites":["studio with default schema.prisma filename"],"updatePoint":{"line":55,"column":30},"line":55,"code":"  test('can start up correctly', async () => {\n    const res = await fetch(`http://localhost:${STUDIO_TEST_PORT}`)\n    expect(res.status).toEqual(200)\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `findMany` queries","suites":["studio with default schema.prisma filename"],"updatePoint":{"line":60,"column":41},"line":60,"code":"  test('can respond to `findMany` queries', async () => {\n    const res = await sendRequest({\n      requestId: 1,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'findMany',\n          args: {\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `create` queries","suites":["studio with default schema.prisma filename"],"updatePoint":{"line":87,"column":39},"line":87,"code":"  test('can respond to `create` queries', async () => {\n    const res = await sendRequest({\n      requestId: 2,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'create',\n          args: {\n            data: {\n              id: 3,\n              string: '',\n              int: 0,\n              float: 0.0,\n              datetime: '2020-08-03T00:00:00.000Z',\n              relation: {\n                connect: {\n                  id: 3,\n                },\n              },\n              relation_list: {\n                connect: {\n                  id: 3,\n                },\n              },\n            },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `update` queries","suites":["studio with default schema.prisma filename"],"updatePoint":{"line":131,"column":39},"line":131,"code":"  test('can respond to `update` queries', async () => {\n    const res = await sendRequest({\n      requestId: 3,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'update',\n          args: {\n            where: {\n              id: 1,\n            },\n            data: {\n              string: 'Changed String',\n              int: 100,\n              float: 100.5,\n              datetime: '2025-08-03T00:00:00.000Z',\n              relation: {\n                connect: {\n                  id: 3,\n                },\n              },\n              relation_list: {\n                connect: {\n                  id: 3,\n                },\n              },\n            },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `delete` queries","suites":["studio with default schema.prisma filename"],"updatePoint":{"line":177,"column":39},"line":177,"code":"  test('can respond to `delete` queries', async () => {\n    const res = await sendRequest({\n      requestId: 4,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'delete',\n          args: {\n            where: { id: 2 },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can start up correctly","suites":["studio with custom schema.prisma filename"],"updatePoint":{"line":238,"column":30},"line":238,"code":"  test('can start up correctly', async () => {\n    const res = await fetch(`http://localhost:${STUDIO_TEST_PORT}`)\n    expect(res.status).toEqual(200)\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `findMany` queries","suites":["studio with custom schema.prisma filename"],"updatePoint":{"line":243,"column":41},"line":243,"code":"  test('can respond to `findMany` queries', async () => {\n    const res = await sendRequest({\n      requestId: 1,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'findMany',\n          args: {\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `create` queries","suites":["studio with custom schema.prisma filename"],"updatePoint":{"line":270,"column":39},"line":270,"code":"  test('can respond to `create` queries', async () => {\n    const res = await sendRequest({\n      requestId: 2,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'create',\n          args: {\n            data: {\n              id: 3,\n              string: '',\n              int: 0,\n              float: 0.0,\n              datetime: '2020-08-03T00:00:00.000Z',\n              relation: {\n                connect: {\n                  id: 3,\n                },\n              },\n              relation_list: {\n                connect: {\n                  id: 3,\n                },\n              },\n            },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `update` queries","suites":["studio with custom schema.prisma filename"],"updatePoint":{"line":314,"column":39},"line":314,"code":"  test('can respond to `update` queries', async () => {\n    const res = await sendRequest({\n      requestId: 3,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'update',\n          args: {\n            where: {\n              id: 1,\n            },\n            data: {\n              string: 'Changed String',\n              int: 100,\n              float: 100.5,\n              datetime: '2025-08-03T00:00:00.000Z',\n              relation: {\n                connect: {\n                  id: 3,\n                },\n              },\n              relation_list: {\n                connect: {\n                  id: 3,\n                },\n              },\n            },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"can respond to `delete` queries","suites":["studio with custom schema.prisma filename"],"updatePoint":{"line":360,"column":39},"line":360,"code":"  test('can respond to `delete` queries', async () => {\n    const res = await sendRequest({\n      requestId: 4,\n      channel: 'prisma',\n      action: 'clientRequest',\n      payload: {\n        data: {\n          modelName: 'with_all_field_types',\n          operation: 'delete',\n          args: {\n            where: { id: 2 },\n            select: {\n              id: true,\n              string: true,\n              int: true,\n              float: true,\n              datetime: true,\n              relation: true,\n              relation_list: true,\n            },\n          },\n        },\n      },\n    })\n    expect(res).toMatchSnapshot()\n  })","file":"commands/Studio.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate should succeed if schema is valid","suites":[],"updatePoint":{"line":7,"column":46},"line":7,"code":"it('validate should succeed if schema is valid', async () => {\n  ctx.fixture('example-project/prisma')\n  await expect(Validate.new().parse(['--schema=schema.prisma'])).resolves.toContain('is valid')\n})","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate should throw if schema is invalid","suites":[],"updatePoint":{"line":12,"column":46},"line":12,"code":"it('validate should throw if schema is invalid', async () => {\n  ctx.fixture('example-project/prisma')\n  await expect(Validate.new().parse(['--schema=broken.prisma'])).rejects.toThrowError('Schema validation error')\n})","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate should throw if env var is not set","suites":[],"updatePoint":{"line":17,"column":47},"line":17,"code":"it('validate should throw if env var is not set', async () => {\n  ctx.fixture('example-project/prisma')\n  await expect(Validate.new().parse(['--schema=env-does-not-exists.prisma'])).rejects.toThrowError(\n    'Environment variable not found',\n  )\n})","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate should reject NoAction referential action on Postgres when relationMode = \"prisma\"","suites":["referential actions"],"updatePoint":{"line":29,"column":97},"line":29,"code":"  it('validate should reject NoAction referential action on Postgres when relationMode = \"prisma\"', async () => {\n    expect.assertions(1)\n\n    try {\n      await Validate.new().parse(['--schema', './prisma/postgres.prisma'])\n    } catch (e) {\n      expect(serializeQueryEngineName(e.message)).toMatchInlineSnapshot(`\n        Schema validation error - Error (query-engine-NORMALIZED)\n        Error code: P1012\n        error: Error validating: Invalid referential action: \\`NoAction\\`. Allowed values: (\\`Cascade\\`, \\`Restrict\\`, \\`SetNull\\`). \\`NoAction\\` is not implemented for Postgres when using \\`relationMode = \"prisma\"\\`, you could try using \\`Restrict\\` instead. Learn more at https://pris.ly/d/relation-mode\n          -->  schema.prisma:21\n           | \n        20 |   id       String @id @default(cuid())\n        21 |   user     SomeUser @relation(fields: [userId], references: [id], onUpdate: NoAction)\n           | \n        error: Error validating: Invalid referential action: \\`NoAction\\`. Allowed values: (\\`Cascade\\`, \\`Restrict\\`, \\`SetNull\\`). \\`NoAction\\` is not implemented for Postgres when using \\`relationMode = \"prisma\"\\`, you could try using \\`Restrict\\` instead. Learn more at https://pris.ly/d/relation-mode\n          -->  schema.prisma:28\n           | \n        27 |   id       String @id @default(cuid())\n        28 |   user     SomeUser @relation(fields: [userId], references: [id], onDelete: NoAction)\n           | \n\n        Validation Error Count: 2\n        [Context: getDmmf]\n\n        Prisma CLI Version : 0.0.0\n      `)\n    }\n  })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate should reject NoAction referential action on sqlite when relationMode = \"prisma\"","suites":["referential actions"],"updatePoint":{"line":59,"column":95},"line":59,"code":"  it('validate should reject NoAction referential action on sqlite when relationMode = \"prisma\"', async () => {\n    expect.assertions(1)\n\n    try {\n      await Validate.new().parse(['--schema', './prisma/postgres.prisma'])\n    } catch (e) {\n      expect(serializeQueryEngineName(e.message)).toMatchInlineSnapshot(`\n        Schema validation error - Error (query-engine-NORMALIZED)\n        Error code: P1012\n        error: Error validating: Invalid referential action: \\`NoAction\\`. Allowed values: (\\`Cascade\\`, \\`Restrict\\`, \\`SetNull\\`). \\`NoAction\\` is not implemented for Postgres when using \\`relationMode = \"prisma\"\\`, you could try using \\`Restrict\\` instead. Learn more at https://pris.ly/d/relation-mode\n          -->  schema.prisma:21\n           | \n        20 |   id       String @id @default(cuid())\n        21 |   user     SomeUser @relation(fields: [userId], references: [id], onUpdate: NoAction)\n           | \n        error: Error validating: Invalid referential action: \\`NoAction\\`. Allowed values: (\\`Cascade\\`, \\`Restrict\\`, \\`SetNull\\`). \\`NoAction\\` is not implemented for Postgres when using \\`relationMode = \"prisma\"\\`, you could try using \\`Restrict\\` instead. Learn more at https://pris.ly/d/relation-mode\n          -->  schema.prisma:28\n           | \n        27 |   id       String @id @default(cuid())\n        28 |   user     SomeUser @relation(fields: [userId], references: [id], onDelete: NoAction)\n           | \n\n        Validation Error Count: 2\n        [Context: getDmmf]\n\n        Prisma CLI Version : 0.0.0\n      `)\n    }\n  })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate should accept NoAction referential action on e.g. MySQL when relationMode = \"prisma\"","suites":["referential actions"],"updatePoint":{"line":89,"column":99},"line":89,"code":"  it('validate should accept NoAction referential action on e.g. MySQL when relationMode = \"prisma\"', async () => {\n    const result = await Validate.new().parse(['--schema', './prisma/mysql.prisma'])\n    expect(result).toBeTruthy()\n  })","file":"commands/Validate.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should error when dependent generator is missing","suites":[],"updatePoint":{"line":6,"column":52},"line":6,"code":"it('should error when dependent generator is missing', async () => {\n  expect.assertions(1)\n\n  try {\n    await execa.node(path.join(__dirname, '../../build/index.js'), ['generate'], {\n      cwd: path.join(__dirname, './fixtures/dependent-generator'),\n      stdio: 'pipe',\n    })\n  } catch (e) {\n    expect(e.stderr).toMatchSnapshot()\n  }\n})","file":"dependent-generator.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should read .env file in root folder and custom-path","suites":[],"updatePoint":{"line":5,"column":56},"line":5,"code":"it('should read .env file in root folder and custom-path', () => {\n  ctx.fixture('dotenv-1-custom-schema-path')\n  loadEnvFile('./custom-path/schema.prisma', true)\n  expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n\n  expect(process.env.DOTENV_PRISMA_WHEN_CUSTOM_SCHEMA_PATH_SHOULD_WORK).toEqual('file:dev.db')\n  expect(process.env.DOTENV_ROOT).toEqual('shouldbebread')\n  expect(process.env.DOTENV_PRISMA_WHEN_CUSTOM_SCHEMA_PATH_SHOULD_BE_UNDEFINED).toEqual(undefined)\n})","file":"dotenv-1-custom-schema-path.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should read .env file in prisma folder","suites":[],"updatePoint":{"line":5,"column":42},"line":5,"code":"it('should read .env file in prisma folder', () => {\n  ctx.fixture('dotenv-2-prisma-folder')\n  loadEnvFile(undefined, true)\n\n  expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n\n  expect(process.env.DOTENV_PRISMA_SHOULD_WORK).toEqual('file:dev.db')\n  expect(process.env.DOTENV_ROOT_SHOULD_BE_UNDEFINED).toEqual(undefined)\n})","file":"dotenv-2-prisma-folder.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should throw error","suites":[],"updatePoint":{"line":5,"column":22},"line":5,"code":"it('should throw error', async () => {\n  ctx.fixture('dotenv-3-conflict')\n  expect.assertions(1)\n\n  await expect(\n    ctx.cli('validate').catch((e) => {\n      const message = e.message.split('\\n').slice(1).join('\\n')\n      throw new Error(message)\n    }),\n  ).rejects.toThrowErrorMatchingInlineSnapshot(`\n          Error: There is a conflict between env var in .env and prisma/.env\n          Conflicting env vars:\n            SHOULD_THROW\n\n          We suggest to move the contents of prisma/.env to .env to consolidate your env vars.\n\n        `)\n})","file":"dotenv-3-conflict.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should read .env file in prisma folder when there is no schema","suites":[],"updatePoint":{"line":5,"column":66},"line":5,"code":"it('should read .env file in prisma folder when there is no schema', () => {\n  ctx.fixture('dotenv-4-prisma-no-schema')\n  loadEnvFile(undefined, true)\n\n  expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n\n  expect(process.env.DOTENV_PRISMA_NO_SCHEMA_SHOULD_WORK).toEqual('file:dev.db')\n  expect(process.env.DOTENV_ROOT_SHOULD_BE_UNDEFINED).toEqual(undefined)\n})","file":"dotenv-4-prisma-when-no-schema.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should not load root .env file","suites":[],"updatePoint":{"line":5,"column":34},"line":5,"code":"it('should not load root .env file', () => {\n  ctx.fixture('dotenv-5-only-root')\n  loadEnvFile(undefined, true)\n\n  expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n\n  expect(process.env.DOTENV_ROOT_SHOULD_BE_UNDEFINED).toEqual(undefined)\n})","file":"dotenv-5-only-root.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"should read expanded env vars","suites":[],"updatePoint":{"line":5,"column":33},"line":5,"code":"it('should read expanded env vars', () => {\n  ctx.fixture('dotenv-6-expand')\n  loadEnvFile('./expand/schema.prisma', true)\n\n  expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n\n  expect(process.env.DOTENV_PRISMA_EXPAND_DATABASE_URL_WITH_SCHEMA).toEqual(\n    'postgres://user:password@server.host:5432/database?ssl=1&schema=schema1234',\n  )\n})","file":"dotenv-6-expand.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":96,"column":14},"line":96,"code":"    it('format', async () => {\n      const result = await Format.new().parse([])\n      expect(result).toMatch(/^Formatted (.*) in \\d+ms 🚀$/)\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":101,"column":16},"line":101,"code":"    it('validate', async () => {\n      expect.assertions(1)\n      try {\n        await Validate.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchSnapshot(urlMustStartWithProtocolValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db push","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":110,"column":15},"line":110,"code":"    it('db push', async () => {\n      expect.assertions(1)\n      try {\n        await DbPush.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchSnapshot(urlMustStartWithProtocolValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db pull","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":119,"column":15},"line":119,"code":"    it('db pull', async () => {\n      expect.assertions(1)\n      try {\n        await DbPull.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchSnapshot(urlMustStartWithProtocolValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db execute","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":128,"column":18},"line":128,"code":"    it('db execute', async () => {\n      fs.writeFileSync('script.sql', dbExecuteSQLScript)\n      expect.assertions(1)\n\n      try {\n        await DbExecute.new().parse(['--file=./script.sql'])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n          P1012\n\n          error: Error validating datasource \\`db\\`: the URL must start with the protocol \\`postgresql://\\` or \\`postgres://\\`.\n            -->  schema.prisma:5\n             | \n           4 |   provider = \"postgresql\"\n           5 |   url      = env(\"SOME_DEFINED_INVALID_URL\")\n             | \n\n\n        `)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate reset","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":150,"column":21},"line":150,"code":"    it('migrate reset', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateReset.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlMustStartWithProtocolValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate dev","suites":["[wasm] incomplete-schemas","datasource-block-url-env-set-invalid"],"updatePoint":{"line":159,"column":19},"line":159,"code":"    it('migrate dev', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateDev.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlMustStartWithProtocolValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":174,"column":16},"line":174,"code":"    it('validate', async () => {\n      expect.assertions(1)\n      try {\n        await Validate.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(envVarNotFoundValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db push","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":183,"column":15},"line":183,"code":"    it('db push', async () => {\n      expect.assertions(1)\n      try {\n        await DbPush.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(envVarNotFoundValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db pull","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":192,"column":15},"line":192,"code":"    it('db pull', async () => {\n      expect.assertions(1)\n      try {\n        await DbPull.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(envVarNotFoundValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db execute","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":201,"column":18},"line":201,"code":"    it('db execute', async () => {\n      fs.writeFileSync('script.sql', dbExecuteSQLScript)\n      expect.assertions(1)\n\n      try {\n        await DbExecute.new().parse(['--file=./script.sql'])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n          P1012\n\n          error: Environment variable not found: SOME_UNDEFINED_DB.\n            -->  schema.prisma:5\n             | \n           4 |   provider = \"postgresql\"\n           5 |   url      = env(\"SOME_UNDEFINED_DB\")\n             | \n\n\n        `)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate reset","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":223,"column":21},"line":223,"code":"    it('migrate reset', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateReset.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(envVarNotFoundValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate dev","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":232,"column":19},"line":232,"code":"    it('migrate dev', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateDev.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(envVarNotFoundValidationError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format","suites":["[wasm] incomplete-schemas","datasource-block-url-env-unset"],"updatePoint":{"line":247,"column":14},"line":247,"code":"    it('format', async () => {\n      const result = await Format.new().parse([])\n      expect(result).toMatch(/^Formatted (.*) in \\d+ms 🚀$/)\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":258,"column":14},"line":258,"code":"    it('format', async () => {\n      expect.assertions(1)\n\n      try {\n        await Format.new().parse([])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(\n          urlIsMissingValidationError('getDmmf'),\n        )\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"format","suites":["[wasm] incomplete-schemas","empty-schema"],"updatePoint":{"line":276,"column":14},"line":276,"code":"    it('format', async () => {\n      const result = await Format.new().parse([])\n      expect(result).toMatch(/^Formatted (.*) in \\d+ms 🚀$/)\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db push","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":287,"column":15},"line":287,"code":"    it('db push', async () => {\n      expect.assertions(1)\n      try {\n        await DbPush.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlIsMissingValidationError('getConfig'))\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db pull","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":296,"column":15},"line":296,"code":"    it('db pull', async () => {\n      expect.assertions(1)\n      try {\n        await DbPull.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlIsMissingValidationError('getConfig'))\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db execute","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":305,"column":18},"line":305,"code":"    it('db execute', async () => {\n      fs.writeFileSync('script.sql', dbExecuteSQLScript)\n      expect.assertions(1)\n\n      try {\n        await DbExecute.new().parse(['--file=./script.sql'])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n          P1012\n\n          error: Argument \"url\" is missing in data source block \"db\".\n            -->  schema.prisma:3\n             | \n           2 | \n           3 | datasource db {\n           4 |   provider = \"postgresql\"\n           5 | }\n             | \n\n\n        `)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate reset","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":329,"column":21},"line":329,"code":"    it('migrate reset', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateReset.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlIsMissingValidationError('getConfig'))\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate dev","suites":["[wasm] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":338,"column":19},"line":338,"code":"    it('migrate dev', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateDev.new().parse([])\n      } catch (e) {\n        expect(stripAnsi(e.message)).toMatchInlineSnapshot(urlIsMissingValidationError('getConfig'))\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate","suites":["[normalized library/binary] incomplete-schemas","datasource-block-no-url"],"updatePoint":{"line":355,"column":16},"line":355,"code":"    it('validate', async () => {\n      expect.assertions(1)\n      try {\n        await Validate.new().parse([])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(\n          urlIsMissingValidationError('getDmmf'),\n        )\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"validate","suites":["[normalized library/binary] incomplete-schemas","empty-schema"],"updatePoint":{"line":372,"column":16},"line":372,"code":"    it('validate', async () => {\n      const result = await Validate.new().parse([])\n      expect(result).toMatch(/^The schema at (.*) is valid 🚀$/)\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db push","suites":["[normalized library/binary] incomplete-schemas","empty-schema"],"updatePoint":{"line":377,"column":15},"line":377,"code":"    it('db push', async () => {\n      expect.assertions(1)\n      try {\n        await DbPush.new().parse([])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(couldNotFindDatasourceError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db pull","suites":["[normalized library/binary] incomplete-schemas","empty-schema"],"updatePoint":{"line":386,"column":15},"line":386,"code":"    it('db pull', async () => {\n      expect.assertions(1)\n      try {\n        await DbPull.new().parse([])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(thereIsNoDatasourceError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"db execute","suites":["[normalized library/binary] incomplete-schemas","empty-schema"],"updatePoint":{"line":395,"column":18},"line":395,"code":"    it('db execute', async () => {\n      fs.writeFileSync('script.sql', dbExecuteSQLScript)\n      expect.assertions(1)\n\n      try {\n        await DbExecute.new().parse(['--file=./script.sql'])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(thereIsNoDatasourceError + '\\n')\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate reset","suites":["[normalized library/binary] incomplete-schemas","empty-schema"],"updatePoint":{"line":406,"column":21},"line":406,"code":"    it('migrate reset', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateReset.new().parse([])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(couldNotFindDatasourceError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"migrate dev","suites":["[normalized library/binary] incomplete-schemas","empty-schema"],"updatePoint":{"line":415,"column":19},"line":415,"code":"    it('migrate dev', async () => {\n      expect.assertions(1)\n      try {\n        await MigrateDev.new().parse([])\n      } catch (e) {\n        expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(couldNotFindDatasourceError)\n      }\n    })","file":"incomplete-schemas.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"normal release","suites":[],"updatePoint":{"line":33,"column":20},"line":33,"code":"test('normal release', () => {\n  printUpdateMessageFromTo('4.5.0', '4.6.0')\n  expect(consoleErrorMock.mock.calls[0][0]).toMatchInlineSnapshot(`\n    ┌─────────────────────────────────────────────────────────┐\n    │  Update available 4.5.0 -> 4.6.0                        │\n    │  Run the following to update                            │\n    │    npm i --save-dev prisma@4.6.0                        │\n    │    npm i @prisma/client@4.6.0                           │\n    └─────────────────────────────────────────────────────────┘\n  `)\n})","file":"printUpdateMessage.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"integration version with long name","suites":[],"updatePoint":{"line":45,"column":40},"line":45,"code":"test('integration version with long name', () => {\n  printUpdateMessageFromTo('4.5.0-integration-use-keep-alive-for-node-fetch.1', '4.6.0')\n  expect(consoleErrorMock.mock.calls[0][0]).toMatchInlineSnapshot(`\n    ┌───────────────────────────────────────────────────────────────────────────────┐\n    │  Update available 4.5.0-integration-use-keep-alive-for-node-fetch.1 -> 4.6.0  │\n    │  Run the following to update                                                  │\n    │    npm i --save-dev prisma@4.6.0                                              │\n    │    npm i @prisma/client@4.6.0                                                 │\n    └───────────────────────────────────────────────────────────────────────────────┘\n  `)\n})","file":"printUpdateMessage.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"dev tag - minor","suites":["update available message"],"updatePoint":{"line":8,"column":21},"line":8,"code":"  it('dev tag - minor', () => {\n    printUpdateMessage({\n      status: 'ok',\n      // @ts-ignore\n      data: {\n        previous_version: '2.6.1-dev.18',\n        current_version: '2.16.0-dev.8',\n        package: 'prisma',\n        release_tag: 'dev',\n      },\n    })\n    const message = ctx.mocked['console.error'].mock.calls[0][0]\n    expect(message).toContain('npm i --save-dev prisma@dev')\n    expect(message).toContain('npm i @prisma/client@dev')\n    expect(message).toMatchSnapshot()\n  })","file":"update-message.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"dev tag - major","suites":["update available message"],"updatePoint":{"line":25,"column":21},"line":25,"code":"  it('dev tag - major', () => {\n    printUpdateMessage({\n      status: 'ok',\n      // @ts-ignore\n      data: {\n        previous_version: '2.6.1-dev.18',\n        current_version: '3.0.1-dev.8',\n        package: 'prisma',\n        release_tag: 'dev',\n      },\n    })\n    const message = ctx.mocked['console.error'].mock.calls[0][0]\n    expect(message).toContain('This is a major update')\n    expect(message).toContain('npm i --save-dev prisma@dev')\n    expect(message).toContain('npm i @prisma/client@dev')\n    expect(message).toMatchSnapshot()\n  })","file":"update-message.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"latest tag - minor","suites":["update available message"],"updatePoint":{"line":43,"column":24},"line":43,"code":"  it('latest tag - minor', () => {\n    printUpdateMessage({\n      status: 'ok',\n      // @ts-ignore\n      data: {\n        previous_version: '2.6.1',\n        current_version: '2.16.0',\n        package: 'prisma',\n        release_tag: 'latest',\n      },\n    })\n    const message = ctx.mocked['console.error'].mock.calls[0][0]\n    expect(message).toContain('npm i --save-dev prisma@latest')\n    expect(message).toContain('npm i @prisma/client@latest')\n    expect(message).toMatchSnapshot()\n  })","file":"update-message.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"latest tag - major","suites":["update available message"],"updatePoint":{"line":60,"column":24},"line":60,"code":"  it('latest tag - major', () => {\n    printUpdateMessage({\n      status: 'ok',\n      // @ts-ignore\n      data: {\n        previous_version: '2.6.1',\n        current_version: '3.0.0',\n        package: 'prisma',\n        release_tag: 'latest',\n      },\n    })\n    const message = ctx.mocked['console.error'].mock.calls[0][0]\n    expect(message).toContain('This is a major update')\n    expect(message).toContain('npm i --save-dev prisma@latest')\n    expect(message).toContain('npm i @prisma/client@latest')\n    expect(message).toMatchSnapshot()\n  })","file":"update-message.test.ts","skipped":false,"dir":"packages/cli/src/__tests__"},{"name":"count happy path","suites":["aggregate"],"updatePoint":{"line":55,"column":24},"line":55,"code":"  test('count happy path', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {\n        take: 10,\n        select: {\n          _count: {\n            select: {\n              _all: true,\n            },\n          },\n        },\n      },\n      rootTypeName: 'query',\n      rootField: 'aggregateUser',\n    })\n    document.validate(undefined, false, 'user', 'colorless')\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        aggregateUser(take: 10) {\n          _count {\n            _all\n          }\n        }\n      }\n    `)\n  })","file":"aggregate.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"combined happy path","suites":["aggregate"],"updatePoint":{"line":83,"column":27},"line":83,"code":"  test('combined happy path', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {\n        take: 10,\n        cursor: {\n          email: 'a@a.de',\n        },\n        orderBy: {\n          age: 'asc',\n        },\n        skip: 12,\n        where: {\n          age: { gt: 500 },\n        },\n        select: {\n          _count: true,\n          _avg: {\n            select: {\n              age: true,\n            },\n          },\n          _min: {\n            select: {\n              age: true,\n            },\n          },\n          _max: {\n            select: {\n              age: true,\n            },\n          },\n          _sum: {\n            select: {\n              age: true,\n            },\n          },\n        },\n      },\n      rootTypeName: 'query',\n      rootField: 'aggregateUser',\n    })\n    document.validate(undefined, false, 'user', 'colorless')\n    expect(String(document)).toMatchSnapshot()\n  })","file":"aggregate.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"unhappy path - incorrect arg","suites":["aggregate"],"updatePoint":{"line":129,"column":36},"line":129,"code":"  test('unhappy path - incorrect arg', () => {\n    const select = { mount: true }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'aggregateUser',\n    })\n    expect(() => document.validate(select, false, 'user', 'colorless')).toThrowErrorMatchingSnapshot()\n  })","file":"aggregate.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"unhappy path - incorrect field","suites":["aggregate"],"updatePoint":{"line":140,"column":38},"line":140,"code":"  test('unhappy path - incorrect field', () => {\n    const select = {\n      select: {\n        _avg: {\n          select: {\n            blub: true,\n          },\n        },\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'aggregateUser',\n    })\n    expect(() => document.validate(select, false, 'user', 'colorless')).toThrowErrorMatchingSnapshot()\n  })","file":"aggregate.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"invalid query","suites":["at least one validation"],"updatePoint":{"line":13,"column":21},"line":13,"code":"  test('invalid query', () => {\n    const select = {\n      where: {\n        email: {},\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          email: {\n\n          }\n        }) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n    try {\n      document.validate(select, false, 'users')\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n        \"\n        Invalid \\`prisma.users()\\` invocation:\n\n        {\n          where: {\n            email: {\n        ?     equals?: String,\n        ?     not?: String | StringFilter,\n        ?     in?: String,\n        ?     notIn?: String,\n        ?     lt?: String,\n        ?     lte?: String,\n        ?     gt?: String,\n        ?     gte?: String,\n        ?     contains?: String,\n        ?     startsWith?: String,\n        ?     endsWith?: String\n            }\n          }\n        }\n\n        Argument where.email of type StringFilter needs at least one argument. Available args are listed in green.\n\n        Note: Lines with ? are optional.\n        \"\n      `)\n    }\n  })","file":"atLeastOne.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"valid query","suites":["at least one validation"],"updatePoint":{"line":77,"column":19},"line":77,"code":"  test('valid query', () => {\n    const select = {\n      where: {\n        email: '',\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(select, false, 'users')).not.toThrow()\n  })","file":"atLeastOne.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"atomic set operation without object wrapping","suites":["minimal atomic update transformation"],"updatePoint":{"line":31,"column":52},"line":31,"code":"  test('atomic set operation without object wrapping', () => {\n    const transformedDocument = getTransformedDocument({\n      data: {\n        countFloat: 3.1415926,\n        countInt1: 3,\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      mutation {\n        updateOneUser(\n          data: {\n            countFloat: 3.1415926e+0\n            countInt1: 3\n          }\n        ) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"atomicOperationsUpdate.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"atomic operations with object wrapping","suites":["minimal atomic update transformation"],"updatePoint":{"line":65,"column":46},"line":65,"code":"  test('atomic operations with object wrapping', () => {\n    const select = {\n      data: {\n        countFloat: {\n          set: null,\n        },\n        countInt1: {\n          set: null,\n        },\n        countInt2: {\n          set: 123,\n        },\n        countInt3: {\n          increment: 1,\n        },\n        countInt4: {\n          decrement: 1,\n        },\n        countInt5: {\n          multiply: 2,\n        },\n        countInt6: {\n          divide: 4,\n        },\n      },\n      where: {\n        email: 'a@a.de',\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'mutation',\n      rootField: 'updateOneUser',\n    })\n\n    expect(String(document)).toMatchInlineSnapshot(`\n      mutation {\n        updateOneUser(\n          data: {\n            countFloat: {\n              set: null\n            }\n            countInt1: {\n              set: null\n            }\n            countInt2: {\n              set: 123\n            }\n            countInt3: {\n              increment: 1\n            }\n            countInt4: {\n              decrement: 1\n            }\n            countInt5: {\n              multiply: 2\n            }\n            countInt6: {\n              divide: 4\n            }\n          }\n          where: {\n            email: \"a@a.de\"\n          }\n        ) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n\n    expect(() => document.validate(select, false)).not.toThrowError()\n  })","file":"atomicOperationsUpdate.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"basic batching","suites":["batching"],"updatePoint":{"line":9,"column":22},"line":9,"code":"  test('basic batching', async () => {\n    const dmmf = new DMMFClass(await getDMMF({ datamodel: blog }))\n    const batches: any[] = []\n    const requests: any[] = []\n\n    const fetcher = new RequestHandler({\n      $connect: () => Promise.resolve(),\n      _engine: {\n        // @ts-expect-error\n        requestBatch: (batch) => {\n          batches.push(batch)\n          return Promise.resolve(batch.map(() => ({ data: { data: null }, elapsed: 0.2 })))\n        },\n        // @ts-expect-error\n        request: (request) => {\n          requests.push(request)\n          return Promise.resolve({ data: { data: null }, elapsed: 0.3 })\n        },\n      },\n    })\n\n    await Promise.all([\n      fetcher.request({\n        clientMethod: 'findUnique',\n        dataPath: [],\n        document: makeDocument({\n          dmmf,\n          select: {\n            where: {\n              id: '1',\n            },\n          },\n          rootTypeName: 'query',\n          rootField: 'findUniqueUser',\n        }),\n        isList: false,\n        rootField: 'query',\n        typeName: 'User',\n        args: {\n          where: {\n            id: '1',\n          },\n        },\n      }),\n      fetcher.request({\n        clientMethod: 'findUnique',\n        dataPath: [],\n        document: makeDocument({\n          dmmf,\n          select: {\n            where: {\n              id: '2',\n            },\n          },\n          rootTypeName: 'query',\n          rootField: 'findUniqueUser',\n        }),\n        isList: false,\n        rootField: 'query',\n        typeName: 'User',\n        args: {\n          where: {\n            id: '2',\n          },\n        },\n      }),\n    ])\n\n    expect(batches).toMatchInlineSnapshot(`\n      Array [\n        Array [\n          query {\n        findUniqueUser(where: {\n          id: \"1\"\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      },\n          query {\n        findUniqueUser(where: {\n          id: \"2\"\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      },\n        ],\n      ]\n    `)\n    expect(requests).toMatchInlineSnapshot(`Array []`)\n  })","file":"batching.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dont batch different models","suites":["batching"],"updatePoint":{"line":124,"column":35},"line":124,"code":"  test('dont batch different models', async () => {\n    const dmmf = new DMMFClass(await getDMMF({ datamodel: blog }))\n    const batches: any[] = []\n    const requests: any[] = []\n\n    const fetcher = new RequestHandler({\n      $connect: () => Promise.resolve(),\n      _engine: {\n        // @ts-expect-error\n        requestBatch: (batch) => {\n          batches.push(batch)\n          return Promise.resolve(batch.map(() => ({ data: { data: null }, elapsed: 0.2 })))\n        },\n        // @ts-expect-error\n        request: (request) => {\n          requests.push(request)\n          return Promise.resolve({ data: { data: null }, elapsed: 0.3 })\n        },\n      },\n    })\n\n    await Promise.all([\n      fetcher.request({\n        clientMethod: 'findUnique',\n        dataPath: [],\n        document: makeDocument({\n          dmmf,\n          select: {\n            where: {\n              id: '1',\n            },\n          },\n          rootTypeName: 'query',\n          rootField: 'findUniquePost',\n        }),\n        isList: false,\n        rootField: 'query',\n        typeName: 'User',\n        args: {\n          where: { id: '1' },\n        },\n      }),\n      fetcher.request({\n        clientMethod: 'findUnique',\n        dataPath: [],\n        document: makeDocument({\n          dmmf,\n          select: {\n            where: {\n              id: '2',\n            },\n          },\n          rootTypeName: 'query',\n          rootField: 'findUniqueUser',\n        }),\n        isList: false,\n        rootField: 'query',\n        typeName: 'User',\n        args: {\n          where: { id: '2' },\n        },\n      }),\n    ])\n\n    expect(batches).toMatchInlineSnapshot(`Array []`)\n    expect(requests).toMatchInlineSnapshot(`\n      Array [\n        query {\n        findUniquePost(where: {\n          id: \"1\"\n        }) {\n          id\n          createdAt\n          updatedAt\n          published\n          title\n          content\n          authorId\n          optional\n        }\n      },\n        query {\n        findUniqueUser(where: {\n          id: \"2\"\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      },\n      ]\n    `)\n  })","file":"batching.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dont batch different wheres","suites":["batching"],"updatePoint":{"line":228,"column":35},"line":228,"code":"  test('dont batch different wheres', async () => {\n    const dmmf = new DMMFClass(await getDMMF({ datamodel: blog }))\n    const batches: any[] = []\n    const requests: any[] = []\n\n    const fetcher = new RequestHandler({\n      $connect: () => Promise.resolve(),\n      _engine: {\n        // @ts-expect-error\n        requestBatch: (batch) => {\n          batches.push(batch)\n          return Promise.resolve(batch.map(() => ({ data: { data: null }, elapsed: 0.2 })))\n        },\n        // @ts-expect-error\n        request: (request) => {\n          requests.push(request)\n          return Promise.resolve({ data: { data: null }, elapsed: 0.3 })\n        },\n      },\n    })\n\n    await Promise.all([\n      fetcher.request({\n        clientMethod: 'findUnique',\n        dataPath: [],\n        document: makeDocument({\n          dmmf,\n          select: {\n            where: {\n              email: 'a@a.de',\n            },\n          },\n          rootTypeName: 'query',\n          rootField: 'findUniqueUser',\n        }),\n        isList: false,\n        rootField: 'query',\n        typeName: 'User',\n        args: { where: { email: 'a@a.de' } },\n      }),\n      fetcher.request({\n        clientMethod: 'findUnique',\n        dataPath: [],\n        document: makeDocument({\n          dmmf,\n          select: {\n            where: {\n              id: '2',\n            },\n          },\n          rootTypeName: 'query',\n          rootField: 'findUniqueUser',\n        }),\n        isList: false,\n        rootField: 'query',\n        typeName: 'User',\n        args: { where: { id: '2' } },\n      }),\n    ])\n\n    expect(batches).toMatchInlineSnapshot(`Array []`)\n    expect(requests).toMatchInlineSnapshot(`\n      Array [\n        query {\n        findUniqueUser(where: {\n          email: \"a@a.de\"\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      },\n        query {\n        findUniqueUser(where: {\n          id: \"2\"\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      },\n      ]\n    `)\n  })","file":"batching.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"should error correctly with invalid flags","suites":["BinaryEngine"],"updatePoint":{"line":6,"column":49},"line":6,"code":"  test('should error correctly with invalid flags', async () => {\n    // Skip for Node-API library\n    // TODO Better scoping when to run this test so this conditional is not necessary\n    if (getClientEngineType() === ClientEngineType.Library) {\n      return\n    }\n\n    try {\n      const engine = new BinaryEngine({\n        flags: ['--flag-that-does-not-exist'],\n        datamodelPath: path.join(__dirname, './runtime-tests/blog/schema.prisma'),\n        tracingConfig: { enabled: false, middleware: false },\n        env: {},\n      })\n      await engine.start()\n    } catch (e) {\n      expect(e.message).toMatch(` Found argument '--flag-that-does-not-exist' which wasn't expected`)\n    }\n  })","file":"binaryEngine.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"generates annotations for a schema and a single engine","suites":["library"],"updatePoint":{"line":13,"column":60},"line":13,"code":"  it('generates annotations for a schema and a single engine', () => {\n    const annotations = buildNFTAnnotations(false, ClientEngineType.Library, ['debian-openssl-1.1.x'], 'out')\n\n    expect(normalizePaths(annotations)).toMatchInlineSnapshot(`\n\n      path.join(__dirname, \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\");\n      path.join(process.cwd(), \"out/libquery_engine-TEST_PLATFORM.so.node\")\n      path.join(__dirname, \"schema.prisma\");\n      path.join(process.cwd(), \"out/schema.prisma\")\n    `)\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"generates annotations for a schema and multiple engines","suites":["library"],"updatePoint":{"line":25,"column":61},"line":25,"code":"  it('generates annotations for a schema and multiple engines', () => {\n    const annotations = buildNFTAnnotations(\n      false,\n      ClientEngineType.Library,\n      ['debian-openssl-1.1.x', 'darwin', 'windows'],\n      'out',\n    )\n\n    expect(normalizePaths(annotations)).toMatchInlineSnapshot(`\n\n      path.join(__dirname, \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\");\n      path.join(process.cwd(), \"out/libquery_engine-TEST_PLATFORM.so.node\")\n\n      path.join(__dirname, \"libquery_engine-TEST_PLATFORM.dylib.node\");\n      path.join(process.cwd(), \"out/libquery_engine-TEST_PLATFORM.dylib.node\")\n\n      path.join(__dirname, \"query_engine-TEST_PLATFORM.dll.node\");\n      path.join(process.cwd(), \"out/query_engine-TEST_PLATFORM.dll.node\")\n      path.join(__dirname, \"schema.prisma\");\n      path.join(process.cwd(), \"out/schema.prisma\")\n    `)\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"generates annotations for a schema and a single engine","suites":["binary"],"updatePoint":{"line":50,"column":60},"line":50,"code":"  it('generates annotations for a schema and a single engine', () => {\n    const annotations = buildNFTAnnotations(false, ClientEngineType.Binary, ['debian-openssl-1.1.x'], 'out')\n\n    expect(normalizePaths(annotations)).toMatchInlineSnapshot(`\n\n      path.join(__dirname, \"query-engine-TEST_PLATFORM\");\n      path.join(process.cwd(), \"out/query-engine-TEST_PLATFORM\")\n      path.join(__dirname, \"schema.prisma\");\n      path.join(process.cwd(), \"out/schema.prisma\")\n    `)\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"generates annotations for a schema and multiple engines","suites":["binary"],"updatePoint":{"line":62,"column":61},"line":62,"code":"  it('generates annotations for a schema and multiple engines', () => {\n    const annotations = buildNFTAnnotations(\n      false,\n      ClientEngineType.Binary,\n      ['debian-openssl-1.1.x', 'darwin', 'windows'],\n      'out',\n    )\n\n    expect(normalizePaths(annotations)).toMatchInlineSnapshot(`\n\n      path.join(__dirname, \"query-engine-TEST_PLATFORM\");\n      path.join(process.cwd(), \"out/query-engine-TEST_PLATFORM\")\n\n      path.join(__dirname, \"query-engine-TEST_PLATFORM\");\n      path.join(process.cwd(), \"out/query-engine-TEST_PLATFORM\")\n\n      path.join(__dirname, \"query-engine-TEST_PLATFORM\");\n      path.join(process.cwd(), \"out/query-engine-TEST_PLATFORM\")\n      path.join(__dirname, \"schema.prisma\");\n      path.join(process.cwd(), \"out/schema.prisma\")\n    `)\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"generates no annotations","suites":["dataproxy"],"updatePoint":{"line":87,"column":30},"line":87,"code":"  it('generates no annotations', () => {\n    const annotations = buildNFTAnnotations(\n      true,\n      ClientEngineType.Library,\n      ['debian-openssl-1.1.x', 'darwin', 'windows'],\n      'out',\n    )\n\n    // TODO: when using .toMatchInlineSnapshot(), this fails after updating snapshots.\n    // Probably an issue with the snapshot serializer?\n    expect(normalizePaths(annotations)).toBe(``)\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"replaces platforms with [\"rhel-openssl-1.0.x\"] on Netlify","suites":["special cases"],"updatePoint":{"line":106,"column":63},"line":106,"code":"  it('replaces platforms with [\"rhel-openssl-1.0.x\"] on Netlify', () => {\n    process.env.NETLIFY = 'true'\n\n    const annotations = buildNFTAnnotations(\n      false,\n      ClientEngineType.Library,\n      ['debian-openssl-1.1.x', 'darwin', 'windows'],\n      'out',\n    )\n\n    delete process.env.NETLIFY\n\n    expect(normalizePaths(annotations)).toMatchInlineSnapshot(`\n\n      path.join(__dirname, \"libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\");\n      path.join(process.cwd(), \"out/libquery_engine-TEST_PLATFORM.so.node\")\n      path.join(__dirname, \"schema.prisma\");\n      path.join(process.cwd(), \"out/schema.prisma\")\n    `)\n\n    expect(annotations).toContain('rhel-openssl-1.0.x')\n  })","file":"buildNFTAnnotations.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"generate correct query","suites":["date where filter"],"updatePoint":{"line":38,"column":30},"line":38,"code":"  test('generate correct query', () => {\n    const select = {\n      where: {\n        AND: [\n          { employeeId: { in: [''] } },\n          { status: 'uploaded' },\n          { paymentDate: new Date('2010-11-13T10:36:43.261Z') },\n          { publishedAt: null },\n        ],\n      },\n      data: {\n        status: 'published',\n        publishedAt: new Date('2020-11-13T10:36:43.261Z'),\n        // tests RFC 3339\n        updatedAt: '2021-01-13T12:40:47+01:00',\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'mutation',\n      rootField: 'updateManyPayslip',\n    })\n    document.validate(select, false)\n    expect(String(document)).toMatchInlineSnapshot(`\n      mutation {\n        updateManyPayslip(\n          where: {\n            AND: [\n              {\n                employeeId: {\n                  in: [\"\"]\n                }\n              },\n              {\n                status: \"uploaded\"\n              },\n              {\n                paymentDate: \"2010-11-13T10:36:43.261Z\"\n              },\n              {\n                publishedAt: null\n              }\n            ]\n          }\n          data: {\n            status: \"published\"\n            publishedAt: \"2020-11-13T10:36:43.261Z\"\n            updatedAt: \"2021-01-13T12:40:47+01:00\"\n          }\n        ) {\n          count\n        }\n      }\n    `)\n    expect(String(transformDocument(document))).toMatchInlineSnapshot(`\n      mutation {\n        updateManyPayslip(\n          where: {\n            AND: [\n              {\n                employeeId: {\n                  in: [\"\"]\n                }\n              },\n              {\n                status: \"uploaded\"\n              },\n              {\n                paymentDate: \"2010-11-13T10:36:43.261Z\"\n              },\n              {\n                publishedAt: null\n              }\n            ]\n          }\n          data: {\n            status: \"published\"\n            publishedAt: \"2020-11-13T10:36:43.261Z\"\n            updatedAt: \"2021-01-13T12:40:47+01:00\"\n          }\n        ) {\n          count\n        }\n      }\n    `)\n  })","file":"dateWhere.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"OR posts some id in","suites":["minimal where transformation"],"updatePoint":{"line":15,"column":27},"line":15,"code":"  test('OR posts some id in', () => {\n    const transformedDocument = getTransformedDocument({\n      where: {\n        OR: [\n          {\n            posts: {\n              some: {\n                OR: [\n                  {\n                    author: {\n                      OR: [\n                        {\n                          AND: [\n                            {\n                              OR: [\n                                {\n                                  id: '10',\n                                },\n                              ],\n                            },\n                          ],\n                        },\n                      ],\n                    },\n                  },\n                ],\n              },\n            },\n          },\n        ],\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          OR: [\n            {\n              posts: {\n                some: {\n                  OR: [\n                    {\n                      author: {\n                        OR: [\n                          {\n                            AND: [\n                              {\n                                OR: [\n                                  {\n                                    id: \"10\"\n                                  }\n                                ]\n                              }\n                            ]\n                          }\n                        ]\n                      }\n                    }\n                  ]\n                }\n              }\n            }\n          ]\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"deepAndOr.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"work with 0","suites":["deepGet"],"updatePoint":{"line":4,"column":19},"line":4,"code":"  test('work with 0', () => {\n    const obj = {\n      aggregateUser: {\n        count: 0,\n      },\n    }\n    const path = ['aggregateUser', 'count']\n    const result = deepGet(obj, path)\n    expect(result).toMatchInlineSnapshot(`0`)\n  })","file":"deepGet.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"work with false","suites":["deepGet"],"updatePoint":{"line":15,"column":23},"line":15,"code":"  test('work with false', () => {\n    const obj = {\n      aggregateUser: {\n        count: false,\n      },\n    }\n    const path = ['aggregateUser', 'count']\n    expect(deepGet(obj, path)).toMatchInlineSnapshot(`false`)\n  })","file":"deepGet.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"work with deep object","suites":["deepGet"],"updatePoint":{"line":25,"column":29},"line":25,"code":"  test('work with deep object', () => {\n    const obj = {\n      very: {\n        deep: {\n          obj: {\n            with: {\n              deep: 'stuff',\n            },\n          },\n        },\n      },\n    }\n    const path = ['very', 'deep', 'obj']\n    expect(deepGet(obj, path)).toMatchInlineSnapshot(`\n      Object {\n        with: Object {\n          deep: stuff,\n        },\n      }\n    `)\n  })","file":"deepGet.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"return undefined for invalid path","suites":["deepGet"],"updatePoint":{"line":47,"column":41},"line":47,"code":"  test('return undefined for invalid path', () => {\n    const obj = {\n      very: {\n        deep: {\n          obj: {\n            with: {\n              deep: 'stuff',\n            },\n          },\n        },\n      },\n    }\n    const path = ['very', 'deep', 'obj2']\n    expect(deepGet(obj, path)).toMatchInlineSnapshot(`undefined`)\n  })","file":"deepGet.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"work with array","suites":["deepGet"],"updatePoint":{"line":63,"column":23},"line":63,"code":"  test('work with array', () => {\n    const obj = [\n      {\n        id: 1,\n      },\n    ]\n\n    const path = ['0', 'id']\n    expect(deepGet(obj, path)).toMatchInlineSnapshot(`1`)\n  })","file":"deepGet.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"OR posts some id in","suites":["minimal where transformation"],"updatePoint":{"line":15,"column":27},"line":15,"code":"  test('OR posts some id in', () => {\n    const transformedDocument = getTransformedDocument({\n      where: {\n        likedArticles: {\n          some: {\n            likedBy: {\n              some: {\n                AND: {\n                  likedArticles: {\n                    some: {\n                      likedBy: {\n                        some: {\n                          likedArticles: {\n                            some: {\n                              title: {\n                                contains: 'A string',\n                              },\n                            },\n                          },\n                        },\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          likedArticles: {\n            some: {\n              likedBy: {\n                some: {\n                  AND: {\n                    likedArticles: {\n                      some: {\n                        likedBy: {\n                          some: {\n                            likedArticles: {\n                              some: {\n                                title: {\n                                  contains: \"A string\"\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }) {\n          id\n          name\n          email\n          personaId\n        }\n      }\n    `)\n  })","file":"deepQuery.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"OR posts some id in","suites":["minimal where transformation"],"updatePoint":{"line":15,"column":27},"line":15,"code":"  test('OR posts some id in', () => {\n    const transformedDocument = getTransformedDocument({\n      where: {\n        posts: {\n          some: {\n            author: {\n              posts: {\n                some: {\n                  author: {\n                    posts: {\n                      some: {\n                        id: '5',\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          posts: {\n            some: {\n              author: {\n                posts: {\n                  some: {\n                    author: {\n                      posts: {\n                        some: {\n                          id: \"5\"\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"deepSome.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"int","suites":["deserializeRawResults"],"updatePoint":{"line":4,"column":11},"line":4,"code":"  test('int', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'int',\n            prisma__value: 42,\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: 42,\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"bigint","suites":["deserializeRawResults"],"updatePoint":{"line":21,"column":14},"line":21,"code":"  test('bigint', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'bigint',\n            prisma__value: '10000',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: BigInt(10000),\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"floating point","suites":["deserializeRawResults"],"updatePoint":{"line":38,"column":22},"line":38,"code":"  test('floating point', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'float',\n            prisma__value: 1.5,\n          },\n          b: {\n            prisma__type: 'double',\n            prisma__value: 0.5,\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: 1.5,\n        b: 0.5,\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"string","suites":["deserializeRawResults"],"updatePoint":{"line":60,"column":14},"line":60,"code":"  test('string', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'string',\n            prisma__value: 'hello',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: 'hello',\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"enum","suites":["deserializeRawResults"],"updatePoint":{"line":77,"column":12},"line":77,"code":"  test('enum', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'enum',\n            prisma__value: 'value',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: 'value',\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"bytes","suites":["deserializeRawResults"],"updatePoint":{"line":94,"column":13},"line":94,"code":"  test('bytes', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'bytes',\n            prisma__value: 'Ynl0ZXM=',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: Buffer.from('bytes'),\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"bool","suites":["deserializeRawResults"],"updatePoint":{"line":111,"column":12},"line":111,"code":"  test('bool', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'bool',\n            prisma__value: true,\n          },\n          b: {\n            prisma__type: 'bool',\n            prisma__value: false,\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: true,\n        b: false,\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"null","suites":["deserializeRawResults"],"updatePoint":{"line":133,"column":12},"line":133,"code":"  test('null', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'null',\n            prisma__value: null,\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: null,\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"json","suites":["deserializeRawResults"],"updatePoint":{"line":150,"column":12},"line":150,"code":"  test('json', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'json',\n            prisma__value: {\n              a: 1,\n              b: [2],\n            },\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: {\n          a: 1,\n          b: [2],\n        },\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"date and time","suites":["deserializeRawResults"],"updatePoint":{"line":173,"column":21},"line":173,"code":"  test('date and time', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'datetime',\n            prisma__value: '2022-01-01T00:00:00.000Z',\n          },\n          b: {\n            prisma__type: 'date',\n            prisma__value: '2022-05-04',\n          },\n          c: {\n            prisma__type: 'time',\n            prisma__value: '14:10:45.912',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: new Date('2022-01-01T00:00:00.000Z'),\n        b: new Date('2022-05-04T00:00:00.000Z'),\n        c: new Date('1970-01-01T14:10:45.912Z'),\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"unsupported","suites":["deserializeRawResults"],"updatePoint":{"line":200,"column":19},"line":200,"code":"  test('unsupported', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'char',\n            prisma__value: 'a',\n          },\n          b: {\n            prisma__type: 'xml',\n            prisma__value: '<xml></xml>',\n          },\n          c: {\n            prisma__type: 'uuid',\n            prisma__value: '00000000-0000-0000-0000-000000000000',\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: 'a',\n        b: '<xml></xml>',\n        c: '00000000-0000-0000-0000-000000000000',\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"array","suites":["deserializeRawResults"],"updatePoint":{"line":227,"column":13},"line":227,"code":"  test('array', () => {\n    expect(\n      deserializeRawResults([\n        {\n          a: {\n            prisma__type: 'array',\n            prisma__value: [\n              {\n                prisma__type: 'int',\n                prisma__value: 1,\n              },\n              {\n                prisma__type: 'int',\n                prisma__value: 2,\n              },\n            ],\n          },\n        },\n      ]),\n    ).toEqual([\n      {\n        a: [1, 2],\n      },\n    ])\n  })","file":"deserializeRawResults.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf enum filter mysql","suites":["dmmf"],"updatePoint":{"line":7,"column":30},"line":7,"code":"  test('dmmf enum filter mysql', async () => {\n    const datamodel = `\n      datasource db {\n        provider = \"mysql\"\n        url      = env(\"MY_MYSQL_DB\")\n      }\n      \n      model User {\n        id Int @id @default(autoincrement())\n        name String\n        email String @unique\n        kind PostKind\n      }\n      \n      enum PostKind {\n        NICE\n        AWESOME\n      }`\n\n    const dmmf = await getDMMF({ datamodel })\n    expect(dmmf.schema.inputObjectTypes.prisma.find((i) => i.name === 'NestedEnumPostKindFilter'))\n      .toMatchInlineSnapshot(`\n      Object {\n        constraints: Object {\n          maxNumFields: null,\n          minNumFields: null,\n        },\n        fields: Array [\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: equals,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: in,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: notIn,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              Object {\n                isList: false,\n                location: inputObjectTypes,\n                namespace: prisma,\n                type: NestedEnumPostKindFilter,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: not,\n          },\n        ],\n        name: NestedEnumPostKindFilter,\n      }\n    `)\n    expect(dmmf.schema.inputObjectTypes.prisma.find((i) => i.name === 'EnumPostKindFilter')).toMatchInlineSnapshot(`\n      Object {\n        constraints: Object {\n          maxNumFields: null,\n          minNumFields: null,\n        },\n        fields: Array [\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: equals,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: in,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: notIn,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              Object {\n                isList: false,\n                location: inputObjectTypes,\n                namespace: prisma,\n                type: NestedEnumPostKindFilter,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: not,\n          },\n        ],\n        name: EnumPostKindFilter,\n      }\n    `)\n  })","file":"dmmf.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf enum filter postgresql","suites":["dmmf"],"updatePoint":{"line":168,"column":35},"line":168,"code":"  test('dmmf enum filter postgresql', async () => {\n    const datamodel = `\n      datasource db {\n        provider = \"postgresql\"\n        url      = env(\"MY_POSTGRES_DB\")\n      }\n      \n      model User {\n        id Int @id @default(autoincrement())\n        name String\n        email String @unique\n        kind PostKind\n      }\n      \n      enum PostKind {\n        NICE\n        AWESOME\n      }`\n\n    const dmmf = await getDMMF({ datamodel })\n    expect(dmmf.schema.inputObjectTypes.prisma.find((i) => i.name === 'NestedEnumPostKindFilter'))\n      .toMatchInlineSnapshot(`\n      Object {\n        constraints: Object {\n          maxNumFields: null,\n          minNumFields: null,\n        },\n        fields: Array [\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: equals,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: in,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: notIn,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              Object {\n                isList: false,\n                location: inputObjectTypes,\n                namespace: prisma,\n                type: NestedEnumPostKindFilter,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: not,\n          },\n        ],\n        name: NestedEnumPostKindFilter,\n      }\n    `)\n    expect(dmmf.schema.inputObjectTypes.prisma.find((i) => i.name === 'EnumPostKindFilter')).toMatchInlineSnapshot(`\n      Object {\n        constraints: Object {\n          maxNumFields: null,\n          minNumFields: null,\n        },\n        fields: Array [\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: equals,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: in,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: true,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: notIn,\n          },\n          Object {\n            inputTypes: Array [\n              Object {\n                isList: false,\n                location: enumTypes,\n                namespace: model,\n                type: PostKind,\n              },\n              Object {\n                isList: false,\n                location: inputObjectTypes,\n                namespace: prisma,\n                type: NestedEnumPostKindFilter,\n              },\n            ],\n            isNullable: false,\n            isRequired: false,\n            name: not,\n          },\n        ],\n        name: EnumPostKindFilter,\n      }\n    `)\n  })","file":"dmmf.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf enum should fail on sqlite","suites":["dmmf"],"updatePoint":{"line":329,"column":39},"line":329,"code":"  test('dmmf enum should fail on sqlite', async () => {\n    const datamodel = `\n      datasource db {\n        provider = \"sqlite\"\n        url      = \"file:./dev.db\"\n      }\n\n      model User {\n        id Int @id @default(autoincrement())\n        name String\n        email String @unique\n        kind PostKind\n      }\n\n      enum PostKind {\n        NICE\n        AWESOME\n      }`\n\n    try {\n      await getDMMF({ datamodel })\n    } catch (e) {\n      expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(`\n        Schema validation error - Error (query-engine-NORMALIZED)\n        Error code: P1012\n        error: Error validating: You defined the enum \\`PostKind\\`. But the current connector does not support enums.\n          -->  schema.prisma:14\n           | \n        13 | \n        14 |       enum PostKind {\n        15 |         NICE\n        16 |         AWESOME\n        17 |       }\n           | \n\n        Validation Error Count: 1\n        [Context: getDmmf]\n\n        Prisma CLI Version : 0.0.0\n      `)\n    }\n  })","file":"dmmf.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf types","suites":[],"line":28,"code":"test.skip('dmmf types', async () => {","file":"dmmfTypes.test.ts","skipped":true,"dir":"packages/client/src/__tests__"},{"name":"document stringify","suites":[],"updatePoint":{"line":3,"column":24},"line":3,"code":"test('document stringify', () => {\n  const document = new Document('query', [\n    new Field({\n      name: 'users',\n      args: new Args([\n        new Arg({\n          key: 'mirst',\n          value: 100,\n          error: {\n            didYouMeanArg: 'first',\n            providedName: 'mirst',\n            providedValue: '',\n            type: 'invalidName',\n            originalType: 'String',\n          },\n        }),\n        new Arg({\n          key: 'skip',\n          value: '200',\n          error: {\n            type: 'invalidType',\n            providedValue: '200',\n            argName: 'skip',\n            requiredType: {\n              inputType: [\n                {\n                  isList: false,\n                  location: 'scalar',\n                  type: 'number',\n                },\n              ],\n              bestFittingType: {\n                isList: false,\n                location: 'scalar',\n                type: 'number',\n              },\n            },\n          },\n        }),\n        new Arg({\n          key: 'where',\n          value: new Args([\n            new Arg({ key: 'age_gt', value: 10 }),\n            new Arg({ key: 'age_in', value: [1, 2, 3] }),\n            new Arg({ key: 'name_in', value: ['hans', 'peter', 'schmidt'] }),\n            new Arg({\n              key: 'OR',\n              value: [\n                new Args([\n                  new Arg({ key: 'age_gt', value: 10123123123 }),\n                  new Arg({\n                    key: 'email_endsWith',\n                    value: 'veryLongNameGoIntoaNewLineNow@gmail.com',\n                  }),\n                ]),\n                new Args([\n                  new Arg({ key: 'age_gt', value: 10123123123 }),\n                  new Arg({\n                    key: 'email_endsWith',\n                    value: 'veryLongNameGoIntoaNewLineNow@gmail.com',\n                  }),\n                  new Arg({\n                    key: 'OR',\n                    value: [\n                      new Args([\n                        new Arg({ key: 'age_gt', value: 10123123123 }),\n                        new Arg({\n                          key: 'email_endsWith',\n                          value: 'veryLongNameGoIntoaNewLineNow@gmail.com',\n                        }),\n                      ]),\n                    ],\n                  }),\n                ]),\n              ],\n            }),\n          ]),\n        }),\n      ]),\n      children: [\n        new Field({ name: 'id' }),\n        new Field({\n          name: 'name2',\n          error: {\n            modelName: 'User',\n            didYouMean: 'name',\n            providedName: 'name2',\n            type: 'invalidFieldName',\n            outputType: {\n              fields: [],\n              name: 'User',\n              fieldMap: {},\n            },\n          },\n        }),\n        new Field({\n          name: 'friends',\n          args: new Args(),\n          children: [new Field({ name: 'id' }), new Field({ name: 'name' })],\n        }),\n        new Field({\n          name: 'posts',\n          args: new Args([new Arg({ key: 'first', value: 200 })]),\n          children: [new Field({ name: 'id' }), new Field({ name: 'name' })],\n        }),\n      ],\n    }),\n  ])\n\n  expect(String(document)).toMatchInlineSnapshot(`\n    query {\n      users(\n        mirst: 100\n        skip: \"200\"\n        where: {\n          age_gt: 10\n          age_in: [1, 2, 3]\n          name_in: [\"hans\", \"peter\", \"schmidt\"]\n          OR: [\n            {\n              age_gt: 10123123123\n              email_endsWith: \"veryLongNameGoIntoaNewLineNow@gmail.com\"\n            },\n            {\n              age_gt: 10123123123\n              email_endsWith: \"veryLongNameGoIntoaNewLineNow@gmail.com\"\n              OR: [\n                {\n                  age_gt: 10123123123\n                  email_endsWith: \"veryLongNameGoIntoaNewLineNow@gmail.com\"\n                }\n              ]\n            }\n          ]\n        }\n      ) {\n        id\n        name2 # INVALID_FIELD\n        friends {\n          id\n          name\n        }\n        posts(first: 200) {\n          id\n          name\n        }\n      }\n    }\n  `)\n})","file":"document.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"ignore comments","suites":[],"updatePoint":{"line":4,"column":21},"line":4,"code":"test('ignore comments', () => {\n  const datamodel = `datasource db {\n    provider = \"sqlite\"\n    // url = \"file:another/wrong/folder/dev.db\"\n    url      = \"file:my/folder/dev.db\"\n  }\n\n  generator client {\n    provider  = \"prisma-client-js\"\n    output    = \"@prisma/client\"\n    transpile = false\n  }\n\n  model User {\n    id    String  @id @default(uuid())\n    email String  @unique\n    name  String?\n    posts Post[]\n  }\n\n  model Post {\n    id         String   @id @default(uuid())\n    createdAt  DateTime @default(now())\n    updatedAt  DateTime @updatedAt\n    randomDate DateTime\n    published  Boolean\n    title      String\n    content    String?\n    author     User?\n  }\n\n  /// Role num comment\n  enum Role {\n    USER\n    ADMIN\n  }`\n\n  const result = extractSqliteSources(datamodel, '/cwd', '/outputdir')\n\n  expect(result).toMatchInlineSnapshot(`\n    Array [\n      Object {\n        name: db,\n        url: ../cwd/my/folder/dev.db,\n      },\n    ]\n  `)\n\n  let serializedResult = serializeDatasources(result)\n\n  // TODO: Windows: fixup to work around a bug in jestSnapshotSerializer\n  if (process.platform === 'win32') {\n    serializedResult = serializedResult.replace(/\\\\\\\\/g, '/')\n  }\n\n  expect(serializedResult).toMatchInlineSnapshot(`\n    [\n      {\n        \"name\": \"db\",\n        \"url\": \"../cwd/my/folder/dev.db\"\n      }\n    ]\n  `)\n})","file":"extractSqliteSources.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"basic happy path","suites":[],"updatePoint":{"line":69,"column":22},"line":69,"code":"test('basic happy path', () => {\n  const datamodel = `datasource db {\n    provider = \"sqlite\"\n    url      = \"file:my/folder/dev.db\"\n    \n  }\n\n  generator client {\n    provider  = \"prisma-client-js\"\n    output    = \"@prisma/client\"\n    transpile = false\n  }\n\n  model User {\n    id    String  @id @default(uuid())\n    email String  @unique\n    name  String?\n    posts Post[]\n  }\n\n  model Post {\n    id         String   @id @default(uuid())\n    createdAt  DateTime @default(now())\n    updatedAt  DateTime @updatedAt\n    randomDate DateTime\n    published  Boolean\n    title      String\n    content    String?\n    author     User?\n  }\n\n  /// Role num comment\n  enum Role {\n    USER\n    ADMIN\n  }`\n\n  const result = extractSqliteSources(datamodel, '/cwd', '/outputdir')\n\n  expect(result).toMatchInlineSnapshot(`\n    Array [\n      Object {\n        name: db,\n        url: ../cwd/my/folder/dev.db,\n      },\n    ]\n  `)\n\n  let serializedResult = serializeDatasources(result)\n\n  // TODO: Windows: fixup to work around a bug in jestSnapshotSerializer\n  if (process.platform === 'win32') {\n    serializedResult = serializedResult.replace(/\\\\\\\\/g, '/')\n  }\n\n  expect(serializedResult).toMatchInlineSnapshot(`\n    [\n      {\n        \"name\": \"db\",\n        \"url\": \"../cwd/my/folder/dev.db\"\n      }\n    ]\n  `)\n})","file":"extractSqliteSources.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"minimal","suites":["generator"],"updatePoint":{"line":24,"column":15},"line":24,"code":"  test('minimal', async () => {\n    const prismaClientTarget = path.join(__dirname, './node_modules/@prisma/client')\n    // Make sure, that nothing is cached.\n    try {\n      await del(prismaClientTarget)\n    } catch (e) {\n      //\n    }\n    await getPackedPackage('@prisma/client', prismaClientTarget)\n\n    if (!fs.existsSync(prismaClientTarget)) {\n      throw new Error(`Prisma Client didn't get packed properly 🤔`)\n    }\n\n    const generator = await getGenerator({\n      schemaPath: path.join(__dirname, 'schema.prisma'),\n      baseDir: __dirname,\n      printDownloadProgress: false,\n      skipDownload: true,\n      dataProxy: false,\n    })\n\n    const manifest = omit<any, any>(generator.manifest, ['version']) as any\n\n    if (manifest.requiresEngineVersion.length !== 40) {\n      throw new Error(`Generator manifest should have \"requiresEngineVersion\" with length 40`)\n    }\n    manifest.requiresEngineVersion = 'ENGINE_VERSION_TEST'\n\n    if (getClientEngineType() === ClientEngineType.Library) {\n      expect(manifest).toMatchInlineSnapshot(`\n        Object {\n          defaultOutput: .prisma/client,\n          prettyName: Prisma Client,\n          requiresEngineVersion: ENGINE_VERSION_TEST,\n          requiresEngines: Array [\n            libqueryEngine,\n          ],\n        }\n      `)\n    } else {\n      expect(manifest).toMatchInlineSnapshot(`\n        Object {\n          defaultOutput: .prisma/client,\n          prettyName: Prisma Client,\n          requiresEngineVersion: ENGINE_VERSION_TEST,\n          requiresEngines: Array [\n            queryEngine,\n          ],\n        }\n      `)\n    }\n\n    expect(omit(generator.options!.generator, ['output'])).toMatchInlineSnapshot(`\n      Object {\n        binaryTargets: Array [],\n        config: Object {},\n        name: client,\n        previewFeatures: Array [],\n        provider: Object {\n          fromEnvVar: null,\n          value: prisma-client-js,\n        },\n      }\n    `)\n\n    expect(path.relative(__dirname, parseEnvValue(generator.options!.generator.output!))).toMatchInlineSnapshot(\n      `node_modules/@prisma/client`,\n    )\n\n    await generator.generate()\n    const photonDir = path.join(__dirname, 'node_modules/@prisma/client')\n    expect(fs.existsSync(photonDir)).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index.js'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index-browser.js'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index.d.ts'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'runtime'))).toBe(true)\n    generator.stop()\n  })","file":"generation/generator.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"denylist from engine validation","suites":["generator"],"updatePoint":{"line":104,"column":39},"line":104,"code":"  test('denylist from engine validation', async () => {\n    expect.assertions(1)\n    const prismaClientTarget = path.join(__dirname, './node_modules/@prisma/client')\n    // Make sure, that nothing is cached.\n    try {\n      await del(prismaClientTarget)\n    } catch (e) {\n      //\n    }\n    await getPackedPackage('@prisma/client', prismaClientTarget)\n\n    if (!fs.existsSync(prismaClientTarget)) {\n      throw new Error(`Prisma Client didn't get packed properly 🤔`)\n    }\n\n    try {\n      await getGenerator({\n        schemaPath: path.join(__dirname, 'denylist.prisma'),\n        baseDir: __dirname,\n        printDownloadProgress: false,\n        skipDownload: true,\n        dataProxy: false,\n      })\n    } catch (e) {\n      expect(serializeQueryEngineName(stripAnsi(e.message))).toMatchInlineSnapshot(`\n        Schema validation error - Error (query-engine-NORMALIZED)\n        Error code: P1012\n        error: Error validating model \"public\": The model name \\`public\\` is invalid. It is a reserved name. Please change it. Read more at https://pris.ly/d/naming-models\n          -->  schema.prisma:10\n           | \n         9 | \n        10 | model public {\n        11 |   id Int @id\n        12 | }\n           | \n        error: Error validating model \"return\": The model name \\`return\\` is invalid. It is a reserved name. Please change it. Read more at https://pris.ly/d/naming-models\n          -->  schema.prisma:14\n           | \n        13 | \n        14 | model return {\n        15 |   id Int @id\n        16 | }\n           | \n\n        Validation Error Count: 2\n        [Context: getDmmf]\n\n        Prisma CLI Version : 0.0.0\n      `)\n    }\n  })","file":"generation/generator.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"schema path does not exist","suites":["generator"],"updatePoint":{"line":156,"column":34},"line":156,"code":"  test('schema path does not exist', async () => {\n    const prismaClientTarget = path.join(__dirname, './node_modules/@prisma/client')\n    // Make sure, that nothing is cached.\n    try {\n      await del(prismaClientTarget)\n    } catch (e) {\n      //\n    }\n    await getPackedPackage('@prisma/client', prismaClientTarget)\n\n    if (!fs.existsSync(prismaClientTarget)) {\n      throw new Error(`Prisma Client didn't get packed properly 🤔`)\n    }\n\n    let doesnNotExistError\n    try {\n      await getGenerator({\n        schemaPath: path.join(__dirname, 'doesnotexist.prisma'),\n        baseDir: __dirname,\n        printDownloadProgress: false,\n        skipDownload: true,\n        dataProxy: false,\n      })\n    } catch (e) {\n      doesnNotExistError = e\n    } finally {\n      expect(stripAnsi(doesnNotExistError.message).split('generation' + path.sep)[1]).toMatchInlineSnapshot(\n        `doesnotexist.prisma does not exist`,\n      )\n    }\n  })","file":"generation/generator.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"override client package","suites":["generator"],"updatePoint":{"line":188,"column":31},"line":188,"code":"  test('override client package', async () => {\n    const generator = await getGenerator({\n      schemaPath: path.join(__dirname, 'main-package-override.prisma'),\n      baseDir: __dirname,\n      printDownloadProgress: false,\n      skipDownload: true,\n      dataProxy: false,\n    })\n\n    try {\n      await expect(generator.generate()).rejects.toThrowErrorMatchingInlineSnapshot(`\n        Generating client into /client/src/__tests__/generation/__fixture__/@prisma/client is not allowed.\n        This package is used by \\`prisma generate\\` and overwriting its content is dangerous.\n\n        Suggestion:\n        In /client/src/__tests__/generation/main-package-override.prisma replace:\n\n        8 output   = \"./__fixture__/@prisma/client\"\n        with\n        8 output   = \"./__fixture__/.prisma/client\"\n\n        You won't need to change your imports.\n        Imports from \\`@prisma/client\\` will be automatically forwarded to \\`.prisma/client\\`\n      `)\n    } finally {\n      generator.stop()\n    }\n  })","file":"generation/generator.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"mongo","suites":["generator"],"updatePoint":{"line":217,"column":13},"line":217,"code":"  test('mongo', async () => {\n    const prismaClientTarget = path.join(__dirname, './node_modules/@prisma/client')\n    // Make sure, that nothing is cached.\n    try {\n      await del(prismaClientTarget)\n    } catch (e) {\n      //\n    }\n    await getPackedPackage('@prisma/client', prismaClientTarget)\n\n    if (!fs.existsSync(prismaClientTarget)) {\n      throw new Error(`Prisma Client didn't get packed properly 🤔`)\n    }\n\n    const generator = await getGenerator({\n      schemaPath: path.join(__dirname, 'mongo.prisma'),\n      baseDir: __dirname,\n      printDownloadProgress: false,\n      skipDownload: true,\n      dataProxy: false,\n    })\n\n    const manifest = omit<any, any>(generator.manifest, ['version']) as any\n\n    if (manifest.requiresEngineVersion.length !== 40) {\n      throw new Error(`Generator manifest should have \"requiresEngineVersion\" with length 40`)\n    }\n    manifest.requiresEngineVersion = 'ENGINE_VERSION_TEST'\n\n    if (getClientEngineType(generator.config) === ClientEngineType.Library) {\n      expect(manifest).toMatchInlineSnapshot(`\n        Object {\n          defaultOutput: .prisma/client,\n          prettyName: Prisma Client,\n          requiresEngineVersion: ENGINE_VERSION_TEST,\n          requiresEngines: Array [\n            libqueryEngine,\n          ],\n        }\n      `)\n    } else {\n      expect(manifest).toMatchInlineSnapshot(`\n        Object {\n          defaultOutput: .prisma/client,\n          prettyName: Prisma Client,\n          requiresEngineVersion: ENGINE_VERSION_TEST,\n          requiresEngines: Array [\n            queryEngine,\n          ],\n        }\n      `)\n    }\n\n    expect(omit(generator.options!.generator, ['output'])).toMatchInlineSnapshot(`\n      Object {\n        binaryTargets: Array [],\n        config: Object {},\n        name: client,\n        previewFeatures: Array [],\n        provider: Object {\n          fromEnvVar: null,\n          value: prisma-client-js,\n        },\n      }\n    `)\n\n    expect(path.relative(__dirname, parseEnvValue(generator.options!.generator.output!))).toMatchInlineSnapshot(\n      `node_modules/@prisma/client`,\n    )\n\n    await generator.generate()\n    const photonDir = path.join(__dirname, 'node_modules/@prisma/client')\n    expect(fs.existsSync(photonDir)).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index.js'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index-browser.js'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'index.d.ts'))).toBe(true)\n    expect(fs.existsSync(path.join(photonDir, 'runtime'))).toBe(true)\n    generator.stop()\n  })","file":"generation/generator.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"info and warn","suites":[],"updatePoint":{"line":3,"column":19},"line":3,"code":"test('info and warn', () => {\n  const level = getLogLevel([\n    {\n      emit: 'event',\n      level: 'info',\n    },\n    {\n      emit: 'event',\n      level: 'warn',\n    },\n  ])\n\n  expect(level).toMatchInlineSnapshot(`info`)\n})","file":"getLogLevel.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"query","suites":[],"updatePoint":{"line":18,"column":11},"line":18,"code":"test('query', () => {\n  const level = getLogLevel([\n    {\n      emit: 'event',\n      level: 'query',\n    },\n  ])\n\n  expect(level).toMatchInlineSnapshot(`undefined`)\n})","file":"getLogLevel.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"strings and objects","suites":[],"updatePoint":{"line":29,"column":25},"line":29,"code":"test('strings and objects', () => {\n  const level = getLogLevel([\n    {\n      emit: 'event',\n      level: 'query',\n    },\n    'warn',\n  ])\n\n  expect(level).toMatchInlineSnapshot(`warn`)\n})","file":"getLogLevel.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"strings","suites":[],"updatePoint":{"line":40,"column":13},"line":40,"code":"test('strings', () => {\n  const level = getLogLevel('warn')\n\n  expect(level).toMatchInlineSnapshot(`warn`)\n})","file":"getLogLevel.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"strings array","suites":[],"updatePoint":{"line":46,"column":19},"line":46,"code":"test('strings array', () => {\n  const level = getLogLevel(['warn', 'error'])\n\n  expect(level).toMatchInlineSnapshot(`error`)\n})","file":"getLogLevel.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"deep include query","suites":["include validation"],"updatePoint":{"line":15,"column":26},"line":15,"code":"  test('deep include query', () => {\n    const ast = {\n      include: {\n        author: {\n          include: {\n            posts: true,\n          },\n        },\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dont allow empty include statements","suites":["include validation"],"updatePoint":{"line":37,"column":43},"line":37,"code":"  test('dont allow empty include statements', () => {\n    const ast = {\n      include: {},\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(ast, false)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n\nInvalid \\`prisma.findManyPost()\\` invocation:\n\n{\n  include: {\n?   author?: true,\n?   categories?: true,\n?   _count?: true\n  }\n}\n\n\nThe \\`include\\` statement for type Post must not be empty. Available options are listed in green.\n\n`)\n    }\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allow normal findMany without include for empty model","suites":["include validation"],"updatePoint":{"line":72,"column":61},"line":72,"code":"  test('allow normal findMany without include for empty model', () => {\n    const ast = {}\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyNoRelations',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    document.validate(ast, false)\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"enforce no include, if no relation","suites":["include validation"],"updatePoint":{"line":86,"column":42},"line":86,"code":"  test('enforce no include, if no relation', () => {\n    const ast = {\n      include: {},\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyNoRelations',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(ast, false)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n\n        Invalid \\`prisma.findManyNoRelations()\\` invocation:\n\n        {\n          include: {}\n        }\n\n\n        NoRelations does not have any relation and therefore can't have an \\`include\\` statement.\n\n      `)\n    }\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"enforce empty include, if no relation","suites":["include validation"],"updatePoint":{"line":117,"column":45},"line":117,"code":"  test('enforce empty include, if no relation', () => {\n    const ast = {\n      include: {\n        asd: true,\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyNoRelations',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(ast, false)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n\n        Invalid \\`prisma.asd()\\` invocation:\n\n        {\n          include: {\n            asd: true\n            ~~~\n          }\n        }\n\n\n        Unknown field \\`asd\\` for include statement on model NoRelations.\n        This model has no relations, so you can't use include with it.\n\n      `)\n    }\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allow include statement with only false properties","suites":["include validation"],"updatePoint":{"line":158,"column":58},"line":158,"code":"  test('allow include statement with only false properties', () => {\n    const ast = {\n      include: {\n        author: true,\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allow deep include with empty object","suites":["include validation"],"updatePoint":{"line":176,"column":44},"line":176,"code":"  test('allow deep include with empty object', () => {\n    const ast = {\n      include: {\n        posts: {},\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyUser {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n          posts {\n            id\n            createdAt\n            updatedAt\n            published\n            title\n            content\n            authorId\n            optional\n          }\n        }\n      }\n    `)\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allow deep include without another include","suites":["include validation"],"updatePoint":{"line":222,"column":50},"line":222,"code":"  test('allow deep include without another include', () => {\n    const ast = {\n      include: {\n        posts: { take: 20 },\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"handle scalar fields special","suites":["include validation"],"updatePoint":{"line":240,"column":36},"line":240,"code":"  test('handle scalar fields special', () => {\n    const ast = {\n      include: {\n        id: true,\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(ast, false)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n\nInvalid \\`prisma.id()\\` invocation:\n\n{\n  include: {\n    id: true,\n    ~~\n?   author?: true,\n?   categories?: true,\n?   _count?: true\n  }\n}\n\n\nInvalid scalar field \\`id\\` for include statement on model Post. Available options are listed in green.\nNote, that include statements only accept relation fields.\n\n`)\n    }\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"catch unknown field name","suites":["include validation"],"updatePoint":{"line":280,"column":32},"line":280,"code":"  test('catch unknown field name', () => {\n    const ast = {\n      include: {\n        mauthor: true,\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(ast, false)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n\nInvalid \\`prisma.mauthor()\\` invocation:\n\n{\n  include: {\n    mauthor: true,\n    ~~~~~~~\n?   author?: true,\n?   categories?: true,\n?   _count?: true\n  }\n}\n\n\nUnknown field \\`mauthor\\` for include statement on model Post. Available options are listed in green. Did you mean \\`author\\`?\n\n`)\n    }\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allow include with a select","suites":["include validation"],"updatePoint":{"line":319,"column":35},"line":319,"code":"  test('allow include with a select', () => {\n    const ast = {\n      include: {\n        posts: {\n          take: 20,\n          select: {\n            id: true,\n          },\n        },\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyUser {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n          posts(take: 20) {\n            id\n          }\n        }\n      }\n    `)\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allow include with a select with an include","suites":["include validation"],"updatePoint":{"line":363,"column":51},"line":363,"code":"  test('allow include with a select with an include', () => {\n    const ast = {\n      include: {\n        posts: {\n          take: 20,\n          select: {\n            id: true,\n            author: {\n              include: { posts: true },\n            },\n          },\n        },\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyUser {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n          posts(take: 20) {\n            id\n            author {\n              id\n              email\n              name\n              json\n              countFloat\n              countInt1\n              countInt2\n              countInt3\n              countInt4\n              countInt5\n              countInt6\n              lastLoginAt\n              coinflips\n              posts {\n                id\n                createdAt\n                updatedAt\n                published\n                title\n                content\n                authorId\n                optional\n              }\n            }\n          }\n        }\n      }\n    `)\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"include.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing-engine-native-binaryTarget: binary","suites":[],"updatePoint":{"line":8,"column":48},"line":8,"code":"test('missing-engine-native-binaryTarget: binary', async () => {\n  if (getClientEngineType() !== ClientEngineType.Binary) {\n    return\n  }\n\n  expect.assertions(1)\n  await generateTestClient()\n\n  const { PrismaClient } = require('./node_modules/@prisma/client')\n\n  const platform = await getPlatform()\n  let binaryPath =\n    getClientEngineType() === ClientEngineType.Library\n      ? path.join(__dirname, 'node_modules/.prisma/client', getNodeAPIName(platform, 'fs'))\n      : path.join(__dirname, 'node_modules/.prisma/client', `query-engine-${platform}`)\n\n  if (process.platform === 'win32') {\n    binaryPath += '.exe'\n  }\n\n  fs.unlinkSync(binaryPath)\n  const prisma = new PrismaClient({\n    log: [\n      {\n        emit: 'event',\n        level: 'query',\n      },\n    ],\n  })\n\n  await expect(async () => {\n    await prisma.user.findMany()\n  }).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n    Invalid \\`prisma.user.findMany()\\` invocation in\n    /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/binary.test.ts:0:0\n\n      36 })\n      37 \n      38 await expect(async () => {\n    → 39   await prisma.user.findMany(\n    Query engine binary for current platform \"TEST_PLATFORM\" could not be found.\n    This probably happens, because you built Prisma Client on a different platform.\n    (Prisma Client looked in \"/client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/@prisma/client/runtime/query-engine-TEST_PLATFORM\")\n\n    Searched Locations:\n\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/@prisma/client/runtime\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/@prisma/client\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget\n      /tmp/prisma-engines\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/.prisma/client\n\n    You already added the platform \"native\" to the \"generator\" block\n    in the \"schema.prisma\" file as described in https://pris.ly/d/client-generator,\n    but something went wrong. That's suboptimal.\n\n    Please create an issue at https://github.com/prisma/prisma/issues/new\n  `)\n})","file":"integration/errors/missing-engine-native-binaryTarget/binary.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing-engine-native-binaryTarget: library","suites":[],"updatePoint":{"line":8,"column":49},"line":8,"code":"test('missing-engine-native-binaryTarget: library', async () => {\n  if (getClientEngineType() !== ClientEngineType.Library) {\n    return\n  }\n\n  expect.assertions(1)\n  await generateTestClient()\n\n  const { PrismaClient } = require('./node_modules/@prisma/client')\n\n  const platform = await getPlatform()\n  const binaryPath =\n    getClientEngineType() === ClientEngineType.Library\n      ? path.join(__dirname, 'node_modules/.prisma/client', getNodeAPIName(platform, 'fs'))\n      : path.join(__dirname, 'node_modules/.prisma/client', `query-engine-${platform}`)\n  fs.unlinkSync(binaryPath)\n  const prisma = new PrismaClient({\n    log: [\n      {\n        emit: 'event',\n        level: 'query',\n      },\n    ],\n  })\n\n  await expect(async () => {\n    await prisma.user.findMany()\n  }).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n    Invalid \\`prisma.user.findMany()\\` invocation in\n    /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/library.test.ts:0:0\n\n      31 })\n      32 \n      33 await expect(async () => {\n    → 34   await prisma.user.findMany(\n    Query engine library for current platform \"TEST_PLATFORM\" could not be found.\n    You incorrectly pinned it to TEST_PLATFORM\n\n    This probably happens, because you built Prisma Client on a different platform.\n    (Prisma Client looked in \"/client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/@prisma/client/runtime/libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\")\n\n    Searched Locations:\n\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/@prisma/client/runtime\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/@prisma/client\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget\n      /tmp/prisma-engines\n      /client/src/__tests__/integration/errors/missing-engine-native-binaryTarget/node_modules/.prisma/client\n\n    You already added the platform \"native\" to the \"generator\" block\n    in the \"schema.prisma\" file as described in https://pris.ly/d/client-generator,\n    but something went wrong. That's suboptimal.\n\n    Please create an issue at https://github.com/prisma/prisma/issues/new\n  `)\n})","file":"integration/errors/missing-engine-native-binaryTarget/library.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing-engine: binary","suites":[],"updatePoint":{"line":8,"column":28},"line":8,"code":"test('missing-engine: binary', async () => {\n  if (getClientEngineType() !== ClientEngineType.Binary) {\n    return\n  }\n\n  expect.assertions(1)\n  await generateTestClient()\n\n  const { PrismaClient } = require('./node_modules/@prisma/client')\n\n  const platform = await getPlatform()\n  let binaryPath =\n    getClientEngineType() === ClientEngineType.Library\n      ? path.join(__dirname, 'node_modules/.prisma/client', getNodeAPIName(platform, 'fs'))\n      : path.join(__dirname, 'node_modules/.prisma/client', `query-engine-${platform}`)\n\n  if (process.platform === 'win32') {\n    binaryPath += '.exe'\n  }\n\n  fs.unlinkSync(binaryPath)\n  const prisma = new PrismaClient({\n    log: [\n      {\n        emit: 'event',\n        level: 'query',\n      },\n    ],\n  })\n\n  await expect(async () => {\n    await prisma.user.findMany()\n  }).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n    Invalid \\`prisma.user.findMany()\\` invocation in\n    /client/src/__tests__/integration/errors/missing-engine/binary.test.ts:0:0\n\n      36 })\n      37 \n      38 await expect(async () => {\n    → 39   await prisma.user.findMany(\n    Query engine binary for current platform \"TEST_PLATFORM\" could not be found.\n    This probably happens, because you built Prisma Client on a different platform.\n    (Prisma Client looked in \"/client/src/__tests__/integration/errors/missing-engine/node_modules/@prisma/client/runtime/query-engine-TEST_PLATFORM\")\n\n    Searched Locations:\n\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/@prisma/client/runtime\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/@prisma/client\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine\n      /tmp/prisma-engines\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/.prisma/client\n\n\n    To solve this problem, add the platform \"TEST_PLATFORM\" to the \"binaryTargets\" attribute in the \"generator\" block in the \"schema.prisma\" file:\n    generator client {\n      provider      = \"prisma-client-js\"\n      binaryTargets = [\"native\"]\n    }\n\n    Then run \"prisma generate\" for your changes to take effect.\n    Read more about deploying Prisma Client: https://pris.ly/d/client-generator\n  `)\n})","file":"integration/errors/missing-engine/binary.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing-engine: library","suites":[],"updatePoint":{"line":8,"column":29},"line":8,"code":"test('missing-engine: library', async () => {\n  if (getClientEngineType() !== ClientEngineType.Library) {\n    return\n  }\n\n  expect.assertions(1)\n  await generateTestClient()\n\n  const { PrismaClient } = require('./node_modules/@prisma/client')\n\n  const platform = await getPlatform()\n  const binaryPath =\n    getClientEngineType() === ClientEngineType.Library\n      ? path.join(__dirname, 'node_modules/.prisma/client', getNodeAPIName(platform, 'fs'))\n      : path.join(__dirname, 'node_modules/.prisma/client', `query-engine-${platform}`)\n  fs.unlinkSync(binaryPath)\n  const prisma = new PrismaClient({\n    log: [\n      {\n        emit: 'event',\n        level: 'query',\n      },\n    ],\n  })\n\n  await expect(async () => {\n    await prisma.user.findMany()\n  }).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n    Invalid \\`prisma.user.findMany()\\` invocation in\n    /client/src/__tests__/integration/errors/missing-engine/library.test.ts:0:0\n\n      31 })\n      32 \n      33 await expect(async () => {\n    → 34   await prisma.user.findMany(\n    Query engine library for current platform \"TEST_PLATFORM\" could not be found.\n    You incorrectly pinned it to TEST_PLATFORM\n\n    This probably happens, because you built Prisma Client on a different platform.\n    (Prisma Client looked in \"/client/src/__tests__/integration/errors/missing-engine/node_modules/@prisma/client/runtime/libquery_engine-TEST_PLATFORM.LIBRARY_TYPE.node\")\n\n    Searched Locations:\n\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/@prisma/client/runtime\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/@prisma/client\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/.prisma/client\n      /client/src/__tests__/integration/errors/missing-engine\n      /tmp/prisma-engines\n      /client/src/__tests__/integration/errors/missing-engine/node_modules/.prisma/client\n\n\n    To solve this problem, add the platform \"TEST_PLATFORM\" to the \"binaryTargets\" attribute in the \"generator\" block in the \"schema.prisma\" file:\n    generator client {\n      provider      = \"prisma-client-js\"\n      binaryTargets = [\"native\"]\n    }\n\n    Then run \"prisma generate\" for your changes to take effect.\n    Read more about deploying Prisma Client: https://pris.ly/d/client-generator\n  `)\n})","file":"integration/errors/missing-engine/library.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf-types","suites":[],"updatePoint":{"line":15,"column":16},"line":15,"code":"test('dmmf-types', async () => {\n  const datamodel = fs.readFileSync(path.join(__dirname, 'schema.prisma'), 'utf-8')\n  const dmmf = await getDMMF({\n    datamodel,\n  })\n  const dmmfFile = path.join(__dirname, 'generated-dmmf.ts')\n\n  fs.writeFileSync(\n    dmmfFile,\n    `import { DMMF } from '@prisma/generator-helper'\n\n  const dmmf: DMMF.Document = ${JSON.stringify(dmmf, null, 2)}`,\n  )\n\n  await expect(compileFile(dmmfFile)).resolves.not.toThrow()\n})","file":"integration/happy/exhaustive-schema-mongo/dmmf-types.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"dmmf-types","suites":[],"updatePoint":{"line":15,"column":16},"line":15,"code":"test('dmmf-types', async () => {\n  const datamodel = fs.readFileSync(path.join(__dirname, 'schema.prisma'), 'utf-8')\n  const dmmf = await getDMMF({\n    datamodel,\n  })\n  const dmmfFile = path.join(__dirname, 'generated-dmmf.ts')\n\n  fs.writeFileSync(\n    dmmfFile,\n    `import { DMMF } from '@prisma/generator-helper'\n\n  const dmmf: DMMF.Document = ${JSON.stringify(dmmf, null, 2)}`,\n  )\n\n  await expect(compileFile(dmmfFile)).resolves.not.toThrow()\n})","file":"integration/happy/exhaustive-schema/dmmf-types.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"is true for proper object","suites":[],"updatePoint":{"line":5,"column":31},"line":5,"code":"test('is true for proper object', () => {\n  expect(isObject({})).toBe(true)\n})","file":"isObject.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"is false for null","suites":[],"updatePoint":{"line":9,"column":23},"line":9,"code":"test('is false for null', () => {\n  expect(isObject(null)).toBe(false)\n})","file":"isObject.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"is false for primitive types","suites":[],"updatePoint":{"line":13,"column":34},"line":13,"code":"test('is false for primitive types', () => {\n  expect(isObject(1)).toBe(false)\n  expect(isObject(undefined)).toBe(false)\n  expect(isObject('hello')).toBe(false)\n  expect(isObject(true)).toBe(false)\n  expect(isObject(BigInt('10'))).toBe(false)\n  expect(isObject(Symbol())).toBe(false)\n})","file":"isObject.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"is false for Dates","suites":[],"updatePoint":{"line":22,"column":24},"line":22,"code":"test('is false for Dates', () => {\n  expect(isObject(new Date('2022-05-06T00:00:00Z'))).toBe(false)\n})","file":"isObject.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"is false for Decimal.js instance","suites":[],"updatePoint":{"line":26,"column":38},"line":26,"code":"test('is false for Decimal.js instance', () => {\n  expect(isObject(new Decimal('12.34'))).toBe(false)\n})","file":"isObject.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"is false for Buffer","suites":[],"updatePoint":{"line":30,"column":25},"line":30,"code":"test('is false for Buffer', () => {\n  expect(isObject(Buffer.from('hello', 'utf8'))).toBe(false)\n})","file":"isObject.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"should be able to create json","suites":[],"updatePoint":{"line":52,"column":37},"line":52,"code":"  test('should be able to create json', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {\n        data: {\n          email: 'a@a.de',\n          json: {\n            hello: 'world',\n          },\n          jsonList: [{ hello: 'world' }],\n          name: 'Bob',\n        },\n      },\n      rootTypeName: 'mutation',\n      rootField: 'createOneUser',\n    })\n    document.validate(undefined, false, 'user', 'colorless')\n    expect(String(document)).toMatchSnapshot()\n  })","file":"json.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"should be able filter json","suites":[],"updatePoint":{"line":72,"column":34},"line":72,"code":"  test('should be able filter json', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {\n        where: {\n          json: {\n            equals: {\n              hello: 'world',\n            },\n          },\n        },\n      },\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    document.validate(undefined, false, 'user', 'colorless')\n    expect(String(document)).toMatchSnapshot()\n  })","file":"json.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"should be able filter json null","suites":[],"updatePoint":{"line":91,"column":39},"line":91,"code":"  test('should be able filter json null', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {\n        where: {\n          json: {\n            equals: objectEnumValues.instances.JsonNull,\n          },\n        },\n      },\n      rootTypeName: 'query',\n      rootField: 'findManyOptionalUser',\n    })\n    document.validate(undefined, false, 'user', 'colorless')\n    expect(String(document)).toMatchSnapshot()\n  })","file":"json.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"should not consider \"JsonNull\" string an enum value","suites":[],"updatePoint":{"line":108,"column":59},"line":108,"code":"  test('should not consider \"JsonNull\" string an enum value', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {\n        where: {\n          json: {\n            equals: 'JsonNull',\n          },\n        },\n      },\n      rootTypeName: 'query',\n      rootField: 'findManyOptionalUser',\n    })\n    document.validate(undefined, false, 'user', 'colorless')\n    expect(String(document)).toMatchSnapshot()\n  })","file":"json.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"should be able filter json \"null\"","suites":[],"updatePoint":{"line":125,"column":41},"line":125,"code":"  test('should be able filter json \"null\"', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {\n        where: {\n          json: {\n            equals: 'null',\n          },\n        },\n      },\n      rootTypeName: 'query',\n      rootField: 'findManyOptionalUser',\n    })\n    document.validate(undefined, false, 'user', 'colorless')\n    expect(String(document)).toMatchSnapshot()\n  })","file":"json.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"should error if equals is missing","suites":[],"updatePoint":{"line":142,"column":41},"line":142,"code":"  test('should error if equals is missing', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {\n        where: {\n          json: {\n            hello: 'world',\n          },\n        },\n      },\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    expect(() => document.validate(undefined, false, 'user', 'colorless')).toThrowErrorMatchingSnapshot()\n  })","file":"json.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"should be able to update json","suites":[],"updatePoint":{"line":158,"column":37},"line":158,"code":"  test('should be able to update json', () => {\n    function getTransformedDocument(select) {\n      const document = makeDocument({\n        dmmf,\n        select,\n        rootTypeName: 'mutation',\n        rootField: 'updateOneUser',\n      })\n      return String(transformDocument(document))\n    }\n\n    const transformedDocument = getTransformedDocument({\n      data: {\n        json: ['value1', 'value2'],\n        jsonList: ['value1', 'value2'],\n      },\n      where: {\n        id: 5,\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      mutation {\n        updateOneUser(\n          data: {\n            json: \"[\\\\\"value1\\\\\",\\\\\"value2\\\\\"]\"\n            jsonList: [\"\\\\\"value1\\\\\"\",\"\\\\\"value2\\\\\"\"]\n          }\n          where: {\n            id: 5\n          }\n        ) {\n          id\n          name\n          email\n          json\n          jsonList\n        }\n      }\n    `)\n  })","file":"json.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"basic mergeBy","suites":[],"updatePoint":{"line":3,"column":19},"line":3,"code":"test('basic mergeBy', () => {\n  const arr1 = [\n    {\n      name: 'db',\n      url: 'file:old-url.db',\n    },\n  ]\n  const arr2 = [\n    {\n      name: 'db',\n      url: 'file:new-url.db',\n    },\n  ]\n  expect(mergeBy(arr1, arr2, (a) => a.name)).toMatchInlineSnapshot(`\n    Array [\n      Object {\n        name: db,\n        url: file:new-url.db,\n      },\n    ]\n  `)\n})","file":"mergeBy.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"mergeBy should merge last item","suites":[],"updatePoint":{"line":26,"column":36},"line":26,"code":"test('mergeBy should merge last item', () => {\n  const arr1 = [\n    {\n      name: 'db',\n      url: 'file:old-url.db',\n    },\n  ]\n  const arr2 = [\n    {\n      name: 'db',\n      url: 'file:new-url.db',\n    },\n    {\n      name: 'db',\n      url: 'file:new-url2.db',\n    },\n  ]\n  expect(mergeBy(arr1, arr2, (a) => a.name)).toMatchInlineSnapshot(`\n    Array [\n      Object {\n        name: db,\n        url: file:new-url2.db,\n      },\n    ]\n  `)\n})","file":"mergeBy.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"OR posts some id in","suites":["minimal where transformation"],"updatePoint":{"line":15,"column":27},"line":15,"code":"  test('OR posts some id in', () => {\n    const transformedDocument = getTransformedDocument({\n      where: {\n        OR: [\n          {\n            posts: {\n              some: {\n                id: {\n                  in: ['test'],\n                },\n              },\n            },\n          },\n        ],\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          OR: [\n            {\n              posts: {\n                some: {\n                  id: {\n                    in: [\"test\"]\n                  }\n                }\n              }\n            }\n          ]\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"minimalWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"OR name startsWith","suites":["minimal where transformation"],"updatePoint":{"line":65,"column":26},"line":65,"code":"  test('OR name startsWith', () => {\n    const transformedDocument = getTransformedDocument({\n      where: {\n        OR: [\n          {\n            name: {\n              startsWith: 'x',\n            },\n          },\n        ],\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          OR: [\n            {\n              name: {\n                startsWith: \"x\"\n              }\n            }\n          ]\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"minimalWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"OR name endsWith","suites":["minimal where transformation"],"updatePoint":{"line":107,"column":24},"line":107,"code":"  test('OR name endsWith', () => {\n    const transformedDocument = getTransformedDocument({\n      where: {\n        OR: [\n          {\n            name: {\n              endsWith: 'x',\n            },\n          },\n        ],\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          OR: [\n            {\n              name: {\n                endsWith: \"x\"\n              }\n            }\n          ]\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"minimalWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"implicit many-to-many relation: contains","suites":["minimal where transformation"],"updatePoint":{"line":149,"column":48},"line":149,"code":"  test('implicit many-to-many relation: contains', () => {\n    const transformedDocument = getTransformedDocument({\n      where: {\n        posts: {\n          some: {\n            title: {\n              contains: 'mytitle',\n            },\n          },\n        },\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          posts: {\n            some: {\n              title: {\n                contains: \"mytitle\"\n              }\n            }\n          }\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"minimalWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"implicit many-to-many relation: select date equals (implicit)","suites":["minimal where transformation"],"updatePoint":{"line":191,"column":69},"line":191,"code":"  test('implicit many-to-many relation: select date equals (implicit)', () => {\n    const transformedDocument = getTransformedDocument({\n      select: {\n        posts: {\n          where: {\n            OR: [\n              {\n                createdAt: '2020-08-19T10:02:43.353Z',\n              },\n            ],\n          },\n        },\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser {\n          posts(where: {\n            OR: [\n              {\n                createdAt: \"2020-08-19T10:02:43.353Z\"\n              }\n            ]\n          }) {\n            id\n            createdAt\n            updatedAt\n            published\n            title\n            content\n            authorId\n            optional\n          }\n        }\n      }\n    `)\n  })","file":"minimalWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"implicit many-to-many relation: select date equals (explicit)","suites":["minimal where transformation"],"updatePoint":{"line":230,"column":69},"line":230,"code":"  test('implicit many-to-many relation: select date equals (explicit)', () => {\n    const transformedDocument = getTransformedDocument({\n      select: {\n        posts: {\n          where: {\n            OR: [\n              {\n                createdAt: { equals: '2020-08-19T10:02:43.353Z' },\n              },\n            ],\n          },\n        },\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser {\n          posts(where: {\n            OR: [\n              {\n                createdAt: {\n                  equals: \"2020-08-19T10:02:43.353Z\"\n                }\n              }\n            ]\n          }) {\n            id\n            createdAt\n            updatedAt\n            published\n            title\n            content\n            authorId\n            optional\n          }\n        }\n      }\n    `)\n  })","file":"minimalWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"implicit many-to-many relation: where null","suites":["minimal where transformation"],"updatePoint":{"line":271,"column":50},"line":271,"code":"  test('implicit many-to-many relation: where null', () => {\n    const transformedDocument = getTransformedDocument({\n      select: {\n        posts: {\n          where: {\n            content: null,\n          },\n        },\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser {\n          posts(where: {\n            content: null\n          }) {\n            id\n            createdAt\n            updatedAt\n            published\n            title\n            content\n            authorId\n            optional\n          }\n        }\n      }\n    `)\n  })","file":"minimalWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"where null","suites":["minimal where transformation"],"updatePoint":{"line":302,"column":18},"line":302,"code":"  test('where null', () => {\n    const transformedDocument = getTransformedDocument({\n      where: {\n        name: null,\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          name: null\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"minimalWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"one-to-one relation where null","suites":["minimal where transformation"],"updatePoint":{"line":332,"column":38},"line":332,"code":"  test('one-to-one relation where null', () => {\n    const transformedDocument = getTransformedDocument({\n      where: {\n        profile: {\n          bio: { not: null },\n        },\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          profile: {\n            bio: {\n              not: null\n            }\n          }\n        }) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"minimalWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"findUnique","suites":["no args"],"updatePoint":{"line":11,"column":18},"line":11,"code":"  test('findUnique', () => {\n    const document = makeDocument({\n      dmmf,\n      select: undefined,\n      rootTypeName: 'query',\n      rootField: 'findUniqueUser',\n    })\n    expect(() => document.validate(undefined, false, 'user', 'colorless')).toThrowErrorMatchingSnapshot()\n  })","file":"noArgs.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"findMany","suites":["no args"],"updatePoint":{"line":21,"column":16},"line":21,"code":"  test('findMany', () => {\n    const document = makeDocument({\n      dmmf,\n      select: undefined,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    document.validate(undefined, false, 'user', 'colorless')\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyUser {\n          id\n          name\n          email\n          personaId\n        }\n      }\n    `)\n  })","file":"noArgs.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"findMany with filter","suites":["no args"],"updatePoint":{"line":40,"column":28},"line":40,"code":"  test('findMany with filter', () => {\n    const select = {\n      where: {\n        likedArticles: null,\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    expect(() => document.validate(select, false, 'user', 'colorless')).toThrowErrorMatchingSnapshot()\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          likedArticles: null\n        }) {\n          id\n          name\n          email\n          personaId\n        }\n      }\n    `)\n  })","file":"noArgs.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"createOne","suites":["no args"],"updatePoint":{"line":66,"column":17},"line":66,"code":"  test('createOne', () => {\n    const document = makeDocument({\n      dmmf,\n      select: undefined,\n      rootTypeName: 'mutation',\n      rootField: 'createOneUser',\n    })\n    expect(() => document.validate(undefined, false, 'user', 'colorless')).toThrowErrorMatchingSnapshot()\n  })","file":"noArgs.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"deleteMany","suites":["no args"],"updatePoint":{"line":75,"column":18},"line":75,"code":"  test('deleteMany', () => {\n    const document = makeDocument({\n      dmmf,\n      select: undefined,\n      rootTypeName: 'mutation',\n      rootField: 'deleteManyUser',\n    })\n    document.validate(undefined, false, 'user', 'colorless')\n    expect(String(document)).toMatchInlineSnapshot(`\n      mutation {\n        deleteManyUser {\n          count\n        }\n      }\n    `)\n  })","file":"noArgs.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"deleteOne","suites":["no args"],"updatePoint":{"line":91,"column":17},"line":91,"code":"  test('deleteOne', () => {\n    const document = makeDocument({\n      dmmf,\n      select: undefined,\n      rootTypeName: 'mutation',\n      rootField: 'deleteOneUser',\n    })\n    expect(() => document.validate(undefined, false, 'user', 'colorless')).toThrowErrorMatchingSnapshot()\n  })","file":"noArgs.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"updateMany","suites":["no args"],"updatePoint":{"line":100,"column":18},"line":100,"code":"  test('updateMany', () => {\n    const document = makeDocument({\n      dmmf,\n      select: undefined,\n      rootTypeName: 'mutation',\n      rootField: 'updateManyUser',\n    })\n    expect(() => document.validate(undefined, false, 'user', 'colorless')).toThrowErrorMatchingSnapshot()\n  })","file":"noArgs.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"upsertOne","suites":["no args"],"updatePoint":{"line":109,"column":17},"line":109,"code":"  test('upsertOne', () => {\n    const document = makeDocument({\n      dmmf,\n      select: undefined,\n      rootTypeName: 'mutation',\n      rootField: 'upsertOneUser',\n    })\n    expect(() => document.validate(undefined, false, 'user', 'colorless')).toThrowErrorMatchingSnapshot()\n  })","file":"noArgs.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"nested create","suites":["no args"],"updatePoint":{"line":118,"column":21},"line":118,"code":"  test('nested create', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {\n        data: {\n          id: 5,\n          name: 'Harshit',\n          email: 'a@a.de',\n          likedArticles: {\n            connect: null,\n          },\n          persona: {\n            create: {\n              id: 123,\n              isDeveloper: true,\n            },\n          },\n        },\n      },\n      rootTypeName: 'mutation',\n      rootField: 'createOneUser',\n    })\n    expect(() => document.validate(undefined, false, 'user', 'colorless')).toThrowErrorMatchingSnapshot()\n  })","file":"noArgs.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"null query","suites":["optional to one relation"],"updatePoint":{"line":15,"column":18},"line":15,"code":"  test('null query', () => {\n    const select = {\n      where: {\n        author: null,\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(transformDocument(document))).toMatchInlineSnapshot(`\n      query {\n        findManyPost(where: {\n          author: null\n        }) {\n          id\n          createdAt\n          updatedAt\n          published\n          title\n          content\n          authorId\n          optional\n        }\n      }\n    `)\n  })","file":"optionalRelation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"invalid or query","suites":["at least one validation"],"updatePoint":{"line":13,"column":24},"line":13,"code":"  test('invalid or query', () => {\n    const select = {\n      where: {\n        OR: {\n          email: {},\n        },\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          OR: [\n            {\n              email: {\n\n              }\n            }\n          ]\n        }) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n    try {\n      document.validate(select, false, 'users')\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n\n                                        Invalid \\`prisma.users()\\` invocation:\n\n                                        {\n                                          where: {\n                                            OR: {\n                                              email: {}\n                                            }\n                                            ~~~~~~~~~~~\n                                          }\n                                        }\n\n                                        Argument OR: Got invalid value \n                                        {\n                                          email: {}\n                                        }\n                                        on prisma.findManyUser. Provided Json, expected List<UserWhereInput>:\n                                        type UserWhereInput {\n                                          AND?: UserWhereInput\n                                          OR?: UserWhereInput\n                                          NOT?: UserWhereInput\n                                          id?: StringFilter | String\n                                          name?: StringFilter | String\n                                          email?: StringFilter | String\n                                          status?: StringFilter | String\n                                          nicknames?: StringNullableListFilter\n                                          permissions?: EnumPermissionNullableListFilter\n                                          favoriteTree?: EnumTreeFilter | Tree\n                                          locationId?: IntFilter | Int\n                                          location?: LocationRelationFilter | LocationWhereInput\n                                          posts?: PostListRelationFilter\n                                          someFloats?: FloatNullableListFilter\n                                        }\n\n\n                              `)\n    }\n  })","file":"or.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"valid or query","suites":["at least one validation"],"updatePoint":{"line":92,"column":22},"line":92,"code":"  test('valid or query', () => {\n    const select = {\n      where: {\n        OR: [\n          {\n            email: '',\n          },\n        ],\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(select, false, 'users')).not.toThrow()\n  })","file":"or.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"transform correctly","suites":["where transformation"],"updatePoint":{"line":13,"column":27},"line":13,"code":"  test('transform correctly', () => {\n    const select = {\n      orderBy: {\n        email: 'asc',\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    document.validate(select, false)\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyUser(orderBy: [\n          {\n            email: asc\n          }\n        ]) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n    expect(String(transformDocument(document))).toMatchInlineSnapshot(`\n      query {\n        findManyUser(orderBy: [\n          {\n            email: asc\n          }\n        ]) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n  })","file":"orderTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"throw when 2 order by args provided","suites":["where transformation"],"updatePoint":{"line":66,"column":43},"line":66,"code":"  test('throw when 2 order by args provided', () => {\n    const select = {\n      orderBy: {\n        email: 'asc',\n        id: 'asc',\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyUser(orderBy: [\n          {\n            email: asc\n            id: asc\n          }\n        ]) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n    expect(String(transformDocument(document))).toMatchInlineSnapshot(`\n      query {\n        findManyUser(orderBy: [\n          {\n            email: asc\n            id: asc\n          }\n        ]) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n    try {\n      document.validate(select, false, 'users')\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n\nInvalid \\`prisma.users()\\` invocation:\n\n{\n  orderBy: {\n    email: 'asc',\n    id: 'asc'\n  }\n  ~~~~~~~~~~~~~~~\n}\n\nArgument orderBy of type UserOrderByWithRelationInput needs exactly one argument, but you provided email and id. Please choose one. Available args: \ntype UserOrderByWithRelationInput {\n  id?: SortOrder\n  name?: SortOrder\n  email?: SortOrder\n  status?: SortOrder\n  nicknames?: SortOrder\n  permissions?: SortOrder\n  favoriteTree?: SortOrder\n  locationId?: SortOrder\n  location?: LocationOrderByWithRelationInput\n  posts?: PostOrderByRelationAggregateInput\n  someFloats?: SortOrder\n}\n\n\n`)\n    }\n  })","file":"orderTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"DO NOT ignore order null","suites":["where transformation"],"updatePoint":{"line":165,"column":32},"line":165,"code":"  test('DO NOT ignore order null', () => {\n    const select = {\n      orderBy: null,\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    expect(String(transformDocument(document))).toMatchInlineSnapshot(`\n      query {\n        findManyUser(orderBy: null) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n  })","file":"orderTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"ignore order by id null","suites":["where transformation"],"updatePoint":{"line":192,"column":31},"line":192,"code":"  test('ignore order by id null', () => {\n    const select = {\n      orderBy: { id: null },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    expect(String(transformDocument(document))).toMatchInlineSnapshot(`\n      query {\n        findManyUser(orderBy: {\n          id: null\n        }) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n  })","file":"orderTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allows to pass it decimal instance","suites":[],"updatePoint":{"line":23,"column":40},"line":23,"code":"test('allows to pass it decimal instance', () => {\n  const document = makeDocument({\n    dmmf,\n    rootTypeName: 'query',\n    rootField: 'findManyUser',\n    select: { where: { money: new Decimal('123456789.12334') } },\n  })\n\n  expect(document.toString()).toMatchInlineSnapshot(`\n    query {\n      findManyUser(where: {\n        money: \"123456789.12334\"\n      }) {\n        id\n        money\n      }\n    }\n  `)\n  expect(() => document.validate()).not.toThrow()\n})","file":"query/decimal.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allows to pass it a string","suites":[],"updatePoint":{"line":44,"column":32},"line":44,"code":"test('allows to pass it a string', () => {\n  const document = makeDocument({\n    dmmf,\n    rootTypeName: 'query',\n    rootField: 'findManyUser',\n    select: { where: { money: '123456789.12334' } },\n  })\n\n  expect(document.toString()).toMatchInlineSnapshot(`\n    query {\n      findManyUser(where: {\n        money: \"123456789.12334\"\n      }) {\n        id\n        money\n      }\n    }\n  `)\n  expect(() => document.validate()).not.toThrow()\n})","file":"query/decimal.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allows to pass it a number","suites":[],"updatePoint":{"line":65,"column":32},"line":65,"code":"test('allows to pass it a number', () => {\n  const document = makeDocument({\n    dmmf,\n    rootTypeName: 'query',\n    rootField: 'findManyUser',\n    select: { where: { money: 12.3456 } },\n  })\n\n  expect(document.toString()).toMatchInlineSnapshot(`\n    query {\n      findManyUser(where: {\n        money: 12.3456\n      }) {\n        id\n        money\n      }\n    }\n  `)\n  expect(() => document.validate()).not.toThrow()\n})","file":"query/decimal.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allows to pass it decimal-like object","suites":[],"updatePoint":{"line":86,"column":43},"line":86,"code":"test('allows to pass it decimal-like object', () => {\n  const document = makeDocument({\n    dmmf,\n    rootTypeName: 'query',\n    rootField: 'findManyUser',\n    select: {\n      where: {\n        money: {\n          d: [12, 5000000],\n          e: 1,\n          s: 1,\n        },\n      },\n    },\n  })\n\n  expect(document.toString()).toMatchInlineSnapshot(`\n    query {\n      findManyUser(where: {\n        money: \"12.5\"\n      }) {\n        id\n        money\n      }\n    }\n  `)\n  expect(() => document.validate()).not.toThrow()\n})","file":"query/decimal.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allows to pass it decimal array","suites":[],"updatePoint":{"line":115,"column":37},"line":115,"code":"test('allows to pass it decimal array', () => {\n  const document = makeDocument({\n    dmmf,\n    rootTypeName: 'query',\n    rootField: 'findManyUser',\n    select: { where: { money: { in: [new Decimal('12.34'), new Decimal('56.78')] } } },\n  })\n\n  expect(document.toString()).toMatchInlineSnapshot(`\n    query {\n      findManyUser(where: {\n        money: {\n          in: [\n            \"12.34\",\n            \"56.78\"\n          ]\n        }\n      }) {\n        id\n        money\n      }\n    }\n  `)\n\n  expect(() => document.validate()).not.toThrow()\n})","file":"query/decimal.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allows to pass it decimal-like objects array","suites":[],"updatePoint":{"line":142,"column":50},"line":142,"code":"test('allows to pass it decimal-like objects array', () => {\n  const document = makeDocument({\n    dmmf,\n    rootTypeName: 'query',\n    rootField: 'findManyUser',\n    select: {\n      where: {\n        money: {\n          in: [\n            {\n              d: [12, 3400000],\n              e: 1,\n              s: 1,\n            },\n\n            {\n              d: [56, 7800000],\n              e: 1,\n              s: 1,\n            },\n          ],\n        },\n      },\n    },\n  })\n\n  expect(document.toString()).toMatchInlineSnapshot(`\n    query {\n      findManyUser(where: {\n        money: {\n          in: [\n            \"12.34\",\n            \"56.78\"\n          ]\n        }\n      }) {\n        id\n        money\n      }\n    }\n  `)\n\n  expect(() => document.validate()).not.toThrow()\n})","file":"query/decimal.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allows to pass it string array","suites":[],"updatePoint":{"line":187,"column":36},"line":187,"code":"test('allows to pass it string array', () => {\n  const document = makeDocument({\n    dmmf,\n    rootTypeName: 'query',\n    rootField: 'findManyUser',\n    select: { where: { money: { in: ['12.34', '56.78'] } } },\n  })\n\n  expect(document.toString()).toMatchInlineSnapshot(`\n    query {\n      findManyUser(where: {\n        money: {\n          in: [\"12.34\", \"56.78\"]\n        }\n      }) {\n        id\n        money\n      }\n    }\n  `)\n\n  expect(() => document.validate()).not.toThrow()\n})","file":"query/decimal.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allows to pass it number array","suites":[],"updatePoint":{"line":211,"column":36},"line":211,"code":"test('allows to pass it number array', () => {\n  const document = makeDocument({\n    dmmf,\n    rootTypeName: 'query',\n    rootField: 'findManyUser',\n    select: { where: { money: { in: [12.34, 56.78] } } },\n  })\n\n  expect(document.toString()).toMatchInlineSnapshot(`\n    query {\n      findManyUser(where: {\n        money: {\n          in: [12.34, 56.78]\n        }\n      }) {\n        id\n        money\n      }\n    }\n  `)\n\n  expect(() => document.validate()).not.toThrow()\n})","file":"query/decimal.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"serializes floats in exponential notation","suites":[],"updatePoint":{"line":32,"column":47},"line":32,"code":"test('serializes floats in exponential notation', () => {\n  const largeInt = getTransformedDocument({\n    data: {\n      value: 100_000_000_000_000_000_000,\n    },\n  })\n\n  expect(largeInt).toMatchInlineSnapshot(`\n    mutation {\n      createOneFloats(data: {\n        value: 1e+20\n      }) {\n        id\n        value\n      }\n    }\n  `)\n\n  const negativeInt = getTransformedDocument({\n    data: {\n      value: Number.MIN_SAFE_INTEGER,\n    },\n  })\n\n  expect(negativeInt).toMatchInlineSnapshot(`\n    mutation {\n      createOneFloats(data: {\n        value: -9.007199254740991e+15\n      }) {\n        id\n        value\n      }\n    }\n  `)\n\n  const otherFloat = getTransformedDocument({\n    data: {\n      value: 13.37,\n    },\n  })\n  expect(otherFloat).toMatchInlineSnapshot(`\n    mutation {\n      createOneFloats(data: {\n        value: 1.337e+1\n      }) {\n        id\n        value\n      }\n    }\n  `)\n})","file":"query/floats.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"where OR not null","suites":["minimal where transformation"],"updatePoint":{"line":15,"column":25},"line":15,"code":"  test('where OR not null', () => {\n    const transformedDocument = getDocument({\n      where: {\n        OR: [\n          {\n            date: { not: null },\n          },\n        ],\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManySale(where: {\n          OR: [\n            {\n              date: {\n                not: null\n              }\n            }\n          ]\n        }) {\n          id\n          date\n        }\n      }\n    `)\n  })","file":"relationWhereORNotNullTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"transform correctly","suites":["relation where transformation"],"updatePoint":{"line":15,"column":27},"line":15,"code":"  test('transform correctly', () => {\n    const select = {\n      where: {\n        Albums: {\n          some: {\n            Tracks: {\n              some: {\n                AND: {\n                  UnitPrice: 5,\n                  Playlists: {\n                    some: {\n                      Tracks: {\n                        some: {\n                          Name: '',\n                          Genre: {\n                            id: 5,\n                          },\n                        },\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyArtist',\n    })\n\n    expect(() => document.validate(select, false, 'users')).toThrowErrorMatchingSnapshot()\n  })","file":"relationWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"throw correctly for incorrect deep scalar","suites":["relation where transformation"],"updatePoint":{"line":53,"column":49},"line":53,"code":"  test('throw correctly for incorrect deep scalar', () => {\n    const select = {\n      where: {\n        Albums: {\n          some: {\n            Tracks: {\n              some: {\n                AND: {\n                  UnitPrice: 5,\n                  Playlists: {\n                    some: {\n                      Tracks: {\n                        some: {\n                          Name: '',\n                          Genre: {\n                            id: '5',\n                          },\n                        },\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyArtist',\n    })\n    expect(() => document.validate(select, false, 'users')).toThrowErrorMatchingSnapshot()\n  })","file":"relationWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"throw correctly for deep at least one error","suites":["relation where transformation"],"updatePoint":{"line":89,"column":51},"line":89,"code":"  test('throw correctly for deep at least one error', () => {\n    const select = {\n      where: {\n        Albums: {\n          some: {\n            Tracks: {\n              some: {\n                AND: {\n                  UnitPrice: 5,\n                  Playlists: {\n                    some: {\n                      Tracks: {\n                        some: {\n                          Name: '',\n                          Genre: {},\n                        },\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyArtist',\n    })\n    expect(() => document.validate(select, false, 'artists')).toThrowErrorMatchingSnapshot()\n  })","file":"relationWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"absolutizeRelativePath","suites":[],"updatePoint":{"line":9,"column":28},"line":9,"code":"test('absolutizeRelativePath', () => {\n  expect(absolutizeRelativePath('file:db.db', cwd, outputDir)).toMatchInlineSnapshot(`../../../../prisma/db.db`)\n  expect(absolutizeRelativePath('file:/db.db', cwd, outputDir)).toMatchInlineSnapshot(`../../../../../../../db.db`)\n  expect(absolutizeRelativePath('file:../db.db', cwd, outputDir)).toMatchInlineSnapshot(`../../../../db.db`)\n  expect(absolutizeRelativePath('file:./db.db', cwd, outputDir)).toMatchInlineSnapshot(`../../../../prisma/db.db`)\n\n  expect(absolutizeRelativePath('file:asd/another/dir/db.db', cwd, outputDir)).toMatchInlineSnapshot(\n    `../../../../prisma/asd/another/dir/db.db`,\n  )\n  expect(absolutizeRelativePath('file:/some/random/dir/db.db', cwd, outputDir)).toMatchInlineSnapshot(\n    `../../../../../../../some/random/dir/db.db`,\n  )\n  expect(\n    absolutizeRelativePath('file:/Users/tim/project/node_modules/@prisma/client/runtime', cwd, outputDir),\n  ).toMatchInlineSnapshot(``)\n  expect(absolutizeRelativePath('file:../another-dir/db.db', cwd, outputDir)).toMatchInlineSnapshot(\n    `../../../../another-dir/db.db`,\n  )\n  expect(absolutizeRelativePath('file:./some/dir/db.db', cwd, outputDir)).toMatchInlineSnapshot(\n    `../../../../prisma/some/dir/db.db`,\n  )\n})","file":"resolveDatasources.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"serializeDatasources","suites":[],"updatePoint":{"line":75,"column":26},"line":75,"code":"test('serializeDatasources', () => {\n  expect(serializeDatasources(datasources.map(datasourceToDatasourceOverwrite))).toMatchInlineSnapshot(`\n    [\n      {\n        \"name\": \"db\",\n        \"url\": \"file:db.db\"\n      },\n      {\n        \"name\": \"db2\",\n        \"url\": \"file:./some-dir/db.db\"\n      },\n      {\n        \"name\": \"db3\",\n        \"url\": \"mysql:localhost\"\n      },\n      {\n        \"name\": \"db4\",\n        \"url\": \"postgresql://\"\n      }\n    ]\n  `)\n})","file":"resolveDatasources.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allow providing Int and Float scalar list in set","suites":["scalar where transformation"],"updatePoint":{"line":15,"column":56},"line":15,"code":"  test('allow providing Int and Float scalar list in set', () => {\n    const select = {\n      data: {\n        name: 'Name',\n        email: 'hans@hans.de',\n        status: '',\n        favoriteTree: 'OAK',\n        location: {\n          create: {\n            city: 'Berlin',\n            id: 5,\n          },\n        },\n        someFloats: {\n          set: [1, 1.2],\n        },\n      },\n    }\n\n    const document = transformDocument(\n      makeDocument({\n        dmmf,\n        select,\n        rootTypeName: 'mutation',\n        rootField: 'createOneUser',\n      }),\n    )\n\n    expect(String(document)).toMatchInlineSnapshot(`\n      mutation {\n        createOneUser(data: {\n          name: \"Name\"\n          email: \"hans@hans.de\"\n          status: \"\"\n          favoriteTree: OAK\n          location: {\n            create: {\n              city: \"Berlin\"\n              id: 5\n            }\n          }\n          someFloats: {\n            set: [1e+0, 1.2e+0]\n          }\n        }) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n\n    expect(() => document.validate(select, false, 'tests')).not.toThrow()\n  })","file":"scalarListCreate.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allow providing Int and Float scalar list without set","suites":["scalar where transformation"],"updatePoint":{"line":76,"column":61},"line":76,"code":"  test('allow providing Int and Float scalar list without set', () => {\n    const select = {\n      data: {\n        name: 'Name',\n        email: 'hans@hans.de',\n        status: '',\n        favoriteTree: 'OAK',\n        location: {\n          create: {\n            city: 'Berlin',\n            id: 5,\n          },\n        },\n        someFloats: [1, 1.2],\n      },\n    }\n\n    const document = transformDocument(\n      makeDocument({\n        dmmf,\n        select,\n        rootTypeName: 'mutation',\n        rootField: 'createOneUser',\n      }),\n    )\n\n    expect(String(document)).toMatchInlineSnapshot(`\n      mutation {\n        createOneUser(data: {\n          name: \"Name\"\n          email: \"hans@hans.de\"\n          status: \"\"\n          favoriteTree: OAK\n          location: {\n            create: {\n              city: \"Berlin\"\n              id: 5\n            }\n          }\n          someFloats: [1e+0, 1.2e+0]\n        }) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n\n    expect(() => document.validate(select, false, 'tests')).not.toThrow()\n  })","file":"scalarListCreate.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"transform correctly","suites":["scalar where transformation"],"updatePoint":{"line":16,"column":27},"line":16,"code":"  test('transform correctly', () => {\n    const select = {\n      where: {\n        AND: [\n          {\n            email: {\n              equals: 'a@a.de',\n              gt: '0',\n            },\n            AND: [\n              {\n                name: {\n                  equals: '5',\n                  not: '7',\n                },\n                OR: [\n                  {\n                    id: {\n                      not: '8',\n                      notIn: ['7'],\n                    },\n                  },\n                  {\n                    id: {\n                      not: '9',\n                    },\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            id: {\n              equals: '1',\n              gt: '0',\n            },\n          },\n        ],\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          AND: [\n            {\n              email: {\n                equals: \"a@a.de\"\n                gt: \"0\"\n              }\n              AND: [\n                {\n                  name: {\n                    equals: \"5\"\n                    not: \"7\"\n                  }\n                  OR: [\n                    {\n                      id: {\n                        not: \"8\"\n                        notIn: [\"7\"]\n                      }\n                    },\n                    {\n                      id: {\n                        not: \"9\"\n                      }\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              id: {\n                equals: \"1\"\n                gt: \"0\"\n              }\n            }\n          ]\n        }) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n    expect(String(transformDocument(document))).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          AND: [\n            {\n              email: {\n                equals: \"a@a.de\"\n                gt: \"0\"\n              }\n              AND: [\n                {\n                  name: {\n                    equals: \"5\"\n                    not: \"7\"\n                  }\n                  OR: [\n                    {\n                      id: {\n                        not: \"8\"\n                        notIn: [\"7\"]\n                      }\n                    },\n                    {\n                      id: {\n                        not: \"9\"\n                      }\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              id: {\n                equals: \"1\"\n                gt: \"0\"\n              }\n            }\n          ]\n        }) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n  })","file":"scalarWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"MODELScalarWhereInput","suites":["scalar where transformation"],"updatePoint":{"line":166,"column":29},"line":166,"code":"  test('MODELScalarWhereInput', () => {\n    const select = {\n      where: {\n        AND: [\n          {\n            title: {\n              equals: 'a@a.de',\n              gt: '0',\n            },\n            AND: [\n              {\n                title: {\n                  equals: '5',\n                  not: '7',\n                },\n                OR: [\n                  {\n                    id: {\n                      not: '8',\n                    },\n                  },\n                  {\n                    id: {\n                      not: '9',\n                    },\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            id: {\n              equals: '1',\n              gt: '0',\n            },\n          },\n        ],\n      },\n      data: {},\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'mutation',\n      rootField: 'updateManyPost',\n    })\n\n    expect(() => document.validate(select)).toThrowErrorMatchingInlineSnapshot(`\n\n      Invalid \\`prisma.updateManyPost()\\` invocation:\n\n      {\n        where: {\n          AND: [\n            {\n              title: {\n              ~~~~~\n                equals: 'a@a.de',\n                gt: '0'\n              },\n              AND: [\n                {\n                  title: {\n                  ~~~~~\n                    equals: '5',\n                    not: '7'\n                  },\n                  OR: [\n                    {\n                      id: {\n                        not: '8'\n                      }\n                    },\n                    {\n                      id: {\n                        not: '9'\n                      }\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              id: {\n                equals: '1',\n                gt: '0'\n              }\n            }\n          ]\n        },\n        data: {}\n      }\n\n      Unknown arg \\`title\\` in where.AND.0.title for type PostWhereInput. Did you mean \\`id\\`? Available args:\n      type PostWhereInput {\n        AND?: PostWhereInput | List<PostWhereInput>\n        OR?: List<PostWhereInput>\n        NOT?: PostWhereInput | List<PostWhereInput>\n        id?: StringFilter | String\n        name?: StringFilter | String\n        email?: StringFilter | String\n        createdAt?: DateTimeFilter | DateTime\n        updatedAt?: DateTimeFilter | DateTime\n        userId?: StringFilter | String\n        user?: UserRelationFilter | UserWhereInput\n      }\n      Unknown arg \\`title\\` in where.AND.0.AND.0.title for type PostWhereInput. Did you mean \\`id\\`? Available args:\n      type PostWhereInput {\n        AND?: PostWhereInput | List<PostWhereInput>\n        OR?: List<PostWhereInput>\n        NOT?: PostWhereInput | List<PostWhereInput>\n        id?: StringFilter | String\n        name?: StringFilter | String\n        email?: StringFilter | String\n        createdAt?: DateTimeFilter | DateTime\n        updatedAt?: DateTimeFilter | DateTime\n        userId?: StringFilter | String\n        user?: UserRelationFilter | UserWhereInput\n      }\n\n\n    `)\n\n    expect(String(transformDocument(document))).toMatchInlineSnapshot(`\n      mutation {\n        updateManyPost(\n          where: {\n            AND: [\n              {\n                title: {\n                  \"equals\": \"a@a.de\",\n                  \"gt\": \"0\"\n                }\n                AND: [\n                  {\n                    title: {\n                      \"equals\": \"5\",\n                      \"not\": \"7\"\n                    }\n                    OR: [\n                      {\n                        id: {\n                          not: \"8\"\n                        }\n                      },\n                      {\n                        id: {\n                          not: \"9\"\n                        }\n                      }\n                    ]\n                  }\n                ]\n              },\n              {\n                id: {\n                  equals: \"1\"\n                  gt: \"0\"\n                }\n              }\n            ]\n          }\n          data: {\n\n          }\n        ) {\n          count\n        }\n      }\n    `)\n  })","file":"scalarWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"validate uuid scalar filter correctly","suites":["scalar where transformation"],"updatePoint":{"line":338,"column":45},"line":338,"code":"  test('validate uuid scalar filter correctly', () => {\n    const select = {\n      where: {\n        id: '806c902c-eab3-4e6e-ba4a-99c135389118',\n      },\n    }\n    const document = transformDocument(\n      makeDocument({\n        dmmf,\n        select,\n        rootTypeName: 'query',\n        rootField: 'findManyTest',\n      }),\n    )\n\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyTest(where: {\n          id: \"806c902c-eab3-4e6e-ba4a-99c135389118\"\n        }) {\n          id\n          name\n        }\n      }\n    `)\n\n    expect(document.validate(select, false, 'tests')).toMatchInlineSnapshot(`undefined`)\n  })","file":"scalarWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"validate uuid scalar filter should error when invalid input","suites":["scalar where transformation"],"updatePoint":{"line":367,"column":67},"line":367,"code":"  test('validate uuid scalar filter should error when invalid input', () => {\n    const select = {\n      where: {\n        id: 'asd',\n      },\n    }\n\n    const document = transformDocument(\n      makeDocument({\n        dmmf,\n        select,\n        rootTypeName: 'query',\n        rootField: 'findManyTest',\n      }),\n    )\n\n    expect(String(document)).toMatchInlineSnapshot(`\n      query {\n        findManyTest(where: {\n          id: \"asd\"\n        }) {\n          id\n          name\n        }\n      }\n    `)\n\n    try {\n      expect(document.validate(select, false, 'tests')).toMatchInlineSnapshot(`undefined`)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n        \"\n        Invalid \\`prisma.tests()\\` invocation:\n\n        {\n          where: {\n            id: 'asd'\n                ~~~~~\n          }\n        }\n\n        Argument id: Got invalid value 'asd' on prisma.findManyTest. Provided String, expected UUID or UUIDFilter.\n        type UUIDFilter {\n          equals?: UUID\n          not?: UUID | UUIDFilter\n          in?: List<UUID>\n          notIn?: List<UUID>\n          lt?: UUID\n          lte?: UUID\n          gt?: UUID\n          gte?: UUID\n          contains?: UUID\n          startsWith?: UUID\n          endsWith?: UUID\n        }\n\n        \"\n      `)\n    }\n  })","file":"scalarWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"filter by enum","suites":["scalar where transformation"],"updatePoint":{"line":428,"column":22},"line":428,"code":"  test('filter by enum', () => {\n    const select = {\n      where: {\n        favoriteTree: {\n          in: ['OAK', 'BLACKASH'],\n        },\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n\n    expect(String(transformDocument(document))).toMatchInlineSnapshot(`\n      query {\n        findManyUser(where: {\n          favoriteTree: {\n            in: [OAK, BLACKASH]\n          }\n        }) {\n          id\n          name\n          email\n          status\n          nicknames\n          permissions\n          favoriteTree\n          locationId\n          someFloats\n        }\n      }\n    `)\n\n    document.validate(select, false, 'user')\n  })","file":"scalarWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"joins the argv array of strings input into one single string","suites":[],"updatePoint":{"line":16,"column":66},"line":16,"code":"test('joins the argv array of strings input into one single string', () => {\n  expect(getPostInstallTrigger()).toEqual('npm foo bar')\n})","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"empty original argv array results in just the package manager name as the command","suites":[],"updatePoint":{"line":20,"column":87},"line":20,"code":"test('empty original argv array results in just the package manager name as the command', () => {\n  process.env.npm_config_argv = '{\"original\":[]}'\n  expect(getPostInstallTrigger()).toEqual('npm')\n})","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"gets package manager name from npm_config_user_agent when matching userAgent pattern e.g. for %s","suites":["npm_config_user_agent"],"line":26,"code":"  test.each([['yarn'], ['npm'], ['pnpm'], ['qux']])(\n    'gets package manager name from npm_config_user_agent when matching userAgent pattern e.g. for %s',\n    (name) => {\n      process.env.npm_config_user_agent = `${name}/1.2.3`\n      expect(getPostInstallTrigger()).toEqual(`${name} foo bar`)\n    },\n  )","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"trailing whitespace on command trimmed","suites":["npm_config_user_agent"],"updatePoint":{"line":34,"column":46},"line":34,"code":"  test('trailing whitespace on command trimmed', () => {\n    process.env.npm_config_user_agent = 'npm /1.2.3'\n    expect(getPostInstallTrigger()).toEqual('npm foo bar')\n  })","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"leading whitespace on command trimmed","suites":["npm_config_user_agent"],"updatePoint":{"line":38,"column":45},"line":38,"code":"  test('leading whitespace on command trimmed', () => {\n    process.env.npm_config_user_agent = '  npm/1.2.3'\n    expect(getPostInstallTrigger()).toEqual('npm foo bar')\n  })","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"if npm_config_user_agent not available then falls back to MISSING_NPM_CONFIG_USER_AGENT","suites":["npm_config_user_agent"],"line":43,"code":"  test.each([[undefined], [''], [' ']])(\n    'if npm_config_user_agent not available then falls back to MISSING_NPM_CONFIG_USER_AGENT',\n    (value) => {\n      if (value === undefined) {\n        delete process.env.npm_config_user_agent\n      } else {\n        process.env.npm_config_user_agent = value\n      }\n      delete process.env.npm_config_user_agent\n      expect(getPostInstallTrigger()).toEqual(`MISSING_NPM_CONFIG_USER_AGENT foo bar`)\n    },\n  )","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"if npm_config_user_agent not parsable then falls back to UNKNOWN_NPM_CONFIG_USER_AGENT","suites":["npm_config_user_agent"],"line":56,"code":"  test.each([['foo@1.2.3']])(\n    'if npm_config_user_agent not parsable then falls back to UNKNOWN_NPM_CONFIG_USER_AGENT',\n    (userAgentString) => {\n      process.env.npm_config_user_agent = userAgentString\n      expect(getPostInstallTrigger()).toEqual(`UNKNOWN_NPM_CONFIG_USER_AGENT(${userAgentString}) foo bar`)\n    },\n  )","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"%s","suites":["fails gracefully with"],"line":67,"code":"  test.each([\n    ['envar missing', undefined, UNABLE_TO_FIND_POSTINSTALL_TRIGGER__ENVAR_MISSING],\n    ['envar bad json', 'bah', UNABLE_TO_FIND_POSTINSTALL_TRIGGER_JSON_PARSE_ERROR +': bah'],\n    ['envar bad json schema missing field', '{}', UNABLE_TO_FIND_POSTINSTALL_TRIGGER_JSON_SCHEMA_ERROR+': {}'],\n    ['envar bad json schema bad field type', '{\"original\":1}', UNABLE_TO_FIND_POSTINSTALL_TRIGGER_JSON_SCHEMA_ERROR+': {\"original\":1}'],\n  ])('%s', (_, envVarValue, expected) => {\n    if (envVarValue === undefined) {\n       delete process.env.npm_config_argv\n     } else  {\n       process.env.npm_config_argv = envVarValue\n     }\n    expect(getPostInstallTrigger()).toEqual(expected)\n  })","file":"scripts/postinstall.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"unknown arg, field, incorrect arg type","suites":["select validation"],"updatePoint":{"line":15,"column":46},"line":15,"code":"  test('unknown arg, field, incorrect arg type', () => {\n    expect.assertions(4)\n    const ast = {\n      skip: 200,\n      where: {\n        name_contains: undefined,\n        name_in: ['hans', 'peter', 'schmidt'],\n        AND: [\n          {\n            age_gt: 10123123123,\n            this_is_completely_arbitrary: 'veryLongNameGoIntoaNewLineNow@gmail.com',\n          },\n          {\n            age_gt: 10123123123,\n            id_endsWith: 'veryLongNameGoIntoaNewLineNow@gmail.com',\n            name_contains: 'hans',\n            name_gt: 2131203912039123,\n            name_in: ['hans'],\n            AND: [\n              {\n                age_gt: '10123123123',\n                id_endsWith: 'veryLongNameGoIntoaNewLineNow@gmail.com',\n              },\n            ],\n          },\n        ],\n      },\n      select: {\n        id: true,\n        name: 'asd',\n        name2: true,\n        posts: {\n          take: 200,\n          select: {\n            id: true,\n            title: false,\n          },\n        },\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyUser',\n    })\n    expect(String(document)).toMatchSnapshot()\n\n    try {\n      document.validate(ast, undefined, undefined, 'minimal')\n    } catch (e) {\n      expect(e.message).toMatchSnapshot()\n    }\n\n    try {\n      document.validate(ast, undefined, undefined, 'colorless')\n    } catch (e) {\n      expect(e.message).toMatchSnapshot()\n    }\n\n    try {\n      document.validate(ast)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchSnapshot()\n    }\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing arg object","suites":["select validation"],"updatePoint":{"line":83,"column":26},"line":83,"code":"  test('missing arg object', () => {\n    expect.assertions(2)\n    const ast = {}\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'mutation',\n      rootField: 'createOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(ast)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchSnapshot()\n    }\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing arg object colorless","suites":["select validation"],"updatePoint":{"line":102,"column":36},"line":102,"code":"  test('missing arg object colorless', () => {\n    expect.assertions(4)\n    const ast = {}\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'mutation',\n      rootField: 'createOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(ast)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchSnapshot()\n    }\n\n    try {\n      document.validate(ast, undefined, undefined, 'minimal')\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchSnapshot()\n    }\n\n    try {\n      document.validate(ast, undefined, undefined, 'colorless')\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchSnapshot()\n    }\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing arg scalar","suites":["select validation"],"updatePoint":{"line":133,"column":26},"line":133,"code":"  test('missing arg scalar', () => {\n    expect.assertions(2)\n    const ast = {\n      data: {\n        title: 'string',\n        author: {\n          connect: { id: '' },\n        },\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'mutation',\n      rootField: 'createOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(ast)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchSnapshot()\n    }\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"missing arg scalar && object","suites":["select validation"],"updatePoint":{"line":159,"column":36},"line":159,"code":"  test('missing arg scalar && object', () => {\n    expect.assertions(2)\n    const ast = {\n      data: {\n        title: 'string',\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'mutation',\n      rootField: 'createOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(ast)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchSnapshot()\n    }\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Allow simple create mutation","suites":["select validation"],"updatePoint":{"line":182,"column":36},"line":182,"code":"  test('Allow simple create mutation', () => {\n    expect.assertions(2)\n    const ast = {\n      data: {\n        title: 'Some title',\n        content: 'Some Content',\n        published: false,\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'mutation',\n      rootField: 'createOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Allow explicit null value","suites":["select validation"],"updatePoint":{"line":203,"column":33},"line":203,"code":"  test('Allow explicit null value', () => {\n    expect.assertions(2)\n    const ast = {\n      data: {\n        title: 'Some title',\n        content: null,\n        published: false,\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'mutation',\n      rootField: 'createOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Allow different iso strings 1","suites":["select validation"],"updatePoint":{"line":224,"column":37},"line":224,"code":"  test('Allow different iso strings 1', () => {\n    expect.assertions(2)\n    const ast = {\n      data: {\n        title: 'Some title',\n        content: null,\n        published: false,\n        createdAt: '2020-05-05T16:28:33.983Z',\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'mutation',\n      rootField: 'createOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Allow different iso strings 2","suites":["select validation"],"updatePoint":{"line":246,"column":37},"line":246,"code":"  test('Allow different iso strings 2', () => {\n    expect.assertions(2)\n    const ast = {\n      data: {\n        title: 'Some title',\n        content: null,\n        published: false,\n        createdAt: '2020-05-05T16:28:33.983+03:00',\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'mutation',\n      rootField: 'createOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Allow different iso strings 3","suites":["select validation"],"updatePoint":{"line":268,"column":37},"line":268,"code":"  test('Allow different iso strings 3', () => {\n    expect.assertions(2)\n    const ast = {\n      data: {\n        title: 'Some title',\n        content: null,\n        published: false,\n        createdAt: '2020-05-05T16:28:33.983-02:00',\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'mutation',\n      rootField: 'createOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Allow uuid for string input","suites":["select validation"],"updatePoint":{"line":290,"column":35},"line":290,"code":"  test('Allow uuid for string input', () => {\n    expect.assertions(2)\n    const ast = {\n      data: {\n        title: 'Some title',\n        content: '123e4567-e89b-12d3-a456-426655440000',\n        published: false,\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'mutation',\n      rootField: 'createOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Allow deep select query","suites":["select validation"],"updatePoint":{"line":311,"column":31},"line":311,"code":"  test('Allow deep select query', () => {\n    expect.assertions(2)\n    const ast = {\n      select: {\n        author: {\n          select: {\n            id: true,\n          },\n        },\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Accept empty where in findMany","suites":["select validation"],"updatePoint":{"line":334,"column":38},"line":334,"code":"  test('Accept empty where in findMany', () => {\n    expect.assertions(2)\n    const ast = {\n      select: {\n        author: {\n          select: {\n            id: true,\n          },\n        },\n      },\n      where: {},\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"allow where with all undefined in findMany","suites":["select validation"],"updatePoint":{"line":358,"column":50},"line":358,"code":"  test('allow where with all undefined in findMany', () => {\n    expect.assertions(2)\n    const ast = {\n      select: {\n        author: {\n          select: {\n            id: true,\n          },\n        },\n      },\n      where: {\n        id: undefined,\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"reject empty where for findUnique","suites":["select validation"],"updatePoint":{"line":384,"column":41},"line":384,"code":"  test('reject empty where for findUnique', () => {\n    expect.assertions(2)\n    const ast = {\n      select: {\n        author: {\n          select: {\n            id: true,\n          },\n        },\n      },\n      where: {},\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findUniquePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(ast)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchSnapshot()\n    }\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"reject all undefined where for findUnique","suites":["select validation"],"updatePoint":{"line":412,"column":49},"line":412,"code":"  test('reject all undefined where for findUnique', () => {\n    expect.assertions(2)\n    const ast = {\n      select: {\n        author: {\n          select: {\n            id: true,\n          },\n        },\n      },\n      where: {\n        id: undefined,\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findUniquePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(ast)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchSnapshot()\n    }\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Allow uuid array for string array","suites":["select validation"],"updatePoint":{"line":442,"column":41},"line":442,"code":"  test('Allow uuid array for string array', () => {\n    expect.assertions(2)\n    const ast = {\n      select: {\n        author: {\n          select: {\n            id: true,\n          },\n        },\n      },\n      where: {\n        id: {\n          in: ['d4082b42-b161-11e9-8754-6542abf52968'],\n        },\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Allow empty input array","suites":["select validation"],"updatePoint":{"line":470,"column":31},"line":470,"code":"  test('Allow empty input array', () => {\n    expect.assertions(2)\n    const ast = {\n      select: {\n        author: {\n          select: {\n            id: true,\n          },\n        },\n      },\n      where: {\n        id: {\n          in: [],\n        },\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Allow select with an include","suites":["select validation"],"updatePoint":{"line":498,"column":36},"line":498,"code":"  test('Allow select with an include', () => {\n    expect.assertions(2)\n    const ast = {\n      select: {\n        author: {\n          include: { posts: true },\n        },\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select: ast,\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    expect(() => document.validate(ast)).not.toThrow()\n  })","file":"select.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"empty","suites":["serializeRawParameters"],"updatePoint":{"line":10,"column":13},"line":10,"code":"  test('empty', () => {\n    expect(serialize([])).toEqual([])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"primitives","suites":["serializeRawParameters"],"updatePoint":{"line":14,"column":18},"line":14,"code":"  test('primitives', () => {\n    const data = [0, 1, true, false, '', 'hi', null, undefined]\n    expect(serialize(data)).toEqual([0, 1, true, false, '', 'hi', null, null])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"date","suites":["serializeRawParameters"],"updatePoint":{"line":19,"column":12},"line":19,"code":"  test('date', () => {\n    const data = [new Date('2020-06-22T17:07:16.348Z')]\n\n    expect(serialize(data)).toEqual([\n      {\n        prisma__type: 'date',\n        prisma__value: '2020-06-22T17:07:16.348Z',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"BigInt","suites":["serializeRawParameters"],"updatePoint":{"line":30,"column":14},"line":30,"code":"  test('BigInt', () => {\n    const data = [BigInt('321804719213721')]\n\n    expect(serialize(data)).toEqual([\n      {\n        prisma__type: 'bigint',\n        prisma__value: '321804719213721',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Decimal","suites":["serializeRawParameters"],"updatePoint":{"line":41,"column":15},"line":41,"code":"  test('Decimal', () => {\n    const data = [new Decimal(1.1)]\n\n    expect(serialize(data)).toEqual([\n      {\n        prisma__type: 'decimal',\n        prisma__value: '1.1',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Buffer","suites":["serializeRawParameters"],"updatePoint":{"line":52,"column":14},"line":52,"code":"  test('Buffer', () => {\n    const data = [Buffer.from('hello')]\n\n    expect(serialize(data)).toEqual([\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'aGVsbG8=',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"typed byte arrays","suites":["serializeRawParameters"],"updatePoint":{"line":63,"column":25},"line":63,"code":"  test('typed byte arrays', () => {\n    const data = [\n      Int8Array.of(0x69, 0x6e, 0x74, 0x38),\n      Uint8Array.of(0x75, 0x69, 0x6e, 0x74, 0x38),\n      Uint8ClampedArray.of(0x75, 0x69, 0x6e, 0x74, 0x38, 0x63),\n    ]\n\n    expect(serialize(data)).toEqual([\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'aW50OA==',\n      },\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'dWludDg=',\n      },\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'dWludDhj',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"ArrayBuffer","suites":["serializeRawParameters"],"updatePoint":{"line":86,"column":19},"line":86,"code":"  test('ArrayBuffer', () => {\n    const arrayBuffer = new ArrayBuffer(6)\n    const array = new Uint8Array(arrayBuffer)\n    array.set([0x62, 0x75, 0x66, 0x66, 0x65, 0x72])\n\n    expect(serialize([arrayBuffer])).toEqual([\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'YnVmZmVy',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"SharedArrayBuffer","suites":["serializeRawParameters"],"updatePoint":{"line":99,"column":25},"line":99,"code":"  test('SharedArrayBuffer', () => {\n    const sharedArrayBuffer = new SharedArrayBuffer(6)\n    const array = new Uint8Array(sharedArrayBuffer)\n    array.set([0x73, 0x68, 0x61, 0x72, 0x65, 0x64])\n\n    expect(serialize([sharedArrayBuffer])).toEqual([\n      {\n        prisma__type: 'bytes',\n        prisma__value: 'c2hhcmVk',\n      },\n    ])\n  })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"no BigInts","suites":["serializeRawParameters","objects"],"updatePoint":{"line":115,"column":20},"line":115,"code":"    test('no BigInts', () => {\n      const data = [\n        {\n          text: 'text',\n          number: 1,\n        },\n        {\n          date: new Date('2020-06-22T17:07:16.348Z'),\n          buffer: Buffer.from('hello'),\n        },\n        {\n          nested: {\n            array: [new Date('2020-06-22T17:07:16.348Z'), '321804719213721'],\n          },\n        },\n        [123, '321804719213721'],\n      ]\n\n      expect(serialize(data)).toEqual([\n        {\n          text: 'text',\n          number: 1,\n        },\n        {\n          date: '2020-06-22T17:07:16.348Z',\n          buffer: { type: 'Buffer', data: [104, 101, 108, 108, 111] },\n        },\n        {\n          nested: {\n            array: ['2020-06-22T17:07:16.348Z', '321804719213721'],\n          },\n        },\n        [123, '321804719213721'],\n      ])\n    })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"with BigInts","suites":["serializeRawParameters","objects"],"updatePoint":{"line":151,"column":22},"line":151,"code":"    test('with BigInts', () => {\n      const data = [\n        {\n          text: 'text',\n          number: 1,\n        },\n        {\n          date: new Date('2020-06-22T17:07:16.348Z'),\n          bigInt: BigInt('321804719213721'),\n          buffer: Buffer.from('hello'),\n        },\n        {\n          nested: {\n            array: [new Date('2020-06-22T17:07:16.348Z'), BigInt('321804719213721')],\n          },\n        },\n        [123, BigInt('321804719213721')],\n      ]\n\n      expect(serialize(data)).toEqual([\n        {\n          text: 'text',\n          number: 1,\n        },\n        {\n          date: '2020-06-22T17:07:16.348Z',\n          bigInt: '321804719213721',\n          buffer: { type: 'Buffer', data: [104, 101, 108, 108, 111] },\n        },\n        {\n          nested: {\n            array: ['2020-06-22T17:07:16.348Z', '321804719213721'],\n          },\n        },\n        [123, '321804719213721'],\n      ])\n    })","file":"serializeRawParameters.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"where null","suites":["minimal where transformation"],"updatePoint":{"line":15,"column":18},"line":15,"code":"  test('where null', () => {\n    const transformedDocument = getTransformedDocument({\n      where: {\n        company: null,\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      query {\n        findManyLocation(where: {\n          company: null\n        }) {\n          id\n          companyId\n        }\n      }\n    `)\n  })","file":"singularRelationWhereTransformation.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"does not depend on 'node' types","suites":["runtime/index.d.ts"],"updatePoint":{"line":5,"column":37},"line":5,"code":"  it(\"does not depend on 'node' types\", () => {\n    const runtimeDtsPath = path.join(__dirname, '..', '..', 'runtime', 'index.d.ts')\n    const runtimeDts = fs.readFileSync(runtimeDtsPath).toString()\n    expect(runtimeDts).not.toContain('/// <reference types=\"node\" />')\n  })","file":"typeDeclaration.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"%s","suites":["valid types"],"line":23,"code":"  test.concurrent.each(subDirs)('%s', async (dir) => {\n    const testName = path.basename(dir)\n\n    const nodeModules = path.join(dir, 'node_modules')\n    if (fs.existsSync(nodeModules)) {\n      await del(nodeModules)\n    }\n    await generateInFolder({\n      projectDir: dir,\n      useLocalRuntime: false,\n      transpile: true,\n      packageSource,\n    })\n    const indexPath = path.join(dir, 'test.ts')\n    const tsdTestPath = path.join(dir, 'index.test-d.ts')\n\n    if (fs.existsSync(tsdTestPath)) {\n      await runTsd(dir)\n    }\n\n    if (testName.startsWith('unhappy')) {\n      await expect(compileFile(indexPath)).rejects.toThrow()\n    } else {\n      await expect(compileFile(indexPath)).resolves.not.toThrow()\n    }\n  })","file":"types/types.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"null when undefined is allowed","suites":["select validation"],"updatePoint":{"line":15,"column":38},"line":15,"code":"  test('null when undefined is allowed', () => {\n    const select = {\n      data: {\n        id: null,\n      },\n      where: {\n        id: 'abc',\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'mutation',\n      rootField: 'updateOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(select)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n\n        Invalid \\`prisma.updateOnePost()\\` invocation:\n\n        {\n          data: {\n            id: null\n                ~~~~\n          },\n          where: {\n            id: 'abc'\n          }\n        }\n\n        Argument id for data.id must not be null. Please use undefined instead.\n\n\n      `)\n    }\n  })","file":"undefined-vs-null.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"null when undefined is not allowed","suites":["select validation"],"updatePoint":{"line":56,"column":42},"line":56,"code":"  test('null when undefined is not allowed', () => {\n    const select = {\n      data: {\n        published: true,\n        title: null,\n      },\n    }\n\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'mutation',\n      rootField: 'createOnePost',\n    })\n\n    expect(String(document)).toMatchSnapshot()\n    try {\n      document.validate(select)\n    } catch (e) {\n      expect(stripAnsi(e.message)).toMatchInlineSnapshot(`\n\n                                                        Invalid \\`prisma.createOnePost()\\` invocation:\n\n                                                        {\n                                                          data: {\n                                                            published: true,\n                                                            title: null\n                                                                   ~~~~\n                                                          }\n                                                        }\n\n                                                        Argument title: Got invalid value null on prisma.createOnePost. Provided null, expected String.\n\n\n                                          `)\n    }\n  })","file":"undefined-vs-null.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"blog findUniqueUser","suites":["getField"],"updatePoint":{"line":16,"column":27},"line":16,"code":"  test('blog findUniqueUser', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {\n        select: {\n          id: true,\n          posts: true,\n        },\n      },\n      rootTypeName: 'query',\n      rootField: 'findUniqueUser',\n    })\n\n    expect(getField(document, ['findUniqueUser']).name).toMatchInlineSnapshot(`findUniqueUser`)\n    expect(getField(document, ['findUniqueUser', 'id']).name).toMatchInlineSnapshot(`id`)\n    expect(getField(document, ['findUniqueUser', 'posts']).name).toMatchInlineSnapshot(`posts`)\n    expect(getField(document, ['findUniqueUser', 'posts', 'title']).name).toMatchInlineSnapshot(`title`)\n  })","file":"unpack.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"findUniquePost","suites":["unpack"],"updatePoint":{"line":37,"column":22},"line":37,"code":"  test('findUniquePost', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {},\n      rootTypeName: 'query',\n      rootField: 'findUniquePost',\n    })\n\n    const path = ['findUniquePost']\n\n    const data = {\n      findUniquePost: {\n        id: 'some-id',\n        createdAt: '2019-10-17T09:56:37.690Z',\n        updatedAt: '2019-10-17T09:56:37.690Z',\n        published: false,\n        title: 'Some mighty hightly title',\n      },\n    }\n\n    const result = unpack({\n      document,\n      path,\n      data,\n    })\n\n    expect(result.createdAt).toBeInstanceOf(Date)\n    expect(result.updatedAt).toBeInstanceOf(Date)\n\n    expect(result).toMatchInlineSnapshot(`\n      Object {\n        createdAt: 2019-10-17T09:56:37.690Z,\n        id: some-id,\n        published: false,\n        title: Some mighty hightly title,\n        updatedAt: 2019-10-17T09:56:37.690Z,\n      }\n    `)\n  })","file":"unpack.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"findManyPost","suites":["unpack"],"updatePoint":{"line":77,"column":20},"line":77,"code":"  test('findManyPost', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {},\n      rootTypeName: 'query',\n      rootField: 'findManyPost',\n    })\n\n    const path = ['findManyPost']\n\n    const data = {\n      findManyPost: [\n        {\n          id: 'some-id',\n          createdAt: '2019-10-17T09:56:37.690Z',\n          updatedAt: '2019-10-17T09:56:37.690Z',\n          published: false,\n          title: 'Some mighty hightly title',\n        },\n        {\n          id: 'some-id2',\n          createdAt: '2019-11-17T09:56:37.690Z',\n          updatedAt: '2019-11-17T09:56:37.690Z',\n          published: true,\n          title: 'Having a title that is recital is just vital',\n        },\n        {\n          id: 'some-id3',\n          createdAt: '2019-11-17T09:56:37.690Z',\n          updatedAt: '2019-11-17T09:56:37.690Z',\n          published: true,\n          title: \"One thing for sure: If you don't read the bible, you can't belong to the tribal.\",\n        },\n      ],\n    }\n\n    const result = unpack({\n      document,\n      path,\n      data,\n    })\n\n    expect(result[0].createdAt).toBeInstanceOf(Date)\n    expect(result[0].updatedAt).toBeInstanceOf(Date)\n\n    expect(result).toMatchInlineSnapshot(`\n      Array [\n        Object {\n          createdAt: 2019-10-17T09:56:37.690Z,\n          id: some-id,\n          published: false,\n          title: Some mighty hightly title,\n          updatedAt: 2019-10-17T09:56:37.690Z,\n        },\n        Object {\n          createdAt: 2019-11-17T09:56:37.690Z,\n          id: some-id2,\n          published: true,\n          title: Having a title that is recital is just vital,\n          updatedAt: 2019-11-17T09:56:37.690Z,\n        },\n        Object {\n          createdAt: 2019-11-17T09:56:37.690Z,\n          id: some-id3,\n          published: true,\n          title: One thing for sure: If you don't read the bible, you can't belong to the tribal.,\n          updatedAt: 2019-11-17T09:56:37.690Z,\n        },\n      ]\n    `)\n  })","file":"unpack.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"findUniqueUser","suites":["unpack"],"updatePoint":{"line":149,"column":22},"line":149,"code":"  test('findUniqueUser', () => {\n    const document = makeDocument({\n      dmmf,\n      select: {\n        include: {\n          posts: true,\n        },\n      },\n      rootTypeName: 'query',\n      rootField: 'findUniqueUser',\n    })\n\n    const path = ['findUniqueUser']\n\n    const data = {\n      findUniqueUser: {\n        id: 'some-id',\n        email: 'a@a.com',\n        json: '{\"hello\": \"world\"}',\n        posts: [\n          {\n            id: 'some-id',\n            createdAt: '2019-10-17T09:56:37.690Z',\n            updatedAt: '2019-10-17T09:56:37.690Z',\n            published: false,\n            title: 'Some mighty hightly title',\n          },\n          {\n            id: 'some-id2',\n            createdAt: '2019-11-17T09:56:37.690Z',\n            updatedAt: '2019-11-17T09:56:37.690Z',\n            published: true,\n            title: 'Having a title that is recital is just vital',\n          },\n          {\n            id: 'some-id3',\n            createdAt: '2019-11-17T09:56:37.690Z',\n            updatedAt: '2019-11-17T09:56:37.690Z',\n            published: true,\n            title: 'Does the bible talk about the revival of the tribal?',\n          },\n        ],\n      },\n    }\n\n    const result = unpack({\n      document,\n      path,\n      data,\n    })\n\n    expect(result).toMatchInlineSnapshot(`\n      Object {\n        email: a@a.com,\n        id: some-id,\n        json: Object {\n          hello: world,\n        },\n        posts: Array [\n          Object {\n            createdAt: 2019-10-17T09:56:37.690Z,\n            id: some-id,\n            published: false,\n            title: Some mighty hightly title,\n            updatedAt: 2019-10-17T09:56:37.690Z,\n          },\n          Object {\n            createdAt: 2019-11-17T09:56:37.690Z,\n            id: some-id2,\n            published: true,\n            title: Having a title that is recital is just vital,\n            updatedAt: 2019-11-17T09:56:37.690Z,\n          },\n          Object {\n            createdAt: 2019-11-17T09:56:37.690Z,\n            id: some-id3,\n            published: true,\n            title: Does the bible talk about the revival of the tribal?,\n            updatedAt: 2019-11-17T09:56:37.690Z,\n          },\n        ],\n      }\n    `)\n  })","file":"unpack.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"set null values","suites":["minimal update transformation"],"updatePoint":{"line":26,"column":23},"line":26,"code":"  test('set null values', () => {\n    const transformedDocument = getTransformedDocument({\n      data: {\n        name: null,\n        profile: {\n          set: null,\n        },\n        posts: {\n          updateMany: {\n            data: {\n              optional: null,\n              content: {\n                set: null,\n              },\n            },\n            where: {\n              id: 'someid',\n            },\n          },\n        },\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      mutation {\n        updateOneUser(\n          data: {\n            name: null\n            profile: {\n              set: null\n            }\n            posts: {\n              updateMany: {\n                data: {\n                  optional: null\n                  content: {\n                    set: null\n                  }\n                }\n                where: {\n                  id: \"someid\"\n                }\n              }\n            }\n          }\n        ) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"update.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"set date","suites":["minimal update transformation"],"updatePoint":{"line":90,"column":16},"line":90,"code":"  test('set date', () => {\n    const transformedDocument = getTransformedDocument({\n      data: {\n        lastLoginAt: new Date('2020-09-04T07:45:24.484Z'),\n        posts: {\n          updateMany: {\n            data: {\n              updatedAt: new Date('2020-09-04T07:45:24.484Z'),\n            },\n            where: {\n              id: 'someid',\n            },\n          },\n        },\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      mutation {\n        updateOneUser(\n          data: {\n            lastLoginAt: \"2020-09-04T07:45:24.484Z\"\n            posts: {\n              updateMany: {\n                data: {\n                  updatedAt: \"2020-09-04T07:45:24.484Z\"\n                }\n                where: {\n                  id: \"someid\"\n                }\n              }\n            }\n          }\n        ) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"update.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"set date with set wrapper","suites":["minimal update transformation"],"updatePoint":{"line":142,"column":33},"line":142,"code":"  test('set date with set wrapper', () => {\n    const transformedDocument = getTransformedDocument({\n      data: {\n        lastLoginAt: {\n          set: new Date('2020-09-04T07:45:24.484Z'),\n        },\n        posts: {\n          updateMany: {\n            data: {\n              updatedAt: {\n                set: new Date('2020-09-04T07:45:24.484Z'),\n              },\n            },\n            where: {\n              id: 'someid',\n            },\n          },\n        },\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      mutation {\n        updateOneUser(\n          data: {\n            lastLoginAt: {\n              set: \"2020-09-04T07:45:24.484Z\"\n            }\n            posts: {\n              updateMany: {\n                data: {\n                  updatedAt: {\n                    set: \"2020-09-04T07:45:24.484Z\"\n                  }\n                }\n                where: {\n                  id: \"someid\"\n                }\n              }\n            }\n          }\n        ) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"update.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Boolean[] list with set","suites":["minimal update transformation"],"updatePoint":{"line":202,"column":31},"line":202,"code":"  test('Boolean[] list with set', () => {\n    const transformedDocument = getTransformedDocument({\n      data: {\n        coinflips: {\n          set: [true, true, true, false, true],\n        },\n      },\n    })\n\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      mutation {\n        updateOneUser(\n          data: {\n            coinflips: {\n              set: [true, true, true, false, true]\n            }\n          }\n        ) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"update.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"Boolean[] list without set","suites":["minimal update transformation"],"updatePoint":{"line":238,"column":34},"line":238,"code":"  test('Boolean[] list without set', () => {\n    const transformedDocument = getTransformedDocument({\n      data: {\n        coinflips: [true, true, true, false, true],\n      },\n    })\n\n    // this is broken and needs to be fixed\n    expect(transformedDocument).toMatchInlineSnapshot(`\n      mutation {\n        updateOneUser(\n          data: {\n            coinflips: [true, true, true, false, true]\n          }\n        ) {\n          id\n          email\n          name\n          json\n          countFloat\n          countInt1\n          countInt2\n          countInt3\n          countInt4\n          countInt5\n          countInt6\n          lastLoginAt\n          coinflips\n        }\n      }\n    `)\n  })","file":"update.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"string first","suites":["at least one validation"],"updatePoint":{"line":21,"column":20},"line":21,"code":"  test('string first', () => {\n    const select = {\n      data: {\n        hobbies: {\n          set: [\n            'sample 1 string',\n            '7fb1aef9-5250-4cf6-92c7-b01f53862822',\n            'sample 3 string',\n            '575e0b28-81fa-43e0-8f05-708a98d55c14',\n            'sample 5 string',\n          ],\n        },\n        name: 'name',\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'mutation',\n      rootField: 'createOneUser',\n    })\n    expect(() => document.validate(select, false)).not.toThrow()\n  })","file":"uuid.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"uuid first","suites":["at least one validation"],"updatePoint":{"line":44,"column":18},"line":44,"code":"  test('uuid first', () => {\n    const select = {\n      data: {\n        hobbies: {\n          set: [\n            '7fb1aef9-5250-4cf6-92c7-b01f53862822',\n            'sample 3 string',\n            '575e0b28-81fa-43e0-8f05-708a98d55c14',\n            'sample 5 string',\n          ],\n        },\n        name: 'name',\n      },\n    }\n    const document = makeDocument({\n      dmmf,\n      select,\n      rootTypeName: 'mutation',\n      rootField: 'createOneUser',\n    })\n    expect(() => document.validate(select, false)).not.toThrow()\n  })","file":"uuid.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"empty","suites":["valid options"],"updatePoint":{"line":4,"column":13},"line":4,"code":"  test('empty', () => {\n    expect.assertions(0)\n    validatePrismaClientOptions({}, ['db'])\n  })","file":"validatePrismaClientOptions.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"full","suites":["valid options"],"updatePoint":{"line":8,"column":12},"line":8,"code":"  test('full', () => {\n    expect.assertions(0)\n    validatePrismaClientOptions(\n      {\n        datasources: {\n          db: {\n            url: '',\n          },\n        },\n        errorFormat: 'pretty',\n        log: ['error'],\n      },\n      ['db'],\n    )\n\n    validatePrismaClientOptions(\n      {\n        datasources: {\n          db: {\n            url: '',\n          },\n        },\n        errorFormat: 'pretty',\n        log: [\n          {\n            emit: 'event',\n            level: 'error',\n          },\n        ],\n      },\n      ['db'],\n    )\n  })","file":"validatePrismaClientOptions.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"typos","suites":["invalid options"],"updatePoint":{"line":44,"column":13},"line":44,"code":"  test('typos', () => {\n    expect(() =>\n      validatePrismaClientOptions(\n        {\n          errorsFormat: 'minimal',\n        } as any,\n        ['db'],\n      ),\n    ).toThrowErrorMatchingInlineSnapshot(`\n      Unknown property errorsFormat provided to PrismaClient constructor. Did you mean \"errorFormat\"?\n      Read more at https://pris.ly/d/client-constructor\n    `)\n    expect(() =>\n      validatePrismaClientOptions(\n        {\n          errorFormat: 'minimal',\n          datasources: {\n            asd: {},\n          },\n        },\n        ['db'],\n      ),\n    ).toThrowErrorMatchingInlineSnapshot(`\n      Unknown datasource asd provided to PrismaClient constructor.Available datasources: db\n      Read more at https://pris.ly/d/client-constructor\n    `)\n    expect(() =>\n      validatePrismaClientOptions(\n        {\n          errorFormat: 'minimal',\n          datasources: {\n            db: { murl: '' },\n          },\n        } as any,\n        ['db'],\n      ),\n    ).toThrowErrorMatchingInlineSnapshot(`\n      Invalid value {\"db\":{\"murl\":\"\"}} for datasource \"db\" provided to PrismaClient constructor.\n      It should have this form: { url: \"CONNECTION_STRING\" }\n      Read more at https://pris.ly/d/client-constructor\n    `)\n    expect(() =>\n      validatePrismaClientOptions(\n        {\n          errorFormat: 'minimal',\n          log: [{ helo: 'world' }],\n        } as any,\n        ['db'],\n      ),\n    ).toThrowErrorMatchingInlineSnapshot(`\n      Invalid property helo for \"log\" provided to PrismaClient constructor\n      Read more at https://pris.ly/d/client-constructor\n    `)\n    expect(() =>\n      validatePrismaClientOptions(\n        {\n          errorFormat: 'minimal',\n          log: ['muery'],\n        } as any,\n        ['db'],\n      ),\n    ).toThrowErrorMatchingInlineSnapshot(`\n      Invalid log level \"muery\" provided to PrismaClient constructor. Did you mean \"query\"?\n      Read more at https://pris.ly/d/client-constructor\n    `)\n  })","file":"validatePrismaClientOptions.test.ts","skipped":false,"dir":"packages/client/src/__tests__"},{"name":"should not log if it is not enabled","suites":["debug"],"updatePoint":{"line":7,"column":43},"line":7,"code":"  test('should not log if it is not enabled', () => {\n    const debug = Debug('my-namespace')\n    const logs: string[] = []\n\n    debug.log = (...args) => {\n      logs.push(stripAnsi(`${args[0]}${args[1]}`).trim())\n    }\n\n    debug('Does it even log?')\n    debug('I dont know')\n\n    expect(removeISODate(JSON.stringify(logs, null, 2))).toMatchInlineSnapshot(`\"[]\"`)\n\n    expect(sanitizeTestLogs(getLogs())).toMatchInlineSnapshot(`\n      \"my-namespace Does it even log?\n      my-namespace I dont know\"\n    `)\n  })","file":"basic.test.ts","skipped":false,"dir":"packages/debug/src/__tests__"},{"name":"should log if its enabled","suites":["debug"],"updatePoint":{"line":26,"column":33},"line":26,"code":"  test('should log if its enabled', () => {\n    const debug = Debug('a-namespace')\n    const logs: string[] = []\n\n    Debug.enable('a-namespace')\n\n    debug.log = (...args) => {\n      logs.push(stripAnsi(`${args[0]}${args[1]}`).trim())\n    }\n\n    debug('Does it even log?')\n    debug('I dont know')\n\n    expect(removeISODate(JSON.stringify(logs, null, 2))).toMatchInlineSnapshot(`\n      \"[\n        \\\\\" a-namespace Does it even log?\\\\\",\n        \\\\\" a-namespace I dont know\\\\\"\n      ]\"\n    `)\n\n    expect(sanitizeTestLogs(getLogs())).toMatchInlineSnapshot(`\n      \"my-namespace Does it even log?\n      my-namespace I dont know\n      a-namespace Does it even log?\n      a-namespace I dont know\"\n    `)\n  })","file":"basic.test.ts","skipped":false,"dir":"packages/debug/src/__tests__"},{"name":"empty env var works as expected","suites":["debug"],"updatePoint":{"line":6,"column":39},"line":6,"code":"  test('empty env var works as expected', async () => {\n    process.env.DEBUG = ''\n\n    const { Debug, getLogs } = await import('../index')\n\n    const debug = Debug('my-namespace')\n    const logs: string[] = []\n\n    debug.log = (...args) => {\n      logs.push(stripAnsi(`${args[0]}${args[1]}`).trim())\n    }\n\n    debug('Does it even log?')\n    debug('I dont know')\n\n    expect(logs).toMatchInlineSnapshot(`Array []`)\n\n    expect(sanitizeTestLogs(getLogs())).toMatchInlineSnapshot(`\n      \"my-namespace Does it even log?\n      my-namespace I dont know\"\n    `)\n  })","file":"env-disabled.test.ts","skipped":false,"dir":"packages/debug/src/__tests__"},{"name":"env vars work as expected","suites":["debug"],"updatePoint":{"line":6,"column":33},"line":6,"code":"  test('env vars work as expected', async () => {\n    process.env.DEBUG = 'my-namespace'\n\n    const { Debug, getLogs } = await import('../index')\n\n    const debug = Debug('my-namespace')\n    const logs: string[] = []\n\n    debug.log = (...args) => {\n      logs.push(stripAnsi(`${args[0]}${args[1]}`).trim())\n    }\n\n    debug('Does it even log?')\n    debug('I dont know')\n\n    expect(removeISODate(JSON.stringify(logs, null, 2))).toMatchInlineSnapshot(`\n      \"[\n        \\\\\" my-namespace Does it even log?\\\\\",\n        \\\\\" my-namespace I dont know\\\\\"\n      ]\"\n    `)\n\n    expect(sanitizeTestLogs(getLogs())).toMatchInlineSnapshot(`\n      \"my-namespace Does it even log?\n      my-namespace I dont know\"\n    `)\n  })","file":"env-enabled.test.ts","skipped":false,"dir":"packages/debug/src/__tests__"},{"name":"serialization of 500 with default message","suites":["responseToError"],"updatePoint":{"line":20,"column":49},"line":20,"code":"  test('serialization of 500 with default message', async () => {\n    expect.assertions(2)\n\n    try {\n      await responseToError(response('', 500), '')\n    } catch (error) {\n      expect(error.message).toEqual('Unknown server error')\n      expect(error.logs).toBe(undefined)\n    }\n  })","file":"errors.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"serialization of 500 with useful message","suites":["responseToError"],"updatePoint":{"line":31,"column":48},"line":31,"code":"  test('serialization of 500 with useful message', async () => {\n    expect.assertions(2)\n\n    const errorJSON = {\n      EngineNotStarted: {\n        reason: 'EngineVersionNotSupported',\n      },\n    }\n\n    try {\n      await responseToError(response(JSON.stringify(errorJSON), 500), '')\n    } catch (error) {\n      expect(error.message).toEqual('Engine version is not supported')\n      expect(error.logs).toBe(undefined)\n    }\n  })","file":"errors.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"serialization of 500 with wrong shape","suites":["responseToError"],"updatePoint":{"line":48,"column":45},"line":48,"code":"  test('serialization of 500 with wrong shape', async () => {\n    expect.assertions(1)\n\n    const errorJSON = {\n      EngineNotStarted: {\n        reason: 'ILikeButterflies',\n      },\n    }\n\n    try {\n      await responseToError(response(JSON.stringify(errorJSON), 500), '')\n    } catch (error) {\n      expect(error.message).toEqual(\n        'Unknown server error: {\"type\":\"UnknownJsonError\",\"body\":{\"EngineNotStarted\":{\"reason\":\"ILikeButterflies\"}}}',\n      )\n    }\n  })","file":"errors.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"serialization of 500 with engine logs","suites":["responseToError"],"updatePoint":{"line":66,"column":45},"line":66,"code":"  test('serialization of 500 with engine logs', async () => {\n    expect.assertions(2)\n\n    const errorJSON = {\n      EngineNotStarted: {\n        reason: {\n          HealthcheckTimeout: {\n            logs: [\n              '{\"timestamp\":\"2022-04-14T12:01:00.487760Z\",\"level\":\"INFO\",\"fields\":{\"message\":\"Encountered error during initialization:\"},\"target\":\"query_engine\"}\\r\\n',\n              '{\"is_panic\":false,\"message\":\"Database error. error code: unknown, error message: Server selection timeout: No available servers. Topology: { Type: ReplicaSetNoPrimary, Servers: [ { Address: test-shard-00-00.abc.mongodb.net:27017, Type: Unknown, Error: Connection reset by peer (os error 104) }, { Address: test-shard-00-01.abc.mongodb.net:27017, Type: Unknown, Error: Connection reset by peer (os error 104) }, { Address: test-shard-00-02.abc.mongodb.net:27017, Type: Unknown, Error: Connection reset by peer (os error 104) }, ] }\",\"backtrace\":\"   0: user_facing_errors::Error::new_non_panic_with_current_backtrace\\\\n   1: query_engine::error::<impl core::convert::From<query_engine::error::PrismaError> for user_facing_errors::Error>::from\\\\n   2: query_engine::error::PrismaError::render_as_json\\\\n   3: query_engine::main::main::{{closure}}::{{closure}}\\\\n   4: <core::future::from_generator::GenFuture<T> as core::future::future::Future>::poll\\\\n   5: std::thread::local::LocalKey<T>::with\\\\n   6: <core::future::from_generator::GenFuture<T> as core::future::future::Future>::poll\\\\n   7: async_io::driver::block_on\\\\n   8: std::thread::local::LocalKey<T>::with\\\\n   9: std::thread::local::LocalKey<T>::with\\\\n  10: async_std::task::builder::Builder::blocking\\\\n  11: query_engine::main\\\\n  12: std::sys_common::backtrace::__rust_begin_short_backtrace\\\\n  13: std::rt::lang_start::{{closure}}\\\\n  14: core::ops::function::impls::<impl core::ops::function::FnOnce<A> for &F>::call_once\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/core/src/ops/function.rs:259:13\\\\n      std::panicking::try::do_call\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panicking.rs:403:40\\\\n      std::panicking::try\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panicking.rs:367:19\\\\n      std::panic::catch_unwind\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panic.rs:133:14\\\\n      std::rt::lang_start_internal::{{closure}}\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/rt.rs:128:48\\\\n      std::panicking::try::do_call\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panicking.rs:403:40\\\\n      std::panicking::try\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panicking.rs:367:19\\\\n      std::panic::catch_unwind\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panic.rs:133:14\\\\n      std::rt::lang_start_internal\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/rt.rs:128:20\\\\n  15: main\\\\n  16: __libc_start_main\\\\n  17: <unknown>\\\\n\"}\\r\\n',\n            ],\n          },\n        },\n      },\n    }\n\n    try {\n      await responseToError(response(JSON.stringify(errorJSON), 500), '')\n    } catch (error) {\n      expect(error.message).toEqual('Engine not started: healthcheck timeout')\n      expect(error.logs).toEqual([\n        '{\"timestamp\":\"2022-04-14T12:01:00.487760Z\",\"level\":\"INFO\",\"fields\":{\"message\":\"Encountered error during initialization:\"},\"target\":\"query_engine\"}\\r\\n',\n        '{\"is_panic\":false,\"message\":\"Database error. error code: unknown, error message: Server selection timeout: No available servers. Topology: { Type: ReplicaSetNoPrimary, Servers: [ { Address: test-shard-00-00.abc.mongodb.net:27017, Type: Unknown, Error: Connection reset by peer (os error 104) }, { Address: test-shard-00-01.abc.mongodb.net:27017, Type: Unknown, Error: Connection reset by peer (os error 104) }, { Address: test-shard-00-02.abc.mongodb.net:27017, Type: Unknown, Error: Connection reset by peer (os error 104) }, ] }\",\"backtrace\":\"   0: user_facing_errors::Error::new_non_panic_with_current_backtrace\\\\n   1: query_engine::error::<impl core::convert::From<query_engine::error::PrismaError> for user_facing_errors::Error>::from\\\\n   2: query_engine::error::PrismaError::render_as_json\\\\n   3: query_engine::main::main::{{closure}}::{{closure}}\\\\n   4: <core::future::from_generator::GenFuture<T> as core::future::future::Future>::poll\\\\n   5: std::thread::local::LocalKey<T>::with\\\\n   6: <core::future::from_generator::GenFuture<T> as core::future::future::Future>::poll\\\\n   7: async_io::driver::block_on\\\\n   8: std::thread::local::LocalKey<T>::with\\\\n   9: std::thread::local::LocalKey<T>::with\\\\n  10: async_std::task::builder::Builder::blocking\\\\n  11: query_engine::main\\\\n  12: std::sys_common::backtrace::__rust_begin_short_backtrace\\\\n  13: std::rt::lang_start::{{closure}}\\\\n  14: core::ops::function::impls::<impl core::ops::function::FnOnce<A> for &F>::call_once\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/core/src/ops/function.rs:259:13\\\\n      std::panicking::try::do_call\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panicking.rs:403:40\\\\n      std::panicking::try\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panicking.rs:367:19\\\\n      std::panic::catch_unwind\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panic.rs:133:14\\\\n      std::rt::lang_start_internal::{{closure}}\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/rt.rs:128:48\\\\n      std::panicking::try::do_call\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panicking.rs:403:40\\\\n      std::panicking::try\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panicking.rs:367:19\\\\n      std::panic::catch_unwind\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/panic.rs:133:14\\\\n      std::rt::lang_start_internal\\\\n             at /rustc/f1edd0429582dd29cccacaf50fd134b05593bd9c/library/std/src/rt.rs:128:20\\\\n  15: main\\\\n  16: __libc_start_main\\\\n  17: <unknown>\\\\n\"}\\r\\n',\n      ])\n    }\n  })","file":"errors.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"serialization of 400 includes default message if it is not a known error","suites":["responseToError"],"updatePoint":{"line":93,"column":80},"line":93,"code":"  test('serialization of 400 includes default message if it is not a known error', async () => {\n    expect.assertions(2)\n\n    try {\n      await responseToError(response(''), '')\n    } catch (error) {\n      expect(error.message).toEqual('This request could not be understood by the server')\n      expect(error.code).toEqual('P5000')\n    }\n  })","file":"errors.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"serialization of 400 includes original cause from data proxy if it is a known error","suites":["responseToError"],"updatePoint":{"line":104,"column":91},"line":104,"code":"  test('serialization of 400 includes original cause from data proxy if it is a known error', async () => {\n    expect.assertions(3)\n\n    const errorJSON = {\n      EngineNotStarted: {\n        reason: {\n          KnownEngineStartupError: {\n            msg: 'Authentication failed against database server at `my-database.random-id.eu-west-1.rds.amazonaws.com`, the provided database credentials for `username` are not valid.\\n\\nPlease make sure to provide valid database credentials for the database server at `my-database.random-id.eu-west-1.rds.amazonaws.com`.',\n            error_code: 'P1000',\n          },\n        },\n      },\n    }\n\n    try {\n      await responseToError(response(JSON.stringify(errorJSON)), '')\n    } catch (error) {\n      expect(error.constructor.name).toEqual('PrismaClientInitializationError')\n      expect(error.message).toEqual(\n        'Authentication failed against database server at `my-database.random-id.eu-west-1.rds.amazonaws.com`, the provided database credentials for `username` are not valid.\\n\\nPlease make sure to provide valid database credentials for the database server at `my-database.random-id.eu-west-1.rds.amazonaws.com`.',\n      )\n      expect(error.errorCode).toEqual('P1000')\n    }\n  })","file":"errors.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"The PDP request Id is added to error messages if the header is present in the response","suites":["responseToError"],"updatePoint":{"line":129,"column":94},"line":129,"code":"  test('The PDP request Id is added to error messages if the header is present in the response', async () => {\n    expect.assertions(1)\n\n    const errorJSON = {\n      EngineNotStarted: {\n        reason: 'SchemaMissing',\n      },\n    }\n\n    const error = await responseToError(response(JSON.stringify(errorJSON), 404, 'some-request-id'), '')\n    if (error) {\n      expect(error.message).toEqual('Schema needs to be uploaded (The request id was: some-request-id)')\n    }\n  })","file":"errors.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"basic serialization","suites":["getErrorMessageWithLink"],"updatePoint":{"line":146,"column":27},"line":146,"code":"  test('basic serialization', () => {\n    const debug = Debug('test-namespace')\n    debug('hello')\n    const message = getErrorMessageWithLink({\n      platform: 'darwin',\n      title: 'This is a title',\n      version: '1.2.3',\n      description: 'This is some crazy description',\n      query: 'QUERY',\n      database: 'mongodb',\n      engineVersion: 'abcdefhg',\n    })\n    expect(\n      stripAnsi(message)\n        .replace(/v\\d{1,2}\\.\\d{1,2}\\.\\d{1,2}/, 'NODE_VERSION')\n        .replace(/[\\+-]/g, ''),\n    ).toMatchInlineSnapshot(`\n      \"This is a title\n\n      This is a nonrecoverable error which probably happens when the Prisma Query Engine has a panic.\n\n      https://github.com/prisma/prisma/issues/new?body=HiPrismaTeam%21MyPrismaClientjustcrashed.Thisisthereport%3A%0A%23%23Versions%0A%0A%7CName%7CVersion%7C%0A%7C%7C%7C%0A%7CNode%7CNODE_VERSION%7C%0A%7COS%7Cdarwin%7C%0A%7CPrismaClient%7C1.2.3%7C%0A%7CQueryEngine%7Cabcdefhg%7C%0A%7CDatabase%7Cmongodb%7C%0A%0A%23Description%0A%60%60%60%0AThisissomecrazydescription%0A%60%60%60%0A%0A%23%23Logs%0A%60%60%60%0Atestnamespacehello%0A%60%60%60%0A%0A%23%23ClientSnippet%0A%60%60%60ts%0A%2F%2FPLEASEFILLYOURCODESNIPPETHERE%0A%60%60%60%0A%0A%23%23Schema%0A%60%60%60prisma%0A%2F%2FPLEASEADDYOURSCHEMAHEREIFPOSSIBLE%0A%60%60%60%0A%0A%23%23PrismaEngineQuery%0A%60%60%60%0AQUERY%0A%60%60%60%0A&title=Thisisatitle&template=bug_report.md\n\n      If you want the Prisma team to look into it, please open the link above 🙏\n      To increase the chance of success, please post your schema and a snippet of\n      how you used Prisma Client in the issue. \n      \"\n    `)\n  })","file":"errors.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"responds to panic GraphQL error with PrismaClientRustPanicError","suites":[],"updatePoint":{"line":92,"column":69},"line":92,"code":"test('responds to panic GraphQL error with PrismaClientRustPanicError', async () => {\n  const { engine, rustEngineMock } = setupMockLibraryEngine()\n\n  rustEngineMock.query.mockResolvedValue(\n    JSON.stringify({\n      errors: [panicError()],\n    }),\n  )\n\n  await expect(engine.request('query Foo { id }')).rejects.toBeInstanceOf(PrismaClientRustPanicError)\n})","file":"LibraryEngine.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"responds to panic GraphQL error with an error, containing github link","suites":[],"updatePoint":{"line":104,"column":75},"line":104,"code":"test('responds to panic GraphQL error with an error, containing github link', async () => {\n  const { engine, rustEngineMock } = setupMockLibraryEngine()\n\n  rustEngineMock.query.mockResolvedValue(\n    JSON.stringify({\n      errors: [panicError()],\n    }),\n  )\n\n  await expect(engine.request('query Foo { id }')).rejects.toMatchObject({\n    message: expect.stringContaining('https://github.com/prisma/prisma/issues'),\n  })\n})","file":"LibraryEngine.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"responds to panic exception with PrismaClientRustPanicError","suites":[],"updatePoint":{"line":118,"column":65},"line":118,"code":"test('responds to panic exception with PrismaClientRustPanicError', async () => {\n  const { engine, rustEngineMock } = setupMockLibraryEngine()\n\n  rustEngineMock.query.mockRejectedValue(panicException())\n\n  await expect(engine.request('query Foo { id }')).rejects.toBeInstanceOf(PrismaClientRustPanicError)\n})","file":"LibraryEngine.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"responds to panic exception with an error, containing github link","suites":[],"updatePoint":{"line":126,"column":71},"line":126,"code":"test('responds to panic exception with an error, containing github link', async () => {\n  const { engine, rustEngineMock } = setupMockLibraryEngine()\n\n  rustEngineMock.query.mockRejectedValue(panicException())\n\n  await expect(engine.request('query Foo { id }')).rejects.toMatchObject({\n    message: expect.stringContaining('https://github.com/prisma/prisma/issues'),\n  })\n})","file":"LibraryEngine.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"responds to known error with PrismaClientKnownRequestError","suites":[],"updatePoint":{"line":136,"column":64},"line":136,"code":"test('responds to known error with PrismaClientKnownRequestError', async () => {\n  const { engine, rustEngineMock } = setupMockLibraryEngine()\n\n  rustEngineMock.query.mockResolvedValue(\n    JSON.stringify({\n      errors: [knownError()],\n    }),\n  )\n\n  await expect(engine.request('query Foo { id }')).rejects.toBeInstanceOf(PrismaClientKnownRequestError)\n})","file":"LibraryEngine.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"responds to unknown error with PrismaClientUnknownRequestError","suites":[],"updatePoint":{"line":148,"column":68},"line":148,"code":"test('responds to unknown error with PrismaClientUnknownRequestError', async () => {\n  const { engine, rustEngineMock } = setupMockLibraryEngine()\n\n  rustEngineMock.query.mockResolvedValue(\n    JSON.stringify({\n      errors: [unknownError()],\n    }),\n  )\n\n  await expect(engine.request('query Foo { id }')).rejects.toBeInstanceOf(PrismaClientUnknownRequestError)\n})","file":"LibraryEngine.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"responds to a non panic error without github link","suites":[],"updatePoint":{"line":160,"column":55},"line":160,"code":"test('responds to a non panic error without github link', async () => {\n  const { engine, rustEngineMock } = setupMockLibraryEngine()\n\n  rustEngineMock.query.mockResolvedValue(\n    JSON.stringify({\n      errors: [knownError()],\n    }),\n  )\n\n  await expect(engine.request('query Foo { id }')).rejects.toMatchObject({\n    message: expect.not.stringContaining('https://github.com/'),\n  })\n})","file":"LibraryEngine.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"big query","suites":[],"updatePoint":{"line":3,"column":15},"line":3,"code":"test('big query', () => {\n  const query = `query {\n  users(\n    mirst: 100\n    skip: \"200\"\n    where: {\n      age_gt: -10\n      age_in: [1, 2, 3.123]\n      name_in: [\"hans\", \"peter\", \"schmidt\"]\n      OR: [\n        {\n          age_gt: 10123123123\n          email_endsWith: \"veryLongNameGoIntoaNewLineNow@gmail.com\"\n        },\n        {\n          age_gt: 10123123123\n          email_endsWith: \"veryLongNameGoIntoaNewLineNow@gmail.com\"\n          OR: [\n            {\n              age_gt: 10123123123\n              email_endsWith: \"veryLongNameGoIntoaNewLineNow@gmail.com\"\n            }\n          ]\n        }\n      ]\n    }\n  ) {\n    id\n    name2 # INVALID_FIELD\n    friends {\n      id\n      name\n    }\n    posts(first: 200) {\n      id\n      name\n    }\n  }\n}`\n\n  expect(maskQuery(query)).toMatchInlineSnapshot(`\n    \"query {\n      users(\n        mirst: 5\n        skip: \\\\\"X\\\\\"\n        where: {\n          age_gt: 5\n          age_in: [5, 5, 5]\n          name_in: [\\\\\"X\\\\\"]\n          OR: [\n            {\n              age_gt: 5\n              email_endsWith: \\\\\"X\\\\\"\n            },\n            {\n              age_gt: 5\n              email_endsWith: \\\\\"X\\\\\"\n              OR: [\n                {\n                  age_gt: 5\n                  email_endsWith: \\\\\"X\\\\\"\n                }\n              ]\n            }\n          ]\n        }\n      ) {\n        id\n        name2 # INVALID_FIELD\n        friends {\n          id\n          name\n        }\n        posts(first: 5) {\n          id\n          name\n        }\n      }\n    }\"\n  `)\n})","file":"maskQuery.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"aggregate","suites":[],"updatePoint":{"line":85,"column":15},"line":85,"code":"test('aggregate', () => {\n  const query = `query {\n    aggregateUser(take: 10) {\n      count {\n        _all\n      }\n    }\n  }`\n\n  expect(maskQuery(query)).toMatchInlineSnapshot(`\n    \"query {\n        aggregateUser(take: 5) {\n          count {\n            _all\n          }\n        }\n      }\"\n  `)\n})","file":"maskQuery.test.ts","skipped":false,"dir":"packages/engine-core/src/__tests__"},{"name":"minimal-executable","suites":["generatorHandler"],"updatePoint":{"line":84,"column":26},"line":84,"code":"  test('minimal-executable', async () => {\n    const generator = new GeneratorProcess(getExecutable('minimal-executable'))\n    await generator.init()\n    const manifest = await generator.getManifest(stubOptions.generator)\n    expect(manifest).toMatchInlineSnapshot(`\n      Object {\n        \"defaultOutput\": \"default-output\",\n        \"denylists\": Object {\n          \"models\": Array [\n            \"SomeForbiddenModel\",\n          ],\n        },\n        \"prettyName\": \"This is a pretty name\",\n        \"requiresEngines\": Array [\n          \"introspection-engine\",\n          \"query-engine\",\n        ],\n        \"requiresGenerators\": Array [\n          \"prisma-client-js\",\n        ],\n      }\n    `)\n    expect(() => generator.generate(stubOptions)).not.toThrow()\n\n    generator.stop()\n  })","file":"generatorHandler.test.ts","skipped":false,"dir":"packages/generator-helper/src/__tests__"},{"name":"failing-executable","suites":["generatorHandler"],"updatePoint":{"line":111,"column":26},"line":111,"code":"  test('failing-executable', async () => {\n    const generator = new GeneratorProcess(getExecutable('failing-executable'))\n    await generator.init()\n    await expect(generator.getManifest(stubOptions.generator)).rejects.toThrow()\n    await expect(generator.generate(stubOptions)).rejects.toThrow()\n    generator.stop()\n  })","file":"generatorHandler.test.ts","skipped":false,"dir":"packages/generator-helper/src/__tests__"},{"name":"nonexistent executable","suites":["generatorHandler"],"updatePoint":{"line":119,"column":30},"line":119,"code":"  test('nonexistent executable', async () => {\n    const generator = new GeneratorProcess(getExecutable('random path that doesnt exist'))\n    await expect(() => generator.init()).rejects.toThrow()\n  })","file":"generatorHandler.test.ts","skipped":false,"dir":"packages/generator-helper/src/__tests__"},{"name":"SQLite: should succeed","suites":["Baselining"],"updatePoint":{"line":30,"column":28},"line":30,"code":"  it('SQLite: should succeed', async () => {\n    ctx.fixture('baseline-sqlite')\n    fs.remove('prisma/migrations')\n    fs.copy('prisma/dev.db', 'prisma/prod.db')\n\n    // Start with the dev database\n    process.env.DATABASE_URL = 'file:./dev.db'\n\n    // db pull\n    const dbPull = DbPull.new().parse([])\n    await expect(dbPull).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n    `)\n    ctx.mocked['console.info'].mockReset()\n\n    // migrate dev --create-only\n    prompt.inject(['y'])\n    const migrateDevCreateOnly = MigrateDev.new().parse(['--create-only'])\n    await expect(migrateDevCreateOnly).resolves.toMatchInlineSnapshot(`\n      Prisma Migrate created the following migration without applying it 20201231000000_\n\n      You can now edit it and apply it by running prisma migrate dev.\n    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      Drift detected: Your database schema is not in sync with your migration history.\n\n      The following is a summary of the differences between the expected database schema given your migrations files, and the actual schema of the database.\n\n      It should be understood as the set of changes to get from the expected schema to the actual schema.\n\n      If you are running this the first time on an existing database, please make sure to read this documentation page:\n      https://www.prisma.io/docs/guides/database/developing-with-prisma-migrate/troubleshooting-development\n\n      [+] Added tables\n        - Blog\n\n\n    `)\n    ctx.mocked['console.info'].mockReset()\n\n    // migrate dev\n    const migrateDev = MigrateDev.new().parse([])\n    await expect(migrateDev).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    ctx.mocked['console.info'].mockReset()\n\n    // Switch to PROD database\n    process.env.DATABASE_URL = 'file:./prod.db'\n\n    // migrate resolve --applied migration_name\n    const migrationName = fs.list('prisma/migrations')![0]\n    const migrateResolveProd = MigrateResolve.new().parse(['--applied', migrationName])\n    await expect(migrateResolveProd).resolves.toMatchInlineSnapshot(`Migration 20201231000000_ marked as applied.`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"prod.db\" at \"file:./prod.db\"\n    `)\n    ctx.mocked['console.info'].mockReset()\n\n    // migrate deploy\n    const migrateDeployProd = MigrateDeploy.new().parse([])\n    await expect(migrateDeployProd).resolves.toMatchInlineSnapshot(`No pending migrations to apply.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"prod.db\" at \"file:./prod.db\"\n\n      1 migration found in prisma/migrations\n\n\n    `)\n\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"Baseline.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"no params should return help","suites":[],"updatePoint":{"line":4,"column":32},"line":4,"code":"it('no params should return help', async () => {\n  const commandInstance = DbCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse([])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"DbCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"wrong flag","suites":[],"updatePoint":{"line":13,"column":14},"line":13,"code":"it('wrong flag', async () => {\n  const commandInstance = DbCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse(['--something'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"DbCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"help flag","suites":[],"updatePoint":{"line":22,"column":13},"line":22,"code":"it('help flag', async () => {\n  const commandInstance = DbCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse(['--help'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"DbCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unknown command","suites":[],"updatePoint":{"line":31,"column":19},"line":31,"code":"it('unknown command', async () => {\n  await expect(DbCommand.new({}).parse(['doesnotexist'])).resolves.toThrowError()\n})","file":"DbCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"db seed with --preview-feature flag","suites":[],"updatePoint":{"line":35,"column":39},"line":35,"code":"it('db seed with --preview-feature flag', async () => {\n  await expect(\n    DbCommand.new({\n      dev: DbSeed.new(),\n    }).parse(['dev', '--preview-feature']),\n  ).rejects.toThrowError()\n})","file":"DbCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"db seed without --preview-feature flag","suites":[],"updatePoint":{"line":43,"column":42},"line":43,"code":"it('db seed without --preview-feature flag', async () => {\n  await expect(\n    DbCommand.new({\n      dev: DbSeed.new(),\n    }).parse(['dev']),\n  ).rejects.toThrowError()\n})","file":"DbCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"requires --preview-feature flag","suites":[],"updatePoint":{"line":12,"column":37},"line":12,"code":"  it('requires --preview-feature flag', async () => {\n    ctx.fixture('empty')\n\n    const result = DbDrop.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            This feature is currently in Preview. There may be bugs and it's not recommended to use it in production environments.\n            Please provide the --preview-feature flag to use this command.\n          `)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":[],"updatePoint":{"line":22,"column":35},"line":22,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n\n    const result = DbDrop.new().parse(['--preview-feature'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                      Could not find a schema.prisma file that is required for this command.\n                      You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n                  `)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"with missing db should fail (prompt)","suites":[],"updatePoint":{"line":32,"column":42},"line":32,"code":"  it('with missing db should fail (prompt)', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/dev.db')\n\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = DbDrop.new().parse(['--preview-feature'])\n    await expect(result).rejects.toMatchInlineSnapshot(`The database name entered \"y\" doesn't match \"dev.db\".`)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"with missing db should fail (--force)","suites":[],"updatePoint":{"line":43,"column":43},"line":43,"code":"  it('with missing db should fail (--force)', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/dev.db')\n\n    const result = DbDrop.new().parse(['--preview-feature', '--force'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      Migration engine error:\n      Failed to delete SQLite database at \\`dev.db\\`.\n      No such file or directory (os error 2)\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work (prompt)","suites":[],"updatePoint":{"line":57,"column":26},"line":57,"code":"  it('should work (prompt)', async () => {\n    ctx.fixture('reset')\n\n    prompt.inject(['dev.db']) // simulate user input\n\n    const result = DbDrop.new().parse(['--preview-feature'])\n    await expect(result).resolves.toMatchInlineSnapshot(`\n            🚀  The SQLite database \"dev.db\" from \"file:dev.db\" was successfully dropped.\n\n          `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work (--force)","suites":[],"updatePoint":{"line":76,"column":27},"line":76,"code":"  it('should work (--force)', async () => {\n    ctx.fixture('reset')\n\n    const result = DbDrop.new().parse(['--preview-feature', '--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(`\n            🚀  The SQLite database \"dev.db\" from \"file:dev.db\" was successfully dropped.\n\n          `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work (-f)","suites":[],"updatePoint":{"line":92,"column":22},"line":92,"code":"  it('should work (-f)', async () => {\n    ctx.fixture('reset')\n    const result = DbDrop.new().parse(['--preview-feature', '-f'])\n    await expect(result).resolves.toMatchInlineSnapshot(`\n            🚀  The SQLite database \"dev.db\" from \"file:dev.db\" was successfully dropped.\n\n          `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should be cancelled (prompt)","suites":[],"updatePoint":{"line":107,"column":34},"line":107,"code":"  it('should be cancelled (prompt)', async () => {\n    ctx.fixture('reset')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()]) // simulate cancel\n\n    const result = DbDrop.new().parse(['--preview-feature'])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Drop cancelled.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toBeCalledWith(130)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should ask for --force if not provided if CI","suites":[],"updatePoint":{"line":128,"column":50},"line":128,"code":"  it('should ask for --force if not provided if CI', async () => {\n    ctx.fixture('reset')\n    process.env.GITHUB_ACTIONS = '1'\n\n    const result = DbDrop.new().parse(['--preview-feature'])\n    await expect(result).rejects.toMatchInlineSnapshot(\n      `Use the --force flag to use the drop command in an unattended environment like prisma db drop --force --preview-feature`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbDrop.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should trigger a warning if --preview-feature is provided","suites":["db execute","generic"],"updatePoint":{"line":22,"column":65},"line":22,"code":"    it('should trigger a warning if --preview-feature is provided', async () => {\n      ctx.fixture('empty')\n      expect.assertions(3)\n\n      try {\n        await DbExecute.new().parse(['--preview-feature', '--file=./doesnotexists.sql', '--schema=1'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toMatchInlineSnapshot(`Provided --file at ./doesnotexists.sql doesn't exist.`)\n      }\n\n      expect(stripAnsi(ctx.mocked['console.warn'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n        prisma:warn \"prisma db execute\" was in Preview and is now Generally Available.\n        You can now remove the --preview-feature flag.\n      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if missing --file and --stdin","suites":["db execute","generic"],"updatePoint":{"line":39,"column":49},"line":39,"code":"    it('should fail if missing --file and --stdin', async () => {\n      ctx.fixture('empty')\n\n      const result = DbExecute.new().parse([])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                          Either --stdin or --file must be provided.\n                          See \\`prisma db execute -h\\`\n                      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if both --file and --stdin are provided","suites":["db execute","generic"],"updatePoint":{"line":49,"column":59},"line":49,"code":"    it('should fail if both --file and --stdin are provided', async () => {\n      ctx.fixture('empty')\n\n      const result = DbExecute.new().parse(['--file=1', '--stdin'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                          --stdin and --file cannot be used at the same time. Only 1 must be provided. \n                          See \\`prisma db execute -h\\`\n                      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if missing --schema and --url","suites":["db execute","generic"],"updatePoint":{"line":59,"column":49},"line":59,"code":"    it('should fail if missing --schema and --url', async () => {\n      ctx.fixture('empty')\n\n      const result = DbExecute.new().parse(['--file=1'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                          Either --url or --schema must be provided.\n                          See \\`prisma db execute -h\\`\n                      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if both --schema and --url are provided","suites":["db execute","generic"],"updatePoint":{"line":69,"column":59},"line":69,"code":"    it('should fail if both --schema and --url are provided', async () => {\n      ctx.fixture('empty')\n\n      const result = DbExecute.new().parse(['--stdin', '--schema=1', '--url=1'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                          --url and --schema cannot be used at the same time. Only 1 must be provided.\n                          See \\`prisma db execute -h\\`\n                      `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if --file does no exists","suites":["db execute","generic"],"updatePoint":{"line":79,"column":44},"line":79,"code":"    it('should fail if --file does no exists', async () => {\n      ctx.fixture('empty')\n      expect.assertions(2)\n\n      try {\n        await DbExecute.new().parse(['--file=./doesnotexists.sql', '--schema=1'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toMatchInlineSnapshot(`Provided --file at ./doesnotexists.sql doesn't exist.`)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if --schema does no exists","suites":["db execute","generic"],"updatePoint":{"line":91,"column":46},"line":91,"code":"    it('should fail if --schema does no exists', async () => {\n      ctx.fixture('empty')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--file=./script.sql', '--schema=./doesnoexists.schema'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toMatchInlineSnapshot(`Provided --schema at ./doesnoexists.schema doesn't exist.`)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with not supported error with --file --schema","suites":["db execute","mongodb"],"updatePoint":{"line":106,"column":65},"line":106,"code":"    it('should fail with not supported error with --file --schema', async () => {\n      ctx.fixture('schema-only-mongodb')\n\n      fs.writeFileSync('script.js', 'Something for MongoDB')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.js'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              dbExecute is not supported on MongoDB\n\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass if no schema file in directory with --file --url","suites":["db execute","sqlite"],"updatePoint":{"line":126,"column":68},"line":126,"code":"    it('should pass if no schema file in directory with --file --url', async () => {\n      ctx.fixture('empty')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url=file:./dev.db', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --schema","suites":["db execute","sqlite"],"updatePoint":{"line":153,"column":40},"line":153,"code":"    it('should pass with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass using a transaction with --file --schema","suites":["db execute","sqlite"],"updatePoint":{"line":161,"column":60},"line":161,"code":"    it('should pass using a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nBEGIN;\n\n${sqlScript}\n\n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url=file:dev.db","suites":["db execute","sqlite"],"updatePoint":{"line":178,"column":49},"line":178,"code":"    it('should pass with --file --url=file:dev.db', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url=file:dev.db', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with empty --file --url=file:dev.db","suites":["db execute","sqlite"],"updatePoint":{"line":186,"column":55},"line":186,"code":"    it('should pass with empty --file --url=file:dev.db', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      fs.writeFileSync('script.sql', '')\n      const result = DbExecute.new().parse(['--url=file:dev.db', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url with --file --url","suites":["db execute","sqlite"],"updatePoint":{"line":194,"column":71},"line":194,"code":"    it('should fail with P1013 error with invalid url with --file --url', async () => {\n      ctx.fixture('schema-only-sqlite')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--url=invalidurl', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. \\`invalidurl\\` is not a known connection URL scheme. Prisma cannot determine the connector. in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url=file:doesnotexists.db","suites":["db execute","sqlite"],"updatePoint":{"line":213,"column":59},"line":213,"code":"    it('should pass with --file --url=file:doesnotexists.db', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url=file:doesnotexists.db', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with --file --schema if there is a database error","suites":["db execute","sqlite"],"updatePoint":{"line":222,"column":69},"line":222,"code":"    it('should fail with --file --schema if there is a database error', async () => {\n      ctx.fixture('schema-only-sqlite')\n      expect.assertions(1)\n\n      fs.writeFileSync('script.sql', 'DROP TABLE \"test-doesnotexists\";')\n      try {\n        await DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.message).toMatchInlineSnapshot(`\n          SQLite database error\n          no such table: test-doesnotexists\n\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with invalid SQL error from database with --file --schema","suites":["db execute","sqlite"],"updatePoint":{"line":239,"column":77},"line":239,"code":"    it('should fail with invalid SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlite')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', 'ThisisnotSQL,itshouldfail')\n      try {\n        await DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toMatchInlineSnapshot(`\n          SQLite database error\n          near \"ThisisnotSQL\": syntax error\n\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":288,"column":40},"line":288,"code":"    it('should pass with --file --schema', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should use env var from .env file","suites":["db execute","postgresql"],"updatePoint":{"line":296,"column":41},"line":296,"code":"    it('should use env var from .env file', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/using-dotenv.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1001\n\n              Can't reach database server at \\`fromdotenvdoesnotexist\\`:\\`5432\\`\n\n              Please make sure your database server is running at \\`fromdotenvdoesnotexist\\`:\\`5432\\`.\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass using a transaction with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":311,"column":60},"line":311,"code":"    it('should pass using a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nBEGIN;\n\n${sqlScript}\n      \n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":328,"column":37},"line":328,"code":"    it('should pass with --file --url', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url', connectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with empty --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":336,"column":43},"line":336,"code":"    it('should pass with empty --file --url', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync('script.sql', '')\n      const result = DbExecute.new().parse(['--url', connectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if DROP DATABASE with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":348,"column":57},"line":348,"code":"    it('should fail if DROP DATABASE with --file --schema', async () => {\n      ctx.fixture('schema-only-postgresql')\n      expect.assertions(2)\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- Drop & Create & Drop\n      DROP DATABASE IF EXISTS \"test-dbexecute\";\n      CREATE DATABASE \"test-dbexecute\";\n      DROP DATABASE \"test-dbexecute\";`,\n      )\n      try {\n        await DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toContain('ERROR: DROP DATABASE cannot')\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":367,"column":71},"line":367,"code":"    it('should fail with P1013 error with invalid url with --file --url', async () => {\n      ctx.fixture('schema-only-postgresql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=postgresql://johndoe::::////::randompassword@doesnotexist/mydb',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. invalid port number in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url provider with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":387,"column":80},"line":387,"code":"    it('should fail with P1013 error with invalid url provider with --file --url', async () => {\n      ctx.fixture('schema-only-postgresql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--url=invalidurl', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. \\`invalidurl\\` is not a known connection URL scheme. Prisma cannot determine the connector. in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1001 error with unreachable url with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":405,"column":75},"line":405,"code":"    it('should fail with P1001 error with unreachable url with --file --url', async () => {\n      ctx.fixture('schema-only-postgresql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=postgresql://johndoe:randompassword@doesnotexist:5432/mydb?schema=public',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1001')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1001\n\n          Can't reach database server at \\`doesnotexist\\`:\\`5432\\`\n\n          Please make sure your database server is running at \\`doesnotexist\\`:\\`5432\\`.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1003 error with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":428,"column":57},"line":428,"code":"    it('should fail with P1003 error with --file --schema', async () => {\n      ctx.fixture('schema-only-postgresql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', 'DROP DATABASE \"test-doesnotexists\";')\n      try {\n        await DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1003')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1003\n\n          Database \\`test-doesnotexists\\` does not exist on the database server at \\`localhost:5432\\`.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with invalid SQL error from database with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":446,"column":77},"line":446,"code":"    it('should fail with invalid SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      fs.writeFileSync('script.sql', 'ThisisnotSQLitshouldfail')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              db error: ERROR: syntax error at or near \"ThisisnotSQLitshouldfail\"\n\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":490,"column":40},"line":490,"code":"    it('should pass with --file --schema', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    }, 10000)","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should use env var from .env file","suites":["db execute","postgresql"],"updatePoint":{"line":499,"column":41},"line":499,"code":"    it('should use env var from .env file', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/using-dotenv.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1001\n\n              Can't reach database server at \\`fromdotenvdoesnotexist\\`:\\`26257\\`\n\n              Please make sure your database server is running at \\`fromdotenvdoesnotexist\\`:\\`26257\\`.\n\n            `)\n    }, 10000)","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass using a transaction with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":515,"column":60},"line":515,"code":"    it('should pass using a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nBEGIN;\n\n${sqlScript}\n      \n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    }, 10000)","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":533,"column":37},"line":533,"code":"    it('should pass with --file --url', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url', connectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with empty --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":542,"column":43},"line":542,"code":"    it('should pass with empty --file --url', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync('script.sql', '')\n      const result = DbExecute.new().parse(['--url', connectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed if DROP DATABASE with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":552,"column":60},"line":552,"code":"    it('should succeed if DROP DATABASE with --file --schema', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n      expect.assertions(0)\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- Drop & Create & Drop\n      DROP DATABASE IF EXISTS \"test-dbexecute\";\n      CREATE DATABASE \"test-dbexecute\";\n      DROP DATABASE \"test-dbexecute\";`,\n      )\n      try {\n        await DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":571,"column":71},"line":571,"code":"    it('should fail with P1013 error with invalid url with --file --url', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=postgresql://johndoe::::////::randompassword@doesnotexist/mydb',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. invalid port number in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url provider with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":593,"column":80},"line":593,"code":"    it('should fail with P1013 error with invalid url provider with --file --url', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--url=invalidurl', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. \\`invalidurl\\` is not a known connection URL scheme. Prisma cannot determine the connector. in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1001 error with unreachable url with --file --url","suites":["db execute","postgresql"],"updatePoint":{"line":612,"column":75},"line":612,"code":"    it('should fail with P1001 error with unreachable url with --file --url', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=postgresql://johndoe:randompassword@doesnotexist:5432/mydb?schema=public',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1001')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1001\n\n          Can't reach database server at \\`doesnotexist\\`:\\`5432\\`\n\n          Please make sure your database server is running at \\`doesnotexist\\`:\\`5432\\`.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with invalid SQL error from database with --file --schema","suites":["db execute","postgresql"],"updatePoint":{"line":636,"column":77},"line":636,"code":"    it('should fail with invalid SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      fs.writeFileSync('script.sql', 'ThisisnotSQLitshouldfail')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              db error: ERROR: at or near \"thisisnotsqlitshouldfail\": syntax error\n              DETAIL: source SQL:\n              ThisisnotSQLitshouldfail\n              ^\n\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":682,"column":40},"line":682,"code":"    it('should pass with --file --schema', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with empty --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":691,"column":46},"line":691,"code":"    it('should fail with empty --file --schema', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync('script.sql', '')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              Query was empty\n\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass using a transaction with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":703,"column":60},"line":703,"code":"    it('should pass using a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nSTART TRANSACTION;\n\n${sqlScript}\n      \n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":720,"column":37},"line":720,"code":"    it('should pass with --file --url', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url', connectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":728,"column":71},"line":728,"code":"    it('should fail with P1013 error with invalid url with --file --url', async () => {\n      ctx.fixture('schema-only-mysql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=mysql://johndoe::::////::randompassword@doesnotexist:3306/mydb',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. invalid port number in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url provider with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":748,"column":80},"line":748,"code":"    it('should fail with P1013 error with invalid url provider with --file --url', async () => {\n      ctx.fixture('schema-only-mysql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--url=invalidurl', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. \\`invalidurl\\` is not a known connection URL scheme. Prisma cannot determine the connector. in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1001 error with unreachable url with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":766,"column":75},"line":766,"code":"    it('should fail with P1001 error with unreachable url with --file --url', async () => {\n      ctx.fixture('schema-only-mysql')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=mysql://johndoe:randompassword@doesnotexist:3306/mydb',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1001')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1001\n\n          Can't reach database server at \\`doesnotexist\\`:\\`3306\\`\n\n          Please make sure your database server is running at \\`doesnotexist\\`:\\`3306\\`.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with SQL error from database with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":789,"column":69},"line":789,"code":"    it('should fail with SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync('script.sql', 'DROP DATABASE `test-doesnotexists`;')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              Can't drop database 'test-doesnotexists'; database doesn't exist\n\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with invalid SQL error from database with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":801,"column":77},"line":801,"code":"    it('should fail with invalid SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      fs.writeFileSync('script.sql', 'This is not SQL, it should fail')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'This is not SQL, it should fail' at line 1\n\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":846,"column":40},"line":846,"code":"    it('should pass with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with empty --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":854,"column":46},"line":854,"code":"    it('should pass with empty --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync('script.sql', '')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":863,"column":37},"line":863,"code":"    it('should pass with --file --url', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync('script.sql', sqlScript)\n      const result = DbExecute.new().parse(['--url', jdbcConnectionString, '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass using a transaction with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":872,"column":60},"line":872,"code":"    it('should pass using a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nBEGIN TRANSACTION;\n\nSELECT 1\n      \n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).resolves.toMatchInlineSnapshot(`Script executed successfully.`)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if DROP DATABASE in a transaction with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":892,"column":74},"line":892,"code":"    it('should fail if DROP DATABASE in a transaction with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync(\n        'script.sql',\n        `-- start a transaction\nBEGIN TRANSACTION;\n\n${sqlScript}\n      \n-- commit changes    \nCOMMIT;`,\n      )\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              DROP DATABASE statement cannot be used inside a user transaction.\n\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":914,"column":71},"line":914,"code":"    it('should fail with P1013 error with invalid url with --file --url', async () => {\n      ctx.fixture('schema-only-sqlserver')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=sqlserver://doesnotexist:1433;;;;database=tests-migrate;user=SA;password=Pr1sm4_Pr1sm4;trustServerCertificate=true;',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. Error parsing connection string: Conversion error: Invalid property key in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1013 error with invalid url provider with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":936,"column":80},"line":936,"code":"    it('should fail with P1013 error with invalid url provider with --file --url', async () => {\n      ctx.fixture('schema-only-sqlserver')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse(['--url=invalidurl', '--file=./script.sql'])\n      } catch (e) {\n        expect(e.code).toEqual('P1013')\n        expect(e.message).toMatchInlineSnapshot(`\n          P1013\n\n          The provided database string is invalid. \\`invalidurl\\` is not a known connection URL scheme. Prisma cannot determine the connector. in database URL. Please refer to the documentation in https://www.prisma.io/docs/reference/database-reference/connection-urls for constructing a correct connection string. In some cases, certain characters must be escaped. Please check the string for any illegal characters.\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with P1001 error with unreachable url with --file --url","suites":["db execute","mysql"],"updatePoint":{"line":955,"column":75},"line":955,"code":"    it('should fail with P1001 error with unreachable url with --file --url', async () => {\n      ctx.fixture('schema-only-sqlserver')\n      expect.assertions(2)\n\n      fs.writeFileSync('script.sql', '-- empty')\n      try {\n        await DbExecute.new().parse([\n          '--url=sqlserver://doesnotexist:1433;database=tests-migrate;user=SA;password=Pr1sm4_Pr1sm4;trustServerCertificate=true;',\n          '--file=./script.sql',\n        ])\n      } catch (e) {\n        // It should error with P1001 but code is undefined\n        // Tracked in following issue:\n        // https://github.com/prisma/prisma/issues/11407\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toMatchInlineSnapshot(`\n          Error creating a database connection.\n\n\n        `)\n      }\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with SQL error from database with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":979,"column":69},"line":979,"code":"    it('should fail with SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync('script.sql', 'DROP DATABASE \"test-doesnotexists\";')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              Cannot drop the database 'test-doesnotexists', because it does not exist or you do not have permission.\n\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with invalid SQL error from database with --file --schema","suites":["db execute","mysql"],"updatePoint":{"line":992,"column":77},"line":992,"code":"    it('should fail with invalid SQL error from database with --file --schema', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      fs.writeFileSync('script.sql', 'ThisisnotSQLitshouldfail')\n      const result = DbExecute.new().parse(['--schema=./prisma/schema.prisma', '--file=./script.sql'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              Could not find stored procedure 'ThisisnotSQLitshouldfail'.\n\n\n            `)\n    })","file":"DbExecute.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":["common/sqlite"],"updatePoint":{"line":44,"column":27},"line":44,"code":"  test('basic introspection', async () => {\n    ctx.fixture('introspection/sqlite')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --force","suites":["common/sqlite"],"updatePoint":{"line":56,"column":29},"line":56,"code":"  test('introspection --force', async () => {\n    ctx.fixture('introspection/sqlite')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection with invalid --url if schema is unspecified","suites":["common/sqlite"],"updatePoint":{"line":84,"column":71},"line":84,"code":"  test('basic introspection with invalid --url if schema is unspecified', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', 'invalidstring'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`Unknown protocol invalidstring:`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed when schema and db do match","suites":["common/sqlite"],"updatePoint":{"line":95,"column":48},"line":95,"code":"  it('should succeed when schema and db do match', async () => {\n    ctx.fixture('introspect/prisma')\n    const result = DbPull.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n').replace(/\\d{2,3}ms/, 'XXms')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      \n      \n      - Introspecting based on datasource defined in schema.prisma\n      \n      ✔ Introspected 3 models and wrote them into schema.prisma in XXXms\n            \n      Run prisma generate to generate Prisma Client.\n      \n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection with invalid --url - empty host","suites":["common/sqlite"],"updatePoint":{"line":145,"column":59},"line":145,"code":"  test('basic introspection with invalid --url - empty host', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', 'postgresql://root:prisma@/prisma'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Error parsing connection string: empty host in database URL\n\n          `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed and keep changes to valid schema and output warnings","suites":["common/sqlite"],"updatePoint":{"line":159,"column":73},"line":159,"code":"  it('should succeed and keep changes to valid schema and output warnings', async () => {\n    ctx.fixture('introspect')\n    const result = DbPull.new().parse(['--schema=./prisma/reintrospection.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n').replace(/\\d{2,3}ms/, 'in XXms')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/reintrospection.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n      - Introspecting based on datasource defined in prisma/reintrospection.prisma\n\n      ✔ Introspected 3 models and wrote them into prisma/reintrospection.prisma in XXXms\n            \n      *** WARNING ***\n\n      These models were enriched with \\`@@map\\` information taken from the previous Prisma schema.\n      - Model \"AwesomeNewPost\"\n      - Model \"AwesomeProfile\"\n      - Model \"AwesomeUser\"\n\n      Run prisma generate to generate Prisma Client.\n\n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n\n    expect(ctx.fs.read('prisma/reintrospection.prisma')).toMatchInlineSnapshot(`\n      generator client {\n        provider = \"prisma-client-js\"\n        output   = \"../generated/client\"\n      }\n\n      datasource db {\n        provider = \"sqlite\"\n        url      = \"file:dev.db\"\n      }\n\n      model AwesomeUser {\n        email    String           @unique(map: \"User.email\")\n        id       Int              @id @default(autoincrement())\n        name     String?\n        newPosts AwesomeNewPost[]\n        profile  AwesomeProfile?\n\n        @@map(\"User\")\n      }\n\n      model AwesomeNewPost {\n        authorId  Int\n        content   String?\n        createdAt DateTime    @default(now())\n        id        Int         @id @default(autoincrement())\n        published Boolean     @default(false)\n        title     String\n        author    AwesomeUser @relation(fields: [authorId], references: [id], onDelete: Cascade)\n\n        @@map(\"Post\")\n      }\n\n      model AwesomeProfile {\n        bio    String?\n        id     Int         @id @default(autoincrement())\n        userId Int         @unique(map: \"Profile.userId\")\n        user   AwesomeUser @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n        @@map(\"Profile\")\n      }\n\n    `)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed and keep changes to valid schema and output warnings when using --print","suites":["common/sqlite"],"updatePoint":{"line":234,"column":92},"line":234,"code":"  it('should succeed and keep changes to valid schema and output warnings when using --print', async () => {\n    ctx.fixture('introspect')\n    const originalSchema = ctx.fs.read('prisma/reintrospection.prisma')\n    const result = DbPull.new().parse(['--print', '--schema=./prisma/reintrospection.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n').replace(/\\d{2,3}ms/, 'in XXms')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n      // *** WARNING ***\n      // \n      // These models were enriched with \\`@@map\\` information taken from the previous Prisma schema.\n      // - Model \"AwesomeNewPost\"\n      // - Model \"AwesomeProfile\"\n      // - Model \"AwesomeUser\"\n      // \n    `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n\n    expect(ctx.fs.read('prisma/reintrospection.prisma')).toStrictEqual(originalSchema)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed when schema and db do not match","suites":["common/sqlite"],"updatePoint":{"line":257,"column":52},"line":257,"code":"  it('should succeed when schema and db do not match', async () => {\n    ctx.fixture('existing-db-histories-diverge')\n    const result = DbPull.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n').replace(/\\d{2,3}ms/, 'in XXms')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      \n      \n      - Introspecting based on datasource defined in prisma/schema.prisma\n      \n      ✔ Introspected 3 models and wrote them into prisma/schema.prisma in XXXms\n            \n      Run prisma generate to generate Prisma Client.\n      \n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail when db is missing","suites":["common/sqlite"],"updatePoint":{"line":280,"column":36},"line":280,"code":"  it('should fail when db is missing', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = DbPull.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n      P4001 The introspected database was empty: \n\n      prisma db pull could not create any models in your schema.prisma file and you will not be able to generate Prisma Client with the prisma generate command.\n\n      To fix this, you have two options:\n\n      - manually create a table in your database.\n      - make sure the database connection URL inside the datasource block in schema.prisma points to a database that is not empty (it must contain at least one table).\n\n      Then you can run prisma db pull again. \n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      \n      \n      - Introspecting based on datasource defined in prisma/schema.prisma\n\n      ✖ Introspecting based on datasource defined in prisma/schema.prisma\n      \n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail when db is empty","suites":["common/sqlite"],"updatePoint":{"line":314,"column":34},"line":314,"code":"  it('should fail when db is empty', async () => {\n    ctx.fixture('schema-only-sqlite')\n    ctx.fs.write('prisma/dev.db', '')\n    const result = DbPull.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n\n      P4001 The introspected database was empty: \n\n      prisma db pull could not create any models in your schema.prisma file and you will not be able to generate Prisma Client with the prisma generate command.\n\n      To fix this, you have two options:\n\n      - manually create a table in your database.\n      - make sure the database connection URL inside the datasource block in schema.prisma points to a database that is not empty (it must contain at least one table).\n\n      Then you can run prisma db pull again. \n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      \n      \n      - Introspecting based on datasource defined in prisma/schema.prisma\n\n      ✖ Introspecting based on datasource defined in prisma/schema.prisma\n      \n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail when Prisma schema is missing","suites":["common/sqlite"],"updatePoint":{"line":349,"column":47},"line":349,"code":"  it('should fail when Prisma schema is missing', async () => {\n    const result = DbPull.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                      Could not find a schema.prisma file that is required for this command.\n                      You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n                  `)\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail when schema is invalid","suites":["common/sqlite"],"updatePoint":{"line":363,"column":40},"line":363,"code":"  it('should fail when schema is invalid', async () => {\n    ctx.fixture('introspect')\n    const result = DbPull.new().parse(['--schema=./prisma/invalid.prisma'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P1012 Introspection failed as your current Prisma schema file is invalid\n\n            Please fix your current schema manually, use prisma validate to confirm it is valid and then run this command again.\n            Or run this command with the --force flag to ignore your current schema and overwrite it. All local modifications will be lost.\n\n          `)\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/invalid.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      \n      \n      - Introspecting based on datasource defined in prisma/invalid.prisma\n\n      ✖ Introspecting based on datasource defined in prisma/invalid.prisma\n      \n    `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should succeed when schema is invalid and using --force","suites":["common/sqlite"],"updatePoint":{"line":392,"column":61},"line":392,"code":"  it('should succeed when schema is invalid and using --force', async () => {\n    ctx.fixture('introspect')\n\n    const result = DbPull.new().parse(['--schema=./prisma/invalid.prisma', '--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n').replace(/\\d{2,3}ms/, 'in XXms')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/invalid.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n                                    - Introspecting based on datasource defined in prisma/invalid.prisma\n\n                                    ✔ Introspected 3 models and wrote them into prisma/invalid.prisma in XXXms\n                                          \n                                    Run prisma generate to generate Prisma Client.\n\n                        `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n\n    expect(ctx.fs.read('prisma/invalid.prisma')).toMatchSnapshot()\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":["postgresql"],"updatePoint":{"line":444,"column":27},"line":444,"code":"  test('basic introspection', async () => {\n    ctx.fixture('introspection/postgresql')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection --url","suites":["postgresql"],"updatePoint":{"line":456,"column":33},"line":456,"code":"  test('basic introspection --url', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', setupParams.connectionString])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection should load .env file with --print","suites":["postgresql"],"updatePoint":{"line":467,"column":56},"line":467,"code":"  test('introspection should load .env file with --print', async () => {\n    ctx.fixture('schema-only-postgresql')\n    expect.assertions(7)\n\n    try {\n      await DbPull.new().parse(['--print', '--schema=./prisma/using-dotenv.prisma'])\n    } catch (e) {\n      expect(e.code).toEqual('P1001')\n      expect(e.message).toContain(`fromdotenvdoesnotexist`)\n    }\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection should load .env file without --print","suites":["postgresql"],"updatePoint":{"line":485,"column":59},"line":485,"code":"  test('introspection should load .env file without --print', async () => {\n    ctx.fixture('schema-only-postgresql')\n    expect.assertions(7)\n\n    try {\n      await DbPull.new().parse(['--schema=./prisma/using-dotenv.prisma'])\n    } catch (e) {\n      expect(e.code).toEqual('P1001')\n      expect(e.message).toContain(`fromdotenvdoesnotexist`)\n    }\n\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/using-dotenv.prisma\n      Environment variables loaded from prisma/.env\n      Datasource \"my_db\": PostgreSQL database \"mydb\", schema \"public\" at \"fromdotenvdoesnotexist:5432\"\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n                                    - Introspecting based on datasource defined in prisma/using-dotenv.prisma\n\n                                    ✖ Introspecting based on datasource defined in prisma/using-dotenv.prisma\n\n                                                        `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"without datasource property `schemas` it should error with P4001, empty database","suites":["postgresql"],"updatePoint":{"line":549,"column":88},"line":549,"code":"  test('without datasource property `schemas` it should error with P4001, empty database', async () => {\n    ctx.fixture('introspection/sqlserver-multi-schema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'without-schemas-in-datasource.prisma'])\n    await expect(result).rejects.toThrowError(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[]` should error with P1012, array can not be empty","suites":["postgresql"],"updatePoint":{"line":561,"column":88},"line":561,"code":"  test('datasource property `schemas=[]` should error with P1012, array can not be empty', async () => {\n    ctx.fixture('introspection/sqlserver-multi-schema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-0-value.prisma'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      Schema validation error - Error (get-config wasm)\n      Error code: P1012\n      error: If provided, the schemas array can not be empty.\n        -->  schema.prisma:4\n         | \n       3 |   url      = env(\"TEST_MSSQL_JDBC_URI_MIGRATE\")\n       4 |   schemas  = []\n         | \n\n      Validation Error Count: 1\n      [Context: getConfig]\n\n      Prisma CLI Version : 0.0.0\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"base\", \"transactional\"]` should succeed","suites":["postgresql"],"updatePoint":{"line":587,"column":78},"line":587,"code":"  test('datasource property `schemas=[\"base\", \"transactional\"]` should succeed', async () => {\n    ctx.fixture('introspection/sqlserver-multi-schema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-2-values.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(sanitizeSQLServerIdName(ctx.mocked['console.log'].mock.calls.join('\\n'))).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"base\"]` should succeed","suites":["postgresql"],"updatePoint":{"line":599,"column":61},"line":599,"code":"  test('datasource property `schemas=[\"base\"]` should succeed', async () => {\n    ctx.fixture('introspection/sqlserver-multi-schema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-1-value.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(sanitizeSQLServerIdName(ctx.mocked['console.log'].mock.calls.join('\\n'))).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"does-not-exist\"]` should error with P4001, empty database","suites":["postgresql"],"updatePoint":{"line":611,"column":96},"line":611,"code":"  test('datasource property `schemas=[\"does-not-exist\"]` should error with P4001, empty database', async () => {\n    ctx.fixture('introspection/sqlserver-multi-schema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-1-non-existing-value.prisma'])\n    await expect(result).rejects.toThrowError(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"does-not-exist\", \"base\"]` should succeed","suites":["postgresql"],"updatePoint":{"line":623,"column":79},"line":623,"code":"  test('datasource property `schemas=[\"does-not-exist\", \"base\"]` should succeed', async () => {\n    ctx.fixture('introspection/sqlserver-multi-schema')\n    const introspect = new DbPull()\n    const result = introspect.parse([\n      '--print',\n      '--schema',\n      'with-schemas-in-datasource-1-existing-1-non-existing-value.prisma',\n    ])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(sanitizeSQLServerIdName(ctx.mocked['console.log'].mock.calls.join('\\n'))).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url with `?schema=does-not-exist` should error with with P4001, empty database","suites":["postgresql"],"updatePoint":{"line":639,"column":88},"line":639,"code":"  test('--url with `?schema=does-not-exist` should error with with P4001, empty database', async () => {\n    const introspect = new DbPull()\n    const connectionString = `${process.env.TEST_MSSQL_JDBC_URI_MIGRATE}schema=does-not-exist`\n    const result = introspect.parse(['--print', '--url', connectionString])\n    await expect(result).rejects.toThrowError(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url with `?schema=base` should succeed","suites":["postgresql"],"updatePoint":{"line":651,"column":48},"line":651,"code":"  test('--url with `?schema=base` should succeed', async () => {\n    const introspect = new DbPull()\n    const connectionString = `${process.env.TEST_MSSQL_JDBC_URI_MIGRATE}schema=base`\n    const result = introspect.parse(['--print', '--url', connectionString])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(sanitizeSQLServerIdName(ctx.mocked['console.log'].mock.calls.join('\\n'))).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"without datasource property `schemas` it should error with P4001, empty database","suites":["postgresql-multi-schema"],"updatePoint":{"line":688,"column":88},"line":688,"code":"  test('without datasource property `schemas` it should error with P4001, empty database', async () => {\n    ctx.fixture('introspection/postgresql-multi-schema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'without-schemas-in-datasource.prisma'])\n    await expect(result).rejects.toThrowError(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[]` should error with P1012, array can not be empty","suites":["postgresql-multi-schema"],"updatePoint":{"line":700,"column":88},"line":700,"code":"  test('datasource property `schemas=[]` should error with P1012, array can not be empty', async () => {\n    ctx.fixture('introspection/postgresql-multi-schema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-0-value.prisma'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      Schema validation error - Error (get-config wasm)\n      Error code: P1012\n      error: If provided, the schemas array can not be empty.\n        -->  schema.prisma:4\n         | \n       3 |   url      = env(\"TEST_POSTGRES_URI_MIGRATE\")\n       4 |   schemas  = []\n         | \n\n      Validation Error Count: 1\n      [Context: getConfig]\n\n      Prisma CLI Version : 0.0.0\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"base\"]` should succeed","suites":["postgresql-multi-schema"],"updatePoint":{"line":738,"column":61},"line":738,"code":"  test('datasource property `schemas=[\"base\"]` should succeed', async () => {\n    ctx.fixture('introspection/postgresql-multi-schema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-1-value.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"does-not-exist\"]` should error with P4001, empty database","suites":["postgresql-multi-schema"],"updatePoint":{"line":750,"column":96},"line":750,"code":"  test('datasource property `schemas=[\"does-not-exist\"]` should error with P4001, empty database', async () => {\n    ctx.fixture('introspection/postgresql-multi-schema')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'with-schemas-in-datasource-1-non-existing-value.prisma'])\n    await expect(result).rejects.toThrowError(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"datasource property `schemas=[\"does-not-exist\", \"base\"]` should succeed","suites":["postgresql-multi-schema"],"updatePoint":{"line":762,"column":79},"line":762,"code":"  test('datasource property `schemas=[\"does-not-exist\", \"base\"]` should succeed', async () => {\n    ctx.fixture('introspection/postgresql-multi-schema')\n    const introspect = new DbPull()\n    const result = introspect.parse([\n      '--print',\n      '--schema',\n      'with-schemas-in-datasource-1-existing-1-non-existing-value.prisma',\n    ])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url with `?schema=does-not-exist` should error with with P4001, empty database","suites":["postgresql-multi-schema"],"updatePoint":{"line":778,"column":88},"line":778,"code":"  test('--url with `?schema=does-not-exist` should error with with P4001, empty database', async () => {\n    const introspect = new DbPull()\n    // postgres://prisma:prisma@localhost:5432/tests-migrate?schema=does-not-exist\n    const connectionString = `${setupParams.connectionString}?schema=does-not-exist`\n    const result = introspect.parse(['--print', '--url', connectionString])\n    await expect(result).rejects.toThrowError(`P4001`)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--url with `?schema=base` should succeed","suites":["postgresql-multi-schema"],"updatePoint":{"line":791,"column":48},"line":791,"code":"  test('--url with `?schema=base` should succeed', async () => {\n    const introspect = new DbPull()\n    // postgres://prisma:prisma@localhost:5432/tests-migrate?schema=base\n    const connectionString = `${setupParams.connectionString}?schema=base`\n    const result = introspect.parse(['--print', '--url', connectionString])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection should succeed and add extensions property to the schema.prisma file","suites":["postgresql-extensions"],"updatePoint":{"line":829,"column":90},"line":829,"code":"  test('introspection should succeed and add extensions property to the schema.prisma file', async () => {\n    ctx.fixture('introspection/postgresql-extensions')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'schema.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    const introspectedSchema = ctx.mocked['console.log'].mock.calls.join('\\n')\n    expect(introspectedSchema).toMatchInlineSnapshot(`\n      generator client {\n        provider        = \"prisma-client-js\"\n        previewFeatures = [\"postgresqlExtensions\"]\n      }\n\n      datasource db {\n        provider   = \"postgresql\"\n        url        = env(\"TEST_POSTGRES_URI_MIGRATE\")\n        extensions = [citext(schema: \"public\")]\n      }\n\n      model Post {\n        id        String    @id\n        createdAt DateTime  @default(now())\n        updatedAt DateTime  @default(dbgenerated(\"'1970-01-01 00:00:00'::timestamp without time zone\"))\n        published Boolean   @default(false)\n        title     String\n        content   String?\n        authorId  String?\n        jsonData  Json?\n        coinflips Boolean[]\n        User      User?     @relation(fields: [authorId], references: [id])\n      }\n\n      model User {\n        id    String  @id\n        email String  @unique(map: \"User.email\")\n        name  String?\n        Post  Post[]\n      }\n\n      enum Role {\n        USER\n        ADMIN\n      }\n\n\n      // introspectionSchemaVersion: NonPrisma,\n    `)\n    expect(introspectedSchema).toContain('[citext(schema:')\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"re-introspection should succeed and keep defined extension in schema.prisma file","suites":["postgresql-extensions"],"updatePoint":{"line":882,"column":88},"line":882,"code":"  test('re-introspection should succeed and keep defined extension in schema.prisma file', async () => {\n    ctx.fixture('introspection/postgresql-extensions')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--schema', 'schema-extensions-citext.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    const introspectedSchema = ctx.mocked['console.log'].mock.calls.join('\\n')\n    expect(introspectedSchema).toMatchInlineSnapshot(`\n      generator client {\n        provider        = \"prisma-client-js\"\n        previewFeatures = [\"postgresqlExtensions\"]\n      }\n\n      datasource db {\n        provider   = \"postgresql\"\n        url        = env(\"TEST_POSTGRES_URI_MIGRATE\")\n        extensions = [citext(schema: \"public\")]\n      }\n\n      model Post {\n        id        String    @id\n        createdAt DateTime  @default(now())\n        updatedAt DateTime  @default(dbgenerated(\"'1970-01-01 00:00:00'::timestamp without time zone\"))\n        published Boolean   @default(false)\n        title     String\n        content   String?\n        authorId  String?\n        jsonData  Json?\n        coinflips Boolean[]\n        User      User?     @relation(fields: [authorId], references: [id])\n      }\n\n      model User {\n        id    String  @id\n        email String  @unique(map: \"User.email\")\n        name  String?\n        Post  Post[]\n      }\n\n      enum Role {\n        USER\n        ADMIN\n      }\n\n\n      // introspectionSchemaVersion: NonPrisma,\n    `)\n    expect(introspectedSchema).toContain('[citext(schema:')\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection (with cockroachdb schema)","suites":["postgresql-extensions"],"updatePoint":{"line":969,"column":53},"line":969,"code":"  test('basic introspection (with cockroachdb schema)', async () => {\n    await testSetup('cockroachdb', { withFixture: true })\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection (with cockroachdb schema, cockroachdb native types)","suites":["postgresql-extensions"],"updatePoint":{"line":979,"column":79},"line":979,"code":"  test('basic introspection (with cockroachdb schema, cockroachdb native types)', async () => {\n    await testSetup('nativeTypes-cockroachdb', { withFixture: true })\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection (with postgresql schema)","suites":["postgresql-extensions"],"updatePoint":{"line":989,"column":52},"line":989,"code":"  test('basic introspection (with postgresql schema)', async () => {\n    await testSetup('cockroachdb-with-postgresql-provider', { withFixture: true })\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection (with postgresql schema, cockroachdb native types)","suites":["postgresql-extensions"],"updatePoint":{"line":999,"column":78},"line":999,"code":"  test('basic introspection (with postgresql schema, cockroachdb native types)', async () => {\n    await testSetup('nativeTypes-cockroachdb-with-postgresql-provider', { withFixture: true })\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection (no schema) --url","suites":["postgresql-extensions"],"updatePoint":{"line":1009,"column":45},"line":1009,"code":"  test('basic introspection (no schema) --url', async () => {\n    await testSetup('cockroachdb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', defaultParams.connectionString])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":["mysql"],"updatePoint":{"line":1075,"column":27},"line":1075,"code":"  test('basic introspection', async () => {\n    ctx.fixture('introspection/mysql')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":["mysql"],"updatePoint":{"line":1130,"column":27},"line":1130,"code":"  test('basic introspection', async () => {\n    ctx.fixture('introspection/sqlserver')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection --url","suites":["mysql"],"updatePoint":{"line":1142,"column":33},"line":1142,"code":"  test('basic introspection --url', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', JDBC_URI])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection","suites":["mysql"],"updatePoint":{"line":1161,"column":27},"line":1161,"code":"  test('basic introspection', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--schema=./prisma/no-model.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/no-model.prisma\n      Datasource \"my_db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n                                  - Introspecting based on datasource defined in prisma/no-model.prisma\n\n                                  ✔ Introspected 1 model and 2 embedded documents and wrote them into prisma/no-model.prisma in XXXms\n                                        \n                                  *** WARNING ***\n                                  \n                                  The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type.\n                                  - Model \"users\", field: \"numberOrString1\", chosen data type: \"Json\"\n                                  - Type \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                                  - Type \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n\n                                  Run prisma generate to generate Prisma Client.\n\n                      `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --force (existing models)","suites":["mysql"],"updatePoint":{"line":1192,"column":47},"line":1192,"code":"  test('introspection --force (existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n                                    - Introspecting based on datasource defined in prisma/schema.prisma\n\n                                    ✔ Introspected 1 model and 2 embedded documents and wrote them into prisma/schema.prisma in XXXms\n                                          \n                                    *** WARNING ***\n                                    \n                                    The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type.\n                                    - Model \"users\", field: \"numberOrString1\", chosen data type: \"Json\"\n                                    - Type \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                                    - Type \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n\n                                    Run prisma generate to generate Prisma Client.\n\n                        `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --print (no existing models)","suites":["mysql"],"updatePoint":{"line":1223,"column":50},"line":1223,"code":"  test('introspection --print (no existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--schema=./prisma/no-model.prisma', '--print'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      generator client {\n        provider = \"prisma-client-js\"\n      }\n\n      datasource my_db {\n        provider = \"mongodb\"\n        url      = env(\"TEST_MONGO_URI_MIGRATE\")\n      }\n\n      type UsersHobbies {\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString2 Json?\n        objects         UsersHobbiesObjects[]\n        tags            String[]\n      }\n\n      type UsersHobbiesObjects {\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString3 Json\n        tags            String[]\n      }\n\n      model users {\n        id              String         @id @default(auto()) @map(\"_id\") @my_db.ObjectId\n        admin           Boolean\n        email           String\n        hobbies         UsersHobbies[]\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString1 Json\n      }\n\n\n      // introspectionSchemaVersion: NonPrisma,\n    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                    // *** WARNING ***\n                                    // \n                                    // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type.\n                                    // - Model \"users\", field: \"numberOrString1\", chosen data type: \"Json\"\n                                    // - Type \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                                    // - Type \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n                                    // \n                        `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --print --composite-type-depth=0 (no existing models)","suites":["mysql"],"updatePoint":{"line":1281,"column":75},"line":1281,"code":"  test('introspection --print --composite-type-depth=0 (no existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--schema=./prisma/no-model.prisma', '--print', '--composite-type-depth=0'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      generator client {\n        provider = \"prisma-client-js\"\n      }\n\n      datasource my_db {\n        provider = \"mongodb\"\n        url      = env(\"TEST_MONGO_URI_MIGRATE\")\n      }\n\n      model users {\n        id              String  @id @default(auto()) @map(\"_id\") @my_db.ObjectId\n        admin           Boolean\n        email           String\n        hobbies         Json[]\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString1 Json\n      }\n\n\n      // introspectionSchemaVersion: NonPrisma,\n    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                    // *** WARNING ***\n                                    // \n                                    // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type.\n                                    // - Model \"users\", field: \"numberOrString1\", chosen data type: \"Json\"\n                                    // \n                        `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --print --composite-type-depth=1 (no existing models)","suites":["mysql"],"updatePoint":{"line":1322,"column":75},"line":1322,"code":"  test('introspection --print --composite-type-depth=1 (no existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--schema=./prisma/no-model.prisma', '--print', '--composite-type-depth=1'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      generator client {\n        provider = \"prisma-client-js\"\n      }\n\n      datasource my_db {\n        provider = \"mongodb\"\n        url      = env(\"TEST_MONGO_URI_MIGRATE\")\n      }\n\n      type UsersHobbies {\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString2 Json?\n        objects         Json[]\n        tags            String[]\n      }\n\n      model users {\n        id              String         @id @default(auto()) @map(\"_id\") @my_db.ObjectId\n        admin           Boolean\n        email           String\n        hobbies         UsersHobbies[]\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString1 Json\n      }\n\n\n      // introspectionSchemaVersion: NonPrisma,\n    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                    // *** WARNING ***\n                                    // \n                                    // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type.\n                                    // - Model \"users\", field: \"numberOrString1\", chosen data type: \"Json\"\n                                    // - Type \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                                    // \n                        `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --force --composite-type-depth=-1 (existing models)","suites":["mysql"],"updatePoint":{"line":1372,"column":73},"line":1372,"code":"  test('introspection --force --composite-type-depth=-1 (existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--force', '--composite-type-depth=-1'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n                                    - Introspecting based on datasource defined in prisma/schema.prisma\n\n                                    ✔ Introspected 1 model and 2 embedded documents and wrote them into prisma/schema.prisma in XXXms\n                                          \n                                    *** WARNING ***\n                                    \n                                    The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type.\n                                    - Model \"users\", field: \"numberOrString1\", chosen data type: \"Json\"\n                                    - Type \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                                    - Type \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n\n                                    Run prisma generate to generate Prisma Client.\n\n                        `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --print --composite-type-depth=-1 (no existing models)","suites":["mysql"],"updatePoint":{"line":1403,"column":76},"line":1403,"code":"  test('introspection --print --composite-type-depth=-1 (no existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--schema=./prisma/no-model.prisma', '--print', '--composite-type-depth=-1'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      generator client {\n        provider = \"prisma-client-js\"\n      }\n\n      datasource my_db {\n        provider = \"mongodb\"\n        url      = env(\"TEST_MONGO_URI_MIGRATE\")\n      }\n\n      type UsersHobbies {\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString2 Json?\n        objects         UsersHobbiesObjects[]\n        tags            String[]\n      }\n\n      type UsersHobbiesObjects {\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString3 Json\n        tags            String[]\n      }\n\n      model users {\n        id              String         @id @default(auto()) @map(\"_id\") @my_db.ObjectId\n        admin           Boolean\n        email           String\n        hobbies         UsersHobbies[]\n        name            String\n        /// Multiple data types found: String: 50%, Int: 50% out of 2 sampled entries\n        numberOrString1 Json\n      }\n\n\n      // introspectionSchemaVersion: NonPrisma,\n    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                    // *** WARNING ***\n                                    // \n                                    // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type.\n                                    // - Model \"users\", field: \"numberOrString1\", chosen data type: \"Json\"\n                                    // - Type \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                                    // - Type \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n                                    // \n                        `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"basic introspection --url","suites":["mysql"],"updatePoint":{"line":1463,"column":33},"line":1463,"code":"  test('basic introspection --url', async () => {\n    const introspect = new DbPull()\n    const result = introspect.parse(['--print', '--url', MONGO_URI])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                    // *** WARNING ***\n                                    // \n                                    // The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type.\n                                    // - Model \"users\", field: \"numberOrString1\", chosen data type: \"Json\"\n                                    // - Type \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                                    // - Type \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n                                    // \n                        `)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection --url - only generator defined","suites":["mysql"],"updatePoint":{"line":1484,"column":52},"line":1484,"code":"  test('introspection --url - only generator defined', async () => {\n    ctx.fixture('schema-only-mongodb/only-generator')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--url', MONGO_URI])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).not.toContain(`Datasource `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Prisma schema loaded from schema.prisma`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n                                    - Introspecting\n\n                                    ✔ Introspected 1 model and 2 embedded documents and wrote them into schema.prisma in XXXms\n                                          \n                                    *** WARNING ***\n                                    \n                                    The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type.\n                                    - Model \"users\", field: \"numberOrString1\", chosen data type: \"Json\"\n                                    - Type \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                                    - Type \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n\n                                    Run prisma generate to generate Prisma Client.\n\n                        `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"introspection with --force","suites":["mysql"],"updatePoint":{"line":1515,"column":34},"line":1515,"code":"  test('introspection with --force', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse(['--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n\n                                    - Introspecting based on datasource defined in prisma/schema.prisma\n\n                                    ✔ Introspected 1 model and 2 embedded documents and wrote them into prisma/schema.prisma in XXXms\n                                          \n                                    *** WARNING ***\n                                    \n                                    The following fields had data stored in multiple types. Either use Json or normalize data to the wanted type.\n                                    - Model \"users\", field: \"numberOrString1\", chosen data type: \"Json\"\n                                    - Type \"UsersHobbies\", field: \"numberOrString2\", chosen data type: \"Json\"\n                                    - Type \"UsersHobbiesObjects\", field: \"numberOrString3\", chosen data type: \"Json\"\n\n                                    Run prisma generate to generate Prisma Client.\n\n                        `)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"re-introspection should error (not supported) (existing models)","suites":["mysql"],"updatePoint":{"line":1546,"column":71},"line":1546,"code":"  test('re-introspection should error (not supported) (existing models)', async () => {\n    ctx.fixture('schema-only-mongodb')\n    const introspect = new DbPull()\n    const result = introspect.parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Iterating on one schema using re-introspection with db pull is currently not supported with MongoDB provider.\n            You can explicitly ignore and override your current local schema file with prisma db pull --force\n            Some information will be lost (relations, comments, mapped fields, @ignore...), follow https://github.com/prisma/prisma/issues/9585 for more info.\n          `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\"\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stdout.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['process.stderr.write'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPull.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--preview-feature flag is not required anymore","suites":[],"updatePoint":{"line":16,"column":52},"line":16,"code":"  it('--preview-feature flag is not required anymore', async () => {\n    ctx.fixture('empty')\n\n    const result = DbPush.new().parse(['--preview-feature'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Could not find a schema.prisma file that is required for this command.\n            You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n          `)\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      prisma:warn Prisma \"db push\" was in Preview and is now Generally Available.\n      You can now remove the --preview-feature flag.\n    `)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":[],"updatePoint":{"line":30,"column":35},"line":30,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n                      Could not find a schema.prisma file that is required for this command.\n                      You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n                  `)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if nativeTypes VarChar on sqlite","suites":[],"updatePoint":{"line":40,"column":50},"line":40,"code":"  it('should fail if nativeTypes VarChar on sqlite', async () => {\n    ctx.fixture('nativeTypes-sqlite')\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P1012\n\n            error: Native type VarChar is not supported for sqlite connector.\n              -->  schema.prisma:12\n               | \n            11 |   id   Int    @id\n            12 |   name String @db.VarChar(100)\n               | \n\n\n          `)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--force flag renamed","suites":[],"updatePoint":{"line":57,"column":26},"line":57,"code":"  it('--force flag renamed', async () => {\n    ctx.fixture('reset')\n    const result = DbPush.new().parse(['--force'])\n    await expect(result).rejects.toMatchInlineSnapshot(\n      `The --force flag was renamed to --accept-data-loss in 2.17.0, use prisma db push --accept-data-loss`,\n    )\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"already in sync","suites":[],"updatePoint":{"line":67,"column":21},"line":67,"code":"  it('already in sync', async () => {\n    ctx.fixture('reset')\n    const result = DbPush.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      🚀  Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"missing SQLite db should be created next to the schema.prisma file","suites":[],"updatePoint":{"line":80,"column":72},"line":80,"code":"  it('missing SQLite db should be created next to the schema.prisma file', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/dev.db')\n    const schemaPath = 'prisma/schema.prisma'\n\n    const result = DbPush.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      🚀  Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    await expect(ctx.fs.inspect(schemaPath)?.size).toBeGreaterThan(0)\n    await expect(ctx.fs.inspect(path.join(path.dirname(schemaPath), 'dev.db'))?.size).toBeGreaterThan(0)\n    await expect(ctx.fs.inspect('dev.db')?.size).toBeUndefined()\n\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"missing SQLite db should be created next to the --schema path","suites":[],"updatePoint":{"line":102,"column":67},"line":102,"code":"  it('missing SQLite db should be created next to the --schema path', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/dev.db')\n\n    const oldSchemaPath = 'prisma/schema.prisma'\n    const newSchemaPath = 'something/schema.prisma'\n    ctx.fs.move(oldSchemaPath, newSchemaPath)\n\n    const result = DbPush.new().parse(['--schema', newSchemaPath])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from something/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      🚀  Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    await expect(ctx.fs.inspect(oldSchemaPath)?.size).toBeUndefined()\n    await expect(ctx.fs.inspect(newSchemaPath)?.size).toBeGreaterThan(0)\n    await expect(ctx.fs.inspect(path.join(path.dirname(oldSchemaPath), 'dev.db'))?.size).toBeUndefined()\n    await expect(ctx.fs.inspect(path.join(path.dirname(newSchemaPath), 'dev.db'))?.size).toBeGreaterThan(0)\n    await expect(ctx.fs.inspect('dev.db')?.size).toBeUndefined()\n\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should ask for --accept-data-loss if not provided in CI","suites":[],"updatePoint":{"line":129,"column":61},"line":129,"code":"  it('should ask for --accept-data-loss if not provided in CI', async () => {\n    ctx.fixture('existing-db-warnings')\n    process.env.GITHUB_ACTIONS = '1'\n\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(\n      `Use the --accept-data-loss flag to ignore the data loss warnings like prisma db push --accept-data-loss`,\n    )\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dataloss warnings accepted (prompt)","suites":[],"updatePoint":{"line":142,"column":41},"line":142,"code":"  it('dataloss warnings accepted (prompt)', async () => {\n    ctx.fixture('existing-db-warnings')\n\n    prompt.inject(['y'])\n\n    const result = DbPush.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      ⚠️  There might be data loss when applying the changes:\n\n        • You are about to drop the \\`Blog\\` table, which is not empty (1 rows).\n\n\n\n      🚀  Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dataloss warnings cancelled (prompt)","suites":[],"updatePoint":{"line":165,"column":42},"line":165,"code":"  it('dataloss warnings cancelled (prompt)', async () => {\n    ctx.fixture('existing-db-warnings')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()]) // simulate user cancellation\n\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      ⚠️  There might be data loss when applying the changes:\n\n        • You are about to drop the \\`Blog\\` table, which is not empty (1 rows).\n\n\n      Push cancelled.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toBeCalledWith(130)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--accept-data-loss flag","suites":[],"updatePoint":{"line":191,"column":29},"line":191,"code":"  it('--accept-data-loss flag', async () => {\n    ctx.fixture('existing-db-warnings')\n    const result = DbPush.new().parse(['--accept-data-loss'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      ⚠️  There might be data loss when applying the changes:\n\n        • You are about to drop the \\`Blog\\` table, which is not empty (1 rows).\n\n\n      🚀  Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unexecutable - drop accepted (prompt)","suites":[],"updatePoint":{"line":209,"column":43},"line":209,"code":"  it('unexecutable - drop accepted (prompt)', async () => {\n    ctx.fixture('existing-db-1-unexecutable-schema-change')\n\n    prompt.inject(['y'])\n\n    const result = DbPush.new().parse([])\n\n    const sqliteDbSizeBefore = ctx.fs.inspect('prisma/dev.db')!.size\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    const sqliteDbSizeAfter = ctx.fs.inspect('prisma/dev.db')!.size\n\n    expect(sqliteDbSizeBefore).toBeGreaterThan(10000)\n    expect(sqliteDbSizeAfter).toBeGreaterThan(10000)\n    expect(sqliteDbSizeAfter).toBeLessThan(sqliteDbSizeBefore)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      ⚠️ We found changes that cannot be executed:\n\n        • Made the column \\`fullname\\` on table \\`Blog\\` required, but there are 1 existing NULL values.\n\n\n      The SQLite database \"dev.db\" from \"file:dev.db\" was successfully reset.\n\n      🚀  Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unexecutable - drop cancelled (prompt)","suites":[],"updatePoint":{"line":243,"column":44},"line":243,"code":"  it('unexecutable - drop cancelled (prompt)', async () => {\n    ctx.fixture('existing-db-warnings')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()]) // simulate user cancellation\n\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      ⚠️  There might be data loss when applying the changes:\n\n        • You are about to drop the \\`Blog\\` table, which is not empty (1 rows).\n\n\n      Push cancelled.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toBeCalledWith(130)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unexecutable - --force-reset","suites":[],"updatePoint":{"line":268,"column":34},"line":268,"code":"  it('unexecutable - --force-reset', async () => {\n    ctx.fixture('existing-db-1-unexecutable-schema-change')\n    const result = DbPush.new().parse(['--force-reset'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      The SQLite database \"dev.db\" from \"file:dev.db\" was successfully reset.\n\n      🚀  Your database is now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unexecutable - should ask for --force-reset in CI","suites":[],"updatePoint":{"line":283,"column":55},"line":283,"code":"  it('unexecutable - should ask for --force-reset in CI', async () => {\n    ctx.fixture('existing-db-1-unexecutable-schema-change')\n    process.env.GITHUB_ACTIONS = '1'\n\n    const result = DbPush.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n\n                                    ⚠️ We found changes that cannot be executed:\n\n                                      • Made the column \\`fullname\\` on table \\`Blog\\` required, but there are 1 existing NULL values.\n\n                                    Use the --force-reset flag to drop the database before push like prisma db push --force-reset\n                                    All data will be lost.\n                                            \n                        `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dataloss warnings accepted (prompt)","suites":[],"updatePoint":{"line":330,"column":41},"line":330,"code":"  it('dataloss warnings accepted (prompt)', async () => {\n    ctx.fixture('existing-db-warnings-mongodb')\n\n    prompt.inject(['y'])\n\n    const result = DbPush.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\"\n      Applying the following changes:\n\n      [+] Collection \\`Post\\`\n\n\n      🚀  Your database indexes are now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dataloss warnings cancelled (prompt)","suites":[],"updatePoint":{"line":351,"column":42},"line":351,"code":"  it('dataloss warnings cancelled (prompt)', async () => {\n    ctx.fixture('existing-db-warnings-mongodb')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()]) // simulate user cancellation\n\n    const result = DbPush.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\"\n      Applying the following changes:\n\n      [+] Collection \\`Post\\`\n\n\n      🚀  Your database indexes are now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toBeCalledWith(130)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--accept-data-loss flag","suites":[],"updatePoint":{"line":376,"column":29},"line":376,"code":"  it('--accept-data-loss flag', async () => {\n    ctx.fixture('existing-db-warnings-mongodb')\n    const result = DbPush.new().parse(['--accept-data-loss'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\"\n      Applying the following changes:\n\n      [+] Collection \\`Post\\`\n\n\n      🚀  Your database indexes are now in sync with your Prisma schema. Done in XXXms\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbPush.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"seed.js","suites":[],"updatePoint":{"line":12,"column":13},"line":12,"code":"  it('seed.js', async () => {\n    ctx.fixture('seed-sqlite-js')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(`\n\n                                                                                                                                                                                                                                                                              🌱  The seed command has been executed.\n                                                                                                                                                                                                                                `)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`node prisma/seed.js\\` ...`,\n    )\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"one broken seed.js file","suites":[],"updatePoint":{"line":28,"column":29},"line":28,"code":"  it('one broken seed.js file', async () => {\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    ctx.fixture('seed-sqlite-js')\n    ctx.fs.write('prisma/seed.js', 'BROKEN_CODE_SHOULD_ERROR;')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`node prisma/seed.js\\` ...`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join()).toContain('An error occurred while running the seed command:')\n    expect(mockExit).toBeCalledWith(1)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"seed.ts","suites":[],"updatePoint":{"line":45,"column":13},"line":45,"code":"  it('seed.ts', async () => {\n    ctx.fixture('seed-sqlite-ts')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(`\n\n                                                                                                                                                                                                                                                                                                      🌱  The seed command has been executed.\n                                                                                                                                                                                                                                                    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`ts-node prisma/seed.ts\\` ...`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  }, 10_000)","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"seed.ts - ESM","suites":[],"updatePoint":{"line":59,"column":19},"line":59,"code":"  it('seed.ts - ESM', async () => {\n    ctx.fixture('seed-sqlite-ts-esm')\n\n    // Needs ts-node to be installed\n    await execa.command('npm i')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(`\n\n                                                                                                                                                                                                                                                                                                      🌱  The seed command has been executed.\n                                                                                                                                                                                                                                                    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`node --loader ts-node/esm prisma/seed.ts\\` ...`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n\n    // \"high\" number since npm install can sometimes be slow\n  }, 30_000)","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"seed.sh","suites":[],"updatePoint":{"line":78,"column":13},"line":78,"code":"  it('seed.sh', async () => {\n    ctx.fixture('seed-sqlite-sh')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(`\n\n                                                                                                                                                                                                                                                                                                      🌱  The seed command has been executed.\n                                                                                                                                                                                                                                                    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`./prisma/seed.sh\\` ...`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"no seed file","suites":[],"updatePoint":{"line":94,"column":18},"line":94,"code":"  it('no seed file', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n    ctx.fs.remove('prisma/seed.js')\n    ctx.fs.remove('prisma/seed.ts')\n    ctx.fs.remove('prisma/seed.sh')\n\n    try {\n      await DbSeed.new().parse([])\n    } catch (e) {\n      expect(e).toMatchInlineSnapshot(`\n        To configure seeding in your project you need to add a \"prisma.seed\" property in your package.json with the command to execute it:\n\n        1. Open the package.json of your project\n        2. Add one of the following examples to your package.json:\n\n        TypeScript:\n        \\`\\`\\`\n        \"prisma\": {\n          \"seed\": \"ts-node ./prisma/seed.ts\"\n        }\n        \\`\\`\\`\n        If you are using ESM (ECMAScript modules):\n        \\`\\`\\`\n        \"prisma\": {\n          \"seed\": \"node --loader ts-node/esm ./prisma/seed.ts\"\n        }\n        \\`\\`\\`\n\n        And install the required dependencies by running:\n        npm i -D ts-node typescript @types/node\n\n        JavaScript:\n        \\`\\`\\`\n        \"prisma\": {\n          \"seed\": \"node ./prisma/seed.js\"\n        }\n        \\`\\`\\`\n\n        Bash:\n        \\`\\`\\`\n        \"prisma\": {\n          \"seed\": \"./prisma/seed.sh\"\n        }\n        \\`\\`\\`\n        And run \\`chmod +x prisma/seed.sh\\` to make it executable.\n        More information in our documentation:\n        https://pris.ly/d/seeding\n      `)\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"more than one seed file","suites":[],"updatePoint":{"line":148,"column":29},"line":148,"code":"  it('more than one seed file', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\nTo configure seeding in your project you need to add a \"prisma.seed\" property in your package.json with the command to execute it:\n\n1. Open the package.json of your project\n2. Add the following example to it:\n\\`\\`\\`\n\"prisma\": {\n  \"seed\": \"node prisma/seed.js\"\n}\n\\`\\`\\`\n\nMore information in our documentation:\nhttps://pris.ly/d/seeding\n`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"deprecation of --preview-feature flag","suites":[],"updatePoint":{"line":171,"column":43},"line":171,"code":"  it('deprecation of --preview-feature flag', async () => {\n    ctx.fixture('seed-sqlite-js')\n\n    const result = DbSeed.new().parse(['--preview-feature'])\n    await expect(result).resolves.toMatchInlineSnapshot(`\n\n                                                                                                      🌱  The seed command has been executed.\n                                                                                    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`node prisma/seed.js\\` ...`,\n    )\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      prisma:warn Prisma \"db seed\" was in Preview and is now Generally Available.\n      You can now remove the --preview-feature flag.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"using --schema should warn","suites":[],"updatePoint":{"line":190,"column":32},"line":190,"code":"  it('using --schema should warn', async () => {\n    ctx.fixture('seed-sqlite-js')\n\n    const result = DbSeed.new().parse(['--schema=./some-folder/schema.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(`\n\n                                                                                                                                                                                                                                                                                                      🌱  The seed command has been executed.\n                                                                                                                                                                                                                                                    `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Running seed command \\`node prisma/seed.js\\` ...`,\n    )\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `prisma:warn The \"--schema\" parameter is not used anymore by \"prisma db seed\" since version 3.0 and can now be removed.`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"custom --schema from package.json should enrich help setup","suites":[],"updatePoint":{"line":207,"column":64},"line":207,"code":"  it('custom --schema from package.json should enrich help setup', async () => {\n    ctx.fixture('seed-sqlite-legacy-schema-from-package-json')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            To configure seeding in your project you need to add a \"prisma.seed\" property in your package.json with the command to execute it:\n\n            1. Open the package.json of your project\n            2. Add the following example to it:\n            \\`\\`\\`\n            \"prisma\": {\n              \"seed\": \"node custom-folder/seed.js\"\n            }\n            \\`\\`\\`\n\n            More information in our documentation:\n            https://pris.ly/d/seeding\n          `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"custom ts-node should warn","suites":[],"updatePoint":{"line":229,"column":32},"line":229,"code":"  it('custom ts-node should warn', async () => {\n    ctx.fixture('seed-sqlite-legacy-custom-ts-node')\n\n    const result = DbSeed.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            To configure seeding in your project you need to add a \"prisma.seed\" property in your package.json with the command to execute it:\n\n            1. Open the package.json of your project\n            2. Add the following example to it:\n            \\`\\`\\`\n            \"prisma\": {\n              \"seed\": \"ts-node prisma/seed.ts\"\n            }\n            \\`\\`\\`\n            If you are using ESM (ECMAScript modules):\n            \\`\\`\\`\n            \"prisma\": {\n              \"seed\": \"node --loader ts-node/esm prisma/seed.ts\"\n            }\n            \\`\\`\\`\n\n            3. Install the required dependencies by running:\n            npm i -D ts-node typescript @types/node\n\n            More information in our documentation:\n            https://pris.ly/d/seeding\n          `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `prisma:warn The \"ts-node\" script in the package.json is not used anymore since version 3.0 and can now be removed.`,\n    )\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"DbSeed.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"can create database - sqlite","suites":[],"updatePoint":{"line":7,"column":32},"line":7,"code":"it('can create database - sqlite', async () => {\n  ctx.fixture('schema-only-sqlite')\n  const schemaPath = (await getSchemaPath())!\n  const result = ensureDatabaseExists('create', true, schemaPath)\n  await expect(result).resolves.toMatchInlineSnapshot(`SQLite database dev.db created at file:dev.db`)\n})","file":"ensureDatabaseExists.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"force panic","suites":["introspection panic"],"updatePoint":{"line":6,"column":19},"line":6,"code":"  test('force panic', async () => {\n    process.env.FORCE_PANIC_INTROSPECTION_ENGINE = '1'\n    process.chdir(path.join(__dirname, 'fixtures', 'introspection', 'sqlite'))\n\n    const introspect = new DbPull()\n    try {\n      await introspect.parse(['--print'])\n    } catch (e) {\n      expect(e).toMatchInlineSnapshot(`[/some/rust/path:0:0] This is the debugPanic artificial panic`)\n    }\n  })","file":"handlePanic.introspect.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"test interactive engine panic","suites":["handlePanic migrate"],"updatePoint":{"line":83,"column":35},"line":83,"code":"  it('test interactive engine panic', async () => {\n    process.env.FORCE_PANIC_MIGRATION_ENGINE = '1'\n    const captureStdout = new CaptureStdout()\n    const files = {\n      'schema.prisma': `\n        datasource my_db {\n          provider = \"sqlite\"\n          url = \"file:./db/db_file.db\"\n          default = true\n        }\n\n        model User {\n          id Int @id\n        }\n      `,\n      'db/.keep': ``,\n    }\n    const schemaPath = join(testRootDir, Object.keys(files)[0])\n    await writeFiles(testRootDir, files)\n\n    captureStdout.startCapture()\n\n    let error\n    try {\n      const migrate = new Migrate(schemaPath)\n      await migrate.createMigration({\n        migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n        migrationName: 'setup',\n        draft: false,\n        prismaSchema: migrate.getPrismaSchema(),\n      })\n    } catch (err) {\n      // No to send error report\n      setTimeout(() => sendKeystrokes(io).then(), 5)\n      // No to create new issue\n      setTimeout(() => sendKeystrokes(io).then(), 5)\n      // This allows this test to be run in the CI\n      try {\n        await handlePanic(err, packageJsonVersion, engineVersion, command)\n      } catch (err) {\n        error = err\n      }\n    }\n    // We use prompts.inject() for testing in our CI\n    if (isCi() && Boolean((prompt as any)._injected?.length) === false) {\n      expect(error).toMatchInlineSnapshot(`\n        Error in migration engine.\n        Reason: [/some/rust/path:0:0] This is the debugPanic artificial panic\n\n        Please create an issue with your \\`schema.prisma\\` at\n        https://github.com/prisma/prisma/issues/new\n\n      `)\n    } else {\n      const output = captureStdout.getCapturedText()\n      expect(stripAnsi(output.join('\\n'))).toMatchInlineSnapshot(`\n\n                                  console.log    Oops, an unexpected error occurred!    Error in migration engine.    Reason: [/some/rust/path:0:0] This is the debugPanic artificial panic        Please create an issue with your \\`schema.prisma\\` at     https://github.com/prisma/prisma/issues/new            Please help us improve Prisma by submitting an error report.    Error reports never contain personal or other sensitive information.    Learn more: https://pris.ly/d/telemetry      at panicDialog (src/utils/handlePanic.ts:25:11)\n\n                                ? Submit error report › - Use arrow-keys. Return to submit.❯   Yes - Send error report once    No\n\n                                ? Submit error report › - Use arrow-keys. Return to submit.    Yes❯   No - Don't send error report\n\n                                ✔ Submit error report › No\n\n\n\n                                ? Would you like to create a GitHub issue? › - Use arrow-keys. Return to submit.❯   Yes - Create a new GitHub issue    No\n\n                                ? Would you like to create a GitHub issue? › - Use arrow-keys. Return to submit.    Yes❯   No - Don't create a new GitHub issue\n\n                                ✔ Would you like to create a GitHub issue? › No\n\n\n                        `)\n    }\n    captureStdout.stopCapture()\n  })","file":"handlePanic.migrate.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"engine panic no interactive mode in CI","suites":["handlePanic migrate"],"updatePoint":{"line":162,"column":44},"line":162,"code":"  it('engine panic no interactive mode in CI', async () => {\n    process.env.FORCE_PANIC_MIGRATION_ENGINE = '1'\n\n    const files = {\n      'schema.prisma': `\n        datasource my_db {\n          provider = \"sqlite\"\n          url = \"file:./db/db_file.db\"\n          default = true\n        }\n\n        model User {\n          id Int @id\n        }\n      `,\n      'db/.keep': ``,\n    }\n    const schemaPath = join(testRootDir, Object.keys(files)[0])\n    await writeFiles(testRootDir, files)\n\n    try {\n      const migrate = new Migrate(schemaPath)\n      await migrate.createMigration({\n        migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n        migrationName: 'setup',\n        draft: false,\n        prismaSchema: migrate.getPrismaSchema(),\n      })\n    } catch (error) {\n      expect(error).toMatchSnapshot()\n      expect(JSON.parse(JSON.stringify(error))).toMatchObject({\n        area: 'LIFT_CLI',\n        schemaPath,\n      })\n      expect(error.rustStack).toContain('This is the debugPanic artificial panic')\n    }\n  })","file":"handlePanic.migrate.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"no params should return help","suites":[],"updatePoint":{"line":4,"column":32},"line":4,"code":"it('no params should return help', async () => {\n  const commandInstance = MigrateCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse([])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"wrong flag","suites":[],"updatePoint":{"line":13,"column":14},"line":13,"code":"it('wrong flag', async () => {\n  const commandInstance = MigrateCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse(['--something'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"help flag","suites":[],"updatePoint":{"line":22,"column":13},"line":22,"code":"it('help flag', async () => {\n  const commandInstance = MigrateCommand.new({})\n  const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n  await commandInstance.parse(['--help'])\n  expect(spy).toHaveBeenCalledTimes(1)\n  spy.mockRestore()\n})","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"unknown command","suites":[],"updatePoint":{"line":31,"column":19},"line":31,"code":"it('unknown command', async () => {\n  await expect(MigrateCommand.new({}).parse(['doesnotexist'])).resolves.toThrowError()\n})","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dev with --preview-feature flag","suites":[],"updatePoint":{"line":35,"column":35},"line":35,"code":"it('dev with --preview-feature flag', async () => {\n  await expect(\n    MigrateCommand.new({\n      dev: MigrateDev.new(),\n    }).parse(['dev', '--preview-feature']),\n  ).rejects.toMatchInlineSnapshot(`\n          Could not find a schema.prisma file that is required for this command.\n          You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n        `)\n})","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"experimental flag","suites":["legacy"],"updatePoint":{"line":47,"column":23},"line":47,"code":"  it('experimental flag', async () => {\n    await expect(MigrateCommand.new({}).parse(['--experimental'])).rejects.toMatchInlineSnapshot(`\n            Prisma Migrate was Experimental and is now Generally Available.\n            WARNING this new version has some breaking changes to use it it's recommended to read the documentation first and remove the --experimental flag.\n          `)\n  })","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"up command","suites":["legacy"],"updatePoint":{"line":54,"column":16},"line":54,"code":"  it('up command', async () => {\n    await expect(MigrateCommand.new({}).parse(['up'])).rejects.toMatchInlineSnapshot(`\n            The current command \"up\" doesn't exist in the new version of Prisma Migrate.\n            Read more about how to upgrade: https://pris.ly/d/migrate-upgrade\n          `)\n  })","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"down command","suites":["legacy"],"updatePoint":{"line":61,"column":18},"line":61,"code":"  it('down command', async () => {\n    await expect(MigrateCommand.new({}).parse(['down'])).rejects.toMatchInlineSnapshot(`\n            The current command \"down\" doesn't exist in the new version of Prisma Migrate.\n            Read more about how to upgrade: https://pris.ly/d/migrate-upgrade\n          `)\n  })","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"save command","suites":["legacy"],"updatePoint":{"line":68,"column":18},"line":68,"code":"  it('save command', async () => {\n    await expect(MigrateCommand.new({}).parse(['save'])).rejects.toMatchInlineSnapshot(`\n            The current command \"save\" doesn't exist in the new version of Prisma Migrate.\n            Read more about how to upgrade: https://pris.ly/d/migrate-upgrade\n          `)\n  })","file":"MigrateCommand.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["common"],"updatePoint":{"line":9,"column":35},"line":9,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n    const result = MigrateDeploy.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Could not find a schema.prisma file that is required for this command.\n            You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n          `)\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if experimental flag","suites":["common"],"updatePoint":{"line":17,"column":38},"line":17,"code":"  it('should fail if experimental flag', async () => {\n    ctx.fixture('empty')\n    const result = MigrateDeploy.new().parse(['--experimental'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Prisma Migrate was Experimental and is now Generally Available.\n            WARNING this new version has some breaking changes to use it it's recommended to read the documentation first and remove the --experimental flag.\n          `)\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if early access flag","suites":["common"],"updatePoint":{"line":25,"column":38},"line":25,"code":"  it('should fail if early access flag', async () => {\n    ctx.fixture('empty')\n    const result = MigrateDeploy.new().parse(['--early-access-feature'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Prisma Migrate was in Early Access and is now Generally Available.\n            Remove the --early-access-feature flag.\n          `)\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"no unapplied migrations","suites":["sqlite"],"updatePoint":{"line":36,"column":29},"line":36,"code":"  it('no unapplied migrations', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateDeploy.new().parse(['--schema=./prisma/empty.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(`No pending migrations to apply.`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/empty.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      No migration found in prisma/migrations\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls).toMatchSnapshot()\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"1 unapplied migration","suites":["sqlite"],"updatePoint":{"line":55,"column":27},"line":55,"code":"  it('1 unapplied migration', async () => {\n    ctx.fixture('existing-db-1-migration')\n    fs.remove('prisma/dev.db')\n\n    const result = MigrateDeploy.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(`\n            The following migration have been applied:\n\n            migrations/\n              └─ 20201231000000_init/\n                └─ migration.sql\n                  \n            All migrations have been successfully applied.\n          `)\n\n    // Second time should do nothing (already applied)\n    const resultBis = MigrateDeploy.new().parse([])\n    await expect(resultBis).resolves.toMatchInlineSnapshot(`No pending migrations to apply.`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      1 migration found in prisma/migrations\n\n      Applying migration \\`20201231000000_init\\`\n\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      1 migration found in prisma/migrations\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls).toMatchSnapshot()\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should throw if database is not empty","suites":["sqlite"],"updatePoint":{"line":95,"column":43},"line":95,"code":"  it('should throw if database is not empty', async () => {\n    ctx.fixture('existing-db-1-migration-conflict')\n\n    const result = MigrateDeploy.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            P3005\n\n            The database schema is not empty. Read more about how to baseline an existing production database: https://pris.ly/d/migrate-baseline\n\n          `)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      1 migration found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls).toMatchSnapshot()\n  })","file":"MigrateDeploy.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"invalid schema","suites":["common"],"updatePoint":{"line":24,"column":20},"line":24,"code":"  it('invalid schema', async () => {\n    ctx.fixture('schema-only-sqlite')\n\n    try {\n      await MigrateDev.new().parse(['--schema=./prisma/invalid.prisma'])\n      expect(true).toBe(false) // unreachable\n    } catch (error) {\n      expect(error.message).toMatchInlineSnapshot(`\n        Schema validation error - Error (get-config wasm)\n        Error code: P1012\n        error: Error validating: This line is invalid. It does not start with any known Prisma schema keyword.\n          -->  schema.prisma:10\n           | \n         9 | }\n        10 | model Blog {\n        11 | \n           | \n\n        Validation Error Count: 1\n        [Context: getConfig]\n\n        Prisma CLI Version : 0.0.0\n      `)\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Prisma schema loaded from prisma/invalid.prisma`,\n    )\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"provider array should fail","suites":["common"],"updatePoint":{"line":56,"column":32},"line":56,"code":"  it('provider array should fail', async () => {\n    ctx.fixture('schema-only-sqlite')\n\n    try {\n      await MigrateDev.new().parse(['--schema=./prisma/provider-array.prisma'])\n      expect(true).toBe(false) // unreachable\n    } catch (error) {\n      expect(error.message).toMatchInlineSnapshot(`\n        Schema validation error - Error (get-config wasm)\n        Error code: P1012\n        error: Error validating datasource \\`my_db\\`: The provider argument in a datasource must be a string literal\n          -->  schema.prisma:2\n           | \n         1 | datasource my_db {\n         2 |     provider = [\"postgresql\", \"sqlite\"]\n           | \n\n        Validation Error Count: 1\n        [Context: getConfig]\n\n        Prisma CLI Version : 0.0.0\n      `)\n    }\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(\n      `Prisma schema loaded from prisma/provider-array.prisma`,\n    )\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"wrong flag","suites":["common"],"updatePoint":{"line":86,"column":16},"line":86,"code":"  it('wrong flag', async () => {\n    const commandInstance = MigrateDev.new()\n    const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n    await commandInstance.parse(['--something'])\n    expect(spy).toHaveBeenCalledTimes(1)\n    spy.mockRestore()\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"help flag","suites":["common"],"updatePoint":{"line":94,"column":15},"line":94,"code":"  it('help flag', async () => {\n    const commandInstance = MigrateDev.new()\n    const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n    await commandInstance.parse(['--help'])\n    expect(spy).toHaveBeenCalledTimes(1)\n    spy.mockRestore()\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["common"],"updatePoint":{"line":102,"column":35},"line":102,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n    const result = MigrateDev.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Could not find a schema.prisma file that is required for this command.\n            You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n          `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if old migrate","suites":["common"],"updatePoint":{"line":110,"column":32},"line":110,"code":"  it('should fail if old migrate', async () => {\n    ctx.fixture('old-migrate')\n    const result = MigrateDev.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            The migrations folder contains migration files from an older version of Prisma Migrate which is not compatible.\n\n            Read more about how to upgrade to the new version of Migrate:\n            https://pris.ly/d/migrate-upgrade\n          `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if experimental flag","suites":["common"],"updatePoint":{"line":120,"column":38},"line":120,"code":"  it('should fail if experimental flag', async () => {\n    ctx.fixture('empty')\n    const result = MigrateDev.new().parse(['--experimental'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Prisma Migrate was Experimental and is now Generally Available.\n            WARNING this new version has some breaking changes to use it it's recommended to read the documentation first and remove the --experimental flag.\n          `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if early access flag","suites":["common"],"updatePoint":{"line":128,"column":38},"line":128,"code":"  it('should fail if early access flag', async () => {\n    ctx.fixture('empty')\n    const result = MigrateDev.new().parse(['--early-access-feature'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Prisma Migrate was in Early Access and is now Generally Available.\n            Remove the --early-access-feature flag.\n          `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dev should error in unattended environment","suites":["common"],"updatePoint":{"line":136,"column":48},"line":136,"code":"  it('dev should error in unattended environment', async () => {\n    ctx.fixture('transition-db-push-migrate')\n    const result = MigrateDev.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            Prisma Migrate has detected that the environment is non-interactive, which is not supported.\n\n            \\`prisma migrate dev\\` is an interactive command designed to create new migrations and evolve the database in development.\n            To apply existing migrations in deployments, use prisma migrate deploy.\n            See https://www.prisma.io/docs/reference/api-reference/command-reference#migrate-deploy\n          `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"empty schema","suites":["sqlite"],"updatePoint":{"line":151,"column":18},"line":151,"code":"  it('empty schema', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateDev.new().parse(['--schema=./prisma/empty.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/empty.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Already in sync, no schema change or pending migration was found.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"first migration (--name)","suites":["sqlite"],"updatePoint":{"line":168,"column":30},"line":168,"code":"  it('first migration (--name)', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(fs.exists('prisma/migrations/migration_lock.toml')).toEqual('file')\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"snapshot of sql","suites":["sqlite"],"updatePoint":{"line":264,"column":21},"line":264,"code":"  it('snapshot of sql', async () => {\n    ctx.fixture('schema-only-sqlite')\n\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    const baseDir = path.join('prisma', 'migrations')\n    const migrationDirList = fs.list(baseDir)\n    const migrationFilePath = path.join(baseDir, migrationDirList![0], 'migration.sql')\n    const migrationFile = fs.read(migrationFilePath)\n    expect(migrationFile).toMatchInlineSnapshot(`\n      -- CreateTable\n      CREATE TABLE \"Blog\" (\n          \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n          \"viewCount20\" INTEGER NOT NULL\n      );\n\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (prompt)","suites":["sqlite"],"updatePoint":{"line":285,"column":40},"line":285,"code":"  it('draft migration and apply (prompt)', async () => {\n    ctx.fixture('schema-only-sqlite')\n\n    prompt.inject(['some-Draft'])\n\n    const draftResult = MigrateDev.new().parse(['--create-only'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_some_draft\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(fs.exists('prisma/dev.db')).toEqual('file')\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Applying migration \\`20201231000000_some_draft\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_some_draft/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration with empty schema (prompt)","suites":["sqlite"],"updatePoint":{"line":327,"column":48},"line":327,"code":"  it('draft migration with empty schema (prompt)', async () => {\n    ctx.fixture('schema-only-sqlite')\n\n    prompt.inject(['some-empty-Draft'])\n\n    const draftResult = MigrateDev.new().parse(['--schema=./prisma/empty.prisma', '--create-only'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_some_empty_draft\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(fs.exists('prisma/dev.db')).toEqual('file')\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/empty.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (--name)","suites":["sqlite"],"updatePoint":{"line":353,"column":40},"line":353,"code":"  it('draft migration and apply (--name)', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const draftResult = MigrateDev.new().parse(['--create-only', '--name=first'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_first\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(fs.exists('prisma/dev.db')).toEqual('file')\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"transition-db-push-migrate (prompt reset yes)","suites":["sqlite"],"updatePoint":{"line":391,"column":51},"line":391,"code":"  it('transition-db-push-migrate (prompt reset yes)', async () => {\n    ctx.fixture('transition-db-push-migrate')\n\n    prompt.inject(['y'])\n\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Drift detected: Your database schema is not in sync with your migration history.\n\n      The following is a summary of the differences between the expected database schema given your migrations files, and the actual schema of the database.\n\n      It should be understood as the set of changes to get from the expected schema to the actual schema.\n\n      If you are running this the first time on an existing database, please make sure to read this documentation page:\n      https://www.prisma.io/docs/guides/database/developing-with-prisma-migrate/troubleshooting-development\n\n      [+] Added tables\n        - Blog\n        - _Migration\n\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"transition-db-push-migrate (prompt reset no)","suites":["sqlite"],"updatePoint":{"line":431,"column":50},"line":431,"code":"  it('transition-db-push-migrate (prompt reset no)', async () => {\n    ctx.fixture('transition-db-push-migrate')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()])\n\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Drift detected: Your database schema is not in sync with your migration history.\n\n      The following is a summary of the differences between the expected database schema given your migrations files, and the actual schema of the database.\n\n      It should be understood as the set of changes to get from the expected schema to the actual schema.\n\n      If you are running this the first time on an existing database, please make sure to read this documentation page:\n      https://www.prisma.io/docs/guides/database/developing-with-prisma-migrate/troubleshooting-development\n\n      [+] Added tables\n        - Blog\n        - _Migration\n\n\n      Reset cancelled.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(mockExit).toBeCalledWith(130)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"edited migration and unapplied empty draft","suites":["sqlite"],"updatePoint":{"line":467,"column":48},"line":467,"code":"  it('edited migration and unapplied empty draft', async () => {\n    ctx.fixture('edited-and-draft')\n\n    prompt.inject(['y'])\n\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      The migration \\`20201231000000_test\\` was modified after it was applied.\n\n      Applying migration \\`20201231000000_test\\`\n      Applying migration \\`20201231000000_draft\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_test/\n          └─ migration.sql\n        └─ 20201231000000_draft/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"removed applied migration and unapplied empty draft","suites":["sqlite"],"updatePoint":{"line":498,"column":57},"line":498,"code":"  it('removed applied migration and unapplied empty draft', async () => {\n    ctx.fixture('edited-and-draft')\n    fs.remove('prisma/migrations/20201117144659_test')\n\n    prompt.inject(['y', 'new-change'])\n\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      - Drift detected: Your database schema is not in sync with your migration history.\n\n      The following is a summary of the differences between the expected database schema given your migrations files, and the actual schema of the database.\n\n      It should be understood as the set of changes to get from the expected schema to the actual schema.\n\n      [+] Added tables\n        - Blog\n\n      - The migrations recorded in the database diverge from the local migrations directory.\n\n\n      Applying migration \\`20201231000000_draft\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_draft/\n          └─ migration.sql\n      Applying migration \\`20201231000000_new_change\\`\n\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_new_change/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"broken migration should fail","suites":["sqlite"],"updatePoint":{"line":545,"column":34},"line":545,"code":"  it('broken migration should fail', async () => {\n    ctx.fixture('broken-migration')\n\n    try {\n      await MigrateDev.new().parse([])\n    } catch (e) {\n      expect(e.code).toEqual('P3006')\n      expect(e.message).toContain('near \"BROKEN\": syntax error')\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: has a failed migration","suites":["sqlite"],"updatePoint":{"line":566,"column":40},"line":566,"code":"  it('existingdb: has a failed migration', async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n\n    try {\n      await MigrateDev.new().parse([])\n    } catch (e) {\n      expect(e.code).toEqual('P3006')\n      expect(e.message).toContain('P3006')\n      expect(e.message).toContain('failed to apply cleanly to the shadow database.')\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-1-migration edit migration with broken sql","suites":["sqlite"],"updatePoint":{"line":586,"column":60},"line":586,"code":"  it('existing-db-1-migration edit migration with broken sql', async () => {\n    ctx.fixture('existing-db-1-migration')\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    // Edit with broken SQL\n    fs.write('prisma/migrations/20201014154943_init/migration.sql', 'CREATE BROKEN')\n\n    try {\n      await MigrateDev.new().parse([])\n    } catch (e) {\n      expect(e.code).toEqual('P3006')\n      expect(e.message).toContain('P3006')\n      expect(e.message).toContain('failed to apply cleanly to the shadow database.')\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Already in sync, no schema change or pending migration was found.\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 unapplied draft","suites":["sqlite"],"updatePoint":{"line":616,"column":35},"line":616,"code":"  it('existingdb: 1 unapplied draft', async () => {\n    ctx.fixture('existing-db-1-draft')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Applying migration \\`20201231000000_draft\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_draft/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 unapplied draft + 1 schema change","suites":["sqlite"],"updatePoint":{"line":639,"column":53},"line":639,"code":"  it('existingdb: 1 unapplied draft + 1 schema change', async () => {\n    ctx.fixture('existing-db-1-draft-1-change')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Applying migration \\`20201231000000_draft\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_draft/\n          └─ migration.sql\n      Applying migration \\`20201231000000_\\`\n\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 unexecutable schema change","suites":["sqlite"],"updatePoint":{"line":670,"column":46},"line":670,"code":"  it('existingdb: 1 unexecutable schema change', async () => {\n    ctx.fixture('existing-db-1-unexecutable-schema-change')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).rejects.toMatchInlineSnapshot(`\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ⚠️ We found changes that cannot be executed:\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                • Step 0 Made the column \\`fullname\\` on table \\`Blog\\` required, but there are 1 existing NULL values.\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              You can use prisma migrate dev --create-only to create the migration file, and manually modify it to address the underlying issue(s).\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Then run prisma migrate dev to apply it and verify it works.\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 unexecutable schema change with --create-only should succeed","suites":["sqlite"],"updatePoint":{"line":694,"column":80},"line":694,"code":"  it('existingdb: 1 unexecutable schema change with --create-only should succeed', async () => {\n    ctx.fixture('existing-db-1-unexecutable-schema-change')\n    const result = MigrateDev.new().parse(['--create-only'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toMatchSnapshot()\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 warning from schema change (prompt yes)","suites":["sqlite"],"updatePoint":{"line":713,"column":59},"line":713,"code":"  it('existingdb: 1 warning from schema change (prompt yes)', async () => {\n    ctx.fixture('existing-db-1-warning')\n\n    prompt.inject(['y'])\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                                                                                                                                                                                                                                                                                                              ⚠️  Warnings for the current datasource:\n\n                                                                                                                                                                                                                                                                                                                                                                                • You are about to drop the \\`Blog\\` table, which is not empty (2 rows).\n                                                                                                                                                                                                                                                    `)\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: 1 warning from schema change (prompt no)","suites":["sqlite"],"updatePoint":{"line":744,"column":58},"line":744,"code":"  it('existingdb: 1 warning from schema change (prompt no)', async () => {\n    ctx.fixture('existing-db-1-warning')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()])\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Migration cancelled.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                                                                                                                                                                                                                                                                                                              ⚠️  Warnings for the current datasource:\n\n                                                                                                                                                                                                                                                                                                                                                                                • You are about to drop the \\`Blog\\` table, which is not empty (2 rows).\n                                                                                                                                                                                                                                                    `)\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(mockExit).toBeCalledWith(130)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"one seed file --skip-seed","suites":["sqlite"],"updatePoint":{"line":805,"column":31},"line":805,"code":"  it('one seed file --skip-seed', async () => {\n    ctx.fixture('seed-sqlite-ts')\n\n    prompt.inject(['y'])\n\n    const result = MigrateDev.new().parse(['--skip-seed'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n      Applying migration \\`20201231000000_y\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_y/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"one broken seed.js file","suites":["sqlite"],"updatePoint":{"line":833,"column":29},"line":833,"code":"  it('one broken seed.js file', async () => {\n    ctx.fixture('seed-sqlite-js')\n    fs.write('prisma/seed.js', 'BROKEN_CODE_SHOULD_ERROR;')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject(['y'])\n\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n      Applying migration \\`20201231000000_y\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_y/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n\n      Running seed command \\`node prisma/seed.js\\` ...\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join()).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join()).toContain(`An error occurred while running the seed command:`)\n    expect(mockExit).toBeCalledWith(1)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"legacy seed (no config in package.json)","suites":["sqlite"],"updatePoint":{"line":868,"column":45},"line":868,"code":"  it('legacy seed (no config in package.json)', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n    ctx.fs.remove('prisma/seed.js')\n    // ctx.fs.remove('prisma/seed.ts')\n    ctx.fs.remove('prisma/seed.sh')\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n      Applying migration \\`20201231000000_y\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_y/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"provider switch: postgresql to sqlite","suites":["sqlite"],"updatePoint":{"line":898,"column":43},"line":898,"code":"  it('provider switch: postgresql to sqlite', async () => {\n    ctx.fixture('provider-switch-postgresql-to-sqlite')\n\n    try {\n      await MigrateDev.new().parse([])\n    } catch (e) {\n      expect(e.code).toEqual('P3019')\n      expect(e.message).toContain('P3019')\n      expect(e.message).toContain('The datasource provider')\n    }\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only","suites":["postgresql"],"updatePoint":{"line":950,"column":17},"line":950,"code":"  it('schema only', async () => {\n    ctx.fixture('schema-only-postgresql')\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only with shadowdb","suites":["postgresql"],"updatePoint":{"line":974,"column":31},"line":974,"code":"  it('schema only with shadowdb', async () => {\n    ctx.fixture('schema-only-postgresql')\n\n    const result = MigrateDev.new().parse(['--schema=./prisma/shadowdb.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/shadowdb.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration","suites":["postgresql"],"updatePoint":{"line":998,"column":28},"line":998,"code":"  it('create first migration', async () => {\n    ctx.fixture('schema-only-postgresql')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration with nativeTypes","suites":["postgresql"],"updatePoint":{"line":1022,"column":45},"line":1022,"code":"  it('create first migration with nativeTypes', async () => {\n    ctx.fixture('nativeTypes-postgresql')\n\n    const result = MigrateDev.new().parse(['--name=first'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (--name)","suites":["postgresql"],"updatePoint":{"line":1069,"column":40},"line":1069,"code":"  it('draft migration and apply (--name)', async () => {\n    ctx.fixture('schema-only-postgresql')\n    jest.setTimeout(7_000)\n\n    const draftResult = MigrateDev.new().parse(['--create-only', '--name=first'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_first\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: create first migration","suites":["postgresql"],"updatePoint":{"line":1108,"column":40},"line":1108,"code":"  it('existingdb: create first migration', async () => {\n    ctx.fixture('schema-only-postgresql')\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": PostgreSQL database \"tests-migrate-dev\", schema \"public\" at \"localhost:5432\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only","suites":["postgresql"],"updatePoint":{"line":1186,"column":17},"line":1186,"code":"  it('schema only', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only with shadowdb","suites":["postgresql"],"updatePoint":{"line":1211,"column":31},"line":1211,"code":"  it('schema only with shadowdb', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n\n    const result = MigrateDev.new().parse(['--schema=./prisma/shadowdb.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/shadowdb.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev-shadowdb\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration","suites":["postgresql"],"updatePoint":{"line":1236,"column":28},"line":1236,"code":"  it('create first migration', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration with nativeTypes","suites":["postgresql"],"updatePoint":{"line":1261,"column":45},"line":1261,"code":"  it('create first migration with nativeTypes', async () => {\n    ctx.fixture('nativeTypes-cockroachdb')\n\n    const result = MigrateDev.new().parse(['--name=first'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  }, 40000)","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (--name)","suites":["postgresql"],"updatePoint":{"line":1285,"column":40},"line":1285,"code":"  it('draft migration and apply (--name)', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n    jest.setTimeout(7_000)\n\n    const draftResult = MigrateDev.new().parse(['--create-only', '--name=first'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_first\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: create first migration","suites":["postgresql"],"updatePoint":{"line":1325,"column":40},"line":1325,"code":"  it('existingdb: create first migration', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": CockroachDB database \"tests-migrate-dev\", schema \"public\" at \"localhost:26257\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only","suites":["mysql"],"updatePoint":{"line":1379,"column":17},"line":1379,"code":"  it('schema only', async () => {\n    ctx.fixture('schema-only-mysql')\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only with shadowdb","suites":["mysql"],"updatePoint":{"line":1402,"column":31},"line":1402,"code":"  it('schema only with shadowdb', async () => {\n    ctx.fixture('schema-only-mysql')\n\n    const result = MigrateDev.new().parse(['--schema=./prisma/shadowdb.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/shadowdb.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration","suites":["mysql"],"updatePoint":{"line":1425,"column":28},"line":1425,"code":"  it('create first migration', async () => {\n    ctx.fixture('schema-only-mysql')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (--name)","suites":["mysql"],"updatePoint":{"line":1496,"column":40},"line":1496,"code":"  it('draft migration and apply (--name)', async () => {\n    ctx.fixture('schema-only-mysql')\n    jest.setTimeout(7_000)\n\n    const draftResult = MigrateDev.new().parse(['--create-only', '--name=first'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_first\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: create first migration","suites":["mysql"],"updatePoint":{"line":1533,"column":40},"line":1533,"code":"  it('existingdb: create first migration', async () => {\n    ctx.fixture('schema-only-mysql')\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": MySQL database \"tests-migrate-dev\" at \"localhost:3306\"\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only","suites":["mysql"],"updatePoint":{"line":1601,"column":17},"line":1601,"code":"  it('schema only', async () => {\n    ctx.fixture('schema-only-sqlserver')\n\n    const result = MigrateDev.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\" - SQL Server\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema only with shadowdb","suites":["mysql"],"updatePoint":{"line":1625,"column":31},"line":1625,"code":"  it('schema only with shadowdb', async () => {\n    ctx.fixture('schema-only-sqlserver')\n\n    const result = MigrateDev.new().parse(['--schema=./prisma/shadowdb.prisma'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/shadowdb.prisma\n      Datasource \"my_db\" - SQL Server\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"create first migration","suites":["mysql"],"updatePoint":{"line":1649,"column":28},"line":1649,"code":"  it('create first migration', async () => {\n    ctx.fixture('schema-only-sqlserver')\n    const result = MigrateDev.new().parse([])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\" - SQL Server\n\n      Applying migration \\`20201231000000_\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"draft migration and apply (--name)","suites":["mysql"],"updatePoint":{"line":1721,"column":40},"line":1721,"code":"  it('draft migration and apply (--name)', async () => {\n    ctx.fixture('schema-only-sqlserver')\n    jest.setTimeout(10_000)\n\n    const draftResult = MigrateDev.new().parse(['--create-only', '--name=first'])\n\n    await expect(draftResult).resolves.toMatchInlineSnapshot(`\n            Prisma Migrate created the following migration without applying it 20201231000000_first\n\n            You can now edit it and apply it by running prisma migrate dev.\n          `)\n\n    const applyResult = MigrateDev.new().parse([])\n    await expect(applyResult).resolves.toMatchInlineSnapshot(``)\n\n    expect((fs.list('prisma/migrations')?.length || 0) > 0).toMatchInlineSnapshot(`true`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\" - SQL Server\n\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\" - SQL Server\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existingdb: create first migration","suites":["mysql"],"updatePoint":{"line":1759,"column":40},"line":1759,"code":"  it('existingdb: create first migration', async () => {\n    ctx.fixture('schema-only-sqlserver')\n    const result = MigrateDev.new().parse(['--name=first'])\n\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\" - SQL Server\n\n      Applying migration \\`20201231000000_first\\`\n\n      The following migration(s) have been created and applied from new schema changes:\n\n      migrations/\n        └─ 20201231000000_first/\n          └─ migration.sql\n\n      Your database is now in sync with your schema.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateDev.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should trigger a warning if --preview-feature is provided","suites":["migrate diff","generic"],"updatePoint":{"line":16,"column":65},"line":16,"code":"    it('should trigger a warning if --preview-feature is provided', async () => {\n      ctx.fixture('introspection/sqlite')\n      await MigrateDiff.new().parse(['--preview-feature', '--from-empty', '--to-url=file:dev.db'])\n\n      expect(stripAnsi(ctx.mocked['console.warn'].mock.calls.join('\\n'))).toMatchInlineSnapshot(`\n        prisma:warn \"prisma migrate diff\" was in Preview and is now Generally Available.\n        You can now remove the --preview-feature flag.\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if missing --from-... and --to-...","suites":["migrate diff","generic"],"updatePoint":{"line":26,"column":54},"line":26,"code":"    it('should fail if missing --from-... and --to-...', async () => {\n      ctx.fixture('empty')\n\n      const result = MigrateDiff.new().parse([])\n      await expect(result).rejects.toThrowError()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if only --from-... is provided","suites":["migrate diff","generic"],"updatePoint":{"line":33,"column":50},"line":33,"code":"    it('should fail if only --from-... is provided', async () => {\n      ctx.fixture('empty')\n\n      const result = MigrateDiff.new().parse(['--from-empty'])\n      await expect(result).rejects.toThrowError()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if only --to-... is provided","suites":["migrate diff","generic"],"updatePoint":{"line":40,"column":48},"line":40,"code":"    it('should fail if only --to-... is provided', async () => {\n      ctx.fixture('empty')\n\n      const result = MigrateDiff.new().parse(['--to-empty'])\n      await expect(result).rejects.toThrowError()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if more than 1 --from-... is provided","suites":["migrate diff","generic"],"updatePoint":{"line":47,"column":57},"line":47,"code":"    it('should fail if more than 1 --from-... is provided', async () => {\n      ctx.fixture('empty')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--from-url=file:dev.db'])\n      await expect(result).rejects.toThrowError()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if more than 1 --to-... is provided","suites":["migrate diff","generic"],"updatePoint":{"line":54,"column":55},"line":54,"code":"    it('should fail if more than 1 --to-... is provided', async () => {\n      ctx.fixture('empty')\n\n      const result = MigrateDiff.new().parse(['--to-empty', '--to-url=file:dev.db'])\n      await expect(result).rejects.toThrowError()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if schema does no exists, --from-schema-datasource","suites":["migrate diff","generic"],"updatePoint":{"line":61,"column":70},"line":61,"code":"    it('should fail if schema does no exists, --from-schema-datasource', async () => {\n      ctx.fixture('empty')\n      expect.assertions(2)\n\n      try {\n        await MigrateDiff.new().parse(['--from-schema-datasource=./doesnoexists.prisma', '--to-empty'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toContain(`Error trying to read Prisma schema file at`)\n      }\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail for empty/empty","suites":["migrate diff","generic"],"updatePoint":{"line":73,"column":35},"line":73,"code":"    it('should fail for empty/empty', async () => {\n      ctx.fixture('empty')\n      expect.assertions(2)\n\n      try {\n        await MigrateDiff.new().parse(['--from-empty', '--to-empty'])\n      } catch (e) {\n        expect(e.code).toEqual(undefined)\n        expect(e.message).toMatchInlineSnapshot(`\n          Could not determine the connector to use for diffing.\n\n\n        `)\n      }\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail --from-empty --to-url=file:doesnotexists.db","suites":["migrate diff","sqlite"],"updatePoint":{"line":91,"column":63},"line":91,"code":"    it('should fail --from-empty --to-url=file:doesnotexists.db', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--to-url=file:doesnotexists.db'])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1003\n\n              Database doesnotexists.db does not exist at doesnotexists.db\n\n            `)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail --from-url=file:doesnotexists.db --to-empty ","suites":["migrate diff","sqlite"],"updatePoint":{"line":103,"column":64},"line":103,"code":"    it('should fail --from-url=file:doesnotexists.db --to-empty ', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url=file:doesnotexists.db', '--to-empty'])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1003\n\n              Database doesnotexists.db does not exist at doesnotexists.db\n\n            `)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if directory in path & sqlite file does not exist","suites":["migrate diff","sqlite"],"updatePoint":{"line":115,"column":69},"line":115,"code":"    it('should fail if directory in path & sqlite file does not exist', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url=file:./something/doesnotexists.db', '--to-empty'])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1003\n\n              Database doesnotexists.db does not exist at ./something/doesnotexists.db\n\n            `)\n      expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-empty --to-url=file:dev.db","suites":["migrate diff","sqlite"],"updatePoint":{"line":129,"column":53},"line":129,"code":"    it('should diff --from-empty --to-url=file:dev.db', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--to-url=file:dev.db'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                                                        [+] Added tables\n                                                                                                                          - Post\n                                                                                                                          - Profile\n                                                                                                                          - User\n                                                                                                                          - _Migration\n\n                                                                                                                        [*] Changed the \\`Profile\\` table\n                                                                                                                          [+] Added unique index on columns (userId)\n\n                                                                                                                        [*] Changed the \\`User\\` table\n                                                                                                                          [+] Added unique index on columns (email)\n                                                                                          `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-empty --to-url=file:dev.db --script","suites":["migrate diff","sqlite"],"updatePoint":{"line":149,"column":62},"line":149,"code":"    it('should diff --from-empty --to-url=file:dev.db --script', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--to-url=file:dev.db', '--script'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchSnapshot()\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma","suites":["migrate diff","sqlite"],"updatePoint":{"line":157,"column":77},"line":157,"code":"    it('should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--to-schema-datamodel=./prisma/schema.prisma'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                                                        [+] Added tables\n                                                                                                                          - Blog\n                                                                                          `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma --script","suites":["migrate diff","sqlite"],"updatePoint":{"line":168,"column":86},"line":168,"code":"    it('should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma --script', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse([\n        '--from-empty',\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        -- CreateTable\n        CREATE TABLE \"Blog\" (\n            \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n            \"viewCount20\" INTEGER NOT NULL\n        );\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty","suites":["migrate diff","sqlite"],"updatePoint":{"line":186,"column":77},"line":186,"code":"    it('should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-schema-datamodel=./prisma/schema.prisma', '--to-empty'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                                                        [-] Removed tables\n                                                                                                                          - Blog\n                                                                                          `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty --script","suites":["migrate diff","sqlite"],"updatePoint":{"line":197,"column":86},"line":197,"code":"    it('should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty --script', async () => {\n      ctx.fixture('schema-only-sqlite')\n\n      const result = MigrateDiff.new().parse([\n        '--from-schema-datamodel=./prisma/schema.prisma',\n        '--to-empty',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        -- DropTable\n        PRAGMA foreign_keys=off;\n        DROP TABLE \"Blog\";\n        PRAGMA foreign_keys=on;\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should pass if no schema file around","suites":["migrate diff","sqlite"],"updatePoint":{"line":214,"column":44},"line":214,"code":"    it('should pass if no schema file around', async () => {\n      ctx.fixture('empty')\n      // Create empty file, as the file needs to exists\n      ctx.fs.write('dev.db', '')\n\n      const result = MigrateDiff.new().parse(['--from-url=file:dev.db', '--to-url=file:dev.db'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`No difference detected.`)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should exit with code 2 when diff is not empty without --script","suites":["migrate diff","sqlite","--exit-code"],"updatePoint":{"line":225,"column":73},"line":225,"code":"      it('should exit with code 2 when diff is not empty without --script', async () => {\n        ctx.fixture('schema-only-sqlite')\n\n        const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n          throw new Error('process.exit: ' + number)\n        })\n\n        const result = MigrateDiff.new().parse([\n          '--from-schema-datamodel=./prisma/schema.prisma',\n          '--to-empty',\n          '--exit-code',\n        ])\n\n        await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 2`)\n        expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n        expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n\n                                                                                [-] Removed tables\n                                                                                  - Blog\n                                                                `)\n\n        expect(mockExit).toHaveBeenCalledTimes(1)\n        expect(mockExit).toHaveBeenCalledWith(2)\n        mockExit.mockRestore()\n      })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should exit with code 2 when diff is not empty with --script","suites":["migrate diff","sqlite","--exit-code"],"updatePoint":{"line":251,"column":70},"line":251,"code":"      it('should exit with code 2 when diff is not empty with --script', async () => {\n        ctx.fixture('schema-only-sqlite')\n\n        const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n          throw new Error('process.exit: ' + number)\n        })\n\n        const result = MigrateDiff.new().parse([\n          '--from-schema-datamodel=./prisma/schema.prisma',\n          '--to-empty',\n          '--script',\n          '--exit-code',\n        ])\n\n        await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 2`)\n        expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n        expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n          -- DropTable\n          PRAGMA foreign_keys=off;\n          DROP TABLE \"Blog\";\n          PRAGMA foreign_keys=on;\n        `)\n\n        expect(mockExit).toHaveBeenCalledTimes(1)\n        expect(mockExit).toHaveBeenCalledWith(2)\n        mockExit.mockRestore()\n      })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should exit with code 0 when diff is empty with --script","suites":["migrate diff","sqlite","--exit-code"],"updatePoint":{"line":279,"column":66},"line":279,"code":"      it('should exit with code 0 when diff is empty with --script', async () => {\n        ctx.fixture('empty')\n        // Create empty file, as the file needs to exists\n        ctx.fs.write('dev.db', '')\n\n        const result = MigrateDiff.new().parse(['--from-empty', '--to-url=file:dev.db', '--script', '--exit-code'])\n\n        await expect(result).resolves.toMatchInlineSnapshot(``)\n        expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`-- This is an empty migration.`)\n      })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma","suites":["migrate diff","mongodb"],"updatePoint":{"line":309,"column":77},"line":309,"code":"    it('should diff --from-empty --to-schema-datamodel=./prisma/schema.prisma', async () => {\n      ctx.fixture('schema-only-mongodb')\n\n      const result = MigrateDiff.new().parse(['--from-empty', '--to-schema-datamodel=./prisma/schema.prisma'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`[+] Collection \\`User\\``)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty","suites":["migrate diff","mongodb"],"updatePoint":{"line":317,"column":77},"line":317,"code":"    it('should diff --from-schema-datamodel=./prisma/schema.prisma --to-empty', async () => {\n      ctx.fixture('schema-only-mongodb')\n\n      const result = MigrateDiff.new().parse(['--from-schema-datamodel=./prisma/schema.prisma', '--to-empty'])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`No difference detected.`)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail with not supported error with --script","suites":["migrate diff","mongodb"],"updatePoint":{"line":325,"column":58},"line":325,"code":"    it('should fail with not supported error with --script', async () => {\n      ctx.fixture('schema-only-mongodb')\n\n      const result = MigrateDiff.new().parse([\n        '--from-empty',\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              Rendering to a script is not supported on MongoDB.\n\n\n            `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script","suites":["migrate diff","mongodb"],"updatePoint":{"line":364,"column":101},"line":364,"code":"    it('should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      const result = MigrateDiff.new().parse([\n        '--from-url',\n        connectionString,\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        -- CreateTable\n        CREATE TABLE \"Blog\" (\n            \"id\" INT4 NOT NULL,\n            \"viewCount20\" INT4 NOT NULL,\n\n            CONSTRAINT \"Blog_pkey\" PRIMARY KEY (\"id\")\n        );\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should use env var from .env file with --from-schema-datasource","suites":["migrate diff","mongodb"],"updatePoint":{"line":386,"column":71},"line":386,"code":"    it('should use env var from .env file with --from-schema-datasource', async () => {\n      ctx.fixture('schema-only-cockroachdb')\n\n      const result = MigrateDiff.new().parse([\n        '--from-schema-datasource=./prisma/using-dotenv.prisma',\n        '--to-schema-datamodel=./prisma/schema.prisma',\n      ])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1001\n\n              Can't reach database server at \\`fromdotenvdoesnotexist\\`:\\`26257\\`\n\n              Please make sure your database server is running at \\`fromdotenvdoesnotexist\\`:\\`26257\\`.\n\n            `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script","suites":["migrate diff","mongodb"],"updatePoint":{"line":404,"column":104},"line":404,"code":"    it('should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url', connectionString, '--to-url=file:dev.db', '--script'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              Error in migration engine.\n              Reason: [/some/rust/path:0:0] called \\`Option::unwrap()\\` on a \\`None\\` value\n\n              Please create an issue with your \\`schema.prisma\\` at\n              https://github.com/prisma/prisma/issues/new\n\n            `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script","suites":["migrate diff","postgresql"],"updatePoint":{"line":441,"column":101},"line":441,"code":"    it('should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      const result = MigrateDiff.new().parse([\n        '--from-url',\n        connectionString,\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        -- CreateTable\n        CREATE TABLE \"Blog\" (\n            \"id\" INTEGER NOT NULL,\n            \"viewCount20\" INTEGER NOT NULL,\n\n            CONSTRAINT \"Blog_pkey\" PRIMARY KEY (\"id\")\n        );\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should use env var from .env file with --from-schema-datasource","suites":["migrate diff","postgresql"],"updatePoint":{"line":462,"column":71},"line":462,"code":"    it('should use env var from .env file with --from-schema-datasource', async () => {\n      ctx.fixture('schema-only-postgresql')\n\n      const result = MigrateDiff.new().parse([\n        '--from-schema-datasource=./prisma/using-dotenv.prisma',\n        '--to-schema-datamodel=./prisma/schema.prisma',\n      ])\n      await expect(result).rejects.toMatchInlineSnapshot(`\n              P1001\n\n              Can't reach database server at \\`fromdotenvdoesnotexist\\`:\\`5432\\`\n\n              Please make sure your database server is running at \\`fromdotenvdoesnotexist\\`:\\`5432\\`.\n\n            `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script","suites":["migrate diff","postgresql"],"updatePoint":{"line":479,"column":104},"line":479,"code":"    it('should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url', connectionString, '--to-url=file:dev.db', '--script'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n        Error in migration engine.\n        Reason: [/some/rust/path:0:0] called \\`Option::unwrap()\\` on a \\`None\\` value\n\n        Please create an issue with your \\`schema.prisma\\` at\n        https://github.com/prisma/prisma/issues/new\n\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script","suites":["migrate diff","mysql"],"updatePoint":{"line":516,"column":101},"line":516,"code":"    it('should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script', async () => {\n      ctx.fixture('schema-only-mysql')\n\n      const result = MigrateDiff.new().parse([\n        '--from-url',\n        connectionString,\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        -- CreateTable\n        CREATE TABLE \\`Blog\\` (\n            \\`id\\` INTEGER NOT NULL,\n            \\`viewCount20\\` INTEGER NOT NULL,\n\n            PRIMARY KEY (\\`id\\`)\n        ) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script","suites":["migrate diff","mysql"],"updatePoint":{"line":537,"column":104},"line":537,"code":"    it('should fail for 2 different connectors --from-url=connectionString --to-url=file:dev.db --script', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url', connectionString, '--to-url=file:dev.db', '--script'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              Error in migration engine.\n              Reason: [/some/rust/path:0:0] Column native type missing in mysql_renderer::render_column_type()\n\n              Please create an issue with your \\`schema.prisma\\` at\n              https://github.com/prisma/prisma/issues/new\n\n            `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script","suites":["migrate diff","mysql"],"updatePoint":{"line":576,"column":101},"line":576,"code":"    it('should diff --from-url=connectionString --to-schema-datamodel=./prisma/schema.prisma --script', async () => {\n      ctx.fixture('schema-only-sqlserver')\n\n      const result = MigrateDiff.new().parse([\n        '--from-url',\n        jdbcConnectionString,\n        '--to-schema-datamodel=./prisma/schema.prisma',\n        '--script',\n      ])\n      await expect(result).resolves.toMatchInlineSnapshot(``)\n      expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n        BEGIN TRY\n\n        BEGIN TRAN;\n\n        -- CreateTable\n        CREATE TABLE [dbo].[Blog] (\n            [id] INT NOT NULL,\n            [viewCount20] INT NOT NULL,\n            CONSTRAINT [Blog_pkey] PRIMARY KEY CLUSTERED ([id])\n        );\n\n        COMMIT TRAN;\n\n        END TRY\n        BEGIN CATCH\n\n        IF @@TRANCOUNT > 0\n        BEGIN\n            ROLLBACK TRAN;\n        END;\n        THROW\n\n        END CATCH\n      `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail for 2 different connectors --from-url=jdbcConnectionString --to-url=file:dev.db --script","suites":["migrate diff","mysql"],"updatePoint":{"line":613,"column":108},"line":613,"code":"    it('should fail for 2 different connectors --from-url=jdbcConnectionString --to-url=file:dev.db --script', async () => {\n      ctx.fixture('introspection/sqlite')\n\n      const result = MigrateDiff.new().parse(['--from-url', jdbcConnectionString, '--to-url=file:dev.db', '--script'])\n      await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n              Error in migration engine.\n              Reason: [/some/rust/path:0:0] Missing column native type in mssql_renderer::render_column_type()\n\n              Please create an issue with your \\`schema.prisma\\` at\n              https://github.com/prisma/prisma/issues/new\n\n            `)\n    })","file":"MigrateDiff.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"wrong flag","suites":["common"],"updatePoint":{"line":14,"column":16},"line":14,"code":"  it('wrong flag', async () => {\n    const commandInstance = MigrateReset.new()\n    const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n    await commandInstance.parse(['--something'])\n    expect(spy).toHaveBeenCalledTimes(1)\n    spy.mockRestore()\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"help flag","suites":["common"],"updatePoint":{"line":22,"column":15},"line":22,"code":"  it('help flag', async () => {\n    const commandInstance = MigrateReset.new()\n    const spy = jest.spyOn(commandInstance, 'help').mockImplementation(() => 'Help Me')\n\n    await commandInstance.parse(['--help'])\n    expect(spy).toHaveBeenCalledTimes(1)\n    spy.mockRestore()\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["common"],"updatePoint":{"line":30,"column":35},"line":30,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n    const result = MigrateReset.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Could not find a schema.prisma file that is required for this command.\n            You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n          `)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if old migrate","suites":["common"],"updatePoint":{"line":38,"column":32},"line":38,"code":"  it('should fail if old migrate', async () => {\n    ctx.fixture('old-migrate')\n    const result = MigrateReset.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            The migrations folder contains migration files from an older version of Prisma Migrate which is not compatible.\n\n            Read more about how to upgrade to the new version of Migrate:\n            https://pris.ly/d/migrate-upgrade\n          `)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if experimental flag","suites":["common"],"updatePoint":{"line":48,"column":38},"line":48,"code":"  it('should fail if experimental flag', async () => {\n    ctx.fixture('empty')\n    const result = MigrateReset.new().parse(['--experimental'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Prisma Migrate was Experimental and is now Generally Available.\n            WARNING this new version has some breaking changes to use it it's recommended to read the documentation first and remove the --experimental flag.\n          `)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if early access flag","suites":["common"],"updatePoint":{"line":56,"column":38},"line":56,"code":"  it('should fail if early access flag', async () => {\n    ctx.fixture('empty')\n    const result = MigrateReset.new().parse(['--early-access-feature'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Prisma Migrate was in Early Access and is now Generally Available.\n            Remove the --early-access-feature flag.\n          `)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work (prompt)","suites":["reset"],"updatePoint":{"line":67,"column":26},"line":67,"code":"  it('should work (prompt)', async () => {\n    ctx.fixture('reset')\n\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Applying migration \\`20201231000000_init\\`\n\n      Database reset successful\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_init/\n          └─ migration.sql\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should work (--force)","suites":["reset"],"updatePoint":{"line":92,"column":27},"line":92,"code":"  it('should work (--force)', async () => {\n    ctx.fixture('reset')\n\n    const result = MigrateReset.new().parse(['--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      Applying migration \\`20201231000000_init\\`\n\n      Database reset successful\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_init/\n          └─ migration.sql\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"with missing db","suites":["reset"],"updatePoint":{"line":114,"column":21},"line":114,"code":"  it('with missing db', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/dev.db')\n\n    const result = MigrateReset.new().parse(['--force'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n      SQLite database dev.db created at file:dev.db\n\n      Applying migration \\`20201231000000_init\\`\n\n      Database reset successful\n\n      The following migration(s) have been applied:\n\n      migrations/\n        └─ 20201231000000_init/\n          └─ migration.sql\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"without the migrations directory should fail (prompt)","suites":["reset"],"updatePoint":{"line":139,"column":59},"line":139,"code":"  it('without the migrations directory should fail (prompt)', async () => {\n    ctx.fixture('reset')\n    ctx.fs.remove('prisma/migrations')\n\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Database reset successful\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should be cancelled if user send n (prompt)","suites":["reset"],"updatePoint":{"line":158,"column":49},"line":158,"code":"  it('should be cancelled if user send n (prompt)', async () => {\n    ctx.fixture('reset')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    prompt.inject([new Error()]) // simulate user cancellation\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 130`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n\n\n      Reset cancelled.\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toBeCalledWith(130)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset should error in unattended environment","suites":["reset"],"updatePoint":{"line":179,"column":50},"line":179,"code":"  it('reset should error in unattended environment', async () => {\n    ctx.fixture('reset')\n    const result = MigrateReset.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            Prisma Migrate has detected that the environment is non-interactive. It is recommended to run this command in an interactive environment.\n\n            Use --force to run this command without user interaction.\n            See https://www.prisma.io/docs/reference/api-reference/command-reference#migrate-reset\n          `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset - multiple seed files","suites":["reset"],"updatePoint":{"line":191,"column":33},"line":191,"code":"  it('reset - multiple seed files', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n\n      Database reset successful\n\n    `)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset - multiple seed files - --skip-seed","suites":["reset"],"updatePoint":{"line":210,"column":47},"line":210,"code":"  it('reset - multiple seed files - --skip-seed', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse(['--skip-seed'])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset - legacy seed (no config in package.json)","suites":["reset"],"updatePoint":{"line":305,"column":53},"line":305,"code":"  it('reset - legacy seed (no config in package.json)', async () => {\n    ctx.fixture('seed-sqlite-legacy')\n    ctx.fs.remove('prisma/seed.js')\n    ctx.fs.remove('prisma/seed.ts')\n    // ctx.fs.remove('prisma/seed.sh')\n    prompt.inject(['y']) // simulate user yes input\n\n    const result = MigrateReset.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(``)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n\n      SQLite database dev.db created at file:./dev.db\n\n\n      Database reset successful\n\n    `)\n    expect(ctx.mocked['console.warn'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n  })","file":"MigrateReset.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["common"],"updatePoint":{"line":8,"column":35},"line":8,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n    const result = MigrateResolve.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Could not find a schema.prisma file that is required for this command.\n            You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if experimental flag","suites":["common"],"updatePoint":{"line":16,"column":38},"line":16,"code":"  it('should fail if experimental flag', async () => {\n    ctx.fixture('empty')\n    const result = MigrateResolve.new().parse(['--experimental'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Prisma Migrate was Experimental and is now Generally Available.\n            WARNING this new version has some breaking changes to use it it's recommended to read the documentation first and remove the --experimental flag.\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if early access flag","suites":["common"],"updatePoint":{"line":24,"column":38},"line":24,"code":"  it('should fail if early access flag', async () => {\n    ctx.fixture('empty')\n    const result = MigrateResolve.new().parse(['--early-access-feature'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Prisma Migrate was in Early Access and is now Generally Available.\n            Remove the --early-access-feature flag.\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no --applied or --rolled-back","suites":["common"],"updatePoint":{"line":32,"column":50},"line":32,"code":"  it('should fail if no --applied or --rolled-back', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateResolve.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            --applied or --rolled-back must be part of the command like:\n            prisma migrate resolve --applied 20201231000000_example\n            prisma migrate resolve --rolled-back 20201231000000_example\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if both --applied or --rolled-back","suites":["common"],"updatePoint":{"line":41,"column":52},"line":41,"code":"  it('should fail if both --applied or --rolled-back', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateResolve.new().parse(['--applied=something_applied', '--rolled-back=something_rolledback'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`Pass either --applied or --rolled-back, not both.`)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no sqlite db - empty schema","suites":["sqlite"],"updatePoint":{"line":49,"column":48},"line":49,"code":"  it('should fail if no sqlite db - empty schema', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateResolve.new().parse(['--schema=./prisma/empty.prisma', '--applied=something_applied'])\n    await expect(result).rejects.toMatchInlineSnapshot(`P1003: Database dev.db does not exist at dev.db`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/empty.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--applied should fail if migration doesn't exist","suites":["sqlite"],"updatePoint":{"line":66,"column":54},"line":66,"code":"  it(\"--applied should fail if migration doesn't exist\", async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const result = MigrateResolve.new().parse(['--applied=does_not_exist'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P3017\n\n            The migration does_not_exist could not be found. Please make sure that the migration exists, and that you included the whole name of the directory. (example: \"20201231000000_initial_migration\")\n\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--applied should fail if migration is already applied","suites":["sqlite"],"updatePoint":{"line":77,"column":59},"line":77,"code":"  it('--applied should fail if migration is already applied', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const result = MigrateResolve.new().parse(['--applied=20201014154943_init'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P3008\n\n            The migration \\`20201231000000_init\\` is already recorded as applied in the database.\n\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--applied should fail if migration is not in a failed state","suites":["sqlite"],"updatePoint":{"line":88,"column":65},"line":88,"code":"  it('--applied should fail if migration is not in a failed state', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const result = MigrateResolve.new().parse(['--applied', '20201014154943_init'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P3008\n\n            The migration \\`20201231000000_init\\` is already recorded as applied in the database.\n\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--applied should work on a failed migration","suites":["sqlite"],"updatePoint":{"line":99,"column":49},"line":99,"code":"  it('--applied should work on a failed migration', async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const result = MigrateResolve.new().parse(['--applied', '20201106130852_failed'])\n    await expect(result).resolves.toMatchInlineSnapshot(`Migration 20201231000000_failed marked as applied.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--rolled-back should fail if migration doesn't exist","suites":["sqlite"],"updatePoint":{"line":115,"column":58},"line":115,"code":"  it(\"--rolled-back should fail if migration doesn't exist\", async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const result = MigrateResolve.new().parse(['--rolled-back=does_not_exist'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P3011\n\n            Migration \\`does_not_exist\\` cannot be rolled back because it was never applied to the database. Hint: did you pass in the whole migration name? (example: \"20201231000000_initial_migration\")\n\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--rolled-back should fail if migration is not in a failed state","suites":["sqlite"],"updatePoint":{"line":126,"column":69},"line":126,"code":"  it('--rolled-back should fail if migration is not in a failed state', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const result = MigrateResolve.new().parse(['--rolled-back', '20201014154943_init'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            P3012\n\n            Migration \\`20201231000000_init\\` cannot be rolled back because it is not in a failed state.\n\n          `)\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--rolled-back should work on a failed migration","suites":["sqlite"],"updatePoint":{"line":137,"column":53},"line":137,"code":"  it('--rolled-back should work on a failed migration', async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const result = MigrateResolve.new().parse(['--rolled-back', '20201106130852_failed'])\n    await expect(result).resolves.toMatchInlineSnapshot(`Migration 20201231000000_failed marked as rolled back.`)\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"--rolled-back works if migration is already rolled back","suites":["sqlite"],"updatePoint":{"line":149,"column":61},"line":149,"code":"  it('--rolled-back works if migration is already rolled back', async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const result = MigrateResolve.new().parse(['--rolled-back', '20201106130852_failed'])\n    await expect(result).resolves.toMatchInlineSnapshot(`Migration 20201231000000_failed marked as rolled back.`)\n\n    // Try again\n    const result2 = MigrateResolve.new().parse(['--rolled-back', '20201106130852_failed'])\n    await expect(result2).resolves.toMatchInlineSnapshot(`Migration 20201231000000_failed marked as rolled back.`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no db - invalid url","suites":["postgresql"],"updatePoint":{"line":170,"column":40},"line":170,"code":"  it('should fail if no db - invalid url', async () => {\n    ctx.fixture('schema-only-postgresql')\n    jest.setTimeout(10_000)\n\n    const result = MigrateResolve.new().parse(['--schema=./prisma/invalid-url.prisma', '--applied=something_applied'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            P1001: Can't reach database server at \\`doesnotexist\\`:\\`5432\\`\n\n            Please make sure your database server is running at \\`doesnotexist\\`:\\`5432\\`.\n          `)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/invalid-url.prisma\n      Datasource \"my_db\": PostgreSQL database \"mydb\", schema \"public\" at \"doesnotexist:5432\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  })","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no db - invalid url","suites":["postgresql"],"updatePoint":{"line":194,"column":40},"line":194,"code":"  it('should fail if no db - invalid url', async () => {\n    ctx.fixture('schema-only-cockroachdb')\n\n    const result = MigrateResolve.new().parse(['--schema=./prisma/invalid-url.prisma', '--applied=something_applied'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            P1001: Can't reach database server at \\`something.cockroachlabs.cloud\\`:\\`26257\\`\n\n            Please make sure your database server is running at \\`something.cockroachlabs.cloud\\`:\\`26257\\`.\n          `)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/invalid-url.prisma\n      Datasource \"db\": CockroachDB database \"clustername.defaultdb\", schema \"public\" at \"something.cockroachlabs.cloud:26257\"\n    `)\n\n    expect(ctx.mocked['console.log'].mock.calls).toEqual([])\n    expect(ctx.mocked['console.error'].mock.calls).toEqual([])\n  }, 10_000)","file":"MigrateResolve.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no schema file","suites":["common"],"updatePoint":{"line":8,"column":35},"line":8,"code":"  it('should fail if no schema file', async () => {\n    ctx.fixture('empty')\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Could not find a schema.prisma file that is required for this command.\n            You can either provide it with --schema, set it as \\`prisma.schema\\` in your package.json or put it into the default location ./prisma/schema.prisma https://pris.ly/d/prisma-schema-location\n          `)\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if experimental flag","suites":["common"],"updatePoint":{"line":16,"column":38},"line":16,"code":"  it('should fail if experimental flag', async () => {\n    ctx.fixture('empty')\n    const result = MigrateStatus.new().parse(['--experimental'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Prisma Migrate was Experimental and is now Generally Available.\n            WARNING this new version has some breaking changes to use it it's recommended to read the documentation first and remove the --experimental flag.\n          `)\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if early access flag","suites":["common"],"updatePoint":{"line":24,"column":38},"line":24,"code":"  it('should fail if early access flag', async () => {\n    ctx.fixture('empty')\n    const result = MigrateStatus.new().parse(['--early-access-feature'])\n    await expect(result).rejects.toThrowErrorMatchingInlineSnapshot(`\n            Prisma Migrate was in Early Access and is now Generally Available.\n            Remove the --early-access-feature flag.\n          `)\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if no sqlite db - empty schema","suites":["sqlite"],"updatePoint":{"line":35,"column":48},"line":35,"code":"  it('should fail if no sqlite db - empty schema', async () => {\n    ctx.fixture('schema-only-sqlite')\n    const result = MigrateStatus.new().parse(['--schema=./prisma/empty.prisma'])\n    await expect(result).rejects.toMatchInlineSnapshot(`P1003: Database dev.db does not exist at dev.db`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/empty.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchSnapshot()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-1-failed-migration","suites":["sqlite"],"updatePoint":{"line":48,"column":36},"line":48,"code":"  it('existing-db-1-failed-migration', async () => {\n    ctx.fixture('existing-db-1-failed-migration')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      1 migration found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Following migration have failed:\n      20201231000000_failed\n\n      During development if the failed migration(s) have not been deployed to a production database you can then fix the migration(s) and run prisma migrate dev.\n\n      The failed migration(s) can be marked as rolled back or applied:\n            \n      - If you rolled back the migration(s) manually:\n      prisma migrate resolve --rolled-back \"20201231000000_failed\"\n\n      - If you fixed the database manually (hotfix):\n      prisma migrate resolve --applied \"20201231000000_failed\"\n\n      Read more about how to resolve migration issues in a production database:\n      https://pris.ly/d/migrate-resolve\n    `)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should error when database needs to be baselined","suites":["sqlite"],"updatePoint":{"line":85,"column":54},"line":85,"code":"  it('should error when database needs to be baselined', async () => {\n    ctx.fixture('baseline-sqlite')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse(['--schema=./prisma/using-file-as-url.prisma'])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/using-file-as-url.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:./dev.db\"\n      No migration found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      The current database is not managed by Prisma Migrate.\n              \n      Read more about how to baseline an existing production database:\n      https://pris.ly/d/migrate-baseline\n    `)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-1-migration","suites":["sqlite"],"updatePoint":{"line":111,"column":29},"line":111,"code":"  it('existing-db-1-migration', async () => {\n    ctx.fixture('existing-db-1-migration')\n    const result = MigrateStatus.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(`Database schema is up to date!`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      1 migration found in prisma/migrations\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchSnapshot()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-1-migration-conflict","suites":["sqlite"],"updatePoint":{"line":127,"column":38},"line":127,"code":"  it('existing-db-1-migration-conflict', async () => {\n    ctx.fixture('existing-db-1-migration-conflict')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      1 migration found in prisma/migrations\n\n      Following migration have not yet been applied:\n      20201231000000_init\n\n      To apply migrations in development run prisma migrate dev.\n      To apply migrations in production run prisma migrate deploy.\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(``)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-brownfield","suites":["sqlite"],"updatePoint":{"line":153,"column":28},"line":153,"code":"  it('existing-db-brownfield', async () => {\n    ctx.fixture('existing-db-brownfield')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      No migration found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      The current database is not managed by Prisma Migrate.\n              \n      Read more about how to baseline an existing production database:\n      https://pris.ly/d/migrate-baseline\n    `)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-warnings","suites":["sqlite"],"updatePoint":{"line":179,"column":26},"line":179,"code":"  it('existing-db-warnings', async () => {\n    ctx.fixture('existing-db-warnings')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      No migration found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      The current database is not managed by Prisma Migrate.\n              \n      Read more about how to baseline an existing production database:\n      https://pris.ly/d/migrate-baseline\n    `)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"old-migrate","suites":["sqlite"],"updatePoint":{"line":205,"column":17},"line":205,"code":"  it('old-migrate', async () => {\n    ctx.fixture('old-migrate')\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n            The migrations folder contains migration files from an older version of Prisma Migrate which is not compatible.\n\n            Read more about how to upgrade to the new version of Migrate:\n            https://pris.ly/d/migrate-upgrade\n          `)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchSnapshot()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"reset","suites":["sqlite"],"updatePoint":{"line":223,"column":11},"line":223,"code":"  it('reset', async () => {\n    ctx.fixture('reset')\n    const result = MigrateStatus.new().parse([])\n    await expect(result).resolves.toMatchInlineSnapshot(`Database schema is up to date!`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      1 migration found in prisma/migrations\n\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchSnapshot()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"existing-db-histories-diverge","suites":["sqlite"],"updatePoint":{"line":239,"column":35},"line":239,"code":"  it('existing-db-histories-diverge', async () => {\n    ctx.fixture('existing-db-histories-diverge')\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => {\n      throw new Error('process.exit: ' + number)\n    })\n\n    const result = MigrateStatus.new().parse([])\n    await expect(result).rejects.toMatchInlineSnapshot(`process.exit: 1`)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Prisma schema loaded from prisma/schema.prisma\n      Datasource \"my_db\": SQLite database \"dev.db\" at \"file:dev.db\"\n      2 migrations found in prisma/migrations\n\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Your local migration history and the migrations table from your database are different:\n\n      The last common migration is: 20201231000000_init\n\n      The migration have not yet been applied:\n      20201231000000_catage\n\n      The migration from the database are not found locally in prisma/migrations:\n      20201231000000_dogage\n    `)\n    expect(mockExit).toHaveBeenCalledWith(1)\n    mockExit.mockRestore()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"should fail if cannot connect","suites":["postgresql"],"updatePoint":{"line":272,"column":35},"line":272,"code":"  it('should fail if cannot connect', async () => {\n    ctx.fixture('schema-only-postgresql')\n    const result = MigrateStatus.new().parse(['--schema=./prisma/invalid-url.prisma'])\n    await expect(result).rejects.toMatchInlineSnapshot(`\n      P1001: Can't reach database server at \\`doesnotexist\\`:\\`5432\\`\n\n      Please make sure your database server is running at \\`doesnotexist\\`:\\`5432\\`.\n    `)\n\n    expect(ctx.mocked['console.info'].mock.calls.join('\\n')).toMatchInlineSnapshot(`\n      Environment variables loaded from prisma/.env\n      Prisma schema loaded from prisma/invalid-url.prisma\n      Datasource \"my_db\": PostgreSQL database \"mydb\", schema \"public\" at \"doesnotexist:5432\"\n    `)\n    expect(ctx.mocked['console.log'].mock.calls.join('\\n')).toMatchSnapshot()\n    expect(ctx.mocked['console.error'].mock.calls.join('\\n')).toMatchSnapshot()\n  })","file":"MigrateStatus.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"simple schema","suites":[],"updatePoint":{"line":3,"column":19},"line":3,"code":"test('simple schema', () => {\n  const schema = `\ndatasource db {\n  provider = \"sqlite\"\n  url = \"file:dev.db\"\n}\n\n\ngenerator gen {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id   Int @id @default(autoincrement())\n  name String\n}\n`\n  expect(removeDatasource(schema)).toMatchInlineSnapshot(`\n    generator gen {\n      provider = \"prisma-client-js\"\n    }\n\n    model User {\n      id   Int @id @default(autoincrement())\n      name String\n    }\n  `)\n})","file":"removeDatasource.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"comments","suites":[],"updatePoint":{"line":32,"column":14},"line":32,"code":"test('comments', () => {\n  const schema = `\ndatasource db {\n// datasource db {\n  provider = \"sqlite\"\n  // provider = \"sqlite\"\n  url = \"file:dev.db\"\n}\n\n\ngenerator gen {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id   Int @id @default(autoincrement())\n  name String\n}\n`\n  expect(removeDatasource(schema)).toMatchInlineSnapshot(`\n    generator gen {\n      provider = \"prisma-client-js\"\n    }\n\n    model User {\n      id   Int @id @default(autoincrement())\n      name String\n    }\n  `)\n})","file":"removeDatasource.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema without datasource","suites":[],"updatePoint":{"line":63,"column":31},"line":63,"code":"test('schema without datasource', () => {\n  const schema = `\n\ngenerator gen {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id   Int @id @default(autoincrement())\n  name String\n}\n`\n  expect(removeDatasource(schema)).toMatchInlineSnapshot(`\n    generator gen {\n      provider = \"prisma-client-js\"\n    }\n\n    model User {\n      id   Int @id @default(autoincrement())\n      name String\n    }\n  `)\n})","file":"removeDatasource.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schema with multiple datasources","suites":[],"updatePoint":{"line":87,"column":38},"line":87,"code":"test('schema with multiple datasources', () => {\n  const schema = `\ndatasource db {\n  provider = \"sqlite\"\n  url = \"file:dev.db\"\n}\n\ndatasource db2 {\n  provider = \"sqlite\"\n  url = \"file:dev.db\"\n}\n\n\ngenerator gen {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id   Int @id @default(autoincrement())\n  name String\n}\n`\n  expect(removeDatasource(schema)).toMatchInlineSnapshot(`\n    generator gen {\n      provider = \"prisma-client-js\"\n    }\n\n    model User {\n      id   Int @id @default(autoincrement())\n      name String\n    }\n  `)\n})","file":"removeDatasource.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"getDatabaseVersion","suites":[],"updatePoint":{"line":9,"column":22},"line":9,"code":"it('getDatabaseVersion', async () => {\n  ctx.fixture('schema-only')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const result = migrate.engine.getDatabaseVersion()\n  await expect(result).resolves.toContain('PostgreSQL')\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"evaluateDataLoss - schema-only-sqlite","suites":[],"updatePoint":{"line":19,"column":41},"line":19,"code":"it('evaluateDataLoss - schema-only-sqlite', async () => {\n  ctx.fixture('schema-only-sqlite')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const schema = migrate.getPrismaSchema()\n  const result = migrate.engine.evaluateDataLoss({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    prismaSchema: schema,\n  })\n\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            migrationSteps: 1,\n            unexecutableSteps: Array [],\n            warnings: Array [],\n          }\n        `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"evaluateDataLoss - existing-db-1-migration","suites":[],"updatePoint":{"line":40,"column":46},"line":40,"code":"it('evaluateDataLoss - existing-db-1-migration', async () => {\n  ctx.fixture('existing-db-1-migration')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const schema = migrate.getPrismaSchema()\n  const result = migrate.engine.evaluateDataLoss({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    prismaSchema: schema,\n  })\n\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            migrationSteps: 0,\n            unexecutableSteps: Array [],\n            warnings: Array [],\n          }\n        `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"createMigration - existing-db-1-migration","suites":[],"updatePoint":{"line":60,"column":45},"line":60,"code":"it('createMigration - existing-db-1-migration', async () => {\n  ctx.fixture('schema-only-sqlite')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const schema = migrate.getPrismaSchema()\n  const result = migrate.engine.createMigration({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    migrationName: 'my_migration',\n    draft: false,\n    prismaSchema: schema,\n  })\n\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            generatedMigrationName: 20201231000000_my_migration,\n          }\n        `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"createMigration draft - existing-db-1-migration","suites":[],"updatePoint":{"line":80,"column":51},"line":80,"code":"it('createMigration draft - existing-db-1-migration', async () => {\n  ctx.fixture('existing-db-1-migration')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const schema = migrate.getPrismaSchema()\n  const result = migrate.engine.createMigration({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    migrationName: 'draft_123',\n    draft: true,\n    prismaSchema: schema,\n  })\n\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            generatedMigrationName: 20201231000000_draft_123,\n          }\n        `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"diagnoseMigrationHistory - optInToShadowDatabase true - existing-db-1-migration","suites":[],"updatePoint":{"line":100,"column":83},"line":100,"code":"it('diagnoseMigrationHistory - optInToShadowDatabase true - existing-db-1-migration', async () => {\n  ctx.fixture('existing-db-1-migration')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const result = migrate.engine.diagnoseMigrationHistory({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    optInToShadowDatabase: true,\n  })\n\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            editedMigrationNames: Array [],\n            failedMigrationNames: Array [],\n            hasMigrationsTable: true,\n            history: null,\n          }\n        `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"diagnoseMigrationHistory - optInToShadowDatabase false - existing-db-1-migration","suites":[],"updatePoint":{"line":120,"column":84},"line":120,"code":"it('diagnoseMigrationHistory - optInToShadowDatabase false - existing-db-1-migration', async () => {\n  ctx.fixture('existing-db-1-migration')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const result = migrate.engine.diagnoseMigrationHistory({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    optInToShadowDatabase: false,\n  })\n\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            editedMigrationNames: Array [],\n            failedMigrationNames: Array [],\n            hasMigrationsTable: true,\n            history: null,\n          }\n        `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"applyMigrations","suites":[],"updatePoint":{"line":140,"column":19},"line":140,"code":"it('applyMigrations', async () => {\n  ctx.fixture('existing-db-1-migration')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const result = migrate.engine.applyMigrations({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n  })\n\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            appliedMigrationNames: Array [],\n          }\n        `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"applyMigrations - should fail on existing brownfield db","suites":[],"updatePoint":{"line":156,"column":59},"line":156,"code":"it('applyMigrations - should fail on existing brownfield db', async () => {\n  ctx.fixture('existing-db-brownfield')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const result = migrate.engine.applyMigrations({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n  })\n\n  await expect(result).rejects.toMatchInlineSnapshot(`\n          P3005\n\n          The database schema is not empty. Read more about how to baseline an existing production database: https://pris.ly/d/migrate-baseline\n\n        `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schemaPush should throw if SQLite database file is missing","suites":[],"updatePoint":{"line":174,"column":62},"line":174,"code":"it('schemaPush should throw if SQLite database file is missing', async () => {\n  ctx.fixture('schema-only-sqlite')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const schema = migrate.getPrismaSchema()\n  const result = migrate.engine.schemaPush({\n    force: false,\n    schema: schema,\n  })\n\n  await expect(result).rejects.toMatchInlineSnapshot(`\n    P1003\n\n    Database dev.db does not exist at dev.db\n\n  `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schemaPush should succeed without warning","suites":[],"updatePoint":{"line":193,"column":45},"line":193,"code":"it('schemaPush should succeed without warning', async () => {\n  ctx.fixture('existing-db-1-draft')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const schema = migrate.getPrismaSchema()\n  const result = migrate.engine.schemaPush({\n    force: false,\n    schema: schema,\n  })\n\n  await expect(result).resolves.toMatchInlineSnapshot(`\n    Object {\n      executedSteps: 1,\n      unexecutable: Array [],\n      warnings: Array [],\n    }\n  `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schemaPush should return executedSteps 0 with warning if dataloss detected","suites":[],"updatePoint":{"line":213,"column":78},"line":213,"code":"it('schemaPush should return executedSteps 0 with warning if dataloss detected', async () => {\n  ctx.fixture('existing-db-brownfield')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const schema = migrate.getPrismaSchema()\n\n  const result = migrate.engine.schemaPush({\n    force: false,\n    schema: schema.replace('Blog', 'Something'),\n  })\n\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            executedSteps: 0,\n            unexecutable: Array [],\n            warnings: Array [\n              You are about to drop the \\`Blog\\` table, which is not empty (1 rows).,\n            ],\n          }\n        `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"schemaPush force should accept dataloss","suites":[],"updatePoint":{"line":236,"column":43},"line":236,"code":"it('schemaPush force should accept dataloss', async () => {\n  ctx.fixture('existing-db-brownfield')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const schema = migrate.getPrismaSchema()\n\n  const result = migrate.engine.schemaPush({\n    force: true,\n    schema: schema.replace('Blog', 'Something'),\n  })\n\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            executedSteps: 2,\n            unexecutable: Array [],\n            warnings: Array [\n              You are about to drop the \\`Blog\\` table, which is not empty (1 rows).,\n            ],\n          }\n        `)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"markMigrationRolledBack - should fail - existing-db-1-migration","suites":[],"updatePoint":{"line":259,"column":67},"line":259,"code":"it('markMigrationRolledBack - should fail - existing-db-1-migration', async () => {\n  jest.setTimeout(10_000)\n  ctx.fixture('existing-db-1-migration')\n\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n\n  const resultMarkRolledBacked = migrate.engine.markMigrationRolledBack({\n    migrationName: '20201014154943_init',\n  })\n\n  await expect(resultMarkRolledBacked).rejects.toMatchInlineSnapshot(`\n          P3012\n\n          Migration \\`20201231000000_init\\` cannot be rolled back because it is not in a failed state.\n\n        `)\n\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"markMigrationRolledBack - existing-db-1-migration","suites":[],"updatePoint":{"line":280,"column":53},"line":280,"code":"it('markMigrationRolledBack - existing-db-1-migration', async () => {\n  ctx.fixture('existing-db-1-migration')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const schema = migrate.getPrismaSchema()\n  const result = await migrate.engine.createMigration({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    migrationName: 'draft_123',\n    draft: true,\n    prismaSchema: schema,\n  })\n\n  expect(result).toMatchInlineSnapshot(`\n          Object {\n            generatedMigrationName: 20201231000000_draft_123,\n          }\n        `)\n\n  fs.write(\n    path.join(migrate.migrationsDirectoryPath!, result.generatedMigrationName!, 'migration.sql'),\n    'SELECT SOMETHING_THAT_DOES_NOT_WORK',\n  )\n\n  try {\n    await migrate.engine.applyMigrations({\n      migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    })\n  } catch (e) {\n    expect(e.message).toContain('no such column: SOMETHING_THAT_DOES_NOT_WORK')\n  }\n\n  const resultMarkRolledBacked = migrate.engine.markMigrationRolledBack({\n    migrationName: result.generatedMigrationName!,\n  })\n\n  await expect(resultMarkRolledBacked).resolves.toMatchSnapshot()\n\n  const resultMarkAppliedFailed = migrate.engine.markMigrationApplied({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    migrationName: result.generatedMigrationName!,\n  })\n\n  await expect(resultMarkAppliedFailed).resolves.toMatchSnapshot()\n\n  const resultMarkApplied = migrate.engine.markMigrationApplied({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    migrationName: result.generatedMigrationName!,\n  })\n\n  await expect(resultMarkApplied).rejects.toMatchInlineSnapshot(`\n          P3008\n\n          The migration \\`20201231000000_draft_123\\` is already recorded as applied in the database.\n\n        `)\n\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"markMigrationApplied - existing-db-1-migration","suites":[],"updatePoint":{"line":339,"column":50},"line":339,"code":"it('markMigrationApplied - existing-db-1-migration', async () => {\n  ctx.fixture('existing-db-1-migration')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const schema = migrate.getPrismaSchema()\n  const result = await migrate.engine.createMigration({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    migrationName: 'draft_123',\n    draft: true,\n    prismaSchema: schema,\n  })\n\n  expect(result).toMatchInlineSnapshot(`\n          Object {\n            generatedMigrationName: 20201231000000_draft_123,\n          }\n        `)\n\n  const resultMarkApplied = migrate.engine.markMigrationApplied({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n    migrationName: result.generatedMigrationName!,\n  })\n\n  await expect(resultMarkApplied).resolves.toMatchInlineSnapshot(`Object {}`)\n\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"listMigrationDirectories - existing-db-1-migration","suites":[],"updatePoint":{"line":367,"column":54},"line":367,"code":"it('listMigrationDirectories - existing-db-1-migration', async () => {\n  ctx.fixture('existing-db-1-migration')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const result = migrate.engine.listMigrationDirectories({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n  })\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            migrations: Array [\n              20201231000000_init,\n            ],\n          }\n        `)\n\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"listMigrationDirectories - schema-only-sqlite","suites":[],"updatePoint":{"line":385,"column":49},"line":385,"code":"it('listMigrationDirectories - schema-only-sqlite', async () => {\n  ctx.fixture('schema-only-sqlite')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const result = migrate.engine.listMigrationDirectories({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n  })\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            migrations: Array [],\n          }\n        `)\n\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"devDiagnostic - createMigration","suites":[],"updatePoint":{"line":401,"column":35},"line":401,"code":"it('devDiagnostic - createMigration', async () => {\n  ctx.fixture('schema-only-sqlite')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const result = migrate.engine.devDiagnostic({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n  })\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            action: Object {\n              tag: createMigration,\n            },\n          }\n        `)\n\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"devDiagnostic - reset because drift","suites":[],"updatePoint":{"line":419,"column":39},"line":419,"code":"it('devDiagnostic - reset because drift', async () => {\n  ctx.fixture('existing-db-1-migration-conflict')\n  const schemaPath = (await getSchemaPath())!\n  const migrate = new Migrate(schemaPath)\n  const result = migrate.engine.devDiagnostic({\n    migrationsDirectoryPath: migrate.migrationsDirectoryPath!,\n  })\n  await expect(result).resolves.toMatchInlineSnapshot(`\n          Object {\n            action: Object {\n              reason: Drift detected: Your database schema is not in sync with your migration history.\n\n          The following is a summary of the differences between the expected database schema given your migrations files, and the actual schema of the database.\n\n          It should be understood as the set of changes to get from the expected schema to the actual schema.\n\n          If you are running this the first time on an existing database, please make sure to read this documentation page:\n          https://www.prisma.io/docs/guides/database/developing-with-prisma-migrate/troubleshooting-development\n\n          [+] Added tables\n            - Blog\n            - _Migration\n          ,\n              tag: reset,\n            },\n          }\n        `)\n\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"},{"name":"dbExecute - sqlite","suites":[],"updatePoint":{"line":450,"column":22},"line":450,"code":"it('dbExecute - sqlite', async () => {\n  ctx.fixture('schema-only-sqlite')\n  const migrate = new Migrate()\n  const result = migrate.engine.dbExecute({\n    datasourceType: {\n      tag: 'url',\n      url: 'file:dev.db',\n    },\n    script: `-- CreateTable\n    SELECT 1\n    `,\n  })\n\n  await expect(result).resolves.toMatchInlineSnapshot(`null`)\n  migrate.stop()\n})","file":"rpc.test.ts","skipped":false,"dir":"packages/migrate/src/__tests__"}]}